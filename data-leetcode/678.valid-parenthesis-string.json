[
    {
        "title": "Number of 1 Bits",
        "question_content": "Write a function that takes&nbsp;the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).\nNote:\n\n\tNote that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n\tIn Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.\n\n&nbsp;\nExample 1:\n\nInput: n = 00000000000000000000000000001011\nOutput: 3\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.\n\nExample 2:\n\nInput: n = 00000000000000000000000010000000\nOutput: 1\nExplanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.\n\nExample 3:\n\nInput: n = 11111111111111111111111111111101\nOutput: 31\nExplanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.\n\n&nbsp;\nConstraints:\n\n\tThe input must be a binary string of length 32.\n\n&nbsp;\nFollow up: If this function is called many times, how would you optimize it?",
        "solutions": [
            {
                "id": 55099,
                "title": "simple-java-solution-bit-shifting",
                "content": "```\\npublic static int hammingWeight(int n) {\\n\\tint ones = 0;\\n    \\twhile(n!=0) {\\n    \\t\\tones = ones + (n & 1);\\n    \\t\\tn = n>>>1;\\n    \\t}\\n    \\treturn ones;\\n}\\n```\\n - An Integer in Java has 32 bits, e.g. 00101000011110010100001000011010.\\n - To count the 1s in the Integer representation we put the input int\\n   n in bit AND with 1 (that is represented as\\n   00000000000000000000000000000001, and if this operation result is 1,\\n   that means that the last bit of the input integer is 1. Thus we add it to the 1s count.\\n\\n> ones = ones + (n & 1);\\n\\n - Then we shift the input Integer by one on the right, to check for the\\n   next bit.\\n\\n> n = n>>>1;\\n\\nWe need to use bit shifting unsigned operation **>>>** (while **>>** depends on sign extension)\\n\\n - We keep doing this until the input Integer is 0.\\n\\nIn Java we need to put attention on the fact that the maximum integer is 2147483647. Integer type in Java is signed and there is no unsigned int. So the input 2147483648 is represented in Java as -2147483648 (in java int type has a cyclic representation, that means **Integer.MAX_VALUE+1==Integer.MIN_VALUE**).\\nThis force us to use \\n\\n> n!=0\\n\\n in the while condition and we cannot use \\n\\n> n>0\\n\\nbecause the input 2147483648 would correspond to -2147483648 in java and the code would not enter the while if the condition is n>0 for n=2147483648.",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic static int hammingWeight(int n) {\\n\\tint ones = 0;\\n    \\twhile(n!=0) {\\n    \\t\\tones = ones + (n & 1);\\n    \\t\\tn = n>>>1;\\n    \\t}\\n    \\treturn ones;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55255,
                "title": "c-solution-n-n-1",
                "content": "    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        \\n        while (n) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n\\nn & (n - 1) drops the lowest set bit. It's a neat little bit trick.\\n\\nLet's use n = 00101100 as an example. This binary representation has three 1s.\\n\\nIf n = 00101100, then n - 1 = 00101011, so n & (n - 1) = 00101100 & 00101011 = 00101000. Count = 1.\\n\\nIf n = 00101000, then n - 1 = 00100111, so n & (n - 1) = 00101000 & 00100111 = 00100000. Count = 2.\\n\\nIf n = 00100000, then n - 1 = 00011111, so n & (n - 1) = 00100000 & 00011111 = 00000000. Count = 3.\\n\\nn is now zero, so the while loop ends, and the final count (the numbers of set bits) is returned.",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        \\n        while (n) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n\\nn & (n - 1) drops the lowest set bit. It's a neat little bit trick.\\n\\nLet's use n = 00101100 as an example. This binary representation has three 1s.\\n\\nIf n = 00101100, then n - 1 = 00101011, so n & (n - 1) = 00101100 & 00101011 = 00101000. Count = 1.\\n\\nIf n = 00101000, then n - 1 = 00100111, so n & (n - 1) = 00101000 & 00100111 = 00100000. Count = 2.\\n\\nIf n = 00100000, then n - 1 = 00011111, so n & (n - 1) = 00100000 & 00011111 = 00000000. Count = 3.\\n\\nn is now zero, so the while loop ends, and the final count (the numbers of set bits) is returned.",
                "codeTag": "Unknown"
            },
            {
                "id": 1044775,
                "title": "python-n-n-1-trick-even-faster-explained",
                "content": "There are a lot of different ways to solve this problem, starting from transforming number to string and count number of ones. However there is a classical bit manipulation trick you should think about when you have bits problem.\\n\\nIf we have number `n`, then `n&(n-1)` **will remove the rightmost** in binary representation of `n`. For example if `n = 10110100`, then `n & (n-1) = 10110100 & 10110011 = 10110000`, where `&` means bitwize operation and. Very convinient, is it not? What we need to do now, just repeat this operation until we have `n = 0` and count number of steps.\\n\\n**Complexity** It is `O(1)` for sure, because we need to make no more than `32` operations here, but it is quite vague: all methods will be `O(1)`, why this one is better than others? In fact it has complexity `O(m)`, where `m` is number of `1`-bits in our number. In average it will be `16` bits, so it is more like `16` operations, not `32` here, which gives us 2-times gain. Space complexity is `O(1)`\\n\\n```\\nclass Solution:\\n    def hammingWeight(self, n):\\n        ans = 0\\n        while n:\\n            n &= (n-1)\\n            ans += 1\\n        return ans\\n```\\n\\n## just 5 operations\\nYou can stop on previous solution and interviewer will be OK with that. But if you show him the following solution, he will be really happy. Let us understand what is going on in the following code.\\n\\n1. First of all `0x55555555 = 01010101010101010101010101010101` in binary representation, so first step will deal with even and odd bits. What happens after first line of code computed: it will count number of non-zero bits in each pair. For simplicity imagine just first `8` bits with constant `0x55 = 01010101` and choose `n = 11000110`, then we have is `10 00 01 01`. Why? We have `2`, that is `10` ones in first pair, than we have `0` ones, than we have `1` one and finally we also have `1`.\\n2. Now, to the second step, we have `0x33333333 = 110011001100110011001100110011`. Again let us look at only first `8` bit, that is to `11001100`. What will happend after this step, number of non-zero bits in groups of `4` will be computed. We stopped on number `10 00 01 01`, now we have `0010 0010`, because there is `2 + 0` ones in first group and `1+1` ones in second group.\\n3. Next step is `0x0f0f0f0f = 1111000011110000111100001111` and we working with groups of `8`, so for our example we will have `00000100`, because we have `2` ones in each group.\\n\\n**Complexity**: we have only `5` iterations for `int32` number, it will be `6` for `int64`, `7` for `int128` and so on. For `int32` there will be not increase of speed, because even though it is `5` operations, each of them consists of several small steps, but for `int64` you can fill the difference. Space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def hammingWeight(self, n):\\n        n = (n & (0x55555555)) + ((n >> 1) & (0x55555555))\\n        n = (n & (0x33333333)) + ((n >> 2) & (0x33333333))\\n        n = (n & (0x0f0f0f0f)) + ((n >> 4) & (0x0f0f0f0f))\\n        n = (n & (0x00ff00ff)) + ((n >> 8) & (0x00ff00ff))\\n        n = (n & (0x0000ffff)) + ((n >> 16) & (0x0000ffff))\\n        return n\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n):\\n        ans = 0\\n        while n:\\n            n &= (n-1)\\n            ans += 1\\n        return ans\\n```\n```\\nclass Solution:\\n    def hammingWeight(self, n):\\n        n = (n & (0x55555555)) + ((n >> 1) & (0x55555555))\\n        n = (n & (0x33333333)) + ((n >> 2) & (0x33333333))\\n        n = (n & (0x0f0f0f0f)) + ((n >> 4) & (0x0f0f0f0f))\\n        n = (n & (0x00ff00ff)) + ((n >> 8) & (0x00ff00ff))\\n        n = (n & (0x0000ffff)) + ((n >> 16) & (0x0000ffff))\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55106,
                "title": "python-2-solutions-one-naive-solution-with-built-in-functions-one-trick-with-bit-operation",
                "content": "1.Built in solution with built-in function:\\n\\n    def hammingWeight(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return bin(n).count(\\'1\\')\\n\\n2.Using bit operation to cancel a `1` in each round\\n\\nThink of a number in binary `n = XXXXXX1000`, `n - 1 is XXXXXX0111`. `n & (n - 1)` will be `XXXXXX0000` which is just remove the last significant  `1`\\n\\n    def hammingWeight(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        c = 0\\n        while n:\\n            n &= n - 1\\n            c += 1\\n        return c",
                "solutionTags": [],
                "code": "1.Built in solution with built-in function:\\n\\n    def hammingWeight(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return bin(n).count(\\'1\\')\\n\\n2.Using bit operation to cancel a `1` in each round\\n\\nThink of a number in binary `n = XXXXXX1000`, `n - 1 is XXXXXX0111`. `n & (n - 1)` will be `XXXXXX0000` which is just remove the last significant  `1`\\n\\n    def hammingWeight(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        c = 0\\n        while n:\\n            n &= n - 1\\n            c += 1\\n        return c",
                "codeTag": "Python3"
            },
            {
                "id": 1044799,
                "title": "c-bit-manipulation-4-approaches-beats-100-0ms-o-1",
                "content": "**Approach 1**\\nIterate the bits of an unsigned integer from right by using **right shift**, and at each iteration check the parity of the first bit from right.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;  // count of set bit\\n        while(n>0){  // iterate until all bits are traversed\\n            if((n&1)>0) // check the parity of first bit from right\\n                ++cnt;\\n            n=n>>1; //n=n/2, shift one bit to right\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n**Approach 2**\\nMore **optimized** solution, no. of iteration will be equal to no. of set bits.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;  // count of set bit\\n        while(n>0){  // iterate until all bits are traversed\\n\\t\\t\\t++cnt;\\n            n=n&(n-1); // change the first set bit from right to 0\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n**Approach 3**\\nUsing inbuilt function **__builtin_popcount** for counting set bits\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return __builtin_popcount(n);\\n    }\\n};\\n```\\n\\n**Approach 4**\\nUsing inbuilt function **bitset**.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return bitset<32>(n).count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;  // count of set bit\\n        while(n>0){  // iterate until all bits are traversed\\n            if((n&1)>0) // check the parity of first bit from right\\n                ++cnt;\\n            n=n>>1; //n=n/2, shift one bit to right\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;  // count of set bit\\n        while(n>0){  // iterate until all bits are traversed\\n\\t\\t\\t++cnt;\\n            n=n&(n-1); // change the first set bit from right to 0\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return __builtin_popcount(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return bitset<32>(n).count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229926,
                "title": "best-c-3-solution-easy-solution-bit-manipulation-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Bit Manipulation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(1).\\n    \\n    Solved using Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while(n != 0){\\n            count += (n%2);\\n            n >>= 1;\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(1).\\n    \\n    Solved using Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while(n != 0){\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(1).\\n    \\n    Solved using Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while(n != 0){\\n            int rmsb = n & -n;\\n            n -= rmsb;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(1).\\n    \\n    Solved using Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while(n != 0){\\n            count += (n%2);\\n            n >>= 1;\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(1).\\n    \\n    Solved using Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while(n != 0){\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(1).\\n    \\n    Solved using Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while(n != 0){\\n            int rmsb = n & -n;\\n            n -= rmsb;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55120,
                "title": "short-code-of-c-o-m-by-time-m-is-the-count-of-1-s-and-another-several-method-of-o-1-time",
                "content": "Each time of \"n &= n - 1\", we delete one '1' from n.\\n\\n    int hammingWeight(uint32_t n)\\n    {\\n        int res = 0;\\n        while(n)\\n        {\\n            n &= n - 1;\\n            ++ res;\\n        }\\n        return res;\\n    }\\n\\nAnother several method of O(1) time.\\n\\nAdd 1 by Tree:\\n\\n    // This is a naive implementation, shown for comparison, and to help in understanding the better functions. \\n    // It uses 24 arithmetic operations (shift, add, and).\\n    int hammingWeight(uint32_t n)\\n    {\\n        n = (n & 0x55555555) + (n >>  1 & 0x55555555); // put count of each  2 bits into those  2 bits \\n        n = (n & 0x33333333) + (n >>  2 & 0x33333333); // put count of each  4 bits into those  4 bits \\n        n = (n & 0x0F0F0F0F) + (n >>  4 & 0x0F0F0F0F); // put count of each  8 bits into those  8 bits \\n        n = (n & 0x00FF00FF) + (n >>  8 & 0x00FF00FF); // put count of each 16 bits into those 16 bits \\n        n = (n & 0x0000FFFF) + (n >> 16 & 0x0000FFFF); // put count of each 32 bits into those 32 bits \\n        return n;\\n    }\\n\\n    // This uses fewer arithmetic operations than any other known implementation on machines with slow multiplication.\\n    // It uses 17 arithmetic operations.\\n    int hammingWeight(uint32_t n)\\n    {\\n        n -= (n >> 1) & 0x55555555; //put count of each 2 bits into those 2 bits\\n        n = (n & 0x33333333) + (n >> 2 & 0x33333333); //put count of each 4 bits into those 4 bits\\n        n = (n + (n >> 4)) & 0x0F0F0F0F; //put count of each 8 bits into those 8 bits\\n        n += n >> 8; // put count of each 16 bits into those 8 bits\\n        n += n >> 16; // put count of each 32 bits into those 8 bits\\n        return n & 0xFF;\\n    }\\n\\n    // This uses fewer arithmetic operations than any other known implementation on machines with fast multiplication.\\n    // It uses 12 arithmetic operations, one of which is a multiply.\\n    int hammingWeight(uint32_t n)\\n    {\\n        n -= (n >> 1) & 0x55555555; // put count of each 2 bits into those 2 bits\\n        n = (n & 0x33333333) + (n >> 2 & 0x33333333); // put count of each 4 bits into those 4 bits\\n        n = (n + (n >> 4)) & 0x0F0F0F0F; // put count of each 8 bits into those 8 bits \\n        return n * 0x01010101 >> 24; // returns left 8 bits of x + (x<<8) + (x<<16) + (x<<24)\\n    }\\n\\n\\u2014\\u2014From Wikipedia.",
                "solutionTags": [],
                "code": "Each time of \"n &= n - 1\", we delete one '1' from n.\\n\\n    int hammingWeight(uint32_t n)\\n    {\\n        int res = 0;\\n        while(n)\\n        {\\n            n &= n - 1;\\n            ++ res;\\n        }\\n        return res;\\n    }\\n\\nAnother several method of O(1) time.\\n\\nAdd 1 by Tree:\\n\\n    // This is a naive implementation, shown for comparison, and to help in understanding the better functions. \\n    // It uses 24 arithmetic operations (shift, add, and).\\n    int hammingWeight(uint32_t n)\\n    {\\n        n = (n & 0x55555555) + (n >>  1 & 0x55555555); // put count of each  2 bits into those  2 bits \\n        n = (n & 0x33333333) + (n >>  2 & 0x33333333); // put count of each  4 bits into those  4 bits \\n        n = (n & 0x0F0F0F0F) + (n >>  4 & 0x0F0F0F0F); // put count of each  8 bits into those  8 bits \\n        n = (n & 0x00FF00FF) + (n >>  8 & 0x00FF00FF); // put count of each 16 bits into those 16 bits \\n        n = (n & 0x0000FFFF) + (n >> 16 & 0x0000FFFF); // put count of each 32 bits into those 32 bits \\n        return n;\\n    }\\n\\n    // This uses fewer arithmetic operations than any other known implementation on machines with slow multiplication.\\n    // It uses 17 arithmetic operations.\\n    int hammingWeight(uint32_t n)\\n    {\\n        n -= (n >> 1) & 0x55555555; //put count of each 2 bits into those 2 bits\\n        n = (n & 0x33333333) + (n >> 2 & 0x33333333); //put count of each 4 bits into those 4 bits\\n        n = (n + (n >> 4)) & 0x0F0F0F0F; //put count of each 8 bits into those 8 bits\\n        n += n >> 8; // put count of each 16 bits into those 8 bits\\n        n += n >> 16; // put count of each 32 bits into those 8 bits\\n        return n & 0xFF;\\n    }\\n\\n    // This uses fewer arithmetic operations than any other known implementation on machines with fast multiplication.\\n    // It uses 12 arithmetic operations, one of which is a multiply.\\n    int hammingWeight(uint32_t n)\\n    {\\n        n -= (n >> 1) & 0x55555555; // put count of each 2 bits into those 2 bits\\n        n = (n & 0x33333333) + (n >> 2 & 0x33333333); // put count of each 4 bits into those 4 bits\\n        n = (n + (n >> 4)) & 0x0F0F0F0F; // put count of each 8 bits into those 8 bits \\n        return n * 0x01010101 >> 24; // returns left 8 bits of x + (x<<8) + (x<<16) + (x<<24)\\n    }\\n\\n\\u2014\\u2014From Wikipedia.",
                "codeTag": "Unknown"
            },
            {
                "id": 644682,
                "title": "easy-to-understand-faster-than-98-2-solutions-simple-python",
                "content": "```\\n    def using_inbuilt_counter(self, n):\\n        counter = collections.Counter(bin(n)[2:])\\n        return counter.get(\"1\", 0)\\n    \\n    def using_bit_manipulation(self, n):\\n        count = 0\\n        while n:\\n            if n & 1: count += 1\\n            n = n >> 1\\n        return count\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\n    def using_inbuilt_counter(self, n):\\n        counter = collections.Counter(bin(n)[2:])\\n        return counter.get(\"1\", 0)\\n    \\n    def using_bit_manipulation(self, n):\\n        count = 0\\n        while n:\\n            if n & 1: count += 1\\n            n = n >> 1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2742007,
                "title": "0ms-explained-solutions-c-bit-manipulation",
                "content": "There are 3 following approaches to the question:\\n\\n# 1st approach (not as much effective)\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n        while (n) {\\n            // let\\'s and(&) each bit with 1, if the result is 1 then we increment count by 1\\n            if (n&1 > 0) count++;\\n            // and then shift n by 1 bit [so that we can check the next bit is 1 or not]\\n            n>>=1;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n# 2nd approach (more effective method)\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n        while (n) {\\n            // when we substract n by 1, the Lowest significant 1 is affected first, thus \\n            // when we use and (&) operation the other 1\\'s stay intact and we increment count by 1\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n# 3rd approach (also a good approach, but you must know bitset class)\\n\\nBitset is a array of bools (why are we using it here? because the values here are only in 0\\'s and 1\\'s similar to true and false which are 1 & 0 respectively)\\n\\nIt is a more compact version of arrays & vectors and have some other restrictions (like you must mention the total size at the time of declaration, etc)\\n\\nWe use count to see how many bools are true (or how many bits are 1, which we actually want)\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return bitset<32>(n).count();\\n    }\\n};\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/2b404d99-9cdb-48ee-8899-f0c23a902759_1674631665.3592732.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n        while (n) {\\n            // let\\'s and(&) each bit with 1, if the result is 1 then we increment count by 1\\n            if (n&1 > 0) count++;\\n            // and then shift n by 1 bit [so that we can check the next bit is 1 or not]\\n            n>>=1;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n        while (n) {\\n            // when we substract n by 1, the Lowest significant 1 is affected first, thus \\n            // when we use and (&) operation the other 1\\'s stay intact and we increment count by 1\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return bitset<32>(n).count();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519675,
                "title": "java-c-simple-optimised-faster-than-100-detailed-explanation",
                "content": "<u>**BASIC IDEA**</u>\\n\\n* Using **Brian Kernighan Algorithm,** we will **not check/compare** or loop through all the 32 bits present but **only count the set bits** which is way better than checking all the 32 bits\\n* Suppose we have a number **10000000000000010000000000000001** (32 bits), now using this algorithm we will skip the 0\\'s bit and **directly jump to set bit(1\\'s bit)** and we don\\'t have to go through each bit to count set bits i.e. the loop will be executed **only for 3 times** for the mentioned example and **not for 32 times.**\\n\\n**<u>NOTE</u>: C++ CODE fluctates a lot from 0ms - 4ms**\\n<iframe src=\"https://leetcode.com/playground/TctjyQah/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\nAssume we are working for 8 bits for better understanding, but the same logic apply for 32 bits\\nSo, we will take a number having 3 set bits.\\n   `n   = 00010110`\\n`n - 1 = 00010101`(by substracting 1 from the number, all the bits gets flipped/toggled after the **rightmost set bit including the rightmost set bit itself. **\\nAfter applying &(bitwise AND) operator on n and n - 1 i.e. (n & n - 1), the **righmost set bit will be turned off/toggled/flipped**\\n\\nLet\\'s understand step by step\\n\\n* **1st Iteration**\\n&nbsp;&nbsp;&nbsp;`00010110` --> (22(n) in decimal)\\n&&nbsp;<u>`00010101`</u> --> (21(n - 1) in decimal i.e. **flipping all the bits** of n(22) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00010100` --> (20(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\n`n = 00010100` (20 in decimal)\\nand **increase the count**\\nbitCount++ (Initial bitCount = 0. By incrementing it, the bitCount = 1)\\n<hr>\\n\\n* **2nd Iteration**\\n&nbsp;&nbsp;&nbsp;`00010100` --> (20(n) in decimal)\\n&&nbsp;<u>`00010011`</u> --> (19(n - 1) in decimal i.e. **flipping all the bits** of n(20) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00010000` --> (16(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\nn = `00010000` (16 in decimal)\\nand **increase the count**\\nbitCount++ (previous bitCount = 1. By incrementing it, the bitCount = 2)\\n<hr>\\n\\n* **3rd Iteration**\\n&nbsp;&nbsp;&nbsp;`00010000` --> (16(n) in decimal)\\n&&nbsp;<u>`00001111`</u> --> (15(n - 1) in decimal i.e. **flipping all the bits** of n(16) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00000000` --> (0(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\nn = `00000000` (0 in decimal)\\nand **increase the count**\\nbitCount++ (previous bitCount = 2. By incrementing it, the bitCount = 3)\\n\\nNow, since the `n = 0`, there will be no furthur iteration as the condition becomes false, so it will come out of the loop and **return bitCount which is 3 which is desired output.**\\n\\n<u>**COMPLEXITY**</u>\\n* **Time: O(m)**, where m is the number of set bits\\n* **Space: O(1)**, in-place\\n\\n<hr>\\n\\n**Refer to the following github repsitory for more leetcode solutions**\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please Upvote if you find the solution helpful :)**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "<u>**BASIC IDEA**</u>\\n\\n* Using **Brian Kernighan Algorithm,** we will **not check/compare** or loop through all the 32 bits present but **only count the set bits** which is way better than checking all the 32 bits\\n* Suppose we have a number **10000000000000010000000000000001** (32 bits), now using this algorithm we will skip the 0\\'s bit and **directly jump to set bit(1\\'s bit)** and we don\\'t have to go through each bit to count set bits i.e. the loop will be executed **only for 3 times** for the mentioned example and **not for 32 times.**\\n\\n**<u>NOTE</u>: C++ CODE fluctates a lot from 0ms - 4ms**\\n<iframe src=\"https://leetcode.com/playground/TctjyQah/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\nAssume we are working for 8 bits for better understanding, but the same logic apply for 32 bits\\nSo, we will take a number having 3 set bits.\\n   `n   = 00010110`\\n`n - 1 = 00010101`(by substracting 1 from the number, all the bits gets flipped/toggled after the **rightmost set bit including the rightmost set bit itself. **\\nAfter applying &(bitwise AND) operator on n and n - 1 i.e. (n & n - 1), the **righmost set bit will be turned off/toggled/flipped**\\n\\nLet\\'s understand step by step\\n\\n* **1st Iteration**\\n&nbsp;&nbsp;&nbsp;`00010110` --> (22(n) in decimal)\\n&&nbsp;<u>`00010101`</u> --> (21(n - 1) in decimal i.e. **flipping all the bits** of n(22) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00010100` --> (20(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\n`n = 00010100` (20 in decimal)\\nand **increase the count**\\nbitCount++ (Initial bitCount = 0. By incrementing it, the bitCount = 1)\\n<hr>\\n\\n* **2nd Iteration**\\n&nbsp;&nbsp;&nbsp;`00010100` --> (20(n) in decimal)\\n&&nbsp;<u>`00010011`</u> --> (19(n - 1) in decimal i.e. **flipping all the bits** of n(20) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00010000` --> (16(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\nn = `00010000` (16 in decimal)\\nand **increase the count**\\nbitCount++ (previous bitCount = 1. By incrementing it, the bitCount = 2)\\n<hr>\\n\\n* **3rd Iteration**\\n&nbsp;&nbsp;&nbsp;`00010000` --> (16(n) in decimal)\\n&&nbsp;<u>`00001111`</u> --> (15(n - 1) in decimal i.e. **flipping all the bits** of n(16) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00000000` --> (0(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\nn = `00000000` (0 in decimal)\\nand **increase the count**\\nbitCount++ (previous bitCount = 2. By incrementing it, the bitCount = 3)\\n\\nNow, since the `n = 0`, there will be no furthur iteration as the condition becomes false, so it will come out of the loop and **return bitCount which is 3 which is desired output.**\\n\\n<u>**COMPLEXITY**</u>\\n* **Time: O(m)**, where m is the number of set bits\\n* **Space: O(1)**, in-place\\n\\n<hr>\\n\\n**Refer to the following github repsitory for more leetcode solutions**\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please Upvote if you find the solution helpful :)**",
                "codeTag": "Unknown"
            },
            {
                "id": 1996783,
                "title": "javascript-solutions-notes-from-a-bootcamp-teacher",
                "content": "# **Hi, I\\'m Mike and I\\'m the Lead Instructor at [10x Code Camp](https://www.10xcodecamp.com/)**.\\n\\nI\\'m going to present as many reasonable solutions as possible. I will first write pseudo-code that will work for most languages. I will include links to relevant documentation. Then I will present the code for each solution.\\n\\nNote, I will not list the Runtime or Memory Usage percentages. Unfortunately, these can be inaccurate and lead learners down the wrong path. For example, you may submit a less optimal solution that gets a higher score than a more optimal one. Then you may think the less optimal one is better. LeetCode\\'s Runtime and Memory Usage are unpredictable and cannot be relied upon to find the most optimal solution. To test this, submit a solution and note its percentages. Then submit it again. You will frequently see discrepancies.\\n\\nInstead, I will display Grades for each solution. These are A through D. A is the highest grade. D is the lowest. These grades are based on Big O notation and best practices in real-world programming. I will sacrifice a millisecond of speed for a good variable name. This is a much better practice than giving variables hard-to-understand 1-letter names or cramming everything into 1 line. I\\'ll include comments too. I\\'ve interviewed and hired many developers, and everything I teach is what I like to see in potential programmers. **Please upvote if you like this style and would like me to continue.**\\n\\n# **Loop through a string | Grade: D**\\n* Convert the 32-bit unsigned integer to a string.\\n* Note: we\\'ll have to pass a **[radix parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#parameters)** of 2 to keep it in **[base 2](https://www.expii.com/t/base-binary-numbers-9192)**.\\n* Create a `count` variable with a value of 0.\\n* Loop through every character.\\n* Increase your count by 1 every time you encounter a 1 in the string.\\n* Return your count.\\n\\n```\\nvar hammingWeight = function(int) {\\n    const str = int.toString(2); // pass a radix parameter of 2 to keep it in base 2.\\n    let count = 0;\\n    for (let char of str) {\\n        if (char === \"1\") count++;\\n    }\\n    return count;    \\n};\\n```\\n\\n# **Filter an array of strings | Grade: D**\\n- Convert the 32-bit unsigned integer to a string.\\n- * Note: we\\'ll have to pass a **[radix parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#parameters)** of 2 to keep it in **[base 2](https://www.expii.com/t/base-binary-numbers-9192)**.\\n- Create an array of each character (using `split`).\\n- Filter the array for 1s.\\n- Return the length of the filtered array.\\n\\n```\\nvar hammingWeight = function(int) {\\n    return int.toString(2)\\n              .split(\"\")\\n              .filter(char => char === \"1\")\\n              .length;    \\n};\\n```\\n\\n# **String matching | Grade: C**\\n- Convert the 32-bit unsigned integer to a string.\\n- Note: we\\'ll have to pass a **[radix parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#parameters)** of 2 to keep it in **[base 2](https://www.expii.com/t/base-binary-numbers-9192)**.\\n- Use Regex `match` to return an array of all matches for the number 1 (`/1/g`).\\n- Return the length of this array.\\n- Remember to handle no matches (with a **[conditional](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)** or **[optional chaining: `?.`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining)**).\\n\\n```\\nvar hammingWeight = function(int) {\\n    const str = int.toString(2)\\n    return str === \\'0\\' ? 0 : (str.match(/1/g)).length; \\n};\\n```\\n\\n\\n# **Convert to string, replace zeroes | Grade: C**\\n- Convert the 32-bit unsigned integer to a string.\\n- Note: we\\'ll have to pass a **[radix parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#parameters)** of 2 to keep it in **[base 2](https://www.expii.com/t/base-binary-numbers-9192)**.\\n- Remove the zeroes. Replace each zero with an empty string.\\n- Return the length of the resulting string.\\n\\n```\\nvar hammingWeight = function(int) {\\n    return int.toString(2).replaceAll(\"0\", \"\").length;    \\n};\\n```\\n\\n\\n# **While loop with integer manipulation | Grade: A**\\n* Converting to strings and arrays is slow. We can just manipulate the bits!\\n* Create a `count` variable with a value of 0.\\n* While the integer is not `0`\\n\\t* Check if the last bit is `1`. We can use a **[bitwise AND](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND)** to check for **[an odd bit (1) or an even bit (0)](https://catonmat.net/low-level-bit-hacks#bithack1)**.\\n\\t* If so, add it to the count.\\n\\t* Chop off the last (farthest right) bit of the integer. JavaScript has **[3 bitwise shift operators](http://speakingjs.com/es5/ch11.html#_bitwise_shift_operators)**.\\n\\t* We can use **[unsigned right shift](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift)**: `int = int >>> 1` or **[unsigned right shift assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift_assignment)**: `int >>>= 1`\\n* Return the count\\n\\n```\\nvar hammingWeight = function(int) {\\n    let count = 0;\\n    while (int !== 0) {\\n        const bitComparison = int & 1; // 1 & 1 will return 1. 0 & 1 will return 0.\\n        if (bitComparison === 1) count++;\\n        int >>>= 1; // unsigned right shift assignment (chop off the last bit and assign it)\\n    }  \\n    return count;\\n};\\n```\\n\\n\\n# **If this function is called many times, how would you optimize it?**\\n\\nIn theory, you could create a dictionary (also called a lookup table - in JavaScript this is an object) with all 32-bit unsigned integers as keys and all their Hamming Weights as their respective values.\\n\\nYou could create this programmatically once and then all future lookups would be as fast as possible.\\n\\nFrom the Wikipedia article on **[Hamming Weight](https://en.wikipedia.org/wiki/Hamming_weight)**:\\n\\n*If greater memory usage is allowed, we can calculate the Hamming weight faster than the above methods. With unlimited memory, we could simply create a large lookup table of the Hamming weight of every integer.*\\n\\nThe Wikipedia article also illustrates how you could compute the Hamming weight of every 32-bit integer if you have a dictionary (lookup table) of every 16-bit integer. So you could:\\n\\n- Have a lookup table of all 32-bit integers (fastest, but more needs more storage for a larger table).\\n- Or, have a lookup table of all 16-bit integers (a little slower, but only needs half the storage).",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hammingWeight = function(int) {\\n    const str = int.toString(2); // pass a radix parameter of 2 to keep it in base 2.\\n    let count = 0;\\n    for (let char of str) {\\n        if (char === \"1\") count++;\\n    }\\n    return count;    \\n};\\n```\n```\\nvar hammingWeight = function(int) {\\n    return int.toString(2)\\n              .split(\"\")\\n              .filter(char => char === \"1\")\\n              .length;    \\n};\\n```\n```\\nvar hammingWeight = function(int) {\\n    const str = int.toString(2)\\n    return str === \\'0\\' ? 0 : (str.match(/1/g)).length; \\n};\\n```\n```\\nvar hammingWeight = function(int) {\\n    return int.toString(2).replaceAll(\"0\", \"\").length;    \\n};\\n```\n```\\nvar hammingWeight = function(int) {\\n    let count = 0;\\n    while (int !== 0) {\\n        const bitComparison = int & 1; // 1 & 1 will return 1. 0 & 1 will return 0.\\n        if (bitComparison === 1) count++;\\n        int >>>= 1; // unsigned right shift assignment (chop off the last bit and assign it)\\n    }  \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3288353,
                "title": "amazing-logic-with-right-shift",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return bin(n)[2:].count(\\'1\\')\\n```\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            count+=n%2\\n            n=n>>1\\n        return count\\n    #please upvote me it would encourage me alot\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return bin(n)[2:].count(\\'1\\')\\n```\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            count+=n%2\\n            n=n>>1\\n        return count\\n    #please upvote me it would encourage me alot\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074658,
                "title": "c-0ms-runtime-2-methods-explained",
                "content": "There are two types of Ideas which can be used here:\\n **1. Brute Force**\\nlets take a number in Binary : 1001 now just see that if it has last bit (least magnificient bit) is one or not if it is increase the count and rightshift our number and repeat same.\\n\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        while(n > 0)\\n        {\\n            if(n%2==1)ans++;\\n            n /= 2;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nNote that: n = n/2 <==> n = n >> 1\\n\\n**2.Bit Manipulation**\\n\\nWe can see that if we do [n & (n - 1)] we will be reducing a one bit from the number. \\ne.g. 1001 & 1000 = 1000, 110 & (101) = 100.\\nwe can actually use this here.\\nin this case iterations required will be equal to number of set bits in a number.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        while(n > 0)\\n        {\\n            n = n & (n-1);\\n            ans++;;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nin both solutions we can see **auxillary time complexity is O(1)** because we run loop for 32 times max. And obviously **Space complexity is also O(1)**\\n\\n**UPVOTE if it Helps**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        while(n > 0)\\n        {\\n            if(n%2==1)ans++;\\n            n /= 2;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        while(n > 0)\\n        {\\n            n = n & (n-1);\\n            ans++;;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55352,
                "title": "super-simple-java-solution",
                "content": "This is about the easiest possible answer in Java :)\\n\\n    public class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            return Integer.bitCount(n);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            return Integer.bitCount(n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3015716,
                "title": "java-easy-solution-beats-100-runtime-0ms",
                "content": "\\n# Approach\\nUsing Bit Manipulation-\\nWe first check the last bit of the number, whether its 1 or 0 by performing binary AND operation of the number n with 1 (i.e. n&1) and store it in a variable named \\'last_bit\\'. We then add the last_bit to the count variable which was initially set to 0 ,because by doing so, if the value of last bit of n is 1 ,then the count will be incremented by 1 ,and if the value of last bit of n is 0 then the count value will be incremented by 0 i.e. it will remain same. We now drop the last digit of the number n by performing the right shift operation of the number with 1 (i.e. n>>>1). We iterate or repeat  all these steps till the number is not equal to 0 as when the number becomes equal to 0 then it does not contain any \"1 bit\" and so we need not to iterate it further.\\n\\n\\nHope this helps!!\\nDo Upvote if you like it.\\n\\nThanks :)\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count=0;\\n        while(n!=0){\\n            int last_bit= n & 1; //Stores the value of the last bit of the number n i.e.(1 or 0)\\n            count+= last_bit; // adds 0 if last bit is 0 and adds 1 if last bit is 1 \\n            n = n>>>1;  //Dropping the last bit of the binary number n \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count=0;\\n        while(n!=0){\\n            int last_bit= n & 1; //Stores the value of the last bit of the number n i.e.(1 or 0)\\n            count+= last_bit; // adds 0 if last bit is 0 and adds 1 if last bit is 1 \\n            n = n>>>1;  //Dropping the last bit of the binary number n \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468836,
                "title": "python-js-java-go-c-o-lg-n-by-bit-manipulation",
                "content": "[Tutorial video in Chinese \\u4E2D\\u6587\\u89E3\\u984C\\u5F71\\u7247](https://www.youtube.com/watch?v=BcLiDexMnvU)\\n\\nPython O( lg n ) sol. based on bit-manipulation\\n\\nNote: Assume the input is of int32.\\n\\n---\\n\\n\\n```python []\\nclass Solution:\\n\\n    def hammingWeight(self, n: int) -> int:\\n        \\n        # Base case\\n        if n == 0 :\\n            return 0\\n        \\n        # General case:\\n        # n = n / 2 + LSB = n / 2 + odd bit = n / 2 + ( n & 1)\\n        \\n        # Python\\'s right shift operator is >>\\n        return (n & 1) + self.hammingWeight( n >> 1 )\\n```\\n\\n\\n---\\n\\nShare extra solutions\\n\\n---\\nin Python:\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        \\n        num_of_1s = 0\\n        \\n        for i in range(32):\\n            \\n            num_of_1s += (n & 1)\\n            \\n            n = n >> 1\\n            \\n        return num_of_1s\\n```\\n\\nExtra supplementary material, python has native binary string corversion function\\n\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        \\n        # Convert to binary string\\n\\t\\t# then count the occurrence of \"1\"\\n        return bin(n).count(\"1\")\\n```\\n\\n---\\n\\nJava:\\n\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        \\n        int onesCount = 0;\\n        \\n        for( int i = 0 ; i < 32 ; i++){\\n            \\n            // keep detecting LSB of n is 1 or 0\\n            onesCount += n & 1;\\n            \\n            // get next digit of n by right shift rotation\\n            n >>= 1;\\n        }\\n        \\n        return onesCount;\\n    }\\n}\\n```\\n\\n\\nExtra supplementary material, Java has native bitCount function.\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        \\n        return Integer.bitCount(n);\\n    }\\n}\\n```\\n\\n---\\n\\nin JavaScript:\\n```\\nvar hammingWeight = function(n) {\\n    \\n    let num_of_1s = 0;\\n    \\n    for( let i=0 ; i < 32; i++ ){\\n        \\n        num_of_1s += n & 1;\\n        \\n        n >>= 1;\\n\\n    }\\n    \\n    return num_of_1s\\n};\\n```\\n\\n---\\nin Go:\\n\\n```\\nfunc hammingWeight(num uint32) int {\\n    \\n    num_of_1s := 0\\n    \\n    for i := 0 ; i < 32; i+=1 {\\n        \\n        if num & uint32(1) == 1{\\n            num_of_1s += 1    \\n        }\\n         \\n        num >>= 1\\n        \\n    }\\n    \\n    return num_of_1s\\n}\\n```\\n\\nExtra supplementary material, Go has native bit count method in package \"math/bits\"\\n\\n```\\nfunc hammingWeight(num uint32)int{\\n    \\n    return bits.OnesCount( uint(num) )\\n    \\n}\\n```\\n\\n---\\n\\nin C++\\n\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        \\n        uint32_t numOfOnes = 0;\\n        \\n        for( short bit = 0 ; bit < 32 ; bit++){\\n            \\n            // Check the 0/1 on LSB\\n            numOfOnes += n & 1;\\n            \\n            // input number right shift\\n            n >>= 1;    \\n        }\\n        \\n        return numOfOnes;\\n    }\\n};\\n```\\n\\nExtra supplementary material, GNU C++ has built-in bit count function.\\n\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        \\n        return __builtin_popcount(n);\\n    }\\n};\\n\\n\\n```\\n\\n\\n---\\n---\\n\\nShare another implementation based on bit operation\\n\\nin Python:\\n\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        \\n        counter = 0\\n    \\n        while n:\\n            \\n            # this will take out the right-most 1 of n    \\n            n = n & (n-1)\\n            \\n            # update counter\\n            counter += 1\\n        \\n        return counter\\n```\\n\\n---\\n\\nJava:\\n\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        \\n        int onesCount = 0;\\n        \\n        while( n != 0 ){\\n            \\n            // update counter when n is non-zero\\n            onesCount ++;\\n            \\n            // take out right most 1 of n\\n            n = n & (n-1);\\n            \\n        }\\n        \\n        return onesCount;\\n    }\\n}\\n\\n```\\n\\n---\\n\\nin Javascript:\\n\\n```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\n\\nvar hammingWeight = function(n) {\\n    \\n    let count = 0;\\n    \\n    while( n ){\\n        \\n        // this will take out the right-most 1 of n    \\n        n = n & (n-1);\\n        \\n        // update counter\\n        count += 1\\n    }\\n    \\n    return count\\n};\\n```\\n\\n---\\n\\nin Go:\\n\\n```\\nfunc hammingWeight(num uint32) int {\\n    \\n    num_of_1s := 0\\n    \\n    for  ;  num != 0;  {\\n        \\n        // this will take out the right-most 1 of n    \\n        num = num & (num - 1)\\n        \\n        // update counter\\n        num_of_1s += 1\\n    }\\n    \\n    return num_of_1s\\n}\\n```\\n\\n---\\n\\nin C++:\\n\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        \\n        uint32_t numOfOnes = 0;\\n        \\n        while( n ){\\n            \\n            // this will take out rightmost 1 in binary representation \\n            n = n & (n-1);\\n            \\n            numOfOnes++;\\n            \\n        }\\n        return numOfOnes;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```python []\\nclass Solution:\\n\\n    def hammingWeight(self, n: int) -> int:\\n        \\n        # Base case\\n        if n == 0 :\\n            return 0\\n        \\n        # General case:\\n        # n = n / 2 + LSB = n / 2 + odd bit = n / 2 + ( n & 1)\\n        \\n        # Python\\'s right shift operator is >>\\n        return (n & 1) + self.hammingWeight( n >> 1 )\\n```\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        \\n        num_of_1s = 0\\n        \\n        for i in range(32):\\n            \\n            num_of_1s += (n & 1)\\n            \\n            n = n >> 1\\n            \\n        return num_of_1s\\n```\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        \\n        # Convert to binary string\\n\\t\\t# then count the occurrence of \"1\"\\n        return bin(n).count(\"1\")\\n```\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        \\n        int onesCount = 0;\\n        \\n        for( int i = 0 ; i < 32 ; i++){\\n            \\n            // keep detecting LSB of n is 1 or 0\\n            onesCount += n & 1;\\n            \\n            // get next digit of n by right shift rotation\\n            n >>= 1;\\n        }\\n        \\n        return onesCount;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        \\n        return Integer.bitCount(n);\\n    }\\n}\\n```\n```\\nvar hammingWeight = function(n) {\\n    \\n    let num_of_1s = 0;\\n    \\n    for( let i=0 ; i < 32; i++ ){\\n        \\n        num_of_1s += n & 1;\\n        \\n        n >>= 1;\\n\\n    }\\n    \\n    return num_of_1s\\n};\\n```\n```\\nfunc hammingWeight(num uint32) int {\\n    \\n    num_of_1s := 0\\n    \\n    for i := 0 ; i < 32; i+=1 {\\n        \\n        if num & uint32(1) == 1{\\n            num_of_1s += 1    \\n        }\\n         \\n        num >>= 1\\n        \\n    }\\n    \\n    return num_of_1s\\n}\\n```\n```\\nfunc hammingWeight(num uint32)int{\\n    \\n    return bits.OnesCount( uint(num) )\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        \\n        uint32_t numOfOnes = 0;\\n        \\n        for( short bit = 0 ; bit < 32 ; bit++){\\n            \\n            // Check the 0/1 on LSB\\n            numOfOnes += n & 1;\\n            \\n            // input number right shift\\n            n >>= 1;    \\n        }\\n        \\n        return numOfOnes;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        \\n        return __builtin_popcount(n);\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        \\n        counter = 0\\n    \\n        while n:\\n            \\n            # this will take out the right-most 1 of n    \\n            n = n & (n-1)\\n            \\n            # update counter\\n            counter += 1\\n        \\n        return counter\\n```\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        \\n        int onesCount = 0;\\n        \\n        while( n != 0 ){\\n            \\n            // update counter when n is non-zero\\n            onesCount ++;\\n            \\n            // take out right most 1 of n\\n            n = n & (n-1);\\n            \\n        }\\n        \\n        return onesCount;\\n    }\\n}\\n\\n```\n```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\n\\nvar hammingWeight = function(n) {\\n    \\n    let count = 0;\\n    \\n    while( n ){\\n        \\n        // this will take out the right-most 1 of n    \\n        n = n & (n-1);\\n        \\n        // update counter\\n        count += 1\\n    }\\n    \\n    return count\\n};\\n```\n```\\nfunc hammingWeight(num uint32) int {\\n    \\n    num_of_1s := 0\\n    \\n    for  ;  num != 0;  {\\n        \\n        // this will take out the right-most 1 of n    \\n        num = num & (num - 1)\\n        \\n        // update counter\\n        num_of_1s += 1\\n    }\\n    \\n    return num_of_1s\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        \\n        uint32_t numOfOnes = 0;\\n        \\n        while( n ){\\n            \\n            // this will take out rightmost 1 in binary representation \\n            n = n & (n-1);\\n            \\n            numOfOnes++;\\n            \\n        }\\n        return numOfOnes;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55108,
                "title": "readable-simple-java-solution-o-1",
                "content": "In the following solution:\\n1. Iterate over 32 bits since its a 32-bit integer. This will be O(1) since it is in constant time\\n2. Left shift the number by i to get the LSB value\\n3. Do an AND of the number obtained from step 2 with 1. If the result of the AND is 1 then increment the count because the LSB value of that bit was 1.\\n\\n```\\n public int hammingWeight(int n) {\\n        int count = 0;\\n        for(int i=0; i<32; i++){\\n            count += (n >> i & 1) == 1 ? 1: 0;\\n        }\\n        return count;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n public int hammingWeight(int n) {\\n        int count = 0;\\n        for(int i=0; i<32; i++){\\n            count += (n >> i & 1) == 1 ? 1: 0;\\n        }\\n        return count;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2941048,
                "title": "one-line-of-code",
                "content": "# Please upvote if you like my solution .\\n\\n# Code\\n```\\nvar hammingWeight = function(n) {\\n    return n.toString(2).split(\"0\").join(\"\").length;\\n};\\n```\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on Linkedin https://www.linkedin.com/in/kailas-rathod/",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hammingWeight = function(n) {\\n    return n.toString(2).split(\"0\").join(\"\").length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55194,
                "title": "use-n-n-n-1-trick-to-clear-the-least-bit",
                "content": "    public int hammingWeight(int n) {\\n        int count = 0;\\n        for (;n!=0;n = n & (n-1))\\n            count++;\\n        return count;\\n    }\\n\\nn=n&(n-1) trick to clear the least significant bit",
                "solutionTags": [],
                "code": "    public int hammingWeight(int n) {\\n        int count = 0;\\n        for (;n!=0;n = n & (n-1))\\n            count++;\\n        return count;\\n    }\\n\\nn=n&(n-1) trick to clear the least significant bit",
                "codeTag": "Unknown"
            },
            {
                "id": 3218849,
                "title": "191-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe solution uses a while loop to iterate over all bits of the given integer n and counts the number of \\'1\\' bits.\\n\\nHere\\'s how the solution works step-by-step:\\n\\n1. Initialize a counter variable count to 0.\\n2. Loop until n is 0.\\n3. Inside the loop, check if the last bit of n is 1 using the bitwise AND operator (&) with 1. If the result is 1, increment the counter count.\\n4. Shift n to the right by 1 bit using the right shift operator (>>).\\n5. Repeat steps 3-4 until all bits of n have been checked.\\n6. Return the counter count containing the number of \\'1\\' bits in the given integer n.\\n\\nFor example, let\\'s take the input n = 00000000000000000000000000001011.\\n\\n1. count = 0\\n2. Loop until n is 0.\\n3. n & 1 = 00000000000000000000000000000011 & 00000000000000000000000000000001 = 1. The last bit of n is 1, so increment count to 1.\\n4. n >> 1 = 00000000000000000000000000000101\\n5. n & 1 = 00000000000000000000000000000101 & 00000000000000000000000000000001 = 1. The last bit of n is 1, so increment count to 2.\\n6. n >> 1 = 00000000000000000000000000000010\\n7. n & 1 = 00000000000000000000000000000010 & 00000000000000000000000000000001 = 0. The last bit of n is 0, so do not increment count.\\n8. n >> 1 = 00000000000000000000000000000001\\n9. n & 1 = 00000000000000000000000000000001 & 00000000000000000000000000000001 = 1. The last bit of n is 1, so increment count to 3.\\n10. n >> 1 = 00000000000000000000000000000000\\n11. Loop terminates because n is now 0.\\n12. Return count = 3.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        # Initialize a counter variable to 0\\n        count = 0\\n        # Loop until n is 0\\n        while n != 0:\\n            # If the last bit of n is 1, increment the counter\\n            if n & 1 == 1:\\n                count += 1\\n            # Shift n to the right by 1 bit\\n            n = n >> 1\\n        # Return the counter\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        # Initialize a counter variable to 0\\n        count = 0\\n        # Loop until n is 0\\n        while n != 0:\\n            # If the last bit of n is 1, increment the counter\\n            if n & 1 == 1:\\n                count += 1\\n            # Shift n to the right by 1 bit\\n            n = n >> 1\\n        # Return the counter\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55434,
                "title": "concise-java-solution-x-x-1",
                "content": "x & (x-1) helps to remove right most 1 for x. For reference, see [Bit Hacks][1]\\n\\n    public class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int count = 0;\\n            while(n != 0){\\n                n = n & (n-1);\\n                count++;\\n            }\\n            return count;\\n        }\\n    }\\n\\n  [1]: http://www.catonmat.net/blog/low-level-bit-hacks-you-absolutely-must-know/",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int count = 0;\\n            while(n != 0){\\n                n = n & (n-1);\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 427069,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\nvar hammingWeight = function(n) {\\n    let sum = 0;\\n    \\n    while(n != 0) {\\n        sum += n & 1;\\n        n = n >>> 1;\\n    }\\n    \\n    return sum;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\nvar hammingWeight = function(n) {\\n    let sum = 0;\\n    \\n    while(n != 0) {\\n        sum += n & 1;\\n        n = n >>> 1;\\n    }\\n    \\n    return sum;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1045330,
                "title": "solution-to-follow-up-question",
                "content": "**A try to solve the follow-up to this question:**\\n*(Please review it)*\\n\\nIn case the call to this function is huge, it is worth precomputing some stuff so that we can achieve O(1) time complexity of this function.\\n\\nNumbers are 32-bits long, so we can split it in two (first 16-bits and second 16-bits)\\n\\nKeep an array for answers of 16-bit numbers.\\n\\n```\\nconst int len = 1 << 16;\\nint f[len]; // this will store answers for 16-bit numbers\\n\\nvoid precompute() {\\n\\tf[0] = 0;\\n\\tfor(int i = 1; i < len; i++) {\\n\\t\\tf[i] = f[i>>1] + (i&1);\\n\\t}\\n}\\n\\nint hammingWeight(uint32_t n) {\\n\\treturn f[n/len] + f[n%len]; // O(1) call\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst int len = 1 << 16;\\nint f[len]; // this will store answers for 16-bit numbers\\n\\nvoid precompute() {\\n\\tf[0] = 0;\\n\\tfor(int i = 1; i < len; i++) {\\n\\t\\tf[i] = f[i>>1] + (i&1);\\n\\t}\\n}\\n\\nint hammingWeight(uint32_t n) {\\n\\treturn f[n/len] + f[n%len]; // O(1) call\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2074152,
                "title": "easy-o-1-space-python-c",
                "content": "***Please upvote if you find it useful***\\n\\n\\n---\\n1. #### Loop and find set bit\\n\\nThe main idea is to find the number of set bits using the masking operator. \\neg: For a binary number` 00000000000000000000000010000000`, we can check if a bit is set at a specific position by doing the following:\\n```\\n(00000000000000000000000010000000 & (1<<7))!=0\\n\\n(1<<7) acts as a mask to find the set bit at the 7th bit position\\n```\\n\\n\\n\\n**Python3**\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int: \\n        return sum((n & (1<<i))!=0 for i in range(32))\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;         \\n        for (int i = 0; i < 32; i++)\\n\\t\\t{ \\t\\t\\t\\n            if((n & (1<<i))!=0)\\n                cnt+=1;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n---\\n\\n2. #### Bit Manipulation\\n\\nThis is a little faster. The max number of iterations in this algorithm is the number of set bits in the input `n`.\\n\\n**Python3**\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        cnt = 0\\n        while n :\\n            cnt+=1\\n            n = n & (n-1)\\n        return cnt\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n      int cnt=0;         \\n        while(n!=0)\\n\\t\\t{ \\n\\t\\t\\tcnt++;     \\n            n&=(n-1); \\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n**Time - O(1)** - The max number of bits in input `n` is bounded to 32 bits. \\n**Space - O(1)**\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n(00000000000000000000000010000000 & (1<<7))!=0\\n\\n(1<<7) acts as a mask to find the set bit at the 7th bit position\\n```\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int: \\n        return sum((n & (1<<i))!=0 for i in range(32))\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;         \\n        for (int i = 0; i < 32; i++)\\n\\t\\t{ \\t\\t\\t\\n            if((n & (1<<i))!=0)\\n                cnt+=1;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        cnt = 0\\n        while n :\\n            cnt+=1\\n            n = n & (n-1)\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n      int cnt=0;         \\n        while(n!=0)\\n\\t\\t{ \\n\\t\\t\\tcnt++;     \\n            n&=(n-1); \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55211,
                "title": "0-ms-c-solution",
                "content": "    int hammingWeight(uint32_t n) {\\n        int count = n ? 1 : 0;\\n        while(n &= (n-1)) count++;\\n        return count;\\n    }\\n\\nEdit: Updated code to make it more readable. Still 0 ms.",
                "solutionTags": [],
                "code": "    int hammingWeight(uint32_t n) {\\n        int count = n ? 1 : 0;\\n        while(n &= (n-1)) count++;\\n        return count;\\n    }\\n\\nEdit: Updated code to make it more readable. Still 0 ms.",
                "codeTag": "Unknown"
            },
            {
                "id": 2075970,
                "title": "three-easy-solutions-linq-no-linq-and-a-system-library",
                "content": "LINQ:\\n```csharp\\npublic int HammingWeight(uint n)\\n\\t=> Convert.ToString(n, 2).Count(x => x == \\'1\\');\\n```\\n\\nNo LINQ:\\n```csharp\\npublic int HammingWeight(uint n)\\n{\\n\\tuint c = 0;\\n\\n\\twhile(n > 0)\\n\\t{\\n\\t\\tc += n & 1; // or: c += n % 2;\\n\\t\\tn >>= 1;    // or: n /= 2;\\n\\t}\\n\\n\\treturn (int) c;\\n}\\n```\\n\\nSystem library (the proper real-world solution of this problem):\\n```csharp\\npublic int HammingWeight(uint n)\\n\\t=> System.Numerics.BitOperations.PopCount(n);\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic int HammingWeight(uint n)\\n\\t=> Convert.ToString(n, 2).Count(x => x == \\'1\\');\\n```\n```csharp\\npublic int HammingWeight(uint n)\\n{\\n\\tuint c = 0;\\n\\n\\twhile(n > 0)\\n\\t{\\n\\t\\tc += n & 1; // or: c += n % 2;\\n\\t\\tn >>= 1;    // or: n /= 2;\\n\\t}\\n\\n\\treturn (int) c;\\n}\\n```\n```csharp\\npublic int HammingWeight(uint n)\\n\\t=> System.Numerics.BitOperations.PopCount(n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55402,
                "title": "java-solution-no-need-to-iterate-all-32-bits-all-the-time",
                "content": "No need to iterate all 32 bits all the time, for the example provided, only 4 iterations required.\\n\\n    public int hammingWeight(int n) {\\n            int result = 0;\\n            while (n != 0) {\\n                if ((n & 1) == 1) {\\n                    result++;\\n                }\\n                n >>>= 1;\\n            }\\n            return result;\\n        }",
                "solutionTags": [],
                "code": "No need to iterate all 32 bits all the time, for the example provided, only 4 iterations required.\\n\\n    public int hammingWeight(int n) {\\n            int result = 0;\\n            while (n != 0) {\\n                if ((n & 1) == 1) {\\n                    result++;\\n                }\\n                n >>>= 1;\\n            }\\n            return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 975887,
                "title": "javascript-dropping-the-least-significant-bit-lsb",
                "content": "Counting the number of 1 bits is the same as dropping the least significant bit until we find that n is now zero instead of whatever it was before.\\n\\nHere\\'s an example of how LSB works\\n\\nn = 5 --> `101`\\n\\nn = n & (n - 1) (**dropping LSB**)\\nn = 101 & (100) = 100\\n\\nAs you can see, we dropped the LSB by doing n - 1, and ANDing it with the n we had before the subtraction. \\n\\nTime Complexity: O(number of bits)\\n\\n```\\nconst hammingWeight = (n) => {\\n\\tlet count = 0;\\n\\n\\twhile (n !== 0) {\\n\\t\\tcount++;\\n\\t\\tn = n & (n - 1);\\n\\t}\\n\\n\\treturn count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst hammingWeight = (n) => {\\n\\tlet count = 0;\\n\\n\\twhile (n !== 0) {\\n\\t\\tcount++;\\n\\t\\tn = n & (n - 1);\\n\\t}\\n\\n\\treturn count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3974845,
                "title": "java-solution-and-best-approach-with-time-complexity-o-set-bits-and-extra-useful-knowledge",
                "content": "**For java coders, a special note given below must read:**\\n\\nUnsigned int means => only +ve numbers in int range (0 to 2147483647)\\nSigned int means =>  +ve and -ve numbers both in int range (-2147483648 to 2147483647)\\n\\nIn Java language, the maximum integer is 2147483647. int type in Java is signed means (-2147483648 to 2147483647) and there is no unsigned int means there you will not get only +ve numbers like (0 to 2147483647) . \\nSo the input 2147483648 is represented in Java as -2147483648 (in java int type has a cyclic representation, that means Integer.MAX_VALUE+1==Integer.MIN_VALUE).\\nThis force us to use\\n```\\nn!=0\\n```\\n\\nin the while condition and we cannot use\\n```\\nn>0\\n```\\nbecause the input 2147483648 would correspond to -2147483648 in java and the code would not enter the while if the condition is n>0 for n=2147483648.  Because -2147483648 is less than 0.\\n\\n# First Approach\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int ans=0;\\n\\n        // TC => O(n) , where n is a binary string of length 32.\\n        while(n!=0){\\n            if((n&1)==1){\\n                ans++;\\n            }\\n            //n = n>>1;  //if use this you will get TLE Error \\n\\t\\t\\tn = n>>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Note:**\\nJava supports two types of right shift operators. The >> operator is a signed right shift operator and >>> is an unsigned right shift operator. The left operands value is moved right by the number of bits specified by the right operand.\\n\\n```\\nn = n>>1; //for Signed right shift\\n```\\n```\\nn = n>>>1; //for Unsigned right shift\\n```\\n\\n\\n# Second Approach:\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int ans=0;\\n        //TC => O(k), where k is total number of set bits. set bit is 1. unset bit is 0.\\n         while(n!=0){\\n             n = n & (n-1);\\n            ans++;\\n        }\\n \\n        return ans;\\n    }\\n}\\n```\\n\\n## ***Please Upvote Guys, it motivates me to write such article for you guys Please Upvote, God Will help you If you help others.***\\n\\n![image](https://assets.leetcode.com/users/images/60a806ee-c927-42a9-8ed6-f68434fc5d8a_1693457375.858137.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nn!=0\\n```\n```\\nn>0\\n```\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int ans=0;\\n\\n        // TC => O(n) , where n is a binary string of length 32.\\n        while(n!=0){\\n            if((n&1)==1){\\n                ans++;\\n            }\\n            //n = n>>1;  //if use this you will get TLE Error \\n\\t\\t\\tn = n>>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nn = n>>1; //for Signed right shift\\n```\n```\\nn = n>>>1; //for Unsigned right shift\\n```\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int ans=0;\\n        //TC => O(k), where k is total number of set bits. set bit is 1. unset bit is 0.\\n         while(n!=0){\\n             n = n & (n-1);\\n            ans++;\\n        }\\n \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55097,
                "title": "javascript-1-line",
                "content": "```\\nvar hammingWeight = function(n) {\\n    return n.toString(2).split(\"0\").join(\"\").length;\\n};",
                "solutionTags": [],
                "code": "```\\nvar hammingWeight = function(n) {\\n    return n.toString(2).split(\"0\").join(\"\").length;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1629020,
                "title": "java-c-simple-o-1-time-faster-than-100-detailed-explanation",
                "content": "# **Please Upvote if you find the solution helpful :)**\\n\\n**Refer to the following github repsitory for more leetcode solutions**\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n<u>**COMPLEXITY**</u>\\n* **Time: O(1)**, maximum number of possible signed bits in int type are 32, so O(32) ~ O(1)\\n* **Space: O(1)**, in-place\\n\\n<u>**BASIC IDEA**</u>\\n\\n* Using **Brian Kernighan Algorithm,** we will **not check/compare** or loop through all the 32 bits present but **only count the set bits** which is way better than checking all the 32 bits\\n* Suppose we have a number **00000000000000000000000000010110** (32 bits), now using this algorithm we will skip the 0\\'s bit and **directly jump to set bit(1\\'s bit)** and we don\\'t have to go through each bit to count set bits i.e. the loop will be executed **only for 3 times** for the mentioned example and **not for 32 times.**\\n\\n**<u>NOTE</u>: C++ CODE fluctates a lot from 0ms - 4ms**\\n<iframe src=\"https://leetcode.com/playground/TctjyQah/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\nAssume we are working for 8 bits for better understanding, but the same logic apply for 32 bits\\nSo, we will take a number having 3 set bits.\\n   `n   = 00010110`\\n`n - 1 = 00010101`(by substracting 1 from the number, all the bits gets flipped/toggled after the **rightmost set bit including the rightmost set bit itself. **\\nAfter applying &(bitwise AND) operator on n and n - 1 i.e. (n & n - 1), the **righmost set bit will be turned off/toggled/flipped**\\n\\nLet\\'s understand step by step\\n\\n* **1st Iteration**\\n&nbsp;&nbsp;&nbsp;`00010110` --> (22(n) in decimal)\\n&&nbsp;<u>`00010101`</u> --> (21(n - 1) in decimal i.e. **flipping all the bits** of n(22) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00010100` --> (20(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\n`n = 00010100` (20 in decimal)\\nand **increase the count**\\nbitCount++ (Initial bitCount = 0. By incrementing it, the bitCount = 1)\\n<hr>\\n\\n* **2nd Iteration**\\n&nbsp;&nbsp;&nbsp;`00010100` --> (20(n) in decimal)\\n&&nbsp;<u>`00010011`</u> --> (19(n - 1) in decimal i.e. **flipping all the bits** of n(20) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00010000` --> (16(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\nn = `00010000` (16 in decimal)\\nand **increase the count**\\nbitCount++ (previous bitCount = 1. By incrementing it, the bitCount = 2)\\n<hr>\\n\\n* **3rd Iteration**\\n&nbsp;&nbsp;&nbsp;`00010000` --> (16(n) in decimal)\\n&&nbsp;<u>`00001111`</u> --> (15(n - 1) in decimal i.e. **flipping all the bits** of n(16) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00000000` --> (0(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\nn = `00000000` (0 in decimal)\\nand **increase the count**\\nbitCount++ (previous bitCount = 2. By incrementing it, the bitCount = 3)\\n\\nNow, since the `n = 0`, there will be no furthur iteration as the condition becomes false, so it will come out of the loop and **return bitCount which is 3 which is desired output.**\\n\\n<hr>\\n\\n**Refer to the following github repsitory for more leetcode solutions**\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please Upvote if you find the solution helpful :)**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "# **Please Upvote if you find the solution helpful :)**\\n\\n**Refer to the following github repsitory for more leetcode solutions**\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n<u>**COMPLEXITY**</u>\\n* **Time: O(1)**, maximum number of possible signed bits in int type are 32, so O(32) ~ O(1)\\n* **Space: O(1)**, in-place\\n\\n<u>**BASIC IDEA**</u>\\n\\n* Using **Brian Kernighan Algorithm,** we will **not check/compare** or loop through all the 32 bits present but **only count the set bits** which is way better than checking all the 32 bits\\n* Suppose we have a number **00000000000000000000000000010110** (32 bits), now using this algorithm we will skip the 0\\'s bit and **directly jump to set bit(1\\'s bit)** and we don\\'t have to go through each bit to count set bits i.e. the loop will be executed **only for 3 times** for the mentioned example and **not for 32 times.**\\n\\n**<u>NOTE</u>: C++ CODE fluctates a lot from 0ms - 4ms**\\n<iframe src=\"https://leetcode.com/playground/TctjyQah/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\nAssume we are working for 8 bits for better understanding, but the same logic apply for 32 bits\\nSo, we will take a number having 3 set bits.\\n   `n   = 00010110`\\n`n - 1 = 00010101`(by substracting 1 from the number, all the bits gets flipped/toggled after the **rightmost set bit including the rightmost set bit itself. **\\nAfter applying &(bitwise AND) operator on n and n - 1 i.e. (n & n - 1), the **righmost set bit will be turned off/toggled/flipped**\\n\\nLet\\'s understand step by step\\n\\n* **1st Iteration**\\n&nbsp;&nbsp;&nbsp;`00010110` --> (22(n) in decimal)\\n&&nbsp;<u>`00010101`</u> --> (21(n - 1) in decimal i.e. **flipping all the bits** of n(22) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00010100` --> (20(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\n`n = 00010100` (20 in decimal)\\nand **increase the count**\\nbitCount++ (Initial bitCount = 0. By incrementing it, the bitCount = 1)\\n<hr>\\n\\n* **2nd Iteration**\\n&nbsp;&nbsp;&nbsp;`00010100` --> (20(n) in decimal)\\n&&nbsp;<u>`00010011`</u> --> (19(n - 1) in decimal i.e. **flipping all the bits** of n(20) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00010000` --> (16(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\nn = `00010000` (16 in decimal)\\nand **increase the count**\\nbitCount++ (previous bitCount = 1. By incrementing it, the bitCount = 2)\\n<hr>\\n\\n* **3rd Iteration**\\n&nbsp;&nbsp;&nbsp;`00010000` --> (16(n) in decimal)\\n&&nbsp;<u>`00001111`</u> --> (15(n - 1) in decimal i.e. **flipping all the bits** of n(16) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00000000` --> (0(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\nn = `00000000` (0 in decimal)\\nand **increase the count**\\nbitCount++ (previous bitCount = 2. By incrementing it, the bitCount = 3)\\n\\nNow, since the `n = 0`, there will be no furthur iteration as the condition becomes false, so it will come out of the loop and **return bitCount which is 3 which is desired output.**\\n\\n<hr>\\n\\n**Refer to the following github repsitory for more leetcode solutions**\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please Upvote if you find the solution helpful :)**",
                "codeTag": "Unknown"
            },
            {
                "id": 55140,
                "title": "intuitive-javascript-solution",
                "content": "```\\nvar hammingWeight = function(n) {\\n    // remove 0s from base2 representation of the number\\n    return n.toString(2).replace(/0/g, '').length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hammingWeight = function(n) {\\n    // remove 0s from base2 representation of the number\\n    return n.toString(2).replace(/0/g, '').length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55217,
                "title": "4ms-1-line-c-solution",
                "content": "     int hammingWeight(uint32_t n) {\\n        return n == 0 ? 0 : 1 + hammingWeight(n & (n - 1));\\n    }",
                "solutionTags": [],
                "code": "     int hammingWeight(uint32_t n) {\\n        return n == 0 ? 0 : 1 + hammingWeight(n & (n - 1));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2074228,
                "title": "c-one-line-of-code",
                "content": "```\\n__builtin_popcount(n): returns number of set bits in n.\\n```\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return __builtin_popcount(n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n__builtin_popcount(n): returns number of set bits in n.\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return __builtin_popcount(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412923,
                "title": "c-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        \\n        uint8_t count = 0;\\n        for(uint8_t i = 0; i<32; ++i)\\n        {\\n            uint8_t bit = (n >> i) & 1;\\n            if(bit)\\n                count++;\\n        }\\n\\n        return (int)count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        \\n        uint8_t count = 0;\\n        for(uint8_t i = 0; i<32; ++i)\\n        {\\n            uint8_t bit = (n >> i) & 1;\\n            if(bit)\\n                count++;\\n        }\\n\\n        return (int)count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55319,
                "title": "the-fastest-c-solution-o-log-n-time-o-1-space",
                "content": "    int hammingWeight(uint32_t n) {\\n        int res =0;\\n        while (n!=0)\\n        {\\n            n = n & (n-1);\\n            res++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    int hammingWeight(uint32_t n) {\\n        int res =0;\\n        while (n!=0)\\n        {\\n            n = n & (n-1);\\n            res++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2482831,
                "title": "python-easy-solution",
                "content": "```\\ndef hammingWeight(self, n: int) -> int: # n = 00000000000000000000000000001011\\n        return bin(n).count(\"1\")    # bin(n) = 0b1011\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef hammingWeight(self, n: int) -> int: # n = 00000000000000000000000000001011\\n        return bin(n).count(\"1\")    # bin(n) = 0b1011\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 377550,
                "title": "python-multiple-solutions-including-o-1",
                "content": "# Using masking\\nThe idea here is that you use masking to count number of bits in every 2 bits, then in every 4 bits and so on.\\n\\n## Example\\n\\nLets say we want to compute the number of bits in a 4 bit number to simplify things\\n```python\\nmask_sum_2bit = 0x5 => 0101\\nx = 0b1010\\n\\n# Count number of bits in every consecutive 2 bits\\n\\nx                           =>  1010\\nx & mask_sum_2bit           =>  0000\\nx >> 1                      =>  0101\\nx >> 1 & mask_sum_2bit      =>  0101\\nx = (x & mask_sum_2bit) + (x >> 1 & mask_sum_2bit ) =>  0101 # Result of computing the number of bits in every consecutive 2 bits\\n\\nmask_sum_4bit = 0x3 => 0011\\n\\nx                      => 0101\\nx & mask_sum_4bit      => 0001\\nx >> 2                 => 0001\\nx >> 2 & mask_sum_4bit => 0001\\nx = (x & mask_sum_4bit) + (x >> 2 & mask_sum_4bit) => 0010 # Result of computing the number of bits in every consecutive 4 bits\\n```\\n\\n\\n## Implementation\\n\\n```python\\nclass Solution(object):\\n    def hammingWeight(self, n):\\n\\t\\n        mask_sum_2bit = 0x55555555\\n        mask_sum_4bit = 0x33333333\\n        mask_sum_8bit = 0x0F0F0F0F\\n        mask_sum_16bit = 0x00FF00FF\\n        mask_sum_32bit = 0x0000FFFF\\n        \\n        n = (n & mask_sum_2bit) + ((n >> 1) & mask_sum_2bit)\\n        n = (n & mask_sum_4bit) + ((n >> 2) & mask_sum_4bit)\\n        n = (n & mask_sum_8bit) + ((n >> 4) & mask_sum_8bit)\\n        n = (n & mask_sum_16bit) + ((n >> 8) & mask_sum_16bit)\\n        n = (n & mask_sum_32bit) + ((n >> 16) & mask_sum_32bit)\\n        \\n        return n\\n```\\n\\n# Kernighan way\\n\\n```python\\nclass Solution(object):\\n    def hammingWeight(self, n):\\n\\n        count = 0\\n        while n:\\n            count += 1\\n            n = n & (n - 1)\\n        \\n        return count\\n```\\n\\nThis exploits the fact that `n` and `n - 1` have the the same bits up to the lower order bit set in `n`. This leads `n & (n - 1)` to unset the lower order bit set in `n`.\\n\\nIf you are still confused lets take an example:\\n\\n```python\\nx = 0b1100 => 12\\ncount = 0\\n\\n# First iteration\\nx           => 1100\\nx - 1       => 1011\\nx & (x - 1) => 1000\\ncount += 1\\n\\n# Second iteration\\nx           => 1000\\nx - 1       => 0111\\nx & (x - 1) => 0000\\ncount += 1\\n\\n# We stop here as x is now 0\\n\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nmask_sum_2bit = 0x5 => 0101\\nx = 0b1010\\n\\n# Count number of bits in every consecutive 2 bits\\n\\nx                           =>  1010\\nx & mask_sum_2bit           =>  0000\\nx >> 1                      =>  0101\\nx >> 1 & mask_sum_2bit      =>  0101\\nx = (x & mask_sum_2bit) + (x >> 1 & mask_sum_2bit ) =>  0101 # Result of computing the number of bits in every consecutive 2 bits\\n\\nmask_sum_4bit = 0x3 => 0011\\n\\nx                      => 0101\\nx & mask_sum_4bit      => 0001\\nx >> 2                 => 0001\\nx >> 2 & mask_sum_4bit => 0001\\nx = (x & mask_sum_4bit) + (x >> 2 & mask_sum_4bit) => 0010 # Result of computing the number of bits in every consecutive 4 bits\\n```\n```python\\nclass Solution(object):\\n    def hammingWeight(self, n):\\n\\t\\n        mask_sum_2bit = 0x55555555\\n        mask_sum_4bit = 0x33333333\\n        mask_sum_8bit = 0x0F0F0F0F\\n        mask_sum_16bit = 0x00FF00FF\\n        mask_sum_32bit = 0x0000FFFF\\n        \\n        n = (n & mask_sum_2bit) + ((n >> 1) & mask_sum_2bit)\\n        n = (n & mask_sum_4bit) + ((n >> 2) & mask_sum_4bit)\\n        n = (n & mask_sum_8bit) + ((n >> 4) & mask_sum_8bit)\\n        n = (n & mask_sum_16bit) + ((n >> 8) & mask_sum_16bit)\\n        n = (n & mask_sum_32bit) + ((n >> 16) & mask_sum_32bit)\\n        \\n        return n\\n```\n```python\\nclass Solution(object):\\n    def hammingWeight(self, n):\\n\\n        count = 0\\n        while n:\\n            count += 1\\n            n = n & (n - 1)\\n        \\n        return count\\n```\n```python\\nx = 0b1100 => 12\\ncount = 0\\n\\n# First iteration\\nx           => 1100\\nx - 1       => 1011\\nx & (x - 1) => 1000\\ncount += 1\\n\\n# Second iteration\\nx           => 1000\\nx - 1       => 0111\\nx & (x - 1) => 0000\\ncount += 1\\n\\n# We stop here as x is now 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55112,
                "title": "python-one-line-solution",
                "content": "    def hammingWeight(self, n): \\n           return str(bin(n)).count('1')",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def hammingWeight(self, n): \\n           return str(bin(n)).count('1')",
                "codeTag": "Python3"
            },
            {
                "id": 1972706,
                "title": "sss-swift-simple-solutions-4-different-approaches",
                "content": "**Binary Arithmetic Approach**\\n\\n```\\nfunc hammingWeight(_ n: Int) -> Int {\\n\\tvar n = n, result = 0\\n\\twhile n != 0 {\\n\\t\\tresult += n % 2\\n\\t\\tn /= 2\\n\\t}\\n\\treturn result\\n}\\n```\\n\\n**Binary Shift Approach**\\n\\n```\\nfunc hammingWeight(_ n: Int) -> Int {\\n\\tvar n = n, result = 0\\n\\twhile n != 0 {\\n\\t\\tresult += n & 1\\n\\t\\tn >>= 1\\n\\t}\\n\\treturn result\\n}\\n```\\n\\n**Magic way**\\n\\nhttps://stackoverflow.com/questions/4678333/n-n-1-what-does-this-expression-do\\n\\n```\\nfunc hammingWeight(_ n: Int) -> Int {\\n\\tvar n = n, result = 0\\n\\twhile n != 0 {\\n\\t\\tresult += 1\\n\\t\\tn &= n - 1 // NOTE: look at https://stackoverflow.com/questions/4678333/\\n\\t}\\n\\treturn result\\n}\\n```\\n\\n**Cheater way**\\n\\n```\\nfunc hammingWeight(_ n: Int) -> Int {\\n\\tn.nonzeroBitCount\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc hammingWeight(_ n: Int) -> Int {\\n\\tvar n = n, result = 0\\n\\twhile n != 0 {\\n\\t\\tresult += n % 2\\n\\t\\tn /= 2\\n\\t}\\n\\treturn result\\n}\\n```\n```\\nfunc hammingWeight(_ n: Int) -> Int {\\n\\tvar n = n, result = 0\\n\\twhile n != 0 {\\n\\t\\tresult += n & 1\\n\\t\\tn >>= 1\\n\\t}\\n\\treturn result\\n}\\n```\n```\\nfunc hammingWeight(_ n: Int) -> Int {\\n\\tvar n = n, result = 0\\n\\twhile n != 0 {\\n\\t\\tresult += 1\\n\\t\\tn &= n - 1 // NOTE: look at https://stackoverflow.com/questions/4678333/\\n\\t}\\n\\treturn result\\n}\\n```\n```\\nfunc hammingWeight(_ n: Int) -> Int {\\n\\tn.nonzeroBitCount\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55394,
                "title": "my-10ms-c-solution-using-bit-operation",
                "content": "    class Solution {\\n    public:\\n        int hammingWeight(uint32_t n) {\\n            int ans = 0;\\n            while (n) {\\n                n &= (n-1);\\n                ans++;\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int hammingWeight(uint32_t n) {\\n            int ans = 0;\\n            while (n) {\\n                n &= (n-1);\\n                ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2417856,
                "title": "java-simple-solution-bit-shifting",
                "content": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n      int count = 0;\\n      while(n != 0) {\\n        count += (n & 1);\\n        n = n >>> 1;\\n      }\\n      return count;\\n    }\\n}\\n```\\n\\nAn Integer in Java has 32 bits, e.g. 00101000011110010100001000011010.\\nTo count the 1s in the Integer representation we put the input int\\nn in bit AND with 1 (that is represented as\\n00000000000000000000000000000001, and if this operation result is 1,\\nthat means that the last bit of the input integer is 1. Thus we add it to the 1s count.\\nones = ones + (n & 1);\\n\\nThen we shift the input Integer by one on the right, to check for the\\nnext bit.\\nn = n>>>1;\\n\\nWe need to use bit shifting unsigned operation >>> (while >> depends on sign extension)\\n\\nWe keep doing this until the input Integer is 0.\\nIn Java we need to put attention on the fact that the maximum integer is 2147483647. Integer type in Java is signed and there is no unsigned int. So the input 2147483648 is represented in Java as -2147483648 (in java int type has a cyclic representation, that means Integer.MAX_VALUE+1==Integer.MIN_VALUE).\\nThis force us to use\\n\\nn!=0\\n\\nin the while condition and we cannot use\\n\\nn>0\\n\\nbecause the input 2147483648 would correspond to -2147483648 in java and the code would not enter the while if the condition is n>0 for n=2147483648.\\n\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n      int count = 0;\\n      while(n != 0) {\\n        count += (n & 1);\\n        n = n >>> 1;\\n      }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881242,
                "title": "java-2ms-o-n-easy-and-simple-solution",
                "content": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String num = Integer.toBinaryString(n); //build in function in java to convert Integer to Binary String \\n        int count=0;\\n        for(char ch:num.toCharArray()){\\n            if(ch==\\'1\\')\\n                count++; //just counting the number of 1\\'s\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Perform a dry run for better understanding !\\nHappy Coding !\\nDo Upvote if it helped !**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String num = Integer.toBinaryString(n); //build in function in java to convert Integer to Binary String \\n        int count=0;\\n        for(char ch:num.toCharArray()){\\n            if(ch==\\'1\\')\\n                count++; //just counting the number of 1\\'s\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186879,
                "title": "java-easy-and-explained-solution-speed-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution involves a simple **iteration of the integer**, we can achive this result by using **Bitwise and Bitshift** operators [i.e. & and >>>] (*Look the note section for other technique*). These operators are faster, give you a precise control over individual bits of a number and are kinda cute when you understand them :D \\n\\n*At each iteration* we have to do Three operations:\\n1) If the **number is odd** there is a \\'1\\' in the last right position, we have to count it;\\n2) **Shift the number** right by one position, it will remove the most right \\'1\\' and add a \\'0\\' at the most left position;\\n3) If the **number is zero** this mean I have no other one to fint.\\n\\n**Note:** Is possible to solve the problem using a **simpler approach** such as `n % 2 == 0` to check if the last bit is zero or one and using `n = n / 2` to make the shift.\\n \\n**Bitwise AND (&):** It returns bit by bit AND of input values [i.e. if both bits are 1, it gives 1, else it shows 0].\\n**Unsigned Right shift operator (>>>):** Is used to shift the bits of a number right, thereby dividing the number by two. (From left add zeros)\\n\\n# Complexity\\n- **Time complexity:** $O(n)$\\n- **Speed Beats:** 100%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:** $O(1)$\\n- **Memory Beats:** 94.18%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        \\n        int count = 0;\\n\\n        while (n != 0) {\\n            \\n            // Check if the number is odd\\n            if ((n & 1) == 1)\\n                count++;\\n            \\n            n = n >>> 1;\\n        }\\n            \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        \\n        int count = 0;\\n\\n        while (n != 0) {\\n            \\n            // Check if the number is odd\\n            if ((n & 1) == 1)\\n                count++;\\n            \\n            n = n >>> 1;\\n        }\\n            \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648157,
                "title": "rust-one-liner-popcnt-solution",
                "content": "This problem is equivelent to the famous popcnt instruction, e.g count the number of ones in a binary number. This is a realitivley foundamental operation and has hardware support on (most modern) cpus.\\n\\nThe promissed one line solution comes as a standard function for i32 \\n\\n```rust\\npub fn hammingWeight (n: u32) -> i32 {\\n        n.count_ones() as i32\\n}\\n```\\n\\nIf we look at the diassembly we see that this is acutally only rellying on a single popcnt instruction and some movs.  This is assembly taken from this [godbolt](https://godbolt.org/z/WfYE8aYnv) session with the rust 1.57 compiler targetting haswell cpus.\\n\\n```asm\\nexample::hammingWeight:\\n        push    rax\\n        popcnt  eax, edi ; HERE is the main show\\n        mov     dword ptr [rsp + 4], eax\\n        mov     eax, dword ptr [rsp + 4]\\n        mov     dword ptr [rsp], eax\\n        mov     eax, dword ptr [rsp]\\n        pop     rcx\\n        ret\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\npub fn hammingWeight (n: u32) -> i32 {\\n        n.count_ones() as i32\\n}\\n```\n```asm\\nexample::hammingWeight:\\n        push    rax\\n        popcnt  eax, edi ; HERE is the main show\\n        mov     dword ptr [rsp + 4], eax\\n        mov     eax, dword ptr [rsp + 4]\\n        mov     dword ptr [rsp], eax\\n        mov     eax, dword ptr [rsp]\\n        pop     rcx\\n        ret\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1044847,
                "title": "python-simple-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef hammingWeight(self, n: int) -> int:\\n\\t\\t\\tans = 0\\n\\t\\t\\twhile n:\\n\\t\\t\\t\\tans += n % 2\\n\\t\\t\\t\\tn = n >> 1\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef hammingWeight(self, n: int) -> int:\\n\\t\\t\\tans = 0\\n\\t\\t\\twhile n:\\n\\t\\t\\t\\tans += n % 2\\n\\t\\t\\t\\tn = n >> 1\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 542786,
                "title": "python-very-simple-12ms-beats-99-98",
                "content": "**Code:**\\n```\\ndef hammingWeight(self, n: int) -> int:\\n        return sum((n>>i&1 for i in range(32)))\\n```\\n\\n**Explanation:**\\nUse bitwise operations:\\n- `&1` returns 1 if the last bit of the result of `n>>i` == 1, else 0\\n- By using `n>>i`, we shift the bits to the right by i places\\n- this way, every bit of n is the  \\'last bit\\' of `n>>i` at one point\\n- sum up the number of 1s that we found that way",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef hammingWeight(self, n: int) -> int:\\n        return sum((n>>i&1 for i in range(32)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2792326,
                "title": "java-4-solutions-bit-manipulation-string-easy",
                "content": "### **Please Upvote** :D\\n##### *Bit Manipulation approaches:*\\n##### Approach 1:\\n```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n\\n        for (int i = 0; i < 32; i++) {\\n            count += n & 1;\\n            n >>= 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(1)\\n```\\n##### Approach 2:\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(1)\\n```\\n##### Approach 3:\\n```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n\\n        while (n != 0) {\\n            count += n & 1;\\n            n >>>= 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(1)\\n```\\n##### *Converting Binary input to String:*\\nWe remove all 0s from the string and return the length of the remaining string which would contain only 1s.\\n```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n).replaceAll(\"0\", \"\");\\n        return s.length();\\n    }\\n}\\n\\n// TC: O(N * logN) => O(32 * log32) => O(1\\n// N -> number of bits\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n\\n        for (int i = 0; i < 32; i++) {\\n            count += n & 1;\\n            n >>= 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(1)\\n```\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(1)\\n```\n```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n\\n        while (n != 0) {\\n            count += n & 1;\\n            n >>>= 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(1)\\n```\n```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n).replaceAll(\"0\", \"\");\\n        return s.length();\\n    }\\n}\\n\\n// TC: O(N * logN) => O(32 * log32) => O(1\\n// N -> number of bits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716328,
                "title": "a-simple-solution-in-java-0-ms",
                "content": "```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        return Integer.bitCount(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        return Integer.bitCount(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650429,
                "title": "100-faster-without-bit-manipulation-optimal",
                "content": "![image](https://assets.leetcode.com/users/images/2d9ebd17-0471-4798-9da4-93e3d7b8c1d4_1664704138.696063.png)\\n![image](https://assets.leetcode.com/users/images/b5c67aad-9a56-4b6e-b398-779b3b4511ce_1664704208.2583528.gif)\\n\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        while(n > 0)\\n        {\\n            if(n%2==1)ans++;\\n            n /= 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        while(n > 0)\\n        {\\n            if(n%2==1)ans++;\\n            n /= 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578463,
                "title": "python-one-line-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef hammingWeight(self, n: int) -> int:\\n\\treturn bin(n).count(\\'1\\')\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef hammingWeight(self, n: int) -> int:\\n\\treturn bin(n).count(\\'1\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1127507,
                "title": "recursive-one-liner-with-bits",
                "content": "TC/SC-O(1) Constant\\n```const hammingWeight = n => (n === 0) ? 0 : 1 + hammingWeight(n &= n - 1);```\\n\\n**Notes**\\nCheckout my follow up post [338. Counting Bits](https://leetcode.com/problems/counting-bits/discuss/1127579/Bits-One-liner-w-Recursive-helper-func) Medium problem that utilizes this one liner.\\nBit Manipulation utilizing the [Brian Kernighan\\'s Algorithm](https://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/) and refactored to use recursion.  \\n\\nBase case: ```if (n === 0) return 0;```\\nRecusive case:  ```1 + hammingWeight(n &= n - 1);```\\nUnset rightmost set bit aka flip ```1``` to ```0```: ```n &= n - 1``` aka ```n = n & (n - 1)```\\nEasier to understand, non-one liner: \\n```\\nvar hammingWeight = function(n) {\\n  if (n === 0) return 0;\\n  return 1 + hammingWeight(n &= n - 1);\\n};\\n```\\n\\n**Happy LeetCoding!**\\n*Please upvote this post\\n*Comments welcomed \\n*Positivity encouraged \\n*You\\'ve got this!",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```const hammingWeight = n => (n === 0) ? 0 : 1 + hammingWeight(n &= n - 1);```\n```if (n === 0) return 0;```\n```1 + hammingWeight(n &= n - 1);```\n```1```\n```0```\n```n &= n - 1```\n```n = n & (n - 1)```\n```\\nvar hammingWeight = function(n) {\\n  if (n === 0) return 0;\\n  return 1 + hammingWeight(n &= n - 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55233,
                "title": "2-ms-java-solution-5-lines-of-code",
                "content": "    public class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int i = 0;\\n            while(n!=0) {\\n                n&= n-1;\\n                i++;\\n            }\\n            return i;\\n        } \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int i = 0;\\n            while(n!=0) {\\n                n&= n-1;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3762297,
                "title": "solution-with-while-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            if n%2==1:\\n                count+=1\\n            n=n//2\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            if n%2==1:\\n                count+=1\\n            n=n//2\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762293,
                "title": "solution-with-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        def bit(n,count):\\n            if n==0:\\n                return count \\n            if n%2==0:\\n                return bit(n//2,count)\\n            else:\\n                return bit(n//2,count+1)\\n\\n        return bit(n,0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        def bit(n,count):\\n            if n==0:\\n                return count \\n            if n%2==0:\\n                return bit(n//2,count)\\n            else:\\n                return bit(n//2,count+1)\\n\\n        return bit(n,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074440,
                "title": "c-1-line-vs-5-lines-o-1",
                "content": "**Time Complexity : O(1)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\n\\tpublic:\\n\\tint hammingWeight(uint32_t n) { // function to count the number of 1s in a 32-bit integer\\n        return __builtin_popcount(n); // built-in function to count the number of 1s in a 32-bit integer\\n\\t}\\n};\\n```\\n**Time Complexity : O(1)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\n\\tpublic:\\n\\tint hammingWeight(uint32_t n) { // function to count the number of 1s in a 32-bit integer\\n        // bitset<32>() is a class that can be used to convert an integer to a bitset of 32 bits \\n        // bitset<32>().count() is a function that counts the number of 1s in a bitset \\n        return bitset<32>(n).count(); \\n\\t}\\n};\\n```\\n**Time Complexity : O(1)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) { // function to count the number of 1s in a 32-bit integer\\n        int count=0; // initialize count to 0\\n        while(n){ // while n is not 0\\n            n=n&(n-1); // set the least significant bit to 0\\n            count++; // increment count\\n        }\\n        return count; // return count\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic:\\n\\tint hammingWeight(uint32_t n) { // function to count the number of 1s in a 32-bit integer\\n        return __builtin_popcount(n); // built-in function to count the number of 1s in a 32-bit integer\\n\\t}\\n};\\n```\n```\\nclass Solution {\\n\\tpublic:\\n\\tint hammingWeight(uint32_t n) { // function to count the number of 1s in a 32-bit integer\\n        // bitset<32>() is a class that can be used to convert an integer to a bitset of 32 bits \\n        // bitset<32>().count() is a function that counts the number of 1s in a bitset \\n        return bitset<32>(n).count(); \\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) { // function to count the number of 1s in a 32-bit integer\\n        int count=0; // initialize count to 0\\n        while(n){ // while n is not 0\\n            n=n&(n-1); // set the least significant bit to 0\\n            count++; // increment count\\n        }\\n        return count; // return count\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045263,
                "title": "number-of-1-bits-explanation-of-3-increasingly-faster-solutions-generalization",
                "content": "Simple problem of counting the number of bits in a 32-bit integer. For people interested in different ways to achieve this there is a lot of information in [Bit Twiddling Hacks by Sean Eron Anderson](https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetNaive).\\n\\nI tried Three Solutions:\\n1. Brute force, test each bit if a 1 or a 0. O(#bits) time O(1) space\\n2. Kernighan approach, count lowest set bit each time. O(#set bits) time O(1) space\\n3. Lookup approach, create a lookup table for segments of the input. O(#segements) time O(segment size) space\\n\\nThe solutions with code are at the bottom of this post.\\n\\nThe problem explicitly states it is a 32-bit number so technically  all the solutions are constant bounded so O(1) for both time and space.\\nHowever I do think it is worth considering how to solve the problem in the face of potentially changing requirements. For example what happens if number of bits is now 64, how does that effect time taken? In this case stating a complexity in terms of bits is helpful, particularly as the second solution is O(#bits set) while the first solution is O(bits).\\nTo conclude, strictly speaking this is O(1) solution, but when considering possible extensions to the problem then giving complexity in terms of number of bits is worthwhile, particularly if it gets extended to counting bits in a PKI solution with 2,048 bit keys for example.\\n\\n**Solution 1 - Brute Force**\\nThis always takes constant time based on the number of bits (for the problem 32).\\n* For each bit\\n\\t* make it the first bit in the integer by shifting it right.\\n\\t* And it with 1 and add result to count\\n* Return count\\n\\n**Time is O(#bits)**\\n```\\n// Brute Force\\n// O(32 >= # Set Bits) = O(1)\\npublic int hammingWeight(int n) {\\n\\tint count = 0;\\n\\tfor (int i=0; i<32; i++)\\n\\t\\tcount += (n>>i) & 1;\\n\\treturn count;\\n}\\n```\\n\\n**Solution 2 - Kernighan Approach**\\nThis uses a method attributed to Brian Kernighan of C fame. Basically it relies on the fact that if you subtract 1 from a binary number you flip the least significant set bit from 0 to 1 and set all the bits lower to 1. When we and the result of this operation with the original number we have removed the lowest set bit from the number.\\nThis takes time dependent on the number of set bits in a number.\\n* While number is not zero\\n\\t* Increment count\\n\\t* remove lowest set bit by subtracting 1 from number and anding it with the original number.\\n* Return count\\n\\n**Time is O(#set bits)**\\n```\\n// Kernighan Algorithm\\n// O(# Set Bits)\\npublic int hammingWeight(int n) {\\n\\tint count = 0;\\n\\twhile (n != 0) {\\n\\t\\tcount++;\\n\\t\\tn = n&(n-1);\\n\\t}\\n\\treturn count;\\n}\\n```\\n\\n**Solution 3 - Lookup Table**\\nWe could speed things up more by having a lookup table that maps the number directly to the number of bits. Obviously it is not practical to store all 2^32 possible values so we store smaller segments. The example below uses 8-bit chunks.\\nThis takes time dependent on the number of segments so we can trade off pace for time, larger segment is more space but faster.\\nThe algorithm has two parts, a pre-compute run once to generate the lookup table, and a per-request loop to calculate the number of bits.\\n* Pre-Compute Run Once\\n\\t* Iterate over all values in a segement (0..2^(segement_bits-1))\\n\\t\\t* count for value = lowest bit (and with 0x01) + count for value / 2\\n* Calculate Number 1 Bits\\n\\t* Iterate over number in segement sizes\\n\\t\\t* Add lookup of number of bits to count\\n\\t* Return count\\n\\n**Time is O(bits/segment size in bits) Space is O(2<<segment size in bits)**\\n```\\n// Lookup Approach\\n// O(32/LOOKUP_SIZE_BITS)\\nstatic final int LOOKUP_SIZE_BITS = 8;\\nstatic final int LOOKUP_TABLE_SIZE = 1<<LOOKUP_SIZE_BITS;\\nstatic final int LOOKUP_MASK = LOOKUP_TABLE_SIZE-1;\\nstatic final int LOOKUP_LOOPS = 32/LOOKUP_SIZE_BITS;\\nstatic int[] lookup = new int[LOOKUP_TABLE_SIZE];\\nstatic {\\n\\tfor (int i=0; i<LOOKUP_TABLE_SIZE; i++)\\n\\t\\tlookup[i] = (i&1) + lookup[i/2];\\n}\\npublic int hammingWeight(int n) {\\n\\tint count = 0;\\n\\tfor (int i=0; i<LOOKUP_LOOPS; i++) {\\n\\t\\tcount += lookup[n&LOOKUP_MASK];\\n\\t\\tn = n>>LOOKUP_SIZE_BITS;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Brute Force\\n// O(32 >= # Set Bits) = O(1)\\npublic int hammingWeight(int n) {\\n\\tint count = 0;\\n\\tfor (int i=0; i<32; i++)\\n\\t\\tcount += (n>>i) & 1;\\n\\treturn count;\\n}\\n```\n```\\n// Kernighan Algorithm\\n// O(# Set Bits)\\npublic int hammingWeight(int n) {\\n\\tint count = 0;\\n\\twhile (n != 0) {\\n\\t\\tcount++;\\n\\t\\tn = n&(n-1);\\n\\t}\\n\\treturn count;\\n}\\n```\n```\\n// Lookup Approach\\n// O(32/LOOKUP_SIZE_BITS)\\nstatic final int LOOKUP_SIZE_BITS = 8;\\nstatic final int LOOKUP_TABLE_SIZE = 1<<LOOKUP_SIZE_BITS;\\nstatic final int LOOKUP_MASK = LOOKUP_TABLE_SIZE-1;\\nstatic final int LOOKUP_LOOPS = 32/LOOKUP_SIZE_BITS;\\nstatic int[] lookup = new int[LOOKUP_TABLE_SIZE];\\nstatic {\\n\\tfor (int i=0; i<LOOKUP_TABLE_SIZE; i++)\\n\\t\\tlookup[i] = (i&1) + lookup[i/2];\\n}\\npublic int hammingWeight(int n) {\\n\\tint count = 0;\\n\\tfor (int i=0; i<LOOKUP_LOOPS; i++) {\\n\\t\\tcount += lookup[n&LOOKUP_MASK];\\n\\t\\tn = n>>LOOKUP_SIZE_BITS;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55162,
                "title": "one-line-c",
                "content": "```\\npublic int HammingWeight(uint n) {\\n        return Convert.ToString(n,2).Replace(\"0\",\"\").Length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int HammingWeight(uint n) {\\n        return Convert.ToString(n,2).Replace(\"0\",\"\").Length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55254,
                "title": "right-bit-shift-in-place-simple-java-solution",
                "content": "    public class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int count = 0;\\n            for(int i = 0; i < 32; i++){  \\n                if ((n & 1) == 1) count++;\\n                n >>= 1;\\n            }\\n            return count;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int count = 0;\\n            for(int i = 0; i < 32; i++){  \\n                if ((n & 1) == 1) count++;\\n                n >>= 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 55265,
                "title": "bit-shifting-solution-using-java",
                "content": "I start by looking at each of the 32 bits for the int value and use `1 << i` to check each bit for 1.\\n\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        for(int i = 0; i < 32; i++) {\\n            if(((1 << i) & n) != 0) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "I start by looking at each of the 32 bits for the int value and use `1 << i` to check each bit for 1.\\n\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        for(int i = 0; i < 32; i++) {\\n            if(((1 << i) & n) != 0) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 55393,
                "title": "one-line-and-clearly-solution-java",
                "content": "Each time n & (n - 1) reduce an '1', here is the code:\\n\\n    public class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            return n == 0 ? 0 : 1 + hammingWeight(n & (n - 1));\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            return n == 0 ? 0 : 1 + hammingWeight(n & (n - 1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3267115,
                "title": "c-easy-solution-beats-100",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing **Right Shift & And operator**\\nAnd operator checks the first bit from the right, \\nRight Shift shifts one bit to the right.\\n> These are bitwise operators they don\\'t operate on entire numbers, these work bit-by-bit. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) \\n    {\\n        \\n        int count = 0 ;\\n        while (n != 0)\\n        {\\n            if(n & 1)\\n            {\\n                count ++ ;\\n            }\\n            n = n >> 1 ;\\n        }        \\n        return count ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/4820e9ad-f033-4fb6-995b-06ce0be9517f_1678166340.7738085.png)\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) \\n    {\\n        \\n        int count = 0 ;\\n        while (n != 0)\\n        {\\n            if(n & 1)\\n            {\\n                count ++ ;\\n            }\\n            n = n >> 1 ;\\n        }        \\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618943,
                "title": "java-solution-in-o-n-simple-bit-shifting",
                "content": "```\\n\\t\\tint count  = 0;\\n        for(int i = 0; i < 32; i++) {\\n            int mask = (1 << i);\\n            if((n & mask) != 0) count++;\\n        }\\n        \\n        return count;\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\t\\tint count  = 0;\\n        for(int i = 0; i < 32; i++) {\\n            int mask = (1 << i);\\n            if((n & mask) != 0) count++;\\n        }\\n        \\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2074207,
                "title": "c-solution-from-brute-force-to-inbuilt",
                "content": "**C++ Solution From Brute Force to Optimized and Inbuilt**\\n* First :-> Brute force:\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {int ans=0;\\n        for(int i=0;i<=31;i++){\\n            if(n%2)ans++;n/=2;\\n        }return ans;\\n    }\\n};\\n```\\n* Second :-> Optimized:\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans=0;\\n        while(n){\\n            n&=n-1;\\n            ans++;\\n        }                           \\n       return ans;\\n    }\\n};\\n```\\n* Third :-> Inbuilt Function:\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n);\\n    }\\n};\\n```\\n**Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {int ans=0;\\n        for(int i=0;i<=31;i++){\\n            if(n%2)ans++;n/=2;\\n        }return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans=0;\\n        while(n){\\n            n&=n-1;\\n            ans++;\\n        }                           \\n       return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956599,
                "title": "c-faster-than-100-0ms-bit-manipulation-diagrammatic-representation",
                "content": "**Explanation**\\n\\n* Set the count to zero.\\n* If n is greater than 0, it means it enters the while loop.\\n* It uses the bitwise And operator(&) to check if n ==1.\\n* If it is true, it means increaments count value.\\n* Shifts the n value to the right extent using the right shift operator.\\n* Finally, return the counted value.\\n\\n***Diagrammatic representation***\\n\\t![image](https://assets.leetcode.com/users/images/0add3b48-7733-4aa9-88c6-901a40a912df_1650185867.5690596.png)\\n \\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n        while(n>0){\\n            if(n&1)\\n                count++;\\n            n=n>>1;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nIf you find this solution useful, kindly **upvote** it.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n        while(n>0){\\n            if(n&1)\\n                count++;\\n            n=n>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921847,
                "title": "four-js-solutions",
                "content": "\\n1) A more JavaScripty approach with `match`\\n```\\n   return n.toString(2).match(/1/g)?.length ?? 0; \\n```\\n2) A more JavaScripty approach with `replace`\\n```\\n   return n.toString(2).replace(/0/g, \\'\\').length; \\n```\\n3) Bit left shift\\n```\\n  let res = 0;\\n  let cur = 1;\\n  for (let i = 0; i < 32; i++) {\\n    if ((n & cur) !== 0) {\\n      res++;\\n    }\\n    cur = cur << 1;\\n  }\\n  return res;\\n```\\n4) Bit trick with n & n - 1\\n```    \\n    let sum = 0;\\n    while (n) {\\n        sum++;\\n        n &= (n - 1);\\n    }\\n    return sum;\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n   return n.toString(2).match(/1/g)?.length ?? 0; \\n```\n```\\n   return n.toString(2).replace(/0/g, \\'\\').length; \\n```\n```\\n  let res = 0;\\n  let cur = 1;\\n  for (let i = 0; i < 32; i++) {\\n    if ((n & cur) !== 0) {\\n      res++;\\n    }\\n    cur = cur << 1;\\n  }\\n  return res;\\n```\n```    \\n    let sum = 0;\\n    while (n) {\\n        sum++;\\n        n &= (n - 1);\\n    }\\n    return sum;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736862,
                "title": "swift-using-nonzerobitcount-property",
                "content": "May not be in the spirit of this challenge, but for those unaware.\\n```\\n    func hammingWeight(_ n: Int) -> Int {\\n        return n.nonzeroBitCount\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    func hammingWeight(_ n: Int) -> Int {\\n        return n.nonzeroBitCount\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 285270,
                "title": "golang-faster-than-100",
                "content": "```\\nfunc hammingWeight(num uint32) int {\\n    val := 0\\n    for num > 0 {\\n        val += int(num & 1)\\n        num = num >> 1\\n    }\\n    return val\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc hammingWeight(num uint32) int {\\n    val := 0\\n    for num > 0 {\\n        val += int(num & 1)\\n        num = num >> 1\\n    }\\n    return val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168853,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def hammingWeight(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        while n > 0:\\n            n, r = divmod(n,2)\\n            if r == 1:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def hammingWeight(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        while n > 0:\\n            n, r = divmod(n,2)\\n            if r == 1:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55227,
                "title": "easy-java-solution",
                "content": "The trick is you check the last bit of n by performing ```n & 1 ``` and add it to result. Then perform unsigned right shift ```>>>``` until n becomes 0.\\n\\n    public int hammingWeight(int n) {\\n       int result = 0;\\n       while(n != 0) { \\n          result += (n & 1);\\n          n >>>= 1;\\n       }\\n       return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```n & 1 ```\n```>>>```",
                "codeTag": "Unknown"
            },
            {
                "id": 55266,
                "title": "3-line-java-solution",
                "content": "\\n    public int hammingWeight(int n) {\\n        String integer = Integer.toBinaryString(n);\\n        integer = integer.replaceAll(\"0\",\"\");\\n        return integer.length();\\n    }",
                "solutionTags": [],
                "code": "\\n    public int hammingWeight(int n) {\\n        String integer = Integer.toBinaryString(n);\\n        integer = integer.replaceAll(\"0\",\"\");\\n        return integer.length();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 55298,
                "title": "java-3-liner-only-iterates-for-1-bits",
                "content": "    public int hammingWeight(int n) {\\n        int i;\\n        for(i=0;n!=0;i++, n&=(n-1));\\n        return i;\\n    }\\n\\n\\nn &=(n-1)\\nremoves the smallest 1 bit in n.",
                "solutionTags": [],
                "code": "    public int hammingWeight(int n) {\\n        int i;\\n        for(i=0;n!=0;i++, n&=(n-1));\\n        return i;\\n    }\\n\\n\\nn &=(n-1)\\nremoves the smallest 1 bit in n.",
                "codeTag": "Unknown"
            },
            {
                "id": 55376,
                "title": "my-simple-solution-in-java",
                "content": "the argument n is regarded as unsigned by us but signed by computer, so using \"n % 2 == 1\" to check if the lowest bit is 1 is wrong  because it doesn't concern the highest bit indicate negative value. So we use \"&\" operation instead to check the lowest bit, and we use \">>>\" (not \">>\") to do logical shift right.\\n\\n    public class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int counter = 0;\\n            while(n != 0) {\\n                if((n & 1) == 1) {\\n                    counter += 1;\\n                }\\n                n >>>= 1;\\n            }\\n            return counter;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int counter = 0;\\n            while(n != 0) {\\n                if((n & 1) == 1) {\\n                    counter += 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3358563,
                "title": "solution-in-c",
                "content": "# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint hammingWeight(uint32_t n) {\\n    if (n == 0) {\\n        return 0;\\n    }\\n\\n    int count = 0;\\n\\n    while (n) {\\n        if (n & 1) {\\n            count++;\\n        }\\n        \\n        n >>= 1;\\n    }\\n\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint hammingWeight(uint32_t n) {\\n    if (n == 0) {\\n        return 0;\\n    }\\n\\n    int count = 0;\\n\\n    while (n) {\\n        if (n & 1) {\\n            count++;\\n        }\\n        \\n        n >>= 1;\\n    }\\n\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2955087,
                "title": "beats-95-o-1-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        ans = 0\\n        while n:\\n            n &= n-1\\n            ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        ans = 0\\n        while n:\\n            n &= n-1\\n            ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215997,
                "title": "python3-simple-solution-do-n-n-1",
                "content": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        result = 0\\n        while n:\\n            n = n & (n-1)\\n            result+=1\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        result = 0\\n        while n:\\n            n = n & (n-1)\\n            result+=1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019630,
                "title": "using-brian-kernighan-s-algorithm-another-approach",
                "content": "We can use Brian Kernighan\\u2019s algorithm to improve the above naive algorithm\\u2019s performance. The idea is to only consider the set bits of an integer by turning off its rightmost set bit (after counting it), so the next iteration of the loop considers the next rightmost bit.\\n\\nThe expression n & (n-1) can be used to turn off the rightmost set bit of a number n. This works as the expression n-1 flips all the bits after the rightmost set bit of n, including the rightmost set bit itself. Therefore, n & (n-1) results in the last bit flipped of n.\\n\\nFor example, consider number 52, which is 00110100 in binary, and has a total 3 bits set.\\n\\n1st iteration of the loop: n = 52\\n \\n00110100    &               (n)\\n00110011                    (n-1)\\n~~~~~~~~\\n00110000\\n \\n \\n2nd iteration of the loop: n = 48\\n \\n00110000    &               (n)\\n00101111                    (n-1)\\n~~~~~~~~\\n00100000\\n \\n \\n3rd iteration of the loop: n = 32\\n \\n00100000    &               (n)\\n00011111                    (n-1)\\n~~~~~~~~\\n00000000                    (n = 0)\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) \\n    {\\n        //Using Brian Kernighan\\u2019s algorithm\\n        int count=0;\\n        while(n)\\n        {\\n            //something unique acquisition\\n            n = n & (n-1);\\n            count++;\\n            \\n        }\\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) \\n    {\\n        //Using Brian Kernighan\\u2019s algorithm\\n        int count=0;\\n        while(n)\\n        {\\n            //something unique acquisition\\n            n = n & (n-1);\\n            count++;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1973916,
                "title": "python-one-line-solution",
                "content": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n````\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return bin(n).count(\"1\")",
                "solutionTags": [
                    "Python"
                ],
                "code": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n````\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return bin(n).count(\"1\")",
                "codeTag": "Java"
            },
            {
                "id": 1905512,
                "title": "python-recursive-follow-up-explained",
                "content": "We want to answer the follow up question: *If this function is called many times, how would you optimize it?*\\n# BEFORE FOLLOW UP DISCUSSION\\nLet\\'s see first a recursive solution to the original problem.\\n\\nWe will use the following property:\\n* if *n* is even, it has exactly the same number of `1` bits as *n / 2*\\n* if *n* is odd, it has exactly one more `1` bit than the number of `1` bits of *floor(n / 2)*\\n\\nThis follows from the fact that a number `n` is odd if and only if its last bit is `1`, that is, if and only if `n & 1 == 1`. Thus we can define `hammingWeight` recursively as follows:\\n```\\n    def hammingWeight(self, n: int) -> int:\\n        return self.hammingWeight(n >> 1) + (n & 1)\\n```\\n\\n# FOLLOW UP\\nIf we are going to call this function several times, we could save previous calls in cache. With a recursive approach, if we call `hammingWeight(n)` we would have calculated `hammingWeight(m)` for *every* `m` between `0` and `n` anyways, so this would be one possible solution to the follow-up question.\\n\\nAssuming we are going to call it so may times that almost every value will need to be calculated at some point, we might as well **precalculate every possible answer**, thus giving us an answer in **O(1)** time. \\n```\\n```\\nThe problem states that the inputs will be *32*-bit numbers, so we will precalculate the answers to `hammingWeight(n)` for every `n` from `0` to `(1 << 32) - 1`, using the recursive definition we discussed before, and save them in a list `memo`. The solution would look something like this:\\n```\\nclass Solution:\\n    \\n\\t# create an array of size 2 ** 32\\n    memo = [0] * (1 << 32)\\n    for i in range(1, 1 << 32):\\n        memo[i] = memo[i >> 1] + (i & 1)\\n    \\n    def hammingWeight(self, n: int) -> int:\\n\\t    # ask memo for the precalculated answer\\n        return self.memo[n]\\n```\\n**There is a problem, though \\uD83D\\uDE2D.** Either *I was wrong* with assuming Python can handle **very big** integers and huge arrays with no issues, or there is a memory limitation that was exceeded on Leetcode with this approach, as running this solution results in `MemoryError`.\\n\\n# **THIS CAN BE FIXED** \\uD83D\\uDE2C\\nWe can precalculate half the answers and still be successful \\uD83E\\uDD73.\\n\\nEvery *32*-bit integer is the concatenation of *two* *16*-bit integers. We can calculate `hammingWeight` of the first *16* bits and add that to `hammingWeight` of the last *16* bits. The first *16* bits of `n` are `n >> 16` and the last *16* are `n % (1 << 16)`, thus our full (accepted) solution looks like:\\n```\\nclass Solution:\\n    \\n    memo = [0] * (1 << 16)\\n    for i in range(1, 1 << 16):\\n        memo[i] = memo[i >> 1] + (i & 1)\\n    \\n    def hammingWeight(self, n: int) -> int:\\n        return self.memo[n >> 16] + self.memo[n % (1 << 16)]\\n```\\n&#8718;",
                "solutionTags": [
                    "Math",
                    "Recursion"
                ],
                "code": "```\\n    def hammingWeight(self, n: int) -> int:\\n        return self.hammingWeight(n >> 1) + (n & 1)\\n```\n```\\n```\n```\\nclass Solution:\\n    \\n\\t# create an array of size 2 ** 32\\n    memo = [0] * (1 << 32)\\n    for i in range(1, 1 << 32):\\n        memo[i] = memo[i >> 1] + (i & 1)\\n    \\n    def hammingWeight(self, n: int) -> int:\\n\\t    # ask memo for the precalculated answer\\n        return self.memo[n]\\n```\n```\\nclass Solution:\\n    \\n    memo = [0] * (1 << 16)\\n    for i in range(1, 1 << 16):\\n        memo[i] = memo[i >> 1] + (i & 1)\\n    \\n    def hammingWeight(self, n: int) -> int:\\n        return self.memo[n >> 16] + self.memo[n % (1 << 16)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050113,
                "title": "follow-up-java",
                "content": "To use the function repeatedly, we will make an 8 bit look-up table and pass it with the input. The 32-bit unsigned integer will be split into 4 equal parts and each part will be looked up in O(1) time.\\n\\nThe look-up table can be easily built as:\\n\\n\\tint[] lookup = new int[256];\\n\\tfor(int i = 0; i <= 255; i++){\\n\\t\\tlookup[i] = (i & 1) + lookup[i / 2];\\n\\t}\\n\\nThe function can be modified as :\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n, int[] lookup) {\\n        int count = lookup[n & 0xff] + lookup[(n >> 8) & 0xff] + \\n            lookup[(n >> 16) & 0xff] + lookup[(n >> 24) & 0xff];\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n, int[] lookup) {\\n        int count = lookup[n & 0xff] + lookup[(n >> 8) & 0xff] + \\n            lookup[(n >> 16) & 0xff] + lookup[(n >> 24) & 0xff];\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044806,
                "title": "c-bitwise-solution-explained-100-time",
                "content": "Basic interview problem, of the kind you are supposed to crack on the spot in most settings - of course without using built-in functions and hopefully without expensive conversions (like turning the input into a string).\\n\\nTo solve this problem, we will first of all declare an accumulator variable `res`, preset to `0`.\\n\\nWe will then loop until `n` is `!= 0`, which, provided we do not need to keep the original value of `n`, is much faster than checking all the bits individually for each number, since we need one less variable and it requires much fewer iterations for lower numbers.\\n\\nInside the loop, we will just:\\n* update `res`, increasing it when the last bit (found with `n & 1`) is `1`;\\n* update `n`, shifting it left by one bit (the one we just checked) at each iteration.\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n\\t\\t// support variables\\n        int res = 0;\\n        while (n) {\\n            // updating res\\n\\t\\t\\tres += n & 1;\\n\\t\\t\\t// reducing n\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nCuriosly, my original submissions from years ago seems to require more memory, I would guess probably because of the unoptimised (by the compiler) modulo or division inside it:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n) {\\n            if (n % 2) count++;\\n            n /= 2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n\\t\\t// support variables\\n        int res = 0;\\n        while (n) {\\n            // updating res\\n\\t\\t\\tres += n & 1;\\n\\t\\t\\t// reducing n\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n) {\\n            if (n % 2) count++;\\n            n /= 2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407836,
                "title": "python-one-liner",
                "content": "Here is a one line version of the common Python solution.\\n\\n```\\nclass Solution(object):\\n    def hammingWeight(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n    \\n        return bin(n).count(\\'1\\')\\n```\\n\\nNot much better, but I didn\\'t see anyone post this option. (Maybe considered more pythonic? idk.)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def hammingWeight(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n    \\n        return bin(n).count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55262,
                "title": "c-solution-of-brian-kernighan-u2019s-algorithm",
                "content": "    // Brian Kernighan\\u2019s Algorithm\\n    // http://www.geeksforgeeks.org/count-set-bits-in-an-integer/\\n    int hammingWeight(uint32_t n) {\\n        int count  = 0;\\n        while (n) {\\n            n = n & (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    // Brian Kernighan\\u2019s Algorithm\\n    // http://www.geeksforgeeks.org/count-set-bits-in-an-integer/\\n    int hammingWeight(uint32_t n) {\\n        int count  = 0;\\n        while (n) {\\n            n = n & (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 55276,
                "title": "sharing-my-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        int hammingWeight(uint32_t n) {\\n            int count = 0;\\n            unsigned int temp;\\n            for(int i=0; i<32; i++)\\n            {\\n                temp = n & (1<<i);\\n                if(temp > 0)\\n                    count++;\\n            }\\n            \\n            return count;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int hammingWeight(uint32_t n) {\\n            int count = 0;\\n            unsigned int temp;\\n            for(int i=0; i<32; i++)\\n            {\\n                temp = n & (1<<i);\\n                if(temp > 0)\\n                    count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 55405,
                "title": "my-simple-python-and-java-solution-for-share",
                "content": "    public class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        for (; n != 0; n >>>= 1)\\n            count += 1 & n;\\n        \\n        return count;\\n    }\\n    }\\n\\nBit Hack\\n\\n    public class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        for (; n != 0; n &= n-1){\\n            count++;\\n        }\\n        return count;\\n    }\\n    }\\n\\nPython one line\\n\\n    class Solution:\\n    # @param n, an integer\\n    # @return an integer\\n    def hammingWeight(self, n):\\n        return bin(n).count('1')",
                "solutionTags": [],
                "code": "class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        for (; n != 0; n >>>= 1)\\n            count += 1 & n;\\n        \\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 55427,
                "title": "c-solution-only-need-1ms",
                "content": "<pre><code>\\nint hammingWeight(uint32_t n) {\\n    \\n    int ret = 0;\\n    while (n) {\\n        if (n & 0x01)\\n            ret++;\\n        n >>= 1;\\n    }\\n    return ret;\\n}\\n</code></pre>",
                "solutionTags": [],
                "code": "<pre><code>\\nint hammingWeight(uint32_t n) {\\n    \\n    int ret = 0;\\n    while (n) {\\n        if (n & 0x01)\\n            ret++;\\n        n >>= 1;\\n    }\\n    return ret;\\n}\\n</code></pre>",
                "codeTag": "Unknown"
            },
            {
                "id": 3357523,
                "title": "go-solution-with-bitwise-operators",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc hammingWeight(num uint32) int {\\n    res := 0\\n    for num > 0 {\\n        if num & 1 == 0 {\\n            num >>= 1\\n        } else {\\n            num &^= 1\\n            res++\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc hammingWeight(num uint32) int {\\n    res := 0\\n    for num > 0 {\\n        if num & 1 == 0 {\\n            num >>= 1\\n        } else {\\n            num &^= 1\\n            res++\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3095697,
                "title": "python-3-one-line-solution",
                "content": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return bin(n).count(\"1\")\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return bin(n).count(\"1\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830302,
                "title": "100-fastest-easy-c-solution-o-1-0ms-with-complexity",
                "content": "Here is My C++ Solution :-\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ones=0;\\n        for (int i=0; i<32; i++){\\n            if (n&1){\\n                ones++;\\n            }\\n            n= n>>1;\\n        }\\n        return ones;\\n    }\\n};\\n```\\n\\nIt is 100 % fast solution. 100% fastest and 0ms runtime.\\n\\n**Time Complexity : O(1)\\nSpace Complexity: O(1)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ones=0;\\n        for (int i=0; i<32; i++){\\n            if (n&1){\\n                ones++;\\n            }\\n            n= n>>1;\\n        }\\n        return ones;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812013,
                "title": "golang-bit-manipulation",
                "content": "# Approach\\nLet\\'s consider ***num = 5*** which in binary notation will look like **101**. \\n\\nEvery step we do the following:\\n1. binary AND operation with 1\\n    10**1** & 00**1** = 00**1** - since the last bit of 5 is 1 we add 1 to the final result.\\n2. binary shift 1 bit to the right:\\n    101 >> 1 = 010\\n\\nRepeat until the original number is 0. \\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(logN)$$\\nWhere ***N*** is the number of bits in the binary representation of ***num***\\n\\n# Code\\n```\\nfunc hammingWeight(num uint32) int {\\n    var res uint32\\n\\n    for num != 0 {\\n        res += num & 1 \\n        num >>= 1\\n    }\\n\\n    return int(res)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc hammingWeight(num uint32) int {\\n    var res uint32\\n\\n    for num != 0 {\\n        res += num & 1 \\n        num >>= 1\\n    }\\n\\n    return int(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2791463,
                "title": "java",
                "content": "```\\n\\n    public int hammingWeight(int n) {\\n        return Integer.bitCount(n);\\n    }\\n\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n\\n    public int hammingWeight(int n) {\\n        return Integer.bitCount(n);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2369836,
                "title": "java-solution",
                "content": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        return Integer.bitCount(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        return Integer.bitCount(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323567,
                "title": "c-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n        while(n!=0){\\n            n=n&n-1;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n        while(n!=0){\\n            n=n&n-1;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173193,
                "title": "the-dumbest-solution-java-dumb-coder",
                "content": "```\\n\\t\\t//convert to string remove 0\\'s and just return the length of the string EZY PZY\\n        return Integer.toBinaryString(n).replaceAll(\"0\",\"\").length();\\n   \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\t//convert to string remove 0\\'s and just return the length of the string EZY PZY\\n        return Integer.toBinaryString(n).replaceAll(\"0\",\"\").length();\\n   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2075153,
                "title": "c-easy-to-understand-bit-manipulation-3-approaches",
                "content": "**Approach 1:-**\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n);\\n    }\\n};\\n```\\n**Approach 2:-**\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n      return bitset<32>(n).count();\\n    }\\n};\\n```\\n**Approach 3:-**\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n      int cnt=0;\\n      while(n>0){\\n          n=n&(n-1);\\n          cnt++;\\n      }\\n      return cnt;\\n    }\\n};\\n```\\n**Don\\'t forget to upvote this post if it has helped you!!!**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n      return bitset<32>(n).count();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n      int cnt=0;\\n      while(n>0){\\n          n=n&(n-1);\\n          cnt++;\\n      }\\n      return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074858,
                "title": "java-solution-with-dry-run",
                "content": "// dry run of this approach is \\n for example = n= 1 0 1 1 1 (binary representation of number )\\n     k  =    10111 - 1 =  10110     (-1  will flip digits till it encounter 1 from right to left  )  \\n\\t\\t n = 10111 & k = 10110\\n\\t\\t // 2nd iteration\\n\\t\\t k = 10110-1 = 10101       (flip digits till 2nd last position )\\n\\t\\t n =  10110  & k = 10100\\n\\t\\t // 3rd iteration \\n\\t\\t k = 10100 - 1 = 10011       (flip digits till 3nd last position )\\n\\t\\t n = 10100  & 10011 = 10000\\n\\t\\t // 4th \\n\\t\\t k = 10000 - 1 = 01111      (flip digit till it encounter 1  from right to left)\\n\\t\\t n = 10000  & 01111 = 00000    , 4 iteration so 4 is the answer \\n```\\n public int hammingWeight(int n) {\\n      int count = 0;\\n      while(n!=0){\\n          n = n & (n - 1);\\n          count++;\\n      }\\n        \\n      return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int hammingWeight(int n) {\\n      int count = 0;\\n      while(n!=0){\\n          n = n & (n - 1);\\n          count++;\\n      }\\n        \\n      return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935570,
                "title": "java-multiple-approaches",
                "content": "# Brute Force Approach\\n```\\npublic int hammingWeight(int n) {\\n\\n        String num = Integer.toBinaryString(n);// convert Integer to Binary String \\n        int count = 0;\\n        for(char ch : num.toCharArray()){\\n            if(ch == \\'1\\')\\n                count++;\\n        }\\n        return count;\\n    }\\n```\\n\\n# Using BitMasking\\n```\\npublic int hammingWeight(int n) {\\n//         using bit masking\\n        int count = 0, i = 0;\\n        while(i < 32){\\n            int mask = (1 << i++);\\n            if((n & mask) != 0) count++;\\n        }\\n        return count;\\n    }\\n```\\n\\n# Right Shift Operation\\n```\\npublic int hammingWeight(int n) {\\n        int count = 0;\\n        while(n != 0){\\n            if((n & 1) != 0) count++;\\n            n >>>= 1;\\n        }\\n        return count;\\n    }\\n```\\n# Using hamming distance method\\n*  Do & operation of that number with n-1 till num != 0\\n*  eg -\\n\\t\\tnum = 123\\n\\t\\tnum = num&(num-1) = 123 & 122 => 122\\n\\t\\tnum = num&(num-1) = 122 & 121 => 120\\n\\t\\tnum = num&(num-1) = 120 & 119 => 112\\n\\t\\tnum = num&(num-1) = 112 & 111 => 96\\n\\t\\tnum = num&(num-1) = 96 & 95 => 64\\n\\t\\tnum = num&(num-1) = 64 & 63 => 0\\n```\\npublic int hammingWeight(int n) {\\n//         using hamming distance method\\n        int count = 0;\\n        while(n != 0){\\n            count++;\\n            n = (n & (n-1));\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic int hammingWeight(int n) {\\n\\n        String num = Integer.toBinaryString(n);// convert Integer to Binary String \\n        int count = 0;\\n        for(char ch : num.toCharArray()){\\n            if(ch == \\'1\\')\\n                count++;\\n        }\\n        return count;\\n    }\\n```\n```\\npublic int hammingWeight(int n) {\\n//         using bit masking\\n        int count = 0, i = 0;\\n        while(i < 32){\\n            int mask = (1 << i++);\\n            if((n & mask) != 0) count++;\\n        }\\n        return count;\\n    }\\n```\n```\\npublic int hammingWeight(int n) {\\n        int count = 0;\\n        while(n != 0){\\n            if((n & 1) != 0) count++;\\n            n >>>= 1;\\n        }\\n        return count;\\n    }\\n```\n```\\npublic int hammingWeight(int n) {\\n//         using hamming distance method\\n        int count = 0;\\n        while(n != 0){\\n            count++;\\n            n = (n & (n-1));\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1808386,
                "title": "java-1-liner-explained",
                "content": "**Method 1:** Check each of the 32 bits if it\\'s set or not\\n>**T/S:** O(1)/O(1)\\n```\\npublic int hammingWeight(int n) {\\n\\tvar popCount = 0;\\n\\tfor (var i = 0; i < 32; i++, n >>= 1)\\n\\t\\tpopCount += n & 1;\\n\\treturn popCount;\\n}\\n```\\n**Method 2:** Use `bitCount` method\\n```\\npublic int hammingWeight(int n) {\\n\\treturn Integer.bitCount(n);\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int hammingWeight(int n) {\\n\\tvar popCount = 0;\\n\\tfor (var i = 0; i < 32; i++, n >>= 1)\\n\\t\\tpopCount += n & 1;\\n\\treturn popCount;\\n}\\n```\n```\\npublic int hammingWeight(int n) {\\n\\treturn Integer.bitCount(n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795287,
                "title": "c-solution-brian-kernighan-s-algorithm-0ms",
                "content": "```\\nint hammingWeight(uint32_t n) {\\n       uint32_t cnt=0;\\n        while(n)\\n        {\\n            n&=(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint hammingWeight(uint32_t n) {\\n       uint32_t cnt=0;\\n        while(n)\\n        {\\n            n&=(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1733197,
                "title": "python-very-simple-iterative-solution-using-bitwise-operators",
                "content": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count = 0\\n        # while there are no more zeros left in our number (000000 == 0)\\n        while n:\\n\\t\\t\\t# & operator returns a binary number that has 1 in every position where both numbers contain a 1. If we use the\\n\\t\\t\\t# & operator with our number and one, it will check if the the first digit is a 1 or a 0. \\n            if n & 1:\\n\\t\\t\\t\\t# if a one exists in the first digit of our current number, increment count\\n                count += 1\\n\\t\\t\\t# shift n to the right one bit to \"iterate\" over the number\\n            n = n >> 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count = 0\\n        # while there are no more zeros left in our number (000000 == 0)\\n        while n:\\n\\t\\t\\t# & operator returns a binary number that has 1 in every position where both numbers contain a 1. If we use the\\n\\t\\t\\t# & operator with our number and one, it will check if the the first digit is a 1 or a 0. \\n            if n & 1:\\n\\t\\t\\t\\t# if a one exists in the first digit of our current number, increment count\\n                count += 1\\n\\t\\t\\t# shift n to the right one bit to \"iterate\" over the number\\n            n = n >> 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708083,
                "title": "javascript-functional-programming-approach-o-n-time-o-n-space",
                "content": "```\\nvar hammingWeight = function(n) {\\n    return Array.from(n.toString(2)).reduce((acc, n) => acc += Number(n), 0)\\n};\\n````",
                "solutionTags": [],
                "code": "```\\nvar hammingWeight = function(n) {\\n    return Array.from(n.toString(2)).reduce((acc, n) => acc += Number(n), 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1461232,
                "title": "python-2-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Check 32 bits**\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        ans = 0\\n        for i in range(32):\\n            if (n >> i) & 1:\\n                ans += 1\\n        return ans\\n```\\nComplexity:\\n- Time: `O(32)`\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Clear the rightmost bit one by one**\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        ans = 0\\n        while n:\\n            n &= (n-1)  # Clear the rightmost bit\\n            ans += 1\\n        return ans\\n```\\nComplexity:\\n- Time: `O(32)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        ans = 0\\n        for i in range(32):\\n            if (n >> i) & 1:\\n                ans += 1\\n        return ans\\n```\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        ans = 0\\n        while n:\\n            n &= (n-1)  # Clear the rightmost bit\\n            ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304131,
                "title": "easy-python-solution-95-81",
                "content": "Runtime: 24 ms, faster than 95.81% of Python3 online submissions for Number of 1 Bits.\\nMemory Usage: 14.3 MB, less than 35.35% of Python3 online submissions for Number of 1 Bits.\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        c=0\\n        while n:\\n            if(n&1):\\n                c+=1\\n            n=n>>1\\n        return c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 24 ms, faster than 95.81% of Python3 online submissions for Number of 1 Bits.\\nMemory Usage: 14.3 MB, less than 35.35% of Python3 online submissions for Number of 1 Bits.\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        c=0\\n        while n:\\n            if(n&1):\\n                c+=1\\n            n=n>>1\\n        return c",
                "codeTag": "Java"
            },
            {
                "id": 1044767,
                "title": "c-super-simple-and-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n) {\\n            count += n % 2;\\n            n = n >> 1;\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n) {\\n            count += n % 2;\\n            n = n >> 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988345,
                "title": "javascript-one-liner",
                "content": "```\\nconst hammingWeight = n => \\n  n.toString(2).match(/1/g)?.length ?? 0; \\n  ```\\n  See the optional chaining operator `?.`:\\n  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator#Relationship_with_the_optional_chaining_operator_",
                "solutionTags": [],
                "code": "```\\nconst hammingWeight = n => \\n  n.toString(2).match(/1/g)?.length ?? 0; \\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 965267,
                "title": "python-bit-manipulation-trick",
                "content": "From Elements of Programming Interviews in Python, `n &= n - 1` deletes the last `1` bit in `n`. For example, `n = 0b1010`, then\\n\\n`0b1010 & 0b1010 - 0b0001 =`\\n`0b1010 & 0b1001 =`\\n`0b1000`\\n\\nAnd you repeat this until there are no ones left. Time complexity is `O(k)` where `k` is the number of ones in the binary representation.\\n\\n```python\\ndef hammingWeight(self, n: int) -> int:\\n        count = 0\\n        while n:\\n            count += 1\\n            n &= n - 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```python\\ndef hammingWeight(self, n: int) -> int:\\n        count = 0\\n        while n:\\n            count += 1\\n            n &= n - 1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 890389,
                "title": "python-simple-solution-using-bit-operations",
                "content": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        res = 0\\n        while n:\\n            res += n & 1\\n            n >>= 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        res = 0\\n        while n:\\n            res += n & 1\\n            n >>= 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722156,
                "title": "c-3-approaches-inbuilt-2-manually",
                "content": "***Runtime: 0 ms, faster than 100.00% of C++ online submissions for Number of 1 Bits.\\nMemory Usage: 6.1 MB, less than 38.02% of C++ online submissions for Number of 1 Bits.***\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while(n){\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n***Runtime: 0 ms, faster than 100.00% of C++ online submissions for Number of 1 Bits.\\nMemory Usage: 5.9 MB, less than 90.40% of C++ online submissions for Number of 1 Bits.***\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return __builtin_popcount(n);\\n    }\\n};\\n```\\n***Runtime: 0 ms, faster than 100.00% of C++ online submissions for Number of 1 Bits.\\nMemory Usage: 6.1 MB, less than 37.16% of C++ online submissions for Number of 1 Bits.***\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return bitset<32>(n).count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while(n){\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return __builtin_popcount(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return bitset<32>(n).count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470633,
                "title": "ruby-recursive-iterative-and-with-language-tools",
                "content": "**With language tools:**\\nThe integer is converted to a string, passing in 2 as the base, ensuring we get a string version of the binary number. Then we count the number of \\'1\\' characters in the string.\\n\\n```\\ndef hamming_weight(n)\\n  n.to_s(2).count(\\'1\\')\\nend\\n```\\n\\n**Iterative with mod/division:**\\nBecause binary is base 2, we can learn what the last digit of the number is by using mod 2 and can then remove it by dividing the number by 2. One by one we remove the last number until there are no numbers left. By adding them all individually we can learn how many ones there are.\\n```\\ndef hamming_weight(n)\\n  sum = 0\\n  while n > 0\\n    sum += n%2\\n    n /= 2\\n  end\\n  sum\\nend\\n```\\n\\n**Iterative with bit shifting:**\\n```\\ndef hamming_weight(n)\\n  sum = 0\\n  while n > 0\\n    sum += (n & 1)\\n    n >>= 1\\n  end\\n  sum\\nend\\n```\\n\\n**Recursive with mod/division:**\\n```\\ndef hamming_weight(n)\\n  n.zero? ? 0 : (n % 2) + hamming_weight(n/2) \\nend\\n```\\n\\n**Recursive with bit shifting:**\\n```\\ndef hamming_weight(n)\\n  n.zero? ? 0 : (n & 1) + hamming_weight(n>>1) \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef hamming_weight(n)\\n  n.to_s(2).count(\\'1\\')\\nend\\n```\n```\\ndef hamming_weight(n)\\n  sum = 0\\n  while n > 0\\n    sum += n%2\\n    n /= 2\\n  end\\n  sum\\nend\\n```\n```\\ndef hamming_weight(n)\\n  sum = 0\\n  while n > 0\\n    sum += (n & 1)\\n    n >>= 1\\n  end\\n  sum\\nend\\n```\n```\\ndef hamming_weight(n)\\n  n.zero? ? 0 : (n % 2) + hamming_weight(n/2) \\nend\\n```\n```\\ndef hamming_weight(n)\\n  n.zero? ? 0 : (n & 1) + hamming_weight(n>>1) \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 390985,
                "title": "c-cheat-solution",
                "content": "The GCC compiler (which LeetCode appears to use) provides a builtin function `__builtin_popcount` that computes the Hamming weight. Some processors can even do this in a single instruction, and `__builtin_popcount` will use that instruction if available.\\n\\n```c\\nint hammingWeight(uint32_t n) {\\n    return __builtin_popcount(n);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c\\nint hammingWeight(uint32_t n) {\\n    return __builtin_popcount(n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55380,
                "title": "simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        int hammingWeight(uint32_t n) {\\n            int res=0;\\n            while (n!=0) {\\n                res += n&1;\\n                n = n >> 1;\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int hammingWeight(uint32_t n) {\\n            int res=0;\\n            while (n!=0) {\\n                res += n&1;\\n                n = n >> 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 55431,
                "title": "simple-java-solution",
                "content": "Iterate over each bit starting from the rightmost bit and working our way left.\\n\\n    public class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int count = 0;\\n            for(int i=0; i < 32; i++) {\\n                if((n & (1 << i)) != 0) count++;\\n            }\\n            return count;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int count = 0;\\n            for(int i=0; i < 32; i++) {\\n                if((n & (1 << i)) != 0) count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3762803,
                "title": "done-through-recurrsion-beginner-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- recurrsion approach -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(log(n)) -->\\n\\n- Space complexity:\\n<!-- 15 mb -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return self.binary(n,0)\\n    def binary(self,n,count):\\n        if n==0: return count\\n        elif n%2==0: return self.binary(n//2,count)\\n        else: return self.binary(n//2,count+1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return self.binary(n,0)\\n    def binary(self,n,count):\\n        if n==0: return count\\n        elif n%2==0: return self.binary(n//2,count)\\n        else: return self.binary(n//2,count+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534668,
                "title": "best-o-logn-solution",
                "content": "# Approach\\nUsing Right Shift\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n != 0) {\\n            count += n & 1;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n != 0) {\\n            count += n & 1;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460892,
                "title": "beats-49-2-25-145-top-interview-question",
                "content": "# Intuition\\n*right shift and left shift, Bit manipulation*\\n\\n# Approach\\nThis is a Python class method called `hammingWeight`, which takes an integer `n` as input and returns the number of 1-bits in its binary representation. Here\\'s a step-by-step breakdown of how the method works:\\n\\n1. Initialize a counter variable `count` to 0.\\n2. Loop 32 times, since integers in Python are represented using 32 bits.\\n3. Check if the least significant bit of `n` is 1 by using the modulo operator (`%`) to check if `n` is odd.\\n4. If the least significant bit is 1, increment the counter `count` by 1.\\n5. Right shift the binary representation of `n` by 1 bit (using the `>>` operator) to remove the least significant bit.\\n6. Repeat steps 3-5 for the remaining 31 bits of `n`.\\n7. Return the final count of 1-bits.\\n\\n`Note:`  that this implementation assumes that `n` is a non-negative integer. If `n` is negative, the method will return the number of 1-bits in its two\\'s complement representation (which may be more than 32 bits).\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\nThe `time complexity` of the `hammingWeight` method is `O(1)` since it always loops through a fixed number of iterations (32). Therefore, the time taken to execute the method does not depend on the size of the input.\\n\\nThe `space complexity` of the method is also `O(1)` since it only uses a fixed amount of memory to store the `count` variable and the loop counter. Regardless of the size of the input integer `n`, the method uses the same amount of memory to store these variables.\\n\\nIn summary, the `hammingWeight` method has a `constant time complexity of O(1)` and a `constant space complexity of O(1)`.\\n# Code\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count = 0\\n        for _ in range(32):\\n            if n%2 == 1:\\n                count +=1\\n            n = n >> 1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count = 0\\n        for _ in range(32):\\n            if n%2 == 1:\\n                count +=1\\n            n = n >> 1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436437,
                "title": "c-simple-clean-code-bit-manipulation-beats-100",
                "content": "# Complexity\\n- Time complexity: O(32)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        \\n        while (n) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        \\n        while (n) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232958,
                "title": "one-line-code-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:99% -----> please upvote me\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)-----> it would encourage me\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return bin(n)[2:].zfill(32).count(\\'1\\')\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return bin(n)[2:].zfill(32).count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200312,
                "title": "counting-the-number-of-1-bits-in-an-unsigned-integer-using-binary-representation-and-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks to count the number of \\'1\\' bits in the binary representation of an unsigned integer. One possible approach is to convert the integer to binary and count the number of \\'1\\' bits in the resulting string.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne approach to solve this problem is to convert the input integer to binary using the built-in `bin` function in Python. Then, we can count the number of \\'1\\' bits in the resulting binary string using the `count` method. To optimize the function for repeated calls, we can use memoization to cache the results for each integer that we have already processed.\\n# Complexity\\n- Time complexity: The time complexity of the `hammingWeight` method is $$O(log n)$$, where n is the input integer, since the `bin` function has a time complexity of $$O(log n)$$, and the `count` method has a time complexity of $$O(m)$$, where m is the length of the binary string.\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the `hammingWeight` method is $$O(log n)$$, since we need to store the binary string of the input integer, which has a length of $$O(log n)$$. In addition, we use a cache to store the results of previously processed integers, which could take up additional space.\\n\\n\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom typing import Dict\\n\\nclass Solution:\\n    def __init__(self):\\n        self.cache = {}\\n        \\n    def hammingWeight(self, n: int) -> int:\\n        if n in self.cache:\\n            return self.cache[n]\\n        else:\\n            count = bin(n).count(\\'1\\')\\n            self.cache[n] = count\\n            return count\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer",
                    "Bit Manipulation"
                ],
                "code": "```\\nfrom typing import Dict\\n\\nclass Solution:\\n    def __init__(self):\\n        self.cache = {}\\n        \\n    def hammingWeight(self, n: int) -> int:\\n        if n in self.cache:\\n            return self.cache[n]\\n        else:\\n            count = bin(n).count(\\'1\\')\\n            self.cache[n] = count\\n            return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172788,
                "title": "100-beats-with-0ms-fast-solution-easy-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int k=0;\\n        while(n>0)\\n        {\\n            n=n&n-1;\\n            k++;\\n        }\\n        return k;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int k=0;\\n        while(n>0)\\n        {\\n            n=n&n-1;\\n            k++;\\n        }\\n        return k;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834893,
                "title": "easy-and-fast-sol-java-time-o-1-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nand the the no with left shift 1\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntaking 1 and shifting left side while checking with number n by and opration \\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count=0;\\n        int a=1;\\n        for (int i=0;i<32;++i){\\n            if( (n & a)!=0)count++;\\n            a<<=1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count=0;\\n        int a=1;\\n        for (int i=0;i<32;++i){\\n            if( (n & a)!=0)count++;\\n            a<<=1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818712,
                "title": "c-simple-solution",
                "content": "\\tint hammingWeight(uint32_t n) {\\n    uint32_t b = n;\\n    int count = 0;\\n    while(b>0){\\n        if (b%2==1){\\n            count++;\\n        }\\n        b/=2;\\n    }\\n    return count;\\n\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tint hammingWeight(uint32_t n) {\\n    uint32_t b = n;\\n    int count = 0;\\n    while(b>0){\\n        if (b%2==1){\\n            count++;\\n        }\\n        b/=2;\\n    }\\n    return count;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2813242,
                "title": "python3-one-liner",
                "content": "```\\nclass Solution:\\n    def hammingWeight(self, n):\\n        return bin(n).count(\\'1\\')\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n):\\n        return bin(n).count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790226,
                "title": "java-easy-solution-bit-shifting",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe\\'ll check if we have bit \"1\" at the first position of given ```n``` (i.e. first position from right side) and will keep on shifting ```n``` towards right by 1\\n**NOTE -> Bitwise Zero Fill Right Shift Operator has to be used here.**\\n\\n```>>``` - *Bitwise Right Shift Operator* preserves the sign bit.\\n```>>>``` - *Bitwise Zero Fill Right Shift* Operator **do not** preserves the sign bit.\\n\\n# Complexity\\n- Time complexity: **O(logn)** \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$Kindly$$ $$upvote$$ $$if$$ $$you$$ $$understood$$ $$the$$ $$solution... :)$$\\n# Code\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n\\n        while(n != 0) {\\n            count += (n & 1);\\n            n = n >>> 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```n```\n```n```\n```>>```\n```>>>```\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n\\n        while(n != 0) {\\n            count += (n & 1);\\n            n = n >>> 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696605,
                "title": "best-easy-3-methods",
                "content": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n1st method\\n        c = 0\\n        b = bin(n)[2:]\\n        for i in b:\\n            if i == \\'1\\':\\n                c = c + 1\\n        return c\\n    \\n2nd method\\n\\n        res = 0\\n        for i in range(32):\\n            res += n & 1\\n            n = n >> 1\\n        \\n        return res        \\n        \\n3rd method\\n        \\n        res = 0\\n        while n:\\n            n = n & (n-1)\\n            res += 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n1st method\\n        c = 0\\n        b = bin(n)[2:]\\n        for i in b:\\n            if i == \\'1\\':\\n                c = c + 1\\n        return c\\n    \\n2nd method\\n\\n        res = 0\\n        for i in range(32):\\n            res += n & 1\\n            n = n >> 1\\n        \\n        return res        \\n        \\n3rd method\\n        \\n        res = 0\\n        while n:\\n            n = n & (n-1)\\n            res += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429512,
                "title": "no-of-1-bits-c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n)\\n    {\\n        int count=0;\\n        while(n!=0)\\n        {\\n            if(n&1==1) \\n                count++;\\n            n=n>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n)\\n    {\\n        int count=0;\\n        while(n!=0)\\n        {\\n            if(n&1==1) \\n                count++;\\n            n=n>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206668,
                "title": "c-solution-3-lines",
                "content": "Use a simple for-loop to check each bit and increment answer. My first post so please upvote me!\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        for(int i = 0; i < 32; i++) if(n &(1 << i)) ans++;\\n        return ans;\\n    }\\n};\\n\\n// Time Complexity O(1)\\n// Space Complexity O(1)\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        for(int i = 0; i < 32; i++) if(n &(1 << i)) ans++;\\n        return ans;\\n    }\\n};\\n\\n// Time Complexity O(1)\\n// Space Complexity O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724179,
                "title": "php-use-bit-manipulation-beat-96-55",
                "content": "```\\nclass Solution {\\n    /**\\n     * @param Integer $n\\n     * @return Integer\\n     */\\n    function hammingWeight($n) {\\n        $count = 0;\\n        while ($n != 0) {\\n            if ($n & 1 == 1) {\\n                $count++;\\n            }\\n            $n = $n >> 1;\\n        }\\n        return $count;\\n    }\\n}",
                "solutionTags": [
                    "PHP",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    /**\\n     * @param Integer $n\\n     * @return Integer\\n     */\\n    function hammingWeight($n) {\\n        $count = 0;\\n        while ($n != 0) {\\n            if ($n & 1 == 1) {\\n                $count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1639862,
                "title": "easy-to-understand-in-c-bit-manipulation",
                "content": "class Solution {\\npublic:\\n\\n    int hammingWeight(uint32_t n) {\\n        int ans=0;\\n        while(n!=0){\\n            if(n & 1){\\n                ans+=1;\\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int hammingWeight(uint32_t n) {\\n        int ans=0;\\n        while(n!=0){\\n            if(n & 1){\\n                ans+=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1283125,
                "title": "java-easy-implementation-of-kernighan-s-algorithm-with-explanation-faster-then-100",
                "content": "\\nThe Solution is Based on **Brian Kernighan\\u2019s Algorithm:**  \\nThe Kernighan\\u2019s Algorithm jumps on only selective bits which are set (1).\\nWhat we are generally Doing here is finding out the right most set bit which is set i.e.  is 1 \\n    which is calculated using \"n & -n\" and then we subtract this from rsb so that the set bit will become non set now following by counting the set bit.\\n    And we count till all the bits become 0 and at the end we return the counted set bits.\\n\\t\\n\\t```\\n\\tpublic class Solution {\\n    public int hammingWeight(int n) {\\n        int count =0;\\n        while(n != 0){\\n            long rsb = n & -n;\\n            n -= rsb;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n\\nP.S. upvote is appericiated",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int hammingWeight(int n) {\\n        int count =0;\\n        while(n != 0){\\n            long rsb = n & -n;\\n            n -= rsb;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1237413,
                "title": "java-100-faster-brian-kernighan-s-algo-full-explaination",
                "content": "**Brian Kernighan\\u2019s Algorithm:**\\nSubtracting 1 from a decimal number flips all the bits after the rightmost set bit(which is 1) including the rightmost set bit. So if we subtract a number by 1 and do bitwise & with itself (n & (n-1)), we unset the rightmost set bit. \\nfor example : \\n10 in binary is 00001010 \\n9 in binary is 00001001 \\n8 in binary is 00001000 \\n7 in binary is 00000111 \\nSo if we subtract a number by 1 and do it bitwise & with itself (n & (n-1)), we unset the rightmost set bit. If we do n & (n-1) in a loop and count the number of times the loop executes, we get the set bit count. \\nThe beauty of this solution is the number of times it loops is equal to the number of set bits in a given integer. \\n\\n\\t   1  Initialize count: = 0\\n\\t   2  If integer n is not zero\\n\\t\\t  (a) Do bitwise & with (n-1) and assign the value back to n\\n\\t\\t\\t  n: = n&(n-1)\\n\\t\\t  (b) Increment count by 1\\n\\t\\t  (c) go to step 2\\n\\t   3  Else return count\\n\\n```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044884,
                "title": "simple-java-solution-with-explaination-using-bit-shift",
                "content": "1.Input is given a integer example 12. We need to return number of 1\\'s in its binary form.\\n2.Idea is to iterate loop keep counting last digit in binary form and remove last digit for next iteration. break the loop if n becomes 0.\\n3.now trick is how to count 1 in binary form without converting n to binary string. for that we will use bitwise operator. If we perform bitwise & operator of any number with 1 we will get result as 1 if last digit is 1 else 0 result. why? \\nfor e.g.-> n=5. 5&1 will give 101 & 001 = 001. in decimal it is 1.\\nn=4, 4&1 will give 100 &001=000 . which is 0.\\n4. now we know how to check last digit. so just add result of above & operator with counter.\\n5. after that we need to remove last digit in binary form. so that above operator will check the correct digit. for that we can use right shift operator. as right shift by 1 will remove rightmost bit from number.\\n6. Once loop finishes counter will have desired 1\\'s count.\\nNote ->\\nsince it is mentioned in a question to treat number as unsigned.but in java every number is signed. and in java range is also cyclic INTEGER.MAX_VALUE+1=INTEGER.MIN_VALUE. so we will use right shift unsigned operator >>> instead of >>. and while loop(n!=0) as our number might go negative also if input passed is Max_VALUE.\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count=0;\\n        while(n!=0) {\\n            count+=(n&1);\\n            n=n>>>1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count=0;\\n        while(n!=0) {\\n            count+=(n&1);\\n            n=n>>>1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546593,
                "title": "python-solution-using-modulus-beating-98-in-time-and-100-in-memory",
                "content": "cnt = 0\\n        while n:\\n            cnt += n % 2\\n            n = n // 2\\n        return cnt",
                "solutionTags": [],
                "code": "cnt = 0\\n        while n:\\n            cnt += n % 2\\n            n = n // 2\\n        return cnt",
                "codeTag": "Unknown"
            },
            {
                "id": 432785,
                "title": "java-and-with-right-shift-zero-fill",
                "content": "```\\npublic int hammingWeight(int n) {\\n\\tint count = 0;\\n\\twhile(n!=0) {\\n\\t\\tcount += (n&1);\\n\\t\\tn>>>=1;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int hammingWeight(int n) {\\n\\tint count = 0;\\n\\twhile(n!=0) {\\n\\t\\tcount += (n&1);\\n\\t\\tn>>>=1;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 293899,
                "title": "c-bit",
                "content": "```\\npublic class Solution {\\n    public int HammingWeight(uint n) {\\n        var count = 0;\\n        for (int i = 0; i < 32; i++) {\\n            if ((n >> i & 1) == 1) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int HammingWeight(uint n) {\\n        var count = 0;\\n        for (int i = 0; i < 32; i++) {\\n            if ((n >> i & 1) == 1) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213229,
                "title": "multiple-python-solutions",
                "content": "```\\ndef hammingWeight(self, n):\\n\\treturn bin(n).count(\\'1\\')\\n\\ndef hammingWeight(self, n):\\n\\treturn \"{0:b}\".format(n).count(\\'1\\')\\n\\ndef hammingWeight(self, n):\\n\\tcount = 0\\n\\twhile n > 0:\\n\\t\\tif n % 2 == 1:\\n\\t\\t\\tcount += 1\\n\\t\\tn //= 2\\n\\treturn count\\n\\ndef hammingWeight(self, n):\\n\\tif n == 0:\\n\\t\\treturn 0\\n\\treturn self.hammingWeight(n // 2) + n % 2\\n\\ndef hammingWeight(self, n):\\n\\treturn sum(1 for i in range(32) if n & (1 << i))\\n```",
                "solutionTags": [],
                "code": "```\\ndef hammingWeight(self, n):\\n\\treturn bin(n).count(\\'1\\')\\n\\ndef hammingWeight(self, n):\\n\\treturn \"{0:b}\".format(n).count(\\'1\\')\\n\\ndef hammingWeight(self, n):\\n\\tcount = 0\\n\\twhile n > 0:\\n\\t\\tif n % 2 == 1:\\n\\t\\t\\tcount += 1\\n\\t\\tn //= 2\\n\\treturn count\\n\\ndef hammingWeight(self, n):\\n\\tif n == 0:\\n\\t\\treturn 0\\n\\treturn self.hammingWeight(n // 2) + n % 2\\n\\ndef hammingWeight(self, n):\\n\\treturn sum(1 for i in range(32) if n & (1 << i))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 55121,
                "title": "javascript-brian-kernighan-u2019s-algorithm",
                "content": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\nvar hammingWeight = function(n) {\\n    var count = 0;\\n    while (n) {\\n      n &= (n-1) ;\\n      count++;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\nvar hammingWeight = function(n) {\\n    var count = 0;\\n    while (n) {\\n      n &= (n-1) ;\\n      count++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55123,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func hammingWeight(_ n: Int) -> Int {\\n        var count = 0\\n        var n = n\\n        \\n        while n > 0 {\\n            n &= n - 1\\n            count += 1\\n        }\\n        \\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    func hammingWeight(_ n: Int) -> Int {\\n        var count = 0\\n        var n = n\\n        \\n        while n > 0 {\\n            n &= n - 1\\n            count += 1\\n        }\\n        \\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55216,
                "title": "java-2ms-solution",
                "content": "    public int hammingWeight(int n) {\\n    \\t\\tint sum = 0;\\n    \\t\\twhile(n != 0) {\\n    \\t\\t\\tif ((n & 1) == 1) {\\n    \\t\\t\\t\\tsum++;\\n    \\t\\t\\t}\\n    \\t\\t\\tn = n >>> 1;\\n    \\t\\t}\\n    \\t\\treturn sum;\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int hammingWeight(int n) {\\n    \\t\\tint sum = 0;\\n    \\t\\twhile(n != 0) {\\n    \\t\\t\\tif ((n & 1) == 1) {\\n    \\t\\t\\t\\tsum++;\\n    \\t\\t\\t}\\n    \\t\\t\\tn = n >>> 1;\\n    \\t\\t}\\n    \\t\\treturn sum;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 55246,
                "title": "my-simple-naive-c-solution",
                "content": "It's another way of asking for a number's binary sequence.\\n\\n    public class Solution {\\n        public int HammingWeight(uint n) {\\n            int count =0;\\n            while(n>0)\\n            {\\n                uint mode = n%2;\\n                if(mode == 1)\\n                    count++;\\n                n=n/2;\\n            }\\n            return count;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int HammingWeight(uint n) {\\n            int count =0;\\n            while(n>0)\\n            {\\n                uint mode = n%2;\\n                if(mode == 1)\\n                    count++;\\n                n=n/2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 55296,
                "title": "my-simple-c-solution-in-o-the-number-of-ones",
                "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n\\n        int count=0;\\n        while (n){\\n            count++;   \\n            n&=n-1;\\n            \\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n\\n        int count=0;\\n        while (n){\\n            count++;   \\n            n&=n-1;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 55304,
                "title": "solution-using-java-operator",
                "content": "    public class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        for(int i = 0; i < 32; i++) {\\n            if((n & 1) == 1) count++;\\n            n = n >>> 1;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        for(int i = 0; i < 32; i++) {\\n            if((n & 1) == 1) count++;\\n            n = n >>> 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 55328,
                "title": "a-python-solution-with-some-speed-tricks",
                "content": "    class Solution:\\n        # @param n, an integer\\n        # @return an integer\\n    \\tdef hammingWeight(self, n):\\n    \\t\\tbitsMap = [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4]\\n    \\t\\ti = 0\\n    \\t\\tresult = 0\\n    \\t\\twhile i < 32:\\n    \\t\\t\\tresult += bitsMap[(n>>i) & 15]\\n    \\t\\t\\ti += 4\\n    \\t\\treturn result\\n\\nI map a number in [0,15] to its number of  '1' bits, and the 'while' cope with 4 bits rather than 1 bits at a time, which means it will be faster.",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @param n, an integer\\n        # @return an integer\\n    \\tdef hammingWeight(self, n):\\n    \\t\\tbitsMap = [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4]\\n    \\t\\ti = 0\\n    \\t\\tresult = 0\\n    \\t\\twhile i < 32:\\n    \\t\\t\\tresult += bitsMap[(n>>i) & 15]\\n    \\t\\t\\ti += 4\\n    \\t\\treturn result\\n\\nI map a number in [0,15] to its number of  '1' bits, and the 'while' cope with 4 bits rather than 1 bits at a time, which means it will be faster.",
                "codeTag": "Java"
            },
            {
                "id": 55372,
                "title": "a-max-value-of-int-in-java-is-2147483647-but-the-test-case-include-the-value-of-2147483648-is-the-system-wrong",
                "content": "I Try to solve this problem using java and not in a bit view. I do like this:\\n                 int num=0;\\n\\t\\t int m;\\n\\t\\t while(n!=0){\\n\\t\\t\\t m=n%2;\\n\\t\\t\\t n=n/2;\\n\\t\\t\\t if(m==1){\\n\\t\\t\\t\\t num++;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t return num;\\n\\nIn actually,It is a  mathematic way.it goes right in most situation,but the test case includes 2147483648,it is out of range in java.so the answer is wrong.\\nI want to know is there any way to solve this problem without using bit-operation (like &)?",
                "solutionTags": [
                    "Java"
                ],
                "code": "I Try to solve this problem using java and not in a bit view. I do like this:\\n                 int num=0;\\n\\t\\t int m;\\n\\t\\t while(n!=0){\\n\\t\\t\\t m=n%2;\\n\\t\\t\\t n=n/2;\\n\\t\\t\\t if(m==1){\\n\\t\\t\\t\\t num++;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t return num;\\n\\nIn actually,It is a  mathematic way.it goes right in most situation,but the test case includes 2147483648,it is out of range in java.so the answer is wrong.\\nI want to know is there any way to solve this problem without using bit-operation (like &)?",
                "codeTag": "Unknown"
            },
            {
                "id": 55370,
                "title": "a-3ms-solution-in-c",
                "content": "My first solution (6ms):\\n\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n > 0) {\\n            uint32_t m = n - 1;\\n            n = m & n;\\n            ++count;\\n        }\\n        return count;\\n    }\\n\\nUsing register variable to improve the first solution (4ms):\\n\\n    register int count = 0;\\n        register uint32_t a = n;\\n        while (a > 0) {\\n            a &= (a - 1);\\n            ++count;\\n        }\\n        return count;\\n    }\\n\\nfinally, get a good balance between time complexity and space complexity (3ms):\\n\\n    int hammingWeight(uint32_t n) {\\n        int map[] = {0, 1,  1, 2,   1, 2, 2, 3,   1, 2, 2, 3, 2, 3, 3, 4};\\n        register int count = 0;\\n        register uint32_t a = n;\\n        while (a > 0) {\\n            count += map[0xf & a];\\n            a >>= 4;\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "My first solution (6ms):\\n\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n > 0) {\\n            uint32_t m = n - 1;\\n            n = m & n;\\n            ++count;\\n        }\\n        return count;\\n    }\\n\\nUsing register variable to improve the first solution (4ms):\\n\\n    register int count = 0;\\n        register uint32_t a = n;\\n        while (a > 0) {\\n            a &= (a - 1);\\n            ++count;\\n        }\\n        return count;\\n    }\\n\\nfinally, get a good balance between time complexity and space complexity (3ms):\\n\\n    int hammingWeight(uint32_t n) {\\n        int map[] = {0, 1,  1, 2,   1, 2, 2, 3,   1, 2, 2, 3, 2, 3, 3, 4};\\n        register int count = 0;\\n        register uint32_t a = n;\\n        while (a > 0) {\\n            count += map[0xf & a];\\n            a >>= 4;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 55437,
                "title": "c-solution-o-m-time-1ms",
                "content": "    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while( n )\\n        {\\n            n &= n - 1;\\n            res++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while( n )\\n        {\\n            n &= n - 1;\\n            res++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3985816,
                "title": "in-javascript-use-the-operator-instead-of-the-operator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\nvar hammingWeight = function(n) {\\n   let count = 0\\n   while(n!== 0){\\n   if(n&1){\\n      count++\\n   }\\n   n = n>>>1\\n//IMPORTANT NOTE:-when we are use >> operator  at that time it will not work for 11111111111111111111111111111101 this test case so we can use >>> operator because Use unsigned right shift to handle large positive numbers\\n   }\\n   return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\nvar hammingWeight = function(n) {\\n   let count = 0\\n   while(n!== 0){\\n   if(n&1){\\n      count++\\n   }\\n   n = n>>>1\\n//IMPORTANT NOTE:-when we are use >> operator  at that time it will not work for 11111111111111111111111111111101 this test case so we can use >>> operator because Use unsigned right shift to handle large positive numbers\\n   }\\n   return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3939808,
                "title": "putta-easy-solution-c-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        while( n > 0){\\n            ans +=  n%2;\\n            n = n/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        while( n > 0){\\n            ans +=  n%2;\\n            n = n/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886181,
                "title": "easy-c-solution",
                "content": "\\n# Approach\\nInitialization: Initialize an integer variable cnt to keep track of the count of set bits. This variable is initially set to 0.\\n\\nBit Traversal: Enter a loop that continues as long as n is greater than 0. This loop iterates through the bits of the binary representation of n.\\n\\nBit Parity Check: Inside the loop, perform a bitwise AND operation between n and the binary value 1 (n & 1). This operation checks whether the rightmost bit of n is set (equal to 1).\\n\\nCount Increment: If the result of the bitwise AND operation is greater than 0, it means the rightmost bit of n is set. In this case, increment the cnt variable to count this set bit.\\n\\nBit Shift: After checking the rightmost bit, right-shift n by one position (n = n >> 1), effectively moving to the next bit from right to left.\\n\\nLoop Continuation: Continue the loop until all bits of n have been traversed. When all bits are shifted out (i.e., n becomes zero), the loop will terminate.\\n\\nReturn Count: After the loop ends, the cnt variable will hold the count of set bits in the binary representation of the input n. Return this count as the final result.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;  // count of set bit\\n        while(n>0){  // iterate until all bits are traversed\\n            if((n&1)>0) // check the parity of first bit from right\\n                ++cnt;\\n            n=n>>1; //n=n/2, shift one bit to right\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;  // count of set bit\\n        while(n>0){  // iterate until all bits are traversed\\n            if((n&1)>0) // check the parity of first bit from right\\n                ++cnt;\\n            n=n>>1; //n=n/2, shift one bit to right\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632319,
                "title": "simplest",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n) {\\n            if (n&1) count++;\\n            n >>= 1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n) {\\n            if (n&1) count++;\\n            n >>= 1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532993,
                "title": "o-1-number-of-1-bits-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) -> since the length of the binary representation of the number is fixed at 32 bits.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int i, count=0;\\n        while(n>0)\\n        {\\n            i = n%2;\\n            n /= 2;\\n            if(i==1)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/234f529c-cadf-4728-b1b9-37b3905b47e0_1684297332.3629935.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int i, count=0;\\n        while(n>0)\\n        {\\n            i = n%2;\\n            n /= 2;\\n            if(i==1)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569428,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1566245,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1576483,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1574925,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1566224,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1568785,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1568380,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1739152,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1570753,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1569676,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1569428,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1566245,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1576483,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1574925,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1566224,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1568785,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1568380,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1739152,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1570753,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1569676,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1569837,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1701191,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1570740,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1574934,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1573946,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1571405,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1569009,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1920451,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1898935,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1889447,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1801736,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 1787751,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 1712882,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 1571406,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 1576142,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 1572084,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 1571404,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 2075841,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 2062216,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 2042195,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 2012595,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1963616,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1957542,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1950474,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1950207,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1924338,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1854409,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1833934,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1827149,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1799578,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1799302,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1797770,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1787787,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1787103,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1780731,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1769522,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1768529,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1766175,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1758034,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1749304,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1746563,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1744317,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1741274,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1739391,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1725101,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1721352,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1717349,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1716397,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1716153,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1713318,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1713066,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1711122,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1708440,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1699462,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1694674,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1687363,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1686110,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1680312,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1676216,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1673535,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            }
        ]
    },
    {
        "title": "Valid Parenthesis String",
        "question_content": "<p>Given a string <code>s</code> containing only three types of characters: <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code> and <code>&#39;*&#39;</code>, return <code>true</code> <em>if</em> <code>s</code> <em>is <strong>valid</strong></em>.</p>\n\n<p>The following rules define a <strong>valid</strong> string:</p>\n\n<ul>\n\t<li>Any left parenthesis <code>&#39;(&#39;</code> must have a corresponding right parenthesis <code>&#39;)&#39;</code>.</li>\n\t<li>Any right parenthesis <code>&#39;)&#39;</code> must have a corresponding left parenthesis <code>&#39;(&#39;</code>.</li>\n\t<li>Left parenthesis <code>&#39;(&#39;</code> must go before the corresponding right parenthesis <code>&#39;)&#39;</code>.</li>\n\t<li><code>&#39;*&#39;</code> could be treated as a single right parenthesis <code>&#39;)&#39;</code> or a single left parenthesis <code>&#39;(&#39;</code> or an empty string <code>&quot;&quot;</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"()\"\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"(*)\"\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> s = \"(*))\"\n<strong>Output:</strong> true\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s[i]</code> is <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code> or <code>&#39;*&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 543521,
                "title": "java-count-open-parenthesis-o-n-time-o-1-space-picture-explain",
                "content": "**Problem 1: Check Valid Parenthesis of a string containing only two types of characters: \\'(\\', \\')\\'**\\n```java\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int openCount = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                openCount++;\\n            } else if (c == \\')\\') {\\n                openCount--;\\n            }\\n            if (openCount < 0) return false;    // Currently, don\\'t have enough open parentheses to match close parentheses-> Invalid\\n                                                // For example: ())(\\n        }\\n        return openCount == 0; // Fully match open parentheses with close parentheses\\n    }\\n}\\n```\\n\\n**Problem 2: Check Valid Parenthesis of a string containing only three types of characters: \\'(\\', \\')\\', \\'*\\'**\\nExample:\\n![image](https://assets.leetcode.com/users/hiepit/image_1587291349.png)\\n\\n\\n```java\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int cmin = 0, cmax = 0; // open parentheses count in range [cmin, cmax]\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                cmax++;\\n                cmin++;\\n            } else if (c == \\')\\') {\\n                cmax--;\\n                cmin--;\\n            } else if (c == \\'*\\') {\\n                cmax++; // if `*` become `(` then openCount++\\n                cmin--; // if `*` become `)` then openCount--\\n                // if `*` become `` then nothing happens\\n                // So openCount will be in new range [cmin-1, cmax+1]\\n            }\\n            if (cmax < 0) return false; // Currently, don\\'t have enough open parentheses to match close parentheses-> Invalid\\n                                        // For example: ())(\\n            cmin = Math.max(cmin, 0);   // It\\'s invalid if open parentheses count < 0 that\\'s why cmin can\\'t be negative\\n        }\\n        return cmin == 0; // Return true if can found `openCount == 0` in range [cmin, cmax]\\n    }\\n}\\n```\\nComplexity\\n- Time: `O(n)`\\n- Space: `O(1)`\\n\\nPlease help to **UPVOTE** if this post is useful for you. \\nIf you have any questions, feel free to comment below.\\nHappy coding!",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int openCount = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                openCount++;\\n            } else if (c == \\')\\') {\\n                openCount--;\\n            }\\n            if (openCount < 0) return false;    // Currently, don\\'t have enough open parentheses to match close parentheses-> Invalid\\n                                                // For example: ())(\\n        }\\n        return openCount == 0; // Fully match open parentheses with close parentheses\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int cmin = 0, cmax = 0; // open parentheses count in range [cmin, cmax]\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                cmax++;\\n                cmin++;\\n            } else if (c == \\')\\') {\\n                cmax--;\\n                cmin--;\\n            } else if (c == \\'*\\') {\\n                cmax++; // if `*` become `(` then openCount++\\n                cmin--; // if `*` become `)` then openCount--\\n                // if `*` become `` then nothing happens\\n                // So openCount will be in new range [cmin-1, cmax+1]\\n            }\\n            if (cmax < 0) return false; // Currently, don\\'t have enough open parentheses to match close parentheses-> Invalid\\n                                        // For example: ())(\\n            cmin = Math.max(cmin, 0);   // It\\'s invalid if open parentheses count < 0 that\\'s why cmin can\\'t be negative\\n        }\\n        return cmin == 0; // Return true if can found `openCount == 0` in range [cmin, cmax]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107577,
                "title": "short-java-o-n-time-o-1-space-one-pass",
                "content": "The idea is to similar to validate a string only contains '(' and ')'. But extend it to tracking the lower and upper bound of valid '(' counts. My thinking process is as following.\\n\\nscan from left to right, and record counts of unpaired \\u2018(\\u2019 for all possible cases. For \\u2018(\\u2019 and \\u2018)\\u2019, it is straightforward, just increment and decrement all counts, respectively. \\nWhen the character is '\\\\*', there are three cases, \\u2018(\\u2019, empty, or \\u2018)\\u2019, we can think those three cases as three branches in the ongoing route. \\nTake \\u201c(**())\\u201d as an example. There are 6 chars:\\n----At step 0: only one count = 1.\\n----At step 1: the route will be diverted into three branches. \\nso there are three counts: 1 - 1, 1, 1 + 1 which is 0, 1, 2, for \\u2018)\\u2019, empty and \\u2018(\\u2019 respectively.\\n----At step 2 each route is diverged into three routes again. so there will be 9 possible routes now. \\n--\\tFor count = 0, it will be diverted into 0 \\u2013 1, 0, 0 + 1, which is -1, 0, 1, but when the count is -1, that means there are more \\u2018)\\u2019s than \\u2018(\\u2019s, and we need to stop early at that route, since it is invalid. we end with 0, 1.\\n--\\tFor count = 1, it will be diverted into 1 \\u2013 1, 1, 1 + 1, which is 0, 1, 2\\n--\\tFor count = 2, it will be diverted into 2 \\u2013 1, 2, 2 + 1, which is 1, 2, 3\\nTo summarize step 2, we end up with counts of 0,1,2,3\\n----At step 3, increment all counts --> 1,2,3,4\\n----At step 4, decrement all counts --> 0,1,2,3\\n----At step 5, decrement all counts --> -1, 0,1,2,  the route with count -1 is invalid, so stop early at that route. Now we have 0,1,2.\\nIn the very end, we find that there is a route that can reach count == 0. Which means all \\u2018(\\u2019 and \\u2018)\\u2019 are cancelled. So, the original String is valid.\\nAnother finding is counts of unpaired \\u2018(\\u2019 for all valid routes are consecutive integers. So we only need to keep a lower and upper bound of that consecutive integers to save space.\\nOne case doesn\\u2019t show up in the example is: if the upper bound is negative, that means all routes have more \\u2018)\\u2019 than \\u2018(\\u2019 --> all routes are invalid --> stop and return false.\\n\\nHope this explanation helps.\\n\\n```\\n    public boolean checkValidString(String s) {\\n        int low = 0;\\n        int high = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == '(') {\\n                low++;\\n                high++;\\n            } else if (s.charAt(i) == ')') {\\n                if (low > 0) {\\n                    low--;\\n                }\\n                high--;\\n            } else {\\n                if (low > 0) {\\n                    low--;\\n                }\\n                high++;\\n            }\\n            if (high < 0) {\\n                return false;\\n            }\\n        }\\n        return low == 0;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean checkValidString(String s) {\\n        int low = 0;\\n        int high = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == '(') {\\n                low++;\\n                high++;\\n            } else if (s.charAt(i) == ')') {\\n                if (low > 0) {\\n                    low--;\\n                }\\n                high--;\\n            } else {\\n                if (low > 0) {\\n                    low--;\\n                }\\n                high++;\\n            }\\n            if (high < 0) {\\n                return false;\\n            }\\n        }\\n        return low == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107570,
                "title": "java-c-python-one-pass-count-the-open-parenthesis",
                "content": "## **Intuition**:\\nOne pass on the string `S`,\\nwe need to know,\\nhow many \\')\\' we are waiting for.\\n\\nIf we meet too many \\')\\', we can return `false` directly.\\nIf we wait for no \\')\\' at the end, then we are good.\\n\\n<br>\\n\\n## **Explanation**:\\nWe count the number of \\')\\' we are waiting for,\\nand it\\'s equal to the number of open parenthesis.\\nThis number will be in a range and we count it as ```[cmin, cmax]```\\n\\n```cmax``` counts the maximum open parenthesis,\\nwhich means the maximum number of unbalanced \\'(\\' that **COULD** be paired.\\n```cmin``` counts the minimum open parenthesis,\\nwhich means the number of unbalanced \\'(\\' that **MUST** be paired.\\n\\n<br>\\n\\n## **Example**:\\nIt\\'s quite straight forward actually.\\nWhen you met \"(\", you know you need one only one \")\", `cmin = 1` and `cmax = 1`.\\nWhen you met \"(*(\", you know you need one/two/three \")\",  `cmin = 1` and `cmax = 3`.\\n\\nThe string is valid for 2 condition:\\n1. ```cmax``` will never be negative.\\n2. ```cmin``` is 0 at the end.\\n\\n<br>\\n\\n## **Time Complexity**:\\nOne pass `O(N)` time, Space `O(1)`\\n\\n<br>\\n\\n**Java:**\\n```\\n    public boolean checkValidString(String s) {\\n        int cmin = 0, cmax = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                cmax++;\\n                cmin++;\\n            } else if (c == \\')\\') {\\n                cmax--;\\n                cmin = Math.max(cmin - 1, 0);\\n            } else {\\n                cmax++;\\n                cmin = Math.max(cmin - 1, 0);\\n            }\\n            if (cmax < 0) return false;\\n        }\\n        return cmin == 0;\\n    }\\n```\\n\\n**C++:**\\n```\\n    bool checkValidString(string s) {\\n        int cmin = 0, cmax = 0;\\n        for (char c : s) {\\n            if (c == \\'(\\')\\n                cmax++, cmin++;\\n            if (c == \\')\\')\\n                cmax--, cmin = max(cmin - 1, 0);\\n            if (c == \\'*\\')\\n                cmax++, cmin = max(cmin - 1, 0);\\n            if (cmax < 0) return false;\\n        }\\n        return cmin == 0;\\n    }\\n```\\n\\n**Python:**\\nEdited after vonzcy\\'s suggestion.\\n````\\ndef checkValidString(self, s):\\n        cmin = cmax = 0\\n        for i in s:\\n            if i == \\'(\\':\\n                cmax += 1\\n                cmin += 1\\n            if i == \\')\\':\\n                cmax -= 1\\n                cmin = max(cmin - 1, 0)\\n            if i == \\'*\\':\\n                cmax += 1\\n                cmin = max(cmin - 1, 0)\\n            if cmax < 0:\\n                return False\\n        return cmin == 0\\n````\\nor shorter\\n\\n````\\n    def checkValidString(self, s):\\n        cmin = cmax = 0\\n        for i in s:\\n            cmax = cmax - 1 if i == \")\" else cmax + 1\\n            cmin = cmin + 1 if i == \\'(\\' else max(cmin - 1, 0)\\n            if cmax < 0: return False\\n        return cmin == 0\\n````",
                "solutionTags": [],
                "code": "```[cmin, cmax]```\n```cmax```\n```cmin```\n```cmax```\n```cmin```\n```\\n    public boolean checkValidString(String s) {\\n        int cmin = 0, cmax = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                cmax++;\\n                cmin++;\\n            } else if (c == \\')\\') {\\n                cmax--;\\n                cmin = Math.max(cmin - 1, 0);\\n            } else {\\n                cmax++;\\n                cmin = Math.max(cmin - 1, 0);\\n            }\\n            if (cmax < 0) return false;\\n        }\\n        return cmin == 0;\\n    }\\n```\n```\\n    bool checkValidString(string s) {\\n        int cmin = 0, cmax = 0;\\n        for (char c : s) {\\n            if (c == \\'(\\')\\n                cmax++, cmin++;\\n            if (c == \\')\\')\\n                cmax--, cmin = max(cmin - 1, 0);\\n            if (c == \\'*\\')\\n                cmax++, cmin = max(cmin - 1, 0);\\n            if (cmax < 0) return false;\\n        }\\n        return cmin == 0;\\n    }\\n```\n````\\ndef checkValidString(self, s):\\n        cmin = cmax = 0\\n        for i in s:\\n            if i == \\'(\\':\\n                cmax += 1\\n                cmin += 1\\n            if i == \\')\\':\\n                cmax -= 1\\n                cmin = max(cmin - 1, 0)\\n            if i == \\'*\\':\\n                cmax += 1\\n                cmin = max(cmin - 1, 0)\\n            if cmax < 0:\\n                return False\\n        return cmin == 0\\n```\n````\\n    def checkValidString(self, s):\\n        cmin = cmax = 0\\n        for i in s:\\n            cmax = cmax - 1 if i == \")\" else cmax + 1\\n            cmin = cmin + 1 if i == \\'(\\' else max(cmin - 1, 0)\\n            if cmax < 0: return False\\n        return cmin == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 107572,
                "title": "java-using-2-stacks-o-n-space-and-time-complexity",
                "content": "The basic idea is to track the index of the left bracket and star position.   \\nPush all the indices of the star and left bracket to their stack respectively.  \\n**STEP 1**\\nOnce a right bracket comes, **pop left bracket stack first if it is not empty.**    If the left bracket stack is empty, pop the star stack if it is not empty.   **A false return can be made provided that both stacks are empty.**\\n\\n**STEP 2**\\nNow attention is paid to the remaining stuff in these two stacks.   Note that the left bracket **CANNOT** appear after the star as there is NO way to balance the bracket.   In other words, whenever there is a left bracket index appears after the Last star,  **a false statement can be made.**   Otherwise, pop out each from the left bracket and star stack.  \\n\\n**STEP 3** \\nA correct sequence should have an empty left bracket stack.   You don't need to take care of the star stack.  \\n\\n**Final Remarks:**\\nGreedy algorithm is used here.  We always want to use left brackets to balance the right one first as the * symbol is a wild card.   There is probably an O(1) space complexity but I think this is worth mentioning. \\n\\n```\\n    public boolean checkValidString(String s) {\\n        Stack<Integer> leftID = new Stack<>();\\n        Stack<Integer> starID = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (ch == '(')\\n                leftID.push(i);\\n            else if (ch == '*')\\n                starID.push(i);\\n            else {\\n                if (leftID.isEmpty() && starID.isEmpty())   return false;\\n                if (!leftID.isEmpty())\\n                    leftID.pop();\\n                else \\n                    starID.pop();\\n            }\\n        }\\n        while (!leftID.isEmpty() && !starID.isEmpty()) {\\n            if (leftID.pop() > starID.pop()) \\n                return false;\\n        }\\n        return leftID.isEmpty();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean checkValidString(String s) {\\n        Stack<Integer> leftID = new Stack<>();\\n        Stack<Integer> starID = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (ch == '(')\\n                leftID.push(i);\\n            else if (ch == '*')\\n                starID.push(i);\\n            else {\\n                if (leftID.isEmpty() && starID.isEmpty())   return false;\\n                if (!leftID.isEmpty())\\n                    leftID.pop();\\n                else \\n                    starID.pop();\\n            }\\n        }\\n        while (!leftID.isEmpty() && !starID.isEmpty()) {\\n            if (leftID.pop() > starID.pop()) \\n                return false;\\n        }\\n        return leftID.isEmpty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107566,
                "title": "java-12-lines-solution-backtracking",
                "content": "1. How to check valid parenthesis w/ only ```(``` and ```)```? Easy. Count each char from left to right. When we see ```(```, count++; when we see ```)``` count--; if count < 0, it is invalid (```)``` is more than ```(```); At last, count should == 0.\\n2. This problem added ```*```. The easiest way is to try ```3``` possible ways when we see it. Return true if one of them is valid.\\n```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        return check(s, 0, 0);\\n    }\\n    \\n    private boolean check(String s, int start, int count) {\\n        if (count < 0) return false;\\n        \\n        for (int i = start; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == '(') {\\n                count++;\\n            }\\n            else if (c == ')') {\\n                if (count <= 0) return false;\\n                count--;\\n            }\\n            else if (c == '*') {\\n                return check(s, i + 1, count + 1) || check(s, i + 1, count - 1) || check(s, i + 1, count);\\n            }\\n        }\\n        \\n        return count == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```(```\n```)```\n```(```\n```)```\n```)```\n```(```\n```*```\n```3```\n```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        return check(s, 0, 0);\\n    }\\n    \\n    private boolean check(String s, int start, int count) {\\n        if (count < 0) return false;\\n        \\n        for (int i = start; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == '(') {\\n                count++;\\n            }\\n            else if (c == ')') {\\n                if (count <= 0) return false;\\n                count--;\\n            }\\n            else if (c == '*') {\\n                return check(s, i + 1, count + 1) || check(s, i + 1, count - 1) || check(s, i + 1, count);\\n            }\\n        }\\n        \\n        return count == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302732,
                "title": "c-o-s-time-o-1-space-one-pass-with-explanation",
                "content": "\\nSee more code in my repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\nLet `diff` be count of left parenthesis minus count of right parenthesis.\\n\\nWhen we meet:\\n\\n* `(`, we increment `diff`.\\n* `)`, we decrement `diff`.\\n* `*`, we have three choices which makes the `diff` become a range -- `[diff - 1, diff + 1]`.\\n\\nSo we use `maxDiff`/`minDiff` to record the maximum/minimum `diff` we can get.\\n\\nWhen we meet:\\n\\n* `(`, `++maxDiff` and `++minDiff`.\\n* `)`, `--maxDiff` and `--minDiff`.\\n* `*`, `++maxDiff` and `--minDiff`.\\n\\nIf `maxDiff` become negative, it means it\\'s already invalid, we should return `false`.\\n\\nWhenever `minDiff` falls below `0`, we should force it to be `0` because we never accept negative `diff` during the process.\\n\\nAfter scanning through string `s`, as long as `minDiff` is `0`, this string can be a valid one.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/valid-parenthesis-string/\\n// Author: github.com/lzl124631x\\n// Time: O(S)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int maxDiff = 0, minDiff = 0;\\n        for (char c : s) {\\n            maxDiff += (c == \\'(\\' || c == \\'*\\') ? 1 : -1;\\n            minDiff += (c == \\')\\' || c == \\'*\\') ? -1 : 1;\\n            if (maxDiff < 0) return false;\\n            minDiff = max(0, minDiff);\\n        }\\n        return minDiff == 0;\\n    }\\n};\\n```\\n\\n---\\n\\nUpdate: 4/16/2020\\n\\n> Whenever `minDiff` falls below `0`, we should force it to be `0` because we never accept negative `diff` during the process.\\n\\n`minDiff` means the `diff` we got if we always try to replace `*` with `)`. If `minDiff` become `-1`, it means that this replacement results in more `)` than `(`, so it should be avoided. To avoid it, we simply reset `minDiff` from `-1` to `0` which implies we only replace `*` with `(` or empty string.\\n\\nExample: `(**)`\\n\\n* Seeing `(`, the range becomes `[1, 1]`.\\n* Seeing `*`, the range becomes `[0, 2]`. `0` correponds to `()`, `1` to `(_`, `2` to `((`.\\n* Seeing `*`, the range becomes `[-1,3]`. But `-1` is invalid because it means `())` and should be avoided. So we correct the range to `[0, 3]`.\\n* Seeing `)`, the range becomes `[-1, 2]`. Again, we correct the range to `[0, 2]` (because `-1` means `()_)` or `(_))`)\\n\\nThe final `[0, 2]` range means that we can either get a perfect string, or has `1` or `2` more `(` available (which are created by `*`).",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/valid-parenthesis-string/\\n// Author: github.com/lzl124631x\\n// Time: O(S)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int maxDiff = 0, minDiff = 0;\\n        for (char c : s) {\\n            maxDiff += (c == \\'(\\' || c == \\'*\\') ? 1 : -1;\\n            minDiff += (c == \\')\\' || c == \\'*\\') ? -1 : 1;\\n            if (maxDiff < 0) return false;\\n            minDiff = max(0, minDiff);\\n        }\\n        return minDiff == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 139759,
                "title": "java-very-easy-solution-no-recursion-or-dp",
                "content": "Think this might be logically easiest solution for this problem. \\nCheck from left to right and then check from right to left. \\nWhen check from left to right, take all \\'\\\\*\\'s as \\'(\\', to see whether can match all \\')\\'s.\\nAnd, When check from right to left, take all \\'\\\\*\\'s as \\')\\', to see whether can match all \\'(\\'s.\\nIf both checks are valid, then the string is valid.\\np.s. Thanks to @vagnihotri1117, we can return true if the first check returns bal=0. \\n```\\n\\tpublic boolean checkValidString(String s) {\\n        int bal = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\'*\\') bal++;\\n            else if (bal-- == 0) return false;\\n        }\\n        if (bal == 0) return true;\\n        bal = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            if (s.charAt(i) == \\')\\' || s.charAt(i) == \\'*\\') bal++;\\n            else if (bal-- == 0) return false;\\n        }\\n        return true;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\tpublic boolean checkValidString(String s) {\\n        int bal = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\'*\\') bal++;\\n            else if (bal-- == 0) return false;\\n        }\\n        if (bal == 0) return true;\\n        bal = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            if (s.charAt(i) == \\')\\' || s.charAt(i) == \\'*\\') bal++;\\n            else if (bal-- == 0) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 582134,
                "title": "c-2-pointer-approach-explained-o-1-space-o-n-time",
                "content": "This problem could be done similarly using two stacks, which I\\'ve already seen posted here, so no need to write the solution here, but if you\\'d like to see how it works, here\\'s a very nice explanation by fellow leetcoder.\\nhttps://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3301/discuss/582074/C++-Using-Two-Stacks\\n\\nFor this approach, I decided to see whether or not I could improve it, both in terms of space and time complexity, although his solution is perfectly fine, so here is my way of getting O(2 * N) time down to O(N) and O(2 * N) space down to O(1). Hope you enjoy!\\n\\nThe idea behind this approach is simple. We keep two counters, each for a seperate kind of parentheses. When we encounter \\'(\\', we increment the first counter and when we encounter \\')\\' we decrement it. The opposite is done to the second counter.\\n\\nIn both cases however, we increment our counters in case * is our current symbol. To illustrate it better I will first run two traversals and later merge them into a single loop. It\\'s easy to see why in the example, so let\\'s consider the following sequence:\\n`*()*(()*))`\\nFirst we traverse from left to right. For each position in the string our counter changes as follow:\\n```\\n-1 (before traversing) = 0\\n0 = 1\\n1 = 2\\n2 = 1\\n3 = 2\\n...\\n9 = 3\\n10 = 2\\n```\\nSince our final result is >= 0, we know there were at least the same number of open and closed parentheses. Were the result less than 0 (at any point), that would mean we encountered more closing parentheses than the opening ones - return false, that\\'s an impossible sequence.\\n\\nSimilarly, we traverse from the end now and swap the key values for incrementation/decrementatoin.\\n```\\n10 (before traversing) = 0\\n9 = 1\\n8 = 2\\n7 = 3\\n...\\n1 = 3\\n0 = 4\\n```\\nOur result is once again >= 0, which means we encountered at least the same number of opening and closing parenthesis. Were it different (at any given point), yet again that would mean we have not closed all the opening brackets until that point.\\n\\nNow let\\'s take a look at the merged code:\\n```cpp\\nint length = s.length() - 1;\\nint openCount = 0, closedCount = 0;\\nfor (int i = 0; i <= length; i++)\\n{\\n\\tif (s[i] == \\'*\\' || s[i] == \\'(\\') openCount++;\\n\\telse openCount--;\\n\\tif (s[length - i] == \\'*\\' || s[length - i] == \\')\\') closedCount++;\\n\\telse closedCount--;\\n\\tif (openCount < 0 || closedCount < 0) return false;\\n}\\nreturn true;\\n```\\n\\nThat\\'s all folks! Really hope you could understand everything. If anything is unclear, hit me up and let me know, your feedback is truly appreciated!",
                "solutionTags": [],
                "code": "```\\n-1 (before traversing) = 0\\n0 = 1\\n1 = 2\\n2 = 1\\n3 = 2\\n...\\n9 = 3\\n10 = 2\\n```\n```\\n10 (before traversing) = 0\\n9 = 1\\n8 = 2\\n7 = 3\\n...\\n1 = 3\\n0 = 4\\n```\n```cpp\\nint length = s.length() - 1;\\nint openCount = 0, closedCount = 0;\\nfor (int i = 0; i <= length; i++)\\n{\\n\\tif (s[i] == \\'*\\' || s[i] == \\'(\\') openCount++;\\n\\telse openCount--;\\n\\tif (s[length - i] == \\'*\\' || s[length - i] == \\')\\') closedCount++;\\n\\telse closedCount--;\\n\\tif (openCount < 0 || closedCount < 0) return false;\\n}\\nreturn true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107611,
                "title": "very-concise-c-solution-with-explaination-no-dp",
                "content": "Since * can be used as 3 kinds of char, if we do backtrack the complexity can blow up if the string is *****.... We need to find a non-trivial method.\\nWithout *, we can just use a number to indicate the unmatch (, ( will increment it and ) will decrement it. We don't want this number less than 0 all the time and it should be 0 when all the string has been matched.\\nWhen * is introduced, the number becomes a range, indicating the number of possible unmatched ( found. One * just expand the range by 1. And we can use the same principle to check if the criteria above is within the range.\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int lower = 0, upper = 0;\\n        for (char c : s) {\\n            if (c=='(') {\\n                lower++;\\n                upper++;\\n            } else if (c==')') {\\n                lower--;               \\n                upper--;\\n            } else { // * encountered\\n                lower--;\\n                upper++;\\n            }\\n            lower = max(lower, 0);\\n            if (upper<0) // unmatched ')' found in the middle of string\\n                return false;\\n        }\\n        return lower==0;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int lower = 0, upper = 0;\\n        for (char c : s) {\\n            if (c=='(') {\\n                lower++;\\n                upper++;\\n            } else if (c==')') {\\n                lower--;               \\n                upper--;\\n            } else { // * encountered\\n                lower--;\\n                upper++;\\n            }\\n            lower = max(lower, 0);\\n            if (upper<0) // unmatched ')' found in the middle of string\\n                return false;\\n        }\\n        return lower==0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 145228,
                "title": "python-using-stack-20ms-beats-100-probably-the-easiest-solution",
                "content": "class Solution(object):\\n    # The idea is, we firstly treat * as left (, then we need to make sure the left ( is always more than or equal to ).\\n    # We can use a stack to do this. \\n    # Then similarly, we treat * as a right ), we go through s from right to left, to make sure the right ) is always \\n\\t # more than or equal to (. If both experiments succeed, then return True.\\n    \\n    # O(n) time, O(n) space\\n    def checkValidString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        # stack 1, try to test all the ( and * can balance all the )\\n        S=[]        \\n        # go through s from left to right\\n        for x in s:\\n            if x==\\'(\\' or x==\\'*\\':\\n                S.append(x)\\n            else:\\n                if len(S)>0:\\n                    S.pop()\\n                else:\\n                    return False        # this means left ( is not enough\\n        \\n        # stack 2, try to test all the ) and * can balance all the (\\n        S=[]        \\n        # go through s from right to left\\n        for x in s[::-1]:\\n            if x==\\')\\' or x==\\'*\\':\\n                S.append(x)\\n            else:\\n                if len(S)>0:\\n                    S.pop()\\n                else:\\n                    return False        # this means right ) is not enough\\n        \\n        return True\\n        \\n        \\n        \\n            ",
                "solutionTags": [],
                "code": "class Solution(object):\\n    # The idea is, we firstly treat * as left (, then we need to make sure the left ( is always more than or equal to ).\\n    # We can use a stack to do this. \\n    # Then similarly, we treat * as a right ), we go through s from right to left, to make sure the right ) is always \\n\\t # more than or equal to (. If both experiments succeed, then return True.\\n    \\n    # O(n) time, O(n) space\\n    def checkValidString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        # stack 1, try to test all the ( and * can balance all the )\\n        S=[]        \\n        # go through s from left to right\\n        for x in s:\\n            if x==\\'(\\' or x==\\'*\\':\\n                S.append(x)\\n            else:\\n                if len(S)>0:\\n                    S.pop()\\n                else:\\n                    return False        # this means left ( is not enough\\n        \\n        # stack 2, try to test all the ) and * can balance all the (\\n        S=[]        \\n        # go through s from right to left\\n        for x in s[::-1]:\\n            if x==\\')\\' or x==\\'*\\':\\n                S.append(x)\\n            else:\\n                if len(S)>0:\\n                    S.pop()\\n                else:\\n                    return False        # this means right ) is not enough\\n        \\n        return True\\n        \\n        \\n        \\n            ",
                "codeTag": "Java"
            },
            {
                "id": 3295236,
                "title": "c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver",
                "content": "# Intuition\\nFirst think about Recursive solution. On the very high level building recursive solution is easy.. Whenever we will face `*` then we have three choices. Add an `opening bracket` or `closing bracket` or `add nothing`. Now lets build the intuition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwhenever you will face an opening bracket then count of opening bracket will increase by 1 and for closing bracket the count of opening bracket will decrease by 1.\\n\\nFinally at the end of the string opening bracket count has to be 0 to be a valid parenthesis string.\\n\\n# Here an edge case.. \\n**Decreasing opening bracket count by 1 when we face a closing bracket states that a closing bracket counters/closes an opening bracket. but if opening bracket count is 0 that means there is no opening bracket to counter/close. \\nSo we will only decrease opening bracket count by 1 when we will face a closing bracket and opening bracket count is not zero.**\\n\\n# Now our recursive solution will build up.\\n\\nThe base case is -> if index reaches end of the string then we will return true if opening bracket count is 0 (Means all opening bracket has been closed by a closing bracket) else we will return false.\\n\\nAnd if the `s[ind]` is not a `*`.\\n- Then if `s[ind] == opening bracket \\'(\\'` then opening bracket count will increase by 1 and move to `ind+1`\\n- And if `s[ind] == closing bracket \\')\\'` then opening bracket count will decrease by 1 if opening bracket count is not 0 and move to `ind+1`\\n\\nAnd if the `s[ind]` is a `*`\\n- Then we can add a opening bracket means opening bracket count will increase by 1 and move to `ind+1`.\\n- Or we can add a closing bracket means opening bracket count will decrease by 1 if opening bracket count is not 0 and move to `ind+1`\\n- Or we don\\'t add anything means opening bracket count will remain same and move to `ind+1`\\n```\\n// Recursive Solution\\nclass Solution {\\n    bool ex(int ind, int openingBracket, string &s){\\n        if(ind==s.size()) return (openingBracket==0);\\n\\n        bool ans=false;\\n        if(s[ind]==\\'*\\'){\\n            ans|=ex(ind+1,openingBracket+1,s); // Add \\'(\\'\\n            if(openingBracket) ans|=ex(ind+1,openingBracket-1,s); // Add \\')\\'\\n            ans|=ex(ind+1,openingBracket,s); //Add Nothing\\n        }else{\\n            if(s[ind]==\\'(\\'){\\n                ans=ex(ind+1,openingBracket+1,s);\\n            }else{\\n                if(openingBracket) ans=ex(ind+1,openingBracket-1,s);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\npublic:\\n    bool checkValidString(string s) {\\n        return ex(0,0,s);\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O (3 ^ n)` This recursive solution will give you TLE because `3 ^ 100` is huge\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O (1)`\\n\\n# Now convert Recursive solution to Memoization.\\nwe have to memoize the recursive solution using a DP table. Becase there are so many repetition.\\n\\nOur DP table will store true or false means if the string is valid for every possible combination of index and opening bracket count.\\nSo lets cache the calculated state in the DP table. And for every iteration just check if the current states are already calculated  or not. If it\\'s then directly return the value from DP table.\\n```\\n// Memoization\\nclass Solution {\\n    bool ex(int ind, int openingBracket, string &s, vector<vector<int>> &dp){\\n        if(ind==s.size()) return (openingBracket==0);\\n\\n        if(dp[ind][openingBracket]!=-1) return dp[ind][openingBracket];\\n\\n        bool ans=false;\\n        if(s[ind]==\\'*\\'){\\n            ans|=ex(ind+1,openingBracket+1,s,dp);\\n            if(openingBracket) ans|=ex(ind+1,openingBracket-1,s,dp);\\n            ans|=ex(ind+1,openingBracket,s,dp);\\n        }else{\\n            if(s[ind]==\\'(\\'){\\n                ans=ex(ind+1,openingBracket+1,s,dp);\\n            }else{\\n                if(openingBracket) ans=ex(ind+1,openingBracket-1,s,dp);\\n            }\\n        }\\n\\n        return dp[ind][openingBracket]=ans;\\n    }\\n\\npublic:\\n    bool checkValidString(string s) {\\n        vector<vector<int>> dp(s.size(), vector<int>(s.size(),-1));\\n        return ex(0,0,s,dp);\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O (n ^ 2) + Recursion stack space` \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O (n * n)`\\n\\n# Now convert Memoization to Tabulation.\\n\\nTabulation means run loop for checking every changing parameters. Here is only two changing parameters. One is index and another one is opening bracket count. so run two loop to go through every possibilities. \\n\\n**Now copy the base case from recursive solution/memoization**\\n\\n- `if(ind==s.size()) return (openingBracket==0);`\\nMeans `dp[s.size()][0] = true` states that at the end of the string opening bracket count has to be 0 to be a valid parenthesis string.\\n\\n**Now copy the recurrence**\\n- Our answer will be stored in `dp[0][0]` states that we will check every combination of index and opening bracket count by two for loops. One for index and one for opening bracket count. \\nAfter traversing the whole string if at `dp[0][0] == true` means It is possible to make a way where after traversing the whole string our opening bracket count will be 0 (Valid parenthesis).\\n```\\n// Tabulation\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        vector<vector<int>> dp(s.size()+1, vector<int>(s.size()+1,0));\\n        dp[s.size()][0]=1;\\n\\n        for(int ind=s.size()-1; ind>=0; ind--){\\n            for(int openingBracket=0; openingBracket<s.size(); openingBracket++){\\n                bool ans=false;\\n                if(s[ind]==\\'*\\'){\\n                    ans|=dp[ind+1][openingBracket+1];\\n                    if(openingBracket) ans|=dp[ind+1][openingBracket-1];\\n                    ans|=dp[ind+1][openingBracket];\\n                }else{\\n                    if(s[ind]==\\'(\\'){\\n                        ans|=dp[ind+1][openingBracket+1];\\n                    }else{\\n                        if(openingBracket) ans|=dp[ind+1][openingBracket-1];\\n                    }\\n                }\\n\\n                dp[ind][openingBracket]=ans;\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O (n ^ 2)`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O (n * n)`\\n\\n# Pleaseeeeeeeeeeeeeeeeeeeee UPVOTE\\n![2roca1.jpg](https://assets.leetcode.com/users/images/7acee8c3-2878-4b8c-a343-f09637b5a43b_1678780243.426397.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Recursive Solution\\nclass Solution {\\n    bool ex(int ind, int openingBracket, string &s){\\n        if(ind==s.size()) return (openingBracket==0);\\n\\n        bool ans=false;\\n        if(s[ind]==\\'*\\'){\\n            ans|=ex(ind+1,openingBracket+1,s); // Add \\'(\\'\\n            if(openingBracket) ans|=ex(ind+1,openingBracket-1,s); // Add \\')\\'\\n            ans|=ex(ind+1,openingBracket,s); //Add Nothing\\n        }else{\\n            if(s[ind]==\\'(\\'){\\n                ans=ex(ind+1,openingBracket+1,s);\\n            }else{\\n                if(openingBracket) ans=ex(ind+1,openingBracket-1,s);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\npublic:\\n    bool checkValidString(string s) {\\n        return ex(0,0,s);\\n    }\\n};\\n```\n```\\n// Memoization\\nclass Solution {\\n    bool ex(int ind, int openingBracket, string &s, vector<vector<int>> &dp){\\n        if(ind==s.size()) return (openingBracket==0);\\n\\n        if(dp[ind][openingBracket]!=-1) return dp[ind][openingBracket];\\n\\n        bool ans=false;\\n        if(s[ind]==\\'*\\'){\\n            ans|=ex(ind+1,openingBracket+1,s,dp);\\n            if(openingBracket) ans|=ex(ind+1,openingBracket-1,s,dp);\\n            ans|=ex(ind+1,openingBracket,s,dp);\\n        }else{\\n            if(s[ind]==\\'(\\'){\\n                ans=ex(ind+1,openingBracket+1,s,dp);\\n            }else{\\n                if(openingBracket) ans=ex(ind+1,openingBracket-1,s,dp);\\n            }\\n        }\\n\\n        return dp[ind][openingBracket]=ans;\\n    }\\n\\npublic:\\n    bool checkValidString(string s) {\\n        vector<vector<int>> dp(s.size(), vector<int>(s.size(),-1));\\n        return ex(0,0,s,dp);\\n    }\\n};\\n```\n```\\n// Tabulation\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        vector<vector<int>> dp(s.size()+1, vector<int>(s.size()+1,0));\\n        dp[s.size()][0]=1;\\n\\n        for(int ind=s.size()-1; ind>=0; ind--){\\n            for(int openingBracket=0; openingBracket<s.size(); openingBracket++){\\n                bool ans=false;\\n                if(s[ind]==\\'*\\'){\\n                    ans|=dp[ind+1][openingBracket+1];\\n                    if(openingBracket) ans|=dp[ind+1][openingBracket-1];\\n                    ans|=dp[ind+1][openingBracket];\\n                }else{\\n                    if(s[ind]==\\'(\\'){\\n                        ans|=dp[ind+1][openingBracket+1];\\n                    }else{\\n                        if(openingBracket) ans|=dp[ind+1][openingBracket-1];\\n                    }\\n                }\\n\\n                dp[ind][openingBracket]=ans;\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582074,
                "title": "c-using-two-stacks",
                "content": "Explanation : \\n\\'*\\' can act as \\'(\\' , \\')\\' ,\\'\\'\\nCreate Two stacks\\nopen :  for storing the indices of \\'(\\' ,and \\nast   :  for storing the indices of \\'*\\'\\nWe will solve the Problem in two stages :\\n#1 STAGE:\\nhere we consider \\'*\\' also as an opening paranthesis IF open stack becomes empty\\nsteps:\\nTraverse over the string:\\n  for any character s[i] , i being its index\\n*   if   s[i] == \\'(\\'\\n       push i in open stack\\n*  if s[i] == \\'*\\'\\n      push i in ast stack\\n* if s[i] == \\')\\'\\n     > pop one elements from open stack\\n\\t  but if open stack is empty :\\n\\t > pop one element from ast stack\\n\\t  but if ast stack is also empty , return false\\n\\t  \\nAfter traversing all the characters, comes Second stage:\\n#2 STAGE:\\nHere we consider \\'*\\' as a closed paranthesis\\nUntil open or ast stack becomes empty perform:\\n* if index at top of open stack > index at top of ast stack, this means there was no \\'*\\' after the last \\'(\\' , so return false\\n* otherwise pop one element from both open and ast stack\\n\\nfinally check if open stack is empty,\\nif YES then we were able to balance the complete string , return TRUE\\nelse return FALSE\\n\\nCODE:\\n```\\nbool checkValidString(string s) {\\n      stack<int> open,ast;\\n      for(int i=0;i<s.length();i++)\\n      {\\n          if(s[i] == \\')\\')\\n          {\\n              if(!open.empty()) open.pop();\\n              else if(!ast.empty()) ast.pop();\\n              else return false;\\n          }\\n          else if(s[i] == \\'(\\')   open.push(i);\\n          else ast.push(i);\\n      }\\n      while(!open.empty() && !ast.empty())\\n      {\\n         if(open.top() > ast.top()) return false;\\n         open.pop();\\n          ast.pop();\\n      }\\n        return open.empty();\\n    }",
                "solutionTags": [],
                "code": "Explanation : \\n\\'*\\' can act as \\'(\\' , \\')\\' ,\\'\\'\\nCreate Two stacks\\nopen :  for storing the indices of \\'(\\' ,and \\nast   :  for storing the indices of \\'*\\'\\nWe will solve the Problem in two stages :\\n#1 STAGE:\\nhere we consider \\'*\\' also as an opening paranthesis IF open stack becomes empty\\nsteps:\\nTraverse over the string:\\n  for any character s[i] , i being its index\\n*   if   s[i] == \\'(\\'\\n       push i in open stack\\n*  if s[i] == \\'*\\'\\n      push i in ast stack\\n* if s[i] == \\')\\'\\n     > pop one elements from open stack\\n\\t  but if open stack is empty :\\n\\t > pop one element from ast stack\\n\\t  but if ast stack is also empty , return false\\n\\t  \\nAfter traversing all the characters, comes Second stage:\\n#2 STAGE:\\nHere we consider \\'*\\' as a closed paranthesis\\nUntil open or ast stack becomes empty perform:\\n* if index at top of open stack > index at top of ast stack, this means there was no \\'*\\' after the last \\'(\\' , so return false\\n* otherwise pop one element from both open and ast stack\\n\\nfinally check if open stack is empty,\\nif YES then we were able to balance the complete string , return TRUE\\nelse return FALSE\\n\\nCODE:\\n```\\nbool checkValidString(string s) {\\n      stack<int> open,ast;\\n      for(int i=0;i<s.length();i++)\\n      {\\n          if(s[i] == \\')\\')\\n          {\\n              if(!open.empty()) open.pop();\\n              else if(!ast.empty()) ast.pop();\\n              else return false;\\n          }\\n          else if(s[i] == \\'(\\')   open.push(i);\\n          else ast.push(i);\\n      }\\n      while(!open.empty() && !ast.empty())\\n      {\\n         if(open.top() > ast.top()) return false;\\n         open.pop();\\n          ast.pop();\\n      }\\n        return open.empty();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 347113,
                "title": "top-down-recursive-solution-dp-memoization-1-ms",
                "content": "Intuition: increment `open` variable when we get `(` and decrement it when `)`.\\nOtherwise we just need to consider 3 cases: skip `*`  symbol or substitute it with either closing or opening bracket, i.e. increase or decrease `open`.\\n\\nCheck for case when we want to decrement zero-valued `open`, that means that we want to put `)` before `(`, which is not acceptable.\\n\\n```\\n    public boolean checkValidString(String s) {\\n        return checkValidString(s, 0, 0);\\n    }\\n\\n    private boolean checkValidString(String s, int index, int open) {\\n        if (index == s.length()) {\\n            return open == 0;\\n        }\\n        if (s.charAt(index) == \\'(\\') {\\n            return checkValidString(s, index + 1, open + 1);\\n        } else if (s.charAt(index) == \\')\\') {\\n            return open != 0 && checkValidString(s, index + 1, open - 1);\\n        } else {\\n            return checkValidString(s, index + 1, open)\\n                    || checkValidString(s, index + 1, open + 1)\\n                    || open != 0 && checkValidString(s, index + 1, open - 1);\\n        }\\n    }\\n```\\n\\nTime complexity ~ O(3^s), ~ 300 ms execution time\\n\\nMemoized solution:\\n\\n```\\n    public boolean checkValidStringMemo(String s) {\\n        Boolean[][] memo = new Boolean[s.length()][s.length()];\\n        return checkValidStringMemo(s, 0, 0, memo);\\n    }\\n\\n    private boolean checkValidStringMemo(String s, int index, int open, Boolean[][] memo) {\\n        if (index == s.length()) {\\n            return open == 0;\\n        }\\n        if (memo[index][open] != null) return memo[index][open];\\n        if (s.charAt(index) == \\'(\\') {\\n            memo[index][open] = checkValidStringMemo(s, index + 1, open + 1, memo);\\n        } else if (s.charAt(index) == \\')\\') {\\n            memo[index][open] = open != 0 && checkValidStringMemo(s, index + 1, open - 1, memo);\\n        } else {\\n            memo[index][open] = checkValidStringMemo(s, index + 1, open, memo)\\n                    || checkValidStringMemo(s, index + 1, open + 1, memo)\\n                    || open != 0 && checkValidStringMemo(s, index + 1, open - 1, memo);\\n        }\\n        return memo[index][open];\\n    }\\n```\\n\\nTime/Space complexity ~ O(s^2), ~ 1 ms execution time",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    public boolean checkValidString(String s) {\\n        return checkValidString(s, 0, 0);\\n    }\\n\\n    private boolean checkValidString(String s, int index, int open) {\\n        if (index == s.length()) {\\n            return open == 0;\\n        }\\n        if (s.charAt(index) == \\'(\\') {\\n            return checkValidString(s, index + 1, open + 1);\\n        } else if (s.charAt(index) == \\')\\') {\\n            return open != 0 && checkValidString(s, index + 1, open - 1);\\n        } else {\\n            return checkValidString(s, index + 1, open)\\n                    || checkValidString(s, index + 1, open + 1)\\n                    || open != 0 && checkValidString(s, index + 1, open - 1);\\n        }\\n    }\\n```\n```\\n    public boolean checkValidStringMemo(String s) {\\n        Boolean[][] memo = new Boolean[s.length()][s.length()];\\n        return checkValidStringMemo(s, 0, 0, memo);\\n    }\\n\\n    private boolean checkValidStringMemo(String s, int index, int open, Boolean[][] memo) {\\n        if (index == s.length()) {\\n            return open == 0;\\n        }\\n        if (memo[index][open] != null) return memo[index][open];\\n        if (s.charAt(index) == \\'(\\') {\\n            memo[index][open] = checkValidStringMemo(s, index + 1, open + 1, memo);\\n        } else if (s.charAt(index) == \\')\\') {\\n            memo[index][open] = open != 0 && checkValidStringMemo(s, index + 1, open - 1, memo);\\n        } else {\\n            memo[index][open] = checkValidStringMemo(s, index + 1, open, memo)\\n                    || checkValidStringMemo(s, index + 1, open + 1, memo)\\n                    || open != 0 && checkValidStringMemo(s, index + 1, open - 1, memo);\\n        }\\n        return memo[index][open];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 598680,
                "title": "concise-java-algo-one-pass-o-n-0ms",
                "content": "Idea is to keep track of how many `*` you have seen so far, and also of how many of those `*` you used as closing paranthesis. Go greedy on completing valid sequences, either with `)` or using `*`. \\n\\nWhen we greedily use `*` to complete one `()`, _we might actually break up the existing valid pair in the sequence_. And hence we might alienate one `)`, which could have matched with current `(`. So we need to account for that.\\n\\nsome, informal, description on steps:\\n\\n1. start from the left- keep pushing all `(` into stack.\\n2. When you encounter `)`:\\n\\t1. if stack not empty, pop one element: (Stack will only have `(` parantheses)\\n\\t4. if stack is empty, then check if we have seen (or used) any `*` so far:  \\n\\t\\t1. if yes, we can _let go_ of this `)` and decrement count for  `*`\\n\\t6. otherwise return `false`\\n7. When you encounter `*`:\\n\\t1. increment count for `*`\\n\\t9. if stack contains elements:\\n\\t\\t1. _pop_  one element to complete valid sequence,  and increment count for `*` again: cuz we used one `(` (and might have broken existing valid pair in the sequence)\\n11. At the end, stack should be emtpy for a valid string, as usual\\n\\n**Here is implementation of my algo**:\\n```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        Deque<Character> stk = new ArrayDeque<>();\\n        int scount = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c == \\'(\\') stk.push(c);\\n            else {\\n                if(c == \\')\\' && !stk.isEmpty()) stk.pop();\\n                else if(c == \\')\\' && scount > 0) scount--;\\n                else if(c  == \\')\\') return false;\\n                else {\\n                    scount++;\\n                    if(!stk.isEmpty()) {\\n                        stk.pop();\\n                        scount++;\\n                    }\\n                }\\n            }\\n        }\\n        return stk.isEmpty();\\n    }\\n}\\n```\\n\\n**More concise solution based on feedback:**\\n```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int leftParans = 0;\\n        int stars = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c == \\'(\\') leftParans++;\\n            else if(c == \\')\\') {\\n                if(leftParans > 0) leftParans--;\\n                else if(stars > 0) stars--;\\n                else return false;\\n            } else {\\n                stars++;\\n                if(leftParans > 0) {\\n                    leftParans--;\\n                    stars++;\\n                }\\n            }\\n        }\\n        return leftParans == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        Deque<Character> stk = new ArrayDeque<>();\\n        int scount = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c == \\'(\\') stk.push(c);\\n            else {\\n                if(c == \\')\\' && !stk.isEmpty()) stk.pop();\\n                else if(c == \\')\\' && scount > 0) scount--;\\n                else if(c  == \\')\\') return false;\\n                else {\\n                    scount++;\\n                    if(!stk.isEmpty()) {\\n                        stk.pop();\\n                        scount++;\\n                    }\\n                }\\n            }\\n        }\\n        return stk.isEmpty();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int leftParans = 0;\\n        int stars = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c == \\'(\\') leftParans++;\\n            else if(c == \\')\\') {\\n                if(leftParans > 0) leftParans--;\\n                else if(stars > 0) stars--;\\n                else return false;\\n            } else {\\n                stars++;\\n                if(leftParans > 0) {\\n                    leftParans--;\\n                    stars++;\\n                }\\n            }\\n        }\\n        return leftParans == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584655,
                "title": "python-o-n-by-stack-85-w-comment",
                "content": "Python O(n) by stack. \\n\\n---\\n\\n```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        \\n        # store the indices of \\'(\\'\\n        stk = []\\n        \\n        # store the indices of \\'*\\'\\n        star = []\\n        \\n        \\n        for idx, char in enumerate(s):\\n            \\n            if char == \\'(\\':\\n                stk.append( idx )\\n                \\n            elif char == \\')\\':\\n                \\n                if stk:\\n                    stk.pop()\\n                elif star:\\n                    star.pop()\\n                else:\\n                    return False\\n            \\n            else:\\n                star.append( idx )\\n        \\n        \\n        # cancel ( and * with valid positions, i.e., \\'(\\' must be on the left hand side of \\'*\\'\\n        while stk and star:\\n            if stk[-1] > star[-1]:\\n                return False\\n        \\n            stk.pop()\\n            star.pop()\\n        \\n        \\n        # Accept when stack is empty, which means all braces are paired\\n        # Reject, otherwise.\\n        return len(stk) == 0\\n                \\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #20 Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        \\n        # store the indices of \\'(\\'\\n        stk = []\\n        \\n        # store the indices of \\'*\\'\\n        star = []\\n        \\n        \\n        for idx, char in enumerate(s):\\n            \\n            if char == \\'(\\':\\n                stk.append( idx )\\n                \\n            elif char == \\')\\':\\n                \\n                if stk:\\n                    stk.pop()\\n                elif star:\\n                    star.pop()\\n                else:\\n                    return False\\n            \\n            else:\\n                star.append( idx )\\n        \\n        \\n        # cancel ( and * with valid positions, i.e., \\'(\\' must be on the left hand side of \\'*\\'\\n        while stk and star:\\n            if stk[-1] > star[-1]:\\n                return False\\n        \\n            stk.pop()\\n            star.pop()\\n        \\n        \\n        # Accept when stack is empty, which means all braces are paired\\n        # Reject, otherwise.\\n        return len(stk) == 0\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 586143,
                "title": "c-stack-runtime-nd-memory-efficient-100",
                "content": "```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Valid Parenthesis String.\\nMemory Usage: 6.1 MB, less than 100.00% of C++ online submissions for Valid Parenthesis String.\\n\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack<int> asterisk;\\n        stack<int> validPar;\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(s[i] == \\'(\\') validPar.push(i);\\n            if(s[i] == \\'*\\') asterisk.push(i);\\n            if(s[i] == \\')\\'){\\n                if(!validPar.empty()) \\n                    validPar.pop();\\n                else if(!asterisk.empty()) \\n                    asterisk.pop();\\n                else \\n                    return false;\\n            }\\n        }\\n        \\n        while(!validPar.empty() && !asterisk.empty()){\\n            if(validPar.top() > asterisk.top()) return false;\\n            \\n            validPar.pop(); asterisk.pop();\\n        }\\n        \\n        return validPar.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Valid Parenthesis String.\\nMemory Usage: 6.1 MB, less than 100.00% of C++ online submissions for Valid Parenthesis String.\\n\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack<int> asterisk;\\n        stack<int> validPar;\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(s[i] == \\'(\\') validPar.push(i);\\n            if(s[i] == \\'*\\') asterisk.push(i);\\n            if(s[i] == \\')\\'){\\n                if(!validPar.empty()) \\n                    validPar.pop();\\n                else if(!asterisk.empty()) \\n                    asterisk.pop();\\n                else \\n                    return false;\\n            }\\n        }\\n        \\n        while(!validPar.empty() && !asterisk.empty()){\\n            if(validPar.top() > asterisk.top()) return false;\\n            \\n            validPar.pop(); asterisk.pop();\\n        }\\n        \\n        return validPar.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582174,
                "title": "simple-python-solution-time-o-n-space-o-1",
                "content": "We need to check if the string is properly balanced with left parenthesis (chars \"(\" and \"*\") and properly right balanced - (chars \")\" and \"*\") . We check open parenthesis from the left and closed parenthesis from the right. So, use two vars to determine left and right balance. We should follow these rules:\\n1. If we met \"(\" or \"*\" - increment left balance; else decrement it\\n2. If we met \")\" or \"*\" - increment right balance; else decrement it\\n3. If we got negative values for left balance or right balance, we have unvaild string - wrong order of parenthesis or unequal number of open/closed parenthesis.\\n4. Repeat steps 1-3 until we reach the end of the string. Return True then, because string is properly balanced.\\n```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        # balance of left parenthesis and right parenthesis\\n        leftBalance = rightBalance = 0\\n        n = len(s)\\n        for i in range(n):\\n            # if char is ( or * - we increment leftBalance value\\n            if s[i] in \"(*\":\\n                leftBalance += 1\\n            # else decrement it\\n            else:\\n                leftBalance -= 1\\n            # we check right balance value starting from the end (right side)\\n            if s[n-i-1] in \"*)\":\\n                rightBalance += 1\\n            else:\\n                rightBalance -= 1\\n            # if any balance goes negative we have the case where order of parenthesis is wrong\\n            # e.g. )(  -> leftBalance will be -1 and rightBalance will be -1 after first iteration\\n            # or ((( - leftBalance is OK, but rightBalance will be -1 after first iteration\\n            if leftBalance < 0  or rightBalance < 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        # balance of left parenthesis and right parenthesis\\n        leftBalance = rightBalance = 0\\n        n = len(s)\\n        for i in range(n):\\n            # if char is ( or * - we increment leftBalance value\\n            if s[i] in \"(*\":\\n                leftBalance += 1\\n            # else decrement it\\n            else:\\n                leftBalance -= 1\\n            # we check right balance value starting from the end (right side)\\n            if s[n-i-1] in \"*)\":\\n                rightBalance += 1\\n            else:\\n                rightBalance -= 1\\n            # if any balance goes negative we have the case where order of parenthesis is wrong\\n            # e.g. )(  -> leftBalance will be -1 and rightBalance will be -1 after first iteration\\n            # or ((( - leftBalance is OK, but rightBalance will be -1 after first iteration\\n            if leftBalance < 0  or rightBalance < 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107589,
                "title": "java-o-n-2pass-ez-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int left = 0, right = 0, leftx = 0, rightx = 0;\\n        for (int i=0; i<s.length(); i++){\\n            if (s.charAt(i) == '(') left++;\\n            else if (s.charAt(i) == ')') left--;\\n            else leftx++;            \\n            if (left < 0){\\n                if (leftx == 0) return false;\\n                else{\\n                    leftx--;\\n                    left++;\\n                }\\n            }\\n        }\\n        for (int i=s.length()-1; i>=0; i--){\\n            if (s.charAt(i) == '(') right--;\\n            else if (s.charAt(i) == ')') right++;\\n            else rightx++;\\n            if (right < 0){\\n                if (rightx == 0) return false;\\n                else{\\n                    rightx--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\nThis might be easier to understand than the top O(n) solution :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int left = 0, right = 0, leftx = 0, rightx = 0;\\n        for (int i=0; i<s.length(); i++){\\n            if (s.charAt(i) == '(') left++;\\n            else if (s.charAt(i) == ')') left--;\\n            else leftx++;            \\n            if (left < 0){\\n                if (leftx == 0) return false;\\n                else{\\n                    leftx--;\\n                    left++;\\n                }\\n            }\\n        }\\n        for (int i=s.length()-1; i>=0; i--){\\n            if (s.charAt(i) == '(') right--;\\n            else if (s.charAt(i) == ')') right++;\\n            else rightx++;\\n            if (right < 0){\\n                if (rightx == 0) return false;\\n                else{\\n                    rightx--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401476,
                "title": "made-easy-c-w-comments",
                "content": "### Explained inside the code for better understanding.\\n# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack<char> open, star;\\n\\n        for(int i=0; i<size(s); i++)\\n        {\\n            //push the index of \\'(\\'\\n            if(s[i] == \\'(\\')\\n                open.push(i);\\n\\n            //push the index of \\'*\\'\\n            else if(s[i] == \\'*\\')\\n                star.push(i);\\n\\n            /*If we get a \\')\\' then\\n                either pop \\'(\\' if we have some\\n                or pop \\'*\\' if there\\'s no \\'(\\'.\\n            */\\n            else{\\n                if(!open.empty())\\n                    open.pop();\\n\\n                else if(!star.empty())\\n                    star.pop();\\n            \\n                //If both \\'(\\' ans \\'*\\' are exhausted then return false.\\n                else\\n                    return false;\\n            }\\n        }\\n\\n        //Processingthe leftover brackets in \\'open\\'\\n\\n        /*compare the position of \\'*\\' ans \\'(\\' if position of \\'*\\' is greater than \\'(\\' then it means we can convert some \\'*\\' to \\')\\'.*/\\n        while(!open.empty() && !star.empty() && star.top() > open.top())\\n        {\\n            open.pop();\\n            star.pop();\\n        }\\n\\n//After processing if open stack is still not empty the return false.\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return open.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack<char> open, star;\\n\\n        for(int i=0; i<size(s); i++)\\n        {\\n            //push the index of \\'(\\'\\n            if(s[i] == \\'(\\')\\n                open.push(i);\\n\\n            //push the index of \\'*\\'\\n            else if(s[i] == \\'*\\')\\n                star.push(i);\\n\\n            /*If we get a \\')\\' then\\n                either pop \\'(\\' if we have some\\n                or pop \\'*\\' if there\\'s no \\'(\\'.\\n            */\\n            else{\\n                if(!open.empty())\\n                    open.pop();\\n\\n                else if(!star.empty())\\n                    star.pop();\\n            \\n                //If both \\'(\\' ans \\'*\\' are exhausted then return false.\\n                else\\n                    return false;\\n            }\\n        }\\n\\n        //Processingthe leftover brackets in \\'open\\'\\n\\n        /*compare the position of \\'*\\' ans \\'(\\' if position of \\'*\\' is greater than \\'(\\' then it means we can convert some \\'*\\' to \\')\\'.*/\\n        while(!open.empty() && !star.empty() && star.top() > open.top())\\n        {\\n            open.pop();\\n            star.pop();\\n        }\\n\\n//After processing if open stack is still not empty the return false.\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return open.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583036,
                "title": "python-simple-solution-20-ms-faster-than-98-16",
                "content": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n\\t\\t# Simplify s to reduce complexity in further loop\\n        while s != s.replace(\"()\", \"\"):\\n            s = s.replace(\"()\", \"\")\\n\\t\\t\\t\\n\\t\\t\"\"\"\\n\\t\\tThe first loop, from left to right, is to check if there are supplementary \")\" before \"(\".\\n\\t\\tFor example, a string like \")(*\" won\\'t be able to pass the first loop.\\n\\t\\t\"\"\"\\n        queue = []\\n        for i in range(len(s)):\\n            if s[i] in [\"(\", \"*\"]:\\n                queue.append(1)\\n            else:\\n                if queue:\\n                    queue.pop()\\n                else:\\n                    return False\\n\\n\\t\\t\"\"\"\\n\\t\\tThe second loop, from right to left, is to check if there are supplementary \"(\" after \")\".\\n\\t\\tFor example, a string like \"*)(\" won\\'t be able to pass the second loop.\\n\\t\\t\"\"\"\\n        queue = []\\n        for i in range(len(s) - 1, -1, -1):\\n            if s[i] in [\")\", \"*\"]:\\n                queue.append(1)\\n            else:\\n                if queue:\\n                    queue.pop()\\n                else:\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n\\t\\t# Simplify s to reduce complexity in further loop\\n        while s != s.replace(\"()\", \"\"):\\n            s = s.replace(\"()\", \"\")\\n\\t\\t\\t\\n\\t\\t\"\"\"\\n\\t\\tThe first loop, from left to right, is to check if there are supplementary \")\" before \"(\".\\n\\t\\tFor example, a string like \")(*\" won\\'t be able to pass the first loop.\\n\\t\\t\"\"\"\\n        queue = []\\n        for i in range(len(s)):\\n            if s[i] in [\"(\", \"*\"]:\\n                queue.append(1)\\n            else:\\n                if queue:\\n                    queue.pop()\\n                else:\\n                    return False\\n\\n\\t\\t\"\"\"\\n\\t\\tThe second loop, from right to left, is to check if there are supplementary \"(\" after \")\".\\n\\t\\tFor example, a string like \"*)(\" won\\'t be able to pass the second loop.\\n\\t\\t\"\"\"\\n        queue = []\\n        for i in range(len(s) - 1, -1, -1):\\n            if s[i] in [\")\", \"*\"]:\\n                queue.append(1)\\n            else:\\n                if queue:\\n                    queue.pop()\\n                else:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902405,
                "title": "python-time-o-n-space-o-1-greedy-solution-with-detailed-explanation-and-some-proof",
                "content": "\\nFirst, if we do not have asterisk\\uFF0Cin order to be vaild\\n* obs1:  \"(\" should be more or equal to \")\" when we check the string from left to right\\n* obs2: At the end, there is no open \"(\" ( i.e. equal number of \"(\" and \")\")\\n\\nFor example,\\n* \"(()))(\"-> False, index = 4, two \"(\" and three \")\" then \")\" at index 4 will never be canceled out\\n* \"(((())\"-> False, at the end two unclosed \"(\"\\n\\nThus, to solve the problem, we can just count the open \"(\" by \\n* openleft = 0\\n*  meet \"(\", openleft += 1\\n*  meet \")\", openleft -= 1 once openleft < 0 -> \"(\" is less than \")\" return False\\n*  At the end, if openleft = 0 -> no open \"(\" and return True\\n\\nNow, let\\'s consider the asterisk. It can be \"(\", \")\" or \"\". Thus, there are more possibilities. The openleft can have different numbers by tunning the asterisk. Let the openleft be within [leftmin, leftmax] if go through the string left to right (now we do not consider the valid just count openleft range for each index)\\n* if \"(\", leftmin, leftmax += 1\\n* if  \")\", leftmin, leftmax  -=1\\n* if \"asterisk\", leftmin -=1 , leftmax += 1\\n\\n* obs3: Openleft can take any value within [leftmin, leftmax]. leftmin can make all \"asterisk\" to \")\", leftmax can make all \"asterisk\" to \"(\", other numbers can just tune the \"asterisk\"\\n\\n\\nHowever there some additional constrains to let the string to be vaild\\n* obs4: According to obs1, openleft shold be greater or equal to 0 at each index. If leftmax < 0, there is no possible openleft. If leftmax >= 0, the range becomes [max(leftmin,0), leftmax]. Since openleft can not take any negative value at each index, we need to truncate the range to above 0\\n* obs5: According to obs 2, at the end openleft should be 0, then the range should contain 0.  Under obs4 constraint, here it is just leftmin =0\\n\\nHere is the code. We only use two constant space leftmin and leftmax, thus space O(1). We need to go through one loop of the string thus time 0(n).\\n```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        leftmin = leftmax = 0\\n        for c in s:\\n            if c == \"(\":\\n                leftmax += 1\\n                leftmin += 1\\n            if c == \")\":\\n                leftmax -= 1\\n                leftmin = max(0, leftmin-1)\\n            if c == \"*\":\\n                leftmax +=1\\n                leftmin = max(0, leftmin-1)\\n            if leftmax < 0:\\n                return False\\n        if leftmin == 0:\\n            return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        leftmin = leftmax = 0\\n        for c in s:\\n            if c == \"(\":\\n                leftmax += 1\\n                leftmin += 1\\n            if c == \")\":\\n                leftmax -= 1\\n                leftmin = max(0, leftmin-1)\\n            if c == \"*\":\\n                leftmax +=1\\n                leftmin = max(0, leftmin-1)\\n            if leftmax < 0:\\n                return False\\n        if leftmin == 0:\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 124493,
                "title": "3ms-java-stack-with-explanation",
                "content": "**Thought**\\nIn Parenthesis-related problems, we care about **balance** only. When we meet `)`,  we have to sacrifice the most recent `(` we met to keep the balance (that\\'s why we establish `leftStack`). If we run out of `(`, the most recent `*` can be used as `(` (that\\'s why we establish `starStack`).\\nIn this way, it is promised that all `)`\\'s can be balanced after one traversal. We should make `(` balanced as well. Thus, we use `*`\\'s to cancel out `(`\\'s. If we run out of `*` but with `(` left, `s` is not valid.\\n**Code**\\n```\\n    public boolean checkValidString(String s) {\\n        Stack<Integer> leftStack = new Stack<>();\\n        Stack<Integer> starStack = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                leftStack.push(i);\\n            }\\n            else if (s.charAt(i) == \\')\\') {\\n                if (!leftStack.isEmpty()) {\\n                    leftStack.pop();\\n                }\\n                else if (!starStack.isEmpty()) {\\n                    starStack.pop();\\n                }\\n                else {\\n                    return false;\\n                }\\n            }\\n            else {\\n                starStack.push(i);\\n            }\\n        }\\n        while (!leftStack.isEmpty() && !starStack.isEmpty()) {\\n            int li = leftStack.pop();\\n            int si = starStack.pop();\\n            if (si < li) {\\n                return false;\\n            }\\n        }\\n        if (!leftStack.isEmpty()) {\\n            return false;\\n        }\\n        return true;\\n    }\\n```\\n**I appreciate your VOTE UP \\u2727\\u207A\\u2E1C(\\u25CF\\u02D9\\u25BE\\u02D9\\u25CF)\\u2E1D\\u207A\\u2727**",
                "solutionTags": [],
                "code": "```\\n    public boolean checkValidString(String s) {\\n        Stack<Integer> leftStack = new Stack<>();\\n        Stack<Integer> starStack = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                leftStack.push(i);\\n            }\\n            else if (s.charAt(i) == \\')\\') {\\n                if (!leftStack.isEmpty()) {\\n                    leftStack.pop();\\n                }\\n                else if (!starStack.isEmpty()) {\\n                    starStack.pop();\\n                }\\n                else {\\n                    return false;\\n                }\\n            }\\n            else {\\n                starStack.push(i);\\n            }\\n        }\\n        while (!leftStack.isEmpty() && !starStack.isEmpty()) {\\n            int li = leftStack.pop();\\n            int si = starStack.pop();\\n            if (si < li) {\\n                return false;\\n            }\\n        }\\n        if (!leftStack.isEmpty()) {\\n            return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1395754,
                "title": "java-easy-approach-with-explanation-greedy-o-n",
                "content": "```\\nclass Solution \\n{\\n    public boolean checkValidString(String s) \\n    {\\n        //cmax counts the maximum open parenthesis, which means the maximum number of unbalanced \\'(\\' that COULD be paired.\\n       //cmin counts the minimum open parenthesis, which means the number of unbalanced \\'(\\' that MUST be paired.\\n        int cmin = 0, cmax = 0; //range [cmin, cmax]\\n        for(char ch : s.toCharArray()) \\n        {\\n            if(ch == \\'(\\'){\\n                cmax+= 1;//incrasing the maximum number of open parenthesis count\\n                cmin+= 1;//incrasing the minimum number of open parenthesis count\\n            } \\n            else if(ch == \\')\\'){\\n                cmax-= 1;//decreasing the maximum number of open parenthesis count and balancing \\n                cmin-= 1;//decreasing the minimum number of open parenthesis count and balancing \\n            } \\n            else if(ch == \\'*\\') {//two possibility of * is that it can provide open parenthesis or close parenthesis \\n                cmax+= 1;//incrasing the maximum number of open parenthesis count\\n                cmin-= 1;//balancing the minimum number of open parenthesis \\n                //new range [cmin-1, cmax+1]\\n            }\\n            \\n            if(cmax < 0)//cmax will never be negative, to be balanced since number of open parentethesis cannot be less than the close parenthesis \\n              return false;//if less returning false \\n          \\n            cmin= Math.max(cmin, 0);//cmin cannot be less than 0, it must be greater than 0 \\n        }\\n        if(cmin == 0)//cmin is 0 at the end, to be balanced//all open parenthesis is balanced \\n           return true;\\n        return false;//else all open parenthesis is not balanced\\n    }\\n}//Please do upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean checkValidString(String s) \\n    {\\n        //cmax counts the maximum open parenthesis, which means the maximum number of unbalanced \\'(\\' that COULD be paired.\\n       //cmin counts the minimum open parenthesis, which means the number of unbalanced \\'(\\' that MUST be paired.\\n        int cmin = 0, cmax = 0; //range [cmin, cmax]\\n        for(char ch : s.toCharArray()) \\n        {\\n            if(ch == \\'(\\'){\\n                cmax+= 1;//incrasing the maximum number of open parenthesis count\\n                cmin+= 1;//incrasing the minimum number of open parenthesis count\\n            } \\n            else if(ch == \\')\\'){\\n                cmax-= 1;//decreasing the maximum number of open parenthesis count and balancing \\n                cmin-= 1;//decreasing the minimum number of open parenthesis count and balancing \\n            } \\n            else if(ch == \\'*\\') {//two possibility of * is that it can provide open parenthesis or close parenthesis \\n                cmax+= 1;//incrasing the maximum number of open parenthesis count\\n                cmin-= 1;//balancing the minimum number of open parenthesis \\n                //new range [cmin-1, cmax+1]\\n            }\\n            \\n            if(cmax < 0)//cmax will never be negative, to be balanced since number of open parentethesis cannot be less than the close parenthesis \\n              return false;//if less returning false \\n          \\n            cmin= Math.max(cmin, 0);//cmin cannot be less than 0, it must be greater than 0 \\n        }\\n        if(cmin == 0)//cmin is 0 at the end, to be balanced//all open parenthesis is balanced \\n           return true;\\n        return false;//else all open parenthesis is not balanced\\n    }\\n}//Please do upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423847,
                "title": "python-3-solution-using-stacks-easy-to-understand-code-and-explain",
                "content": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        if not s:\\n            return True\\n        \\n        # Maintaining two stacks\\n        # 1) left parenthesis\\'s indexes\\n        # 2) star\\'s (\"*\") indexes\\n        left = list()\\n        star = list()\\n        \\n        for i, c in enumerate(s):\\n            if c == \"*\":\\n                star.append(i)\\n            elif c == \"(\":\\n                left.append(i)\\n            elif c == \")\":\\n                # When encounter \"*\"\\n                # Prefer balance out using the left \"(\" than \"*\"\\n                if left:\\n                    left.pop()\\n                elif star:\\n                    star.pop()\\n                else:\\n                    return False\\n        \\n        if len(left) > len(star):\\n            # Checking the counts of residual left and star\\n            return False\\n        \\n        while left and star:\\n            # Compare the indexes of left and star\\n            # Make sure star came aftewards, if not, return False\\n            if left.pop() > star.pop():\\n                return False\\n        \\n        return True\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        if not s:\\n            return True\\n        \\n        # Maintaining two stacks\\n        # 1) left parenthesis\\'s indexes\\n        # 2) star\\'s (\"*\") indexes\\n        left = list()\\n        star = list()\\n        \\n        for i, c in enumerate(s):\\n            if c == \"*\":\\n                star.append(i)\\n            elif c == \"(\":\\n                left.append(i)\\n            elif c == \")\":\\n                # When encounter \"*\"\\n                # Prefer balance out using the left \"(\" than \"*\"\\n                if left:\\n                    left.pop()\\n                elif star:\\n                    star.pop()\\n                else:\\n                    return False\\n        \\n        if len(left) > len(star):\\n            # Checking the counts of residual left and star\\n            return False\\n        \\n        while left and star:\\n            # Compare the indexes of left and star\\n            # Make sure star came aftewards, if not, return False\\n            if left.pop() > star.pop():\\n                return False\\n        \\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 107581,
                "title": "o-n-time-o-1-space-no-recursion-just-scan-from-left-and-then-scan-from-right",
                "content": "Share my accepted code. \\nFirst scan from left, then scan from right.\\n````\\n    public boolean checkFromLeft(String s) {\\n        if (s == null || s.length() == 0) {\\n            return true;\\n        }\\n        int star = 0;\\n        int open = 0;\\n        int close = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == '(') {\\n                open++;\\n            } else if (c == ')') {\\n                close++;\\n            } else {\\n                star++;\\n            }\\n            if (close > open + star) {\\n                return false;\\n            }\\n        }\\n        if (close == open || close - open <= star) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public boolean checkFromRight(String s) {\\n        if (s == null || s.length() == 0) {\\n            return true;\\n        }\\n        int star = 0;\\n        int open = 0;\\n        int close = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            char c = s.charAt(i);\\n            if (c == ')') {\\n                open++;\\n            } else if (c == '(') {\\n                close++;\\n            } else {\\n                star++;\\n            }\\n            if (close > open + star) {\\n                return false;\\n            }\\n        }\\n        if (close == open || close - open <= star) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public boolean checkValidString(String s) {\\n        return checkFromLeft(s) && checkFromRight(s);\\n    }\\n````",
                "solutionTags": [],
                "code": "````\\n    public boolean checkFromLeft(String s) {\\n        if (s == null || s.length() == 0) {\\n            return true;\\n        }\\n        int star = 0;\\n        int open = 0;\\n        int close = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == '(') {\\n                open++;\\n            } else if (c == ')') {\\n                close++;\\n            } else {\\n                star++;\\n            }\\n            if (close > open + star) {\\n                return false;\\n            }\\n        }\\n        if (close == open || close - open <= star) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public boolean checkFromRight(String s) {\\n        if (s == null || s.length() == 0) {\\n            return true;\\n        }\\n        int star = 0;\\n        int open = 0;\\n        int close = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            char c = s.charAt(i);\\n            if (c == ')') {\\n                open++;\\n            } else if (c == '(') {\\n                close++;\\n            } else {\\n                star++;\\n            }\\n            if (close > open + star) {\\n                return false;\\n            }\\n        }\\n        if (close == open || close - open <= star) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public boolean checkValidString(String s) {\\n        return checkFromLeft(s) && checkFromRight(s);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3356782,
                "title": "easy-intuitive-solution-greedy-100-fast-0-memory-consumption",
                "content": "# Intuition\\nThe basic rule of Parenthesis matching  at each point is \\n- While traversing from left to right count(leftParenthesis)> count(rightParenthesis). Then at the end of traversal, we can check if left==right.\\n- While traversing from right to left count(rightParenthesis)> count(leftParenthesis). Then at the end of traversal, we can check if left==right.\\n\\n# Approach\\n- The problem is similar to normal parenthesis matching just that we have extra paramater as \"*\" which can either be a left parenthesis or a right parenthesis or empty string.\\n- So we will traverse the string 2 times, one from left hand side to check that any point we do not have rightParenthesis > leftParenthesis.\\nThen we will traverse from right to left, to check that at any point we do not have leftParenthesis > rightParenthesis.\\n- So we have extra \"*\", which can be anything, so while traversing left to right we can add a check that if rightParenthesis > leftParenthesis + star, that means return false.\\nIf it did not return false until the end of traversal we just need to check if  left+star>=right as star can have empty value as well.\\n- Similarly while traversing right to left we can add a check that if leftParenthesis > rightParenthesis + star, that means return false.\\nIf it did not return false until the end of traversal we just need to check if  right+star>=left as star can have empty value as well.\\n\\n\\n\\n# Complexity\\n- **Time complexity**:\\nWe are traversing the loop twice so O(2n)-->O(n)\\n\\n- **Space complexity**:\\nWe are not utilising any extra space. SC O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int l=0,r=0;\\n        int star=0;\\n        for(auto it:s)\\n        {\\n            if(it==\\'(\\')l++;\\n            else if(it==\\')\\')r++;\\n            else star++;\\n            if(r>l+star)return false;\\n        }\\n        bool f1= (l+star>=r);\\n        l=0;\\n        r=0;\\n        star=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'(\\')l++;\\n            else if(s[i]==\\')\\')r++;\\n            else star++;\\n\\n            if(l>r+star)return false;\\n        }\\n        bool f2=(r+star>=l);\\n        return (f1 and f2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int l=0,r=0;\\n        int star=0;\\n        for(auto it:s)\\n        {\\n            if(it==\\'(\\')l++;\\n            else if(it==\\')\\')r++;\\n            else star++;\\n            if(r>l+star)return false;\\n        }\\n        bool f1= (l+star>=r);\\n        l=0;\\n        r=0;\\n        star=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'(\\')l++;\\n            else if(s[i]==\\')\\')r++;\\n            else star++;\\n\\n            if(l>r+star)return false;\\n        }\\n        bool f2=(r+star>=l);\\n        return (f1 and f2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330927,
                "title": "java-stack-o-n",
                "content": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        \\n        Stack<Integer> brackets, stars;\\n        brackets = new Stack<>();\\n        stars = new Stack<>();\\n        \\n        for(int i=0; i<s.length(); i++){\\n            \\n            char bracket = s.charAt(i);\\n            \\n            if(bracket == \\'(\\'){\\n                brackets.push(i);\\n            }\\n            else if(bracket == \\'*\\'){\\n                stars.push(i);\\n            }\\n            else if(!brackets.isEmpty()){\\n                brackets.pop();\\n            }\\n            else if(!stars.isEmpty()){\\n                stars.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n            \\n        }\\n        \\n        while(!brackets.isEmpty() && !stars.isEmpty() && brackets.peek() < stars.peek()){\\n            brackets.pop();\\n            stars.pop();\\n        }\\n        \\n        return brackets.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        \\n        Stack<Integer> brackets, stars;\\n        brackets = new Stack<>();\\n        stars = new Stack<>();\\n        \\n        for(int i=0; i<s.length(); i++){\\n            \\n            char bracket = s.charAt(i);\\n            \\n            if(bracket == \\'(\\'){\\n                brackets.push(i);\\n            }\\n            else if(bracket == \\'*\\'){\\n                stars.push(i);\\n            }\\n            else if(!brackets.isEmpty()){\\n                brackets.pop();\\n            }\\n            else if(!stars.isEmpty()){\\n                stars.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n            \\n        }\\n        \\n        while(!brackets.isEmpty() && !stars.isEmpty() && brackets.peek() < stars.peek()){\\n            brackets.pop();\\n            stars.pop();\\n        }\\n        \\n        return brackets.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821486,
                "title": "c-better-than-100-submissions-stacks-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack<char> st;        // insert indices of \\'(\\'\\n        stack<char> sr;         // insert indices of \\'*\\'\\n        \\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            else if(s[i] == \\'*\\')\\n                sr.push(i);\\n            else            // when \\')\\' appears        \\n            {\\n                if(!st.empty())\\n                    st.pop();\\n                else if(!sr.empty())     // case = \"*(()*))\"\\n                    sr.pop();\\n                else                        // case =  \")*()\"  \\n                    return false;\\n            }\\n        }\\n        \\n        // this part executes only if st is not empty i.e. \"(\" are not balanced till now.\\n        while(!st.empty())    // to balance the \"(\" \\n        {\\n            if(sr.empty())   // if no \"*\" are present then we can\\'t balace the \"(\"\\n                return false;\\n            else if(st.top() < sr.top())    // to balance \"(\" we neeed \"*\" to the right side of \"(\"\\n            {\\n                st.pop();                 // case = \"(*(**)\"\\n                sr.pop();\\n            }\\n            else         // case = \"***(()\"\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack<char> st;        // insert indices of \\'(\\'\\n        stack<char> sr;         // insert indices of \\'*\\'\\n        \\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            else if(s[i] == \\'*\\')\\n                sr.push(i);\\n            else            // when \\')\\' appears        \\n            {\\n                if(!st.empty())\\n                    st.pop();\\n                else if(!sr.empty())     // case = \"*(()*))\"\\n                    sr.pop();\\n                else                        // case =  \")*()\"  \\n                    return false;\\n            }\\n        }\\n        \\n        // this part executes only if st is not empty i.e. \"(\" are not balanced till now.\\n        while(!st.empty())    // to balance the \"(\" \\n        {\\n            if(sr.empty())   // if no \"*\" are present then we can\\'t balace the \"(\"\\n                return false;\\n            else if(st.top() < sr.top())    // to balance \"(\" we neeed \"*\" to the right side of \"(\"\\n            {\\n                st.pop();                 // case = \"(*(**)\"\\n                sr.pop();\\n            }\\n            else         // case = \"***(()\"\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582697,
                "title": "intuitive-approach-using-two-stacks-java-beats-100-o-n-time-and-space",
                "content": "My algorithm works based on 4 simple rules \\n1. If the character is \\'(\\', then push the index to paraStack.\\n2. If the character is \\'\\\\*\\' , then push the index to starStack.\\n3. if the character is \\')\\' \\n\\t3.1 If paraStack is not empty ,pop from paraStack\\n\\t3.2 else if starStack is not empty , pop from starStack\\n\\t3.3 else it means the string not valid , return false;\\n4. The final check isBalancedStack is to make sure that there are enough * charcters on the right of \\n\\'(\\' which are still in paraStack (those open paranthesis which are not matched by closing paranthesis).\\n\\nNote : Whenever i hear a question related to valid paranthesis , only stacks come to my mind :) ,  \\ni am sure that i am not alone .\\n\\n```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        \\n        Deque<Integer> paraStack = new LinkedList<>();\\n        Deque<Integer> starStack = new LinkedList<>();\\n        \\n        for(int i = 0 ; i< s.length(); i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\')\\n                paraStack.push(i);\\n            else if(ch == \\'*\\')\\n                starStack.push(i);\\n            else{\\n                if(!paraStack.isEmpty())\\n                    paraStack.pop();\\n                else if(!starStack.isEmpty())\\n                    starStack.pop();\\n                else\\n                    return false;\\n            }        \\n        }\\n        \\n        return isStacksBalanced(paraStack,starStack);\\n    }\\n    private boolean isStacksBalanced(Deque<Integer> paraStack, Deque<Integer> starStack){\\n        \\n        while(!paraStack.isEmpty()&& !starStack.isEmpty()){\\n            if(paraStack.pop() > starStack.pop())\\n                return false;\\n        }\\n        return paraStack.isEmpty();\\n        \\n    }\\n    \\n}\\n```\\nPlease do UpVote if you find the solution and explanation useful, happy coding :).",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        \\n        Deque<Integer> paraStack = new LinkedList<>();\\n        Deque<Integer> starStack = new LinkedList<>();\\n        \\n        for(int i = 0 ; i< s.length(); i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\')\\n                paraStack.push(i);\\n            else if(ch == \\'*\\')\\n                starStack.push(i);\\n            else{\\n                if(!paraStack.isEmpty())\\n                    paraStack.pop();\\n                else if(!starStack.isEmpty())\\n                    starStack.pop();\\n                else\\n                    return false;\\n            }        \\n        }\\n        \\n        return isStacksBalanced(paraStack,starStack);\\n    }\\n    private boolean isStacksBalanced(Deque<Integer> paraStack, Deque<Integer> starStack){\\n        \\n        while(!paraStack.isEmpty()&& !starStack.isEmpty()){\\n            if(paraStack.pop() > starStack.pop())\\n                return false;\\n        }\\n        return paraStack.isEmpty();\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583590,
                "title": "solution-using-stack-python-faster-than-90",
                "content": "\\n    def checkValidString(self, s):\\n        stack, star_stack=[],[]\\n        for index,char in enumerate(s):\\n            if char==\\'(\\':\\n                stack.append(index)\\n            elif char==\\'*\\':\\n                star_stack.append(index)\\n            elif char==\\')\\':\\n                if len(stack)>0:\\n                    stack.pop()\\n                elif len(star_stack)>0:\\n                    star_stack.pop()\\n                else:\\n                    return False\\n                \\n        while stack and star_stack:\\n            if stack[-1] < star_stack[-1]:\\n                stack.pop()\\n                star_stack.pop()\\n            else:\\n                break\\n        return len(stack)==0",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "\\n    def checkValidString(self, s):\\n        stack, star_stack=[],[]\\n        for index,char in enumerate(s):\\n            if char==\\'(\\':\\n                stack.append(index)\\n            elif char==\\'*\\':\\n                star_stack.append(index)\\n            elif char==\\')\\':\\n                if len(stack)>0:\\n                    stack.pop()\\n                elif len(star_stack)>0:\\n                    star_stack.pop()\\n                else:\\n                    return False\\n                \\n        while stack and star_stack:\\n            if stack[-1] < star_stack[-1]:\\n                stack.pop()\\n                star_stack.pop()\\n            else:\\n                break\\n        return len(stack)==0",
                "codeTag": "Python3"
            },
            {
                "id": 582711,
                "title": "c-o-n-time-o-1-space-simple-clean-solution",
                "content": "We can rephrase the problem by listing all the valid cases. There are 3 valid cases:\\n1- There are more open parenthesis but we have enough * so we can balance the parenthesis with \\')\\'\\n2- There are more close parenthesis but we have enough * so we can balance the parenthesis with \\'(\\'\\n3- There are as many \\'(\\' than \\')\\' so all parentheses are balanced, we can ignore the extra \\'*\\'\\nAlgorithm: You can parse the String twice, once from left to right by replacing all * by \\'(\\' and once from right to left by replacing all * by \\')\\'. For each of the 2 loops, if there\\'s an iteration where you end up with a negative count (SUM[\\'(\\'] - SUM[\\')\\'] < 0) then you know the parenthesis were not balanced. You can return false. After these 2 checks (2 loops), you know the string is balanced because you\\'ve satisfied all the 3 valid cases mentioned above. \\n\\n```c++\\nbool checkValidString( string s ) {\\n    int bal = 0;\\n    for( int i=0; i < s.length(); i++ ) {\\n        if( s[i] == \\'(\\' || s[i] == \\'*\\' ) bal++;\\n        else bal--;\\n        if( bal < 0 ) return false;\\n    }\\n    if( bal == 0 ) return true;\\n\\n    bal = 0;\\n    for( int i=s.length()-1; i >= 0; i-- ) {\\n        if( s[i] == \\')\\' || s[i] == \\'*\\' ) bal++;\\n        else bal--;\\n        if( bal < 0 ) return false; \\n     }\\n     return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```c++\\nbool checkValidString( string s ) {\\n    int bal = 0;\\n    for( int i=0; i < s.length(); i++ ) {\\n        if( s[i] == \\'(\\' || s[i] == \\'*\\' ) bal++;\\n        else bal--;\\n        if( bal < 0 ) return false;\\n    }\\n    if( bal == 0 ) return true;\\n\\n    bal = 0;\\n    for( int i=s.length()-1; i >= 0; i-- ) {\\n        if( s[i] == \\')\\' || s[i] == \\'*\\' ) bal++;\\n        else bal--;\\n        if( bal < 0 ) return false; \\n     }\\n     return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 156317,
                "title": "c-o-n-time-o-1-space-one-pass-beats-100-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int starsMatched = 0;\\n        int Lefts = 0;\\n        int starsLeft = 0;\\n        for (unsigned i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') {\\n                Lefts++;\\n            }\\n            else if (s[i] == \\')\\') {\\n                // If there is a left parenthesis available, match with this right parenth\\n                if (Lefts) {\\n                    Lefts--;\\n                }\\n                // If no more left parenth available, check if any open stars to match with\\n                else if (starsLeft){\\n                    starsLeft--;\\n                }\\n                // If no more stars to match with, match with any stars matched with earlier left parenth\\n                else if(starsMatched) {\\n                    starsMatched--;\\n                    starsLeft++;\\n                }\\n                else {\\n                    return false;\\n                }\\n            }\\n            else {\\n                // If no more lefts available, increase num of available stars\\n                if (!Lefts) {\\n                    starsLeft++;\\n                }\\n                // Otherwise match with left and keep track of this match\\n                else {\\n                    starsMatched++;\\n                    Lefts--;\\n                }\\n            }\\n        }\\n        return !Lefts;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int starsMatched = 0;\\n        int Lefts = 0;\\n        int starsLeft = 0;\\n        for (unsigned i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') {\\n                Lefts++;\\n            }\\n            else if (s[i] == \\')\\') {\\n                // If there is a left parenthesis available, match with this right parenth\\n                if (Lefts) {\\n                    Lefts--;\\n                }\\n                // If no more left parenth available, check if any open stars to match with\\n                else if (starsLeft){\\n                    starsLeft--;\\n                }\\n                // If no more stars to match with, match with any stars matched with earlier left parenth\\n                else if(starsMatched) {\\n                    starsMatched--;\\n                    starsLeft++;\\n                }\\n                else {\\n                    return false;\\n                }\\n            }\\n            else {\\n                // If no more lefts available, increase num of available stars\\n                if (!Lefts) {\\n                    starsLeft++;\\n                }\\n                // Otherwise match with left and keep track of this match\\n                else {\\n                    starsMatched++;\\n                    Lefts--;\\n                }\\n            }\\n        }\\n        return !Lefts;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054730,
                "title": "c-fastest-stack",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack<int> open;\\n        stack<int> star;\\n\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i]==\\'(\\'){\\n                open.push(i);\\n            }\\n            else if(s[i]==\\'*\\'){\\n                star.push(i);;\\n            }\\n            else {\\n                if(s[i]==\\')\\'){\\n                    if(!open.empty()){\\n                        open.pop();\\n                    }\\n                    else if(!star.empty()){\\n                        star.pop();\\n                    }\\n                    else return false;\\n                }\\n            }\\n\\n        }\\n        while(!open.empty() && !star.empty() && open.top() < star.top()){\\n            open.pop();\\n            star.pop();\\n        }\\n\\n        return open.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack<int> open;\\n        stack<int> star;\\n\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i]==\\'(\\'){\\n                open.push(i);\\n            }\\n            else if(s[i]==\\'*\\'){\\n                star.push(i);;\\n            }\\n            else {\\n                if(s[i]==\\')\\'){\\n                    if(!open.empty()){\\n                        open.pop();\\n                    }\\n                    else if(!star.empty()){\\n                        star.pop();\\n                    }\\n                    else return false;\\n                }\\n            }\\n\\n        }\\n        while(!open.empty() && !star.empty() && open.top() < star.top()){\\n            open.pop();\\n            star.pop();\\n        }\\n\\n        return open.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416848,
                "title": "java-two-stacks-1ms",
                "content": "stack1: save \"(\" index\\nstack2: save \\'\\\\*\\' index\\n\\nWhen meet \")\", first try pop from stack1, otherwise pop from stack2.\\nAt last, if stack1 not empty, compare the element value, try use stack2 elements to pop stack1 elements.\\n\\n```\\nclass Solution {\\n    private Stack<Integer> stack1 = new Stack<Integer>();\\n    private Stack<Integer> stack2 = new Stack<Integer>();\\n\\n    public boolean checkValidString(String s) {\\n        char[] chars = s.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            char c = chars[i];\\n            if (c == \\'(\\') {\\n                stack1.push(i);\\n            } else if (c == \\')\\') {\\n                if (!stack1.isEmpty()) {\\n                    stack1.pop();\\n                } else if(!stack2.isEmpty()) {\\n                    stack2.pop();\\n                } else {\\n                    return false;\\n                }\\n            } else if (c == \\'*\\') {\\n                stack2.push(i);\\n            }\\n        }\\n\\n        while(!stack1.isEmpty() && !stack2.isEmpty()) {\\n            Integer value = stack2.pop();\\n            if (stack1.peek() < value) {\\n                stack1.pop();\\n            }\\n        }\\n\\n        return stack1.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private Stack<Integer> stack1 = new Stack<Integer>();\\n    private Stack<Integer> stack2 = new Stack<Integer>();\\n\\n    public boolean checkValidString(String s) {\\n        char[] chars = s.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            char c = chars[i];\\n            if (c == \\'(\\') {\\n                stack1.push(i);\\n            } else if (c == \\')\\') {\\n                if (!stack1.isEmpty()) {\\n                    stack1.pop();\\n                } else if(!stack2.isEmpty()) {\\n                    stack2.pop();\\n                } else {\\n                    return false;\\n                }\\n            } else if (c == \\'*\\') {\\n                stack2.push(i);\\n            }\\n        }\\n\\n        while(!stack1.isEmpty() && !stack2.isEmpty()) {\\n            Integer value = stack2.pop();\\n            if (stack1.peek() < value) {\\n                stack1.pop();\\n            }\\n        }\\n\\n        return stack1.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377095,
                "title": "c-easy-to-understand-using-2-stacks-beats-100-time",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack<int> ast, stk;\\n        for(int i = 0; i < s.size(); ++i) {\\n            if(s[i] == \\'(\\') {\\n                stk.push(i);\\n            }\\n            else if(s[i] == \\'*\\') ast.push(i);\\n            else {\\n                if(stk.empty() && ast.empty()) return false;\\n                if(!stk.empty()) stk.pop();\\n                else ast.pop();\\n            }\\n        }\\n        while(!stk.empty() && !ast.empty() && stk.top() < ast.top()) {\\n            stk.pop();\\n            ast.pop();\\n        }\\n        return stk.empty();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack<int> ast, stk;\\n        for(int i = 0; i < s.size(); ++i) {\\n            if(s[i] == \\'(\\') {\\n                stk.push(i);\\n            }\\n            else if(s[i] == \\'*\\') ast.push(i);\\n            else {\\n                if(stk.empty() && ast.empty()) return false;\\n                if(!stk.empty()) stk.pop();\\n                else ast.pop();\\n            }\\n        }\\n        while(!stk.empty() && !ast.empty() && stk.top() < ast.top()) {\\n            stk.pop();\\n            ast.pop();\\n        }\\n        return stk.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664391,
                "title": "easy-c-code-greedy-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int open = 0;\\n        int star = 0;\\n        int used = 0;\\n        for(char i:s)\\n        {\\n          if(i == \\'(\\')\\n          {\\n            open++;\\n          }\\n          else if(i == \\'*\\')\\n          {\\n            if(open > 0)\\n            {\\n              used++;\\n              open--;\\n            }\\n            else\\n            {\\n              star++;\\n            }\\n          }\\n          else\\n          {\\n            if(open > 0)\\n            {\\n              open--;\\n            }\\n            else if(star > 0)\\n            {\\n              star--;\\n            }\\n            else if(used>0)\\n            {\\n              used--;\\n              star++;\\n            }\\n            else\\n            {\\n              return false;\\n            }\\n          }\\n        }\\n\\n        if(open == 0)\\n        {\\n          return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int open = 0;\\n        int star = 0;\\n        int used = 0;\\n        for(char i:s)\\n        {\\n          if(i == \\'(\\')\\n          {\\n            open++;\\n          }\\n          else if(i == \\'*\\')\\n          {\\n            if(open > 0)\\n            {\\n              used++;\\n              open--;\\n            }\\n            else\\n            {\\n              star++;\\n            }\\n          }\\n          else\\n          {\\n            if(open > 0)\\n            {\\n              open--;\\n            }\\n            else if(star > 0)\\n            {\\n              star--;\\n            }\\n            else if(used>0)\\n            {\\n              used--;\\n              star++;\\n            }\\n            else\\n            {\\n              return false;\\n            }\\n          }\\n        }\\n\\n        if(open == 0)\\n        {\\n          return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650260,
                "title": "naive-to-efficient-2-approaches-simple-easy-c",
                "content": "Implementation\\n\\n**Using Stack\\nTime Complexity = O(N), Space Complexity = O(N)**\\n```\\nclass Solution {\\npublic:\\n\\tbool checkValidString(string str) {\\n\\t stack<char> star, open;\\n\\t\\n\\t for(int itr = 0; itr < str.size(); itr++){\\n\\t     if(str[itr] == \\'(\\') open.push(itr);\\n\\t     else if(str[itr] == \\'*\\') star.push(itr);\\n\\t     else{\\n\\t         if(!open.empty()) open.pop();\\n\\t         else if(!star.empty()) star.pop();\\n\\t         else return false;\\n\\t     }\\n\\t }\\n\\t\\n\\t while(!open.empty()){\\n\\t     if(star.empty()) return false;\\n\\t     else if(open.top() < star.top()){\\n\\t         open.pop();\\n\\t         star.pop();\\n\\t     }\\n\\t     else return false;\\n\\t }        \\n\\t\\n\\t return true;\\n\\t}\\n};\\n```\\n\\n**Efficient Solution\\nTime Complexity = O(N), Space Complexity = O(1)**\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string str) {\\n        int high = 0, low = 0;\\n        \\n        for(auto itr : str){\\n            if(itr == \\'(\\'){\\n                high++;\\n                low++;\\n            }\\n            else if(itr == \\')\\'){\\n                high--;\\n                if(low > 0) low--;\\n            }\\n            else{\\n                high++;\\n                if(low > 0) low--;\\n            }\\n            \\n            // it means Currently, don\\'t have enough open parentheses to match close parentheses->\\n            // For example: \"())(\" or \")*\"\\n            if(high < 0) return false\\n        }\\n        \\n        return (low == 0);\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool checkValidString(string str) {\\n\\t stack<char> star, open;\\n\\t\\n\\t for(int itr = 0; itr < str.size(); itr++){\\n\\t     if(str[itr] == \\'(\\') open.push(itr);\\n\\t     else if(str[itr] == \\'*\\') star.push(itr);\\n\\t     else{\\n\\t         if(!open.empty()) open.pop();\\n\\t         else if(!star.empty()) star.pop();\\n\\t         else return false;\\n\\t     }\\n\\t }\\n\\t\\n\\t while(!open.empty()){\\n\\t     if(star.empty()) return false;\\n\\t     else if(open.top() < star.top()){\\n\\t         open.pop();\\n\\t         star.pop();\\n\\t     }\\n\\t     else return false;\\n\\t }        \\n\\t\\n\\t return true;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string str) {\\n        int high = 0, low = 0;\\n        \\n        for(auto itr : str){\\n            if(itr == \\'(\\'){\\n                high++;\\n                low++;\\n            }\\n            else if(itr == \\')\\'){\\n                high--;\\n                if(low > 0) low--;\\n            }\\n            else{\\n                high++;\\n                if(low > 0) low--;\\n            }\\n            \\n            // it means Currently, don\\'t have enough open parentheses to match close parentheses->\\n            // For example: \"())(\" or \")*\"\\n            if(high < 0) return false\\n        }\\n        \\n        return (low == 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884414,
                "title": "java-o-n-very-easy-with-explanation",
                "content": "The given leetcode solutions are all way more complicated than they need to be.  For a moment lets exclude the star and just look at the valid parenthesis problem.  You simply use a stack and iterating through the string and push to the stack on open parenthesis and pop the stack when you come across closed.  Invalid occurrs either when the stack is empty but you have remaining closed parenthesis or you\\'ve iterated through the entire string and the stack is not empty (open parenthesis remain). Now introducing stars doesn\\'t actually change this problem a whole lot, we just need to slightly tweek our invalid cases.  If we have a closed parenthesis and the stack is empty, we can check if we have a star.  If not, it is invalid, if we do we are good.  Now for the second invalid case where we have remaining parenthesis, as long as each index in the parenthesis stack is countered by a higher index in the star stack, the string is valid, else the string is invalid. Otherwise the string is valid.\\n\\n```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        Stack<Integer> star = new Stack<>();\\n        char[] charArray = s.toCharArray();\\n        \\n        for (int i = 0; i < charArray.length; i++) {\\n            if (charArray[i] == \\'(\\') stack.push(i);\\n            else if (charArray[i] == \\')\\') {\\n                if (stack.isEmpty()) {\\n                    if (star.isEmpty()) return false;\\n                    else star.pop();\\n                } else {\\n                    stack.pop();\\n                }\\n            } else star.push(i);\\n        }\\n        \\n        while (!stack.isEmpty()) {\\n            int index = stack.pop();\\n            \\n            if (star.isEmpty() || star.peek() < index) return false;\\n            else star.pop();\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        Stack<Integer> star = new Stack<>();\\n        char[] charArray = s.toCharArray();\\n        \\n        for (int i = 0; i < charArray.length; i++) {\\n            if (charArray[i] == \\'(\\') stack.push(i);\\n            else if (charArray[i] == \\')\\') {\\n                if (stack.isEmpty()) {\\n                    if (star.isEmpty()) return false;\\n                    else star.pop();\\n                } else {\\n                    stack.pop();\\n                }\\n            } else star.push(i);\\n        }\\n        \\n        while (!stack.isEmpty()) {\\n            int index = stack.pop();\\n            \\n            if (star.isEmpty() || star.peek() < index) return false;\\n            else star.pop();\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582102,
                "title": "c-greedy-solution-100-time-and-space-2-stacks-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n      if(s.size()==0) return true;\\n        \\n      stack<int> s1;\\n      stack<int> s2;\\n      \\n      for(int i=0;i<s.size();i++)\\n      {\\n          if(s[i]==\\'(\\') s1.push(i);\\n          else if(s[i]==\\'*\\') s2.push(i);\\n          else\\n          {\\n              if(s1.size()>0)\\n              {\\n                  s1.pop();\\n              }\\n              else if(s2.size()>0)\\n              {\\n                  s2.pop();\\n              }\\n              else return false;\\n          }\\n      }\\n        while(!s1.empty() && !s2.empty())\\n        {\\n            if(s1.top()>s2.top()) return false;\\n            s1.pop();\\n            s2.pop();\\n        }\\n        if(s1.size()>0) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n      if(s.size()==0) return true;\\n        \\n      stack<int> s1;\\n      stack<int> s2;\\n      \\n      for(int i=0;i<s.size();i++)\\n      {\\n          if(s[i]==\\'(\\') s1.push(i);\\n          else if(s[i]==\\'*\\') s2.push(i);\\n          else\\n          {\\n              if(s1.size()>0)\\n              {\\n                  s1.pop();\\n              }\\n              else if(s2.size()>0)\\n              {\\n                  s2.pop();\\n              }\\n              else return false;\\n          }\\n      }\\n        while(!s1.empty() && !s2.empty())\\n        {\\n            if(s1.top()>s2.top()) return false;\\n            s1.pop();\\n            s2.pop();\\n        }\\n        if(s1.size()>0) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107615,
                "title": "python-greedy-with-explanation",
                "content": "Let `lo, hi` respectively be the smallest and largest possible number of open left brackets after processing the current character `c` in the string.  Every integer in this interval is possible to attain.  \\n\\nIf we see a `'('`, we know that we must have one extra left bracket, otherwise we could have one less.  If we don't see a `')'`, we know we could have one extra left bracket, otherwise we must have one less.\\n\\nIf at any point the maximum number of open left brackets is negative, then it is impossible to make a valid string.  At the end, we want to know if it was possible to have exactly 0 open left brackets.\\n\\n```python\\ndef checkValidString(self, s):\\n    lo = hi = 0\\n    for c in s:\\n        lo += 1 if c == '(' else -1\\n        hi += 1 if c != ')' else -1\\n        if hi < 0: break\\n        lo = max(lo, 0)\\n\\n    return lo == 0\\n```",
                "solutionTags": [],
                "code": "```python\\ndef checkValidString(self, s):\\n    lo = hi = 0\\n    for c in s:\\n        lo += 1 if c == '(' else -1\\n        hi += 1 if c != ')' else -1\\n        if hi < 0: break\\n        lo = max(lo, 0)\\n\\n    return lo == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3788230,
                "title": "super-easy-solution",
                "content": "# Intuition:\\nThe approach to solving this problem involves using two stacks, one to keep track of the indices of open parentheses (\\'(\\') and another to keep track of the indices of asterisks (\\'*\\'). We iterate through the string character by character, and for each character, we perform the following actions:\\n\\nIf we encounter an open parenthesis \\'(\\', we push its index onto the open stack.\\nIf we encounter an asterisk \\'*\\', we push its index onto the star stack.\\nIf we encounter a closing parenthesis \\')\\', we try to match it with a corresponding open parenthesis \\'(\\'. We prioritize using an open parenthesis from the open stack if available, as it maintains the correct order. If the open stack is empty, we use an asterisk from the star stack, treating it as an open parenthesis. If both the open and star stacks are empty, we return false since we cannot find a corresponding open parenthesis for the closing parenthesis.\\nAfter processing the entire string, we need to ensure that all open parentheses are matched with either a closing parenthesis or an asterisk. To do this, we process any leftover open parentheses in the open stack. For each open parenthesis index in the open stack, we look for an asterisk index in the star stack that appears after the open parenthesis index. If we find such an asterisk, we consider it as a valid match and pop both the open parenthesis and the asterisk from their respective stacks. If we don\\'t find a valid asterisk, the string is invalid.\\n\\nIf we successfully process all characters and leftover open parentheses, the string is valid, and we return true.\\n\\n# Algorithm:\\n\\nInitialize two stacks, open and star, to keep track of the indices of open parentheses and asterisks, respectively.\\nIterate through the string s character by character:\\na. If the character is \\'(\\', push its index onto the open stack.\\nb. If the character is \\'*\\', push its index onto the star stack.\\nc. If the character is \\')\\':\\nIf the open stack is not empty, pop an index from the open stack, indicating that we found a matching open parenthesis for the closing parenthesis.\\nIf the open stack is empty, but the star stack is not empty, pop an index from the star stack, treating the asterisk as a valid match for the closing parenthesis.\\nIf both the open and star stacks are empty, return false as we cannot find a matching open parenthesis.\\nAfter processing the entire string, process any leftover open parentheses in the open stack:\\na. For each index in the open stack, look for an asterisk index in the star stack that appears after the open parenthesis index.\\nb. If we find such an asterisk, pop both the open parenthesis index and the asterisk index from their respective stacks, indicating a valid match.\\nc. If we don\\'t find a valid asterisk, return false.\\nIf we successfully process all characters and leftover open parentheses, return true.\\nComplexity Analysis:\\n\\n# Time Complexity:\\n The algorithm iterates through the string once and performs stack operations, which take O(n) time, where n is the length of the input string.\\n# Space Complexity:\\n The algorithm uses two stacks, open and star, which can have at most O(n) elements combined. Hence, the space complexity is O(n).\\nOverall, the algorithm has a linear time complexity of O(n) and a linear space complexity of O(n).\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n       stack<int> open,star;\\n        int len = s.length();\\n        \\n        for(int i=0;s[i]!=\\'\\\\0\\';++i)\\n        {\\n            if(s[i]==\\'(\\')\\n                open.push(i);\\n            else if(s[i]==\\'*\\')\\n                star.push(i);\\n            else\\n            {\\n                if(!open.empty())\\n                    open.pop();\\n                else if(!star.empty())\\n                    star.pop();\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        //Now process leftover opening brackets\\n        while(!open.empty())\\n        {\\n            if(star.empty())\\n                return false;\\n            else if(open.top() < star.top())\\n            {\\n                open.pop();\\n                star.pop();\\n            }\\n            else    //CASE: open.top() > star.top()\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n       stack<int> open,star;\\n        int len = s.length();\\n        \\n        for(int i=0;s[i]!=\\'\\\\0\\';++i)\\n        {\\n            if(s[i]==\\'(\\')\\n                open.push(i);\\n            else if(s[i]==\\'*\\')\\n                star.push(i);\\n            else\\n            {\\n                if(!open.empty())\\n                    open.pop();\\n                else if(!star.empty())\\n                    star.pop();\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        //Now process leftover opening brackets\\n        while(!open.empty())\\n        {\\n            if(star.empty())\\n                return false;\\n            else if(open.top() < star.top())\\n            {\\n                open.pop();\\n                star.pop();\\n            }\\n            else    //CASE: open.top() > star.top()\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318835,
                "title": "678-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nInitialize two empty stacks, left_paren_stack and asterisk_stack, to keep track of indices of left parentheses and asterisks, respectively.\\n\\nIterate through each character s[i] in the string:\\n\\nIf s[i] is \\'(\\', append the index i to the left_paren_stack.\\nIf s[i] is \\'*\\', append the index i to the asterisk_stack.\\nIf s[i] is \\')\\', check if there is a left parenthesis in the left_paren_stack. If there is, pop it. Otherwise, check if there is an asterisk in the asterisk_stack. If there is, pop it. If there is neither a left parenthesis nor an asterisk to match the right parenthesis, return False.\\nIterate through the remaining elements in the left_paren_stack and asterisk_stack:\\n\\nIf the index of the left parenthesis is greater than the index of the asterisk, return False.\\nPop the top elements from both stacks.\\nIf there are no more left parentheses to match the asterisks, return True. Otherwise, return False.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        # Initialize two stacks to keep track of indices of left parentheses and asterisks\\n        left_paren_stack, asterisk_stack = [], []\\n        \\n        # Iterate through each character in the string\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                # Add the index of the left parenthesis to the left_paren_stack\\n                left_paren_stack.append(i)\\n            elif s[i] == \\'*\\':\\n                # Add the index of the asterisk to the asterisk_stack\\n                asterisk_stack.append(i)\\n            else: # s[i] == \\')\\'\\n                # If there is a left parenthesis in the left_paren_stack, pop it\\n                if left_paren_stack:\\n                    left_paren_stack.pop()\\n                # Otherwise, if there is an asterisk in the asterisk_stack, pop it\\n                elif asterisk_stack:\\n                    asterisk_stack.pop()\\n                # If there is neither a left parenthesis nor an asterisk to match the right parenthesis, the string is invalid\\n                else:\\n                    return False\\n        \\n        # Iterate through the remaining elements in the left_paren_stack and asterisk_stack\\n        while left_paren_stack and asterisk_stack:\\n            # If the index of the left parenthesis is greater than the index of the asterisk, the string is invalid\\n            if left_paren_stack[-1] > asterisk_stack[-1]:\\n                return False\\n            left_paren_stack.pop()\\n            asterisk_stack.pop()\\n            \\n        # If there are no more left parentheses to match the asterisks, the string is valid\\n        return not left_paren_stack\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        # Initialize two stacks to keep track of indices of left parentheses and asterisks\\n        left_paren_stack, asterisk_stack = [], []\\n        \\n        # Iterate through each character in the string\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                # Add the index of the left parenthesis to the left_paren_stack\\n                left_paren_stack.append(i)\\n            elif s[i] == \\'*\\':\\n                # Add the index of the asterisk to the asterisk_stack\\n                asterisk_stack.append(i)\\n            else: # s[i] == \\')\\'\\n                # If there is a left parenthesis in the left_paren_stack, pop it\\n                if left_paren_stack:\\n                    left_paren_stack.pop()\\n                # Otherwise, if there is an asterisk in the asterisk_stack, pop it\\n                elif asterisk_stack:\\n                    asterisk_stack.pop()\\n                # If there is neither a left parenthesis nor an asterisk to match the right parenthesis, the string is invalid\\n                else:\\n                    return False\\n        \\n        # Iterate through the remaining elements in the left_paren_stack and asterisk_stack\\n        while left_paren_stack and asterisk_stack:\\n            # If the index of the left parenthesis is greater than the index of the asterisk, the string is invalid\\n            if left_paren_stack[-1] > asterisk_stack[-1]:\\n                return False\\n            left_paren_stack.pop()\\n            asterisk_stack.pop()\\n            \\n        # If there are no more left parentheses to match the asterisks, the string is valid\\n        return not left_paren_stack\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710555,
                "title": "c-o-n-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) \\n    {\\n        for(int i=0,bal=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'*\\' || s[i]==\\'(\\') bal += 1;\\n            else bal -= 1;\\n            if(bal < 0) return false;\\n        }\\n        \\n        for(int i=s.length()-1,bal=0;i>=0;i--)\\n        {\\n            if(s[i]==\\'*\\' || s[i]==\\')\\') bal += 1;\\n            else bal -= 1;\\n            if(bal < 0) return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkValidString(string s) \\n    {\\n        for(int i=0,bal=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'*\\' || s[i]==\\'(\\') bal += 1;\\n            else bal -= 1;\\n            if(bal < 0) return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1364546,
                "title": "python-o-n-o-n-beats-98",
                "content": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        \\n        stack = []\\n        starStack = []\\n        \\n        for pos, char in enumerate(s):\\n            \\n            if char == \"(\":\\n                stack.append(pos)\\n                \\n            elif char == \"*\":\\n                starStack.append(pos)\\n                \\n            else:\\n                if stack:\\n                    stack.pop(-1)\\n                elif starStack :\\n                    starStack.pop(-1)\\n                else:\\n                    return False\\n        \\n\\n        while stack and starStack:\\n            openPos = stack.pop(-1)\\n            starPos = starStack.pop(-1)\\n            \\n            if openPos > starPos:\\n                return False\\n        \\n        \\n        return len(stack) == 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        \\n        stack = []\\n        starStack = []\\n        \\n        for pos, char in enumerate(s):\\n            \\n            if char == \"(\":\\n                stack.append(pos)\\n                \\n            elif char == \"*\":\\n                starStack.append(pos)\\n                \\n            else:\\n                if stack:\\n                    stack.pop(-1)\\n                elif starStack :\\n                    starStack.pop(-1)\\n                else:\\n                    return False\\n        \\n\\n        while stack and starStack:\\n            openPos = stack.pop(-1)\\n            starPos = starStack.pop(-1)\\n            \\n            if openPos > starPos:\\n                return False\\n        \\n        \\n        return len(stack) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825937,
                "title": "java-double-stack-0ms-beats-100-runtime",
                "content": "Hope the comment I left is enough ^_^\\n\\n```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        Stack<Integer> open = new Stack<>();\\n        Stack<Integer> star = new Stack<>();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'(\\') {open.push(i);}\\n            else if(s.charAt(i) == \\'*\\') {star.push(i);}\\n            else {\\n                if(!open.isEmpty()) {open.pop();} // found matched \\'(\\'with\\')\\'\\n                else if (!star.isEmpty()) {star.pop();} // match \\'*\\' with \\')\\'\\n                else return false; // cannot find match\\n            }\\n        }\\n\\n        // checking leftover on 2 stack\\n        while(!open.isEmpty()) { // we can have \\'*\\' leftover, but \\'open\\' must run out \\n            if(star.isEmpty()) {return false;} // \\'(\\' leftover\\n            else if (open.peek()<star.peek()){open.pop(); star.pop();} // \\'*\\'index > \\'(\\' index, matched\\n            else {return false;} // open>top, corner case\\n        }\\n        return true;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        Stack<Integer> open = new Stack<>();\\n        Stack<Integer> star = new Stack<>();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'(\\') {open.push(i);}\\n            else if(s.charAt(i) == \\'*\\') {star.push(i);}\\n            else {\\n                if(!open.isEmpty()) {open.pop();} // found matched \\'(\\'with\\')\\'\\n                else if (!star.isEmpty()) {star.pop();} // match \\'*\\' with \\')\\'\\n                else return false; // cannot find match\\n            }\\n        }\\n\\n        // checking leftover on 2 stack\\n        while(!open.isEmpty()) { // we can have \\'*\\' leftover, but \\'open\\' must run out \\n            if(star.isEmpty()) {return false;} // \\'(\\' leftover\\n            else if (open.peek()<star.peek()){open.pop(); star.pop();} // \\'*\\'index > \\'(\\' index, matched\\n            else {return false;} // open>top, corner case\\n        }\\n        return true;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597627,
                "title": "best-c-solution-using-bit-manipulation-time-o-n-space-o-1",
                "content": "When checking whether the string is valid, we care about the current balance of parenthesis. The key is to record how many \"extra \"left brackets we have currently when iterating the string(If we have more right brackets than left brackets, the string is invalid).\\n\\nThe idea of my solution is simple. We use a single integer to record how many extra left brackets we have. Every bit in the integer represents the corresponding number of extra left brackets.  For example, if we have a string \"(((\", the integer is 8(1000 in binary), indicating we currently have three extra left brackets. If we have a string \"(()\", the integer is 4(100 in binary), indicating we have two extra left brackets.\\n\\nThe integer is set to be 1 at the beginning, indicating we are at balance now. Every time we meet a \\'(\\' , the integer is left shifted one bit. When we meet \\')\\', the integer is right shifted one bit. For example, if we have a string \"()\", our integer will change in this way:   1 -> 2 -> 1. Finally, we have a 1, which means we are in balance again.\\n\\nThe tricky part is that the star can be treated as left bracket, right bracket or empty string. Bascially every star  in the string produces three possible counts of extra left brackets. How can we deal with the star?\\n\\nRemember we use every bit represents how many extra left brackets we have. If we have a 4(100), it means we have two extra left brackets. The star can either add one extra left bracket, remove one extra left bracket or do nothing. Therefore, we can simply change 4(100) to 14(1110), meaning that we either have three, two or one extra left brackets.\\n\\nAt the end, we just check if the integer can deliver a \"balanced\" result, which is that whether the integer has a 1 in its lowest bit.\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        long long n=1;\\n        for(auto c:s){\\n            if(n<=0)\\n                return false;\\n            if(c==\\'(\\')\\n                n = n<<1;\\n            else if(c==\\')\\')\\n                n = n>>1;\\n            else\\n                n =  (n>>1) | n | (n<<1) ;\\n        }\\n        return n&1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        long long n=1;\\n        for(auto c:s){\\n            if(n<=0)\\n                return false;\\n            if(c==\\'(\\')\\n                n = n<<1;\\n            else if(c==\\')\\')\\n                n = n>>1;\\n            else\\n                n =  (n>>1) | n | (n<<1) ;\\n        }\\n        return n&1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903871,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\u0913\\u092A\\u0928 \\u0914\\u0930 \\u0938\\u094D\\u091F\\u093E\\u0930 \\u0928\\u093E\\u092E\\u0915 \\u0926\\u094B \\u0938\\u094D\\u091F\\u0948\\u0915 \\u0932\\u0947\\u0902, \\u090F\\u0915 \\u0913\\u092A\\u0928 \\u092C\\u094D\\u0930\\u0948\\u0915\\u0947\\u091F \\u0915\\u0947 \\u0932\\u093F\\u090F \\u0914\\u0930 \\u090F\\u0915 \\u0938\\u094D\\u091F\\u093E\\u0930 (\\u0924\\u093E\\u0930\\u093E\\u0902\\u0915\\u0928) \\u0915\\u0947 \\u0932\\u093F\\u090F\\u0964\\n\\u092F\\u0926\\u093F \\u0915\\u094B\\u0908 \\u0938\\u092E\\u093E\\u092A\\u0928 \\u092C\\u094D\\u0930\\u0948\\u0915\\u0947\\u091F \\u0926\\u093F\\u0916\\u093E\\u0908 \\u0926\\u0947\\u0924\\u093E \\u0939\\u0948, \\u0924\\u094B \\u0916\\u0941\\u0932\\u0947 \\u0938\\u0947 \\u092A\\u0949\\u092A \\u0915\\u0930\\u0947\\u0902 (\\u092F\\u0926\\u093F \\u0916\\u0941\\u0932\\u093E \\u0916\\u093E\\u0932\\u0940 \\u0928\\u0939\\u0940\\u0902 \\u0939\\u0948)\\u0964 \\u092F\\u0926\\u093F \\u0916\\u0941\\u0932\\u093E \\u0939\\u0948 \\u0924\\u094B \\u0938\\u094D\\u091F\\u093E\\u0930 \\u0938\\u0947 \\u0916\\u093E\\u0932\\u0940 \\u092A\\u0949\\u092A \\u0939\\u0948\\u0964\\n\\u0907\\u0938\\u0940 \\u092A\\u094D\\u0930\\u0915\\u093E\\u0930 \\u0936\\u0947\\u0937 \\u0916\\u0941\\u0932\\u0947 \\u0915\\u094B\\u0937\\u094D\\u0920\\u0915\\u094B\\u0902 \\u0915\\u0940 \\u092D\\u0940 \\u091C\\u093E\\u0901\\u091A \\u0915\\u0930\\u0947\\u0902\\u0964 \\u092F\\u0926\\u093F \\u0915\\u094D\\u0932\\u094B\\u091C\\u093F\\u0902\\u0917 \\u092C\\u094D\\u0930\\u0948\\u0915\\u0947\\u091F \\u092F\\u093E \\u0938\\u094D\\u091F\\u093E\\u0930 \\u0916\\u0941\\u0932\\u0947 \\u092C\\u094D\\u0930\\u0948\\u0915\\u0947\\u091F \\u0907\\u0902\\u0921\\u0947\\u0915\\u094D\\u0938 \\u0938\\u0947 \\u0905\\u0927\\u093F\\u0915 \\u0907\\u0902\\u0921\\u0947\\u0915\\u094D\\u0938 \\u092A\\u0930 \\u092E\\u094C\\u091C\\u0942\\u0926 \\u0939\\u0948, \\u0924\\u094B \\u092A\\u0949\\u092A \\u0915\\u0930\\u0947\\u0902\\u0964\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack<int> open,star;\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'(\\') open.push(i);\\n            else if(s[i]==\\'*\\')star.push(i);\\n            else{\\n                if(!open.empty())\\n                {\\n                    open.pop();\\n                }else if(!star.empty()) star.pop();\\n                else return false;\\n            }\\n        }\\n        while(!open.empty())\\n        {\\n            if(!star.empty())\\n            {\\n                if(star.top()>open.top()){\\n                    star.pop(); open.pop();\\n                }else return false;\\n            }else return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack<int> open,star;\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'(\\') open.push(i);\\n            else if(s[i]==\\'*\\')star.push(i);\\n            else{\\n                if(!open.empty())\\n                {\\n                    open.pop();\\n                }else if(!star.empty()) star.pop();\\n                else return false;\\n            }\\n        }\\n        while(!open.empty())\\n        {\\n            if(!star.empty())\\n            {\\n                if(star.top()>open.top()){\\n                    star.pop(); open.pop();\\n                }else return false;\\n            }else return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516224,
                "title": "100-faster-most-intuitive-easiest-approach-with-detailed-explanation-in-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack <int> brac, star;          // store opening bracket and star indices in spearate stacks\\n        int n = s.size();\\n        \\n        for (int i = 0; i < n; i++){\\n            if (s[i] == \\'(\\')            // push index in bracket stack if opening bracket occurs\\n                brac.push(i);\\n\\t\\t\\t\\t\\n            else if (s[i] == \\'*\\')      // push index in star stack if asterisk occurs\\n                star.push(i);\\n\\t\\t\\t\\t\\n            else {       // if closing bracket occurs\\n                if (!brac.empty())                  // validate it via an opening bracket \\n                    brac.pop();                    // remove opening bracket\\'s index as it has formed a pair with a closing bracket\\n\\t\\t\\t\\t\\t\\n                else if (!star.empty())          // if opening brackets are not present, validate it via an asterisk [Convert asterisk to opening bracket]\\n                    star.pop();                 // remove opening bracket\\'s index as it has formed a pair with a closing bracket\\n\\t\\t\\t\\t\\t\\n                else \\n                    return false;             // if neither an opening bracket nor an asterisk is present before a closing bracket, string is invalid\\n            }\\n        }\\n\\t\\t\\n        // now all that\\'s left is opening brackets and/or asterisks\\n\\t\\t// if no opening brackets are left ie brac stack is empty, then all asterisks can be replaced via \"\" and hence our code will return true\\n\\t\\t\\n        while (!brac.empty()){                                     // but, if opening brackets are still left, asterisk has to be converted to closing bracket to validate each of them\\n            if (star.empty() || brac.top() > star.top())          // if no asterisks or the asterisk occurs BEFORE the opening bracket[Opening bracket desperately needs a closing brackets AFTER it], we can\\'t validate our string\\n                return false;\\n            else{ // remove from both as the pair has been validated\\n                brac.pop();\\n                star.pop();\\n            }\\n        }\\n        return true;        // aah, lovely! our brac stack is now empty which means we have validated the whole string pair by pair and it doesn\\'t matter if our star stack is empty or not since all asterisks can now be considered as \"\"\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack <int> brac, star;          // store opening bracket and star indices in spearate stacks\\n        int n = s.size();\\n        \\n        for (int i = 0; i < n; i++){\\n            if (s[i] == \\'(\\')            // push index in bracket stack if opening bracket occurs\\n                brac.push(i);\\n\\t\\t\\t\\t\\n            else if (s[i] == \\'*\\')      // push index in star stack if asterisk occurs\\n                star.push(i);\\n\\t\\t\\t\\t\\n            else {       // if closing bracket occurs\\n                if (!brac.empty())                  // validate it via an opening bracket \\n                    brac.pop();                    // remove opening bracket\\'s index as it has formed a pair with a closing bracket\\n\\t\\t\\t\\t\\t\\n                else if (!star.empty())          // if opening brackets are not present, validate it via an asterisk [Convert asterisk to opening bracket]\\n                    star.pop();                 // remove opening bracket\\'s index as it has formed a pair with a closing bracket\\n\\t\\t\\t\\t\\t\\n                else \\n                    return false;             // if neither an opening bracket nor an asterisk is present before a closing bracket, string is invalid\\n            }\\n        }\\n\\t\\t\\n        // now all that\\'s left is opening brackets and/or asterisks\\n\\t\\t// if no opening brackets are left ie brac stack is empty, then all asterisks can be replaced via \"\" and hence our code will return true\\n\\t\\t\\n        while (!brac.empty()){                                     // but, if opening brackets are still left, asterisk has to be converted to closing bracket to validate each of them\\n            if (star.empty() || brac.top() > star.top())          // if no asterisks or the asterisk occurs BEFORE the opening bracket[Opening bracket desperately needs a closing brackets AFTER it], we can\\'t validate our string\\n                return false;\\n            else{ // remove from both as the pair has been validated\\n                brac.pop();\\n                star.pop();\\n            }\\n        }\\n        return true;        // aah, lovely! our brac stack is now empty which means we have validated the whole string pair by pair and it doesn\\'t matter if our star stack is empty or not since all asterisks can now be considered as \"\"\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815483,
                "title": "python-easy-solution-with-comment",
                "content": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        left_par_stack = []     # store the index of \"(\"\\n        star_stack = []         # store the index of \"*\"\\n        \\n        for i in range(len(s)):\\n            if s[i] == \"(\":                 # When encounter \"(\" or \"*\", we store it separately as \"money\" for future use.\\n                left_par_stack.append(i)\\n            elif s[i] == \"*\":\\n                star_stack.append(i)\\n            elif s[i] == \")\":               # When encounter \")\", it\\'s time we need to pay,\\n                if left_par_stack:          # we give priority to pay with \"(\", so the right-most \"(\" will be consumed.\\n                    left_par_stack.pop()\\n                elif star_stack:            # Otherwise, we pay with \"*\".\\n                    star_stack.pop()\\n                else:\\n                    return False            # We don\\'t have enough money to pay, game over.\\n        \\n        while left_par_stack:               # In situ that some \"(\" haven\\'t been consumed.\\n            if not star_stack:\\n                break\\n            elif star_stack[-1] > left_par_stack[-1]: # Only when the idx of \"*\" is greater than idx of \"(\" that can we apply \"*\" as \")\"\\n                star_stack.pop()\\n                left_par_stack.pop()\\n            elif star_stack[-1] < left_par_stack[-1]:\\n                break\\n        \\n        return not left_par_stack",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        left_par_stack = []     # store the index of \"(\"\\n        star_stack = []         # store the index of \"*\"\\n        \\n        for i in range(len(s)):\\n            if s[i] == \"(\":                 # When encounter \"(\" or \"*\", we store it separately as \"money\" for future use.\\n                left_par_stack.append(i)\\n            elif s[i] == \"*\":\\n                star_stack.append(i)\\n            elif s[i] == \")\":               # When encounter \")\", it\\'s time we need to pay,\\n                if left_par_stack:          # we give priority to pay with \"(\", so the right-most \"(\" will be consumed.\\n                    left_par_stack.pop()\\n                elif star_stack:            # Otherwise, we pay with \"*\".\\n                    star_stack.pop()\\n                else:\\n                    return False            # We don\\'t have enough money to pay, game over.\\n        \\n        while left_par_stack:               # In situ that some \"(\" haven\\'t been consumed.\\n            if not star_stack:\\n                break\\n            elif star_stack[-1] > left_par_stack[-1]: # Only when the idx of \"*\" is greater than idx of \"(\" that can we apply \"*\" as \")\"\\n                star_stack.pop()\\n                left_par_stack.pop()\\n            elif star_stack[-1] < left_par_stack[-1]:\\n                break\\n        \\n        return not left_par_stack",
                "codeTag": "Java"
            },
            {
                "id": 1026704,
                "title": "c-dp-0-ms-top-down",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    bool dfs(string &s, int i, int open) {\\n        if (open < 0) return 0;\\n        if (i == s.length()) return open == 0;\\n        if (dp[i][open] != -1) return dp[i][open];\\n        if (s[i] == \\'(\\') return dp[i][open] = dfs(s, i + 1, open + 1);\\n        if (s[i] == \\')\\') return dp[i][open] = dfs(s, i + 1, open - 1);      \\n        return dp[i][open] = dfs(s, i + 1, open + 1) || dfs(s, i + 1, open - 1) || dfs(s, i + 1, open);\\n    }\\n    \\n    bool checkValidString(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(s, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    bool dfs(string &s, int i, int open) {\\n        if (open < 0) return 0;\\n        if (i == s.length()) return open == 0;\\n        if (dp[i][open] != -1) return dp[i][open];\\n        if (s[i] == \\'(\\') return dp[i][open] = dfs(s, i + 1, open + 1);\\n        if (s[i] == \\')\\') return dp[i][open] = dfs(s, i + 1, open - 1);      \\n        return dp[i][open] = dfs(s, i + 1, open + 1) || dfs(s, i + 1, open - 1) || dfs(s, i + 1, open);\\n    }\\n    \\n    bool checkValidString(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(s, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582217,
                "title": "explanation-using-2-stack",
                "content": "The base intution is we can either use a * as a \\'(\\' or \\')\\' we just have to know how?\\n\\n1)Assume that the example is ((* ) )) here we can see we have to use the star as a left parenthesis. So if we exchange * -->(  our parenthesis are balanced now.\\nFor this purpose what we wil do is create two seperate stacks one for left parenthesis(st1)and other for the star(st1).\\nif a \\')\\' is encountered first pop from st1 then from st2 so in this we make use of * as (.\\n\\n2) Assume the example to be (((* )) so here we can clearly see that we have to exchange * with ). we do the step (1) after that we are left with some values in two stacks one representing the left parenthesis and other the star. The. only condition we have to keep in mind is a * can only be on right side of \\'(\\'. That is \" (* \"  then only we can replace it with a \" ) \"\\nand balance the string. so index of * must be greater than index of (.\\n```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        //star can be treated either as ( or )\\n        //if the number of left p and right p are equal than treat * as empty\\n        // if number of unbalanced parenthesis is equal to number of stars then it can be balanced\\n        //intution is star can not come before ( --> *(\\n        \\n        \\n        \\n//         if(s=\"\")\\n//             return true;\\n        int starcounter=0;\\n        int failed=0;\\n        Stack<Integer> st1 = new Stack<>();\\n        Stack<Integer> st2=new Stack<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n               st1.push(i); \\n            }\\n            else if(s.charAt(i)==\\'*\\')\\n            {\\n                st2.push(i);\\n            }\\n            else\\n            {\\n                if(!st1.isEmpty())\\n                    st1.pop();\\n                else if(!st2.isEmpty())\\n                    st2.pop();\\n                else return false;\\n            }\\n        }\\n        //now compare the 2 stacks\\n        // we are not worried about the star stack because a star can be\\n        // treat as empty also\\n        while(!st1.isEmpty() && !st2.isEmpty())\\n        {\\n            if(st2.pop()<st1.pop())\\n                return false;\\n            //take out index from paren and star\\n            \\n        }\\n        return st1.isEmpty();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        //star can be treated either as ( or )\\n        //if the number of left p and right p are equal than treat * as empty\\n        // if number of unbalanced parenthesis is equal to number of stars then it can be balanced\\n        //intution is star can not come before ( --> *(\\n        \\n        \\n        \\n//         if(s=\"\")\\n//             return true;\\n        int starcounter=0;\\n        int failed=0;\\n        Stack<Integer> st1 = new Stack<>();\\n        Stack<Integer> st2=new Stack<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n               st1.push(i); \\n            }\\n            else if(s.charAt(i)==\\'*\\')\\n            {\\n                st2.push(i);\\n            }\\n            else\\n            {\\n                if(!st1.isEmpty())\\n                    st1.pop();\\n                else if(!st2.isEmpty())\\n                    st2.pop();\\n                else return false;\\n            }\\n        }\\n        //now compare the 2 stacks\\n        // we are not worried about the star stack because a star can be\\n        // treat as empty also\\n        while(!st1.isEmpty() && !st2.isEmpty())\\n        {\\n            if(st2.pop()<st1.pop())\\n                return false;\\n            //take out index from paren and star\\n            \\n        }\\n        return st1.isEmpty();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577216,
                "title": "python-easy-o-n-time-and-o-1-space",
                "content": "Runtime: 24 ms less than 90% solutions\\nMemory Usage: 13.9 MB less than 20% solutions\\n```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        \\n        if len(s)==0 or s==\\'*\\':return True\\n        if len(s)==1:return False\\n        \\n        leftBalance = 0\\n        # from left\\n        for i in s:\\n            if i==\\')\\':leftBalance-=1\\n            else: leftBalance+=1\\n            \\n            if leftBalance<0:return False #If number of ) brackets is more than the sum of ( and *, string is unbalanced\\n        \\n        if leftBalance==0:return True\\n        \\n        rightBalance = 0\\n        # from right\\n        for i in reversed(s):\\n            if i==\\'(\\':rightBalance-=1\\n            else: rightBalance+=1\\n            \\n            if rightBalance<0:return False#If number of ( brackets is more than the sum of ) and *, string is unbalanced\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        \\n        if len(s)==0 or s==\\'*\\':return True\\n        if len(s)==1:return False\\n        \\n        leftBalance = 0\\n        # from left\\n        for i in s:\\n            if i==\\')\\':leftBalance-=1\\n            else: leftBalance+=1\\n            \\n            if leftBalance<0:return False #If number of ) brackets is more than the sum of ( and *, string is unbalanced\\n        \\n        if leftBalance==0:return True\\n        \\n        rightBalance = 0\\n        # from right\\n        for i in reversed(s):\\n            if i==\\'(\\':rightBalance-=1\\n            else: rightBalance+=1\\n            \\n            if rightBalance<0:return False#If number of ( brackets is more than the sum of ) and *, string is unbalanced\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468363,
                "title": "greedy-java-solution",
                "content": "# Greedy solution\\n* If open paren \\'(\\'  - then push to **leftParenIndices** stack\\n* If \\'\\\\*\\' - then push to **starIndices** stack\\n* If close paren \\')\\' then,\\n\\t* if **leftParenIndices** stack is not Empty then match it, else\\n\\t* if **starIndices** stack is not empty then match it, else\\n\\t* No matching present return **false**\\n\\n*  Once All closing paren is matched - if **leftParenIndices** stack is not empty then,\\n\\t*  if **starIndices** is not empty then check whether the * is after left paren \\'(\\'\\n\\t*  if either **starIndices** is empty or the index falls before \\'(\\' then return **false**\\n\\n```\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> leftParenIndices = new Stack<>();\\n        Stack<Integer> starIndices = new Stack<>();\\n\\n        for (int index = 0; index < s.length(); index++) {\\n            char c = s.charAt(index);\\n            if (c == \\'(\\') leftParenIndices.push(index);\\n            else if (c == \\')\\') {\\n                if (!leftParenIndices.isEmpty()) leftParenIndices.pop();\\n                else if (!starIndices.isEmpty()) starIndices.pop();\\n                else return false;\\n            } else {\\n                starIndices.push(index);\\n            }\\n        }\\n\\n        while (!leftParenIndices.isEmpty()) {\\n            if (starIndices.isEmpty() || starIndices.pop() < leftParenIndices.pop()) return false;\\n        }\\n\\n        return true;\\n    }\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> leftParenIndices = new Stack<>();\\n        Stack<Integer> starIndices = new Stack<>();\\n\\n        for (int index = 0; index < s.length(); index++) {\\n            char c = s.charAt(index);\\n            if (c == \\'(\\') leftParenIndices.push(index);\\n            else if (c == \\')\\') {\\n                if (!leftParenIndices.isEmpty()) leftParenIndices.pop();\\n                else if (!starIndices.isEmpty()) starIndices.pop();\\n                else return false;\\n            } else {\\n                starIndices.push(index);\\n            }\\n        }\\n\\n        while (!leftParenIndices.isEmpty()) {\\n            if (starIndices.isEmpty() || starIndices.pop() < leftParenIndices.pop()) return false;\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 406589,
                "title": "javascript-solutions-backtracking-and-interval-balance",
                "content": "The common idea is simply the same as if we would not have `*`: calculate the balance between `(` and `)` characters. At the end the balance should be `0` for the valid string.\\n\\n### Backtracking\\nJust consider all the possible characters instead of `*`:\\n\\n```js\\nvar checkValidString = function(s, count = 0) {\\n  for (let i = 0; i < s.length; i++) {\\n    if (count < 0) {\\n      return false;\\n    }\\n    \\n    const char = s[i];\\n\\n    if (char === \\'(\\') {\\n      count++;\\n      continue;\\n    }\\n    \\n    if (char === \\')\\') {\\n      count--;\\n      continue;\\n    }\\n    \\n    const next = s.slice(i + 1);\\n    \\n    return checkValidString(next, count)\\n      || checkValidString(next, count + 1)\\n      || checkValidString(next, count - 1);\\n  }\\n  \\n  return count === 0;\\n};\\n```\\n\\n### Balance range\\nKeep track of the `low` and `high` balance of opened braces. `high` is the one when we consider every `*` to be an open brace `(`. `low` is the one that we consider every `*` to be a closing brace `)`.\\n\\nThe obvious failure is: `high` goes below `0` - means that balance become negative even though we considered every `*` as a `(`.\\n\\nAnother tricky moment is that the `low` never goes below `0` - since that is not having sense. That is invalid state that we should never go in. \\nIn such a case when `low` is about to go below the zero - we fix it to `0` (imagine it as going back to the previous `*` casted to the `low` => `)` and switching it to `(` to keep lowest state correct). That should be possible, since the `high` is positive. Other way we would exit with the `false` already.\\n\\n```js\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar checkValidString = function(s) {\\n  let lo = 0;\\n  let hi = 0;\\n  \\n  for (let char of s) {\\n    if (char === \\'(\\') {\\n      hi++;\\n      lo++;\\n      continue;\\n    }\\n    \\n    if (char === \\')\\' && hi === 0) {\\n      return false;\\n    }\\n    \\n    if (char === \\')\\') {\\n      hi--;\\n      lo = Math.max(0, lo - 1);\\n      continue;\\n    }\\n    \\n    hi++;\\n    lo = Math.max(0, lo - 1);\\n  }\\n  \\n  return lo === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```js\\nvar checkValidString = function(s, count = 0) {\\n  for (let i = 0; i < s.length; i++) {\\n    if (count < 0) {\\n      return false;\\n    }\\n    \\n    const char = s[i];\\n\\n    if (char === \\'(\\') {\\n      count++;\\n      continue;\\n    }\\n    \\n    if (char === \\')\\') {\\n      count--;\\n      continue;\\n    }\\n    \\n    const next = s.slice(i + 1);\\n    \\n    return checkValidString(next, count)\\n      || checkValidString(next, count + 1)\\n      || checkValidString(next, count - 1);\\n  }\\n  \\n  return count === 0;\\n};\\n```\n```js\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar checkValidString = function(s) {\\n  let lo = 0;\\n  let hi = 0;\\n  \\n  for (let char of s) {\\n    if (char === \\'(\\') {\\n      hi++;\\n      lo++;\\n      continue;\\n    }\\n    \\n    if (char === \\')\\' && hi === 0) {\\n      return false;\\n    }\\n    \\n    if (char === \\')\\') {\\n      hi--;\\n      lo = Math.max(0, lo - 1);\\n      continue;\\n    }\\n    \\n    hi++;\\n    lo = Math.max(0, lo - 1);\\n  }\\n  \\n  return lo === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 210335,
                "title": "c-concise-dp",
                "content": "We use the 2D matrix as the DP storage.\\n\\nWe fill the 2D matrix by main diagonal, sub diagnal, sub sub diagonal and etc. This means we want to find out if the single character substring can be valid, for example \"\\\\*\"? if the two characters substring can be valid, for exampe, \"(\\\\*\", \"\\\\*)\", \"\\\\*\\\\*\" and \"()\"? if the three characters substring can be valid? etc.. Hence we use **len** as the outer loop.\\n\\nFor each **len**, we want to find out if the substring (i, j) could be valid. It is valid if we can find a k, such that substring (i,k-1) is valid, substring (k+1, j-1) is valid, and pair (k, j) is also valid.\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int size = s.size(); if(size == 0) return true;\\n        vector<vector<bool>> dp(size, vector<bool>(size, false));\\n        for(int len=1; len<=size; len++) {\\n            for(int i=0; i<=size-len; i++) {\\n                int j = i+len-1;\\n                bool flag = false;\\n                for(int k=i; k<=j; k++) {\\n                    bool seg1 = (k-1)>=i ? dp[i][k-1] : true;\\n                    bool seg2 = (j-1)>=(k+1) ? dp[k+1][j-1] : true;\\n                    bool seg3;\\n                    if((s[k] == \\'*\\' && s[j] != \\'(\\') || (s[j] == \\'*\\' && s[k] != \\')\\') || (s[k]==\\'(\\' && s[j]==\\')\\')) {seg3 = true;} \\n                    else { seg3 = false; }\\n                    if(seg1==true && seg2==true && seg3==true){flag = true; break;}\\n                }\\n                dp[i][j] = flag;\\n            }\\n        }\\n        return dp[0][size-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int size = s.size(); if(size == 0) return true;\\n        vector<vector<bool>> dp(size, vector<bool>(size, false));\\n        for(int len=1; len<=size; len++) {\\n            for(int i=0; i<=size-len; i++) {\\n                int j = i+len-1;\\n                bool flag = false;\\n                for(int k=i; k<=j; k++) {\\n                    bool seg1 = (k-1)>=i ? dp[i][k-1] : true;\\n                    bool seg2 = (j-1)>=(k+1) ? dp[k+1][j-1] : true;\\n                    bool seg3;\\n                    if((s[k] == \\'*\\' && s[j] != \\'(\\') || (s[j] == \\'*\\' && s[k] != \\')\\') || (s[k]==\\'(\\' && s[j]==\\')\\')) {seg3 = true;} \\n                    else { seg3 = false; }\\n                    if(seg1==true && seg2==true && seg3==true){flag = true; break;}\\n                }\\n                dp[i][j] = flag;\\n            }\\n        }\\n        return dp[0][size-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675385,
                "title": "stack-approach-runtime-1-ms-faster-than-72-27-memory-usage-40-4-mb-less-than-87-60",
                "content": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        //first stack to store position of open bracket\\n        Stack<Integer> star  = new Stack<Integer>();\\n        //second stack to store position of star\\n        Stack<Integer> open = new Stack<Integer>();\\n        \\n        for(int i=0;i<s.length();i++) {\\n            char ch = s.charAt(i);\\n            \\n            //if left bracket then push it in stack\\n            if(ch ==\\'(\\')\\n                open.push(i);\\n            \\n            else  if(ch == \\'*\\')\\n                star.push(i);\\n            \\n            else{\\n                //when right bracket comes, check for stack of left bracket\\n                if(!open.empty()) //if non empty remove it\\n                    open.pop();\\n                \\n                else if(!star.empty()) //if left is 0, then check if we can take star as left bracket\\n                    star.pop();\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        \\n        //left over left bracket balance needs to be checked\\n        while(!open.empty()) {\\n            if(star.empty())\\n                return false;\\n            \\n            //position comparison as left bracket should come before right bracket\\n            else if(open.peek()<star.peek()) {\\n                open.pop();\\n                star.pop();\\n            }\\n            \\n            else\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n        \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        //first stack to store position of open bracket\\n        Stack<Integer> star  = new Stack<Integer>();\\n        //second stack to store position of star\\n        Stack<Integer> open = new Stack<Integer>();\\n        \\n        for(int i=0;i<s.length();i++) {\\n            char ch = s.charAt(i);\\n            \\n            //if left bracket then push it in stack\\n            if(ch ==\\'(\\')\\n                open.push(i);\\n            \\n            else  if(ch == \\'*\\')\\n                star.push(i);\\n            \\n            else{\\n                //when right bracket comes, check for stack of left bracket\\n                if(!open.empty()) //if non empty remove it\\n                    open.pop();\\n                \\n                else if(!star.empty()) //if left is 0, then check if we can take star as left bracket\\n                    star.pop();\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        \\n        //left over left bracket balance needs to be checked\\n        while(!open.empty()) {\\n            if(star.empty())\\n                return false;\\n            \\n            //position comparison as left bracket should come before right bracket\\n            else if(open.peek()<star.peek()) {\\n                open.pop();\\n                star.pop();\\n            }\\n            \\n            else\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n        \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399443,
                "title": "c-using-stack-100-efficiency-with-explaination",
                "content": "**Explaination: Using vector to simulate stack**\\n1. Store index of open parenthesis.\\n2. Store index of asterisks.\\n3. Now whenever we encounter a closed parenthesis.\\n   i. We first use open parenthesis to cover for that close parenthesis.\\n   ii. If there are no open parenthesis, then we will use asterisk to cover that close parenthesis.\\n   iii. And if we had neither(open or asterisk) then it means we encountered a close parenthesis for which we dont           have either open parenthesis or asterisk, for this we maintain a invalid variable, we set that invalid as 1 and             break the loop as the string became invalid.\\n4. At last when the string is over, we check if we have any open parenthesis, if yes then,\\n\\ti. If we have asterisk whose last index is greater than the open last index, then we cover that open parenthesis with the asterisk else the string again becomes invalid.\\n5. At last return the count of open parenthesis.(If the string is valid the open parenthesis and the close parenthesis will be zero).\\n\\n**Soution:**\\n\\nclass Solution {\\npublic:\\n\\n    bool checkValidString(string s) {\\n        vector<int> open, ast; // using vector to simulate stack, stack can also be used.\\n        int invalid = 0;\\n        \\n        for(int i=0; i<s.length(); ++i){\\n            if(s[i] == \\'(\\'){\\n                open.push_back(i);// storing the indexes of open parenthesis.\\n            } else if(s[i] == \\'*\\'){\\n                ast.push_back(i);// storing the indexes of asterisks.\\n            } else {\\n                if(!open.empty()) open.pop_back();\\n                else if(!ast.empty()){\\n                    ast.pop_back();\\n                } else {\\n                    invalid = 1;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        while(!open.empty() and !ast.empty()){\\n            if(open.back() < ast.back()){\\n                open.pop_back();\\n                ast.pop_back();\\n            } else {\\n\\t\\t\\t\\t//else will encounter in this case: *(*(\\n                break;\\n            }\\n        }\\n        return invalid == 1 ? false : open.empty();\\n    }\\n};\\n\\n**Time: O(N), Space: O(N).**\\n**PLEASE UPVOTE IF HELPFUL!!!**\\nFor doubt or query, comment below.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool checkValidString(string s) {\\n        vector<int> open, ast; // using vector to simulate stack, stack can also be used.\\n        int invalid = 0;\\n        \\n        for(int i=0; i<s.length(); ++i){\\n            if(s[i] == \\'(\\'){\\n                open.push_back(i);// storing the indexes of open parenthesis.\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2350009,
                "title": "beats-100-other-s-solutions",
                "content": "```\\nclass Solution:\\n    def checkValidString(self, s):\\n        lo = hi = 0\\n        for c in s:\\n            lo += 1 if c == \\'(\\' else -1\\n            hi += 1 if c != \\')\\' else -1\\n            if hi < 0: break\\n            lo = max(lo, 0)\\n\\n        return lo == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkValidString(self, s):\\n        lo = hi = 0\\n        for c in s:\\n            lo += 1 if c == \\'(\\' else -1\\n            hi += 1 if c != \\')\\' else -1\\n            if hi < 0: break\\n            lo = max(lo, 0)\\n\\n        return lo == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600086,
                "title": "easy-c-solution-with-the-help-of-two-stacks-100-time-0ms",
                "content": "Traverse over the string:\\n\\nif s[i] == \\'(\\'\\npush i in bracket stack \\'b\\'\\nif s[i] == \\'*\\'\\npush i in star stack \\'s\\'\\nif s[i] == \\')\\'\\npop top most index if b stack is not empty else \\npop one element from s stack\\nbut if ast stack is also empty , return false\\n\\nAfter traversing all the characters if b stack is still not empty then ensure that the elements in b stack is balanced by s stack\\nif index at top of b stack > index at top of s stack, this means there was no \\'*\\' came before \\'(\\' , so there is no way we can balance them i.e. now we return false\\notherwise pop one element from both s and b stack\\n\\nfinally if stack b is empty return true , else return false\\n\\n```\\n\\n        stack <int> b;\\n        stack <int> st;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')b.push(i);\\n            else if(s[i]==\\'*\\')st.push(i);\\n            else \\n            {\\n                if(!b.empty())b.pop();\\n                else if(!st.empty())st.pop();\\n                else return false;\\n            }\\n        }\\n\\n        while(!b.empty()  && !st.top())\\n        {\\n           if(b.top()>st.top())return false;\\n            else\\n           {\\n               b.pop();\\n               st.pop();\\n           }\\n        }\\n        \\n        if(!b.empty())return false;\\n        return true;\\n\\t\\t```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n\\n        stack <int> b;\\n        stack <int> st;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')b.push(i);\\n            else if(s[i]==\\'*\\')st.push(i);\\n            else \\n            {\\n                if(!b.empty())b.pop();\\n                else if(!st.empty())st.pop();\\n                else return false;\\n            }\\n        }\\n\\n        while(!b.empty()  && !st.top())\\n        {\\n           if(b.top()>st.top())return false;\\n            else\\n           {\\n               b.pop();\\n               st.pop();\\n           }\\n        }\\n        \\n        if(!b.empty())return false;\\n        return true;\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1491783,
                "title": "java-greedy-2-passes-solution-clear-o-n-time",
                "content": "```\\n// Greedy 2 Passes Solution\\n// Time complexity: O(N)\\n// Space complexity: O(1)\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        if (s == null || s.length() == 0) return true;  // or throw exception\\n        final int N = s.length();\\n        // Check left balance from left to right\\n        int leftBalance = 0;\\n        for (int i = 0; i < N; i++) {\\n            char ch = s.charAt(i);\\n            if (ch == \\'(\\' || ch == \\'*\\') {\\n                leftBalance++;\\n            } else {\\n                leftBalance--;\\n            }\\n            if (leftBalance < 0) return false;  // not enough left parenthesis\\n        }\\n        if (leftBalance == 0) return true;\\n        // Check right balance from right to left\\n        int rightBalance = 0;\\n        for (int i = N - 1; i >= 0; i--) {\\n            char ch = s.charAt(i);\\n            if (ch == \\')\\' || ch == \\'*\\') {\\n                rightBalance++;\\n            } else {\\n                rightBalance--;\\n            }\\n            if (rightBalance < 0) return false;  // not enough right parenthesis\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Greedy 2 Passes Solution\\n// Time complexity: O(N)\\n// Space complexity: O(1)\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        if (s == null || s.length() == 0) return true;  // or throw exception\\n        final int N = s.length();\\n        // Check left balance from left to right\\n        int leftBalance = 0;\\n        for (int i = 0; i < N; i++) {\\n            char ch = s.charAt(i);\\n            if (ch == \\'(\\' || ch == \\'*\\') {\\n                leftBalance++;\\n            } else {\\n                leftBalance--;\\n            }\\n            if (leftBalance < 0) return false;  // not enough left parenthesis\\n        }\\n        if (leftBalance == 0) return true;\\n        // Check right balance from right to left\\n        int rightBalance = 0;\\n        for (int i = N - 1; i >= 0; i--) {\\n            char ch = s.charAt(i);\\n            if (ch == \\')\\' || ch == \\'*\\') {\\n                rightBalance++;\\n            } else {\\n                rightBalance--;\\n            }\\n            if (rightBalance < 0) return false;  // not enough right parenthesis\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583548,
                "title": "summary-of-3-types-of-solutions-6-solutions-with-bonus-preprocess-trick",
                "content": "## preprocess trick\\nThis is what I didn\\'t find in other posts so I list it separately here.\\n\\nThe basic idea is: \\nIf there are two adjacent \\'(\\' and \\')\\', then they are definitely paired no matter how we interpret \\'*\\'s, so we can directly eliminate the pair. After we eliminate them, if there are newly generated adjacent \\'(\\' and \\')\\' we can recursively eliminate that pair. \\n\\nThis process can be impemented using stack, similar to traditional parenthese problems. It can in general make `N` much smaller thus accelerate algorithms a lot.\\n\\n```python\\n\\t# preprocess code\\n\\tstack = []\\n\\tfor c in s:\\n\\t\\tif c == \\')\\':\\n\\t\\t\\tif not stack: return False\\n\\t\\t\\tif stack[-1] == \\'(\\': stack.pop()\\n\\t\\t\\telse: stack.append(\\')\\')\\n\\t\\telse:\\n\\t\\t\\tstack.append(c)\\t\\t\\t\\n\\ts = \"\".join(stack)\\n```\\n\\n## solution 1: DFS\\nessentially brute force with pruning, O(N*2^N)\\n```python\\ndef checkValidString(self, s):   \\n        \\n        # preprocess: eliminate paired brackets\\n        stack = []\\n        for c in s:\\n            if c == \\'(\\': stack.append(c)\\n            elif c == \\'*\\':  stack.append(\\'*\\')\\n            else:\\n                if not stack: return False\\n                if stack[-1] == \\'(\\': stack.pop()\\n                else: stack.append(\\')\\')\\n        L = len(stack)                \\n        \\n        def process(indexS, nleft):\\n            while indexS < L and stack[indexS] != \\'*\\':\\n                if stack[indexS] == \\'(\\': nleft += 1\\n                else:\\n                    if not nleft:  return -1\\n                    nleft -= 1\\n                indexS += 1\\n\\n            if indexS == L:  return nleft\\n\\n            plain = process(indexS+1, nleft)         \\n            if plain == 0:  return 0\\n            elif plain < 0: return process(indexS+1, nleft+1)\\n            elif nleft:  # do not forget to check nleft > 0 !\\n                return process(indexS+1, nleft-1) \\n            else: return plain\\n\\n        return process(0,0) == 0  \\n```\\n\\n## solution 2: DP\\n\\n### 2.1 from top to bottom\\uFF08demand-driven DP\\uFF09\\nTheoretically still O(N^3)\\uFF0Chowever much faster in practice than traditional DP, since we do not calculate the results which is not used in final decision. \\n\\n```python\\nimport functools\\n\\ndef checkValidString(self, s):          \\n        # preprocess: eliminate paired brackets\\n        stack = []\\n        for c in s:\\n            if c == \\'(\\':  stack.append(c)\\n            elif c == \\'*\\': stack.append(\\'*\\')\\n            else:\\n                if not stack: return False\\n                if stack[-1] == \\'(\\':  stack.pop()\\n                else: stack.append(\\')\\')\\n        s = \"\".join(stack)\\n        \\n        @functools.lru_cache(maxsize = None)\\n        def valid(i, j):\\n            if i == j: return True\\n            if s[i] == \\')\\' or s[j-1] == \\'(\\': return False\\n            if s[i] == \\'*\\':\\n                if valid(i+1, j): return True            \\n            return any( s[k] != \\'(\\' and valid(i+1,k) and valid(k+1,j) for k in range(i+1, j) )       \\n        \\n        return valid(0, len(s))\\n```\\n\\n### 2.2 from bottom to top\\nO(N^3)\\n```python\\ndef checkValidString(self, s: str) -> bool:\\n        \\n        # preprocess: eliminate paired brackets\\n        stack = []\\n        for c in s:\\n            if c == \\'(\\':  stack.append(c)\\n            elif c == \\'*\\': stack.append(\\'*\\')\\n            else:\\n                if not stack: return False\\n                if stack[-1] == \\'(\\':  stack.pop()\\n                else: stack.append(\\')\\')\\n        s = \"\".join(stack)\\n        L = len(s)\\n        \\n        dp = [ [True] * (i+1) + [False] * (L-i) for i in range(L+1) ]        \\n        for i in range(L):            \\n            if s[i] == \\'*\\':\\n                dp[i][i+1] = True\\n        for i in range(L-1):\\n            if s[i] in \"*(\" and s[i+1] in \")*\":\\n                dp[i][i+2] = True\\n                \\n        for width in range(3, L+1):\\n            for i in range( L + 1 - width ):\\n                if s[i] == \\'*\\' and dp[i+1][i+width]:\\n                    dp[i][i+width] = True\\n                elif s[i] in \"(*\":\\n                    if any( s[k] in \")*\" and dp[i+1][k] and dp[k+1][i+width] for k in range(i+1, i+width) ):\\n                        dp[i][i+width] = True\\n         \\n        return dp[0][L]\\n```\\n\\n\\n\\n## solution 3 greedy / math\\nO(N)\\n\\n### 3.1 calculate balance of open left brackets\\n```python\\ndef checkValidString(self, s: str) -> bool:\\n        loOpen = hiOpen = 0  # possible number of open left brackets\\n        for c in s:\\n            if c == \\'(\\':\\n                loOpen, hiOpen = loOpen+1, hiOpen+1\\n            elif c == \\')\\':\\n                loOpen, hiOpen = loOpen-1, hiOpen-1\\n            else:\\n                loOpen, hiOpen = loOpen-1, hiOpen+1\\n            if hiOpen < 0: return False\\n            loOpen = max(0, loOpen)        \\n        \\n        return loOpen == 0   # essentially loOpen <= 0 <= hiOpen\\n```\\n\\n### 3.2 Two Stacks\\n```c++\\nbool checkValidString(string s) {\\n      stack<int> open,ast;\\n      for(int i=0;i<s.length();i++)\\n      {\\n          if(s[i] == \\')\\')\\n          {\\n              if(!open.empty()) open.pop();\\n              else if(!ast.empty()) ast.pop();\\n              else return false;\\n          }\\n          else if(s[i] == \\'(\\')   open.push(i);\\n          else ast.push(i);\\n      }\\n      while(!open.empty() && !ast.empty())\\n      {\\n         if(open.top() > ast.top()) return false;\\n         open.pop();\\n          ast.pop();\\n      }\\n        return open.empty();\\n    }\\n```\\n\\n### 3.3 Two Pass\\nEssentially do greedy twice, once forwards treating all * as ( and once backwards treating all * as )\\n```python\\ndef checkValidString(self, s):   \\n        # preprocess: eliminate paired brackets\\n        stack = []\\n        for c in s:\\n            if c == \\'(\\':  stack.append(c)\\n            elif c == \\'*\\': stack.append(\\'*\\')\\n            else:\\n                if not stack: return False\\n                if stack[-1] == \\'(\\':  stack.pop()\\n                else: stack.append(\\')\\')\\n        s = \"\".join(stack)\\n        \\n        if not s:  return True\\n        if not \"*\" in s or s[-1] == \\'(\\': return False\\n                \\n        left = [0] * len(s)\\n        for i in range(1, len(s)):\\n            left[i] = left[i-1] + ( s[i] == \\')\\' )\\n        if any( n > i-n for i,n in enumerate(left, start = 1) ):\\n            return False\\n        \\n        right = [0] * len(s)\\n        for i in range( len(s)-2, -1, -1 ):\\n            right[i] = right[i+1] + ( s[i] == \\'(\\' )\\n        if any( n > i-n for i,n in enumerate(right[::-1], start = 1) ):\\n            return False\\n        \\n        return True\\n```\\n\\n( Some of the code is learned from other posts. It is written originally as a personal note for myself, so I didn\\'t record the source. Contact me to add links to original posts if you wish. )",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\\t# preprocess code\\n\\tstack = []\\n\\tfor c in s:\\n\\t\\tif c == \\')\\':\\n\\t\\t\\tif not stack: return False\\n\\t\\t\\tif stack[-1] == \\'(\\': stack.pop()\\n\\t\\t\\telse: stack.append(\\')\\')\\n\\t\\telse:\\n\\t\\t\\tstack.append(c)\\t\\t\\t\\n\\ts = \"\".join(stack)\\n```\n```python\\ndef checkValidString(self, s):   \\n        \\n        # preprocess: eliminate paired brackets\\n        stack = []\\n        for c in s:\\n            if c == \\'(\\': stack.append(c)\\n            elif c == \\'*\\':  stack.append(\\'*\\')\\n            else:\\n                if not stack: return False\\n                if stack[-1] == \\'(\\': stack.pop()\\n                else: stack.append(\\')\\')\\n        L = len(stack)                \\n        \\n        def process(indexS, nleft):\\n            while indexS < L and stack[indexS] != \\'*\\':\\n                if stack[indexS] == \\'(\\': nleft += 1\\n                else:\\n                    if not nleft:  return -1\\n                    nleft -= 1\\n                indexS += 1\\n\\n            if indexS == L:  return nleft\\n\\n            plain = process(indexS+1, nleft)         \\n            if plain == 0:  return 0\\n            elif plain < 0: return process(indexS+1, nleft+1)\\n            elif nleft:  # do not forget to check nleft > 0 !\\n                return process(indexS+1, nleft-1) \\n            else: return plain\\n\\n        return process(0,0) == 0  \\n```\n```python\\nimport functools\\n\\ndef checkValidString(self, s):          \\n        # preprocess: eliminate paired brackets\\n        stack = []\\n        for c in s:\\n            if c == \\'(\\':  stack.append(c)\\n            elif c == \\'*\\': stack.append(\\'*\\')\\n            else:\\n                if not stack: return False\\n                if stack[-1] == \\'(\\':  stack.pop()\\n                else: stack.append(\\')\\')\\n        s = \"\".join(stack)\\n        \\n        @functools.lru_cache(maxsize = None)\\n        def valid(i, j):\\n            if i == j: return True\\n            if s[i] == \\')\\' or s[j-1] == \\'(\\': return False\\n            if s[i] == \\'*\\':\\n                if valid(i+1, j): return True            \\n            return any( s[k] != \\'(\\' and valid(i+1,k) and valid(k+1,j) for k in range(i+1, j) )       \\n        \\n        return valid(0, len(s))\\n```\n```python\\ndef checkValidString(self, s: str) -> bool:\\n        \\n        # preprocess: eliminate paired brackets\\n        stack = []\\n        for c in s:\\n            if c == \\'(\\':  stack.append(c)\\n            elif c == \\'*\\': stack.append(\\'*\\')\\n            else:\\n                if not stack: return False\\n                if stack[-1] == \\'(\\':  stack.pop()\\n                else: stack.append(\\')\\')\\n        s = \"\".join(stack)\\n        L = len(s)\\n        \\n        dp = [ [True] * (i+1) + [False] * (L-i) for i in range(L+1) ]        \\n        for i in range(L):            \\n            if s[i] == \\'*\\':\\n                dp[i][i+1] = True\\n        for i in range(L-1):\\n            if s[i] in \"*(\" and s[i+1] in \")*\":\\n                dp[i][i+2] = True\\n                \\n        for width in range(3, L+1):\\n            for i in range( L + 1 - width ):\\n                if s[i] == \\'*\\' and dp[i+1][i+width]:\\n                    dp[i][i+width] = True\\n                elif s[i] in \"(*\":\\n                    if any( s[k] in \")*\" and dp[i+1][k] and dp[k+1][i+width] for k in range(i+1, i+width) ):\\n                        dp[i][i+width] = True\\n         \\n        return dp[0][L]\\n```\n```python\\ndef checkValidString(self, s: str) -> bool:\\n        loOpen = hiOpen = 0  # possible number of open left brackets\\n        for c in s:\\n            if c == \\'(\\':\\n                loOpen, hiOpen = loOpen+1, hiOpen+1\\n            elif c == \\')\\':\\n                loOpen, hiOpen = loOpen-1, hiOpen-1\\n            else:\\n                loOpen, hiOpen = loOpen-1, hiOpen+1\\n            if hiOpen < 0: return False\\n            loOpen = max(0, loOpen)        \\n        \\n        return loOpen == 0   # essentially loOpen <= 0 <= hiOpen\\n```\n```c++\\nbool checkValidString(string s) {\\n      stack<int> open,ast;\\n      for(int i=0;i<s.length();i++)\\n      {\\n          if(s[i] == \\')\\')\\n          {\\n              if(!open.empty()) open.pop();\\n              else if(!ast.empty()) ast.pop();\\n              else return false;\\n          }\\n          else if(s[i] == \\'(\\')   open.push(i);\\n          else ast.push(i);\\n      }\\n      while(!open.empty() && !ast.empty())\\n      {\\n         if(open.top() > ast.top()) return false;\\n         open.pop();\\n          ast.pop();\\n      }\\n        return open.empty();\\n    }\\n```\n```python\\ndef checkValidString(self, s):   \\n        # preprocess: eliminate paired brackets\\n        stack = []\\n        for c in s:\\n            if c == \\'(\\':  stack.append(c)\\n            elif c == \\'*\\': stack.append(\\'*\\')\\n            else:\\n                if not stack: return False\\n                if stack[-1] == \\'(\\':  stack.pop()\\n                else: stack.append(\\')\\')\\n        s = \"\".join(stack)\\n        \\n        if not s:  return True\\n        if not \"*\" in s or s[-1] == \\'(\\': return False\\n                \\n        left = [0] * len(s)\\n        for i in range(1, len(s)):\\n            left[i] = left[i-1] + ( s[i] == \\')\\' )\\n        if any( n > i-n for i,n in enumerate(left, start = 1) ):\\n            return False\\n        \\n        right = [0] * len(s)\\n        for i in range( len(s)-2, -1, -1 ):\\n            right[i] = right[i+1] + ( s[i] == \\'(\\' )\\n        if any( n > i-n for i,n in enumerate(right[::-1], start = 1) ):\\n            return False\\n        \\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 582776,
                "title": "javascript-using-one-stack",
                "content": "```\\nvar checkValidString = function (s) {\\n    if (!s) return true;\\n    var stack = [],\\n    l=0,r=0,len = s.length,star = 0;\\n    for (let i = 0; i < len; i++) {\\n        if (s[i] === \"(\") {\\n            l++;\\n            stack.push(true);\\n        } else if (s[i] === \")\") {\\n            r++;\\n            if(star + l < r){\\n                return false;\\n            }\\n            stack.pop();\\n        } else if (s[i] === \"*\") {\\n            star++;\\n            stack.pop();\\n        }\\n    }\\n    if (stack.length === 0) return true;\\n    return false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar checkValidString = function (s) {\\n    if (!s) return true;\\n    var stack = [],\\n    l=0,r=0,len = s.length,star = 0;\\n    for (let i = 0; i < len; i++) {\\n        if (s[i] === \"(\") {\\n            l++;\\n            stack.push(true);\\n        } else if (s[i] === \")\") {\\n            r++;\\n            if(star + l < r){\\n                return false;\\n            }\\n            stack.pop();\\n        } else if (s[i] === \"*\") {\\n            star++;\\n            stack.pop();\\n        }\\n    }\\n    if (stack.length === 0) return true;\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 582592,
                "title": "javascript-using-stacks-beats-100-memory",
                "content": "```\\nvar checkValidString = function(s) {\\n    \\n    const openStack = [];\\n    const starStack = [];\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        \\n        if(s[i] === \\'(\\') {\\n            openStack.push(i);\\n        } else if (s[i] === \\'*\\') {\\n            starStack.push(i);\\n        } else {\\n            if(openStack.length > 0) {\\n                openStack.pop();\\n            } else if(starStack.length > 0) {\\n                starStack.pop();\\n            } else {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    let i = openStack.length - 1;\\n    let j = starStack.length - 1;\\n    \\n    while(openStack[i] < starStack[j]) {\\n        openStack.pop();\\n        starStack.pop();\\n        i--;\\n        j--;\\n    }\\n    \\n    if(openStack.length === 0) {\\n        return true;\\n    } else {\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkValidString = function(s) {\\n    \\n    const openStack = [];\\n    const starStack = [];\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        \\n        if(s[i] === \\'(\\') {\\n            openStack.push(i);\\n        } else if (s[i] === \\'*\\') {\\n            starStack.push(i);\\n        } else {\\n            if(openStack.length > 0) {\\n                openStack.pop();\\n            } else if(starStack.length > 0) {\\n                starStack.pop();\\n            } else {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    let i = openStack.length - 1;\\n    let j = starStack.length - 1;\\n    \\n    while(openStack[i] < starStack[j]) {\\n        openStack.pop();\\n        starStack.pop();\\n        i--;\\n        j--;\\n    }\\n    \\n    if(openStack.length === 0) {\\n        return true;\\n    } else {\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107600,
                "title": "678-valid-parenthesis-string-c-using-stack",
                "content": "In the stack, we also store the position information.\\n\\n    class Solution {\\n    public:\\n    bool checkValidString(string s) {\\n        if(s.empty()) return true;\\n        stack<pair<char, int> > st;\\n        stack<pair<char, int> > st2;\\n        int i = 0;\\n        for(;i < s.size(); ++i){\\n            if(s[i] == '*'){\\n                st2.push({s[i],i});\\n            }else if(s[i] == '('){\\n                st.push({s[i],i});\\n            }else{\\n                if(!st.empty()){\\n                    st.pop();\\n                }else if(!st2.empty()){\\n                    st2.pop();\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n        while(!st.empty() && !st2.empty()){\\n            auto left = st.top();\\n            auto star = st2.top();\\n            if(left.second >= star.second){\\n                break;\\n            }\\n            st.pop();\\n            st2.pop();\\n        }\\n        return st.empty() && i == s.size();\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    bool checkValidString(string s) {\\n        if(s.empty()) return true;\\n        stack<pair<char, int> > st;\\n        stack<pair<char, int> > st2;\\n        int i = 0;\\n        for(;i < s.size(); ++i){\\n            if(s[i] == '*'){\\n                st2.push({s[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 3505092,
                "title": "c-using-2-stacks-very-detailed-and-beginner-friendly-explanation",
                "content": "# Intuition\\nIf you have previously solved the normal Valid Parenthesis problem ,the first thought that comes when solving this problem , is using a stack to store the open brackets , and then on every occurence of a closing bracket , pop the stack if the top element is an open bracket and hence balance the parenthesis.\\n\\nHowever in this case there is an added complexity of the \\'*\\' character that we need to take care of . \\nCharacters which are brackets will be processed with the same old logic , but stars will be processed differently , maybe with another stack . Lets see how !\\n# Approach\\n**Step 1**\\nSo initially we will have two stacks \\n- One for storing the indices of open brackets\\n- One for storing the indices of star characters.\\n\\n***Why storing indices?***\\nIn this problem the position of characters is the most important thing . \\n\\n**A star, in whatever form we convert it , cannot balance a closing bracket that comes before it**\\n\\nExample `)*( )\\n`\\n\\nIn this case the characters at positon 2 and 3 can get balanced easily , but the star cannot balance the closing bracket on index 0\\n\\n**Hence we need to store the indices of the character to think in terms of their positions.**\\n\\n**Step 2:**\\nWe iterate over the string and push \\'(\\' in open stack and \\'*\\' in star stack.\\n\\nUpon encountering a \\')\\' bracket we would check if there is a \\'(\\' on the top of open stack . \\n\\n- If yes -> simply pop and proceed\\n- If no ->  Dont worry ! star stack is there for rescue . If there is star left in the star stack we can use it balance our \\')\\' dude.\\n\\nBut if both the conditions fail , we cannot balance the bracket and hence return false\\n\\n**Step 3 :**\\nNow so far we have processed the closed brackets and have done respective popping for them . Now its time to process the open brackets\\n\\n**This is where the storing of indices will make more sense**\\n\\nLets assume after doing step 2 , we are left with the following stack states\\n\\n\\n```\\nstr = \"(*(**)\"\\n\\nAfter processing the entire string this is what we are left with.\\n\\nopen = [0]\\nstar = [1,3,4]\\n```\\n\\nNow we will start to balance out opening brackets with stars however the condition is that the star should appear after the opening bracket in the string \\n\\n`index of open bracket < index of star \\n`\\n\\nThen only we can balance them out . But if thats not the case we can return false\\n\\nFinally we check whether our open stack is empty , if it is then we return true because all the open brackets have been processed and balanced\\n\\nEmptiness of star stack is not important , because even if it is not empty , it doesnt matter as all the leftover stars can be considered to be empty characters.\\n\\n# Complexity\\n**Time complexity:**\\n\\n```\\nActual TC : O(N) + O(min(X,Y))\\n\\n```\\n- N is the length of string\\n- X is the number of leftover open brackets after initial processing\\n- Y is the number of leftover stars after intitla processing\\n\\n```\\nOverall Time Complexity ~ O(N)\\n\\n```\\n\\n**Space complexity:**\\n```\\nSC : O(N) + O(N) -- For two stacks\\n\\nSC : ~ O(N)\\n\\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {         \\n        \\n        stack<char> open,star;\\n\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\') open.push(i);\\n            if(s[i]==\\'*\\') star.push(i);\\n            else if(s[i]==\\')\\'){\\n                if(!open.empty()) open.pop();\\n                else{\\n                    if(!star.empty()) star.pop();\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // We have processed the closing brackets . Now we will process the opening brackets\\n        // Now if our opening bracket is at index \"x\" \\n        // then we should have the star at an index > x\\n\\n        while(!open.empty() and !star.empty() and open.top()<star.top()){\\n            open.pop();\\n            star.pop();\\n        }\\n\\n        return (open.empty()) ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstr = \"(*(**)\"\\n\\nAfter processing the entire string this is what we are left with.\\n\\nopen = [0]\\nstar = [1,3,4]\\n```\n```\\nActual TC : O(N) + O(min(X,Y))\\n\\n```\n```\\nOverall Time Complexity ~ O(N)\\n\\n```\n```\\nSC : O(N) + O(N) -- For two stacks\\n\\nSC : ~ O(N)\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {         \\n        \\n        stack<char> open,star;\\n\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\') open.push(i);\\n            if(s[i]==\\'*\\') star.push(i);\\n            else if(s[i]==\\')\\'){\\n                if(!open.empty()) open.pop();\\n                else{\\n                    if(!star.empty()) star.pop();\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // We have processed the closing brackets . Now we will process the opening brackets\\n        // Now if our opening bracket is at index \"x\" \\n        // then we should have the star at an index > x\\n\\n        while(!open.empty() and !star.empty() and open.top()<star.top()){\\n            open.pop();\\n            star.pop();\\n        }\\n\\n        return (open.empty()) ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569636,
                "title": "100-faster-dp-without-dp-easy-c-solution",
                "content": "First Way : If you need to learn dp then you follow first way. If you need faster solution follow second way.\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    bool checkValidString(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return find(s, 0, 0);\\n    }\\n    bool find(string s, int pos, int open) {\\n         if(pos == s.length() && !open) {\\n            return true;\\n        }\\n        if(pos>s.length() || open < 0) {\\n            return false;\\n        }\\n        if(dp[pos][open] != -1) {\\n            return dp[pos][open];\\n        }\\n        if(s[pos] == \\'(\\') {\\n            dp[pos][open] = find(s, pos+1, open+1);\\n        } else if(s[pos] == \\')\\') {\\n            dp[pos][open] =  find(s, pos+1, open-1);\\n        } else {\\n            dp[pos][open] = find(s,pos+1, open+1) || find(s, pos+1, open-1) || find(s, pos+1, open);\\n        }\\n        return dp[pos][open];\\n    }\\n    \\n};\\n```\\n\\n\\nSecond Way: 100% faster solution. Runtime 0 ms.\\n\\t\\n```\\nclass Solution {\\npublic:\\n     bool checkValidString(string s) {\\n        int n = s.length(),cnt1=0,cnt2=0;\\n        for(int i=0; i<n; i++) {\\n            if(s[i] == \\'(\\' || s[i] == \\'*\\') cnt1++;\\n            else cnt1--;\\n            if(s[n-i-1]==\\')\\' || s[n-i-1] == \\'*\\') cnt2++;\\n            else cnt2--;\\n            if(cnt1<0||cnt2<0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    bool checkValidString(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return find(s, 0, 0);\\n    }\\n    bool find(string s, int pos, int open) {\\n         if(pos == s.length() && !open) {\\n            return true;\\n        }\\n        if(pos>s.length() || open < 0) {\\n            return false;\\n        }\\n        if(dp[pos][open] != -1) {\\n            return dp[pos][open];\\n        }\\n        if(s[pos] == \\'(\\') {\\n            dp[pos][open] = find(s, pos+1, open+1);\\n        } else if(s[pos] == \\')\\') {\\n            dp[pos][open] =  find(s, pos+1, open-1);\\n        } else {\\n            dp[pos][open] = find(s,pos+1, open+1) || find(s, pos+1, open-1) || find(s, pos+1, open);\\n        }\\n        return dp[pos][open];\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n     bool checkValidString(string s) {\\n        int n = s.length(),cnt1=0,cnt2=0;\\n        for(int i=0; i<n; i++) {\\n            if(s[i] == \\'(\\' || s[i] == \\'*\\') cnt1++;\\n            else cnt1--;\\n            if(s[n-i-1]==\\')\\' || s[n-i-1] == \\'*\\') cnt2++;\\n            else cnt2--;\\n            if(cnt1<0||cnt2<0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328933,
                "title": "very-easy-java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        \\n        // checking from left to right..\\n        int leftBalance = 0;\\n        for(int i=0 ; i<s.length() ; i++){\\n            if(s.charAt(i)==\\'(\\' || s.charAt(i)==\\'*\\'){\\n                leftBalance++;\\n            }\\n            else{\\n                leftBalance--;\\n            }\\n            \\n            if(leftBalance<0){\\n                return false;\\n            }\\n        }\\n        if(leftBalance == 0) return true;\\n        \\n        // checking from right to left..\\n        int rightBalance = 0;\\n        for(int i=s.length()-1 ; i>=0 ; i--){\\n            if(s.charAt(i)==\\')\\' || s.charAt(i)==\\'*\\'){\\n                rightBalance++;\\n            }\\n            else{\\n                rightBalance--;\\n            }\\n            \\n            if(rightBalance<0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        \\n        // checking from left to right..\\n        int leftBalance = 0;\\n        for(int i=0 ; i<s.length() ; i++){\\n            if(s.charAt(i)==\\'(\\' || s.charAt(i)==\\'*\\'){\\n                leftBalance++;\\n            }\\n            else{\\n                leftBalance--;\\n            }\\n            \\n            if(leftBalance<0){\\n                return false;\\n            }\\n        }\\n        if(leftBalance == 0) return true;\\n        \\n        // checking from right to left..\\n        int rightBalance = 0;\\n        for(int i=s.length()-1 ; i>=0 ; i--){\\n            if(s.charAt(i)==\\')\\' || s.charAt(i)==\\'*\\'){\\n                rightBalance++;\\n            }\\n            else{\\n                rightBalance--;\\n            }\\n            \\n            if(rightBalance<0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1236809,
                "title": "runtime-o-ms-using-stack-in-cpp-with-elaborated-comments",
                "content": "```\\n    bool checkValidString(string s) {\\n      /* we are storing position of character rather character itself because \\n        *( is not valid but *) is valid so position has more importance than character */ \\n      \\n\\t  stack<int> o_pert;  //stack to store opening parenthesis   \\n      stack<int> ast;     //stack to store asterisk\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')  o_pert.push(i);\\n            else if(s[i]==\\'*\\') ast.push(i);\\n            else if(s[i]==\\')\\'){\\n                if(!o_pert.empty())  // check ) can be balanced with ( or not\\n                     o_pert.pop();\\n                else if(!ast.empty()) // if o_pert stack is empty try to balance ) with *\\n                     ast.pop();\\n                else return false; // if both stack is empty and we encounter with ) we cannot balance it hence retuen false\\n            }\\n        }\\n        while(!o_pert.empty()){  // this loop is to balance left o_pert with * \\n            if(ast.size()==0) return false;\\n            else if(ast.top()> o_pert.top()){\\n                ast.pop();\\n                 o_pert.pop();\\n            }\\n            else return false;\\n        }\\n        return true;  // if o_pert stack is empty this means both ( and ) are balanced\\n    }\\n\\tupvote if it\\'s easy to understand \\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n    bool checkValidString(string s) {\\n      /* we are storing position of character rather character itself because \\n        *( is not valid but *) is valid so position has more importance than character */ \\n      \\n\\t  stack<int> o_pert;  //stack to store opening parenthesis   \\n      stack<int> ast;     //stack to store asterisk\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')  o_pert.push(i);\\n            else if(s[i]==\\'*\\') ast.push(i);\\n            else if(s[i]==\\')\\'){\\n                if(!o_pert.empty())  // check ) can be balanced with ( or not\\n                     o_pert.pop();\\n                else if(!ast.empty()) // if o_pert stack is empty try to balance ) with *\\n                     ast.pop();\\n                else return false; // if both stack is empty and we encounter with ) we cannot balance it hence retuen false\\n            }\\n        }\\n        while(!o_pert.empty()){  // this loop is to balance left o_pert with * \\n            if(ast.size()==0) return false;\\n            else if(ast.top()> o_pert.top()){\\n                ast.pop();\\n                 o_pert.pop();\\n            }\\n            else return false;\\n        }\\n        return true;  // if o_pert stack is empty this means both ( and ) are balanced\\n    }\\n\\tupvote if it\\'s easy to understand \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1178966,
                "title": "c-easy-to-understand-written-with-comments-to-explain-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        \\n        //simply check at the end of string if the following conditions are fulfilled for open brackets\\n\\n        int minOpen = 0, maxOpen = 0; // count of minimum open brackets and maximum open brackets\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == \\'(\\') { // increasing count for open brackets\\n                minOpen++;\\n                maxOpen++;\\n            } else if(s[i] == \\')\\') { // decreasing count for closed brackets\\n                minOpen--;\\n                maxOpen--;\\n            } else { // case for \"*\" \\n                minOpen--; //considering it as a closing bracket, therefore decreasing the open count\\n                maxOpen++; //considering it as a opening bracket, therefore increasing the open count\\n            }\\n            if(maxOpen < 0) { // opening bracket count decreased to negative, not a valid string because it cant be balanced by \\'*\\' as well.\\n                return false;\\n            }\\n            minOpen = max(minOpen, 0); // keeping the case in mind that \\'*\\' can be ignored too.\\n        }\\n        return minOpen == 0;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        \\n        //simply check at the end of string if the following conditions are fulfilled for open brackets\\n\\n        int minOpen = 0, maxOpen = 0; // count of minimum open brackets and maximum open brackets\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == \\'(\\') { // increasing count for open brackets\\n                minOpen++;\\n                maxOpen++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 784807,
                "title": "java-o-n-easy-to-understand-2-pass-iteration",
                "content": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        // 1st pass : treat all * as left (\\n        int leftWithWild = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c == \\')\\') {\\n                leftWithWild--;\\n                if(leftWithWild < 0) {\\n                    return false;\\n                }\\n            } else {\\n                leftWithWild++;\\n            }\\n        }\\n        \\n        // 2nd pass : treat all * as right )\\n        int rightWithWild = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            char c = s.charAt(i);\\n            if(c == \\'(\\') {\\n                rightWithWild--;\\n                if(rightWithWild < 0) {\\n                    return false;\\n                }\\n            } else {\\n                rightWithWild++;\\n            }\\n        } \\n\\t\\t// treat some of * as \\'(\\' and some of * as \\')\\' \\n        return true; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        // 1st pass : treat all * as left (\\n        int leftWithWild = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c == \\')\\') {\\n                leftWithWild--;\\n                if(leftWithWild < 0) {\\n                    return false;\\n                }\\n            } else {\\n                leftWithWild++;\\n            }\\n        }\\n        \\n        // 2nd pass : treat all * as right )\\n        int rightWithWild = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            char c = s.charAt(i);\\n            if(c == \\'(\\') {\\n                rightWithWild--;\\n                if(rightWithWild < 0) {\\n                    return false;\\n                }\\n            } else {\\n                rightWithWild++;\\n            }\\n        } \\n\\t\\t// treat some of * as \\'(\\' and some of * as \\')\\' \\n        return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638259,
                "title": "java-fast-than-100-and-easy-to-understand-with-3-invalid-cases",
                "content": "consider \\'(\\' as 1, \\')\\' as -1. \\'*\\' can be -1, 0, or 1. \\nthere are three cases which are invalid\\ncase 1:` \")\"`\\ncase 2: `\"((()\"`\\ncase 3: `\"(*)(\"`\\n\\n\\n\\n```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        if (s == null || s.length() == 0) {\\n            return true;\\n        }\\n        int min = 0;\\n        int max = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char curr = s.charAt(i);\\n            if (curr == \\'(\\') {\\n                min++;\\n                max++;\\n            } else if (curr == \\')\\'){\\n                max--;\\n                min--;\\n                \\n            } else {\\n                min--;\\n                max++;\\n            }\\n            if (max < 0) {\\n                return false;  //case 1\\n            }\\n            //eg: (*)(\\n            //    ) cannot be used to pair ( which after it, so it cannot be negetive\\n            min = Math.max(min, 0);  //case 3\\n        }\\n        return min == 0; //case 2\\n    }\\n}\\n//vote me, star me if you like the solution, haha\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        if (s == null || s.length() == 0) {\\n            return true;\\n        }\\n        int min = 0;\\n        int max = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char curr = s.charAt(i);\\n            if (curr == \\'(\\') {\\n                min++;\\n                max++;\\n            } else if (curr == \\')\\'){\\n                max--;\\n                min--;\\n                \\n            } else {\\n                min--;\\n                max++;\\n            }\\n            if (max < 0) {\\n                return false;  //case 1\\n            }\\n            //eg: (*)(\\n            //    ) cannot be used to pair ( which after it, so it cannot be negetive\\n            min = Math.max(min, 0);  //case 3\\n        }\\n        return min == 0; //case 2\\n    }\\n}\\n//vote me, star me if you like the solution, haha\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589921,
                "title": "java-o-n-100-faster-using-2-stacks",
                "content": "Storing the index of asterisk and open braces in the stacks to compare the position of the asterisk and open braces, if we encounter asterisk before the open braces, we return false.\\n```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        Stack<Integer> stack = new Stack();\\n        Stack<Integer> ast = new Stack();\\n        char[] chars = new char[s.length()];\\n        chars= s.toCharArray();\\n        for(int i=0; i< chars.length; i++){\\n            switch(chars[i]){\\n                case \\'(\\':\\n                    stack.push(i);\\n                    break;\\n                case \\'*\\':\\n                    ast.push(i);\\n                    break;\\n                case \\')\\':\\n                    if(!stack.isEmpty()){\\n                        stack.pop();\\n                    }\\n                    else if(!ast.isEmpty()){\\n                        ast.pop();\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n            }\\n        }\\n        while(!stack.isEmpty() && !ast.isEmpty()){\\n            if(stack.pop()>ast.pop()){\\n                return false;\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        Stack<Integer> stack = new Stack();\\n        Stack<Integer> ast = new Stack();\\n        char[] chars = new char[s.length()];\\n        chars= s.toCharArray();\\n        for(int i=0; i< chars.length; i++){\\n            switch(chars[i]){\\n                case \\'(\\':\\n                    stack.push(i);\\n                    break;\\n                case \\'*\\':\\n                    ast.push(i);\\n                    break;\\n                case \\')\\':\\n                    if(!stack.isEmpty()){\\n                        stack.pop();\\n                    }\\n                    else if(!ast.isEmpty()){\\n                        ast.pop();\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n            }\\n        }\\n        while(!stack.isEmpty() && !ast.isEmpty()){\\n            if(stack.pop()>ast.pop()){\\n                return false;\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 587778,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int min = 0; //least number of \\')\\' to balance\\n        int max = 0; //largest number of \\')\\' to balance\\n        for (int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                ++min;\\n                ++max;\\n            } else if (c == \\')\\') {\\n                --min;\\n                --max;\\n                if (max < 0) {\\n                    //more \\')\\' than \\'(\\' + \\'*\\'\\n                    return false;\\n                }\\n            } else if (c == \\'*\\') {\\n                --min;\\n                ++max;\\n            } \\n            \\n            if (min < 0) {\\n                //in previous characters, a \\'*\\' is used to balance \\'(\\' while it should be empty\\n                min = 0;\\n            }\\n        }\\n        return min == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int min = 0; //least number of \\')\\' to balance\\n        int max = 0; //largest number of \\')\\' to balance\\n        for (int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                ++min;\\n                ++max;\\n            } else if (c == \\')\\') {\\n                --min;\\n                --max;\\n                if (max < 0) {\\n                    //more \\')\\' than \\'(\\' + \\'*\\'\\n                    return false;\\n                }\\n            } else if (c == \\'*\\') {\\n                --min;\\n                ++max;\\n            } \\n            \\n            if (min < 0) {\\n                //in previous characters, a \\'*\\' is used to balance \\'(\\' while it should be empty\\n                min = 0;\\n            }\\n        }\\n        return min == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583165,
                "title": "java-one-pass-solution-with-o-n-time-and-o-1-space",
                "content": "Idea:\\nBased on the original idea (attached below), we can simply get rid of stack and use a variable `stack` to replace the stack.  \\n\\n```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int len = s.length(), stack = 0, left = 0;\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                stack += 1;\\n            } else if (c == \\')\\') {\\n                if (stack != 0) {\\n                    stack -= 1;\\n                } else if (left > 0){\\n                    left -= 1;\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                if (stack != 0) {\\n                    stack -= 1;\\n                    left += 1;\\n                } \\n                left += 1;\\n            }\\n        }\\n        if (stack == 0) {\\n            return true;\\n        } \\n        return false;\\n    }\\n}\\n```\\n\\n\\n---\\nOriginal Post: One stack solution with O(n) time and one pass  \\n\\nIdea:  \\n1. Never push `\\')\\'` to stack\\n2. Never push `\\'*\\'` to stack\\n3. The stack only contains `\\'(\\'` if it isn\\'t empty \\n4. Use `left` to count potential `\\'(\\'`  before following `\\')\\'` , to offset following `\\')\\'` \\n(where potential `\\'(\\'` means `\\'*\\'` or `\\'(\\'` popped because of `\\'*\\'`)\\n```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int len = s.length(), left = 0;\\n        Stack <Character> stack = new Stack();\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                stack.push(c);\\n            } else if (c == \\')\\') {\\n                if (!stack.isEmpty()) {\\n                    stack.pop();\\n                } else if (left > 0){\\n                    left -= 1;\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                if (!stack.isEmpty()) {\\n                    stack.pop();\\n                    left += 1;\\n                } \\n                left += 1;\\n            }\\n        }\\n        if (stack.isEmpty()) {\\n            return true;\\n        } \\n        return false;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int len = s.length(), stack = 0, left = 0;\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                stack += 1;\\n            } else if (c == \\')\\') {\\n                if (stack != 0) {\\n                    stack -= 1;\\n                } else if (left > 0){\\n                    left -= 1;\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                if (stack != 0) {\\n                    stack -= 1;\\n                    left += 1;\\n                } \\n                left += 1;\\n            }\\n        }\\n        if (stack == 0) {\\n            return true;\\n        } \\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int len = s.length(), left = 0;\\n        Stack <Character> stack = new Stack();\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                stack.push(c);\\n            } else if (c == \\')\\') {\\n                if (!stack.isEmpty()) {\\n                    stack.pop();\\n                } else if (left > 0){\\n                    left -= 1;\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                if (!stack.isEmpty()) {\\n                    stack.pop();\\n                    left += 1;\\n                } \\n                left += 1;\\n            }\\n        }\\n        if (stack.isEmpty()) {\\n            return true;\\n        } \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582160,
                "title": "simple-solution-easy-to-understand-python-90",
                "content": "False occured only when there is a single ) where there is no ( or * on the left to match with, or when there is a ( with no ) or * on the right. \\nThis is equal to:\\nwhen counting from the left, the number of ) is larger than ( and * . And when counting from the right, the numer of ( is larger than ) and * . \\nIf neither occured, then returen True.\\n\\n```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        le = len(s)\\n        L=R=S=0\\n        LL=RR=SS=0\\n        for i in range(le):\\n            if s[i]==\"(\":\\n                L += 1\\n            if s[i]==\")\":\\n                R += 1\\n            if s[i]==\"*\":\\n                S += 1\\n                \\n            if s[le-1-i]==\"(\":\\n                LL += 1\\n            if s[le-1-i]==\")\":\\n                RR += 1\\n            if s[le-1-i]==\"*\":\\n                SS += 1\\n                \\n            if R > L+S:\\n                return False\\n            if LL>RR+SS:\\n                return False\\n\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        le = len(s)\\n        L=R=S=0\\n        LL=RR=SS=0\\n        for i in range(le):\\n            if s[i]==\"(\":\\n                L += 1\\n            if s[i]==\")\":\\n                R += 1\\n            if s[i]==\"*\":\\n                S += 1\\n                \\n            if s[le-1-i]==\"(\":\\n                LL += 1\\n            if s[le-1-i]==\")\":\\n                RR += 1\\n            if s[le-1-i]==\"*\":\\n                SS += 1\\n                \\n            if R > L+S:\\n                return False\\n            if LL>RR+SS:\\n                return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512137,
                "title": "top-down-dp-with-modified-memorization-easy-to-understand",
                "content": "```\\nclass Solution {\\n    String s;\\n    Boolean[][] dp;\\n    public boolean checkValidString(String s) {\\n        this.s = s;\\n        this.dp = new Boolean[s.length() + 1][s.length() + 1];\\n        return helper(0, 0);\\n    }\\n    public boolean helper(int i, int open) {\\n        if(i == s.length()) {\\n            if(open == 0) return true;\\n            return false;\\n        }\\n        int j = open >= 0 ? open : 0;\\n        if(dp[i][j] != null) return dp[i][j];\\n        if(open < 0) return dp[i][j] = false;\\n        if(s.charAt(i) == \\'(\\') {\\n            return dp[i][j] = helper(i + 1, open + 1);\\n        } else if(s.charAt(i) == \\')\\') {\\n            if(open > 0) {\\n                return dp[i][j] = helper(i + 1, open - 1);\\n            } else {\\n                return dp[i][j] = false;\\n            }\\n        } else {\\n            return dp[i][j] = helper(i + 1, open) || helper(i + 1, open + 1) || helper(i + 1, open - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    String s;\\n    Boolean[][] dp;\\n    public boolean checkValidString(String s) {\\n        this.s = s;\\n        this.dp = new Boolean[s.length() + 1][s.length() + 1];\\n        return helper(0, 0);\\n    }\\n    public boolean helper(int i, int open) {\\n        if(i == s.length()) {\\n            if(open == 0) return true;\\n            return false;\\n        }\\n        int j = open >= 0 ? open : 0;\\n        if(dp[i][j] != null) return dp[i][j];\\n        if(open < 0) return dp[i][j] = false;\\n        if(s.charAt(i) == \\'(\\') {\\n            return dp[i][j] = helper(i + 1, open + 1);\\n        } else if(s.charAt(i) == \\')\\') {\\n            if(open > 0) {\\n                return dp[i][j] = helper(i + 1, open - 1);\\n            } else {\\n                return dp[i][j] = false;\\n            }\\n        } else {\\n            return dp[i][j] = helper(i + 1, open) || helper(i + 1, open + 1) || helper(i + 1, open - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430956,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int leftMin = 0;\\n        int leftMax = 0;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') {\\n                leftMin++;\\n                leftMax++;\\n            } else if (s[i] == \\')\\') {\\n                leftMin--;\\n                leftMax--;\\n            } else {\\n                leftMin--;\\n                leftMax++;\\n            }\\n            if (leftMax < 0) {\\n                return false;\\n            }\\n            if (leftMin < 0) {\\n                leftMin = 0;\\n            }\\n        }\\n        if (leftMin == 0) {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        leftMin, leftMax = 0, 0\\n\\n        for c in s:\\n            if c == \"(\":\\n                leftMin += 1\\n                leftMax += 1\\n            elif c == \")\":\\n                leftMin -= 1\\n                leftMax -= 1\\n            else:\\n                leftMin -= 1\\n                leftMax += 1\\n            \\n            if leftMax < 0:\\n                return False\\n            elif leftMin < 0:\\n                leftMin = 0\\n        \\n        return leftMin == 0\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int low = 0;\\n        int high = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                low++;\\n                high++;\\n            } else if (s.charAt(i) == \\')\\') {\\n                if (low > 0) {\\n                    low--;\\n                }\\n                high--;\\n            } else {\\n                if (low > 0) {\\n                    low--;\\n                }\\n                high++;\\n            }\\n            if (high < 0) {\\n                return false;\\n            }\\n        }\\n        return low == 0;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int leftMin = 0;\\n        int leftMax = 0;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') {\\n                leftMin++;\\n                leftMax++;\\n            } else if (s[i] == \\')\\') {\\n                leftMin--;\\n                leftMax--;\\n            } else {\\n                leftMin--;\\n                leftMax++;\\n            }\\n            if (leftMax < 0) {\\n                return false;\\n            }\\n            if (leftMin < 0) {\\n                leftMin = 0;\\n            }\\n        }\\n        if (leftMin == 0) {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        leftMin, leftMax = 0, 0\\n\\n        for c in s:\\n            if c == \"(\":\\n                leftMin += 1\\n                leftMax += 1\\n            elif c == \")\":\\n                leftMin -= 1\\n                leftMax -= 1\\n            else:\\n                leftMin -= 1\\n                leftMax += 1\\n            \\n            if leftMax < 0:\\n                return False\\n            elif leftMin < 0:\\n                leftMin = 0\\n        \\n        return leftMin == 0\\n```\n```Java []\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int low = 0;\\n        int high = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                low++;\\n                high++;\\n            } else if (s.charAt(i) == \\')\\') {\\n                if (low > 0) {\\n                    low--;\\n                }\\n                high--;\\n            } else {\\n                if (low > 0) {\\n                    low--;\\n                }\\n                high++;\\n            }\\n            if (high < 0) {\\n                return false;\\n            }\\n        }\\n        return low == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678577,
                "title": "python-2-stacks-o-n-simple-16-lines-with-comments-and-explanation",
                "content": "The intuition is just like counting open parens, then subtracting them when you visit a close paren, but now we include asterix. \\n\\nIf we reach the while loop in the end, then we know we have found a matching asterix or left paren for every right paren. \\n\\nThe while loop needs to find an asterix that acts like a right paren for all of the leftover left parens. We use indexes to ensure the asterix comes after the left paren we are currently matching.\\n\\nGood luck with your interviews :)\\n```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        \\n        left, ast = [], []\\n        \\n        for i, char in enumerate(s):\\n            if char == \"(\":\\n                left.append(i)\\n            elif char == \"*\":\\n                ast.append(i)\\n\\t\\t\\t\\t\\n\\t\\t\\t# The next three conditions are when char == \")\"\\n            elif left: # Match left paren with right paren\\n                left.pop()\\n            elif ast: # Match asterix with right paren\\n                ast.pop()\\n            else: # Can\\'t match this right paren with anything\\n                return False\\n        \\n\\t\\t# Found matches for all right parens, now match any leftover left parens\\n\\t\\t# Ensure any asterix used as a right paren comes after the left paren we are matching\\n        while left and ast and left[-1] < ast[-1]:\\n            left.pop()\\n            ast.pop() \\n        \\n\\t\\t# If there\\'s any leftover left parens, then we couldn\\'t match those, so False\\n        return not left\\n```\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n\\t\\t",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        \\n        left, ast = [], []\\n        \\n        for i, char in enumerate(s):\\n            if char == \"(\":\\n                left.append(i)\\n            elif char == \"*\":\\n                ast.append(i)\\n\\t\\t\\t\\t\\n\\t\\t\\t# The next three conditions are when char == \")\"\\n            elif left: # Match left paren with right paren\\n                left.pop()\\n            elif ast: # Match asterix with right paren\\n                ast.pop()\\n            else: # Can\\'t match this right paren with anything\\n                return False\\n        \\n\\t\\t# Found matches for all right parens, now match any leftover left parens\\n\\t\\t# Ensure any asterix used as a right paren comes after the left paren we are matching\\n        while left and ast and left[-1] < ast[-1]:\\n            left.pop()\\n            ast.pop() \\n        \\n\\t\\t# If there\\'s any leftover left parens, then we couldn\\'t match those, so False\\n        return not left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677649,
                "title": "python-with-2-stacks-o-n-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing 2 stacks, 1 for \\'(\\' and 1 for \\'*\\'.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis one is less space optimizied than the greedy soln but more understandable.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        s1 = []\\n        s2 = []\\n        for i, c in enumerate(s):\\n            if c == \\'(\\':\\n                s1.append(i)\\n            elif c == \\'*\\':\\n                s2.append(i)\\n            else:\\n                if s1:\\n                    s1.pop()\\n                elif s2:\\n                    s2.pop()\\n                else:\\n                    return False\\n\\n        while s1 and s2:\\n            if s1[-1] > s2[-1]: # ( is closer to the end than *\\n                return False\\n            s1.pop()\\n            s2.pop()\\n        return s1 == []\\n        # O(n)|O(n)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        s1 = []\\n        s2 = []\\n        for i, c in enumerate(s):\\n            if c == \\'(\\':\\n                s1.append(i)\\n            elif c == \\'*\\':\\n                s2.append(i)\\n            else:\\n                if s1:\\n                    s1.pop()\\n                elif s2:\\n                    s2.pop()\\n                else:\\n                    return False\\n\\n        while s1 and s2:\\n            if s1[-1] > s2[-1]: # ( is closer to the end than *\\n                return False\\n            s1.pop()\\n            s2.pop()\\n        return s1 == []\\n        # O(n)|O(n)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673187,
                "title": "python-two-stack-solution",
                "content": "```\\n    def checkValidString(self, s: str) -> bool:\\n        stack, star = [], []\\n\\t\\t\\n        for i,char in enumerate(s):\\n            if char == \"(\": stack.append(i)\\n            elif char == \")\":\\n                if not stack and not star: return False\\n                elif stack: stack.pop()\\n                elif star: star.pop()\\n            else: star.append(i)\\n    \\n        while stack:\\n            if star and stack[-1] < star[-1]:\\n                stack.pop()\\n                star.pop()\\n            else:\\n                if not star: return False\\n                else: star.pop()\\n\\t\\t\\t\\t\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\n    def checkValidString(self, s: str) -> bool:\\n        stack, star = [], []\\n\\t\\t\\n        for i,char in enumerate(s):\\n            if char == \"(\": stack.append(i)\\n            elif char == \")\":\\n                if not stack and not star: return False\\n                elif stack: stack.pop()\\n                elif star: star.pop()\\n            else: star.append(i)\\n    \\n        while stack:\\n            if star and stack[-1] < star[-1]:\\n                stack.pop()\\n                star.pop()\\n            else:\\n                if not star: return False\\n                else: star.pop()\\n\\t\\t\\t\\t\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2670779,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 :- Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * N * N)***\\n\\n* ***Space Complexity :- O(N * N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[105][105][105];\\n    \\n    bool helper(string& str, int i, int n, int open, int close)\\n    {\\n        // if at any moment we are getting no. of closing brackets > no.of opening brackets, then this can\\'t be valid  \\n        \\n        // eg. [())(()]\\n        \\n        if(close > open)\\n            return false;\\n        \\n        // base case\\n        \\n        if(i == n)\\n        {\\n            if(open == close)\\n                return true;\\n            \\n            else\\n                return false;\\n        }\\n        \\n        // if already calculated\\n        \\n        if(dp[i][open][close] != -1)\\n            return dp[i][open][close];\\n        \\n        if(str[i] == \\'(\\')\\n        {\\n            return dp[i][open][close] = helper(str, i + 1, n, open + 1, close);\\n        }\\n        else if(str[i] == \\')\\')\\n        {\\n            return dp[i][open][close] = helper(str, i + 1, n, open, close + 1);\\n        }\\n        else if(str[i] == \\'*\\')\\n        {\\n            // we have three options here, treat \\'*\\' as [\\'(\\' or \\')\\' or \\'\\']\\n            \\n            bool op1 = helper(str, i + 1, n, open + 1, close);\\n            \\n            bool op2 = helper(str, i + 1, n, open, close + 1);\\n            \\n            bool op3 = helper(str, i + 1, n, open, close);\\n            \\n            return dp[i][open][close] = (op1 | op2 | op3);\\n        }\\n          \\n        return false;\\n    }\\n    \\n    bool checkValidString(string str) {\\n        \\n        int n = str.size();\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(str, 0, n, 0, 0);\\n    }\\n};\\n```\\n\\n* ***Approach 2 :- Optimized Using Stack***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string str) {\\n        \\n        int n = str.size();\\n        \\n        // open_idx will store the index of open parenthesis\\n        \\n        stack<int> open_idx;\\n        \\n        // star_idx will store the index of \\'*\\'\\n        \\n        stack<int> star_idx;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == \\'(\\')\\n            {\\n                open_idx.push(i);\\n            }\\n            else if(str[i] == \\'*\\')\\n            {\\n                star_idx.push(i);\\n            }\\n            else if(str[i] == \\')\\')\\n            {\\n                if(open_idx.empty() == false)\\n                {\\n                    open_idx.pop();\\n                }\\n                else if(star_idx.empty() == false)\\n                {\\n                    star_idx.pop();\\n                }\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        // if the index of star_idx is greater than the index of open_idx then pop out from both\\n        \\n        while(!open_idx.empty() && !star_idx.empty() && open_idx.top() < star_idx.top())\\n        {\\n            open_idx.pop();\\n            \\n            star_idx.pop();\\n        }\\n        \\n        return open_idx.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Stack",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[105][105][105];\\n    \\n    bool helper(string& str, int i, int n, int open, int close)\\n    {\\n        // if at any moment we are getting no. of closing brackets > no.of opening brackets, then this can\\'t be valid  \\n        \\n        // eg. [())(()]\\n        \\n        if(close > open)\\n            return false;\\n        \\n        // base case\\n        \\n        if(i == n)\\n        {\\n            if(open == close)\\n                return true;\\n            \\n            else\\n                return false;\\n        }\\n        \\n        // if already calculated\\n        \\n        if(dp[i][open][close] != -1)\\n            return dp[i][open][close];\\n        \\n        if(str[i] == \\'(\\')\\n        {\\n            return dp[i][open][close] = helper(str, i + 1, n, open + 1, close);\\n        }\\n        else if(str[i] == \\')\\')\\n        {\\n            return dp[i][open][close] = helper(str, i + 1, n, open, close + 1);\\n        }\\n        else if(str[i] == \\'*\\')\\n        {\\n            // we have three options here, treat \\'*\\' as [\\'(\\' or \\')\\' or \\'\\']\\n            \\n            bool op1 = helper(str, i + 1, n, open + 1, close);\\n            \\n            bool op2 = helper(str, i + 1, n, open, close + 1);\\n            \\n            bool op3 = helper(str, i + 1, n, open, close);\\n            \\n            return dp[i][open][close] = (op1 | op2 | op3);\\n        }\\n          \\n        return false;\\n    }\\n    \\n    bool checkValidString(string str) {\\n        \\n        int n = str.size();\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(str, 0, n, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string str) {\\n        \\n        int n = str.size();\\n        \\n        // open_idx will store the index of open parenthesis\\n        \\n        stack<int> open_idx;\\n        \\n        // star_idx will store the index of \\'*\\'\\n        \\n        stack<int> star_idx;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == \\'(\\')\\n            {\\n                open_idx.push(i);\\n            }\\n            else if(str[i] == \\'*\\')\\n            {\\n                star_idx.push(i);\\n            }\\n            else if(str[i] == \\')\\')\\n            {\\n                if(open_idx.empty() == false)\\n                {\\n                    open_idx.pop();\\n                }\\n                else if(star_idx.empty() == false)\\n                {\\n                    star_idx.pop();\\n                }\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        // if the index of star_idx is greater than the index of open_idx then pop out from both\\n        \\n        while(!open_idx.empty() && !star_idx.empty() && open_idx.top() < star_idx.top())\\n        {\\n            open_idx.pop();\\n            \\n            star_idx.pop();\\n        }\\n        \\n        return open_idx.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592425,
                "title": "c-using-dp-100-faster-than-all",
                "content": "```\\nclass Solution {\\npublic:\\n     bool checkValidString(string s) {\\n        int n = s.length(),cnt1=0,cnt2=0;\\n        for(int i=0; i<n; i++) {\\n            if(s[i] == \\'(\\' || s[i] == \\'*\\') cnt1++;\\n            else cnt1--;\\n            if(s[n-i-1]==\\')\\' || s[n-i-1] == \\'*\\') cnt2++;\\n            else cnt2--;\\n            if(cnt1<0||cnt2<0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n     bool checkValidString(string s) {\\n        int n = s.length(),cnt1=0,cnt2=0;\\n        for(int i=0; i<n; i++) {\\n            if(s[i] == \\'(\\' || s[i] == \\'*\\') cnt1++;\\n            else cnt1--;\\n            if(s[n-i-1]==\\')\\' || s[n-i-1] == \\'*\\') cnt2++;\\n            else cnt2--;\\n            if(cnt1<0||cnt2<0) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2587351,
                "title": "valid-parenthesis-string-using-greedy-c-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        \\n        //stack of int as we are going to store indices of parenthesis and star \\n        //as we have to check wheather string can be converted to valid string or not\\n        stack<int> open;\\n        stack<int> star;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                open.push(i);\\n            }\\n            else if(s[i] == \\'*\\')\\n            {\\n                star.push(i);\\n            }\\n            else //handle closing parenthesis\\n            {\\n                //if stack is empty and \\')\\' comes means we are unable to balence the string\\n                //in that case we need to return false\\n                //but open stack is not empty, we can pop out to balance\\n                //open empty and star is not empty, we can use it to balance\\n                \\n                if(!open.empty())\\n                {\\n                    //open is not empty, remove corresponding open parenthesis\\n                    open.pop();\\n                }\\n                else if(!star.empty())\\n                {\\n                    //open empty star not empty, use star as a open parenthesis to balance\\n                    star.pop();\\n                }\\n                else\\n                {\\n                    //if both empty, there is no other way to balance it\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        \\n        //now process those leftover brackets if any \\n        //once we have balanced closing  brackets, we need to handle opening brackets\\n        \\n        //till the opening parenthesis stack is not empty, as we need to balance it\\n        //if star stack isn\\'t empty, it isn\\'t a problem\\n        while(!open.empty())\\n        {\\n            //if open isn\\'t empty but star is empty, how is we going to balance?\\n            //with help of star we are suppossed to balance it\\n            if(star.empty())\\n            {\\n                return false;\\n            }\\n            else if(open.top() < star.top())\\n            {\\n                //both stack will have elements in increasing order\\n                //if we have \\'*\\' after \\'(\\', we can make satr to \\')\\', in order to balance \\'()\\'\\n                //but if we have \\'*\\' first and then \\'(\\', it is of no use \\n                //as we cant make \\'*\\' to \\')\\'  as its of no use we cant balance\\n                //and we leave \\'*\\' as empty, there would be leftover of \\'(\\' which makes string imbalance\\n                //so star stack top should greater than open stack top, its mendatory\\n                //thats the reason we have used indices in place of actual characters\\n                open.pop();\\n                star.pop();\\n            }\\n            else //open stack top is greater than star stack top, unable to balance\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        \\n        //we reach here if everything is okay and just star stack is non empty or maybe its empty too\\n        return true;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        \\n        //stack of int as we are going to store indices of parenthesis and star \\n        //as we have to check wheather string can be converted to valid string or not\\n        stack<int> open;\\n        stack<int> star;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                open.push(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2462168,
                "title": "c-dp-memoization-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>>dp;\\n    bool checkValidString(string s) {\\n        \\n        int n=s.length();\\n        dp.resize(n,vector<vector<int>>(n,vector<int>(n,-1)));\\n        int open=0;\\n        int close=0;\\n        int idx=0;\\n        return fun(s,idx,open,close);\\n    }\\n    bool fun(string &s,int idx,int open,int close)\\n    {\\n         if(idx>=s.length())\\n         {\\n             if(open==close)\\n                 return true;\\n             else\\n                 return false;\\n         }\\n         if(close>open)\\n             return false;\\n         if(dp[idx][open][close]!=-1)\\n             return dp[idx][open][close];\\n        \\n         if(s[idx]==\\'(\\')\\n         {\\n              return dp[idx][open][close]=fun(s,idx+1,open+1,close);\\n         }\\n         if(s[idx]==\\')\\')\\n         {\\n              return dp[idx][open][close]=fun(s,idx+1,open,close+1);\\n         }\\n         else if(s[idx]==\\'*\\')\\n         {\\n             bool a =  fun(s,idx+1,open,close);   //just empty \\n             bool b =  fun(s,idx+1,open+1,close);\\n             bool c =  fun(s,idx+1,open,close+1);\\n             \\n             return dp[idx][open][close]=a or b or c;\\n         }\\n         return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>>dp;\\n    bool checkValidString(string s) {\\n        \\n        int n=s.length();\\n        dp.resize(n,vector<vector<int>>(n,vector<int>(n,-1)));\\n        int open=0;\\n        int close=0;\\n        int idx=0;\\n        return fun(s,idx,open,close);\\n    }\\n    bool fun(string &s,int idx,int open,int close)\\n    {\\n         if(idx>=s.length())\\n         {\\n             if(open==close)\\n                 return true;\\n             else\\n                 return false;\\n         }\\n         if(close>open)\\n             return false;\\n         if(dp[idx][open][close]!=-1)\\n             return dp[idx][open][close];\\n        \\n         if(s[idx]==\\'(\\')\\n         {\\n              return dp[idx][open][close]=fun(s,idx+1,open+1,close);\\n         }\\n         if(s[idx]==\\')\\')\\n         {\\n              return dp[idx][open][close]=fun(s,idx+1,open,close+1);\\n         }\\n         else if(s[idx]==\\'*\\')\\n         {\\n             bool a =  fun(s,idx+1,open,close);   //just empty \\n             bool b =  fun(s,idx+1,open+1,close);\\n             bool c =  fun(s,idx+1,open,close+1);\\n             \\n             return dp[idx][open][close]=a or b or c;\\n         }\\n         return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424800,
                "title": "0ms-c-intuition-explained",
                "content": "``` \\nbool checkValidString(string s){\\n    stack<int> asterisk;  // this only contsins the indexes of *\\n    stack<int> validPar;  // this only contains the indexes of ( brackets\\n\\n    for(int i=0; i<s.length(); i++){\\n        if(s[i] == \\'(\\'){\\n            validPar.push(i);\\n        }\\n        else if(s[i] == \\'*\\'){\\n            asterisk.push(i);\\n        }\\n        else if(s[i] == \\')\\'){\\n            if(!validPar.empty()){\\n                validPar.pop();\\n            }\\n            else if(!asterisk.empty()){\\n                asterisk.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n    }\\n\\n    // we have extra ( brakcets which we have to balance by converting them to ).\\n    // to be able to convert, then index of astrix must be more than index of (\\n    while(!validPar.empty() && !asterisk.empty()){\\n        if(validPar.top() > asterisk.top()){\\n            return false;\\n        }\\n\\n        validPar.pop();\\n        asterisk.pop();\\n    }\\n\\n    // after removing all the (, there should be no more ( brackets remaining\\n    return validPar.empty();\\n}\\n\\n \\n\\n\\n```\\n\\nUpvote if it helped! :)",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "``` \\nbool checkValidString(string s){\\n    stack<int> asterisk;  // this only contsins the indexes of *\\n    stack<int> validPar;  // this only contains the indexes of ( brackets\\n\\n    for(int i=0; i<s.length(); i++){\\n        if(s[i] == \\'(\\'){\\n            validPar.push(i);\\n        }\\n        else if(s[i] == \\'*\\'){\\n            asterisk.push(i);\\n        }\\n        else if(s[i] == \\')\\'){\\n            if(!validPar.empty()){\\n                validPar.pop();\\n            }\\n            else if(!asterisk.empty()){\\n                asterisk.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n    }\\n\\n    // we have extra ( brakcets which we have to balance by converting them to ).\\n    // to be able to convert, then index of astrix must be more than index of (\\n    while(!validPar.empty() && !asterisk.empty()){\\n        if(validPar.top() > asterisk.top()){\\n            return false;\\n        }\\n\\n        validPar.pop();\\n        asterisk.pop();\\n    }\\n\\n    // after removing all the (, there should be no more ( brackets remaining\\n    return validPar.empty();\\n}\\n\\n \\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2421140,
                "title": "simple-java-solution-with-explanation-2-pass-on-input",
                "content": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int countStar = 0;\\n\\t\\tint countOpen = 0;\\n        int countClose = 0;\\n        char[] arr = s.toCharArray();\\n        \\n        // check left to right if string is invalid\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == \\'(\\') {\\n                countOpen++;\\n            } else if (arr[i] == \\')\\') {\\n                if (countOpen > 0) {\\n                    countOpen--; // an existing open bracket can complement this closing bracket\\n                } else if (countStar > 0) {\\n                    countStar--; // an existing star can complement this closing bracket\\n                } else {\\n                    return false;\\n                }\\n            } else if (arr[i] == \\'*\\') {\\n                countStar++;\\n            }\\n        }\\n        \\n        countStar = 0;\\n\\t\\t\\n        // check right to left if string is invalid\\n        for (int i = arr.length-1; i >= 0; i--) {\\n            if (arr[i] == \\')\\') {\\n                countClose++;\\n            } else if (arr[i] == \\'(\\') {\\n                if (countClose > 0) {\\n                    countClose--; // an existing closing bracket can complement this opening bracket\\n                } else if (countStar > 0) {\\n                    countStar--; // an existing star can complement this opening bracket\\n                } else {\\n                    return false;\\n                }\\n            } else if (arr[i] == \\'*\\') {\\n                countStar++;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int countStar = 0;\\n\\t\\tint countOpen = 0;\\n        int countClose = 0;\\n        char[] arr = s.toCharArray();\\n        \\n        // check left to right if string is invalid\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == \\'(\\') {\\n                countOpen++;\\n            } else if (arr[i] == \\')\\') {\\n                if (countOpen > 0) {\\n                    countOpen--; // an existing open bracket can complement this closing bracket\\n                } else if (countStar > 0) {\\n                    countStar--; // an existing star can complement this closing bracket\\n                } else {\\n                    return false;\\n                }\\n            } else if (arr[i] == \\'*\\') {\\n                countStar++;\\n            }\\n        }\\n        \\n        countStar = 0;\\n\\t\\t\\n        // check right to left if string is invalid\\n        for (int i = arr.length-1; i >= 0; i--) {\\n            if (arr[i] == \\')\\') {\\n                countClose++;\\n            } else if (arr[i] == \\'(\\') {\\n                if (countClose > 0) {\\n                    countClose--; // an existing closing bracket can complement this opening bracket\\n                } else if (countStar > 0) {\\n                    countStar--; // an existing star can complement this opening bracket\\n                } else {\\n                    return false;\\n                }\\n            } else if (arr[i] == \\'*\\') {\\n                countStar++;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184779,
                "title": "simple-stack-solution-python-o-n-and-o-n",
                "content": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        count = []\\n        stack = []\\n\\t\\t# we only add in (, and if we meet a ), we pop one (\\n\\t\\t# if we meet a *, we add the index into count. We first assume all * is empty string.\\n        for i, st in enumerate(s):\\n            if st == \"(\":\\n                stack.append(i)\\n            elif st == \")\":\\n                if not stack and not count:\\n                    return False\\n                elif not stack:\\n                    count.pop()\\n                else:\\n                    stack.pop()\\n            else:\\n                count.append(i)\\n\\t\\t\\n\\t\\t# we finally ensure if stack has extra (, the * in count appear after (. \\n        while stack and count:\\n            if stack.pop() > count.pop():\\n                return False\\n        return True if not stack else False\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        count = []\\n        stack = []\\n\\t\\t# we only add in (, and if we meet a ), we pop one (\\n\\t\\t# if we meet a *, we add the index into count. We first assume all * is empty string.\\n        for i, st in enumerate(s):\\n            if st == \"(\":\\n                stack.append(i)\\n            elif st == \")\":\\n                if not stack and not count:\\n                    return False\\n                elif not stack:\\n                    count.pop()\\n                else:\\n                    stack.pop()\\n            else:\\n                count.append(i)\\n\\t\\t\\n\\t\\t# we finally ensure if stack has extra (, the * in count appear after (. \\n        while stack and count:\\n            if stack.pop() > count.pop():\\n                return False\\n        return True if not stack else False\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069102,
                "title": "easy-c-solution-give-it-a-look",
                "content": "Here we need to use two stacks. it will be helpful if we use stack of indexes over chars. Step by Step solution is here. I think it will be helpful.\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n     stack<int>open,star;\\n     for(int i=0;i<s.length();i++){\\n         if(s[i]==\\'(\\') open.push(i);\\n         if(s[i]==\\'*\\') star.push(i);\\n         if(s[i]==\\')\\'){\\n             if(!open.empty()){\\n                 open.pop();\\n             }\\n             else{\\n                 if(!star.empty()){\\n                     star.pop();\\n                 }\\n                 else{\\n                     return false;\\n                 }\\n             }\\n         }\\n     }\\n        while(!open.empty()){\\n            int opnidx=open.top();\\n            open.pop();\\n            if(star.empty()) return false;\\n            int stridx=star.top();\\n            star.pop();\\n            if(stridx<opnidx) return false;\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n     stack<int>open,star;\\n     for(int i=0;i<s.length();i++){\\n         if(s[i]==\\'(\\') open.push(i);\\n         if(s[i]==\\'*\\') star.push(i);\\n         if(s[i]==\\')\\'){\\n             if(!open.empty()){\\n                 open.pop();\\n             }\\n             else{\\n                 if(!star.empty()){\\n                     star.pop();\\n                 }\\n                 else{\\n                     return false;\\n                 }\\n             }\\n         }\\n     }\\n        while(!open.empty()){\\n            int opnidx=open.top();\\n            open.pop();\\n            if(star.empty()) return false;\\n            int stridx=star.top();\\n            star.pop();\\n            if(stridx<opnidx) return false;\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786954,
                "title": "understandable-approach-using-stack-code-explanation",
                "content": "If you have solved the 2Sum or Parenthesis question then it would be easy for you to understand. And, if not then I\\'ll explain you.\\nIf you read the question carefully, that is talking about matching the parenthesis, and when we listen about something like that we directly think about adding and removing elements to match and that time our first approach in our mind would be using the stack data structure. \\n\\n**Intuition:**\\nHere I am using the two stack one for open parenthesis and second for star(because according to the question we can use it as either open parenthesis, close parenthesis, or as an empty string), we are using another stack for Asterix is because if we out of left parenthesis and we still have right parenthesis then we can use Asterix as a left parenthesis to make it valid.\\n\\n**Steps to approach:**\\n**1**. Create  two stacks:\\n        - open_stack(i.e for open parenthesis)\\n        - start_stack(i.e. for Asterix symbol)\\n**2**.  transverse character-by-character to the input string\\n**3**.  then all the condition statements will be clear if you see the code.\\n**4**.  After traversing through till the last, I have used the while loop, if any open parenthesis is left out and also we have left with Asterix symbol then we can validate the parenthesis by making supposing Asterix as a close parenthesis.\\n\\n**Note: I have the added index number into the stack because as the condition says open parenthesis comes before the close parenthesis. So, when we use the while loop to check if we left out with open parenthesis and Asterix or not and if yes, then we check if open parenthesis comes before Asterix then we make it validate otherwise it is invalid(i.e. False).**\\n\\n\\n```\\n    def checkValidString(self, s: str) -> bool:\\n        open_stack = []\\n        star_stack = []\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                open_stack.append(i)\\n            elif s[i] == \"*\":\\n                star_stack.append(i)\\n            else:\\n                if len(open_stack) != 0:\\n                    open_stack.pop()\\n                elif len(star_stack) != 0:\\n                    star_stack.pop()\\n                else:\\n                    return False\\n        while len(open_stack) != 0:\\n            if len(star_stack) == 0:\\n                return False\\n            elif open_stack[-1] < star_stack[-1]:\\n                open_stack.pop()\\n                star_stack.pop()\\n            else:\\n                return False\\n        return True\\n```\\n\\nThere could be another approach better than this. But, this is what came to my mind at first so think to share it with everyone.\\nFeel free to add up something.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def checkValidString(self, s: str) -> bool:\\n        open_stack = []\\n        star_stack = []\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                open_stack.append(i)\\n            elif s[i] == \"*\":\\n                star_stack.append(i)\\n            else:\\n                if len(open_stack) != 0:\\n                    open_stack.pop()\\n                elif len(star_stack) != 0:\\n                    star_stack.pop()\\n                else:\\n                    return False\\n        while len(open_stack) != 0:\\n            if len(star_stack) == 0:\\n                return False\\n            elif open_stack[-1] < star_stack[-1]:\\n                open_stack.pop()\\n                star_stack.pop()\\n            else:\\n                return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1612871,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int cmax = 0, cmin = 0;\\n        for(Character c : s.toCharArray()){\\n            if(c == \\'(\\'){\\n                cmax++;\\n                cmin++;\\n            }else if(c == \\')\\'){\\n                cmax--;\\n                cmin--;\\n            }else if(c == \\'*\\'){\\n//         There are two chances \\'(\\' or \\')\\' hence we are using two counts\\n                cmax++;\\n                cmin--;\\n            }\\n            if(cmax < 0) return false;\\n            cmin = Math.max(cmin, 0);\\n        }\\n        return cmin == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int cmax = 0, cmin = 0;\\n        for(Character c : s.toCharArray()){\\n            if(c == \\'(\\'){\\n                cmax++;\\n                cmin++;\\n            }else if(c == \\')\\'){\\n                cmax--;\\n                cmin--;\\n            }else if(c == \\'*\\'){\\n//         There are two chances \\'(\\' or \\')\\' hence we are using two counts\\n                cmax++;\\n                cmin--;\\n            }\\n            if(cmax < 0) return false;\\n            cmin = Math.max(cmin, 0);\\n        }\\n        return cmin == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285263,
                "title": "c-o-1-space-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) \\n    {\\n        int left=0,star=0,right=0,i,n=s.size();\\n        for(i=0;i<n;i++){\\n            if(s[i]==\\'(\\') left++;\\n            else if(s[i]==\\')\\') right++;\\n            else if(s[i]==\\'*\\') star++;\\n            if(left+star<right) return 0;\\n        }\\n        left=0; star=0; right=0;\\n        for(i=n-1;i>=0;i--){\\n            if(s[i]==\\'(\\') left++;\\n            else if(s[i]==\\')\\') right++;\\n            else if(s[i]==\\'*\\') star++;\\n            if(right+star<left) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) \\n    {\\n        int left=0,star=0,right=0,i,n=s.size();\\n        for(i=0;i<n;i++){\\n            if(s[i]==\\'(\\') left++;\\n            else if(s[i]==\\')\\') right++;\\n            else if(s[i]==\\'*\\') star++;\\n            if(left+star<right) return 0;\\n        }\\n        left=0; star=0; right=0;\\n        for(i=n-1;i>=0;i--){\\n            if(s[i]==\\'(\\') left++;\\n            else if(s[i]==\\')\\') right++;\\n            else if(s[i]==\\'*\\') star++;\\n            if(right+star<left) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231878,
                "title": "easily-understandable-code-in-c-faster-than-100-of-all-submissions",
                "content": "There are two cases to keep in mind:-\\n(i) when we are moving from left to right -> in this case right bracket(\" ) \") should not be greater than left bracket(\" ( \");\\n(ii)when we are moving from right to left -> in this case left bracket(\" ( \") should not be greater than right bracket(\" ) \");\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int n = s.size();\\n        int stars = 0;\\n        int leftpar = 0, rightpar = 0;\\n        \\n        bool possible = true;\\n        for(int i = 0; i < n; ++i){\\n            if(s[i] == \\'(\\'){\\n                ++leftpar;\\n            } else if(s[i] == \\')\\')\\n                ++rightpar;\\n            else ++stars;\\n            \\n            if(rightpar > leftpar){\\n                int diff = rightpar - leftpar;\\n                if(diff > stars){\\n                    possible = false;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        leftpar = 0, rightpar = 0, stars = 0;\\n        for(int i = n - 1; i >= 0; --i){\\n            if(s[i] == \\'(\\')\\n                ++leftpar;\\n            else if(s[i] == \\')\\')\\n                ++rightpar;\\n            else ++stars;\\n            \\n            if(leftpar > rightpar){\\n                int diff = leftpar - rightpar;\\n                if(diff > stars){\\n                    possible = false;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return possible;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int n = s.size();\\n        int stars = 0;\\n        int leftpar = 0, rightpar = 0;\\n        \\n        bool possible = true;\\n        for(int i = 0; i < n; ++i){\\n            if(s[i] == \\'(\\'){\\n                ++leftpar;\\n            } else if(s[i] == \\')\\')\\n                ++rightpar;\\n            else ++stars;\\n            \\n            if(rightpar > leftpar){\\n                int diff = rightpar - leftpar;\\n                if(diff > stars){\\n                    possible = false;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        leftpar = 0, rightpar = 0, stars = 0;\\n        for(int i = n - 1; i >= 0; --i){\\n            if(s[i] == \\'(\\')\\n                ++leftpar;\\n            else if(s[i] == \\')\\')\\n                ++rightpar;\\n            else ++stars;\\n            \\n            if(leftpar > rightpar){\\n                int diff = leftpar - rightpar;\\n                if(diff > stars){\\n                    possible = false;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return possible;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999586,
                "title": "c-solution-faster-than-100-c-users",
                "content": "```\\nclass Solution {\\npublic:\\nbool checkValidString(string s) {\\n          int leftbalance = 0;\\n          for(int i = 0;i<s.size();i++)\\n          {\\n          \\tif(s[i] == \\'(\\' || s[i] == \\'*\\')\\n          \\t\\tleftbalance++;\\n          \\telse\\n          \\t\\tleftbalance--;\\n                 \\n                if(leftbalance < 0 ) return false;\\n          }\\n          if(leftbalance == 0) return true;\\n          int rightbalance = 0;\\n          for(int i = s.size() - 1;i>=0;i--)\\n          {\\n          \\tif(s[i] == \\')\\' || s[i] == \\'*\\')\\n          \\t\\trightbalance++;\\n          \\telse\\n          \\t\\trightbalance--;\\n                  \\n                if(rightbalance < 0 )return false;\\n          }\\n        \\nreturn true;\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nbool checkValidString(string s) {\\n          int leftbalance = 0;\\n          for(int i = 0;i<s.size();i++)\\n          {\\n          \\tif(s[i] == \\'(\\' || s[i] == \\'*\\')\\n          \\t\\tleftbalance++;\\n          \\telse\\n          \\t\\tleftbalance--;\\n                 \\n                if(leftbalance < 0 ) return false;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 584523,
                "title": "java-o-n-3-dp-top-down-solution",
                "content": "This solution is translated from HuaHua\\'s C++ version solution.\\nJust as HuaHua said in the video, this is a very good question for practicing DP. And thanks for this question and HuaHua\\'s instruction that let me understand what is Top-down and Bottom-up. So just post this thread for marking this solution.\\n\\n```\\nclass Solution {\\n    int [][] dp; \\n    public boolean checkValidString(String s) {\\n        int len =s.length();\\n        dp = new int [len][len];\\n        for(int [] d: dp){\\n            Arrays.fill(d,-1);\\n        }\\n        return isValid(s,0,len-1)==1;\\n    }\\n    \\n    private int isValid(String s, int start, int end){\\n        if(start>end) return 1;\\n        if(dp[start][end]!=-1) return dp[start][end];\\n       \\n        if(start==end)\\n            return dp[start][end]=s.charAt(start)==\\'*\\'?1:0;\\n        if((s.charAt(start)==\\'(\\'||s.charAt(start)==\\'*\\')&&(s.charAt(end)==\\')\\'||s.charAt(end)==\\'*\\')&&(isValid(s,start+1,end-1)==1)){\\n               dp[start][end]=1;\\n               return 1;\\n        }\\n        \\n        for(int i=start;i<end;i++){\\n            if(isValid(s,start,i)==1&&isValid(s,i+1,end)==1){\\n                dp[start][end]=1;\\n                return 1;\\n            }     \\n        }\\n        dp[start][end]=0;\\n        return 0;\\n         \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int [][] dp; \\n    public boolean checkValidString(String s) {\\n        int len =s.length();\\n        dp = new int [len][len];\\n        for(int [] d: dp){\\n            Arrays.fill(d,-1);\\n        }\\n        return isValid(s,0,len-1)==1;\\n    }\\n    \\n    private int isValid(String s, int start, int end){\\n        if(start>end) return 1;\\n        if(dp[start][end]!=-1) return dp[start][end];\\n       \\n        if(start==end)\\n            return dp[start][end]=s.charAt(start)==\\'*\\'?1:0;\\n        if((s.charAt(start)==\\'(\\'||s.charAt(start)==\\'*\\')&&(s.charAt(end)==\\')\\'||s.charAt(end)==\\'*\\')&&(isValid(s,start+1,end-1)==1)){\\n               dp[start][end]=1;\\n               return 1;\\n        }\\n        \\n        for(int i=start;i<end;i++){\\n            if(isValid(s,start,i)==1&&isValid(s,i+1,end)==1){\\n                dp[start][end]=1;\\n                return 1;\\n            }     \\n        }\\n        dp[start][end]=0;\\n        return 0;\\n         \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583289,
                "title": "simple-java-solution-0ms-100-faster",
                "content": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int bal = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\'*\\') {\\n                bal++;\\n            }\\n            else if (--bal< 0) {\\n                return false;\\n            }\\n        }\\n        if (bal == 0) {\\n            return true;\\n        }\\n        bal = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            if (s.charAt(i) == \\')\\' || s.charAt(i) == \\'*\\') {\\n                bal++;\\n            }\\n            else if (--bal< 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int bal = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\'*\\') {\\n                bal++;\\n            }\\n            else if (--bal< 0) {\\n                return false;\\n            }\\n        }\\n        if (bal == 0) {\\n            return true;\\n        }\\n        bal = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            if (s.charAt(i) == \\')\\' || s.charAt(i) == \\'*\\') {\\n                bal++;\\n            }\\n            else if (--bal< 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582511,
                "title": "two-stacks-python-0-n",
                "content": "using two stacks to record the index of `(` and `*`\\n1. we push the index to s1 if  `(` occurent and  push the index to s2 if `*` occurent\\n2. if `)` occurent, we try to pop the last `(` first, if s1 is empty which mean there are no `(` anymore. we try to use  `*`  replace `(`. we return False when both of s1 and s2 are empty\\n3. After go throught the string, we need to analyse the position of rest of `(`, we need one `*` with larger index for each `(`.\\n``` python\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        if not s:\\n            return True\\n        s1 = []\\n        s2 = []\\n        for i in range(len(s)):\\n            if s[i] == \"(\":\\n                s1.append(i)\\n            elif s[i] == \"*\":\\n                s2.append(i)\\n            elif s[i] == \")\":\\n                if s1:\\n                    s1.pop(-1)\\n                else:\\n                    if s2:\\n                        s2.pop(-1)\\n                    else:\\n                        return False\\n        while s1:\\n            if not s2:\\n                return False\\n            else:\\n                if s1.pop(-1) >s2.pop(-1):\\n                    return False\\n        return True\\n        \\n```",
                "solutionTags": [],
                "code": "``` python\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        if not s:\\n            return True\\n        s1 = []\\n        s2 = []\\n        for i in range(len(s)):\\n            if s[i] == \"(\":\\n                s1.append(i)\\n            elif s[i] == \"*\":\\n                s2.append(i)\\n            elif s[i] == \")\":\\n                if s1:\\n                    s1.pop(-1)\\n                else:\\n                    if s2:\\n                        s2.pop(-1)\\n                    else:\\n                        return False\\n        while s1:\\n            if not s2:\\n                return False\\n            else:\\n                if s1.pop(-1) >s2.pop(-1):\\n                    return False\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 582263,
                "title": "mirror-method-non-dp-o-n-time-o-1-space",
                "content": "This solution is based on a key observation: **if a parenthesis string is valid, then it\\'s still valid when \"mirrored\"** (read backwards, and replace `(` by `)` and `)` by `(`).\\n\\nFirst write a simple & intuitive algorithm to handle `)`. It\\'s not yet possible to rule out cases like `()*((*`.\\n\\nThen \"mirror\" the string. The example is now `*))*()`, and it can be ruled out by the same algorithm as the first pass.\\n\\nSince we\\'ve handled imbalances caused by both `(` and `)`, this algorithm should have eliminated all invalid strings.\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        // a = asterisk, d = depth\\n        int a = 0, d = 0, n = s.length();\\n        \\n        // First Pass\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'(\\') d++;\\n            else if (s[i] == \\'*\\') a++;\\n            else {\\n                if (d > 0) d--;\\n                else if (a > 0) a--; // Turn one of *\\'s into (\\n                else return false;\\n            }\\n        }\\n        if (d==0) return true;\\n        if (a<d) return false;\\n        \\n        // Second Pass\\n        d=a=0;\\n        for (int i = n-1; i >= 0; --i) {\\n            if (s[i] == \\')\\') d++;  // DIFFERENT\\n            else if (s[i] == \\'*\\') a++;\\n            else {\\n                if (d > 0) d--;\\n                else if (a > 0) a--; // Turn one of *\\'s into )\\n                else return false;\\n            }\\n        }\\n        if (d==0) return true;\\n        if (a<d) return false;\\n        return true;\\n    }\\n};\\n```\\n\\nFinally, the two loops can be merged, making it a single-pass algorithm.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        // a = asterisk, d = depth\\n        int a = 0, d = 0, n = s.length();\\n        \\n        // First Pass\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'(\\') d++;\\n            else if (s[i] == \\'*\\') a++;\\n            else {\\n                if (d > 0) d--;\\n                else if (a > 0) a--; // Turn one of *\\'s into (\\n                else return false;\\n            }\\n        }\\n        if (d==0) return true;\\n        if (a<d) return false;\\n        \\n        // Second Pass\\n        d=a=0;\\n        for (int i = n-1; i >= 0; --i) {\\n            if (s[i] == \\')\\') d++;  // DIFFERENT\\n            else if (s[i] == \\'*\\') a++;\\n            else {\\n                if (d > 0) d--;\\n                else if (a > 0) a--; // Turn one of *\\'s into )\\n                else return false;\\n            }\\n        }\\n        if (d==0) return true;\\n        if (a<d) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464943,
                "title": "java-stack-explanation",
                "content": "```java\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        // Stack\\n        //1. ( --> Push any previous starts back to stack; push ( into stack\\n        //2. * --> push into stack\\n        //3. ) --> pop stack, if * then record, if ( then \\n        //4. When string finished, use all the *\\n        //5. If stack stil has (, then return false\\n        if(s == null || s.length() == 0) return true;\\n        \\n        Stack<Character> stack = new Stack<>();\\n        int starCount = 0;\\n        char[] arr = s.toCharArray();\\n        for(int i = 0; i < arr.length; i++) {\\n            if(arr[i] == \\'*\\') stack.push(arr[i]);\\n            else if(arr[i] == \\'(\\') {\\n                // push the stars back to the stack, to maintain original order\\n                for(int j = 0; j < starCount; j++) {\\n                    stack.push(\\'*\\');\\n                }\\n                starCount = 0; // reset the count to zero\\n                stack.push(arr[i]);\\n            } else if(arr[i] == \\')\\') {\\n                // If the stack is empty, then use up all the saved stars\\n                if(stack.isEmpty()) {\\n                    if(starCount > 0) {\\n                        starCount --;\\n                        continue;\\n                    } else \\n                        return false;\\n                }\\n                // temporarily save the stars\\n                while(!stack.isEmpty() && stack.peek() == \\'*\\') {\\n                    stack.pop(); // pop out the *\\n                    starCount ++;\\n                }\\n                if(!stack.isEmpty())\\n                    stack.pop(); //pop the (\\n                else \\n                    i--; // if stack is empty, don\\'t move the cursor to the next position\\n            }\\n        }\\n        \\n        // Check if the saved stars can pair all the remained (\\n        while(!stack.isEmpty()) {\\n            if(stack.peek() == \\'*\\') {\\n                starCount ++;\\n                stack.pop();\\n            } else {\\n                if(starCount > 0) {\\n                    starCount --;\\n                    stack.pop();\\n                } else {\\n                    return stack.isEmpty();\\n                }\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        // Stack\\n        //1. ( --> Push any previous starts back to stack; push ( into stack\\n        //2. * --> push into stack\\n        //3. ) --> pop stack, if * then record, if ( then \\n        //4. When string finished, use all the *\\n        //5. If stack stil has (, then return false\\n        if(s == null || s.length() == 0) return true;\\n        \\n        Stack<Character> stack = new Stack<>();\\n        int starCount = 0;\\n        char[] arr = s.toCharArray();\\n        for(int i = 0; i < arr.length; i++) {\\n            if(arr[i] == \\'*\\') stack.push(arr[i]);\\n            else if(arr[i] == \\'(\\') {\\n                // push the stars back to the stack, to maintain original order\\n                for(int j = 0; j < starCount; j++) {\\n                    stack.push(\\'*\\');\\n                }\\n                starCount = 0; // reset the count to zero\\n                stack.push(arr[i]);\\n            } else if(arr[i] == \\')\\') {\\n                // If the stack is empty, then use up all the saved stars\\n                if(stack.isEmpty()) {\\n                    if(starCount > 0) {\\n                        starCount --;\\n                        continue;\\n                    } else \\n                        return false;\\n                }\\n                // temporarily save the stars\\n                while(!stack.isEmpty() && stack.peek() == \\'*\\') {\\n                    stack.pop(); // pop out the *\\n                    starCount ++;\\n                }\\n                if(!stack.isEmpty())\\n                    stack.pop(); //pop the (\\n                else \\n                    i--; // if stack is empty, don\\'t move the cursor to the next position\\n            }\\n        }\\n        \\n        // Check if the saved stars can pair all the remained (\\n        while(!stack.isEmpty()) {\\n            if(stack.peek() == \\'*\\') {\\n                starCount ++;\\n                stack.pop();\\n            } else {\\n                if(starCount > 0) {\\n                    starCount --;\\n                    stack.pop();\\n                } else {\\n                    return stack.isEmpty();\\n                }\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352959,
                "title": "java-recursion-with-memo",
                "content": "```java\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        Boolean[][] memo = new Boolean[s.length() + 1][s.length() + 1];\\n        return checkValidString(s, 0, 0, memo);\\n    }\\n    \\n    private boolean checkValidString(String s, int index, int count, Boolean[][] memo) {\\n        if (count < 0) {\\n            return false;\\n        }\\n        \\n        if (memo[index][count] != null) {\\n            return memo[index][count];\\n        }\\n        \\n        if (index == s.length()) {\\n            if (count == 0) {\\n                return true;\\n            } else {\\n                memo[index][count] = false;\\n                return false;\\n            }\\n        }\\n        \\n        if (s.charAt(index) == \\'(\\') {\\n            if (checkValidString(s, index + 1, count + 1, memo)) {\\n                return true;\\n            }\\n        } else if (s.charAt(index) == \\')\\') {\\n            if (checkValidString(s, index + 1, count - 1, memo)) {\\n                return true;\\n            }\\n        } else {\\n            if (checkValidString(s, index + 1, count + 1, memo) ||\\n                checkValidString(s, index + 1, count - 1, memo) ||\\n                checkValidString(s, index + 1, count, memo)) {\\n                return true;\\n            }\\n        }\\n        \\n        memo[index][count] = false;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        Boolean[][] memo = new Boolean[s.length() + 1][s.length() + 1];\\n        return checkValidString(s, 0, 0, memo);\\n    }\\n    \\n    private boolean checkValidString(String s, int index, int count, Boolean[][] memo) {\\n        if (count < 0) {\\n            return false;\\n        }\\n        \\n        if (memo[index][count] != null) {\\n            return memo[index][count];\\n        }\\n        \\n        if (index == s.length()) {\\n            if (count == 0) {\\n                return true;\\n            } else {\\n                memo[index][count] = false;\\n                return false;\\n            }\\n        }\\n        \\n        if (s.charAt(index) == \\'(\\') {\\n            if (checkValidString(s, index + 1, count + 1, memo)) {\\n                return true;\\n            }\\n        } else if (s.charAt(index) == \\')\\') {\\n            if (checkValidString(s, index + 1, count - 1, memo)) {\\n                return true;\\n            }\\n        } else {\\n            if (checkValidString(s, index + 1, count + 1, memo) ||\\n                checkValidString(s, index + 1, count - 1, memo) ||\\n                checkValidString(s, index + 1, count, memo)) {\\n                return true;\\n            }\\n        }\\n        \\n        memo[index][count] = false;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 264073,
                "title": "c-simple-backtracking",
                "content": "Valid parenthesis is solved by putting open braces into stack and removing them in case of closing brace. At the end we should have no elements in the stack. It is enough to have a number of opened braces in this particular case. To process \\'*\\', we try opening, closing brace and empty string recursively. \\n\\n```\\n    bool visit(const char* s, int opened_braces){\\n        if (!*s)\\n            return !opened_braces;\\n        \\n        if (opened_braces<0)\\n            return false;\\n        \\n        if (*s == \\'(\\')\\n            return visit(s+1, opened_braces+1);\\n        \\n        if (*s == \\')\\')\\n            return visit(s+1, opened_braces-1);\\n        \\n        // star symbol\\n        \\n        // simulate (\\n        if (visit(s+1, opened_braces+1))\\n            return true;\\n\\n        // simulate )\\n        if (visit(s+1, opened_braces-1))\\n            return true;\\n        \\n        // simulate empty string\\n        if (visit(s+1, opened_braces))\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    bool checkValidString(string s) {\\n        return visit(s.c_str(), 0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool visit(const char* s, int opened_braces){\\n        if (!*s)\\n            return !opened_braces;\\n        \\n        if (opened_braces<0)\\n            return false;\\n        \\n        if (*s == \\'(\\')\\n            return visit(s+1, opened_braces+1);\\n        \\n        if (*s == \\')\\')\\n            return visit(s+1, opened_braces-1);\\n        \\n        // star symbol\\n        \\n        // simulate (\\n        if (visit(s+1, opened_braces+1))\\n            return true;\\n\\n        // simulate )\\n        if (visit(s+1, opened_braces-1))\\n            return true;\\n        \\n        // simulate empty string\\n        if (visit(s+1, opened_braces))\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    bool checkValidString(string s) {\\n        return visit(s.c_str(), 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107583,
                "title": "c-two-pass-forward-and-back-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        for (int i = 0, cnt = 0, star = 0; i < n; i++) {\\n            if (s[i] == '(') \\n                cnt++;\\n            else if (s[i] == '*') \\n                star++;\\n            else {\\n                if (cnt == 0 && star == 0) return false;\\n                if (cnt) \\n                    cnt--;\\n                else \\n                    star--;\\n            }\\n        }\\n        for (int i = n-1, cnt = 0, star = 0; i >= 0; i--) {\\n            if (s[i] == ')') \\n                cnt++;\\n            else if (s[i] == '*') \\n                star++;\\n            else {\\n                if (cnt == 0 && star == 0) return false;\\n                if (cnt) \\n                    cnt--;\\n                else \\n                    star--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        for (int i = 0, cnt = 0, star = 0; i < n; i++) {\\n            if (s[i] == '(') \\n                cnt++;\\n            else if (s[i] == '*') \\n                star++;\\n            else {\\n                if (cnt == 0 && star == 0) return false;\\n                if (cnt) \\n                    cnt--;\\n                else \\n                    star--;\\n            }\\n        }\\n        for (int i = n-1, cnt = 0, star = 0; i >= 0; i--) {\\n            if (s[i] == ')') \\n                cnt++;\\n            else if (s[i] == '*') \\n                star++;\\n            else {\\n                if (cnt == 0 && star == 0) return false;\\n                if (cnt) \\n                    cnt--;\\n                else \\n                    star--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939145,
                "title": "dynamic-programming-solution-explained-easy-to-understand-cpp",
                "content": "**Recursive Solution**\\n```\\nclass Solution {\\n    bool solve(string &s, int index, int open){\\n        // if we have traversed the entire string, then at the end\\n        // the count of open parenthesis must be zero, it means all \\n        // the open brackets are nullify with the closed brackets\\n        if(index == s.size()){\\n            return open == 0;\\n        }\\n        \\n        // if current character is \\'(\\' then increment the \\n        // open parenthesis counter and move to the next index\\n        if(s[index] == \\'(\\'){\\n            return solve(s, index + 1, open + 1);\\n        }\\n        // if current character is \\')\\' then make sure that previously \\n        // we got some open parenthesis, then decrement the open parenthesis \\n        // and move to the next index\\n        else if(s[index] == \\')\\'){\\n            return open != 0 && solve(s, index + 1, open - 1);\\n        }\\n        // if current character is \\'*\\' we have three options available\\n        // it can be a \\'(\\' or \\')\\' or \\'\\', and therefore we exploring all the \\n        // three possibilities\\n        else{\\n            return solve(s, index + 1, open + 1) \\n                || open != 0 && solve(s, index + 1, open - 1)\\n                || solve(s, index + 1, open);\\n        }\\n    }\\npublic:\\n    bool checkValidString(string s) {\\n        return solve(s, 0, 0);\\n    }\\n};\\n```\\n\\n**Optimization using Memoization**\\n\\n```\\nclass Solution {\\n    int dp[101][101];\\n    bool solve(string &s, int index, int open){\\n        if(index == s.size()){\\n            return open == 0;\\n        }\\n        \\n        if(dp[index][open] != -1){\\n            return dp[index][open];\\n        }\\n        \\n        if(s[index] == \\'(\\'){\\n            return dp[index][open] = solve(s, index + 1, open + 1);\\n        }\\n        else if(s[index] == \\')\\'){\\n            return dp[index][open] = open != 0 && solve(s, index + 1, open - 1);\\n        }\\n        else{\\n            return dp[index][open] = solve(s, index + 1, open + 1) \\n                || open != 0 && solve(s, index + 1, open - 1)\\n                || solve(s, index + 1, open);\\n        }\\n    }\\npublic:\\n    bool checkValidString(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(s, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    bool solve(string &s, int index, int open){\\n        // if we have traversed the entire string, then at the end\\n        // the count of open parenthesis must be zero, it means all \\n        // the open brackets are nullify with the closed brackets\\n        if(index == s.size()){\\n            return open == 0;\\n        }\\n        \\n        // if current character is \\'(\\' then increment the \\n        // open parenthesis counter and move to the next index\\n        if(s[index] == \\'(\\'){\\n            return solve(s, index + 1, open + 1);\\n        }\\n        // if current character is \\')\\' then make sure that previously \\n        // we got some open parenthesis, then decrement the open parenthesis \\n        // and move to the next index\\n        else if(s[index] == \\')\\'){\\n            return open != 0 && solve(s, index + 1, open - 1);\\n        }\\n        // if current character is \\'*\\' we have three options available\\n        // it can be a \\'(\\' or \\')\\' or \\'\\', and therefore we exploring all the \\n        // three possibilities\\n        else{\\n            return solve(s, index + 1, open + 1) \\n                || open != 0 && solve(s, index + 1, open - 1)\\n                || solve(s, index + 1, open);\\n        }\\n    }\\npublic:\\n    bool checkValidString(string s) {\\n        return solve(s, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int dp[101][101];\\n    bool solve(string &s, int index, int open){\\n        if(index == s.size()){\\n            return open == 0;\\n        }\\n        \\n        if(dp[index][open] != -1){\\n            return dp[index][open];\\n        }\\n        \\n        if(s[index] == \\'(\\'){\\n            return dp[index][open] = solve(s, index + 1, open + 1);\\n        }\\n        else if(s[index] == \\')\\'){\\n            return dp[index][open] = open != 0 && solve(s, index + 1, open - 1);\\n        }\\n        else{\\n            return dp[index][open] = solve(s, index + 1, open + 1) \\n                || open != 0 && solve(s, index + 1, open - 1)\\n                || solve(s, index + 1, open);\\n        }\\n    }\\npublic:\\n    bool checkValidString(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(s, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749031,
                "title": "simple-c-sollution",
                "content": "\\n\\n### Approach:\\n\\nThe main idea of this approach is to track the minimum and maximum possible unmatched open parentheses while iterating through the given string. We use two variables, `minOpen` and `maxOpen`, to keep track of these values.\\n\\nWe increment both `minOpen` and `maxOpen` when an open parenthesis `\\'(\\'` is encountered because it can potentially match with a closing parenthesis later.\\n\\nWhen a closing parenthesis `\\')\\'` is encountered, we decrement `minOpen` (if it\\'s already positive) because it matches with the encountered closing parenthesis. We also decrement `maxOpen` since the encountered closing parenthesis has been matched with an open parenthesis.\\n\\nFor the asterisk `\\'*\\'`, we consider it as either an empty string or an open parenthesis. So, we decrement `minOpen` (if it\\'s already positive) and increment `maxOpen`.\\n\\nAt any point during the iteration, if `maxOpen` becomes negative, it means there are more closing parentheses than open parentheses encountered so far, and we know that the string is invalid. In such cases, we can return `false` immediately.\\n\\nAfter processing all characters in the string, if `minOpen` is zero, it means that all the open parentheses have been matched, and there are no unmatched parentheses left. In this case, we can return `true`. Otherwise, there are unmatched open parentheses, and we return `false`.\\n\\n### Algorithm:\\n\\n1. Initialize two variables, `minOpen` and `maxOpen`, to zero.\\n2. Iterate through each character `c` in the given string `s`:\\n   - If `c` is `\\'(\\'`, increment both `minOpen` and `maxOpen`.\\n   - If `c` is `\\')\\'`, decrement `minOpen` (if it\\'s already positive) and decrement `maxOpen`.\\n   - If `c` is `\\'*\\'`, decrement `minOpen` (if it\\'s already positive) and increment `maxOpen`.\\n   - If `maxOpen` becomes negative during the iteration, return `false`.\\n3. After the iteration, check if `minOpen` is zero. If it is, return `true`; otherwise, return `false`.\\n\\n### Code in C++:\\n\\n```cpp\\nbool checkValidString(string s) {\\n    int minOpen = 0, maxOpen = 0;\\n\\n    for (char c : s) {\\n        if (c == \\'(\\') {\\n            minOpen++;\\n            maxOpen++;\\n        } else if (c == \\')\\') {\\n            minOpen = max(minOpen - 1, 0);\\n            maxOpen--;\\n        } else { // c == \\'*\\'\\n            minOpen = max(minOpen - 1, 0);\\n            maxOpen++;\\n        }\\n\\n        if (maxOpen < 0) {\\n            return false;\\n        }\\n    }\\n\\n    return minOpen == 0;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nbool checkValidString(string s) {\\n    int minOpen = 0, maxOpen = 0;\\n\\n    for (char c : s) {\\n        if (c == \\'(\\') {\\n            minOpen++;\\n            maxOpen++;\\n        } else if (c == \\')\\') {\\n            minOpen = max(minOpen - 1, 0);\\n            maxOpen--;\\n        } else { // c == \\'*\\'\\n            minOpen = max(minOpen - 1, 0);\\n            maxOpen++;\\n        }\\n\\n        if (maxOpen < 0) {\\n            return false;\\n        }\\n    }\\n\\n    return minOpen == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3638525,
                "title": "c-recursion-memoization-take-not-take",
                "content": "# Intuition\\nWe have 3 option when a star came either make it \"(\" or make it \")\" or doing nothing. So clearly we have to try all possibilities. So This problem can be solved by using recursion and memoization.\\n\\n``` \\nIF YOU FOUND IT USELESS THEN PLEASE UPVOTE TOO :) \\n```\\n\\n# Recursive Approach\\ncreate one recursive function f.\\n\\nBase case: if (i>=s.size()) return br==0 \\n           if(br<0) return 0\\n\\nhere br is bracket number br is +1 for \"(\" and -1 for \")\".\\n\\nif(s[i] == \\'*\\' ) we have 3 possibilities\\n\\nFirst initialise a varibale take with false\\n\\n1. make it \\'(\\' -> take= take | f(i+1,s,br+1,dp);\\n2. make it \\')\\' -> take | f(i+1,s,br-1,dp);  // Here we need to take care if br>0 as we can\\'t take more number of ending bracket\\n3. doing nothing -> take | f(i+1,s,br,dp);\\n\\nif( s[i] != \\'*\\' ) we have only 2 possibilities\\n\\n1. if(s[i]==\\'(\\' ) take = take | f(i+1,s,br+1,dp);\\n2. if(s[i]==\\')\\' ) take | f(i+1,s,br-1,dp);\\n\\nreturn take;\\n\\n# Recursive code:\\n```\\nclass Solution {\\npublic:\\n    \\n    bool f(int i, string &s,int br){\\n        if(i>=s.size()){\\n            return br==0;\\n        }\\n\\n        if(br<0){\\n            return false;\\n        }\\n\\n        bool take=false;\\n        // 3 options\\n        if(s[i]==\\'*\\'){\\n            take= take | f(i+1,s,br+1);  // add \\'(\\' \\n            if(br) take = take | f(i+1,s,br-1);  // add \\')\\' but cond there must be any opening bracket\\n            take = take | f(i+1,s,br);  // doing nothing\\n        }else{\\n            if(s[i]==\\'(\\') take = take | f(i+1,s,br+1);\\n            else take= take | f(i+1,s,br-1);\\n        }\\n        return take;\\n    }\\n\\n    bool checkValidString(string s) {\\n        return f(0,s,0);\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(3^n)$$\\n\\n\\n# Memoization Approach\\nwe will use a 2-D vector of size n \\n\\ndp[i][j] -> number of bracket (j) till index (i)\\n\\n# Memoization Code\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool f(int i, string &s,int br,vector<vector<int>> &dp){\\n        if(i>=s.size()){\\n            return br==0;\\n        }\\n\\n        if(br<0){\\n            return false;\\n        }\\n\\n        if(dp[i][br]!=-1) return dp[i][br];\\n        bool take=false;\\n        // 3 options\\n        if(s[i]==\\'*\\'){\\n            take= take | f(i+1,s,br+1,dp);  // add \\'(\\' \\n            if(br) take = take | f(i+1,s,br-1,dp);  // add \\')\\' but cond there must be any opening bracket\\n            take = take | f(i+1,s,br,dp);  // doing nothing\\n        }else{\\n            if(s[i]==\\'(\\') take = take | f(i+1,s,br+1,dp);\\n            else take= take | f(i+1,s,br-1,dp);\\n        }\\n        return dp[i][br]=take;\\n    }\\n\\n    bool checkValidString(string s) {\\n        vector<vector<int>> dp((int) s.size()+1,vector<int>((int)s.size()+1,-1));\\n        return f(0,s,0,dp);\\n    }\\n};\\n```\\n# Time Complexity\\n\\n$$ O(n^2) $$\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "``` \\nIF YOU FOUND IT USELESS THEN PLEASE UPVOTE TOO :) \\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool f(int i, string &s,int br){\\n        if(i>=s.size()){\\n            return br==0;\\n        }\\n\\n        if(br<0){\\n            return false;\\n        }\\n\\n        bool take=false;\\n        // 3 options\\n        if(s[i]==\\'*\\'){\\n            take= take | f(i+1,s,br+1);  // add \\'(\\' \\n            if(br) take = take | f(i+1,s,br-1);  // add \\')\\' but cond there must be any opening bracket\\n            take = take | f(i+1,s,br);  // doing nothing\\n        }else{\\n            if(s[i]==\\'(\\') take = take | f(i+1,s,br+1);\\n            else take= take | f(i+1,s,br-1);\\n        }\\n        return take;\\n    }\\n\\n    bool checkValidString(string s) {\\n        return f(0,s,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool f(int i, string &s,int br,vector<vector<int>> &dp){\\n        if(i>=s.size()){\\n            return br==0;\\n        }\\n\\n        if(br<0){\\n            return false;\\n        }\\n\\n        if(dp[i][br]!=-1) return dp[i][br];\\n        bool take=false;\\n        // 3 options\\n        if(s[i]==\\'*\\'){\\n            take= take | f(i+1,s,br+1,dp);  // add \\'(\\' \\n            if(br) take = take | f(i+1,s,br-1,dp);  // add \\')\\' but cond there must be any opening bracket\\n            take = take | f(i+1,s,br,dp);  // doing nothing\\n        }else{\\n            if(s[i]==\\'(\\') take = take | f(i+1,s,br+1,dp);\\n            else take= take | f(i+1,s,br-1,dp);\\n        }\\n        return dp[i][br]=take;\\n    }\\n\\n    bool checkValidString(string s) {\\n        vector<vector<int>> dp((int) s.size()+1,vector<int>((int)s.size()+1,-1));\\n        return f(0,s,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629608,
                "title": "c-easy-solution-using-two-stacks-t-c-o-n-s-c-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int n = s.length();\\n        stack<int> open;\\n        stack<int> star;\\n\\n        for(int i = 0; i < n ; i++){\\n            if(s[i]==\\'(\\')open.push(i);\\n            else if(s[i]==\\'*\\')star.push(i);\\n            else{\\n                if(open.empty() && star.empty())return false;\\n                if(!open.empty())open.pop();\\n                else star.pop();\\n            }\\n        }\\n\\n        // cout<<open.size()<<\" \"<<star.size()<<endl;\\n\\n        if(!open.empty()){\\n            if(open.size()>star.size())return false;\\n            else{\\n                while(!open.empty()){\\n                    if(open.top()>star.top())return false;\\n                    star.pop();\\n                    open.pop();\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int n = s.length();\\n        stack<int> open;\\n        stack<int> star;\\n\\n        for(int i = 0; i < n ; i++){\\n            if(s[i]==\\'(\\')open.push(i);\\n            else if(s[i]==\\'*\\')star.push(i);\\n            else{\\n                if(open.empty() && star.empty())return false;\\n                if(!open.empty())open.pop();\\n                else star.pop();\\n            }\\n        }\\n\\n        // cout<<open.size()<<\" \"<<star.size()<<endl;\\n\\n        if(!open.empty()){\\n            if(open.size()>star.size())return false;\\n            else{\\n                while(!open.empty()){\\n                    if(open.top()>star.top())return false;\\n                    star.pop();\\n                    open.pop();\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3621408,
                "title": "very-easy-solution-with-explanantion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The code then iterates through each character in the input string using a for loop. Here\\'s what happens inside the loop:\\n\\nIf the current character is \\'(\\', it means an open parenthesis is encountered. In this case, both leftmin and leftmax are incremented by 1 since we have one more open parenthesis.\\n\\nIf the current character is \\')\\', it means a closing parenthesis is encountered. In this case, both leftmin and leftmax are decremented by 1 since we have matched one open parenthesis with a closing one.\\n\\nIf the current character is neither \\'(\\' nor \\')\\', it means it is an asterisk (*), which can represent either an open parenthesis, a closing parenthesis, or an empty string. In this case, leftmin is decremented by 1 (considering it as a closing parenthesis) and leftmax is incremented by 1 (considering it as an open parenthesis).\\n\\nAfter updating the leftmin and leftmax variables, the code checks two conditions:\\n\\nIf leftmax becomes negative at any point during the iteration, it means we have encountered more closing parentheses than the possible open parentheses, which makes the expression invalid. In that case, the function returns false.\\n\\nIf leftmin becomes negative at any point during the iteration, it means we have encountered more closing parentheses than the open parentheses available so far. To keep leftmin non-negative, it is set to 0, assuming all the extra closing parentheses are balanced by open parentheses.\\n\\nFinally, outside the loop, the code checks if leftmin is equal to 0. If it is, it means all open parentheses have been matched and canceled out by the corresponding closing parentheses, and there are no unmatched parentheses left. In that case, the function returns true. Otherwise, it returns false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        \\n        int leftmin=0;\\n        int leftmax=0;\\n\\n        for(int i =0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                leftmin++;\\n                leftmax++;\\n            }\\n\\n            else if(s[i]==\\')\\')\\n            {\\n                leftmin--;\\n                leftmax--;\\n            }\\n            else{\\n                leftmin--;\\n                leftmax++;\\n\\n            }\\n\\n            if(leftmax<0) return false;\\n            if(leftmin<0) leftmin=0;\\n        }\\n\\n        return leftmin==0;\\n       \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        \\n        int leftmin=0;\\n        int leftmax=0;\\n\\n        for(int i =0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                leftmin++;\\n                leftmax++;\\n            }\\n\\n            else if(s[i]==\\')\\')\\n            {\\n                leftmin--;\\n                leftmax--;\\n            }\\n            else{\\n                leftmin--;\\n                leftmax++;\\n\\n            }\\n\\n            if(leftmax<0) return false;\\n            if(leftmin<0) leftmin=0;\\n        }\\n\\n        return leftmin==0;\\n       \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111357,
                "title": "c-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        \\n        int leftmin=0;\\n        int leftmax=0;\\n\\n        for(int i =0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                leftmin++;\\n                leftmax++;\\n            }\\n\\n            else if(s[i]==\\')\\')\\n            {\\n                leftmin--;\\n                leftmax--;\\n            }\\n            else{\\n                leftmin--;\\n                leftmax++;\\n\\n            }\\n\\n            if(leftmax<0) return false;\\n            if(leftmin<0) leftmin=0;\\n        }\\n\\n        return leftmin==0;\\n       \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        \\n        int leftmin=0;\\n        int leftmax=0;\\n\\n        for(int i =0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                leftmin++;\\n                leftmax++;\\n            }\\n\\n            else if(s[i]==\\')\\')\\n            {\\n                leftmin--;\\n                leftmax--;\\n            }\\n            else{\\n                leftmin--;\\n                leftmax++;\\n\\n            }\\n\\n            if(leftmax<0) return false;\\n            if(leftmin<0) leftmin=0;\\n        }\\n\\n        return leftmin==0;\\n       \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073985,
                "title": "python-two-stack-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing two stack approch\\nfirst stack store only opening bracket\\nsecond stack store only star\\n\\nwhen closing bracket comes that time \\n1} check opening bracket exits or not if exist then pop out one opening bracket because it will valid parenthesis\\n2} if opening bracket not exit check star if exist then it is also valid parenthesis string ex ---> *) < -- this is valid\\n3} else it will False because there is only closing bracket ex--> ) (  )  <-- invalid\\n\\ncheck againg any  opening bracket presint or not \\nif  opening bracket remaning and stars are not exits then it will false\\n\\nif stars are present and indexing is greater than opening bracket then it will valid otherwise false ex --> *( <-- not valid if it is valid when * comes after bracket --> ( *      \\n\\nThanks\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidString(self, s):\\n        st=[]\\n        sr=[]\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                st.append(i)\\n            elif s[i]== \\'*\\':\\n                sr.append(i)\\n            else:\\n                if st:\\n                    st.pop()\\n                elif sr:\\n                    sr.pop()\\n                else:\\n                    return False\\n        while st:\\n            if len(sr)==0:\\n                return False\\n            elif st[-1]< sr[-1]:\\n                st.pop()\\n                sr.pop()\\n            else:\\n                return False\\n        return True\\n\\n\\n\\n\\n                \\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidString(self, s):\\n        st=[]\\n        sr=[]\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                st.append(i)\\n            elif s[i]== \\'*\\':\\n                sr.append(i)\\n            else:\\n                if st:\\n                    st.pop()\\n                elif sr:\\n                    sr.pop()\\n                else:\\n                    return False\\n        while st:\\n            if len(sr)==0:\\n                return False\\n            elif st[-1]< sr[-1]:\\n                st.pop()\\n                sr.pop()\\n            else:\\n                return False\\n        return True\\n\\n\\n\\n\\n                \\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690048,
                "title": "c-optimized-code-with-explanation-very-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack<int> st, st1;\\n        \\n        for (int i=0; i<s.length(); i++) {\\n            if (s[i] == \\'(\\' || s[i] == \\'*\\')\\n                st.push(s[i]);\\n            else\\n                if (st.empty())\\n                    return false;\\n                else {\\n                    while (!st.empty() && st.top() == \\'*\\') { \\n                        // find the rightmost occurrence of a left-parenthesis\\n                        st1.push(st.top()); //pushing st1 on top of stack st\\n                        st.pop();   //and then remove it\\n                    }\\n                    \\n                    if (st.empty()) // no left-parenthesis found, pop it\\n                        st1.pop();\\n                    else // pop left parenthesis\\n                        st.pop();\\n                    \\n                    while (!st1.empty()) { \\n                        // by the time st1 dont get empty push ele in st by taking topmost ele from st1                             and then pop it\\n                        st.push(st1.top());\\n                        st1.pop();\\n                    }\\n                }\\n        }\\n        \\n        int sc = 0; // asterisks count\\n        char c;\\n        \\n        while (!st.empty()) {\\n            c = st.top();\\n            st.pop();\\n            \\n            if (c==\\'*\\')\\n                sc++;\\n            else {\\n                if (sc>0) // there is an asterisk on the right of left-parenthesis\\n                    sc--;\\n                else // no asterisk on the right of left parenthesis\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/e14bd4c2-9e96-4083-953e-d6fe16afe350_1665486374.3379164.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        stack<int> st, st1;\\n        \\n        for (int i=0; i<s.length(); i++) {\\n            if (s[i] == \\'(\\' || s[i] == \\'*\\')\\n                st.push(s[i]);\\n            else\\n                if (st.empty())\\n                    return false;\\n                else {\\n                    while (!st.empty() && st.top() == \\'*\\') { \\n                        // find the rightmost occurrence of a left-parenthesis\\n                        st1.push(st.top()); //pushing st1 on top of stack st\\n                        st.pop();   //and then remove it\\n                    }\\n                    \\n                    if (st.empty()) // no left-parenthesis found, pop it\\n                        st1.pop();\\n                    else // pop left parenthesis\\n                        st.pop();\\n                    \\n                    while (!st1.empty()) { \\n                        // by the time st1 dont get empty push ele in st by taking topmost ele from st1                             and then pop it\\n                        st.push(st1.top());\\n                        st1.pop();\\n                    }\\n                }\\n        }\\n        \\n        int sc = 0; // asterisks count\\n        char c;\\n        \\n        while (!st.empty()) {\\n            c = st.top();\\n            st.pop();\\n            \\n            if (c==\\'*\\')\\n                sc++;\\n            else {\\n                if (sc>0) // there is an asterisk on the right of left-parenthesis\\n                    sc--;\\n                else // no asterisk on the right of left parenthesis\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625536,
                "title": "python-greedy-solution-o-n-time-o-1-space",
                "content": "```\\n# * Greedy Solution | O(n) Time | O(1) Space\\n# * n -> The length of s string\\n\\n\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        left_min = left_max = 0\\n        for char in s:\\n            if char == \"(\":\\n                left_min += 1\\n                left_max += 1\\n            elif char == \")\":\\n                left_min -= 1\\n                left_max -= 1\\n            else:\\n                left_min -= 1\\n                left_max += 1\\n\\n            if left_max < 0:\\n                return False\\n\\n            left_min = max(left_min, 0)\\n\\n        return left_min == 0\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n# * Greedy Solution | O(n) Time | O(1) Space\\n# * n -> The length of s string\\n\\n\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        left_min = left_max = 0\\n        for char in s:\\n            if char == \"(\":\\n                left_min += 1\\n                left_max += 1\\n            elif char == \")\":\\n                left_min -= 1\\n                left_max -= 1\\n            else:\\n                left_min -= 1\\n                left_max += 1\\n\\n            if left_max < 0:\\n                return False\\n\\n            left_min = max(left_min, 0)\\n\\n        return left_min == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386169,
                "title": "java-very-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int cmin = 0, cmax = 0; // open parentheses count in range [cmin, cmax]\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                cmax++;\\n                cmin++;\\n            } else if (c == \\')\\') {\\n                cmax--;\\n                cmin--;\\n            } else if (c == \\'*\\') {\\n                cmax++; // if `*` become `(` then openCount++\\n                cmin--; // if `*` become `)` then openCount--\\n                // if `*` become `` then nothing happens\\n                // So openCount will be in new range [cmin-1, cmax+1]\\n            }\\n            if (cmax < 0) return false; // Currently, don\\'t have enough open parentheses to match close parentheses-> Invalid\\n                                        // For example: ())(\\n            cmin = Math.max(cmin, 0);   // It\\'s invalid if open parentheses count < 0 that\\'s why cmin can\\'t be negative\\n        }\\n        return cmin == 0; // Return true if can found `openCount == 0` in range [cmin, cmax]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int cmin = 0, cmax = 0; // open parentheses count in range [cmin, cmax]\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                cmax++;\\n                cmin++;\\n            } else if (c == \\')\\') {\\n                cmax--;\\n                cmin--;\\n            } else if (c == \\'*\\') {\\n                cmax++; // if `*` become `(` then openCount++\\n                cmin--; // if `*` become `)` then openCount--\\n                // if `*` become `` then nothing happens\\n                // So openCount will be in new range [cmin-1, cmax+1]\\n            }\\n            if (cmax < 0) return false; // Currently, don\\'t have enough open parentheses to match close parentheses-> Invalid\\n                                        // For example: ())(\\n            cmin = Math.max(cmin, 0);   // It\\'s invalid if open parentheses count < 0 that\\'s why cmin can\\'t be negative\\n        }\\n        return cmin == 0; // Return true if can found `openCount == 0` in range [cmin, cmax]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362404,
                "title": "java-stack-easy-solution-o-n-solution",
                "content": "```\\nclass Solution{\\n\\tpublic boolean checkValidString(String s){\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tStack<Integer> star = new Stack<>();\\n\\t\\tfor(int i=0;i<s.length();i++){\\n\\t\\t\\tif(s.charAt(i)==\\'(\\' ) \\n                stack.push(i);\\n            else if(s.charAt(i)==\\'*\\') \\n                star.push(i);\\n\\t\\t\\telse {\\n                if(!stack.isEmpty())\\n                         stack.pop();\\n                \\n               else if(!star.isEmpty())\\n                          star.pop();\\n                 else \\n                          return false;\\n                \\n\\t\\t\\t}\\n\\t\\t}\\n        while(!stack.isEmpty()){\\n            if(star.isEmpty()) \\n                return false;\\n            else if( stack.peek()<star.peek())                \\n            {\\n                star.pop();\\n                stack.pop();\\n            }\\n            else\\n                 return false;\\n        }\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution{\\n\\tpublic boolean checkValidString(String s){\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tStack<Integer> star = new Stack<>();\\n\\t\\tfor(int i=0;i<s.length();i++){\\n\\t\\t\\tif(s.charAt(i)==\\'(\\' ) \\n                stack.push(i);\\n            else if(s.charAt(i)==\\'*\\') \\n                star.push(i);\\n\\t\\t\\telse {\\n                if(!stack.isEmpty())\\n                         stack.pop();\\n                \\n               else if(!star.isEmpty())\\n                          star.pop();\\n                 else \\n                          return false;\\n                \\n\\t\\t\\t}\\n\\t\\t}\\n        while(!stack.isEmpty()){\\n            if(star.isEmpty()) \\n                return false;\\n            else if( stack.peek()<star.peek())                \\n            {\\n                star.pop();\\n                stack.pop();\\n            }\\n            else\\n                 return false;\\n        }\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323639,
                "title": "c-ok",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n     int cmin = 0, cmax = 0;\\n        for (char a : s) {\\n            if (a== \\'(\\')\\n                cmax++, cmin++;\\n            if (a== \\')\\')\\n                cmax--, cmin = max(cmin - 1, 0);\\n            if (a == \\'*\\')\\n                cmax++, cmin = max(cmin - 1, 0);\\n            if (cmax < 0) return false;\\n        }\\n        return cmin == 0;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n     int cmin = 0, cmax = 0;\\n        for (char a : s) {\\n            if (a== \\'(\\')\\n                cmax++, cmin++;\\n            if (a== \\')\\')\\n                cmax--, cmin = max(cmin - 1, 0);\\n            if (a == \\'*\\')\\n                cmax++, cmin = max(cmin - 1, 0);\\n            if (cmax < 0) return false;\\n        }\\n        return cmin == 0;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221392,
                "title": "100-fast-and-clean-code",
                "content": "\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool checkValidString(string str) {\\n        int o = 0, s = 0, c = 0;\\n        for( int i = 0 ; i < str.size() ; i++ ){\\n            if( str[i] == \\')\\' ) c++;\\n            if( str[i] == \\'(\\' ) o++;\\n            if( str[i] == \\'*\\' ) s++;\\n\\n\\t\\t\\tif( c > o+s ){\\n                return false;\\n            }\\n        }\\n        \\n        o = 0, s = 0, c = 0;\\n        for( int i = str.size()-1 ; i >= 0 ; i-- ){\\n            if( str[i] == \\')\\' ) o++;\\n            if( str[i] == \\'(\\' ) c++;\\n            if( str[i] == \\'*\\' ) s++;\\n            \\n            if( c > o+s ){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool checkValidString(string str) {\\n        int o = 0, s = 0, c = 0;\\n        for( int i = 0 ; i < str.size() ; i++ ){\\n            if( str[i] == \\')\\' ) c++;\\n            if( str[i] == \\'(\\' ) o++;\\n            if( str[i] == \\'*\\' ) s++;\\n\\n\\t\\t\\tif( c > o+s ){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2091670,
                "title": "c-100-faster-o-n-with-detailed-explanation",
                "content": "```\\n//  The simple idea is that first traverse from left and decreament count for \\')\\' parenthesis and increment otherwise. If at any index count is less than zero then it will not be possible to make it valid. \\n// Similarly traverse agian from right and do same for \\'(\\' parenthesis and check the condition.\\n// If in both traversal we didn\\'t find any such condition than it will always be possible to make the valid parenthesis string.\\n```class Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int n=s.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\')\\')\\n                cnt--;\\n            else cnt++;\\n            if(cnt<0) return false;\\n        }\\n        cnt=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'(\\') cnt--;\\n            else cnt++;\\n            if(cnt<0) return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n//  The simple idea is that first traverse from left and decreament count for \\')\\' parenthesis and increment otherwise. If at any index count is less than zero then it will not be possible to make it valid. \\n// Similarly traverse agian from right and do same for \\'(\\' parenthesis and check the condition.\\n// If in both traversal we didn\\'t find any such condition than it will always be possible to make the valid parenthesis string.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2074683,
                "title": "c-simple-two-stacks",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n\\n        stack<int> parenStack;\\n        stack<int> stars;\\n        int numstars = 0;\\n        for(int i = 0 ; i < s.size(); i++)\\n        {\\n            if(s[i] == \\'*\\')\\n            {\\n                stars.push(i);\\n            }\\n            else if(s[i] == \\'(\\')\\n                parenStack.push(i);\\n            else\\n            {\\n                if(parenStack.size() > 0)\\n                {\\n                    parenStack.pop();\\n                }\\n                else if(stars.size() > 0)\\n                {\\n                    stars.pop();\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        if(stars.size() < parenStack.size())\\n            return false;\\n        \\n        while(stars.size() && parenStack.size())\\n        {\\n            if(stars.top() > parenStack.top())\\n            {\\n                stars.pop();\\n                parenStack.pop();\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n\\n        stack<int> parenStack;\\n        stack<int> stars;\\n        int numstars = 0;\\n        for(int i = 0 ; i < s.size(); i++)\\n        {\\n            if(s[i] == \\'*\\')\\n            {\\n                stars.push(i);\\n            }\\n            else if(s[i] == \\'(\\')\\n                parenStack.push(i);\\n            else\\n            {\\n                if(parenStack.size() > 0)\\n                {\\n                    parenStack.pop();\\n                }\\n                else if(stars.size() > 0)\\n                {\\n                    stars.pop();\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        if(stars.size() < parenStack.size())\\n            return false;\\n        \\n        while(stars.size() && parenStack.size())\\n        {\\n            if(stars.top() > parenStack.top())\\n            {\\n                stars.pop();\\n                parenStack.pop();\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030987,
                "title": "c-100-fast-recursion-meomization-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    int dp[101][500];\\n    bool solve(string &s, int idx, int score){\\n            if(score < 0 || idx > s.size()) return false;\\n            if(idx == s.size() && score == 0){\\n             return true;\\n            }\\n             if(dp[idx][score] != -1) return dp[idx][score];\\n             bool flag = false;\\n            if(s[idx] == \\')\\'){\\n               flag |= solve(s, idx + 1, score - 1);\\n            }\\n            else if(s[idx] == \\'(\\'){\\n               flag |= solve(s, idx + 1, score + 1);\\n            }\\n        \\n            else{\\n               flag |= solve(s, idx + 1, score);\\n               flag |= solve(s, idx + 1, score + 1);\\n               flag |= solve(s, idx + 1, score - 1);\\n            }\\n        return dp[idx][score] = flag;\\n    }\\n\\n    bool checkValidString(string s) {\\n           memset(dp, -1, sizeof(dp));\\n           return solve(s, 0, 0);      \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n   \\n    int dp[101][500];\\n    bool solve(string &s, int idx, int score){\\n            if(score < 0 || idx > s.size()) return false;\\n            if(idx == s.size() && score == 0){\\n             return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2002899,
                "title": "2-pass-easy-to-understand-java-solution",
                "content": "```\\nApproach: \\n* There are more open parenthesis but we have enough \\'*\\' so we can balance the parenthesis with \\')\\'\\n* There are more close parenthesis but we have enough \\'*\\' so we can balance the parenthesis with \\'(\\'\\n* There are as many \\'(\\' than \\')\\' so all parenthesis are balanced, we can ignore the extra \\'*\\'\\n\\npublic boolean checkValidString(String s) {\\n        // Iterate from left - > right and count left \\n        int left = 0; \\n        for (char c: s.toCharArray()) {\\n            if (c == \\'(\\' || c == \\'*\\') left++;\\n            else left--;\\n            if (left < 0) return false; \\n        }\\n        \\n        if (left == 0) return true; \\n        \\n        // Iterate from right -> left and count right\\n        int right = 0; \\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) == \\')\\' || s.charAt(i) == \\'*\\') right++;\\n            else right--;\\n            if (right < 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\nApproach: \\n* There are more open parenthesis but we have enough \\'*\\' so we can balance the parenthesis with \\')\\'\\n* There are more close parenthesis but we have enough \\'*\\' so we can balance the parenthesis with \\'(\\'\\n* There are as many \\'(\\' than \\')\\' so all parenthesis are balanced, we can ignore the extra \\'*\\'\\n\\npublic boolean checkValidString(String s) {\\n        // Iterate from left - > right and count left \\n        int left = 0; \\n        for (char c: s.toCharArray()) {\\n            if (c == \\'(\\' || c == \\'*\\') left++;\\n            else left--;\\n            if (left < 0) return false; \\n        }\\n        \\n        if (left == 0) return true; \\n        \\n        // Iterate from right -> left and count right\\n        int right = 0; \\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) == \\')\\' || s.charAt(i) == \\'*\\') right++;\\n            else right--;\\n            if (right < 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1938312,
                "title": "c-two-passes-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n     \\n        if(s.size() < 2) return (s[0] == \\'*\\');\\n        int closed = 0;\\n        int open = 0;\\n        int either = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'(\\') open++;\\n            else if(s[i] == \\')\\') closed++;\\n            else either++;\\n            if(closed > (open+either)) return false;\\n        }\\n        closed = 0;\\n        open = 0;\\n        either = 0;\\n        for(int i = s.size()-1; i >= 0; i--){\\n            if(s[i] == \\'(\\') open++;\\n            else if(s[i] == \\')\\') closed++;\\n            else either++;\\n            if(open > (closed+either)) return false;\\n        }\\n        return true; //~The Answer~\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n     \\n        if(s.size() < 2) return (s[0] == \\'*\\');\\n        int closed = 0;\\n        int open = 0;\\n        int either = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'(\\') open++;\\n            else if(s[i] == \\')\\') closed++;\\n            else either++;\\n            if(closed > (open+either)) return false;\\n        }\\n        closed = 0;\\n        open = 0;\\n        either = 0;\\n        for(int i = s.size()-1; i >= 0; i--){\\n            if(s[i] == \\'(\\') open++;\\n            else if(s[i] == \\')\\') closed++;\\n            else either++;\\n            if(open > (closed+either)) return false;\\n        }\\n        return true; //~The Answer~\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931697,
                "title": "c-easy-to-understand",
                "content": "In this solution we traverse the string twice, once from left to right and once from left to right.\\n\\nIn each pass we check four things :\\n1. Number of Stars.\\n2. Number of open brackets\\n3. Number of closed brackets\\n4. Unpaired brackets (closed - open)\\n\\nAfter each step we check whether the **number of unpaired is greater than the stars or not**.\\nIf yes we there and then return FALSE. (as we can\\'t proceed after that)\\notherwise we continue. \\nIf we are able traverse the string through both passes then we return TRUE.\\n\\nIt is a clever way to solve this problem.\\n\\nHappy Coding :-)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {       \\n        \\n          \\n        int star = 0, open = 0, closed = 0, unpaired;\\n        for(int i = 0; i <s.length(); i++) {\\n            if (s[i] == \\'*\\')\\n                star++;\\n            else if (s[i] == \\'(\\')\\n                open++;\\n            else if (s[i] == \\')\\')\\n                closed++;\\n            unpaired = closed-open;\\n            if (unpaired > star)\\n                return false;\\n        }\\n          \\n        star = 0, open = 0, closed = 0, unpaired=0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            if (s[i] == \\'*\\')\\n                star++;\\n            else if (s[i] == \\'(\\')\\n                open++;\\n            else if (s[i] == \\')\\')\\n                closed++;\\n            unpaired = open-closed;\\n            if (unpaired > star)\\n                return false;\\n        }\\n          \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {       \\n        \\n          \\n        int star = 0, open = 0, closed = 0, unpaired;\\n        for(int i = 0; i <s.length(); i++) {\\n            if (s[i] == \\'*\\')\\n                star++;\\n            else if (s[i] == \\'(\\')\\n                open++;\\n            else if (s[i] == \\')\\')\\n                closed++;\\n            unpaired = closed-open;\\n            if (unpaired > star)\\n                return false;\\n        }\\n          \\n        star = 0, open = 0, closed = 0, unpaired=0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            if (s[i] == \\'*\\')\\n                star++;\\n            else if (s[i] == \\'(\\')\\n                open++;\\n            else if (s[i] == \\')\\')\\n                closed++;\\n            unpaired = open-closed;\\n            if (unpaired > star)\\n                return false;\\n        }\\n          \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917098,
                "title": "c-two-stacks-with-detailed-intuitive-explanation",
                "content": "\\nin this problem, we try to use a greedy kind of an algorithm\\n\\nwe have two stacks , one for the opening brackets [\\'(\\'] and one for the stars (*)\\n\\nwhenever we encounter an opening bracket, we push its index into the openingBracket stack\\nwhenever we encounter a star (*), we push it into the star stack\\nnow whenever we encounter a closing bracket, we try to balance it with an opening bracket firstso for this we check the opening braket stack first, and if it has some index in it, we pop it (that is, that openingbracket will be used to balance this closing bracket)\\n\\nbut in case the opening bracket stack is empty, we look into the star stack,\\nwe pop out the top element (signifying that this star (*) will now be used to balance this closing bracket)\\n\\nin case both the stacks are empty, it means that we have no one to balance this closing bracket, and we will\\nhave to return false\\n\\n\\nat the end, there will be some elements left out in both the stacks\\nbut the important one is the opening bracket stack. the left out ones are those opening brackets, which\\nnever got balanced by any closing bracket. so these left out opening brackets, have only one hope left : i.e\\nonly stars (*) can balance them out by behaving like closing brackets\\n\\nso while both stacks are non empty, keep popping the top guys from both of them\\nnow for a star to balance out an opening bracket, it is obvious that it should come after the opening bracket\\n\\nso in case the index of star is less than index of opening bracket, return false, because this star wont be able to balance it\\n(we return false, because all the subsequent stars which we encouter would have an even lower index, because of the order in which the elements are\\n\\tgetting pushed)\\n\\nat the end, we return true, only if the opening bracket stack is empty()\\n\\tthe stars which remain in the star stack, would behave like empty strings\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n\\tbool checkValidString(string s) {\\n\\n\\t\\tstack<int> leftBracketStack;\\n\\t\\tstack<int> starStack;\\n\\t\\tint len = s.length();\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (s[i] == \\'(\\') leftBracketStack.push(i);\\n\\t\\t\\telse if (s[i] == \\'*\\') starStack.push(i);\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (leftBracketStack.empty() && starStack.empty()) return false;\\n\\n\\t\\t\\t\\tif (leftBracketStack.size()) leftBracketStack.pop();\\n\\t\\t\\t\\telse starStack.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\twhile (!leftBracketStack.empty() && !starStack.empty()) {\\n\\t\\t\\tint leftBracketIndex = leftBracketStack.top(); leftBracketStack.pop();\\n\\t\\t\\tint starIndex = starStack.top(); starStack.pop();\\n\\t\\t\\tif (leftBracketIndex > starIndex) return false;\\n\\t\\t}\\n\\n\\t\\treturn leftBracketStack.empty();\\n\\n\\n\\t}\\n};\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n\\tbool checkValidString(string s) {\\n\\n\\t\\tstack<int> leftBracketStack;\\n\\t\\tstack<int> starStack;\\n\\t\\tint len = s.length();\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (s[i] == \\'(\\') leftBracketStack.push(i);\\n\\t\\t\\telse if (s[i] == \\'*\\') starStack.push(i);\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (leftBracketStack.empty() && starStack.empty()) return false;\\n\\n\\t\\t\\t\\tif (leftBracketStack.size()) leftBracketStack.pop();\\n\\t\\t\\t\\telse starStack.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\twhile (!leftBracketStack.empty() && !starStack.empty()) {\\n\\t\\t\\tint leftBracketIndex = leftBracketStack.top(); leftBracketStack.pop();\\n\\t\\t\\tint starIndex = starStack.top(); starStack.pop();\\n\\t\\t\\tif (leftBracketIndex > starIndex) return false;\\n\\t\\t}\\n\\n\\t\\treturn leftBracketStack.empty();\\n\\n\\n\\t}\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815567,
                "title": "count-of-open-and-closed-parenthesis-dp-top-down-cpp",
                "content": "Idea is that \\nIf at any point we get more \\'(\\' than \\')\\'\\nthere is a possiblity that extra \\'(\\' could be cancelled out by \\')\\' which we might accros in future \\n\\nBut \\nIf at any point we get more \\')\\' than \\'(\\'\\nThen no matter how many \\'(\\' we get in future \\nwe cannot make the string valid Parenthesis.\\n\\nSo when we find that count of \\')\\' is greater than \\'(\\' we return \\n\\n\\'\\'\\'\\n\\n    int dp[101][101][101];\\n    bool solve(string s,int i,int o,int c){\\n        \\n        if(i == s.size()){\\n            if(o==c)\\n                return true;\\n            else\\n                return false;\\n        }\\n        if(c > o){\\n            return false;\\n        }\\n        if(dp[i][o][c]!=-1)return dp[i][o][c];\\n        bool ans;\\n        if(s[i] == \\'*\\'){\\n            ans = solve(s,i+1,o,c) || \\n                    solve(s,i+1,o+1,c) ||\\n                    solve(s,i+1,o,c+1);\\n        } \\n        \\n        if(s[i] == \\'(\\'){\\n            ans = solve(s,i+1,o+1,c);\\n        }\\n    \\n        if(s[i] == \\')\\'){\\n            ans = solve(s,i+1,o,c+1);\\n        }\\n    \\n        return dp[i][o][c] = ans ;\\n    }\\n    \\n    bool checkValidString(string s) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(s,0,0,0);\\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "Idea is that \\nIf at any point we get more \\'(\\' than \\')\\'\\nthere is a possiblity that extra \\'(\\' could be cancelled out by \\')\\' which we might accros in future \\n\\nBut \\nIf at any point we get more \\')\\' than \\'(\\'\\nThen no matter how many \\'(\\' we get in future \\nwe cannot make the string valid Parenthesis.\\n\\nSo when we find that count of \\')\\' is greater than \\'(\\' we return \\n\\n\\'\\'\\'\\n\\n    int dp[101][101][101];\\n    bool solve(string s,int i,int o,int c){\\n        \\n        if(i == s.size()){\\n            if(o==c)\\n                return true;\\n            else\\n                return false;\\n        }\\n        if(c > o){\\n            return false;\\n        }\\n        if(dp[i][o][c]!=-1)return dp[i][o][c];\\n        bool ans;\\n        if(s[i] == \\'*\\'){\\n            ans = solve(s,i+1,o,c) || \\n                    solve(s,i+1,o+1,c) ||\\n                    solve(s,i+1,o,c+1);\\n        } \\n        \\n        if(s[i] == \\'(\\'){\\n            ans = solve(s,i+1,o+1,c);\\n        }\\n    \\n        if(s[i] == \\')\\'){\\n            ans = solve(s,i+1,o,c+1);\\n        }\\n    \\n        return dp[i][o][c] = ans ;\\n    }\\n    \\n    bool checkValidString(string s) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(s,0,0,0);\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1795975,
                "title": "c-easy-stack-100-faster",
                "content": "**IDEA**\\n* Maintain  separate stracks for left brackets \\'(\\' and stars \\'\\\\*\\' to store the index values\\n* Answer will be true only if, finally the left bracket stack is empty.\\n* First, try to pop the index from the left bracket stack for each encounter of right bracket.\\n* if there is no index in the bracket stack then try to balance right bracket using the stars stack.\\n* Now, after traversing the string, if left bracket stack is still not empty, then try to empty it using stars stack and make sure that only those stars can pop left bracket which have higher index value than bracket.(i.e on the right side of bracket). and...\\n***Upvote : )***\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int n = s.length();\\n        stack <char> bracket, star;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(s[i] == \\'(\\')bracket.push(i);\\n            else if(s[i] == \\'*\\')star.push(i);\\n            else \\n            {\\n                if(!bracket.empty())\\n                    bracket.pop();\\n                else if(!star.empty())\\n                    star.pop();\\n                else\\n                    return false;\\n            }\\n        }\\n        if(!bracket.empty())\\n        {\\n            while(!bracket.empty() && !star.empty() && bracket.top() < star.top())\\n            {\\n                bracket.pop(); star.pop();\\n            }\\n        }\\n        return (bracket.empty())? true: false;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int n = s.length();\\n        stack <char> bracket, star;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(s[i] == \\'(\\')bracket.push(i);\\n            else if(s[i] == \\'*\\')star.push(i);\\n            else \\n            {\\n                if(!bracket.empty())\\n                    bracket.pop();\\n                else if(!star.empty())\\n                    star.pop();\\n                else\\n                    return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1724233,
                "title": "java-simple-stack-solution",
                "content": "class Solution {\\n    public boolean checkValidString(String s) {\\n      Stack<Integer> paran=new Stack<>();\\n      Stack<Integer> star=new Stack<>();\\n        \\n        for(int i=0; i< s.length();i++){\\n            char c= s.charAt(i);\\n            if(c==\\'(\\'){\\n                paran.push(i);\\n            }\\n            if(c==\\'*\\'){\\n                star.push(i);\\n            }\\n            if(c==\\')\\' && paran.size()==0 && star.size()==0){\\n                return false;\\n            }else if(c==\\')\\' && paran.size()>0){\\n                paran.pop();\\n            }else if(c==\\')\\' && star.size()>0){\\n                star.pop();\\n            }\\n        }\\n        if(!paran.isEmpty() && star.isEmpty()){\\n            return false;\\n        }\\n        while(!paran.isEmpty() ){\\n            int p= paran.pop();\\n            int st= star.pop();\\n            if(st<p || (!paran.isEmpty() && star.isEmpty())) return false;\\n            \\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public boolean checkValidString(String s) {\\n      Stack<Integer> paran=new Stack<>();\\n      Stack<Integer> star=new Stack<>();\\n        \\n        for(int i=0; i< s.length();i++){\\n            char c= s.charAt(i);\\n            if(c==\\'(\\'){\\n                paran.push(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1684781,
                "title": "c-100-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n      int ast=0,opened=0,closed=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'*\\')\\n            {\\n                ast++;\\n            }\\n            else if(s[i]==\\'(\\')\\n            {\\n                opened++;\\n            }\\n            else\\n            {\\n                closed++;\\n            }\\n            if(closed>ast+opened)\\n            {\\n                return false;\\n            }\\n        }\\n        ast=0,opened=0,closed=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'*\\')\\n            {\\n                ast++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                closed++;\\n            }\\n            else\\n            {\\n                opened++;\\n            }\\n            if(closed+ast<opened)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n      int ast=0,opened=0,closed=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'*\\')\\n            {\\n                ast++;\\n            }\\n            else if(s[i]==\\'(\\')\\n            {\\n                opened++;\\n            }\\n            else\\n            {\\n                closed++;\\n            }\\n            if(closed>ast+opened)\\n            {\\n                return false;\\n            }\\n        }\\n        ast=0,opened=0,closed=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'*\\')\\n            {\\n                ast++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                closed++;\\n            }\\n            else\\n            {\\n                opened++;\\n            }\\n            if(closed+ast<opened)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650405,
                "title": "c-left-to-right-right-to-left",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int n = s.length();\\n        \\n        //left to right: to balance unpaired \\')\\'\\n        int wildCard = 0;\\n        int balance = 0;\\n        for(int i=0;i<n;i++){\\n            balance += (s[i]==\\'(\\') - (s[i]==\\')\\');\\n            wildCard += (s[i]==\\'*\\');\\n            \\n            if(balance == -1){\\n                if(wildCard == 0)\\n                    return false;\\n                else\\n                    wildCard--;\\n                \\n                balance = 0;\\n            }\\n        }\\n        \\n        //right to let: to balance unpaired \\'(\\'\\n        wildCard=0;\\n        balance = 0;\\n        for(int i=n-1;i>=0;i--){\\n            balance += (s[i]==\\')\\') -(s[i]==\\'(\\');\\n            wildCard += (s[i]==\\'*\\');\\n            \\n            if(balance == -1){\\n                if(wildCard == 0)\\n                    return false;\\n                else\\n                    wildCard--;\\n                \\n                balance = 0;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int n = s.length();\\n        \\n        //left to right: to balance unpaired \\')\\'\\n        int wildCard = 0;\\n        int balance = 0;\\n        for(int i=0;i<n;i++){\\n            balance += (s[i]==\\'(\\') - (s[i]==\\')\\');\\n            wildCard += (s[i]==\\'*\\');\\n            \\n            if(balance == -1){\\n                if(wildCard == 0)\\n                    return false;\\n                else\\n                    wildCard--;\\n                \\n                balance = 0;\\n            }\\n        }\\n        \\n        //right to let: to balance unpaired \\'(\\'\\n        wildCard=0;\\n        balance = 0;\\n        for(int i=n-1;i>=0;i--){\\n            balance += (s[i]==\\')\\') -(s[i]==\\'(\\');\\n            wildCard += (s[i]==\\'*\\');\\n            \\n            if(balance == -1){\\n                if(wildCard == 0)\\n                    return false;\\n                else\\n                    wildCard--;\\n                \\n                balance = 0;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637889,
                "title": "100-faster-easy-to-understand-c-code",
                "content": "* ******Using Stack******\\n1. ***Time Complexity : O(N)***\\n2. ***Space Complexity : O(N)***\\n\\n```\\nbool checkValidString(string str) {\\n        int n = str.length();\\n        \\n        stack<int> open,star;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == \\'(\\')\\n            {\\n                open.push(i);\\n            }\\n            else\\n            {\\n                if(str[i] == \\'*\\')\\n                    star.push(i);\\n                else\\n                {\\n                    if(open.empty() == 0)\\n                        open.pop();\\n                    else if(star.empty() == 0)\\n                        star.pop();\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        \\n        while(open.empty() == false)\\n        {\\n            if(star.empty() == true)\\n                return false;\\n            else\\n            {\\n                if(open.top() < star.top())\\n                {\\n                    open.pop();\\n                    star.pop();\\n                }\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        if(open.empty() == true)\\n            return true;\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nbool checkValidString(string str) {\\n        int n = str.length();\\n        \\n        stack<int> open,star;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == \\'(\\')\\n            {\\n                open.push(i);\\n            }\\n            else\\n            {\\n                if(str[i] == \\'*\\')\\n                    star.push(i);\\n                else\\n                {\\n                    if(open.empty() == 0)\\n                        open.pop();\\n                    else if(star.empty() == 0)\\n                        star.pop();\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        \\n        while(open.empty() == false)\\n        {\\n            if(star.empty() == true)\\n                return false;\\n            else\\n            {\\n                if(open.top() < star.top())\\n                {\\n                    open.pop();\\n                    star.pop();\\n                }\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        if(open.empty() == true)\\n            return true;\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1600262,
                "title": "c-dp-soln",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int dp[105][105];\\n\\n    bool solve(string &s , int index , int open )\\n    {\\n        int n = s.length();\\n        if(open < 0) return false;\\n        if(index == n){\\n            if(open == 0) return true;\\n            return false;\\n        }\\n        bool ans = false;\\n        if(dp[index][open] != -1) return dp[index][open];\\n        if(s[index] == \\'(\\'){\\n            ans = ans | solve(s , index + 1 , open + 1 );\\n        }\\n        else if(s[index] == \\')\\'){\\n            ans = ans | solve(s , index + 1 , open - 1) ;\\n        }\\n        else if(s[index] == \\'*\\'){\\n            ans = ans | solve(s , index + 1 , open + 1 ) ;\\n            ans = ans | solve(s , index + 1 , open - 1);\\n            ans = ans | solve(s , index + 1 , open) ;\\n        }\\n        dp[index][open] = ans;\\n        return ans;\\n    }\\n\\n    bool checkValidString(string s) {\\n        memset(dp , -1 , sizeof dp) ;\\n        return solve(s , 0 , 0);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[105][105];\\n\\n    bool solve(string &s , int index , int open )\\n    {\\n        int n = s.length();\\n        if(open < 0) return false;\\n        if(index == n){\\n            if(open == 0) return true;\\n            return false;\\n        }\\n        bool ans = false;\\n        if(dp[index][open] != -1) return dp[index][open];\\n        if(s[index] == \\'(\\'){\\n            ans = ans | solve(s , index + 1 , open + 1 );\\n        }\\n        else if(s[index] == \\')\\'){\\n            ans = ans | solve(s , index + 1 , open - 1) ;\\n        }\\n        else if(s[index] == \\'*\\'){\\n            ans = ans | solve(s , index + 1 , open + 1 ) ;\\n            ans = ans | solve(s , index + 1 , open - 1);\\n            ans = ans | solve(s , index + 1 , open) ;\\n        }\\n        dp[index][open] = ans;\\n        return ans;\\n    }\\n\\n    bool checkValidString(string s) {\\n        memset(dp , -1 , sizeof dp) ;\\n        return solve(s , 0 , 0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457686,
                "title": "c-beat-100-stack-simple-solution",
                "content": "1. use two stacks to store the index of \\'(\\' and \\'*\\';\\n2. whenever encounter a \\')\\', first try to balance it with \\'(\\' stack, if not used from the wild card stack;\\n3. just need to make sure every index of of \\'(\\' is less than index of \\'*\\', simple pop stack element operation.\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) \\n    {\\n\\t\\t// two stacks to store the index of \\'(\\' and \\'*\\'\\n        stack<int> st1, st2;\\n        \\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] == \\'(\\')\\n            {\\n                st1.push(i);\\n            }\\n            else if (s[i] == \\')\\')\\n            {\\n\\t\\t\\t\\t// try to balance it with \\'(\\' firsrt \\n                if (st1.size() > 0)\\n                {\\n                    st1.pop();\\n                }\\n\\t\\t\\t\\t// if no enough \\'(\\', need to balane with wild card, or return false\\n                else if (st2.size() > 0)\\n                {\\n                    st2.pop();\\n                }\\n                else\\n                    return false;\\n            }\\n            else if (s[i] == \\'*\\')\\n                st2.push(i);\\n        }\\n        if (st1.size() > st2.size())\\n            return false;\\n        \\n\\t\\t// every index of \\'(\\' should be less than that of \\'*\\'\\n        while(st1.size())\\n        {\\n            if (st1.top() > st2.top())\\n                return false;\\n            else\\n            {\\n                st1.pop();\\n                st2.pop();\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) \\n    {\\n\\t\\t// two stacks to store the index of \\'(\\' and \\'*\\'\\n        stack<int> st1, st2;\\n        \\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] == \\'(\\')\\n            {\\n                st1.push(i);\\n            }\\n            else if (s[i] == \\')\\')\\n            {\\n\\t\\t\\t\\t// try to balance it with \\'(\\' firsrt \\n                if (st1.size() > 0)\\n                {\\n                    st1.pop();\\n                }\\n\\t\\t\\t\\t// if no enough \\'(\\', need to balane with wild card, or return false\\n                else if (st2.size() > 0)\\n                {\\n                    st2.pop();\\n                }\\n                else\\n                    return false;\\n            }\\n            else if (s[i] == \\'*\\')\\n                st2.push(i);\\n        }\\n        if (st1.size() > st2.size())\\n            return false;\\n        \\n\\t\\t// every index of \\'(\\' should be less than that of \\'*\\'\\n        while(st1.size())\\n        {\\n            if (st1.top() > st2.top())\\n                return false;\\n            else\\n            {\\n                st1.pop();\\n                st2.pop();\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436489,
                "title": "c-o-n-time-o-1-space-greedy-solution",
                "content": "For a string to be valid parenthesis ,a open bracket should have a corresponding closing bracket to it and in similar way a closing bracket should have a corresponding open bracket for it this is what we check for in a normal parenthesis.\\nBut as now we have stars so we can use them to validate parenthesis.\\n1.)a star appearing before a open parenthesis is of no use to it but we can use it for closing bracket so we will store it as star,\\n2.)a star appearing after open bracket can be used as closing bracket now, if we use it now and a corresponding closing bracket appears we will left with no open bracket, so what we will do we use it as closing bracket and store it as used, now if  a corresponding closing bracket appears we will decrese use and will free star for furthur use.\\n\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int open=0,star=0,used=0;\\n        \\n        for(char i:s)\\n        {\\n            if(i==\\'(\\')\\n            {\\n                open++;\\n            }\\n            else if(i==\\'*\\')\\n            {\\n                if(open>0)\\n                {\\n                    used++;\\n                    open--;\\n                }\\n                else\\n                {\\n                    star++;\\n                }\\n            }\\n            else\\n            {\\n                if(open>0)\\n                {\\n                    open--;\\n                }\\n                else if(star>0)\\n                {\\n                    star--;\\n                }\\n                else if(used>0)\\n                {\\n                    used--;\\n                    star++;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        if(open==0)\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int open=0,star=0,used=0;\\n        \\n        for(char i:s)\\n        {\\n            if(i==\\'(\\')\\n            {\\n                open++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1430829,
                "title": "cpp-fastest-soluiton-easy-to-undrestand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        \\n        stack<int>open,star;\\n        \\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s[i]==\\'(\\') open.push(i);\\n            \\n            else if(s[i]==\\'*\\') star.push(i);\\n            \\n            else{\\n                \\n                if(!open.empty()) open.pop();\\n                \\n                else {\\n                    if(!star.empty()) star.pop();\\n                    \\n                    else return false;\\n                }\\n                \\n            }\\n        }\\n        \\n        // Balancing the remaining open brackets\\n        \\n        while(!open.empty()){\\n            \\n            if(star.empty()) return false;\\n            \\n            else{\\n                \\n                if(open.top() < star.top()){\\n                    open.pop();\\n                    star.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        \\n        stack<int>open,star;\\n        \\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s[i]==\\'(\\') open.push(i);\\n            \\n            else if(s[i]==\\'*\\') star.push(i);\\n            \\n            else{\\n                \\n                if(!open.empty()) open.pop();\\n                \\n                else {\\n                    if(!star.empty()) star.pop();\\n                    \\n                    else return false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1421748,
                "title": "simple-greedy-based-java-solution-explained-case-to-case-using-comments-time-o-n",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(1)\\n\\nThis is the greedy based solution\\n\\n```\\npublic boolean checkValidString(String s) {\\n        //low: left bracket, smallest possible number of \\'(\\'\\n        //high: possible right brackets, largest possible number of \\'(\\'\\n        int low=0,high=0;\\n        \\n        for(char ch: s.toCharArray()){\\n            if(ch==\\'(\\'){\\n                low++;\\n            } else {\\n                low--;\\n            }\\n            \\n            if(ch!=\\')\\'){\\n                high++;\\n            } else {\\n                high--;\\n            }\\n            \\n            if(high<0){//we have no left brackets or more closing brackets before opening brackets\\n                break;\\n            }\\n            \\n            low = Math.max(0, low); //this will avoid low having negative values, because having negative left bracket makes no sense at all\\n            \\n        }\\n        return low==0;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\npublic boolean checkValidString(String s) {\\n        //low: left bracket, smallest possible number of \\'(\\'\\n        //high: possible right brackets, largest possible number of \\'(\\'\\n        int low=0,high=0;\\n        \\n        for(char ch: s.toCharArray()){\\n            if(ch==\\'(\\'){\\n                low++;\\n            } else {\\n                low--;\\n            }\\n            \\n            if(ch!=\\')\\'){\\n                high++;\\n            } else {\\n                high--;\\n            }\\n            \\n            if(high<0){//we have no left brackets or more closing brackets before opening brackets\\n                break;\\n            }\\n            \\n            low = Math.max(0, low); //this will avoid low having negative values, because having negative left bracket makes no sense at all\\n            \\n        }\\n        return low==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240635,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) \\n    {\\n        int left=0,star=0,right=0,i,n=s.size();\\n        for(i=0;i<n;i++){\\n            if(s[i]==\\'(\\') left++;\\n            else if(s[i]==\\')\\') right++;\\n            else if(s[i]==\\'*\\') star++;\\n            if(left+star<right) return 0;\\n        }\\n        left=0; star=0; right=0;\\n        for(i=n-1;i>=0;i--){\\n            if(s[i]==\\'(\\') left++;\\n            else if(s[i]==\\')\\') right++;\\n            else if(s[i]==\\'*\\') star++;\\n            if(right+star<left) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) \\n    {\\n        int left=0,star=0,right=0,i,n=s.size();\\n        for(i=0;i<n;i++){\\n            if(s[i]==\\'(\\') left++;\\n            else if(s[i]==\\')\\') right++;\\n            else if(s[i]==\\'*\\') star++;\\n            if(left+star<right) return 0;\\n        }\\n        left=0; star=0; right=0;\\n        for(i=n-1;i>=0;i--){\\n            if(s[i]==\\'(\\') left++;\\n            else if(s[i]==\\')\\') right++;\\n            else if(s[i]==\\'*\\') star++;\\n            if(right+star<left) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235658,
                "title": "constant-space-o-n",
                "content": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        if(s == null || s.length() == 0) return true;\\n        int openCount = 0;\\n        int starCount = 0;\\n        int openMatchedWithStar = 0;\\n        for(int i=0; i<s.length(); i++) {\\n            char currentChar = s.charAt(i);\\n            if(currentChar == \\')\\') {\\n                if(openCount > 0) { // first match it against any existing open bracket\\n                    openCount --;\\n                    continue;\\n                }\\n                if(openMatchedWithStar > 0) { // next check if an open bracket was eagerly matched with a star. \\n                    starCount++;              // Make the star available. \\n                    openMatchedWithStar--;    // reduce the count of open brackets eagerly matched with a star\\n                    continue;\\n                }\\n                if(starCount > 0) { // if none above then look for a stary star appeared before to match against.\\n                    starCount --;\\n                    continue;\\n                }\\n                return false; // if none of the above then current close bracket is unbalanced.\\n            }\\n            if(currentChar == \\'*\\') {\\n                if(openCount > 0) { // if there are open brackets available then eagerly match the current star with that.\\n                    openCount--;\\n                    openMatchedWithStar ++;\\n                } else\\n                    starCount++;\\n            }\\n            if(currentChar == \\'(\\') \\n                openCount++;\\n        }\\n        return openCount == 0; // make sure there are no left over open brackets.\\n    }\\n} \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        if(s == null || s.length() == 0) return true;\\n        int openCount = 0;\\n        int starCount = 0;\\n        int openMatchedWithStar = 0;\\n        for(int i=0; i<s.length(); i++) {\\n            char currentChar = s.charAt(i);\\n            if(currentChar == \\')\\') {\\n                if(openCount > 0) { // first match it against any existing open bracket\\n                    openCount --;\\n                    continue;\\n                }\\n                if(openMatchedWithStar > 0) { // next check if an open bracket was eagerly matched with a star. \\n                    starCount++;              // Make the star available. \\n                    openMatchedWithStar--;    // reduce the count of open brackets eagerly matched with a star\\n                    continue;\\n                }\\n                if(starCount > 0) { // if none above then look for a stary star appeared before to match against.\\n                    starCount --;\\n                    continue;\\n                }\\n                return false; // if none of the above then current close bracket is unbalanced.\\n            }\\n            if(currentChar == \\'*\\') {\\n                if(openCount > 0) { // if there are open brackets available then eagerly match the current star with that.\\n                    openCount--;\\n                    openMatchedWithStar ++;\\n                } else\\n                    starCount++;\\n            }\\n            if(currentChar == \\'(\\') \\n                openCount++;\\n        }\\n        return openCount == 0; // make sure there are no left over open brackets.\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216428,
                "title": "c-easy-dp-recursive-approach",
                "content": "```\\nbool fun(string s,int pos,int count,int dp[][101])\\n    {\\n        int i=pos;\\n        if(pos>=s.size()) \\n        {  \\n            if(count==0) return true;\\n            else return false;\\n        }\\n        if(count<0) return false;\\n        if(dp[pos][count]!=-1) return dp[pos][count];\\n        if(s[i]==\\'(\\')\\n        {\\n            return dp[pos][count]=fun(s,pos+1,count+1,dp);\\n        }\\n        else if(s[i]==\\')\\')\\n        {\\n            return dp[pos][count]=fun(s,pos+1,count-1,dp);\\n        }\\n        else\\n        {   \\n            bool a=fun(s,pos+1,count+1,dp);\\n            bool b=fun(s,pos+1,count,dp);\\n            bool c=fun(s,pos+1,count-1,dp);\\n            bool tem=(a||b||c);\\n            return dp[pos][count]=tem;\\n        }\\n    }\\n    bool checkValidString(string s) {\\n        int count=0;\\n        int dp[101][101];\\n        for(int i=0;i<101;i++) for(int j=0;j<101;j++) dp[i][j]=-1;\\n       return  fun(s,0,count,dp);\\n    }\\n```\\nIf you liked the code, Give it a **Thumbs Up** !!!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nbool fun(string s,int pos,int count,int dp[][101])\\n    {\\n        int i=pos;\\n        if(pos>=s.size()) \\n        {  \\n            if(count==0) return true;\\n            else return false;\\n        }\\n        if(count<0) return false;\\n        if(dp[pos][count]!=-1) return dp[pos][count];\\n        if(s[i]==\\'(\\')\\n        {\\n            return dp[pos][count]=fun(s,pos+1,count+1,dp);\\n        }\\n        else if(s[i]==\\')\\')\\n        {\\n            return dp[pos][count]=fun(s,pos+1,count-1,dp);\\n        }\\n        else\\n        {   \\n            bool a=fun(s,pos+1,count+1,dp);\\n            bool b=fun(s,pos+1,count,dp);\\n            bool c=fun(s,pos+1,count-1,dp);\\n            bool tem=(a||b||c);\\n            return dp[pos][count]=tem;\\n        }\\n    }\\n    bool checkValidString(string s) {\\n        int count=0;\\n        int dp[101][101];\\n        for(int i=0;i<101;i++) for(int j=0;j<101;j++) dp[i][j]=-1;\\n       return  fun(s,0,count,dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1169463,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[109][109];\\n    bool find(string &s,int i,int open)\\n    {\\n        if(open<0)\\n        {\\n            return 0;\\n        }\\n        if(i==s.size())\\n        {\\n            return open==0;\\n        }\\n        if(dp[i][open]!=-1)\\n        {\\n            return dp[i][open];\\n        }\\n        if(s[i]==\\'(\\')\\n        {\\n           dp[i][open]=find(s,i+1,open+1);\\n        }\\n        else if(s[i]==\\')\\')\\n        {\\n            dp[i][open]=find(s,i+1,open-1);\\n        }\\n        else\\n        {\\n            dp[i][open]=find(s,i+1,open-1)||find(s,i+1,open)||find(s,i+1,open+1);\\n        }\\n        return dp[i][open];\\n    }\\n    bool checkValidString(string s)\\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return find(s,0,0)==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[109][109];\\n    bool find(string &s,int i,int open)\\n    {\\n        if(open<0)\\n        {\\n            return 0;\\n        }\\n        if(i==s.size())\\n        {\\n            return open==0;\\n        }\\n        if(dp[i][open]!=-1)\\n        {\\n            return dp[i][open];\\n        }\\n        if(s[i]==\\'(\\')\\n        {\\n           dp[i][open]=find(s,i+1,open+1);\\n        }\\n        else if(s[i]==\\')\\')\\n        {\\n            dp[i][open]=find(s,i+1,open-1);\\n        }\\n        else\\n        {\\n            dp[i][open]=find(s,i+1,open-1)||find(s,i+1,open)||find(s,i+1,open+1);\\n        }\\n        return dp[i][open];\\n    }\\n    bool checkValidString(string s)\\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return find(s,0,0)==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135223,
                "title": "cpp-without-stack-runtime-beats-100-of-cpp-solutions-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int l=0, r=0, a=0, x=1;\\n        for(int i=0; s[i]; i++)\\n        {\\n            if(s[i] == \\'(\\')++l;\\n            else if(s[i] == \\')\\')\\n            {\\n                if(l>0)--l;\\n                else if(a>0)--a;\\n                else x=0;\\n            }\\n            else ++a;\\n        }\\n        \\n        // checking open bracket\\n        l=0, a=0; \\n        int x1=1;\\n        for(int i=s.length()-1; i>=0; i--)\\n        {\\n            if(s[i] == \\')\\')++l;\\n            else if(s[i] == \\'(\\')\\n            {\\n                if(l>0)--l;\\n                else if(a>0)--a;\\n                else x1=0;\\n            }\\n            else ++a;\\n        }\\n\\n        \\n        if(x&&x1)return true;\\n        else return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        int l=0, r=0, a=0, x=1;\\n        for(int i=0; s[i]; i++)\\n        {\\n            if(s[i] == \\'(\\')++l;\\n            else if(s[i] == \\')\\')\\n            {\\n                if(l>0)--l;\\n                else if(a>0)--a;\\n                else x=0;\\n            }\\n            else ++a;\\n        }\\n        \\n        // checking open bracket\\n        l=0, a=0; \\n        int x1=1;\\n        for(int i=s.length()-1; i>=0; i--)\\n        {\\n            if(s[i] == \\')\\')++l;\\n            else if(s[i] == \\'(\\')\\n            {\\n                if(l>0)--l;\\n                else if(a>0)--a;\\n                else x1=0;\\n            }\\n            else ++a;\\n        }\\n\\n        \\n        if(x&&x1)return true;\\n        else return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102371,
                "title": "python-3-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        stack=[]\\n        for i in s:\\n            if i==\\'(\\':\\n                stack.append(i)\\n            elif i==\\'*\\':\\n                stack.append(\\'*\\')\\n            else:\\n                if len(stack)!=0:\\n                    if stack[-1]==\\'(\\':\\n                        stack.pop()\\n                    elif stack[-1]==\\'*\\':\\n                        tiwari=False\\n                        j=len(stack)-1\\n                        while j>=0:\\n                            if stack[j]==\\'(\\':\\n                                tiwari=True\\n                                break\\n                            j-=1\\n                        if tiwari==True:\\n                            stack.pop(j)\\n                        else:\\n                            stack.pop()\\n                else:\\n                    return False\\n        stack1=[]\\n        for i in stack:\\n            if i==\\'(\\':\\n                stack1.append(i)\\n            elif i==\\'*\\':\\n                if len(stack1)!=0:\\n                    stack1.pop()\\n        if len(stack1)!=0:\\n            return False\\n\\n        return True\\n\\n\\n\\n\\n## Thanks\\t\\t\\n\\t\\t\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        stack=[]\\n        for i in s:\\n            if i==\\'(\\':\\n                stack.append(i)\\n            elif i==\\'*\\':\\n                stack.append(\\'*\\')\\n            else:\\n                if len(stack)!=0:\\n                    if stack[-1]==\\'(\\':\\n                        stack.pop()\\n                    elif stack[-1]==\\'*\\':\\n                        tiwari=False\\n                        j=len(stack)-1\\n                        while j>=0:\\n                            if stack[j]==\\'(\\':\\n                                tiwari=True\\n                                break\\n                            j-=1\\n                        if tiwari==True:\\n                            stack.pop(j)\\n                        else:\\n                            stack.pop()\\n                else:\\n                    return False\\n        stack1=[]\\n        for i in stack:\\n            if i==\\'(\\':\\n                stack1.append(i)\\n            elif i==\\'*\\':\\n                if len(stack1)!=0:\\n                    stack1.pop()\\n        if len(stack1)!=0:\\n            return False\\n\\n        return True\\n\\n\\n\\n\\n## Thanks\\t\\t\\n\\t\\t\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989891,
                "title": "python-10-lines-beats-80",
                "content": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        counts = {0}\\n        for ch in s:\\n            if ch == \"(\":\\n                counts = set(prev+1 for prev in counts)\\n            elif ch == \")\":\\n                counts = set(prev-1 for prev in counts if prev > 0)\\n            elif ch == \"*\":\\n                counts = set([prev+1 for prev in counts] + [prev-1 for prev in counts] + list(counts))\\n        return 0 in counts\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n        counts = {0}\\n        for ch in s:\\n            if ch == \"(\":\\n                counts = set(prev+1 for prev in counts)\\n            elif ch == \")\":\\n                counts = set(prev-1 for prev in counts if prev > 0)\\n            elif ch == \"*\":\\n                counts = set([prev+1 for prev in counts] + [prev-1 for prev in counts] + list(counts))\\n        return 0 in counts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975045,
                "title": "python-easy-to-understand-o-n",
                "content": "Python Easy to understand O(N)\\n```\\nclass Solution(object):\\n    def checkValidString(self, s):\\n        # stack\\n        stk_o = [] # for openbracket  ( - stores index\\n        stk_s = [] # for asterisk     * - stores index\\n        stk_c = [] # for closebracket ) - stores index of brackets which has no open bracket\\n        for i in range(len(s)):\\n            e = s[i]\\n            if e == \\'(\\' :\\n                stk_o.append(i)\\n            elif e == \\')\\' and stk_o:\\n                stk_o.pop()\\n            elif e == \\')\\' and not stk_o:\\n                stk_c.append(i)\\n            elif e == \\'*\\':\\n                stk_s.append(i)\\n        # less number of asterisks than remaining brackets - QUICK RETURN\\n        if len(stk_s) < len(stk_c) + len(stk_o) : return(False)\\n        else :\\n            # loop through asterisk stack and compare index with other two stacks\\n            # if not understood then print all three stacks before this loop.\\n            for i in stk_s :\\n                if stk_c :\\n                    if i < stk_c[0] : \\n                        stk_c.pop(0)\\n                if stk_o :\\n                    if i > stk_o[0] : \\n                        stk_o.pop(0)\\n            if not stk_c and not stk_o : return(True)\\n            else : return(False)\\n\\t\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def checkValidString(self, s):\\n        # stack\\n        stk_o = [] # for openbracket  ( - stores index\\n        stk_s = [] # for asterisk     * - stores index\\n        stk_c = [] # for closebracket ) - stores index of brackets which has no open bracket\\n        for i in range(len(s)):\\n            e = s[i]\\n            if e == \\'(\\' :\\n                stk_o.append(i)\\n            elif e == \\')\\' and stk_o:\\n                stk_o.pop()\\n            elif e == \\')\\' and not stk_o:\\n                stk_c.append(i)\\n            elif e == \\'*\\':\\n                stk_s.append(i)\\n        # less number of asterisks than remaining brackets - QUICK RETURN\\n        if len(stk_s) < len(stk_c) + len(stk_o) : return(False)\\n        else :\\n            # loop through asterisk stack and compare index with other two stacks\\n            # if not understood then print all three stacks before this loop.\\n            for i in stk_s :\\n                if stk_c :\\n                    if i < stk_c[0] : \\n                        stk_c.pop(0)\\n                if stk_o :\\n                    if i > stk_o[0] : \\n                        stk_o.pop(0)\\n            if not stk_c and not stk_o : return(True)\\n            else : return(False)\\n\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 935335,
                "title": "java-solution-using-two-stacks-o-n-time-and-o-n-space-beats-100",
                "content": "Idea is to use two stacks one to store indices of *(sstack) and other to store indices of **(** (cstack). \\nWhen we find **)**, we simply look for  cstack and if found remove it and if not take one from cstack if not empty.\\nAfter all chars are done, try to match each **(** in cstack with * in sstack, if index of * is greater than **(** which signifies that * appeared after a give **(** in original string. \\n\\n```\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> cstack = new Stack<>();\\n        Stack<Integer> sstack = new Stack<>();\\n        char[] ca = s.toCharArray();\\n        for(int i = 0; i < ca.length; i++){\\n            if(ca[i] == \\'(\\')\\n                cstack.push(i);\\n            else if(ca[i] == \\'*\\')\\n                sstack.push(i);\\n            else{\\n                Stack<Integer> us = cstack.empty() ? sstack : cstack;\\n                if(us.empty()) return false;\\n                us.pop();                    \\n            }\\n        }\\n        while(!cstack.empty()){\\n            if(sstack.empty() || sstack.peek() < cstack.peek()) return false;\\n            cstack.pop();\\n            sstack.pop();\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> cstack = new Stack<>();\\n        Stack<Integer> sstack = new Stack<>();\\n        char[] ca = s.toCharArray();\\n        for(int i = 0; i < ca.length; i++){\\n            if(ca[i] == \\'(\\')\\n                cstack.push(i);\\n            else if(ca[i] == \\'*\\')\\n                sstack.push(i);\\n            else{\\n                Stack<Integer> us = cstack.empty() ? sstack : cstack;\\n                if(us.empty()) return false;\\n                us.pop();                    \\n            }\\n        }\\n        while(!cstack.empty()){\\n            if(sstack.empty() || sstack.peek() < cstack.peek()) return false;\\n            cstack.pop();\\n            sstack.pop();\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 910506,
                "title": "python-stack-straightforward-with-explanation",
                "content": "Basic idea is to have two stacks to record the position of \\'(\\' and \"\\\\*\". \\nStep 1: When a \\')\\' comes, we first serve it using \\'(\\', unless we have an empty stack for \\'(\\', in which case, we use the star stack.\\nStep 2: After going thru s, we check the elements left in \\'(\\' stack and \\'\\\\*\\' stack. Now \\'\\\\*\\' can be used as \\')\\', but we need to make sure that the \\'\\\\*\\' position come after corresponding \\'(\\' position in \\'(\\' stack.\\n\\n```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n\\t\\t# deque for \\'(\\' positions\\n        left = collections.deque()\\n\\t\\t# deque for \\'*\\' positions\\n        star = collections.deque()\\n        \\n        for i, c in enumerate(s):\\n            if c == \"(\":\\n                left.append(i)\\n            elif c == \"*\":\\n                star.append(i)\\n            else:\\n                if left:\\n                    left.pop()\\n                else:\\n                    if star:\\n                        star.popleft()\\n                    else:\\n                        return False\\n            \\n        while left: \\n\\t\\t\\t# if we still have \\'(\\' remaining in stack, we need to match them with remaining \\'*\\'\\n            idx = left.popleft()\\n            while star and star[0] < idx:\\n                star.popleft()\\n            if not star:\\n                return False\\n            star.popleft()\\n            \\n        return True",
                "solutionTags": [],
                "code": "Basic idea is to have two stacks to record the position of \\'(\\' and \"\\\\*\". \\nStep 1: When a \\')\\' comes, we first serve it using \\'(\\', unless we have an empty stack for \\'(\\', in which case, we use the star stack.\\nStep 2: After going thru s, we check the elements left in \\'(\\' stack and \\'\\\\*\\' stack. Now \\'\\\\*\\' can be used as \\')\\', but we need to make sure that the \\'\\\\*\\' position come after corresponding \\'(\\' position in \\'(\\' stack.\\n\\n```\\nclass Solution:\\n    def checkValidString(self, s: str) -> bool:\\n\\t\\t# deque for \\'(\\' positions\\n        left = collections.deque()\\n\\t\\t# deque for \\'*\\' positions\\n        star = collections.deque()\\n        \\n        for i, c in enumerate(s):\\n            if c == \"(\":\\n                left.append(i)\\n            elif c == \"*\":\\n                star.append(i)\\n            else:\\n                if left:\\n                    left.pop()\\n                else:\\n                    if star:\\n                        star.popleft()\\n                    else:\\n                        return False\\n            \\n        while left: \\n\\t\\t\\t# if we still have \\'(\\' remaining in stack, we need to match them with remaining \\'*\\'\\n            idx = left.popleft()\\n            while star and star[0] < idx:\\n                star.popleft()\\n            if not star:\\n                return False\\n            star.popleft()\\n            \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 866899,
                "title": "o-n-python-solution-with-clear-explanation",
                "content": "Thought process: think as if you are walking on x axis, if you found \"(\" then you move one step forward,\\nif you found \")\" then you move one step backward, and if you found \"*\" then you can move either one step forward or on step back ward or stay in the same place as you are at that point of time.\\n\\nIf the given string can be made to have balanced parenthesis, then you should be at \\'0\\' after traversing all the string.\\n\\nIf the problem is a simple verify balanced parenthesis string without any \"*\", then after reading every character in string\\nwe can deterministicaly say that we will be at particular single point on x axis after reading that.\\nBut in this problem we also have \"*\", so due to this we will have a range of positions that we can possibly be at on x axis\\nafter reading a particular character as \"*\" lead us to one step back or same position or one step forward.\\n\\nso, if 0 is present in the range of positions after reading all charcters then we can make the string balanced.\\nand make sure that the range of positions does not completely lie below zero while reading characters(This situation happens when no of closing brackets are more than opening brackets even if we use \\'*\\'s to compensate).\\nNote: remember to only consider the ranges with left>=0, as we dont want negative positions as negative positions represent loss of balance.\\n\\n\\n```\\ndef checkValidString(self, s: str) -> bool:\\n        left = 0\\n        right = 0\\n        for c in s:\\n            if c == \"(\":\\n                left += 1\\n                right += 1\\n\\n            elif c == \")\":\\n                left = max(left-1,0)\\n                right -= 1\\n            elif c == \"*\":\\n                left = max(left-1,0)\\n                right += 1\\n            if right < 0:\\n                    return False\\n                \\n        if left<=0 and 0<=right:\\n            return True\\n        return False\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef checkValidString(self, s: str) -> bool:\\n        left = 0\\n        right = 0\\n        for c in s:\\n            if c == \"(\":\\n                left += 1\\n                right += 1\\n\\n            elif c == \")\":\\n                left = max(left-1,0)\\n                right -= 1\\n            elif c == \"*\":\\n                left = max(left-1,0)\\n                right += 1\\n            if right < 0:\\n                    return False\\n                \\n        if left<=0 and 0<=right:\\n            return True\\n        return False\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 859608,
                "title": "java-2-stacks-solution-o-n",
                "content": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        // stack holds indices of open parens\\n        Stack<Integer> stack = new Stack();\\n        // indices holds indices of * \\n        Stack<Integer> wildCards = new Stack();\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            // Simply push the index of open paren (which is meaningless)\\n            if(s.charAt(i) == \\'(\\'){\\n                stack.push(i);\\n            }\\n            \\n            else if(s.charAt(i) == \\')\\'){\\n                // Can pop off a matching paren\\n                if(!stack.isEmpty()){\\n                    stack.pop();\\n                }\\n                // We have a wildcard we can use (that has occured before index i)\\n                else if(!wildCards.isEmpty()){\\n                    wildCards.pop();\\n                }\\n                // No wildcards or matching parens\\n                else{\\n                    return false;\\n                }\\n            }\\n            // Add to wildcard\\n            else{\\n                wildCards.push(i);\\n            }\\n        }\\n        \\n        // Not enough wildcards \\n        if(stack.size() > wildCards.size()) return false;\\n        \\n        // This is where we need the indices to see if the wildcards come AFTER the open parens\\n        while(!stack.isEmpty()){\\n            if(stack.peek() < wildCards.peek()){\\n                stack.pop();\\n                wildCards.pop();\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        // stack holds indices of open parens\\n        Stack<Integer> stack = new Stack();\\n        // indices holds indices of * \\n        Stack<Integer> wildCards = new Stack();\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            // Simply push the index of open paren (which is meaningless)\\n            if(s.charAt(i) == \\'(\\'){\\n                stack.push(i);\\n            }\\n            \\n            else if(s.charAt(i) == \\')\\'){\\n                // Can pop off a matching paren\\n                if(!stack.isEmpty()){\\n                    stack.pop();\\n                }\\n                // We have a wildcard we can use (that has occured before index i)\\n                else if(!wildCards.isEmpty()){\\n                    wildCards.pop();\\n                }\\n                // No wildcards or matching parens\\n                else{\\n                    return false;\\n                }\\n            }\\n            // Add to wildcard\\n            else{\\n                wildCards.push(i);\\n            }\\n        }\\n        \\n        // Not enough wildcards \\n        if(stack.size() > wildCards.size()) return false;\\n        \\n        // This is where we need the indices to see if the wildcards come AFTER the open parens\\n        while(!stack.isEmpty()){\\n            if(stack.peek() < wildCards.peek()){\\n                stack.pop();\\n                wildCards.pop();\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753123,
                "title": "c-solution-using-stack-faster-than-100",
                "content": "So the main problem in this question is to determine weather to take \\'*\\' as empty string or left parenthesis or right parenthisis.\\nIt can be done using two stacks:\\n1. s1=To store the indices of all left parenthisis\\n2. s2=To store indices all asteric.\\nWe would first try to balance the right parenthisis i.e number of right parenthisis should be less than the number of left parenthisis.\\nIn this case asteric can only behave as empty or left parenthisis.\\nWe would pop an element from s1 everytime we get a right parenthisis.\\nif the right parenthisis are balanced we would balance the left paranthesis.\\nThis situation will only arise if size of stack s1 is greater than zero.\\nNow the situation is totally opposite now asteric can behave only as empty or right parentheisis.For every star a left parenthesis will be balanced.\\nNow here is the catch**We could have also stored the characters in the stack but why did we store the indices?\\nThis is because every right parenthesis occurs after its left parenthesis hence in order to keep a check on their position indices are used**\\nConsider these situations\\n*  \"****((\"\\n*  \"((***\"\\n*  \"))***\"\\n*  \"*)( *\"\\n\\nThink about this situation yourself\\nFor better understanding the code is available\\n```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        if(s.size()==0)\\n            return true;\\n        stack <int> s1;\\n        stack <int> s2;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\')\\n                s1.push(i);\\n            if(s[i]==\\'*\\')\\n                s2.push(i);\\n            if(s[i]==\\')\\'){\\n                if(s1.size()==0 && s2.size()==0)\\n                    return false;\\n                else if(s1.size()==0)\\n                    s2.pop();\\n                else\\n                    s1.pop();\\n            }\\n        }\\n        if(s1.size()==0)\\n            return true;\\n        while(s2.size()!=0){\\n             if(s1.size()==0)\\n                return true;\\n            else if(s1.top()<s2.top()){\\n                s1.pop();\\n                s2.pop();\\n            }\\n             \\n            else if(s1.top()>s2.top())\\n                return false;\\n          \\n        }\\n        if(s1.size()==0)\\n        return true;\\n        else\\n            return false;\\n\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidString(string s) {\\n        if(s.size()==0)\\n            return true;\\n        stack <int> s1;\\n        stack <int> s2;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\')\\n                s1.push(i);\\n            if(s[i]==\\'*\\')\\n                s2.push(i);\\n            if(s[i]==\\')\\'){\\n                if(s1.size()==0 && s2.size()==0)\\n                    return false;\\n                else if(s1.size()==0)\\n                    s2.pop();\\n                else\\n                    s1.pop();\\n            }\\n        }\\n        if(s1.size()==0)\\n            return true;\\n        while(s2.size()!=0){\\n             if(s1.size()==0)\\n                return true;\\n            else if(s1.top()<s2.top()){\\n                s1.pop();\\n                s2.pop();\\n            }\\n             \\n            else if(s1.top()>s2.top())\\n                return false;\\n          \\n        }\\n        if(s1.size()==0)\\n        return true;\\n        else\\n            return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584776,
                "title": "simple-java-solution-in-o-n-o-1",
                "content": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int balance=0;\\n        for(int i=0;i<s.length();i++){\\n            if(String.valueOf(s.charAt(i)).equals(\"(\")||String.valueOf(s.charAt(i)).equals(\"*\"))\\n                balance++;\\n            \\n            else if(--balance<0)\\n                return false;\\n        }\\n        balance=0;\\n         for(int i=s.length()-1;i>=0;i--){\\n            if(String.valueOf(s.charAt(i)).equals(\")\")||String.valueOf(s.charAt(i)).equals(\"*\"))\\n                balance++;\\n            else if(--balance<0)\\n                return false;\\n        }\\n        return true;\\n       \\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int balance=0;\\n        for(int i=0;i<s.length();i++){\\n            if(String.valueOf(s.charAt(i)).equals(\"(\")||String.valueOf(s.charAt(i)).equals(\"*\"))\\n                balance++;\\n            \\n            else if(--balance<0)\\n                return false;\\n        }\\n        balance=0;\\n         for(int i=s.length()-1;i>=0;i--){\\n            if(String.valueOf(s.charAt(i)).equals(\")\")||String.valueOf(s.charAt(i)).equals(\"*\"))\\n                balance++;\\n            else if(--balance<0)\\n                return false;\\n        }\\n        return true;\\n       \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583606,
                "title": "python-two-stacks-beats-90-in-time-complexity-with-clear-explaination-in-comments",
                "content": "```\\nclass Solution(object):\\n    def checkValidString(self, s):\\n        left_stack, star_stack = list(), list()\\n        for index, letter in enumerate(s):\\n            if letter == \"(\":\\n                left_stack.append(index)\\n            elif letter == \"*\":\\n                star_stack.append(index)\\n            else:\\n                \"\"\"\\n                if extra \\'(\\' is in there, pop it off\\n                \"\"\"\\n                if left_stack:\\n                    left_stack.pop()\\n                elif star_stack: # if no extra \\'(\\' is present, use \\'*\\' as \\'(\\', match and pop off\\n                    star_stack.pop()\\n                else:\\n                    return False\\n\\n        if not left_stack:\\n            \"\"\"\\n            if no open \\'(\\' is present, all \\'*\\' are left as open blanks, hence return true\\n            \"\"\"\\n            return True\\n        else:\\n            \"\"\"we have to check otherwise, if * can be used to close an open bracket or not.\\n            ie, if star is present before open bracket, then its of no use to close, we will use it \\n            as a space, only if it is present after the index of first element in left_stack, it can be \\n            converted as a closing bracket and can be used.\\n            \"\"\"\\n\\n            first_elem = left_stack[0]\\n            while star_stack:\\n                if star_stack[0] < first_elem:\\n                    star_stack.pop(0)\\n                else:\\n                    star_stack.pop(0)\\n                    left_stack.pop(0)\\n                    if left_stack:\\n                        first_elem = left_stack[0]\\n                    else:\\n                        return True\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def checkValidString(self, s):\\n        left_stack, star_stack = list(), list()\\n        for index, letter in enumerate(s):\\n            if letter == \"(\":\\n                left_stack.append(index)\\n            elif letter == \"*\":\\n                star_stack.append(index)\\n            else:\\n                \"\"\"\\n                if extra \\'(\\' is in there, pop it off\\n                \"\"\"\\n                if left_stack:\\n                    left_stack.pop()\\n                elif star_stack: # if no extra \\'(\\' is present, use \\'*\\' as \\'(\\', match and pop off\\n                    star_stack.pop()\\n                else:\\n                    return False\\n\\n        if not left_stack:\\n            \"\"\"\\n            if no open \\'(\\' is present, all \\'*\\' are left as open blanks, hence return true\\n            \"\"\"\\n            return True\\n        else:\\n            \"\"\"we have to check otherwise, if * can be used to close an open bracket or not.\\n            ie, if star is present before open bracket, then its of no use to close, we will use it \\n            as a space, only if it is present after the index of first element in left_stack, it can be \\n            converted as a closing bracket and can be used.\\n            \"\"\"\\n\\n            first_elem = left_stack[0]\\n            while star_stack:\\n                if star_stack[0] < first_elem:\\n                    star_stack.pop(0)\\n                else:\\n                    star_stack.pop(0)\\n                    left_stack.pop(0)\\n                    if left_stack:\\n                        first_elem = left_stack[0]\\n                    else:\\n                        return True\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583510,
                "title": "simple-greedy-approach-python-solution-with-comments-faster-than-98",
                "content": "\\n    def checkValidString(self, s):\\n        if len(s)==0 or s==\\'*\\':\\n            return True\\n        if len(s)==1:\\n            return False\\n        \\n        leftBalance=0  #declaring variable to count from left\\n        for i in s:\\n            if i==\\')\\':\\n                leftBalance-=1\\n            else:            #if i is \\'(\\' or \"*\", then increment by 1\\n                leftBalance+=1\\n                \\n            if leftBalance<0:    #if at any point lB is -ve it should return False as \\'(\\' must always precede \\')\\' and a -ve means an extra \\')\\' has occured and even if we go ahead in s it wont satisy the \\'preceding\\' condition \\n                return False\\n        if leftBalance==0:   #after for loop is complete from left side and lB is 0 , it means it is balanced, hence true\\n            return True\\n        \\n        \\n        rightBalance=0 #declaring variable to count from right or end\\n        for i in reversed(s):\\n            if i==\\'(\\':\\n                rightBalance-=1\\n            else:   #if i is \\')\\' or \\'*\\' increment rightBalance by 1\\n                rightBalance+=1\\n                \\n            if rightBalance<0:\\n                return False\\n        return True",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "\\n    def checkValidString(self, s):\\n        if len(s)==0 or s==\\'*\\':\\n            return True\\n        if len(s)==1:\\n            return False\\n        \\n        leftBalance=0  #declaring variable to count from left\\n        for i in s:\\n            if i==\\')\\':\\n                leftBalance-=1\\n            else:            #if i is \\'(\\' or \"*\", then increment by 1\\n                leftBalance+=1\\n                \\n            if leftBalance<0:    #if at any point lB is -ve it should return False as \\'(\\' must always precede \\')\\' and a -ve means an extra \\')\\' has occured and even if we go ahead in s it wont satisy the \\'preceding\\' condition \\n                return False\\n        if leftBalance==0:   #after for loop is complete from left side and lB is 0 , it means it is balanced, hence true\\n            return True\\n        \\n        \\n        rightBalance=0 #declaring variable to count from right or end\\n        for i in reversed(s):\\n            if i==\\'(\\':\\n                rightBalance-=1\\n            else:   #if i is \\')\\' or \\'*\\' increment rightBalance by 1\\n                rightBalance+=1\\n                \\n            if rightBalance<0:\\n                return False\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 583256,
                "title": "c-stack-solution-beats-100-in-time-and-memory-detailed-explanantion",
                "content": "```\\n/*\\n    https://leetcode.com/problems/valid-parenthesis-string/submissions/\\n    \\n    TC: O(N), SC: O(N)\\n    \\n    The idea is that \\')\\' can be balanced by \\'(\\' or \\'*\\' whic has occurred before it \\n    and \\'(\\' can be balanced only by \\')\\' or \\'*\\' which has occurred after it. So we keep track of index of \\n    \\'*\\' and \\'(\\' we encounter and using the above info check if a string is valid.\\n    \\n    We push \\'(\\' or \\'*\\' as their index in stack.\\n    We if we get \\')\\' check if there is any of \\'(\\' or \\'*\\' before\\n    After traversal if we are keft with \\'(\\' in stack, check if there are \\'*\\' after it to balance it.\\n*/\\nclass Solution {\\npublic:\\n    bool checkValidString(string str) {\\n        stack<int> s;\\n        stack<int> special_char;\\n        \\n        for(int i = 0; i < str.size(); i++) {\\n            char c = str[i];\\n            if(c == \\'(\\') {\\n                s.emplace(i);\\n            }\\n            else if(c == \\'*\\')\\n                special_char.emplace(i);\\n            // if ) is encountered, there should be * or ( in the stack\\n            // before \\n            else if(c == \\')\\') {\\n                if(!s.empty() ||\\n                  !special_char.empty()) {\\n                    if(!s.empty())\\n                        s.pop();\\n                    else\\n                        special_char.pop();\\n                }\\n                // no chars to balance \\')\\' found\\n                else\\n                    return false;\\n            }\\n            // any other character is not valid\\n            else\\n                return false;\\n        }\\n        \\n        // start popping the remaining stack elements \\'(\\'\\n        while(!s.empty()) {\\n            // for every \\'(\\' left, we need a * char, which occurs after that\\n            // which can behave as \\')\\' to balance it\\n            if(special_char.empty())\\n                return false;\\n            int left_bracket_idx = s.top();\\n            s.pop();\\n            int special_char_idx = special_char.top();\\n            special_char.pop();\\n            // if there is no \\'*\\' after current brace to balance, str is not valid\\n            if(special_char_idx < left_bracket_idx)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/valid-parenthesis-string/submissions/\\n    \\n    TC: O(N), SC: O(N)\\n    \\n    The idea is that \\')\\' can be balanced by \\'(\\' or \\'*\\' whic has occurred before it \\n    and \\'(\\' can be balanced only by \\')\\' or \\'*\\' which has occurred after it. So we keep track of index of \\n    \\'*\\' and \\'(\\' we encounter and using the above info check if a string is valid.\\n    \\n    We push \\'(\\' or \\'*\\' as their index in stack.\\n    We if we get \\')\\' check if there is any of \\'(\\' or \\'*\\' before\\n    After traversal if we are keft with \\'(\\' in stack, check if there are \\'*\\' after it to balance it.\\n*/\\nclass Solution {\\npublic:\\n    bool checkValidString(string str) {\\n        stack<int> s;\\n        stack<int> special_char;\\n        \\n        for(int i = 0; i < str.size(); i++) {\\n            char c = str[i];\\n            if(c == \\'(\\') {\\n                s.emplace(i);\\n            }\\n            else if(c == \\'*\\')\\n                special_char.emplace(i);\\n            // if ) is encountered, there should be * or ( in the stack\\n            // before \\n            else if(c == \\')\\') {\\n                if(!s.empty() ||\\n                  !special_char.empty()) {\\n                    if(!s.empty())\\n                        s.pop();\\n                    else\\n                        special_char.pop();\\n                }\\n                // no chars to balance \\')\\' found\\n                else\\n                    return false;\\n            }\\n            // any other character is not valid\\n            else\\n                return false;\\n        }\\n        \\n        // start popping the remaining stack elements \\'(\\'\\n        while(!s.empty()) {\\n            // for every \\'(\\' left, we need a * char, which occurs after that\\n            // which can behave as \\')\\' to balance it\\n            if(special_char.empty())\\n                return false;\\n            int left_bracket_idx = s.top();\\n            s.pop();\\n            int special_char_idx = special_char.top();\\n            special_char.pop();\\n            // if there is no \\'*\\' after current brace to balance, str is not valid\\n            if(special_char_idx < left_bracket_idx)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582740,
                "title": "java-fastest-simplest-and-most-straight-forward-solution-beat-100-time",
                "content": "I have been mangled with this for much more I expected. So I want to share my solution here.\\nThe basic idea is kept tracking what is the range the result could be. Eventullay the result should be 0. Tricky part is in the procedure, the result should be negative, like \"))((\" or \"*))(\". So the first * can\\'t be used as \")\".\\n```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int[] range = new int[2];\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                range[0]++;\\n                range[1]++;\\n            } else if (c == \\'*\\') {\\n                range[0] = Math.max(0, range[0]-1);\\n                range[1]++;\\n            } else if (c == \\')\\') {\\n                range[0] = Math.max(0, range[0]-1);\\n                range[1]--;\\n                if (range[1] < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return range[0] == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkValidString(String s) {\\n        int[] range = new int[2];\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                range[0]++;\\n                range[1]++;\\n            } else if (c == \\'*\\') {\\n                range[0] = Math.max(0, range[0]-1);\\n                range[1]++;\\n            } else if (c == \\')\\') {\\n                range[0] = Math.max(0, range[0]-1);\\n                range[1]--;\\n                if (range[1] < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return range[0] == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1910718,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 1934666,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 1576928,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 1881728,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 1832026,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 1774433,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 1665560,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 2066983,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 2008675,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 1931068,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 1910718,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 1934666,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 1576928,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 1881728,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 1832026,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 1774433,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 1665560,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 2066983,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 2008675,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            },
            {
                "id": 1931068,
                "content": [
                    {
                        "username": "anmolpatel562",
                        "content": "Please provide more sample inputs in the question. "
                    },
                    {
                        "username": "shrawank22",
                        "content": "Can anyone tell me how this problem comes under greedy? "
                    },
                    {
                        "username": "yashpal_sparton",
                        "content": "I had no idea at begining , then i thought it could be done using DP.\\n\\nTo make it Valid Parenthesis String , No. of \\'(\\' should be 0;\\nThen i define state as ,\\nDp[i][j]=string contain i no. of \\'(\\' at end of jth character.\\nDp[i][j]=1; if it contain\\nDp[i][j]=0 ; if it don\\'t contain\\n\\nState transition \\nif(s[j]==\\'(\\' )\\n{\\ndp[i][j]=dp[i-1][j-1];\\n}\\n\\nif(s[j]==\\')\\' )\\n{\\ndp[i][j]=dp[i+1][j-1];\\n}\\n\\nif(s[j]==\\'*\\' )\\n{\\ndp[i][j]=max(dp[i-1][j-1],dp[i+1][j-1],dp[i][j]);\\n}\\nand \\nreturn dp[0][n];"
                    },
                    {
                        "username": "juxtapo",
                        "content": "Nice! I solved it using 3 states, one for the index of the string, second for the number of open parens and third for the number of stars. Looking at your solution I realized I don\\'t need the third one. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Here\\'s a small hint -  The linear solution with constant space complexity is not intuitive AT ALL. So, if you\\'re struggling with this problem for a while, and you really want solve this, then try to find a solution with a non-linear time complexity."
                    },
                    {
                        "username": "bhaskar_op",
                        "content": "Recursion -> Memoization -> Tabulation\\nhttps://leetcode.com/problems/valid-parenthesis-string/solutions/3295236/c-recursion-memoization-tabulation-approach-building-crisp-explanation-like-striver/"
                    },
                    {
                        "username": "sharforaz_rahman",
                        "content": "Hello everyone, Can anyone tell me why the output is false for this particular input? here is my code below, Thank you\n\nimport java.util.Stack;\n\npublic class valid_parenthesis_string {\n    public static void main(String[] args) {\n        String s = (((((*(()((((*((**(((()()*)()()()*((((**)())*)*)))))))(())(()))())((*()()(((()((()*(())*(()**)()(());\n        System.out.println(checkValidString(s));\n    }\n\n    public static boolean checkValidString(String s) {\n        Stack<Character> stack = new Stack<>();\n        int star_Count = 0, bracketCount = 0;\n\n        for (char i : s.toCharArray()) {\n            if (i == '(') bracketCount++;\n            if (i == ')') bracketCount--;\n        }\n        if (bracketCount == 0) return true;\n\n        for (char i : s.toCharArray()) {\n            if (!stack.isEmpty() && i == ')' && stack.peek() == '(') stack.pop();\n            else if (i == '*') star_Count++;\n            else stack.push(i);\n        }\n        System.out.println(star_Count);\n        System.out.println(stack);\n        return stack.size() <= star_Count;\n    }\n}\n"
                    },
                    {
                        "username": "Mohammad_Umer",
                        "content": "can you check for this input  \"*(\" it should return false but it returns true. I think this code is not valid for this test case.\\n"
                    },
                    {
                        "username": "legit_me",
                        "content": "try this test case :--  * ( ( ) "
                    },
                    {
                        "username": "Rishi_Sharma",
                        "content": "`bool checkValidString(string s) {`\\n`        int open=0, close=0;`\\n`        for(auto x: s){`\\n`            if(x == \\')\\')`\\n`                open--;`\\n  `          else`\\n    `            open++;`\\n      `      if(open < 0)`\\n        `        return false;`\\n        `}`\\n `       for(int i=s.length()-1; i>=0; i--){`\\n   `         if(s[i] == \\'(\\')`\\n     `           close--;`\\n       `     else`\\n         `       close++;`\\n           ` if(close < 0)`\\n            `    return false;`\\n        `}`\\n        `return true;`\\n    `}`\\n\\nTime: O(n)\\nSpace: O(1)"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Please don\\'t post any solutions in this discussion tab"
                    },
                    {
                        "username": "pratham2712",
                        "content": "for greedy logic is to think in terms of count of (,),* and increase count, decrease count"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Greedy approach is elegant but it can be also solved with two deques/stacks !"
                    },
                    {
                        "username": "user5693U",
                        "content": "How did you manage to do 500+ p in 3 months? "
                    },
                    {
                        "username": "shyamala1307",
                        "content": "My solution using 2 stacks:\\n\\npublic boolean checkValidString(String s) {\\n        Stack<Integer> op = new Stack<>();\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i) == \\'(\\') op.push(i);\\n          else if(s.charAt(i) == \\'*\\') st.push(i);\\n          else if(s.charAt(i) == \\')\\'){\\n            if(op.size() > 0) op.pop();\\n            else if(st.size() > 0) st.pop();\\n            else return false;\\n          }\\n        }\\n\\n        while(op.size() > 0 && st.size() > 0){\\n          if(op.peek() > st.peek()) return false;\\n          op.pop();\\n          st.pop();\\n        }\\n        return op.size() == 0;\\n    }"
                    }
                ]
            }
        ]
    }
]