[
    {
        "title": "Bricks Falling When Hit",
        "question_content": "You are given an m x n binary grid, where each 1 represents a brick and 0 represents an empty space. A brick is stable if:\n\n\tIt is directly connected to the top of the grid, or\n\tAt least one other brick in its four adjacent cells is stable.\n\nYou are also given an array hits, which is a sequence of erasures we want to apply. Each time we want to erase the brick at the location hits[i] = (rowi, coli). The brick on that location&nbsp;(if it exists) will disappear. Some other bricks may no longer be stable because of that erasure and will fall. Once a brick falls, it is immediately erased from the grid (i.e., it does not land on other stable bricks).\nReturn an array result, where each result[i] is the number of bricks that will fall after the ith erasure is applied.\nNote that an erasure may refer to a location with no brick, and if it does, no bricks drop.\n&nbsp;\nExample 1:\n\nInput: grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]\nOutput: [2]\nExplanation: Starting with the grid:\n[[1,0,0,0],\n [1,1,1,0]]\nWe erase the underlined brick at (1,0), resulting in the grid:\n[[1,0,0,0],\n [0,1,1,0]]\nThe two underlined bricks are no longer stable as they are no longer connected to the top nor adjacent to another stable brick, so they will fall. The resulting grid is:\n[[1,0,0,0],\n [0,0,0,0]]\nHence the result is [2].\n\nExample 2:\n\nInput: grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]\nOutput: [0,0]\nExplanation: Starting with the grid:\n[[1,0,0,0],\n [1,1,0,0]]\nWe erase the underlined brick at (1,1), resulting in the grid:\n[[1,0,0,0],\n [1,0,0,0]]\nAll remaining bricks are still stable, so no bricks fall. The grid remains the same:\n[[1,0,0,0],\n [1,0,0,0]]\nNext, we erase the underlined brick at (1,0), resulting in the grid:\n[[1,0,0,0],\n [0,0,0,0]]\nOnce again, all remaining bricks are still stable, so no bricks fall.\nHence the result is [0,0].\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 200\n\tgrid[i][j] is 0 or 1.\n\t1 <= hits.length <= 4 * 104\n\thits[i].length == 2\n\t0 <= xi&nbsp;<= m - 1\n\t0 <=&nbsp;yi <= n - 1\n\tAll (xi, yi) are unique.",
        "solutions": [
            {
                "id": 119829,
                "title": "python-solution-by-reversely-adding-hits-bricks-back",
                "content": "We can reverse the problem and count how many new no-dropping bricks are added when we add the bricks reversely. It\\'s just the same of counting dropping bricks when erase one brick.\\n\\nLet m, n = len(grid), len(grid[0]).\\n\\nHere is the detailed solution:\\n\\n1. For each hit (i, j), if grid[i][j]==0, set grid[i][j]=-1 otherwise set grid[i][j]=0. Since a hit may happen at an empty position, we need to seperate emptys from bricks.\\n2. For i in [0, n], do dfs at grid[i][0] and mark no-dropping bricks. Here we get the grid after all hits.\\n3. Then for each hit (i,j) (reversely), first we check grid[i][j]==-1, if yes, it\\'s empty, skip this hit. Then we check whether it\\'s connected to any no-dropping bricks or it\\'s at the top, if not, it can\\'t add any no-dropping bricks, skip this hit. Otherwise we do dfs at grid[i][j], mark new added no-dropping bricks and record amount of them.\\n4. Return the amounts of new added no-dropping bricks at each hits.\\n\\nHere is a example, you can walk from the last step to the first step to see how we transfer the question:\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/luckypants/image_1521450349.png)\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/luckypants/image_1521450376.png)\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/luckypants/image_1521450387.png)\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/luckypants/image_1521450393.png)\\n\\nUsing this method, we only do $O(n)+O(len(hits))$ dfs.\\n\\n\\n\\nHere is my Python code:\\n\\n**EDIT**:  Many thanks to @lee215 for pointing mistake out and improving the code:\\n* I used h[0], h[1] in is_connected, although it works, it\\'s a mistake\\n* Use grid[i][j]-=1 to execute hits and grid[i][j]+=1 to add bricks (So when we have repeating hits, only when we add from 0 to 1, it\\'s the true time we hit the brick, following hits are done on empty), it makes the code concise and deals with repeating hits (Although the problem guarantees no repeating hits)\\n\\nI also simplified some for loops when checking adjacent positions.\\n\\n```\\nclass Solution:\\n    def hitBricks(self, grid, hits):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type hits: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        m, n = len(grid), len(grid[0])\\n        \\n        # Connect unconnected bricks and \\n        def dfs(i, j):\\n            if not (0<=i<m and 0<=j<n) or grid[i][j]!=1:\\n                return 0\\n            ret = 1\\n            grid[i][j] = 2\\n            ret += sum(dfs(x, y) for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)])\\n            return ret\\n        \\n        # Check whether (i, j) is connected to Not Falling Bricks\\n        def is_connected(i, j):\\n            return i==0 or any([0<=x<m and 0<=y<n and grid[x][y]==2 for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]])\\n        \\n        # Mark whether there is a brick at the each hit\\n        for i, j in hits:\\n            grid[i][j] -= 1\\n                \\n        # Get grid after all hits\\n        for i in range(n):\\n            dfs(0, i)\\n        \\n        # Reversely add the block of each hits and get count of newly add bricks\\n        ret = [0]*len(hits)\\n        for k in reversed(range(len(hits))):\\n            i, j = hits[k]\\n            grid[i][j] += 1\\n            if grid[i][j]==1 and is_connected(i, j):\\n                ret[k] = dfs(i, j)-1\\n            \\n        return ret\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hitBricks(self, grid, hits):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type hits: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        m, n = len(grid), len(grid[0])\\n        \\n        # Connect unconnected bricks and \\n        def dfs(i, j):\\n            if not (0<=i<m and 0<=j<n) or grid[i][j]!=1:\\n                return 0\\n            ret = 1\\n            grid[i][j] = 2\\n            ret += sum(dfs(x, y) for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)])\\n            return ret\\n        \\n        # Check whether (i, j) is connected to Not Falling Bricks\\n        def is_connected(i, j):\\n            return i==0 or any([0<=x<m and 0<=y<n and grid[x][y]==2 for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]])\\n        \\n        # Mark whether there is a brick at the each hit\\n        for i, j in hits:\\n            grid[i][j] -= 1\\n                \\n        # Get grid after all hits\\n        for i in range(n):\\n            dfs(0, i)\\n        \\n        # Reversely add the block of each hits and get count of newly add bricks\\n        ret = [0]*len(hits)\\n        for k in reversed(range(len(hits))):\\n            i, j = hits[k]\\n            grid[i][j] += 1\\n            if grid[i][j]==1 and is_connected(i, j):\\n                ret[k] = dfs(i, j)-1\\n            \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 195781,
                "title": "union-find-logical-thinking",
                "content": "> When won\\'t a brick drop?\\n> A brick will not drop if it connects to top or its adjacent bricks will not drop.\\n> That is, the brick will not drop if it belongs to the same connected component with top.\\n> Problems related to **connect** can be solved by **Disjoint Set**\\n\\n> We represent the top as 0, and any `grid[x][y] as (x * cols + y + 1)`.\\n> We union 1-cells on the first row with 0, and any two adjacent 1-cells.\\n\\n> There are n hits. \\n> Instead of checking all cells after each hit, we start from the last hit to the first hit, restoring it and observing the change of `bricksLeft` -  that is actually the corresponding bricks dropped. `change of bricksLeft = change of size(find(0))` \\n****\\n```\\nclass Solution {\\n    private static final int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    private int[][] grid;\\n    private int rows, cols;\\n\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        rows = grid.length;\\n        cols = grid[0].length;\\n        this.grid = grid;\\n        \\n        DisjointSet ds = new DisjointSet(rows * cols + 1);\\n        \\n        /** Mark cells to hit as 2. */\\n        for (int[] hit : hits) {\\n            if (grid[hit[0]][hit[1]] == 1) grid[hit[0]][hit[1]] = 2;\\n        }\\n        \\n        /** Union around 1 cells. */\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j ++) {\\n                if (grid[i][j] == 1) unionAround(i, j, ds);\\n            }\\n        }\\n        \\n        int numBricksLeft = ds.size[ds.find(0)]; // numBricksLeft after the last erasure.\\n        int i = hits.length - 1; // Index of erasure.\\n        int[] numBricksDropped = new int[hits.length]; // Number of bricks that will drop after each erasure.\\n        \\n        while (i >= 0) {\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            if (grid[x][y] == 2) {\\n                grid[x][y] = 1; // Restore to last erasure.\\n                unionAround(x, y, ds);\\n                int newNumBricksLeft = ds.size[ds.find(0)];\\n                numBricksDropped[i] = Math.max(newNumBricksLeft - numBricksLeft - 1, 0); // Excluding the brick to erase.\\n                numBricksLeft = newNumBricksLeft;\\n            }\\n            i--;\\n        }\\n        \\n        return numBricksDropped;\\n    }\\n    \\n    private void unionAround(int x, int y, DisjointSet ds) {   \\n        int curMark = mark(x, y);\\n        \\n        for (int[] direction : directions) {\\n            int nx = x + direction[0];\\n            int ny = y + direction[1];\\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] == 1) {\\n                ds.union(curMark, mark(nx, ny));\\n            }\\n        }\\n        \\n        if(x == 0) ds.union(0, curMark); // Connect to the top of the grid.\\n    }\\n    \\n    private int mark(int x, int y) {\\n        return x * cols + y + 1;\\n    }\\n    \\n    class DisjointSet {\\n        int[] parent, size;\\n        \\n        public DisjointSet(int n) {\\n            parent = new int[n];\\n            size = new int[n];\\n            Arrays.fill(size, 1);\\n            for (int i = 0; i < n; i++) { // 0 indicates top of the grid.\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public int find(int x) {\\n            if (x == parent[x]) return x;\\n            return parent[x] = find(parent[x]);\\n        }\\n        \\n        public void union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY) {\\n                parent[rootX] = rootY;\\n                size[rootY] += size[rootX];\\n            }\\n        }\\n    }\\n}\\n```\\n**(\\uFF89>\\u03C9<)\\uFF89 Vote up, please!**",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    private static final int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    private int[][] grid;\\n    private int rows, cols;\\n\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        rows = grid.length;\\n        cols = grid[0].length;\\n        this.grid = grid;\\n        \\n        DisjointSet ds = new DisjointSet(rows * cols + 1);\\n        \\n        /** Mark cells to hit as 2. */\\n        for (int[] hit : hits) {\\n            if (grid[hit[0]][hit[1]] == 1) grid[hit[0]][hit[1]] = 2;\\n        }\\n        \\n        /** Union around 1 cells. */\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j ++) {\\n                if (grid[i][j] == 1) unionAround(i, j, ds);\\n            }\\n        }\\n        \\n        int numBricksLeft = ds.size[ds.find(0)]; // numBricksLeft after the last erasure.\\n        int i = hits.length - 1; // Index of erasure.\\n        int[] numBricksDropped = new int[hits.length]; // Number of bricks that will drop after each erasure.\\n        \\n        while (i >= 0) {\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            if (grid[x][y] == 2) {\\n                grid[x][y] = 1; // Restore to last erasure.\\n                unionAround(x, y, ds);\\n                int newNumBricksLeft = ds.size[ds.find(0)];\\n                numBricksDropped[i] = Math.max(newNumBricksLeft - numBricksLeft - 1, 0); // Excluding the brick to erase.\\n                numBricksLeft = newNumBricksLeft;\\n            }\\n            i--;\\n        }\\n        \\n        return numBricksDropped;\\n    }\\n    \\n    private void unionAround(int x, int y, DisjointSet ds) {   \\n        int curMark = mark(x, y);\\n        \\n        for (int[] direction : directions) {\\n            int nx = x + direction[0];\\n            int ny = y + direction[1];\\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] == 1) {\\n                ds.union(curMark, mark(nx, ny));\\n            }\\n        }\\n        \\n        if(x == 0) ds.union(0, curMark); // Connect to the top of the grid.\\n    }\\n    \\n    private int mark(int x, int y) {\\n        return x * cols + y + 1;\\n    }\\n    \\n    class DisjointSet {\\n        int[] parent, size;\\n        \\n        public DisjointSet(int n) {\\n            parent = new int[n];\\n            size = new int[n];\\n            Arrays.fill(size, 1);\\n            for (int i = 0; i < n; i++) { // 0 indicates top of the grid.\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public int find(int x) {\\n            if (x == parent[x]) return x;\\n            return parent[x] = find(parent[x]);\\n        }\\n        \\n        public void union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY) {\\n                parent[rootX] = rootY;\\n                size[rootY] += size[rootX];\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141229,
                "title": "java-simple-dfs-16ms-reversely-add-bricks-back",
                "content": "The idea is simple. \\n1. Remove all bricks in hits. If the cell is originly 1, we set it to -1 so that we can add the brick back;\\n2. DFS from the first row (roof), set all cells of bricks to 2 so that we know these cells have been visited.\\n3. Iterate from the last hit to the first one, i.e., put the erasured bricks back. For every step: \\n    3.1 if the cell is 0, continue;\\n    3.2 else the cell is -1. Check if the cell is attathed to the roof (or any cell with value 2)\\n         If no, continue;\\n\\t\\t\\t\\t Else, reuse the dfs function to count all the connected bricks (cells with value 1). These are bricks that fell down when we erase the hit! Remember to minus 1, which is the brick we erased. \\n\\t\\t\\t\\t \\nCode here:\\n```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        if (hits == null || hits.length == 0) return null;\\n        int[] res = new int[hits.length];\\n        if (grid == null || grid.length == 0) return res;\\n        int m = grid.length, n = grid[0].length;\\n        if (n == 0) return res;\\n        \\n        for (int k = 0; k < hits.length; k++){\\n            int x = hits[k][0], y = hits[k][1];\\n            if (grid[x][y] == 1) grid[x][y] = -1;\\n        }\\n        // set all cells attached to the roof to 2\\n        int count = countBricks(grid);\\n        \\n        for (int k = hits.length-1; k >= 0; k--){\\n            int x = hits[k][0], y = hits[k][1];\\n            if (grid[x][y] == 0) res[k] = 0;\\n            else {\\n                grid[x][y] = 1;\\n                if (!attachedToRoof(grid, x, y)) continue;\\n                res[k] = dfs(grid, x, y) - 1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int countBricks(int[][] grid){\\n        int m = grid.length, n = grid[0].length;\\n        int count = 0;\\n        for (int j = 0; j < n; j++){\\n            count += dfs(grid, 0, j);\\n        }\\n        return count;\\n    }\\n\\n    // count all cells starting from (i, j)\\n    public int dfs(int[][] grid, int i, int j){\\n        if (grid[i][j] != 1) return 0;\\n        int m = grid.length, n = grid[0].length;\\n        int count = 1;\\n        grid[i][j] = 2;\\n        int[] shift = new int[]{-1, 0, 1, 0, -1};\\n        for (int k = 0; k < 4; k++){\\n            int p = i + shift[k];\\n            int q = j + shift[k+1];\\n            if (p < 0 || p >= m || q < 0 || q >= n) continue;\\n            if (grid[p][q] != 1) continue;\\n            count += dfs(grid, p, q);\\n        }\\n        return count;\\n    }\\n    \\n    public boolean attachedToRoof(int[][] grid, int i, int j){\\n        if (i == 0) return true;\\n        int m = grid.length, n = grid[0].length;\\n        int[] shift = new int[]{-1, 0, 1, 0, -1};\\n        for (int k = 0; k < 4; k++){\\n            int p = i + shift[k];\\n            int q = j + shift[k+1];\\n            if (p < 0 || p >= m || q < 0 || q >= n) continue;\\n            if (grid[p][q] == 2) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        if (hits == null || hits.length == 0) return null;\\n        int[] res = new int[hits.length];\\n        if (grid == null || grid.length == 0) return res;\\n        int m = grid.length, n = grid[0].length;\\n        if (n == 0) return res;\\n        \\n        for (int k = 0; k < hits.length; k++){\\n            int x = hits[k][0], y = hits[k][1];\\n            if (grid[x][y] == 1) grid[x][y] = -1;\\n        }\\n        // set all cells attached to the roof to 2\\n        int count = countBricks(grid);\\n        \\n        for (int k = hits.length-1; k >= 0; k--){\\n            int x = hits[k][0], y = hits[k][1];\\n            if (grid[x][y] == 0) res[k] = 0;\\n            else {\\n                grid[x][y] = 1;\\n                if (!attachedToRoof(grid, x, y)) continue;\\n                res[k] = dfs(grid, x, y) - 1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int countBricks(int[][] grid){\\n        int m = grid.length, n = grid[0].length;\\n        int count = 0;\\n        for (int j = 0; j < n; j++){\\n            count += dfs(grid, 0, j);\\n        }\\n        return count;\\n    }\\n\\n    // count all cells starting from (i, j)\\n    public int dfs(int[][] grid, int i, int j){\\n        if (grid[i][j] != 1) return 0;\\n        int m = grid.length, n = grid[0].length;\\n        int count = 1;\\n        grid[i][j] = 2;\\n        int[] shift = new int[]{-1, 0, 1, 0, -1};\\n        for (int k = 0; k < 4; k++){\\n            int p = i + shift[k];\\n            int q = j + shift[k+1];\\n            if (p < 0 || p >= m || q < 0 || q >= n) continue;\\n            if (grid[p][q] != 1) continue;\\n            count += dfs(grid, p, q);\\n        }\\n        return count;\\n    }\\n    \\n    public boolean attachedToRoof(int[][] grid, int i, int j){\\n        if (i == 0) return true;\\n        int m = grid.length, n = grid[0].length;\\n        int[] shift = new int[]{-1, 0, 1, 0, -1};\\n        for (int k = 0; k < 4; k++){\\n            int p = i + shift[k];\\n            int q = j + shift[k+1];\\n            if (p < 0 || p >= m || q < 0 || q >= n) continue;\\n            if (grid[p][q] == 2) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 120057,
                "title": "c-dfs-similar-to-lc749",
                "content": "1. when there is a hit, we change grid cell to 0. \\n2. we assign all the resulting connecting parts a unique id and judge if it falls.\\n3. for each falling parts, we count the number, reset the falling cell = 0.\\n4. ++id (prepare to check another resulting parts of this run/start a new run of hit).\\n```\\nclass Solution {\\npublic:\\n    vector<int> dr = {-1, 0, 1, 0};\\n    vector<int> dc = {0, 1, 0, -1};\\n    vector<vector<int>> g;\\n    int vst[201][201], id;\\n    int n, m;\\n\\t\\t\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        n = grid.size(),m = grid[0].size();\\n        g.swap(grid);\\n        vector<int> ret;\\n        for(auto h:hits){\\n            int r = h[0], c = h[1];\\n            int removal = 0;\\n            if(g[r][c] == 1){\\n                g[r][c] = 0;\\n                for(int d = 0;d<4;d++){\\n                    int x = r+dr[d],y = c + dc[d];\\n                    if (!valid(x, y) || !g[x][y]) continue;\\n                    ++id; //mark each connecting parts with a unique id in this run\\n                    if(falling(x,y)) removal += cnt(x,y);\\n                }\\n            }\\n            ret.push_back(removal);\\n        }\\n        return ret;\\n    }\\n    bool falling(int r,int c){\\n        if(!valid(r,c)||!g[r][c]) return true;\\n        if (vst[r][c] == id) return true; //visited and belongs to the same part this run\\n        if (r == 0) return false; //connecting 1st row\\n        vst[r][c] = id;\\n        for (int d = 0; d < 4; ++d){\\n            if (!falling(r + dr[d], c + dc[d])) return false;\\n        } \\n        return true;\\n    }\\n    int cnt(int r,int c){\\n        if (!valid(r,c)||!g[r][c]) return 0;\\n        int ret = 1;\\n        g[r][c] = 0;\\n        for(int d = 0; d < 4; ++d){\\n            ret += cnt(r + dr[d], c + dc[d]);\\n        }\\n        return ret;\\n    }\\n    bool valid(int r,int c){\\n        return 0 <= r && r < n && 0 <= c && c < m;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dr = {-1, 0, 1, 0};\\n    vector<int> dc = {0, 1, 0, -1};\\n    vector<vector<int>> g;\\n    int vst[201][201], id;\\n    int n, m;\\n\\t\\t\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        n = grid.size(),m = grid[0].size();\\n        g.swap(grid);\\n        vector<int> ret;\\n        for(auto h:hits){\\n            int r = h[0], c = h[1];\\n            int removal = 0;\\n            if(g[r][c] == 1){\\n                g[r][c] = 0;\\n                for(int d = 0;d<4;d++){\\n                    int x = r+dr[d],y = c + dc[d];\\n                    if (!valid(x, y) || !g[x][y]) continue;\\n                    ++id; //mark each connecting parts with a unique id in this run\\n                    if(falling(x,y)) removal += cnt(x,y);\\n                }\\n            }\\n            ret.push_back(removal);\\n        }\\n        return ret;\\n    }\\n    bool falling(int r,int c){\\n        if(!valid(r,c)||!g[r][c]) return true;\\n        if (vst[r][c] == id) return true; //visited and belongs to the same part this run\\n        if (r == 0) return false; //connecting 1st row\\n        vst[r][c] = id;\\n        for (int d = 0; d < 4; ++d){\\n            if (!falling(r + dr[d], c + dc[d])) return false;\\n        } \\n        return true;\\n    }\\n    int cnt(int r,int c){\\n        if (!valid(r,c)||!g[r][c]) return 0;\\n        int ret = 1;\\n        g[r][c] = 0;\\n        for(int d = 0; d < 4; ++d){\\n            ret += cnt(r + dr[d], c + dc[d]);\\n        }\\n        return ret;\\n    }\\n    bool valid(int r,int c){\\n        return 0 <= r && r < n && 0 <= c && c < m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669090,
                "title": "c-simple-dfs-with-clear-explanation",
                "content": "```\\nclass Solution {\\n    const vector<pair<int, int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    static constexpr int CEILING_ROW = 0;\\n    \\n    int dfs(vector<vector<int>>& grid, const int row, const int col)\\n    {\\n        // Return num bricks attached to ceiling.\\n        // Also floodfill to mark cells connected to ceiling already \"2\"\\n        \\n        // base\\n        if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size())\\n            return 0;        \\n        if (grid[row][col] != 1)\\n            return 0;\\n        \\n        grid[row][col] = 2; // 2 means brick in a cluster connected to ceiling  \\n        int ans = 1;        // At least this brick. \\n        for (const auto [dx, dy] : directions)\\n            ans += dfs(grid, row+dx, col + dy);\\n        \\n        return ans;\\n    }\\n    \\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) \\n    {\\n        // Instead of we count fallen ones after each cut, we reverse the process by first removing all the hits. \\n        // Count how many connected components from ceiling (no need to worry about bricks getting hold up by other ceiling-connected ones)\\n        // and find the difference each time we add back a brick which was hit.\\n        \\n        // First remove brick according to hits\\n        for (const auto & hit : hits)\\n            grid[hit[0]][hit[1]] = grid[hit[0]][hit[1]]? 0: -1; // -1 means hitting a blank spot. \\n        \\n        vector<int> ans(hits.size(), 0); \\n        \\n        // Initial condition after all hit ones removed.\\n        for (int col = 0; col < grid[0].size(); ++col)\\n            dfs(grid, CEILING_ROW, col);\\n        \\n        for (int i = hits.size() -1; i >=0; --i)\\n        {\\n            const int row = hits[i][0], col = hits[i][1];\\n\\n            // everytime we add a brick, we probe if\\n            //  - it\\'s attached to a ceiling-connected cluster, by checking its 4 neighbors\\n            //  - or it\\'s directly attached to ceiling.\\n            // if either, we have to perform DFS again to recount how many bricks can be connected to ceiling. \\n            int & hit_spot = grid[row][col];\\n            if (hit_spot == -1)\\n                // ignore as it was an empty spot.\\n                continue;\\n            \\n            hit_spot = 1;\\n            \\n            // Recount condition 1: attached to ceiling directly.\\n            bool needs_to_recount = (row == CEILING_ROW);            \\n            if (!needs_to_recount)\\n            {\\n                for (const auto [dx, dy] : directions)\\n                {\\n                    if (row + dx  < 0 || col + dy < 0 || row + dx >= grid.size() || col + dy >= grid[0].size())\\n                        continue;\\n                                        \\n                    if (grid[row+dx][col+dy] == 2)\\n                        // Recount condition 2: one neighbor can reach ceiling.\\n                        needs_to_recount = true;\\n                }\\n            }\\n            \\n            if (needs_to_recount)\\n                ans[i] = dfs(grid, row, col) - 1; // Exclude the newly added back one. \\n        }\\n        \\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const vector<pair<int, int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    static constexpr int CEILING_ROW = 0;\\n    \\n    int dfs(vector<vector<int>>& grid, const int row, const int col)\\n    {\\n        // Return num bricks attached to ceiling.\\n        // Also floodfill to mark cells connected to ceiling already \"2\"\\n        \\n        // base\\n        if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size())\\n            return 0;        \\n        if (grid[row][col] != 1)\\n            return 0;\\n        \\n        grid[row][col] = 2; // 2 means brick in a cluster connected to ceiling  \\n        int ans = 1;        // At least this brick. \\n        for (const auto [dx, dy] : directions)\\n            ans += dfs(grid, row+dx, col + dy);\\n        \\n        return ans;\\n    }\\n    \\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) \\n    {\\n        // Instead of we count fallen ones after each cut, we reverse the process by first removing all the hits. \\n        // Count how many connected components from ceiling (no need to worry about bricks getting hold up by other ceiling-connected ones)\\n        // and find the difference each time we add back a brick which was hit.\\n        \\n        // First remove brick according to hits\\n        for (const auto & hit : hits)\\n            grid[hit[0]][hit[1]] = grid[hit[0]][hit[1]]? 0: -1; // -1 means hitting a blank spot. \\n        \\n        vector<int> ans(hits.size(), 0); \\n        \\n        // Initial condition after all hit ones removed.\\n        for (int col = 0; col < grid[0].size(); ++col)\\n            dfs(grid, CEILING_ROW, col);\\n        \\n        for (int i = hits.size() -1; i >=0; --i)\\n        {\\n            const int row = hits[i][0], col = hits[i][1];\\n\\n            // everytime we add a brick, we probe if\\n            //  - it\\'s attached to a ceiling-connected cluster, by checking its 4 neighbors\\n            //  - or it\\'s directly attached to ceiling.\\n            // if either, we have to perform DFS again to recount how many bricks can be connected to ceiling. \\n            int & hit_spot = grid[row][col];\\n            if (hit_spot == -1)\\n                // ignore as it was an empty spot.\\n                continue;\\n            \\n            hit_spot = 1;\\n            \\n            // Recount condition 1: attached to ceiling directly.\\n            bool needs_to_recount = (row == CEILING_ROW);            \\n            if (!needs_to_recount)\\n            {\\n                for (const auto [dx, dy] : directions)\\n                {\\n                    if (row + dx  < 0 || col + dy < 0 || row + dx >= grid.size() || col + dy >= grid[0].size())\\n                        continue;\\n                                        \\n                    if (grid[row+dx][col+dy] == 2)\\n                        // Recount condition 2: one neighbor can reach ceiling.\\n                        needs_to_recount = true;\\n                }\\n            }\\n            \\n            if (needs_to_recount)\\n                ans[i] = dfs(grid, row, col) - 1; // Exclude the newly added back one. \\n        }\\n        \\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 121072,
                "title": "java-solution",
                "content": "the key question is found out the bricks number that can connect to the top one by the hit one.\\nso there have 3 kind of bricks:\\n1.  the hit one is zero, it can connect nothing to the top\\n2.  the hit one is 1, but it cannot connect to top, then no one can connect to top by it.  \\n3.  the hit one is 1, it can connect to the top, but the near one can connect to the top by other bricks too; \\n\\t  for this case when remove the hit one, the one connect to it will no drop\\n4. the hit one is 1, it can connect to the top, and the near one can connect to the top by it and no other way connect to the top.\\n\\t\\t\\t for this case, there will be some brick drop after the hit one been removed.\\n\\nSo what need to do is:\\n\\t1. check whether the hit one can connect to the top;\\n\\t2. count the bricks number that cannot connect to the top without the hit one.\\n\\t**Below is my solution**\\n\\n```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        if (hits.length == 0 || hits[0].length == 0) return null;\\n        removeHitBrick(grid, hits);\\n        markRemainBricks(grid);\\n        return searchFallingBrick(grid, hits);\\n    }\\n\\n    private void markRemainBricks(int[][] grid) {\\n        for (int i = 0; i < grid[0].length; i++) {\\n            deepSearch(grid, 0, i);\\n        }\\n    }\\n\\n    private void removeHitBrick(int[][] grid, int[][] hits) {\\n        for (int i = 0; i < hits.length; i++) {\\n            grid[hits[i][0]][hits[i][1]] = grid[hits[i][0]][hits[i][1]] - 1;\\n        }\\n    }\\n\\n    private int[] searchFallingBrick(int[][] grid, int[][] hits) {\\n        int[] result = new int[hits.length];\\n        for (int i = hits.length - 1; i >= 0; i--) {\\n            if (grid[hits[i][0]][hits[i][1]] == 0) {\\n                grid[hits[i][0]][hits[i][1]] = 1;\\n                if (isConnectToTop(grid, hits[i][0], hits[i][1])) {\\n                    result[i] = deepSearch(grid, hits[i][0], hits[i][1]) - 1;\\n                } else {\\n                    result[i] = 0;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private boolean isConnectToTop(int[][] grid, int i, int j) {\\n        if(i == 0) return true;\\n\\n        if (i - 1 >= 0 && grid[i - 1][j] == 2) {\\n            return true;\\n        }\\n        if (i + 1 < grid.length && grid[i + 1][j] == 2) {\\n            return true;\\n        }\\n        if (j - 1 >= 0 && grid[i][j - 1] == 2) {\\n            return true;\\n        }\\n        if (j + 1 < grid[0].length && grid[i][j + 1] == 2) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    private int deepSearch(int[][] data, int row, int column) {\\n        int arrayRow = data.length;\\n        int arrayLine = data[0].length;\\n        int effectBricks = 0;\\n        if (row < 0 || row >= arrayRow) return effectBricks;\\n        if (column < 0 || column >= arrayLine) return effectBricks;\\n        if (data[row][column] == 1) {\\n            data[row][column] = 2;\\n            effectBricks = 1;\\n            effectBricks += deepSearch(data, row + 1, column);\\n            effectBricks += deepSearch(data, row - 1, column);\\n            effectBricks += deepSearch(data, row, column + 1);\\n            effectBricks += deepSearch(data, row, column - 1);\\n        }\\n        return effectBricks;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        if (hits.length == 0 || hits[0].length == 0) return null;\\n        removeHitBrick(grid, hits);\\n        markRemainBricks(grid);\\n        return searchFallingBrick(grid, hits);\\n    }\\n\\n    private void markRemainBricks(int[][] grid) {\\n        for (int i = 0; i < grid[0].length; i++) {\\n            deepSearch(grid, 0, i);\\n        }\\n    }\\n\\n    private void removeHitBrick(int[][] grid, int[][] hits) {\\n        for (int i = 0; i < hits.length; i++) {\\n            grid[hits[i][0]][hits[i][1]] = grid[hits[i][0]][hits[i][1]] - 1;\\n        }\\n    }\\n\\n    private int[] searchFallingBrick(int[][] grid, int[][] hits) {\\n        int[] result = new int[hits.length];\\n        for (int i = hits.length - 1; i >= 0; i--) {\\n            if (grid[hits[i][0]][hits[i][1]] == 0) {\\n                grid[hits[i][0]][hits[i][1]] = 1;\\n                if (isConnectToTop(grid, hits[i][0], hits[i][1])) {\\n                    result[i] = deepSearch(grid, hits[i][0], hits[i][1]) - 1;\\n                } else {\\n                    result[i] = 0;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private boolean isConnectToTop(int[][] grid, int i, int j) {\\n        if(i == 0) return true;\\n\\n        if (i - 1 >= 0 && grid[i - 1][j] == 2) {\\n            return true;\\n        }\\n        if (i + 1 < grid.length && grid[i + 1][j] == 2) {\\n            return true;\\n        }\\n        if (j - 1 >= 0 && grid[i][j - 1] == 2) {\\n            return true;\\n        }\\n        if (j + 1 < grid[0].length && grid[i][j + 1] == 2) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    private int deepSearch(int[][] data, int row, int column) {\\n        int arrayRow = data.length;\\n        int arrayLine = data[0].length;\\n        int effectBricks = 0;\\n        if (row < 0 || row >= arrayRow) return effectBricks;\\n        if (column < 0 || column >= arrayLine) return effectBricks;\\n        if (data[row][column] == 1) {\\n            data[row][column] = 2;\\n            effectBricks = 1;\\n            effectBricks += deepSearch(data, row + 1, column);\\n            effectBricks += deepSearch(data, row - 1, column);\\n            effectBricks += deepSearch(data, row, column + 1);\\n            effectBricks += deepSearch(data, row, column - 1);\\n        }\\n        return effectBricks;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450482,
                "title": "from-bad-general-intuition-to-good-reversely-adding-bricks",
                "content": "To understand the question better think of it like this:\\n\\n1) Every brick has a power of stickiness. They will keep sticking until an external force is applied.\\n\\n2) Top row bricks have a superpower of **stickiness sharing** (other bricks will also get this power if they are connected to the top ones directly or indirectly ).\\n\\n3) The power of the top row bricks is overwhelming. Because of this, if a brick comes in contact with top row bricks(directly or indirectly) they will lose their own power permanently and start resonating the power of the top row( **stickiness sharing**).\\n\\n4) As soon as a bridging brick ( which is receiving power from some top brick and sharing it with others)  is hit then the bricks connected to it will also drop because they stopped receiving the power from the top row.\\n\\n5) One other scenario is that the connected bricks are receiving stickiness superpower from multiple top row bricks. So they may not fall if they are connected to some other top brick directly or indirectly.\\n\\n\\n```\\n\\n```\\nInitial solution brute force, Time Limit Exceed\\n\\nThis soluton was based on general intution and we are checking all of the connected bricks again and again after removal of each brick.\\n\\n```\\n\\n var hitBricks = function(grid, hits) {\\n    let output = []\\n    for (let i = 0; i < hits.length; i++) {\\n        let map = {};\\n        \\n        if (grid[hits[i][0]][hits[i][1]] == 1) {\\n            \\n            grid[hits[i][0]][hits[i][1]] = 0;\\n            \\n            \\n            for (let j = 0; j<grid[0].length; j++) {\\n                if (grid[0][j] == 1) {\\n                    dfs (grid, output, map, 0, j);\\n                    break;\\n                }\\n            }\\n            /* removing bricks that are not connected and adding the count to array */\\n            removeBricks(grid, map, output);  \\n        } else {\\n            output.push(0)\\n        }\\n        \\n        \\n    }\\n    return output;\\n};\\n\\nfunction dfs(grid, output, map, i, j) {\\n    \\n    if (i >= grid.length || j >= grid[0].length || i < 0 || j < 0) return;\\n    \\n    let key = i +\\'_\\'+ j\\n    \\n    if (map[key]) return;\\n    \\n    if (grid[i][j] == 1) {\\n        \\n        map[key] = 1;\\n        \\n        dfs(grid, output, map, i+1, j);\\n        dfs(grid, output, map, i-1, j);\\n        dfs(grid, output, map, i, j+1);\\n        dfs(grid, output, map, i, j-1);\\n        \\n    }\\n    \\n}\\n\\nfunction removeBricks (grid, map, output) {\\n    let count = 0;\\n    for (let row = 0; row < grid.length; row++) {\\n        for (let col = 0; col < grid[row].length; col++) {\\n            let key = row +\\'_\\'+ col;\\n            \\n            if (grid[row][col] == 1 && !map[key] ) {\\n                grid[row][col] = 0;\\n                count++\\n            }\\n        }\\n    }\\n    output.push(count)\\n    \\n}\\n\\n```\\n\\n\\nThe next solution didn\\'t come intutively, I had to go through discuss section to understand that this is another way to do this.\\nTo explain it in simple words, On every brick hit I was looping throught entire top row of grid and running dfs on each cell whenever I found there is a brick.\\nI want to somehow limit the number checking of connected bricks on every hit.\\n\\nIn the below solution what I am doing is: \\n\\n1) doing all hits on grid\\n2) after all hits, checking all of the connected bricks\\n3) Now restoring bricks one by one and only running dfs for each restoration once (this is main keypoint)\\n    Earlier I was checking connected bricks for every cell in first row on every hit.\\n\\tand now I am only doing checking on the restored brick only.\\n\\n\\n```\\nvar hitBricks = function(grid, hits) {\\n    \\n    const output = new Array(hits.length).fill(0);\\n    \\n    \\n    // removing bricks from hits\\n    // if it is an empty space then marking it as -1 \\n    // so that we can differentiate later on whether it was an empty space or brick\\n    for (let i = 0; i < hits.length; i++) {\\n        \\n        if (grid[hits[i][0]][hits[i][1]] == 1) {\\n            \\n            grid[hits[i][0]][hits[i][1]] = 0\\n            \\n        } else {\\n            \\n            grid[hits[i][0]][hits[i][1]] = -1\\n            \\n        }\\n    }\\n    \\n    // looping over top row and running dfs to \\n    // mark all of the bricks as 2 which are connected to top\\n    for (let j = 0; j < grid[0].length; j++) {\\n        markAndCount(0, j, grid)\\n    }\\n    \\n    \\n    // looping over hits array backwards and restoring bricks\\n    for (let i = hits.length-1; i >= 0; i-- ) {\\n        \\n        // if there was an empty space then skip the counting\\n        // of restored bricks else count how many bricks it has restored\\n        if (grid[hits[i][0]][hits[i][1]]  === -1 ) continue;\\n        \\n        grid[hits[i][0]][hits[i][1]] = 1 // restored brick\\n        \\n        // if the restored brick is not connected to previously marked bricks\\n        // which are not falling then it will not restore new bricks;\\n        if (!isConnectedToTop(hits[i][0], hits[i][1], grid)) continue;\\n        // saving the number of restored bricks\\n        output[i] = markAndCount(hits[i][0], hits[i][1], grid) - 1\\n        \\n    }\\n    \\n    \\n    return output;\\n    \\n    \\n}\\n\\n\\n// it traverse the grid and mark bricks connected witj top as 2\\n// and also gives back the number of added brick when restoring a hit\\n\\nfunction markAndCount (i, j, grid) {\\n   \\n    // in this if condition the last grid[i][j] != 1 check is important\\n    // because with this we are disregarding the previously counted nodes\\n    // and empty spaces\\n    if (i >= grid.length || \\n        j >= grid[0].length || \\n        i < 0 || \\n        j < 0 || \\n        grid[i][j] != 1) return 0;\\n    \\n    let restored = 1;\\n    \\n    // marking the visited cell as 2\\n    grid[i][j] = 2\\n    \\n    restored += markAndCount(i+1, j, grid);\\n    restored += markAndCount(i-1, j, grid);\\n    restored += markAndCount(i, j+1, grid);\\n    restored += markAndCount(i, j-1, grid);\\n    \\n    return restored\\n    \\n}\\n\\nfunction isConnectedToTop (i,j, grid) {\\n    if ( i == 0 ||\\n        (grid[i-1] && grid[i-1][j] == 2) ||\\n        (grid[i+1] && grid[i+1][j] == 2) ||\\n        grid[i][j-1] == 2 ||\\n        grid[i][j+1] == 2) return true;\\n        \\n    return false\\n}\\n\\n\\n```\\n\\n\\n**I hope it helps.**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n```\n```\\n\\n var hitBricks = function(grid, hits) {\\n    let output = []\\n    for (let i = 0; i < hits.length; i++) {\\n        let map = {};\\n        \\n        if (grid[hits[i][0]][hits[i][1]] == 1) {\\n            \\n            grid[hits[i][0]][hits[i][1]] = 0;\\n            \\n            \\n            for (let j = 0; j<grid[0].length; j++) {\\n                if (grid[0][j] == 1) {\\n                    dfs (grid, output, map, 0, j);\\n                    break;\\n                }\\n            }\\n            /* removing bricks that are not connected and adding the count to array */\\n            removeBricks(grid, map, output);  \\n        } else {\\n            output.push(0)\\n        }\\n        \\n        \\n    }\\n    return output;\\n};\\n\\nfunction dfs(grid, output, map, i, j) {\\n    \\n    if (i >= grid.length || j >= grid[0].length || i < 0 || j < 0) return;\\n    \\n    let key = i +\\'_\\'+ j\\n    \\n    if (map[key]) return;\\n    \\n    if (grid[i][j] == 1) {\\n        \\n        map[key] = 1;\\n        \\n        dfs(grid, output, map, i+1, j);\\n        dfs(grid, output, map, i-1, j);\\n        dfs(grid, output, map, i, j+1);\\n        dfs(grid, output, map, i, j-1);\\n        \\n    }\\n    \\n}\\n\\nfunction removeBricks (grid, map, output) {\\n    let count = 0;\\n    for (let row = 0; row < grid.length; row++) {\\n        for (let col = 0; col < grid[row].length; col++) {\\n            let key = row +\\'_\\'+ col;\\n            \\n            if (grid[row][col] == 1 && !map[key] ) {\\n                grid[row][col] = 0;\\n                count++\\n            }\\n        }\\n    }\\n    output.push(count)\\n    \\n}\\n\\n```\n```\\nvar hitBricks = function(grid, hits) {\\n    \\n    const output = new Array(hits.length).fill(0);\\n    \\n    \\n    // removing bricks from hits\\n    // if it is an empty space then marking it as -1 \\n    // so that we can differentiate later on whether it was an empty space or brick\\n    for (let i = 0; i < hits.length; i++) {\\n        \\n        if (grid[hits[i][0]][hits[i][1]] == 1) {\\n            \\n            grid[hits[i][0]][hits[i][1]] = 0\\n            \\n        } else {\\n            \\n            grid[hits[i][0]][hits[i][1]] = -1\\n            \\n        }\\n    }\\n    \\n    // looping over top row and running dfs to \\n    // mark all of the bricks as 2 which are connected to top\\n    for (let j = 0; j < grid[0].length; j++) {\\n        markAndCount(0, j, grid)\\n    }\\n    \\n    \\n    // looping over hits array backwards and restoring bricks\\n    for (let i = hits.length-1; i >= 0; i-- ) {\\n        \\n        // if there was an empty space then skip the counting\\n        // of restored bricks else count how many bricks it has restored\\n        if (grid[hits[i][0]][hits[i][1]]  === -1 ) continue;\\n        \\n        grid[hits[i][0]][hits[i][1]] = 1 // restored brick\\n        \\n        // if the restored brick is not connected to previously marked bricks\\n        // which are not falling then it will not restore new bricks;\\n        if (!isConnectedToTop(hits[i][0], hits[i][1], grid)) continue;\\n        // saving the number of restored bricks\\n        output[i] = markAndCount(hits[i][0], hits[i][1], grid) - 1\\n        \\n    }\\n    \\n    \\n    return output;\\n    \\n    \\n}\\n\\n\\n// it traverse the grid and mark bricks connected witj top as 2\\n// and also gives back the number of added brick when restoring a hit\\n\\nfunction markAndCount (i, j, grid) {\\n   \\n    // in this if condition the last grid[i][j] != 1 check is important\\n    // because with this we are disregarding the previously counted nodes\\n    // and empty spaces\\n    if (i >= grid.length || \\n        j >= grid[0].length || \\n        i < 0 || \\n        j < 0 || \\n        grid[i][j] != 1) return 0;\\n    \\n    let restored = 1;\\n    \\n    // marking the visited cell as 2\\n    grid[i][j] = 2\\n    \\n    restored += markAndCount(i+1, j, grid);\\n    restored += markAndCount(i-1, j, grid);\\n    restored += markAndCount(i, j+1, grid);\\n    restored += markAndCount(i, j-1, grid);\\n    \\n    return restored\\n    \\n}\\n\\nfunction isConnectedToTop (i,j, grid) {\\n    if ( i == 0 ||\\n        (grid[i-1] && grid[i-1][j] == 2) ||\\n        (grid[i+1] && grid[i+1][j] == 2) ||\\n        grid[i][j-1] == 2 ||\\n        grid[i][j+1] == 2) return true;\\n        \\n    return false\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 137465,
                "title": "java-union-find-beats-100",
                "content": "Think of it reversely: from end to start each hit will add one blick to the grid, \\nWhat we want to find is how many blicks that have been fixed onto the ceiling. \\nThis is a Union-Find Solution. Used ufs[key] to determine which union-find-set the key is in, and num[root] to store the number of elements in this set.  \\nSome tricks:\\n1.  Using grid[i][j]-- every time, we can check if grid[i][j] > 0 to find the first time the blick has been removed if there are duplicated hits in the sequence.   \\n2.  When initializing ufs and num array, don\\'t need to union 4-neighbors, but just top and left instead. \\n3.  Only store the number of nodes in set at the root node. \\n4.  If a ceiling is in set, it will always be root.\\n```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        // Think of it reversely: from end to start each hit will add one blick to the grid, \\n        // What we want to find is how many blicks that have been fixed onto the ceiling. \\n        // This is a Union-Find Solution\\n        if (grid.length == 0) return new int[0];\\n        final int M = grid.length, N = grid[0].length, K = hits.length;\\n        for (int[] hit : hits) {\\n            // Using grid[i][j]-- every time, we can check if grid[i][j] > 0 \\n            // to find the first time the blick has been removed if there are duplicated hits in the sequence.\\n            grid[hit[0]][hit[1]]--;         \\n        }\\n        int[] ufs = new int[M * N];         // Union find set, ufs[key] is key\\'s parent, thru which we can find root recursively\\n        int[] num = new int[M * N];         // Number of nodes in this set, only stored at the root node\\n        int[] ret = new int[K];             // the retval we need to compute\\n        // init ufs and num\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (grid[i][j] < 1) continue;\\n                addOneBlick(grid, ufs, num, i, j, M, N, false);\\n            }\\n        }\\n        // start to go thru hits (reversely)\\n        for (int k = K - 1; k >= 0; k--) {\\n            int x = hits[k][0], y = hits[k][1];\\n            if (++grid[x][y] <= 0) ret[k] = 0;\\n            else ret[k] = addOneBlick(grid, ufs, num, x, y, M, N, true);\\n        }\\n        return ret;\\n    }\\n    \\n    private int addOneBlick(int[][] grid, int[] ufs, int[] num, int x, int y, int M, int N, boolean union4) {\\n        // This func is used to union neighbors and calculate the count of blicks that have been unioned to ceiling\\n        // Note that if this is iterating from left-top to right-bottom, we only need to union current with left and top\\n        // So union4 is a flag determining if we go thru 4 neighbors or just 2; \\n        int key = x * N + y;\\n        ufs[key] = key;\\n        num[key] = 1;\\n        int count = key < N ? 1 : 0;    // if key is at ceiling, init count as 1, because this blick has already been fixed. \\n        if (x > 0 && grid[x-1][y] == 1) count += union(ufs, num, key - N, key, N);\\n        if (y > 0 && grid[x][y-1] == 1) count += union(ufs, num, key - 1, key, N);\\n        if (union4 && x < M - 1 && grid[x+1][y] == 1) count += union(ufs, num, key + N, key, N);\\n        if (union4 && y < N - 1 && grid[x][y+1] == 1) count += union(ufs, num, key + 1, key, N);\\n        count--;                        // remove the added blick itself if we have some blicks fixed. \\n        return Math.max(0, count);\\n    }\\n    \\n    private int union(int[] ufs, int[] num, int k1, int k2, int N) {\\n        // Union the two set\\n        // If one root is ceiling, union the other to this\\n        // Only if some out-ceiling nodes has been unioned to ceiling set, we return the number of blicks settled. \\n        while (k1 != ufs[k1]) k1 = ufs[k1];\\n        while (k2 != ufs[k2]) k2 = ufs[k2];\\n        if (k1 == k2) return 0;\\n        if (k1 < N || k2 >= N) {\\n            num[k1] += num[k2];\\n            ufs[k2] = k1;\\n            if (k1 < N && k2 >= N) return num[k2];\\n            return 0;\\n        }\\n        // k1 >= N && k2 < N\\n        num[k2] += num[k1];\\n        ufs[k1] = k2;\\n        return num[k1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        // Think of it reversely: from end to start each hit will add one blick to the grid, \\n        // What we want to find is how many blicks that have been fixed onto the ceiling. \\n        // This is a Union-Find Solution\\n        if (grid.length == 0) return new int[0];\\n        final int M = grid.length, N = grid[0].length, K = hits.length;\\n        for (int[] hit : hits) {\\n            // Using grid[i][j]-- every time, we can check if grid[i][j] > 0 \\n            // to find the first time the blick has been removed if there are duplicated hits in the sequence.\\n            grid[hit[0]][hit[1]]--;         \\n        }\\n        int[] ufs = new int[M * N];         // Union find set, ufs[key] is key\\'s parent, thru which we can find root recursively\\n        int[] num = new int[M * N];         // Number of nodes in this set, only stored at the root node\\n        int[] ret = new int[K];             // the retval we need to compute\\n        // init ufs and num\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (grid[i][j] < 1) continue;\\n                addOneBlick(grid, ufs, num, i, j, M, N, false);\\n            }\\n        }\\n        // start to go thru hits (reversely)\\n        for (int k = K - 1; k >= 0; k--) {\\n            int x = hits[k][0], y = hits[k][1];\\n            if (++grid[x][y] <= 0) ret[k] = 0;\\n            else ret[k] = addOneBlick(grid, ufs, num, x, y, M, N, true);\\n        }\\n        return ret;\\n    }\\n    \\n    private int addOneBlick(int[][] grid, int[] ufs, int[] num, int x, int y, int M, int N, boolean union4) {\\n        // This func is used to union neighbors and calculate the count of blicks that have been unioned to ceiling\\n        // Note that if this is iterating from left-top to right-bottom, we only need to union current with left and top\\n        // So union4 is a flag determining if we go thru 4 neighbors or just 2; \\n        int key = x * N + y;\\n        ufs[key] = key;\\n        num[key] = 1;\\n        int count = key < N ? 1 : 0;    // if key is at ceiling, init count as 1, because this blick has already been fixed. \\n        if (x > 0 && grid[x-1][y] == 1) count += union(ufs, num, key - N, key, N);\\n        if (y > 0 && grid[x][y-1] == 1) count += union(ufs, num, key - 1, key, N);\\n        if (union4 && x < M - 1 && grid[x+1][y] == 1) count += union(ufs, num, key + N, key, N);\\n        if (union4 && y < N - 1 && grid[x][y+1] == 1) count += union(ufs, num, key + 1, key, N);\\n        count--;                        // remove the added blick itself if we have some blicks fixed. \\n        return Math.max(0, count);\\n    }\\n    \\n    private int union(int[] ufs, int[] num, int k1, int k2, int N) {\\n        // Union the two set\\n        // If one root is ceiling, union the other to this\\n        // Only if some out-ceiling nodes has been unioned to ceiling set, we return the number of blicks settled. \\n        while (k1 != ufs[k1]) k1 = ufs[k1];\\n        while (k2 != ufs[k2]) k2 = ufs[k2];\\n        if (k1 == k2) return 0;\\n        if (k1 < N || k2 >= N) {\\n            num[k1] += num[k2];\\n            ufs[k2] = k1;\\n            if (k1 < N && k2 >= N) return num[k2];\\n            return 0;\\n        }\\n        // k1 >= N && k2 < N\\n        num[k2] += num[k1];\\n        ufs[k1] = k2;\\n        return num[k1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244730,
                "title": "java-short-unionfind-solution",
                "content": "```\\n    public int[] hitBricks(int[][] g, int[][] hits) {\\n        int m = g.length, n = g[0].length;\\n        UnionFind uf = new UnionFind(m*n + 1);\\n        \\n        for(int[] h : hits) if(g[h[0]][h[1]] == 1) g[h[0]][h[1]] = 2;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(g[i][j] == 1) {\\n                    unionAll(i, j, g, uf);\\n                }\\n            }\\n        }\\n        \\n        int[] res = new int[hits.length];\\n        int count = uf.size[uf.find(0)];\\n        for(int i = hits.length - 1; i >= 0; i--) {\\n            int x = hits[i][0], y = hits[i][1];\\n            if(g[x][y] == 2) {\\n                unionAll(x, y, g, uf);\\n                g[x][y] = 1;\\n            }\\n            int newCount = uf.size[uf.find(0)];\\n            res[i] = newCount > count ? newCount - count - 1 : 0;\\n            count = newCount;\\n        }\\n\\n        return res;\\n    }\\n    \\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    void unionAll(int i, int j, int[][] g, UnionFind uf) {\\n        int m = g.length, n = g[0].length;\\n        for(int[] dir : dirs) {\\n            int x = i + dir[0], y = j + dir[1];\\n            if(x < 0 || x == m || y < 0 || y == n || g[x][y] != 1) continue;\\n            uf.union(i*n + j + 1, x*n + y + 1);\\n        }\\n        \\n        if(i == 0) uf.union(j + 1, 0);\\n    }\\n    \\nclass UnionFind {\\n    int[] id, size;\\n    public UnionFind(int size) {\\n        this.id = new int[size];\\n        this.size = new int[size];\\n        for(int i = 0; i < size; i++) id[i] = i;\\n        Arrays.fill(this.size, 1);\\n    }\\n    \\n    int find(int i) {\\n        while(id[i] != i) {\\n            id[i] = id[id[i]];\\n            i = id[i];\\n        }\\n        return i;\\n    }\\n    \\n    void union(int i, int j) {\\n        int p1 = find(i);\\n        int p2 = find(j);\\n        if(p1 != p2) {\\n            id[p1] = p2;\\n            size[p2] += size[p1]; \\n        }\\n    }\\n}    \\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] hitBricks(int[][] g, int[][] hits) {\\n        int m = g.length, n = g[0].length;\\n        UnionFind uf = new UnionFind(m*n + 1);\\n        \\n        for(int[] h : hits) if(g[h[0]][h[1]] == 1) g[h[0]][h[1]] = 2;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(g[i][j] == 1) {\\n                    unionAll(i, j, g, uf);\\n                }\\n            }\\n        }\\n        \\n        int[] res = new int[hits.length];\\n        int count = uf.size[uf.find(0)];\\n        for(int i = hits.length - 1; i >= 0; i--) {\\n            int x = hits[i][0], y = hits[i][1];\\n            if(g[x][y] == 2) {\\n                unionAll(x, y, g, uf);\\n                g[x][y] = 1;\\n            }\\n            int newCount = uf.size[uf.find(0)];\\n            res[i] = newCount > count ? newCount - count - 1 : 0;\\n            count = newCount;\\n        }\\n\\n        return res;\\n    }\\n    \\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    void unionAll(int i, int j, int[][] g, UnionFind uf) {\\n        int m = g.length, n = g[0].length;\\n        for(int[] dir : dirs) {\\n            int x = i + dir[0], y = j + dir[1];\\n            if(x < 0 || x == m || y < 0 || y == n || g[x][y] != 1) continue;\\n            uf.union(i*n + j + 1, x*n + y + 1);\\n        }\\n        \\n        if(i == 0) uf.union(j + 1, 0);\\n    }\\n    \\nclass UnionFind {\\n    int[] id, size;\\n    public UnionFind(int size) {\\n        this.id = new int[size];\\n        this.size = new int[size];\\n        for(int i = 0; i < size; i++) id[i] = i;\\n        Arrays.fill(this.size, 1);\\n    }\\n    \\n    int find(int i) {\\n        while(id[i] != i) {\\n            id[i] = id[id[i]];\\n            i = id[i];\\n        }\\n        return i;\\n    }\\n    \\n    void union(int i, int j) {\\n        int p1 = find(i);\\n        int p2 = find(j);\\n        if(p1 != p2) {\\n            id[p1] = p2;\\n            size[p2] += size[p1]; \\n        }\\n    }\\n}    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 173204,
                "title": "java-dfs-solution-by-adding-bricks-reversely",
                "content": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        // O(m). Reverse the step, and first get the final board status\\n        for(int i = 0; i < hits.length; i++) {\\n            grid[hits[i][0]][hits[i][1]] -= 1;\\n        }\\n\\n        HashSet<Integer> nonDrop = new HashSet<>();\\n        // O(m). Check which grid is still sticked to the top eventually.\\n        for(int i = 0; i < grid[0].length; i++) {\\n            if(grid[0][i] == 1)\\n                dfs(nonDrop, 0, i, grid);\\n        }\\n\\n        int[] output = new int[hits.length];\\n        // O(m)\\n        for (int i = hits.length - 1; i >= 0; i--) {\\n            int size = nonDrop.size();\\n            grid[hits[i][0]][hits[i][1]] += 1;\\n            // The added grid should be connected to at least one non drop grid or it is one of the top grids.\\n            if(grid[hits[i][0]][hits[i][1]] == 1) {\\n                if ((hits[i][0] - 1 >= 0 && nonDrop.contains((hits[i][0] - 1) * grid[0].length + hits[i][1])) \\n                   || (hits[i][0] + 1 < grid.length && nonDrop.contains((hits[i][0] + 1) * grid[0].length + hits[i][1]))\\n                   || (hits[i][1] - 1 >= 0 && nonDrop.contains(hits[i][1] - 1 + (hits[i][0]) * grid[0].length))\\n                   || (hits[i][1] + 1 < grid[0].length && nonDrop.contains((hits[i][0]) * grid[0].length + hits[i][1] + 1))\\n                   || hits[i][0] == 0) {\\n                    dfs(nonDrop, hits[i][0], hits[i][1], grid); //  O(n) in total\\n                    output[i] = nonDrop.size() - size - 1;  // -1 because the added grid is not counted;\\n                }\\n            }\\n        }\\n\\n        return output;\\n    }\\n\\n    // Because every nodes will be visted at most 5 times, so in total the dfs is O(n)\\n    public void dfs(HashSet<Integer> nonDrop, int i, int j, int[][] grid) {\\n        if (i < 0 || j < 0 || i > grid.length - 1 || j > grid[0].length - 1 || grid[i][j] != 1 || nonDrop.contains(i*grid[0].length + j))\\n            return;\\n        else {\\n            nonDrop.add(i * grid[0].length + j);\\n            dfs(nonDrop, i - 1, j, grid);\\n            dfs(nonDrop, i + 1, j, grid);\\n            dfs(nonDrop, i, j - 1, grid);\\n            dfs(nonDrop, i, j + 1, grid);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        // O(m). Reverse the step, and first get the final board status\\n        for(int i = 0; i < hits.length; i++) {\\n            grid[hits[i][0]][hits[i][1]] -= 1;\\n        }\\n\\n        HashSet<Integer> nonDrop = new HashSet<>();\\n        // O(m). Check which grid is still sticked to the top eventually.\\n        for(int i = 0; i < grid[0].length; i++) {\\n            if(grid[0][i] == 1)\\n                dfs(nonDrop, 0, i, grid);\\n        }\\n\\n        int[] output = new int[hits.length];\\n        // O(m)\\n        for (int i = hits.length - 1; i >= 0; i--) {\\n            int size = nonDrop.size();\\n            grid[hits[i][0]][hits[i][1]] += 1;\\n            // The added grid should be connected to at least one non drop grid or it is one of the top grids.\\n            if(grid[hits[i][0]][hits[i][1]] == 1) {\\n                if ((hits[i][0] - 1 >= 0 && nonDrop.contains((hits[i][0] - 1) * grid[0].length + hits[i][1])) \\n                   || (hits[i][0] + 1 < grid.length && nonDrop.contains((hits[i][0] + 1) * grid[0].length + hits[i][1]))\\n                   || (hits[i][1] - 1 >= 0 && nonDrop.contains(hits[i][1] - 1 + (hits[i][0]) * grid[0].length))\\n                   || (hits[i][1] + 1 < grid[0].length && nonDrop.contains((hits[i][0]) * grid[0].length + hits[i][1] + 1))\\n                   || hits[i][0] == 0) {\\n                    dfs(nonDrop, hits[i][0], hits[i][1], grid); //  O(n) in total\\n                    output[i] = nonDrop.size() - size - 1;  // -1 because the added grid is not counted;\\n                }\\n            }\\n        }\\n\\n        return output;\\n    }\\n\\n    // Because every nodes will be visted at most 5 times, so in total the dfs is O(n)\\n    public void dfs(HashSet<Integer> nonDrop, int i, int j, int[][] grid) {\\n        if (i < 0 || j < 0 || i > grid.length - 1 || j > grid[0].length - 1 || grid[i][j] != 1 || nonDrop.contains(i*grid[0].length + j))\\n            return;\\n        else {\\n            nonDrop.add(i * grid[0].length + j);\\n            dfs(nonDrop, i - 1, j, grid);\\n            dfs(nonDrop, i + 1, j, grid);\\n            dfs(nonDrop, i, j - 1, grid);\\n            dfs(nonDrop, i, j + 1, grid);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 120459,
                "title": "my-c-solution-based-on-union-find",
                "content": "I think for this problem, it is not easy to think the hit sequence recursely. However, this is the first essential step to solve this problem.\\n\\nIn the Union Find, I used a dummy node `m*n` to denote the roof node. So, the 1 in the first row will be connected to this roof node.  \\n\\nThe method to calculate how many bricks are fall is to calcuate the rank difference of the roof node. There are a few cases to handle : \\n\\n1. hit to 0. In this case, we simply add `0` to the result, since this will make no difference for the grid.\\n2. hit to 1. But this `1` is not connected to roof. So the falling brick will be `curRoofRank - prevRoofRank`. \\n3. hit to 1. But this `1` is connected to roof. So the falling brick will be `curRoofRank - prevRoofRank - 1`.  \\n\\n```\\nstruct Node{\\n    int rank, parent;\\n    Node():rank(1),parent(-1){};\\n};\\n\\nclass UF{\\npublic:\\n    UF(int n){\\n        uf = vector<Node>(n);\\n    }\\n    int Find(int x){\\n        if(uf[x].parent < 0){\\n            return x;\\n        }\\n        int res = Find(uf[x].parent);\\n        uf[x].parent = res;\\n        return res;\\n    }\\n    int GetRank(int x){\\n        int parX = Find(x);\\n        return uf[parX].rank;\\n    }\\n\\n    void Union(int x, int y){\\n        int parX = Find(x);\\n        int parY = Find(y);\\n        if(parX == parY){\\n            return;\\n        }\\n\\n        if(uf[parX].rank > uf[parY].rank){\\n            uf[parY].parent = parX;\\n            uf[parX].rank += uf[parY].rank;\\n            uf[parY].rank = 1;\\n        }\\n        else{\\n            uf[parX].parent = parY;\\n            uf[parY].rank += uf[parX].rank;\\n            uf[parX].rank = 1;\\n\\n        }\\n    }\\n\\n    vector<Node> uf;\\nprivate:\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> hitBricks(vector<vector<int>> grid, vector<vector<int>> hits) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> mat = grid;\\n        for(auto &hit: hits){\\n            int x = hit[0];\\n            int y = hit[1];\\n            mat[x][y] = 0;\\n        }\\n\\n        vector<int> res;\\n        UF myUf(m*n+1);\\n        // get the last step union find\\n        // let m*n node is the roof node\\n        for(int j=0; j<n; ++j){\\n            if(mat[0][j] == 1){\\n                myUf.Union(j, m*n);\\n            }\\n        }\\n\\n        for(int i=1; i<m; ++i){\\n            for(int j=0; j<n; ++j){\\n                if(mat[i][j] == 1){\\n                    if(mat[i-1][j] == 1){\\n                        myUf.Union(i*n+j, (i-1)*n+j);\\n                    }\\n                    if(j-1>=0 && mat[i][j-1]==1){\\n                        myUf.Union(i*n+j, i*n+(j-1));\\n                    }\\n                }\\n            }\\n        }\\n\\n        // put brick back\\n        for(int k = hits.size()-1; k>=0; --k){\\n            int x = hits[k][0];\\n            int y = hits[k][1];\\n\\n            if(grid[x][y] == 1){\\n                int prevRoofRank = myUf.GetRank(m*n);\\n                mat[x][y] = 1;\\n                if(x+1<m && mat[x+1][y] == 1){\\n                   myUf.Union((x+1)*n+y, x*n+y);\\n                }\\n                if(x-1>=0 && mat[x-1][y] == 1){\\n                    myUf.Union((x-1)*n+y, x*n+y);\\n                }\\n                if(y+1<n && mat[x][y+1] == 1){\\n                    myUf.Union(x*n+y+1, x*n+y);\\n                }\\n                if(y-1>=0 && mat[x][y-1] == 1){\\n                    myUf.Union(x*n+y-1, x*n+y);\\n                }\\n                if(x==0){ // merge to roof node\\n                    myUf.Union(m*n, x*n+y);\\n                }\\n                int curRoofRank = myUf.GetRank(m*n);\\n\\n                int curPar = myUf.Find(x*n+y);\\n                int roofPar = myUf.Find(m*n);\\n                if(curPar == roofPar){\\n                    res.push_back(curRoofRank- prevRoofRank -1);\\n                }\\n                else{\\n                    res.push_back(curRoofRank- prevRoofRank);\\n                }\\n\\n            }\\n            else{\\n                res.push_back(0);\\n            }\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nstruct Node{\\n    int rank, parent;\\n    Node():rank(1),parent(-1){};\\n};\\n\\nclass UF{\\npublic:\\n    UF(int n){\\n        uf = vector<Node>(n);\\n    }\\n    int Find(int x){\\n        if(uf[x].parent < 0){\\n            return x;\\n        }\\n        int res = Find(uf[x].parent);\\n        uf[x].parent = res;\\n        return res;\\n    }\\n    int GetRank(int x){\\n        int parX = Find(x);\\n        return uf[parX].rank;\\n    }\\n\\n    void Union(int x, int y){\\n        int parX = Find(x);\\n        int parY = Find(y);\\n        if(parX == parY){\\n            return;\\n        }\\n\\n        if(uf[parX].rank > uf[parY].rank){\\n            uf[parY].parent = parX;\\n            uf[parX].rank += uf[parY].rank;\\n            uf[parY].rank = 1;\\n        }\\n        else{\\n            uf[parX].parent = parY;\\n            uf[parY].rank += uf[parX].rank;\\n            uf[parX].rank = 1;\\n\\n        }\\n    }\\n\\n    vector<Node> uf;\\nprivate:\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> hitBricks(vector<vector<int>> grid, vector<vector<int>> hits) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> mat = grid;\\n        for(auto &hit: hits){\\n            int x = hit[0];\\n            int y = hit[1];\\n            mat[x][y] = 0;\\n        }\\n\\n        vector<int> res;\\n        UF myUf(m*n+1);\\n        // get the last step union find\\n        // let m*n node is the roof node\\n        for(int j=0; j<n; ++j){\\n            if(mat[0][j] == 1){\\n                myUf.Union(j, m*n);\\n            }\\n        }\\n\\n        for(int i=1; i<m; ++i){\\n            for(int j=0; j<n; ++j){\\n                if(mat[i][j] == 1){\\n                    if(mat[i-1][j] == 1){\\n                        myUf.Union(i*n+j, (i-1)*n+j);\\n                    }\\n                    if(j-1>=0 && mat[i][j-1]==1){\\n                        myUf.Union(i*n+j, i*n+(j-1));\\n                    }\\n                }\\n            }\\n        }\\n\\n        // put brick back\\n        for(int k = hits.size()-1; k>=0; --k){\\n            int x = hits[k][0];\\n            int y = hits[k][1];\\n\\n            if(grid[x][y] == 1){\\n                int prevRoofRank = myUf.GetRank(m*n);\\n                mat[x][y] = 1;\\n                if(x+1<m && mat[x+1][y] == 1){\\n                   myUf.Union((x+1)*n+y, x*n+y);\\n                }\\n                if(x-1>=0 && mat[x-1][y] == 1){\\n                    myUf.Union((x-1)*n+y, x*n+y);\\n                }\\n                if(y+1<n && mat[x][y+1] == 1){\\n                    myUf.Union(x*n+y+1, x*n+y);\\n                }\\n                if(y-1>=0 && mat[x][y-1] == 1){\\n                    myUf.Union(x*n+y-1, x*n+y);\\n                }\\n                if(x==0){ // merge to roof node\\n                    myUf.Union(m*n, x*n+y);\\n                }\\n                int curRoofRank = myUf.GetRank(m*n);\\n\\n                int curPar = myUf.Find(x*n+y);\\n                int roofPar = myUf.Find(m*n);\\n                if(curPar == roofPar){\\n                    res.push_back(curRoofRank- prevRoofRank -1);\\n                }\\n                else{\\n                    res.push_back(curRoofRank- prevRoofRank);\\n                }\\n\\n            }\\n            else{\\n                res.push_back(0);\\n            }\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808751,
                "title": "c-union-find-by-rank-explained",
                "content": "Make a list of m*n+1 , and keep 0 as the main root to which if 0th row elements are connected then they are stable.\\nNow construct a size array with size of every element as 1, but size of 0 as 0 as its a virtual element.\\nRest is parent and rank array, usual DSU implementation. Just one extra thing increase size array in union function.\\nUnionAround function is nothing but just cheking is there is any stable element in 4 directions.\\nApply DSU for all elements whose value is 1 and not in hits. For those elements present in hits first make them 2 before applying DSU to ignore them.\\nNow ,apply DSU in reverse order for all elements in hits. Keep count of size of 0(virtual element), update new count and return new-curr-1 as the hit brick is not considered in count.\\nBelow is the implementation for this-\\n```\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector <int> parent;\\n    vector <int> rank;\\n    vector <int> size;\\n    \\n    int find(int x){\\n        if (parent[x]!=x) parent[x]=find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    void Union(int x,int y){\\n        int r1=find(x);\\n        int r2=find(y);\\n        if (r1!=r2){\\n            if (rank[r1]>rank[r2]){\\n                parent[r2]=r1;\\n                size[r1]+=size[r2];\\n            }\\n            else if (rank[r2]>rank[r1]){\\n                parent[r1]=r2;\\n                size[r2]+=size[r1];\\n            }\\n            else{\\n                parent[r2]=r1;\\n                size[r1]+=size[r2];\\n                rank[r1]++;\\n            }\\n        }\\n    }\\n    void unionAround(int i,int j,vector<vector<int>>& grid){\\n        int seq=i*n+j+1;\\n        vector <pair<int,int>> directions={{0,1},{0,-1},{-1,0},{1,0}};\\n        for (auto &d: directions){\\n            int ni=i+d.first,nj=j+d.second;\\n            if (ni>=0 && ni<m && nj>=0 && nj<n && grid[ni][nj]==1){\\n                int new_seq=ni*n+nj+1;\\n                Union(seq,new_seq);\\n            }\\n        }\\n        if (i==0) Union(0,seq);\\n    }\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\\n        m=grid.size();\\n        n=grid[0].size();\\n        int hitCnt=hits.size();\\n        vector <int> Size(m*n+1,1);\\n        size=Size;\\n        size[0]=0;\\n        vector <int> Parent(m*n+1,0);\\n        parent=Parent;\\n        for (int i=0;i<=m*n;i++) parent[i]=i;\\n        vector <int> Rank(m*n+1,0);\\n        rank=Rank;\\n        vector <int> ans(hitCnt,0);\\n        for (auto &v: hits){\\n            int x=v[0],y=v[1];\\n            if (grid[x][y]==1) grid[x][y]=2;\\n        }\\n        for (int i=0;i<m;i++){\\n            for (int j=0; j<n;j++){\\n                if (grid[i][j]==1) unionAround(i,j,grid);\\n            }\\n        }\\n        int currCnt=size[find(0)];\\n        for (int i=hitCnt-1; i>=0; i--){\\n            int x=hits[i][0],y=hits[i][1];\\n            if (grid[x][y]==2){\\n                grid[x][y]=1;\\n                unionAround(x,y,grid);\\n                int newCnt=size[find(0)];\\n                if (newCnt>currCnt) ans[i]=newCnt-currCnt-1;\\n                currCnt=newCnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector <int> parent;\\n    vector <int> rank;\\n    vector <int> size;\\n    \\n    int find(int x){\\n        if (parent[x]!=x) parent[x]=find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    void Union(int x,int y){\\n        int r1=find(x);\\n        int r2=find(y);\\n        if (r1!=r2){\\n            if (rank[r1]>rank[r2]){\\n                parent[r2]=r1;\\n                size[r1]+=size[r2];\\n            }\\n            else if (rank[r2]>rank[r1]){\\n                parent[r1]=r2;\\n                size[r2]+=size[r1];\\n            }\\n            else{\\n                parent[r2]=r1;\\n                size[r1]+=size[r2];\\n                rank[r1]++;\\n            }\\n        }\\n    }\\n    void unionAround(int i,int j,vector<vector<int>>& grid){\\n        int seq=i*n+j+1;\\n        vector <pair<int,int>> directions={{0,1},{0,-1},{-1,0},{1,0}};\\n        for (auto &d: directions){\\n            int ni=i+d.first,nj=j+d.second;\\n            if (ni>=0 && ni<m && nj>=0 && nj<n && grid[ni][nj]==1){\\n                int new_seq=ni*n+nj+1;\\n                Union(seq,new_seq);\\n            }\\n        }\\n        if (i==0) Union(0,seq);\\n    }\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\\n        m=grid.size();\\n        n=grid[0].size();\\n        int hitCnt=hits.size();\\n        vector <int> Size(m*n+1,1);\\n        size=Size;\\n        size[0]=0;\\n        vector <int> Parent(m*n+1,0);\\n        parent=Parent;\\n        for (int i=0;i<=m*n;i++) parent[i]=i;\\n        vector <int> Rank(m*n+1,0);\\n        rank=Rank;\\n        vector <int> ans(hitCnt,0);\\n        for (auto &v: hits){\\n            int x=v[0],y=v[1];\\n            if (grid[x][y]==1) grid[x][y]=2;\\n        }\\n        for (int i=0;i<m;i++){\\n            for (int j=0; j<n;j++){\\n                if (grid[i][j]==1) unionAround(i,j,grid);\\n            }\\n        }\\n        int currCnt=size[find(0)];\\n        for (int i=hitCnt-1; i>=0; i--){\\n            int x=hits[i][0],y=hits[i][1];\\n            if (grid[x][y]==2){\\n                grid[x][y]=1;\\n                unionAround(x,y,grid);\\n                int newCnt=size[find(0)];\\n                if (newCnt>currCnt) ans[i]=newCnt-currCnt-1;\\n                currCnt=newCnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 296033,
                "title": "java-reverse-placement-beats-100-time-and-85-memory",
                "content": "This solution has a time complexity of *O(n + h)* (n being the number of cells in the grid and h being the size of array *hits*). The memory complexity is *O(h)*. We\\'re doing things in-place.\\n\\n```\\nclass Solution {\\n\\n    static final int HIT = -1;\\n    static final int BRICK = 1;\\n    static final int VISITED = 2;\\n\\t\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int [] result = new int[hits.length];\\n\\t\\t\\n\\t\\t// Mark erased bricks\\n        for (int [] hit : hits) {\\n            if (grid[hit[0]][hit[1]] == BRICK) {\\n                grid[hit[0]][hit[1]] = HIT;\\n            }\\n        }\\n\\t\\t/*\\n\\t\\t\\tRun Depth First Search from top row in order to know \\n\\t\\t\\twhich bricks are left after every erase operation.\\n\\t\\t\\tWe should mark these bricks as visited.\\n\\t\\t*/\\n        for (int j = 0; j < grid[0].length; j++) {\\n            if (grid[0][j] == BRICK) {\\n                dfs(grid, 0, j);\\n            }\\n        }\\n\\t\\t/*\\n\\t\\t\\tRun the hits array in reverse order.\\n\\t\\t\\tWe should run a new DFS from here in order to know which cells can be visited.\\n\\t\\t\\tCount the new visited cells except the DFS root cell (because it was erased, it didn\\'t fall)\\n\\t\\t*/\\n        for (int k = result.length - 1; k >= 0; k--) {\\n            int i = hits[k][0], j = hits[k][1];\\n            if (grid[i][j] == HIT) {\\n                grid[i][j] = BRICK;\\n                if (isConnected(grid, i, j)) result[k] = dfs(grid, i, j) - 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\t\\n    public boolean isConnected(int [][] grid, int i, int j) {\\n        return i - 1 < 0 || (grid[i - 1][j] == VISITED) ||\\n                (i + 1 < grid.length && grid[i + 1][j] == VISITED) ||\\n                (j - 1 >= 0 && grid[i][j - 1] == VISITED) ||\\n                (j + 1 < grid[0].length && grid[i][j + 1] == VISITED);\\n    }\\n\\t\\n    public int dfs(int [][] grid, int i, int j) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != BRICK) {\\n            return 0;\\n        }\\n        grid[i][j] = VISITED;\\n        int sum = 1;\\n        sum += dfs(grid, i + 1, j);\\n        sum += dfs(grid,  i - 1, j);\\n        sum += dfs(grid, i, j + 1);\\n        sum += dfs(grid, i, j - 1);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    static final int HIT = -1;\\n    static final int BRICK = 1;\\n    static final int VISITED = 2;\\n\\t\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int [] result = new int[hits.length];\\n\\t\\t\\n\\t\\t// Mark erased bricks\\n        for (int [] hit : hits) {\\n            if (grid[hit[0]][hit[1]] == BRICK) {\\n                grid[hit[0]][hit[1]] = HIT;\\n            }\\n        }\\n\\t\\t/*\\n\\t\\t\\tRun Depth First Search from top row in order to know \\n\\t\\t\\twhich bricks are left after every erase operation.\\n\\t\\t\\tWe should mark these bricks as visited.\\n\\t\\t*/\\n        for (int j = 0; j < grid[0].length; j++) {\\n            if (grid[0][j] == BRICK) {\\n                dfs(grid, 0, j);\\n            }\\n        }\\n\\t\\t/*\\n\\t\\t\\tRun the hits array in reverse order.\\n\\t\\t\\tWe should run a new DFS from here in order to know which cells can be visited.\\n\\t\\t\\tCount the new visited cells except the DFS root cell (because it was erased, it didn\\'t fall)\\n\\t\\t*/\\n        for (int k = result.length - 1; k >= 0; k--) {\\n            int i = hits[k][0], j = hits[k][1];\\n            if (grid[i][j] == HIT) {\\n                grid[i][j] = BRICK;\\n                if (isConnected(grid, i, j)) result[k] = dfs(grid, i, j) - 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\t\\n    public boolean isConnected(int [][] grid, int i, int j) {\\n        return i - 1 < 0 || (grid[i - 1][j] == VISITED) ||\\n                (i + 1 < grid.length && grid[i + 1][j] == VISITED) ||\\n                (j - 1 >= 0 && grid[i][j - 1] == VISITED) ||\\n                (j + 1 < grid[0].length && grid[i][j + 1] == VISITED);\\n    }\\n\\t\\n    public int dfs(int [][] grid, int i, int j) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != BRICK) {\\n            return 0;\\n        }\\n        grid[i][j] = VISITED;\\n        int sum = 1;\\n        sum += dfs(grid, i + 1, j);\\n        sum += dfs(grid,  i - 1, j);\\n        sum += dfs(grid, i, j + 1);\\n        sum += dfs(grid, i, j - 1);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 121077,
                "title": "java-union-find-by-backwardly-adding-bricks-back-20ms",
                "content": "```\\nclass Solution {\\n    class UnionFind{\\n        int[] father;\\n        int[] count;\\n        UnionFind(int len) {\\n            father = new int[len];\\n            count = new int[len];\\n            for (int i = 0; i < len ; i++) {\\n                father[i] = i;\\n                count[i] = 1;\\n            }\\n        }\\n        \\n        int find(int toFind) {\\n            while(father[toFind] != toFind) {\\n                father[toFind] = father[father[toFind]];\\n                toFind = father[toFind];\\n            }\\n            return toFind;\\n        }\\n        \\n        void union(int a, int b) {\\n            int fatherA = find(a);\\n            int fatherB = find(b);\\n            if (fatherA != fatherB) {\\n                father[fatherA] = fatherB;\\n                count[fatherB] += count[fatherA];\\n            }\\n        }\\n    }\\n   \\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        UnionFind uf = new UnionFind(m * n + 1);\\n        for (int[] hit : hits) {\\n            if (grid[hit[0]][hit[1]] == 1) {\\n                grid[hit[0]][hit[1]] = 2;\\n            }\\n        }\\n\\n        for (int i = 0 ; i < m; i++)  {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    unionAround(i, j, grid, uf);\\n                }\\n            }\\n        }\\n        \\n        int count = uf.count[uf.find(0)];\\n        int[] res = new int[hits.length];\\n        \\n        for (int i = hits.length -1; i >= 0; i--) {\\n            int[] hit = hits[i];\\n            if (grid[hit[0]][hit[1]] == 2) {\\n                unionAround(hit[0], hit[1], grid, uf);\\n                grid[hit[0]][hit[1]] = 1;\\n            }\\n            int newCount = uf.count[uf.find(0)];\\n            // -1 for the the brick got hit\\n            res[i] = (newCount - count > 0) ? newCount - count - 1 : 0;\\n            count = newCount;\\n        }\\n        return res;\\n    }\\n    \\n    private void unionAround(int x, int y, int[][] grid, UnionFind uf) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] dx = new int[] {-1, 1, 0, 0};\\n        int[] dy = new int[] {0, 0, -1, 1};\\n        for (int i = 0; i < 4; i++) {\\n            int nextX = x + dx[i];\\n            int nextY = y + dy[i];\\n            if (nextX < 0 || nextX >= m || nextY < 0 || nextY >= n) continue;\\n            if (grid[nextX][nextY] == 1) {\\n                // shift all by 1\\n                uf.union(x * n + y + 1, nextX * n + nextY + 1);\\n            }\\n        }\\n        // use 0 as pivot to connect all elements in row 0\\n        if (x == 0) {\\n            uf.union(x * n + y + 1, 0);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class UnionFind{\\n        int[] father;\\n        int[] count;\\n        UnionFind(int len) {\\n            father = new int[len];\\n            count = new int[len];\\n            for (int i = 0; i < len ; i++) {\\n                father[i] = i;\\n                count[i] = 1;\\n            }\\n        }\\n        \\n        int find(int toFind) {\\n            while(father[toFind] != toFind) {\\n                father[toFind] = father[father[toFind]];\\n                toFind = father[toFind];\\n            }\\n            return toFind;\\n        }\\n        \\n        void union(int a, int b) {\\n            int fatherA = find(a);\\n            int fatherB = find(b);\\n            if (fatherA != fatherB) {\\n                father[fatherA] = fatherB;\\n                count[fatherB] += count[fatherA];\\n            }\\n        }\\n    }\\n   \\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        UnionFind uf = new UnionFind(m * n + 1);\\n        for (int[] hit : hits) {\\n            if (grid[hit[0]][hit[1]] == 1) {\\n                grid[hit[0]][hit[1]] = 2;\\n            }\\n        }\\n\\n        for (int i = 0 ; i < m; i++)  {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    unionAround(i, j, grid, uf);\\n                }\\n            }\\n        }\\n        \\n        int count = uf.count[uf.find(0)];\\n        int[] res = new int[hits.length];\\n        \\n        for (int i = hits.length -1; i >= 0; i--) {\\n            int[] hit = hits[i];\\n            if (grid[hit[0]][hit[1]] == 2) {\\n                unionAround(hit[0], hit[1], grid, uf);\\n                grid[hit[0]][hit[1]] = 1;\\n            }\\n            int newCount = uf.count[uf.find(0)];\\n            // -1 for the the brick got hit\\n            res[i] = (newCount - count > 0) ? newCount - count - 1 : 0;\\n            count = newCount;\\n        }\\n        return res;\\n    }\\n    \\n    private void unionAround(int x, int y, int[][] grid, UnionFind uf) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] dx = new int[] {-1, 1, 0, 0};\\n        int[] dy = new int[] {0, 0, -1, 1};\\n        for (int i = 0; i < 4; i++) {\\n            int nextX = x + dx[i];\\n            int nextY = y + dy[i];\\n            if (nextX < 0 || nextX >= m || nextY < 0 || nextY >= n) continue;\\n            if (grid[nextX][nextY] == 1) {\\n                // shift all by 1\\n                uf.union(x * n + y + 1, nextX * n + nextY + 1);\\n            }\\n        }\\n        // use 0 as pivot to connect all elements in row 0\\n        if (x == 0) {\\n            uf.union(x * n + y + 1, 0);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505293,
                "title": "java-reverse-way-dfs-commented-formatted",
                "content": "```java\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        // idea - failing depends on whether connected to stable brick\\n        // but this connection info will lose after we do \"hits\"\\n        // so how about, mark hits first and also mark stable brick from top (as condition)\\n        // then in a reverse way, we apply valid hit back while counting how many connected bricks\\n        // if this hit is connected to a stable one\\n        int m = grid.length, n = grid[0].length;\\n        int count = hits.length;\\n        \\n        // mark empty brick for hit as -1\\n        for (int[] hit : hits) {\\n            grid[hit[0]][hit[1]] = grid[hit[0]][hit[1]] == 0 ? -1 : 0;\\n        }\\n        \\n        // mark stable brick as 2\\n        for (int i = 0; i < n; i++) {\\n            dfs(grid, 0, i);\\n        }\\n        \\n        int[] res = new int[count];\\n        // reverse loop on hits\\n        for (int i = count - 1; i >= 0; i--) {\\n            int[] hit = hits[i];\\n            // skip empty\\n            if (grid[hit[0]][hit[1]] == -1) {\\n                continue;\\n            }\\n            // bring hitted brick back as 1 - otherwise will not move dfs  \\n            grid[hit[0]][hit[1]] = 1;\\n            // only a stable hit will make sense to count connected brick (will fall so)\\n            if (isStable(grid, hit[0], hit[1])) {\\n                // minus the hit self as the example\\n                res[i] = dfs(grid, hit[0], hit[1]) - 1;\\n            }\\n        }\\n        \\n        // yeah, not hard? \\n        return res;\\n    }\\n    \\n    private int dfs(int[][] grid, int x, int y) {\\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) {\\n            return 0;\\n        }\\n        if (grid[x][y] != 1) {\\n            return 0;\\n        }\\n        int res = 1;\\n        grid[x][y] = 2;\\n        res += dfs(grid, x - 1, y);\\n        res += dfs(grid, x + 1, y);\\n        res += dfs(grid, x, y - 1);\\n        res += dfs(grid, x, y + 1);\\n        return res;\\n    }\\n    \\n    private boolean isStable(int[][] grid, int x, int y) {\\n        if (x == 0) { return true; }\\n        if (x >= 1 && grid[x - 1][y] == 2) { return true; }\\n        if (x < grid.length - 1 && grid[x + 1][y] == 2) { return true; }\\n        if (y >= 1 && grid[x][y - 1] == 2) { return true; }\\n        if (y < grid[0].length - 1 && grid[x][y + 1] == 2) { return true; }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        // idea - failing depends on whether connected to stable brick\\n        // but this connection info will lose after we do \"hits\"\\n        // so how about, mark hits first and also mark stable brick from top (as condition)\\n        // then in a reverse way, we apply valid hit back while counting how many connected bricks\\n        // if this hit is connected to a stable one\\n        int m = grid.length, n = grid[0].length;\\n        int count = hits.length;\\n        \\n        // mark empty brick for hit as -1\\n        for (int[] hit : hits) {\\n            grid[hit[0]][hit[1]] = grid[hit[0]][hit[1]] == 0 ? -1 : 0;\\n        }\\n        \\n        // mark stable brick as 2\\n        for (int i = 0; i < n; i++) {\\n            dfs(grid, 0, i);\\n        }\\n        \\n        int[] res = new int[count];\\n        // reverse loop on hits\\n        for (int i = count - 1; i >= 0; i--) {\\n            int[] hit = hits[i];\\n            // skip empty\\n            if (grid[hit[0]][hit[1]] == -1) {\\n                continue;\\n            }\\n            // bring hitted brick back as 1 - otherwise will not move dfs  \\n            grid[hit[0]][hit[1]] = 1;\\n            // only a stable hit will make sense to count connected brick (will fall so)\\n            if (isStable(grid, hit[0], hit[1])) {\\n                // minus the hit self as the example\\n                res[i] = dfs(grid, hit[0], hit[1]) - 1;\\n            }\\n        }\\n        \\n        // yeah, not hard? \\n        return res;\\n    }\\n    \\n    private int dfs(int[][] grid, int x, int y) {\\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) {\\n            return 0;\\n        }\\n        if (grid[x][y] != 1) {\\n            return 0;\\n        }\\n        int res = 1;\\n        grid[x][y] = 2;\\n        res += dfs(grid, x - 1, y);\\n        res += dfs(grid, x + 1, y);\\n        res += dfs(grid, x, y - 1);\\n        res += dfs(grid, x, y + 1);\\n        return res;\\n    }\\n    \\n    private boolean isStable(int[][] grid, int x, int y) {\\n        if (x == 0) { return true; }\\n        if (x >= 1 && grid[x - 1][y] == 2) { return true; }\\n        if (x < grid.length - 1 && grid[x + 1][y] == 2) { return true; }\\n        if (y >= 1 && grid[x][y - 1] == 2) { return true; }\\n        if (y < grid[0].length - 1 && grid[x][y + 1] == 2) { return true; }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950348,
                "title": "python-3-dfs-explanation",
                "content": "- We can do it on regular order, which will take `O(KMN)`, where `K = len(hits), M = len(grid), N = len(grid[0])`\\n- If we do it reversely of `hits`, it will take `O(MN) + O(K)` since we can utilize the known information (we know how many nodes is already connected), all points will be at most be visited twice (mark as unstable + mark as stable)\\n### Without comments\\n<iframe src=\"https://leetcode.com/playground/6bd6DPwf/shared\" frameBorder=\"0\" width=\"950\" height=\"400\"></iframe>  \\n\\n### With comments\\n<iframe src=\"https://leetcode.com/playground/5kRDSxNZ/shared\" frameBorder=\"0\" width=\"950\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "- We can do it on regular order, which will take `O(KMN)`, where `K = len(hits), M = len(grid), N = len(grid[0])`\\n- If we do it reversely of `hits`, it will take `O(MN) + O(K)` since we can utilize the known information (we know how many nodes is already connected), all points will be at most be visited twice (mark as unstable + mark as stable)\\n### Without comments\\n<iframe src=\"https://leetcode.com/playground/6bd6DPwf/shared\" frameBorder=\"0\" width=\"950\" height=\"400\"></iframe>  \\n\\n### With comments\\n<iframe src=\"https://leetcode.com/playground/5kRDSxNZ/shared\" frameBorder=\"0\" width=\"950\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 587100,
                "title": "c-dfs-sol",
                "content": "We first mark all the bricks that will be hit as 0 (thinking as they don\\'t exist yet).\\n\\nThen by running dfs from the roof, we mark all bricks connected to the roof.\\n\\nThen let\\'s run through `hits` vector in reverse order and add bricks back. When we add a brick back, 1) if it has a neighbor which is connected to the roof, then we run dfs on this brick (we do not attend bricks that are already known to be connected to the roof). All the bricks that we encounter will constitude a connected component of bricks which are now connected to the roof. And we append size of this component to the answer array (in reverse). 2) if it didn\\'t had a neighbor connected to the roof, then we do nothing.\\n\\nFor better understanding imagine: (`R` - denotes connectedness to the roof, `h` - denotes current brick that is being hit)\\n  0R00\\n  0Rh1\\n  0011\\n  0010\\nWhere brick at (2, 3) is being hit, since it has a neighbor connected to the roof, then when we run dfs on `h`, we will mark it and all other bricks in its component as `R`. \\n\\nAnalysis: we know that DFS is by itself linear, but we have multiple DFSs. But, each brick will be attended by all DFSs at most once. Which will make total time complexity of all DFSs linear over number of bricks as well.\\n\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> grid;\\n    int counter = 0;\\n    const int CONNECTED_TO_ROOF = 2;\\n\\n    bool valid_cell(int i, int j)\\n    {\\n        return i >= 0 && i < n && j >= 0 && j < m;\\n    }\\n\\n    void dfs(int i, int j)\\n    {\\n        if(i == -1) /// this stands for the ROOF\\n        {\\n            for(int k = 0; k < m; k++)\\n                if(grid[0][k] == 1)\\n                    dfs(0, k);\\n        }\\n        else\\n        {\\n            counter += 1;\\n            grid[i][j] = CONNECTED_TO_ROOF;\\n            int x[4] = {i+1, i-1, i, i};\\n            int y[4] = {j, j, j-1, j+1};\\n\\n            for(int k = 0; k < 4; k++)\\n            {\\n                if(valid_cell(x[k], y[k]) && grid[x[k]][y[k]] == 1)\\n                    dfs(x[k], y[k]);\\n            }\\n        }\\n    }\\n\\n    vector<int> hitBricks(vector<vector<int>>& gridPassed, vector<vector<int>>& hits)\\n    {\\n        grid = gridPassed;\\n        n = grid.size();\\n        m = grid[0].size();\\n\\n        for(auto cell: hits)\\n            grid[cell[0]][cell[1]] = 0;\\n\\n        dfs(-1, -1);\\n\\n        vector<int> ans(hits.size());\\n\\n        for(int r_ind = hits.size()-1; r_ind >= 0; r_ind--)\\n        {\\n            int i = hits[r_ind][0];\\n            int j = hits[r_ind][1];\\n\\n            if(gridPassed[i][j] == 1)\\n            {\\n                bool exist_neighbor_connected_to_roof = false;\\n                int x[4] = {i+1, i-1, i, i};\\n                int y[4] = {j, j, j-1, j+1};\\n\\n                for(int k = 0; k < 4; k++)\\n                    if(x[k] == -1 || (valid_cell(x[k], y[k]) && grid[x[k]][y[k]] == CONNECTED_TO_ROOF))\\n                        exist_neighbor_connected_to_roof = true;\\n\\n                grid[i][j] = 1;\\n                if(exist_neighbor_connected_to_roof)\\n                {\\n                    counter = 0;\\n                    dfs(i, j);\\n\\n                    ans[r_ind] = counter - 1;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> grid;\\n    int counter = 0;\\n    const int CONNECTED_TO_ROOF = 2;\\n\\n    bool valid_cell(int i, int j)\\n    {\\n        return i >= 0 && i < n && j >= 0 && j < m;\\n    }\\n\\n    void dfs(int i, int j)\\n    {\\n        if(i == -1) /// this stands for the ROOF\\n        {\\n            for(int k = 0; k < m; k++)\\n                if(grid[0][k] == 1)\\n                    dfs(0, k);\\n        }\\n        else\\n        {\\n            counter += 1;\\n            grid[i][j] = CONNECTED_TO_ROOF;\\n            int x[4] = {i+1, i-1, i, i};\\n            int y[4] = {j, j, j-1, j+1};\\n\\n            for(int k = 0; k < 4; k++)\\n            {\\n                if(valid_cell(x[k], y[k]) && grid[x[k]][y[k]] == 1)\\n                    dfs(x[k], y[k]);\\n            }\\n        }\\n    }\\n\\n    vector<int> hitBricks(vector<vector<int>>& gridPassed, vector<vector<int>>& hits)\\n    {\\n        grid = gridPassed;\\n        n = grid.size();\\n        m = grid[0].size();\\n\\n        for(auto cell: hits)\\n            grid[cell[0]][cell[1]] = 0;\\n\\n        dfs(-1, -1);\\n\\n        vector<int> ans(hits.size());\\n\\n        for(int r_ind = hits.size()-1; r_ind >= 0; r_ind--)\\n        {\\n            int i = hits[r_ind][0];\\n            int j = hits[r_ind][1];\\n\\n            if(gridPassed[i][j] == 1)\\n            {\\n                bool exist_neighbor_connected_to_roof = false;\\n                int x[4] = {i+1, i-1, i, i};\\n                int y[4] = {j, j, j-1, j+1};\\n\\n                for(int k = 0; k < 4; k++)\\n                    if(x[k] == -1 || (valid_cell(x[k], y[k]) && grid[x[k]][y[k]] == CONNECTED_TO_ROOF))\\n                        exist_neighbor_connected_to_roof = true;\\n\\n                grid[i][j] = 1;\\n                if(exist_neighbor_connected_to_roof)\\n                {\\n                    counter = 0;\\n                    dfs(i, j);\\n\\n                    ans[r_ind] = counter - 1;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678931,
                "title": "recreating-graph-reverse-approach-beats-99-35",
                "content": "* Whenever doing the brick hit, we need to count all the fallen bricks which will take O(N^2) time\\n* Even if you want to know effect of only single brick it might take you O(N) again, also the shape of graph will keep changing with online query\\n* Reverse it!, instead of breaking the original graph with each hit, try to create a new graph when the hits happen backward\\n* Say a brick was hit and due to which fallen bricks are x, now while reversing, whenever this was hit, and we know there was a brick we just join the fallen over bricks to the top if possible, hence the number of fallen bricks essentially is number of new bricks joined when we attach a brick to the wall\\n* We store in **bricks** if at some hit brick was there or not, and if brick was there and it is connected to top then only it will contribute to join the part of bricks (which in actual case were fallen due to this)\\n* If the brick was not connected to the top then there is eithet no brick or brick was even unstable itself so must have fallen, thus push 0 for such case\\n\\n```\\nclass Solution {\\npublic:\\n    /**\\n     * @param grid: a grid\\n     * @param hits: some erasures order\\n     * @return: an array representing the number of bricks that will drop after each erasure in sequence\\n     */\\n    int matrix[201][201];\\n    int n,m;\\n    bool vis[201][201]={0};\\n    int cnt=0;\\n    int dx[4]={1,-1,0,0};\\n    int dy[4]={0,0,1,-1};\\n    void dfs(int x,int y){\\n        if(!vis[x][y])cnt++;\\n        vis[x][y]=1;\\n        for(int i=0;i<4;i++){\\n            int nx=x+dx[i];\\n            int ny=y+dy[i];\\n\\t\\t\\t// only visit new bricks if valid and exist\\n            if(nx>=0 && ny>=0 && nx<n && ny<m && matrix[nx][ny]==1 && !vis[nx][ny])\\n                dfs(nx,ny);\\n        }\\n    }\\n    bool is_connected(int x,int y){\\n        if(x==0){\\n            return true;\\n        }\\n        for(int i=0;i<4;i++){\\n            int nx=x+dx[i];\\n            int ny=y+dy[i];\\n            if(nx>=0 && ny>=0 && nx<n && ny<m && matrix[nx][ny]==1 && vis[nx][ny]){\\n               return true; \\n            }\\n        }\\n        return false;\\n        \\n    }\\n    \\n    vector<int> hitBricks(vector<vector<int>> &grid, vector<vector<int>> &hits) {\\n        memset(matrix,0,sizeof(matrix));\\n        n = grid.size();\\n        m = grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vis[i][j]=0;\\n                matrix[i][j]=grid[i][j];\\n            }\\n        }\\n            // for each hit just store the value if there was some brick here or not\\n            // and if it was just reset to 0 in matrix\\n        vector<pair<pair<int,int> ,int> > bricks;\\n        for(int i=0;i<hits.size();i++){\\n            if(matrix[hits[i][0]][hits[i][1]]){\\n                matrix[hits[i][0]][hits[i][1]]=0;\\n                bricks.push_back({{hits[i][0],hits[i][1]},1});\\n            }\\n            else{\\n                bricks.push_back({{hits[i][0],hits[i][1]},0});\\n            }\\n        }\\n        // now find the answer if all hits were done\\n\\t\\t// dont count the top bricks which were not fallen anyway\\n        for(int i=0;i<m;i++){\\n            if(!vis[0][i] && matrix[0][i])\\n            dfs(0,i);\\n        }\\n        vector<int> ans;\\n\\t\\t//iterate hits backwards\\n        for(int i=bricks.size()-1;i>=0;i--){\\n            int x=bricks[i].first.first;\\n            int y=bricks[i].first.second;\\n            int was_brick=bricks[i].second;\\n\\t\\t\\t//cnt of joined bricks with current hit\\n            cnt=0;\\n            if(was_brick){\\n                // there was a brick\\n                // find if any of its 4 neighbours connected to 1\\n                matrix[x][y]=1;\\n                if(is_connected(x,y)){\\n                    vis[x][y]=1;\\n                    dfs(x,y);\\n                }\\n            }\\n            ans.push_back(cnt);\\n        }\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /**\\n     * @param grid: a grid\\n     * @param hits: some erasures order\\n     * @return: an array representing the number of bricks that will drop after each erasure in sequence\\n     */\\n    int matrix[201][201];\\n    int n,m;\\n    bool vis[201][201]={0};\\n    int cnt=0;\\n    int dx[4]={1,-1,0,0};\\n    int dy[4]={0,0,1,-1};\\n    void dfs(int x,int y){\\n        if(!vis[x][y])cnt++;\\n        vis[x][y]=1;\\n        for(int i=0;i<4;i++){\\n            int nx=x+dx[i];\\n            int ny=y+dy[i];\\n\\t\\t\\t// only visit new bricks if valid and exist\\n            if(nx>=0 && ny>=0 && nx<n && ny<m && matrix[nx][ny]==1 && !vis[nx][ny])\\n                dfs(nx,ny);\\n        }\\n    }\\n    bool is_connected(int x,int y){\\n        if(x==0){\\n            return true;\\n        }\\n        for(int i=0;i<4;i++){\\n            int nx=x+dx[i];\\n            int ny=y+dy[i];\\n            if(nx>=0 && ny>=0 && nx<n && ny<m && matrix[nx][ny]==1 && vis[nx][ny]){\\n               return true; \\n            }\\n        }\\n        return false;\\n        \\n    }\\n    \\n    vector<int> hitBricks(vector<vector<int>> &grid, vector<vector<int>> &hits) {\\n        memset(matrix,0,sizeof(matrix));\\n        n = grid.size();\\n        m = grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vis[i][j]=0;\\n                matrix[i][j]=grid[i][j];\\n            }\\n        }\\n            // for each hit just store the value if there was some brick here or not\\n            // and if it was just reset to 0 in matrix\\n        vector<pair<pair<int,int> ,int> > bricks;\\n        for(int i=0;i<hits.size();i++){\\n            if(matrix[hits[i][0]][hits[i][1]]){\\n                matrix[hits[i][0]][hits[i][1]]=0;\\n                bricks.push_back({{hits[i][0],hits[i][1]},1});\\n            }\\n            else{\\n                bricks.push_back({{hits[i][0],hits[i][1]},0});\\n            }\\n        }\\n        // now find the answer if all hits were done\\n\\t\\t// dont count the top bricks which were not fallen anyway\\n        for(int i=0;i<m;i++){\\n            if(!vis[0][i] && matrix[0][i])\\n            dfs(0,i);\\n        }\\n        vector<int> ans;\\n\\t\\t//iterate hits backwards\\n        for(int i=bricks.size()-1;i>=0;i--){\\n            int x=bricks[i].first.first;\\n            int y=bricks[i].first.second;\\n            int was_brick=bricks[i].second;\\n\\t\\t\\t//cnt of joined bricks with current hit\\n            cnt=0;\\n            if(was_brick){\\n                // there was a brick\\n                // find if any of its 4 neighbours connected to 1\\n                matrix[x][y]=1;\\n                if(is_connected(x,y)){\\n                    vis[x][y]=1;\\n                    dfs(x,y);\\n                }\\n            }\\n            ans.push_back(cnt);\\n        }\\n    reverse(ans.begin(),ans.end());\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 120382,
                "title": "c-o-n-n-reverse-time-dfs-with-explanations-and-proof",
                "content": "Let\\'s start at the end. Use DFS to see which bricks are still alive. Now we add back one brick at a time. \\n\\nThere are 3 cases:\\n- Brick has been erased before. In this case no brick is added back.\\n- Brick has not been erased. If the brick was alive at somepoint then we put the brick in zombie mode.\\n- If the zombie brick is at the top or it is adjacent to an alive brick, then we bring back all the existing zombie bricks. Since it is clear now that these bricks weren\\'t dropped/erased before that due them connecting to alive top bricks, they are all legitimate.\\n\\nThe complexity at the step in case 3, which is a dfs is the number of zombie bricks. Since each brick can only turn to alive state from zombie state once, the total complexity is of this step is O(#bricks)\\n\\n```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<vector<int>> &g) {\\n        int n = g.size(), m = g[0].size();\\n        if (i < 0 || j < 0 || i >=n || j >= m) return 0;\\n        if (!g[i][j] || g[i][j] > 1) return 0 ;\\n        g[i][j] = 2;\\n        return 1 \\n            + dfs(i+1,j,g)\\n            + dfs(i-1,j,g)\\n            + dfs(i,j+1,g)\\n            + dfs(i,j-1,g);\\n    }\\n    \\n    vector<int> hitBricks(vector<vector<int>>& g, vector<vector<int>>& h) {\\n        int n = g.size(), m = g[0].size();\\n        vector<vector<int>>s(n, vector<int>(m)), t = g;\\n        for (auto &v:h) g[v[0]][v[1]] = 0, ++s[v[0]][v[1]];\\n        for (int j = 0; j < m; ++j) if (g[0][j]) dfs(0,j,g);\\n        for (auto &v:h) if (g[v[0]][v[1]] == 1) g[v[0]][v[1]] = 0;\\n        reverse(h.begin(), h.end());\\n        vector<int> ans;\\n        for (auto &v:h) {\\n            int r = v[0], c = v[1];\\n            if (--s[r][c] == 0 && t[r][c]) {\\n                g[r][c] = 1;\\n                bool gd = 0;\\n                if (r && g[r-1][c] == 2) gd = 1;\\n                if (c && g[r][c-1] == 2) gd = 1;\\n                if (r < n -1 && g[r+1][c] == 2) gd = 1;\\n                if (c < m -1 && g[r][c+1] == 2) gd = 1;\\n                if (r == 0) gd = 1;\\n                if (gd) ans.push_back(dfs(r,c,g) - 1);\\n                else ans.push_back(0);\\n            }\\n            else ans.push_back(0);\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<vector<int>> &g) {\\n        int n = g.size(), m = g[0].size();\\n        if (i < 0 || j < 0 || i >=n || j >= m) return 0;\\n        if (!g[i][j] || g[i][j] > 1) return 0 ;\\n        g[i][j] = 2;\\n        return 1 \\n            + dfs(i+1,j,g)\\n            + dfs(i-1,j,g)\\n            + dfs(i,j+1,g)\\n            + dfs(i,j-1,g);\\n    }\\n    \\n    vector<int> hitBricks(vector<vector<int>>& g, vector<vector<int>>& h) {\\n        int n = g.size(), m = g[0].size();\\n        vector<vector<int>>s(n, vector<int>(m)), t = g;\\n        for (auto &v:h) g[v[0]][v[1]] = 0, ++s[v[0]][v[1]];\\n        for (int j = 0; j < m; ++j) if (g[0][j]) dfs(0,j,g);\\n        for (auto &v:h) if (g[v[0]][v[1]] == 1) g[v[0]][v[1]] = 0;\\n        reverse(h.begin(), h.end());\\n        vector<int> ans;\\n        for (auto &v:h) {\\n            int r = v[0], c = v[1];\\n            if (--s[r][c] == 0 && t[r][c]) {\\n                g[r][c] = 1;\\n                bool gd = 0;\\n                if (r && g[r-1][c] == 2) gd = 1;\\n                if (c && g[r][c-1] == 2) gd = 1;\\n                if (r < n -1 && g[r+1][c] == 2) gd = 1;\\n                if (c < m -1 && g[r][c+1] == 2) gd = 1;\\n                if (r == 0) gd = 1;\\n                if (gd) ans.push_back(dfs(r,c,g) - 1);\\n                else ans.push_back(0);\\n            }\\n            else ans.push_back(0);\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710066,
                "title": "c-union-find-well-commented-clean-code",
                "content": "```\\n// standard union find template, slightly modified for this question\\nclass UnionFind {\\n\\npublic:\\n\\n\\tvector<int> parent, rank, size;\\n    int n;\\n    \\n    UnionFind(int n){\\n        this->n = n;\\n        parent = vector<int>(n);\\n        rank = vector<int>(n);\\n\\t\\tsize = vector<int>(n);\\n        \\n        for(int i=0; i<n; i++){\\n            parent[i] = i; // parent of each node will be itself initially\\n            rank[i] = 0; // rank will be 0 for all nodes initially\\n\\t\\t\\tsize[i] = 1; // size will be 1 for all nodes initially\\n        }\\n    }\\n    \\n    // finds the parent of given node u\\n    int find(int u) {\\n\\t\\t// if the node is the parent of itself, then it is the root of the set \\n        if(u == parent[u]){\\n            return u;\\n        }\\n\\t\\t// else, find the parent while also compressing the paths\\n        return u = find(parent[u]);\\n    }\\n    \\n    // merges two sets into one, u and v belong to the corresponding sets\\n\\t// performs union by rank\\n    void unionByRank(int u, int v) {\\n        // find the parents of u and v\\n        u = find(u);\\n        v = find(v);\\n        \\n        // if u and v does not belong to the same set\\n        if(u != v){\\n\\t\\t\\t// if tree has lower rank\\n            if(rank[u] < rank[v]){\\n                swap(u, v);\\n            }\\n            \\n            // attach lower rank tree to higher rank tree\\n            parent[v] = u;\\n            \\n\\t\\t\\t// if the ranks become equal, then increase the rank\\n            if(rank[u] == rank[v]){\\n                rank[u]++;\\n            }\\n        }\\n    }\\n\\n\\t// perform union by size\\n\\tint unionBySize(int u, int v) {\\n\\t\\t// find the parents of u and v\\n\\t\\tu = find(u);\\n\\t\\tv = find(v);\\n        int res = 0;\\n\\n\\t\\t// if u and v do not belong to the same set\\n\\t\\tif(u != v) {\\n            // if the bricks belonging to the set v is not stable\\n            if(find(v) != find(n-1)) res = size[v];\\n\\n\\t\\t\\t// if size of u is smaller\\n\\t\\t\\tif(size[u] < size[v]) {\\n\\t\\t\\t\\tswap(u, v);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// attach smaller size tree to larger size tree\\n\\t\\t\\tparent[v] = u;\\n\\n\\t\\t\\t// the tree u now contains all the elements of v as well\\n\\t\\t\\tsize[u] += size[v];\\n\\t\\t}\\n\\n        return res;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int m, n;\\n\\n    int toInd(int x, int y) {\\n        return n*x + y;\\n    }\\n\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        m=grid.size(), n=grid[0].size();\\n\\n        // remove the nodes that are present in hits from the grid\\n        for(vector<int>& hit : hits) {\\n            int x=hit[0], y=hit[1];\\n\\n            // remove the node only if it is actually present in the grid\\n            if(grid[x][y]==1) grid[x][y] = -1;\\n        }\\n\\n        // create UnionFind of size m*n + 1;\\n        UnionFind uf(m*n + 1);\\n\\n        // connect the first row nodes to the top of the grid represented by the special node m*n\\n        for(int i=0; i<n; i++) {\\n            if(grid[0][i]==1) uf.unionBySize(i, m*n);\\n        }\\n\\n        // connect the remaining nodes\\n        for(int i=1; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j]==1) {\\n                    if(grid[i-1][j]==1) uf.unionBySize(toInd(i,j), toInd(i-1,j));\\n                    if(i+1<m and grid[i+1][j]==1) uf.unionBySize(toInd(i,j), toInd(i+1,j));\\n                    if(j-1>=0 and grid[i][j-1]==1) uf.unionBySize(toInd(i,j), toInd(i,j-1));\\n                    if(j+1<n and grid[i][j+1]==1) uf.unionBySize(toInd(i,j), toInd(i,j+1));\\n                }\\n            }\\n        }\\n\\n        // reverse the hits\\n        reverse(hits.begin(), hits.end());\\n\\n        // now add the nodes deleted by hits one by one and check the number of nodes that become stable\\n        vector<int> result;\\n\\n        for(vector<int>& hit : hits) {\\n            int x=hit[0], y=hit[1];\\n\\n            // if the node was not present in the initial grid\\n            if(grid[x][y] != -1) {\\n                result.push_back(0);\\n                continue;\\n            }\\n\\n            // add the node back to the grid\\n            grid[x][y] = 1;\\n\\n            // check if the node belongs to the first row, if true then connect it to the special node m*n\\n            if(x == 0) uf.unionBySize(toInd(x,y), m*n);\\n\\n            // the number of nodes that belong to the adjacent non-stable components\\n            int count = 0;\\n\\n            // connect the current node to the adjacent nodes\\n            if(x-1>=0 and grid[x-1][y]==1) count += uf.unionBySize(toInd(x,y),toInd(x-1,y));\\n            if(x+1<m and grid[x+1][y]==1) count += uf.unionBySize(toInd(x,y),toInd(x+1,y));\\n            if(y-1>=0 and grid[x][y-1]==1) count += uf.unionBySize(toInd(x,y),toInd(x,y-1));\\n            if(y+1<n and grid[x][y+1]==1) count += uf.unionBySize(toInd(x,y),toInd(x,y+1));\\n\\n            // if the current node became stable or was already stable\\n            if(uf.find(toInd(x,y)) == uf.find(m*n)) result.push_back(count);\\n            else result.push_back(0);\\n        }\\n\\n        reverse(result.begin(), result.end());\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// standard union find template, slightly modified for this question\\nclass UnionFind {\\n\\npublic:\\n\\n\\tvector<int> parent, rank, size;\\n    int n;\\n    \\n    UnionFind(int n){\\n        this->n = n;\\n        parent = vector<int>(n);\\n        rank = vector<int>(n);\\n\\t\\tsize = vector<int>(n);\\n        \\n        for(int i=0; i<n; i++){\\n            parent[i] = i; // parent of each node will be itself initially\\n            rank[i] = 0; // rank will be 0 for all nodes initially\\n\\t\\t\\tsize[i] = 1; // size will be 1 for all nodes initially\\n        }\\n    }\\n    \\n    // finds the parent of given node u\\n    int find(int u) {\\n\\t\\t// if the node is the parent of itself, then it is the root of the set \\n        if(u == parent[u]){\\n            return u;\\n        }\\n\\t\\t// else, find the parent while also compressing the paths\\n        return u = find(parent[u]);\\n    }\\n    \\n    // merges two sets into one, u and v belong to the corresponding sets\\n\\t// performs union by rank\\n    void unionByRank(int u, int v) {\\n        // find the parents of u and v\\n        u = find(u);\\n        v = find(v);\\n        \\n        // if u and v does not belong to the same set\\n        if(u != v){\\n\\t\\t\\t// if tree has lower rank\\n            if(rank[u] < rank[v]){\\n                swap(u, v);\\n            }\\n            \\n            // attach lower rank tree to higher rank tree\\n            parent[v] = u;\\n            \\n\\t\\t\\t// if the ranks become equal, then increase the rank\\n            if(rank[u] == rank[v]){\\n                rank[u]++;\\n            }\\n        }\\n    }\\n\\n\\t// perform union by size\\n\\tint unionBySize(int u, int v) {\\n\\t\\t// find the parents of u and v\\n\\t\\tu = find(u);\\n\\t\\tv = find(v);\\n        int res = 0;\\n\\n\\t\\t// if u and v do not belong to the same set\\n\\t\\tif(u != v) {\\n            // if the bricks belonging to the set v is not stable\\n            if(find(v) != find(n-1)) res = size[v];\\n\\n\\t\\t\\t// if size of u is smaller\\n\\t\\t\\tif(size[u] < size[v]) {\\n\\t\\t\\t\\tswap(u, v);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// attach smaller size tree to larger size tree\\n\\t\\t\\tparent[v] = u;\\n\\n\\t\\t\\t// the tree u now contains all the elements of v as well\\n\\t\\t\\tsize[u] += size[v];\\n\\t\\t}\\n\\n        return res;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int m, n;\\n\\n    int toInd(int x, int y) {\\n        return n*x + y;\\n    }\\n\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        m=grid.size(), n=grid[0].size();\\n\\n        // remove the nodes that are present in hits from the grid\\n        for(vector<int>& hit : hits) {\\n            int x=hit[0], y=hit[1];\\n\\n            // remove the node only if it is actually present in the grid\\n            if(grid[x][y]==1) grid[x][y] = -1;\\n        }\\n\\n        // create UnionFind of size m*n + 1;\\n        UnionFind uf(m*n + 1);\\n\\n        // connect the first row nodes to the top of the grid represented by the special node m*n\\n        for(int i=0; i<n; i++) {\\n            if(grid[0][i]==1) uf.unionBySize(i, m*n);\\n        }\\n\\n        // connect the remaining nodes\\n        for(int i=1; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j]==1) {\\n                    if(grid[i-1][j]==1) uf.unionBySize(toInd(i,j), toInd(i-1,j));\\n                    if(i+1<m and grid[i+1][j]==1) uf.unionBySize(toInd(i,j), toInd(i+1,j));\\n                    if(j-1>=0 and grid[i][j-1]==1) uf.unionBySize(toInd(i,j), toInd(i,j-1));\\n                    if(j+1<n and grid[i][j+1]==1) uf.unionBySize(toInd(i,j), toInd(i,j+1));\\n                }\\n            }\\n        }\\n\\n        // reverse the hits\\n        reverse(hits.begin(), hits.end());\\n\\n        // now add the nodes deleted by hits one by one and check the number of nodes that become stable\\n        vector<int> result;\\n\\n        for(vector<int>& hit : hits) {\\n            int x=hit[0], y=hit[1];\\n\\n            // if the node was not present in the initial grid\\n            if(grid[x][y] != -1) {\\n                result.push_back(0);\\n                continue;\\n            }\\n\\n            // add the node back to the grid\\n            grid[x][y] = 1;\\n\\n            // check if the node belongs to the first row, if true then connect it to the special node m*n\\n            if(x == 0) uf.unionBySize(toInd(x,y), m*n);\\n\\n            // the number of nodes that belong to the adjacent non-stable components\\n            int count = 0;\\n\\n            // connect the current node to the adjacent nodes\\n            if(x-1>=0 and grid[x-1][y]==1) count += uf.unionBySize(toInd(x,y),toInd(x-1,y));\\n            if(x+1<m and grid[x+1][y]==1) count += uf.unionBySize(toInd(x,y),toInd(x+1,y));\\n            if(y-1>=0 and grid[x][y-1]==1) count += uf.unionBySize(toInd(x,y),toInd(x,y-1));\\n            if(y+1<n and grid[x][y+1]==1) count += uf.unionBySize(toInd(x,y),toInd(x,y+1));\\n\\n            // if the current node became stable or was already stable\\n            if(uf.find(toInd(x,y)) == uf.find(m*n)) result.push_back(count);\\n            else result.push_back(0);\\n        }\\n\\n        reverse(result.begin(), result.end());\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824820,
                "title": "java-clean-dfs-solution-with-explanation-15ms-reversely-adding-bricks",
                "content": "The Brute force approach is to remove bricks and do a dfs for each column at row == 0 after each hit. This will TLE.\\n\\nA clever approach would be to modify the grid into end state and restore the bricks instead of erasing them. This way we\\'ll only have to do a dfs from that particular restored position.\\n\\nTo achieve this we would need to modify the grid with new states. Here\\'s the states that i used.\\n```\\nBrick is not present -> 0\\nBrick is present and stable -> 2 (These are the stables bricks at any given state)\\nBrick is present and unstable -> 1 (These are the bricks that will be restored in the future)\\nBrick was present but has been removed after the hit -> -1 (These are the bricks that will act as the starting point for our restoration process)\\n```\\n\\n***So after we have modified the grid our problem statement breaks down to how many bricks were restored before that hit***\\n\\nHere are the steps followed in the code\\nGrid modification:\\n* Change the state of all the hit position that has brick to -1 (so that we know these are the starting points for our restoration process)\\n* Change the state of all the stable bricks to 2, do a dfs from each column at row == 0\\n\\nNow for the fun part. This is the restoration process:\\n* For each restoration, check whether its stable\\n\\t* If its stable do a dfs from that position to mark all the reachable node and itself to state 2. Please note the ```markAndCountStableBricks``` func also returns the number of bricks restored.\\n\\t* Otherwise just change the state of this restored brick to 1\\n\\n\\n```\\nclass Solution {\\n    int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        //marking all the hits that has a brick with -1\\n        for(int i=0;i<hits.length;i++)\\n            if(grid[hits[i][0]][hits[i][1]] == 1)\\n                grid[hits[i][0]][hits[i][1]] = -1;\\n        \\n        //marking all the stable bricks\\n        for(int i=0;i<grid[0].length;i++)\\n            markAndCountStableBricks(grid, 0, i);\\n        \\n        int[] res = new int[hits.length];\\n        //looping over hits array backwards and restoring bricks\\n        for(int i=hits.length-1;i>=0;i--){\\n            int row = hits[i][0];\\n            int col = hits[i][1];\\n            \\n            //hit is at empty space so continue\\n            if(grid[row][col] == 0)\\n                continue;\\n            \\n            //marking it with 1, this signifies that a brick is present in an unstable state and will be restored in the future\\n            grid[row][col] = 1;\\n            // checking brick stability, if it\\'s unstable no need to visit the neighbours\\n            if(!isStable(grid, row, col))\\n                continue;\\n\\t\\t\\t\\n\\t\\t\\t//So now as our brick is stable we can restore all the bricks connected to it\\n            //mark all the unstable bricks as stable and get the count\\n            res[i] = markAndCountStableBricks(grid, hits[i][0], hits[i][1])-1; //Subtracting 1 from the total count, as we don\\'t wanna include the starting restored brick\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int markAndCountStableBricks(int[][] grid, int row, int col){\\n        if(grid[row][col] == 0 || grid[row][col] == -1)\\n            return 0;\\n        \\n        grid[row][col] = 2;\\n        int stableBricks = 1;\\n        for(int[] dir:dirs){\\n            int r = row+dir[0];\\n            int c = col+dir[1];\\n            \\n            if(r < 0 || r >= grid.length || c < 0 || c >= grid[0].length)\\n                continue;\\n            \\n            if(grid[r][c] == 0 || grid[r][c] == -1 || grid[r][c] == 2)\\n                continue;\\n            \\n            stableBricks += markAndCountStableBricks(grid, r, c);\\n        }\\n        \\n        return stableBricks;\\n    }\\n    \\n    private boolean isStable(int[][] grid, int row, int col){\\n        if(row == 0)\\n            return true;\\n        \\n        for(int[] dir:dirs){\\n            int r = row+dir[0];\\n            int c = col+dir[1];\\n            \\n            if(r < 0 || r >= grid.length || c < 0 || c >= grid[0].length)\\n                continue;\\n            \\n            if(grid[r][c] == 2)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\nFor the second approach where we reversely add bricks, I had to come to discussion section.\\nI found this explanation wonderful: [Brick Restoration](https://leetcode.com/problems/bricks-falling-when-hit/discuss/450482/From-bad(general-intuition)-to-good(-reversely-adding-bricks))\\nMy code is a slight modfication of this and written in java.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nBrick is not present -> 0\\nBrick is present and stable -> 2 (These are the stables bricks at any given state)\\nBrick is present and unstable -> 1 (These are the bricks that will be restored in the future)\\nBrick was present but has been removed after the hit -> -1 (These are the bricks that will act as the starting point for our restoration process)\\n```\n```markAndCountStableBricks```\n```\\nclass Solution {\\n    int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        //marking all the hits that has a brick with -1\\n        for(int i=0;i<hits.length;i++)\\n            if(grid[hits[i][0]][hits[i][1]] == 1)\\n                grid[hits[i][0]][hits[i][1]] = -1;\\n        \\n        //marking all the stable bricks\\n        for(int i=0;i<grid[0].length;i++)\\n            markAndCountStableBricks(grid, 0, i);\\n        \\n        int[] res = new int[hits.length];\\n        //looping over hits array backwards and restoring bricks\\n        for(int i=hits.length-1;i>=0;i--){\\n            int row = hits[i][0];\\n            int col = hits[i][1];\\n            \\n            //hit is at empty space so continue\\n            if(grid[row][col] == 0)\\n                continue;\\n            \\n            //marking it with 1, this signifies that a brick is present in an unstable state and will be restored in the future\\n            grid[row][col] = 1;\\n            // checking brick stability, if it\\'s unstable no need to visit the neighbours\\n            if(!isStable(grid, row, col))\\n                continue;\\n\\t\\t\\t\\n\\t\\t\\t//So now as our brick is stable we can restore all the bricks connected to it\\n            //mark all the unstable bricks as stable and get the count\\n            res[i] = markAndCountStableBricks(grid, hits[i][0], hits[i][1])-1; //Subtracting 1 from the total count, as we don\\'t wanna include the starting restored brick\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int markAndCountStableBricks(int[][] grid, int row, int col){\\n        if(grid[row][col] == 0 || grid[row][col] == -1)\\n            return 0;\\n        \\n        grid[row][col] = 2;\\n        int stableBricks = 1;\\n        for(int[] dir:dirs){\\n            int r = row+dir[0];\\n            int c = col+dir[1];\\n            \\n            if(r < 0 || r >= grid.length || c < 0 || c >= grid[0].length)\\n                continue;\\n            \\n            if(grid[r][c] == 0 || grid[r][c] == -1 || grid[r][c] == 2)\\n                continue;\\n            \\n            stableBricks += markAndCountStableBricks(grid, r, c);\\n        }\\n        \\n        return stableBricks;\\n    }\\n    \\n    private boolean isStable(int[][] grid, int row, int col){\\n        if(row == 0)\\n            return true;\\n        \\n        for(int[] dir:dirs){\\n            int r = row+dir[0];\\n            int c = col+dir[1];\\n            \\n            if(r < 0 || r >= grid.length || c < 0 || c >= grid[0].length)\\n                continue;\\n            \\n            if(grid[r][c] == 2)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603387,
                "title": "java-explained-tc-explained",
                "content": "// Thanks to @zhengzw for the solution\\n// 1. Remove all bricks in hits. If the cell is originly 1-> 0 & if 0 -> -1, so that we can ADD the brick back;\\n// 2. DFS from the first row (roof), set all cells of bricks to 2 so that we know these cells have been visited.\\n// 3. Iterate from the LAST HIT to the first one, i.e., put the erasured bricks back. For every step:\\n// 3.1 if the cell is 0, continue;\\n// 3.2 Check if the cell is attathed to the roof (or any cell with value 2)\\n// If no, continue;\\n// Else, reuse the dfs function to count all the connected bricks (cells with value 1). These are bricks that fell down when we erase the hit! Remember to minus 1, which is the brick we erased.\\n\\n// TC : O(H * (4 + M*N)) -> H = hits.length , M = grid.length, N = grid[0].length -> for all the HITS we check isConnectedToRoof which has inner \\'for\\' loop which runs 4 times and then dfs() runs for M*N times\\n// SC : O(1)\\n\\n```\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        // Step 1\\n        for(int[] hit : hits) {\\n            int x = hit[0];\\n            int y = hit[1];\\n            \\n            grid[x][y]--; // make it 0 or -1 (if no brick at forst place)\\n        }\\n        \\n        // Step 2\\n        int row = 0;\\n        for(int col = 0; col < cols; col++) {\\n            dfs(row, col, grid);\\n        }\\n        \\n        // Step 3\\n        int[] res = new int[hits.length];\\n        for(int i = hits.length - 1; i >= 0; i--) {\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            \\n            grid[x][y]++; // if 0 then become 1 (if it was a brick initially)\\n            if(grid[x][y] == 1 && isConnectedToRoof(x, y, grid)) {\\n                res[i] = dfs(x, y, grid) - 1; // -1 because we added this grid[x][y] brick as well\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // this dfs() will check if the present cell of grid is Brick, and if it is brick then will convert it to 2 and gets the count of total bricks connected to this cell (similar to finding the num of islands)\\n    private int dfs(int i, int j, int[][] grid) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != 1) {\\n            return 0;\\n        }        \\n        grid[i][j] = 2;\\n        return dfs(i + 1, j, grid) \\n             + dfs(i - 1, j, grid)\\n             + dfs(i, j + 1, grid)\\n             + dfs(i, j - 1, grid) + 1;\\n    }\\n    \\n    // This checks if the present BRICK is connected to the roof (first row\\'s BRICK) or not; \\n    // if yes, then next step would be to count the bricks\\n    // if no, then we do not need to worry about the brick\\n    private boolean isConnectedToRoof(int i,int j, int[][] grid) {\\n        if (i == 0) {\\n            return true;\\n        }       \\n        for (int[] d : dirs) {\\n            int x = i + d[0], y = j + d[1];\\n            if (x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 2) {\\n                return true;\\n            }\\n        }               \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        // Step 1\\n        for(int[] hit : hits) {\\n            int x = hit[0];\\n            int y = hit[1];\\n            \\n            grid[x][y]--; // make it 0 or -1 (if no brick at forst place)\\n        }\\n        \\n        // Step 2\\n        int row = 0;\\n        for(int col = 0; col < cols; col++) {\\n            dfs(row, col, grid);\\n        }\\n        \\n        // Step 3\\n        int[] res = new int[hits.length];\\n        for(int i = hits.length - 1; i >= 0; i--) {\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            \\n            grid[x][y]++; // if 0 then become 1 (if it was a brick initially)\\n            if(grid[x][y] == 1 && isConnectedToRoof(x, y, grid)) {\\n                res[i] = dfs(x, y, grid) - 1; // -1 because we added this grid[x][y] brick as well\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // this dfs() will check if the present cell of grid is Brick, and if it is brick then will convert it to 2 and gets the count of total bricks connected to this cell (similar to finding the num of islands)\\n    private int dfs(int i, int j, int[][] grid) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != 1) {\\n            return 0;\\n        }        \\n        grid[i][j] = 2;\\n        return dfs(i + 1, j, grid) \\n             + dfs(i - 1, j, grid)\\n             + dfs(i, j + 1, grid)\\n             + dfs(i, j - 1, grid) + 1;\\n    }\\n    \\n    // This checks if the present BRICK is connected to the roof (first row\\'s BRICK) or not; \\n    // if yes, then next step would be to count the bricks\\n    // if no, then we do not need to worry about the brick\\n    private boolean isConnectedToRoof(int i,int j, int[][] grid) {\\n        if (i == 0) {\\n            return true;\\n        }       \\n        for (int[] d : dirs) {\\n            int x = i + d[0], y = j + d[1];\\n            if (x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 2) {\\n                return true;\\n            }\\n        }               \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505117,
                "title": "c-803-bricks-falling-when-hit",
                "content": "\\n```\\nclass UnionFind {\\n    vector<int> parent, rank; \\n    \\npublic: \\n    UnionFind(int n) {\\n        parent.resize(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        rank = vector<int>(n, 1); \\n    }\\n    \\n    int find(int p) {\\n        if (p != parent[p]) \\n            parent[p] = find(parent[p]); \\n        return parent[p]; \\n    }\\n    \\n    bool connect(int p, int q) {\\n        int prt = find(p), qrt = find(q); \\n        if (prt == qrt) return false; \\n        if (rank[prt] > rank[qrt]) swap(prt, qrt); \\n        parent[prt] = qrt; \\n        rank[qrt] += rank[prt]; \\n        return true; \\n    }\\n    \\n    int top() {\\n        return rank[find(parent.size()-1)]; \\n    }\\n}; \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        int m = grid.size(), n = grid[0].size(), dir[5] = {-1, 0, 1, 0, -1}; \\n        vector<vector<bool>> on(m, vector<bool>(n)); \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j)\\n                if (grid[i][j]) on[i][j] = true; \\n        \\n        for (auto& hit : hits) \\n            grid[hit[0]][hit[1]] = 0; \\n        \\n        UnionFind* uf = new UnionFind(m*n+1); \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                if (grid[i][j]) {\\n                    if (i == 0) uf->connect(j, m*n); \\n                    for (int k = 0; k < 4; ++k) {\\n                        int ii = i + dir[k], jj = j + dir[k+1]; \\n                        if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj])\\n                            uf->connect(i*n+j, ii*n+jj); \\n                    }\\n                }\\n        \\n        vector<int> ans; \\n        int prev = uf->top(); \\n        for (int x = hits.size()-1; x >= 0; --x) {\\n            int i = hits[x][0], j = hits[x][1]; \\n            if (on[i][j]) {\\n                grid[i][j] = 1; \\n                if (i == 0) uf->connect(j, m*n); \\n                for (int k = 0; k < 4; ++k) {\\n                    int ii = i + dir[k], jj = j + dir[k+1]; \\n                    if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj]) \\n                        uf->connect(i*n+j, ii*n+jj); \\n                }\\n                int rank = uf->top(); \\n                ans.push_back(max(0, rank - prev - 1)); \\n                prev = rank; \\n            } else \\n                ans.push_back(0); \\n        }\\n        reverse(ans.begin(), ans.end()); \\n        return ans; \\n    }\\n}; \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass UnionFind {\\n    vector<int> parent, rank; \\n    \\npublic: \\n    UnionFind(int n) {\\n        parent.resize(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        rank = vector<int>(n, 1); \\n    }\\n    \\n    int find(int p) {\\n        if (p != parent[p]) \\n            parent[p] = find(parent[p]); \\n        return parent[p]; \\n    }\\n    \\n    bool connect(int p, int q) {\\n        int prt = find(p), qrt = find(q); \\n        if (prt == qrt) return false; \\n        if (rank[prt] > rank[qrt]) swap(prt, qrt); \\n        parent[prt] = qrt; \\n        rank[qrt] += rank[prt]; \\n        return true; \\n    }\\n    \\n    int top() {\\n        return rank[find(parent.size()-1)]; \\n    }\\n}; \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        int m = grid.size(), n = grid[0].size(), dir[5] = {-1, 0, 1, 0, -1}; \\n        vector<vector<bool>> on(m, vector<bool>(n)); \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j)\\n                if (grid[i][j]) on[i][j] = true; \\n        \\n        for (auto& hit : hits) \\n            grid[hit[0]][hit[1]] = 0; \\n        \\n        UnionFind* uf = new UnionFind(m*n+1); \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                if (grid[i][j]) {\\n                    if (i == 0) uf->connect(j, m*n); \\n                    for (int k = 0; k < 4; ++k) {\\n                        int ii = i + dir[k], jj = j + dir[k+1]; \\n                        if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj])\\n                            uf->connect(i*n+j, ii*n+jj); \\n                    }\\n                }\\n        \\n        vector<int> ans; \\n        int prev = uf->top(); \\n        for (int x = hits.size()-1; x >= 0; --x) {\\n            int i = hits[x][0], j = hits[x][1]; \\n            if (on[i][j]) {\\n                grid[i][j] = 1; \\n                if (i == 0) uf->connect(j, m*n); \\n                for (int k = 0; k < 4; ++k) {\\n                    int ii = i + dir[k], jj = j + dir[k+1]; \\n                    if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj]) \\n                        uf->connect(i*n+j, ii*n+jj); \\n                }\\n                int rank = uf->top(); \\n                ans.push_back(max(0, rank - prev - 1)); \\n                prev = rank; \\n            } else \\n                ans.push_back(0); \\n        }\\n        reverse(ans.begin(), ans.end()); \\n        return ans; \\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505073,
                "title": "python3-union-find",
                "content": "\\n```\\nclass UnionFind: \\n    \\n    def __init__(self, n): \\n        self.parent = list(range(n))\\n        self.rank = [1] * n\\n        \\n    def find(self, p): \\n        if p != self.parent[p]: \\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q):\\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt\\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt]\\n        return True \\n\\n\\nclass Solution:\\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0]) # dimensions \\n        \\n        seen = set()\\n        for i, j in hits: \\n            if grid[i][j]: \\n                seen.add((i, j))\\n                grid[i][j] = 0\\n        \\n        uf = UnionFind(m*n+1)\\n        for i in range(m): \\n            for j in range(n): \\n                if i == 0 and grid[i][j]: uf.union(j, m*n)\\n                if grid[i][j]: \\n                    for ii, jj in (i-1, j), (i, j-1): \\n                        if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]: uf.union(i*n+j, ii*n+jj)\\n        \\n        ans = []\\n        prev = uf.rank[uf.find(m*n)]\\n        for i, j in reversed(hits): \\n            if (i, j) in seen: \\n                grid[i][j] = 1\\n                if i == 0: uf.union(j, m*n)\\n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]: uf.union(i*n+j, ii*n+jj)\\n                rank = uf.rank[uf.find(m*n)]\\n                ans.append(max(0, rank - prev - 1))\\n                prev = rank\\n            else: ans.append(0)\\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind: \\n    \\n    def __init__(self, n): \\n        self.parent = list(range(n))\\n        self.rank = [1] * n\\n        \\n    def find(self, p): \\n        if p != self.parent[p]: \\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q):\\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt\\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt]\\n        return True \\n\\n\\nclass Solution:\\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0]) # dimensions \\n        \\n        seen = set()\\n        for i, j in hits: \\n            if grid[i][j]: \\n                seen.add((i, j))\\n                grid[i][j] = 0\\n        \\n        uf = UnionFind(m*n+1)\\n        for i in range(m): \\n            for j in range(n): \\n                if i == 0 and grid[i][j]: uf.union(j, m*n)\\n                if grid[i][j]: \\n                    for ii, jj in (i-1, j), (i, j-1): \\n                        if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]: uf.union(i*n+j, ii*n+jj)\\n        \\n        ans = []\\n        prev = uf.rank[uf.find(m*n)]\\n        for i, j in reversed(hits): \\n            if (i, j) in seen: \\n                grid[i][j] = 1\\n                if i == 0: uf.union(j, m*n)\\n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]: uf.union(i*n+j, ii*n+jj)\\n                rank = uf.rank[uf.find(m*n)]\\n                ans.append(max(0, rank - prev - 1))\\n                prev = rank\\n            else: ans.append(0)\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273274,
                "title": "java-clean-union-find-solution-with-comments",
                "content": "```\\nclass Solution {\\n    int[] parents;\\n    int[] sizes;\\n    int m, n;\\n    \\n    private static final int[][] DIRECTIONS = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        \\n        // Step 1). copy table and removing all stones being hit\\n        this.parents = new int[m * n + 1];\\n        for (int i = 0; i <= m * n; i++) parents[i] = i;\\n        this.sizes = new int[m * n + 1];\\n        //Arrays.fill(sizes, 1);\\n        \\n        int[][] mat = new int[m][n];\\n        for (int i = 0; i < m; i++) \\n            for (int j = 0; j < n; j++) \\n                mat[i][j] = grid[i][j];\\n            \\n        for (int[] hit : hits) \\n            mat[hit[0]][hit[1]] = 0;\\n        \\n        \\n        for (int i = 0; i < m; i++) \\n            for (int j = 0; j < n; j++) \\n                if (mat[i][j] == 1) sizes[i * n + j] = 1;\\n        \\n        \\n        \\n        // Step 2). initialization, union all remaining entries\\n        for (int j = 0; j < n; j++) \\n            if (mat[0][j] == 1) union(j, m * n);\\n            \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (mat[i][j] == 0) continue;\\n                \\n                int id = i * n + j;\\n                if (mat[i-1][j] == 1) union(id, (i-1) * n + j);\\n                if (j != 0 && mat[i][j-1] == 1) union(id, i * n + (j-1));\\n            }\\n        }\\n\\n        \\n        // Step 3). adding bricks being hit\\n        int[] res = new int[hits.length];\\n        for (int h = hits.length - 1; h >= 0; h--) {\\n            int x = hits[h][0];\\n            int y = hits[h][1];\\n            if (grid[x][y] == 0) continue;\\n            \\n            // hit on a brick, add that brick back\\n            int id = x * n + y;\\n            mat[x][y] = 1;\\n            sizes[id] = 1;\\n            \\n            int afterStable = sizes[m * n];\\n            \\n            for (int[] dir : DIRECTIONS) {\\n                int newX = x + dir[0];\\n                int newY = y + dir[1];\\n                \\n                if (newX < 0) {\\n                    union(id, m * n);\\n                    continue;\\n                }\\n                \\n                if (newY < 0 || newX >= m || newY >= n) continue;\\n                if (mat[newX][newY] == 0) continue;\\n                \\n                int nId = newX * n + newY;\\n                union(id, nId);\\n            }\\n            \\n            \\n            int currStable = sizes[m * n];\\n            \\n            // hitting the brick actually causes some brick to fall\\n            if (currStable - afterStable > 0) {\\n                res[h] = currStable - afterStable - 1;\\n            }\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    private int find(int x) {\\n        while (x != parents[x]) {\\n            parents[x] = parents[parents[x]];\\n            x = parents[x];\\n        }\\n        return x;\\n    }\\n    \\n    private void union(int x, int y) {\\n        int xParent = find(x);\\n        int yParent = find(y);\\n      \\n        if (xParent == yParent) return;\\n        \\n        if (xParent == m * n) {\\n            parents[yParent] = xParent;\\n            sizes[xParent] += sizes[yParent];\\n        } else {\\n            parents[xParent] = yParent;\\n            sizes[yParent] += sizes[xParent];\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int[] parents;\\n    int[] sizes;\\n    int m, n;\\n    \\n    private static final int[][] DIRECTIONS = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        \\n        // Step 1). copy table and removing all stones being hit\\n        this.parents = new int[m * n + 1];\\n        for (int i = 0; i <= m * n; i++) parents[i] = i;\\n        this.sizes = new int[m * n + 1];\\n        //Arrays.fill(sizes, 1);\\n        \\n        int[][] mat = new int[m][n];\\n        for (int i = 0; i < m; i++) \\n            for (int j = 0; j < n; j++) \\n                mat[i][j] = grid[i][j];\\n            \\n        for (int[] hit : hits) \\n            mat[hit[0]][hit[1]] = 0;\\n        \\n        \\n        for (int i = 0; i < m; i++) \\n            for (int j = 0; j < n; j++) \\n                if (mat[i][j] == 1) sizes[i * n + j] = 1;\\n        \\n        \\n        \\n        // Step 2). initialization, union all remaining entries\\n        for (int j = 0; j < n; j++) \\n            if (mat[0][j] == 1) union(j, m * n);\\n            \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (mat[i][j] == 0) continue;\\n                \\n                int id = i * n + j;\\n                if (mat[i-1][j] == 1) union(id, (i-1) * n + j);\\n                if (j != 0 && mat[i][j-1] == 1) union(id, i * n + (j-1));\\n            }\\n        }\\n\\n        \\n        // Step 3). adding bricks being hit\\n        int[] res = new int[hits.length];\\n        for (int h = hits.length - 1; h >= 0; h--) {\\n            int x = hits[h][0];\\n            int y = hits[h][1];\\n            if (grid[x][y] == 0) continue;\\n            \\n            // hit on a brick, add that brick back\\n            int id = x * n + y;\\n            mat[x][y] = 1;\\n            sizes[id] = 1;\\n            \\n            int afterStable = sizes[m * n];\\n            \\n            for (int[] dir : DIRECTIONS) {\\n                int newX = x + dir[0];\\n                int newY = y + dir[1];\\n                \\n                if (newX < 0) {\\n                    union(id, m * n);\\n                    continue;\\n                }\\n                \\n                if (newY < 0 || newX >= m || newY >= n) continue;\\n                if (mat[newX][newY] == 0) continue;\\n                \\n                int nId = newX * n + newY;\\n                union(id, nId);\\n            }\\n            \\n            \\n            int currStable = sizes[m * n];\\n            \\n            // hitting the brick actually causes some brick to fall\\n            if (currStable - afterStable > 0) {\\n                res[h] = currStable - afterStable - 1;\\n            }\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    private int find(int x) {\\n        while (x != parents[x]) {\\n            parents[x] = parents[parents[x]];\\n            x = parents[x];\\n        }\\n        return x;\\n    }\\n    \\n    private void union(int x, int y) {\\n        int xParent = find(x);\\n        int yParent = find(y);\\n      \\n        if (xParent == yParent) return;\\n        \\n        if (xParent == m * n) {\\n            parents[yParent] = xParent;\\n            sizes[xParent] += sizes[yParent];\\n        } else {\\n            parents[xParent] = yParent;\\n            sizes[yParent] += sizes[xParent];\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913640,
                "title": "cpp14-dfs-solution",
                "content": "First remove all the hit bricks if present. Then add one by from last to first and find how many becomes connected with roof or indirectly connected with a brick that is directly or indirectly connected to roof bcoz roof brick will never fall. Answer will be number of new bricks till now - old - 1. -1 bcoz we dont want to add erased brick to our answer. \\n\\n```\\nclass Solution {\\npublic:\\n\\n\\n    void dfs(vector<vector<int>> &grid , int i , int j , unordered_set<int> &dontdrop)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i < 0 or i >= n or j < 0 or j >= m or grid[i][j] != 1 or  dontdrop.count(i*m+j)) return ; \\n        dontdrop.insert(i*m+j);\\n        dfs(grid , i - 1 , j , dontdrop) ;\\n        dfs(grid , i + 1 , j , dontdrop) ;\\n        dfs(grid , i , j - 1 , dontdrop) ;\\n        dfs(grid , i , j + 1 , dontdrop) ;\\n    }\\n\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> ans;\\n        for(int i = 0 ; i < hits.size() ; ++i) ans.push_back(0);\\n        for(int i = 0 ; i < hits.size() ; ++i){\\n            grid[hits[i][0]][hits[i][1]]-=1;\\n        }\\n        unordered_set<int> dontdrop;\\n        for(int i = 0 ; i < m ; ++i){\\n            if(grid[0][i] == 1) dfs(grid, 0 , i , dontdrop);\\n        }\\n        for(int i = hits.size() - 1 ; i >= 0 ; --i){\\n            int oldsize = dontdrop.size();\\n            int x = hits[i][0] , y = hits[i][1];\\n            ++grid[x][y];\\n            if(grid[x][y] != 1) continue;\\n            bool issafe = false;\\n            if(x - 1 >= 0 and dontdrop.count((x-1) * m + y)) issafe = true;\\n            if(x + 1 <= n - 1 and dontdrop.count((x+1)*m + y)) issafe = true;\\n            if(y - 1 >= 0 and dontdrop.count((x*m)+y -1)) issafe = true;\\n            if(y + 1 <= m - 1 and dontdrop.count((x*m) + y + 1)) issafe = true;\\n            if(x == 0) issafe = true; \\n\\n            if(issafe == true){\\n                dfs(grid , x , y , dontdrop) ;\\n                ans[i] = dontdrop.size() - oldsize - 1 ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    void dfs(vector<vector<int>> &grid , int i , int j , unordered_set<int> &dontdrop)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i < 0 or i >= n or j < 0 or j >= m or grid[i][j] != 1 or  dontdrop.count(i*m+j)) return ; \\n        dontdrop.insert(i*m+j);\\n        dfs(grid , i - 1 , j , dontdrop) ;\\n        dfs(grid , i + 1 , j , dontdrop) ;\\n        dfs(grid , i , j - 1 , dontdrop) ;\\n        dfs(grid , i , j + 1 , dontdrop) ;\\n    }\\n\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> ans;\\n        for(int i = 0 ; i < hits.size() ; ++i) ans.push_back(0);\\n        for(int i = 0 ; i < hits.size() ; ++i){\\n            grid[hits[i][0]][hits[i][1]]-=1;\\n        }\\n        unordered_set<int> dontdrop;\\n        for(int i = 0 ; i < m ; ++i){\\n            if(grid[0][i] == 1) dfs(grid, 0 , i , dontdrop);\\n        }\\n        for(int i = hits.size() - 1 ; i >= 0 ; --i){\\n            int oldsize = dontdrop.size();\\n            int x = hits[i][0] , y = hits[i][1];\\n            ++grid[x][y];\\n            if(grid[x][y] != 1) continue;\\n            bool issafe = false;\\n            if(x - 1 >= 0 and dontdrop.count((x-1) * m + y)) issafe = true;\\n            if(x + 1 <= n - 1 and dontdrop.count((x+1)*m + y)) issafe = true;\\n            if(y - 1 >= 0 and dontdrop.count((x*m)+y -1)) issafe = true;\\n            if(y + 1 <= m - 1 and dontdrop.count((x*m) + y + 1)) issafe = true;\\n            if(x == 0) issafe = true; \\n\\n            if(issafe == true){\\n                dfs(grid , x , y , dontdrop) ;\\n                ans[i] = dontdrop.size() - oldsize - 1 ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 120259,
                "title": "c-reverse-adding-brick-with-union-o-colume-row-hits-time-and-space",
                "content": "With a little bit modification of union find, `Count` and `if attach to top` can be applied.\\n`count`: Only on the root of the union, `count` make sence. Connect `A` to `B` means cnt[B]+=cnt[A]\\n`if attach to top`: Only on the root of the union, it make sence. Connect `A` to `B` means t[A]=t[B]=(t[A]|t[B])\\nwe reversely:\\n1. Adding bricks (if it exist), every step we sum up `count` of union, which not attached to the top, but directly connet to the hited brick. \\n2. Meanwhile we connect the unions. \\n3. If after all, this big union is attached to top, then the # of bricks dropped is the sum we had at previous step\\n```\\nclass Solution {\\npublic:\\n    vector<int> u,cnt,t; //u: union; cnt union count; t if attach to top\\n    int find(int i){\\n        if(u[i]==-1) return i;\\n        u[i]=find(u[i]);\\n        return u[i];\\n    }\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        int move[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\\n        int n=grid.size(), m=grid[0].size();\\n        for(int i=0;i<hits.size();i++){\\n            if(grid[hits[i][0]][hits[i][1]]) grid[hits[i][0]][hits[i][1]]=0;\\n            else hits[i][0]=-1; //if there\\'s no brick at the hits, we mark it\\n        }\\n        u.assign(n*m,-1);cnt.assign(n*m,1);t.assign(n*m,0);\\n        for(int i=0;i<m;i++)t[i]=1;\\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++){//initializing\\n            if(!grid[i][j])continue;\\n            if(i+1<n && grid[i+1][j]){\\n                int x=find(i*m+j), y=find((i+1)*m+j);\\n                if(x!=y){\\n                    cnt[x]+=cnt[y];t[x]=t[y]=(t[x]|t[y]);u[y]=x;\\n                }\\n            }\\n            if(j+1<m && grid[i][j+1]){\\n                int x=find(i*m+j), y=find(i*m+j+1);\\n                if(x!=y){\\n                    cnt[x]+=cnt[y];t[x]=t[y]=(t[x]|t[y]);u[y]=x;\\n                }\\n            }\\n        }\\n        vector<int> ret(hits.size(),0);\\n        for(int i=hits.size()-1;i>=0;i--){ //revert adding\\n            if(hits[i][0]==-1)continue;\\n            bool isvalid=false;int ct=0;\\n            int x=hits[i][0], y=hits[i][1];int a=find(x*m+y);\\n            for(int j=0;j<4;j++){\\n                if(x+move[j][0]<0 || x+move[j][0]>=n)continue;\\n                if(y+move[j][1]<0 || y+move[j][1]>=m)continue;\\n                if(!grid[x+move[j][0]][y+move[j][1]])continue;\\n                int b=find(m*(x+move[j][0])+y+move[j][1]);\\n                if(a==b)continue;\\n                if(!t[b])ct+=cnt[b];\\n                cnt[a]+=cnt[b];t[a]=t[b]=t[a]|t[b];u[b]=a;\\n            }\\n            if(t[a])ret[i]=ct;\\n            grid[x][y]=1;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> u,cnt,t; //u: union; cnt union count; t if attach to top\\n    int find(int i){\\n        if(u[i]==-1) return i;\\n        u[i]=find(u[i]);\\n        return u[i];\\n    }\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        int move[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\\n        int n=grid.size(), m=grid[0].size();\\n        for(int i=0;i<hits.size();i++){\\n            if(grid[hits[i][0]][hits[i][1]]) grid[hits[i][0]][hits[i][1]]=0;\\n            else hits[i][0]=-1; //if there\\'s no brick at the hits, we mark it\\n        }\\n        u.assign(n*m,-1);cnt.assign(n*m,1);t.assign(n*m,0);\\n        for(int i=0;i<m;i++)t[i]=1;\\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++){//initializing\\n            if(!grid[i][j])continue;\\n            if(i+1<n && grid[i+1][j]){\\n                int x=find(i*m+j), y=find((i+1)*m+j);\\n                if(x!=y){\\n                    cnt[x]+=cnt[y];t[x]=t[y]=(t[x]|t[y]);u[y]=x;\\n                }\\n            }\\n            if(j+1<m && grid[i][j+1]){\\n                int x=find(i*m+j), y=find(i*m+j+1);\\n                if(x!=y){\\n                    cnt[x]+=cnt[y];t[x]=t[y]=(t[x]|t[y]);u[y]=x;\\n                }\\n            }\\n        }\\n        vector<int> ret(hits.size(),0);\\n        for(int i=hits.size()-1;i>=0;i--){ //revert adding\\n            if(hits[i][0]==-1)continue;\\n            bool isvalid=false;int ct=0;\\n            int x=hits[i][0], y=hits[i][1];int a=find(x*m+y);\\n            for(int j=0;j<4;j++){\\n                if(x+move[j][0]<0 || x+move[j][0]>=n)continue;\\n                if(y+move[j][1]<0 || y+move[j][1]>=m)continue;\\n                if(!grid[x+move[j][0]][y+move[j][1]])continue;\\n                int b=find(m*(x+move[j][0])+y+move[j][1]);\\n                if(a==b)continue;\\n                if(!t[b])ct+=cnt[b];\\n                cnt[a]+=cnt[b];t[a]=t[b]=t[a]|t[b];u[b]=a;\\n            }\\n            if(t[a])ret[i]=ct;\\n            grid[x][y]=1;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828204,
                "title": "c-union-find-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(m * n + k)\\n\\n- Space complexity:\\n O(m * n + k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>parent,size;\\n    vector<vector<int>>dict={{0,1},{1,0},{0,-1},{-1,0}};\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        parent.resize(m*n,0);\\n        size.resize(m*n,1);\\n        for(int i=0;i<m*n;i++)\\n        {\\n            parent[i]=i;\\n        }\\n        vector<int>vec(hits.size(),0);\\n\\n        //deleting earlier before creating its union\\n        for(auto& x:hits)\\n        {\\n            grid[x[0]][x[1]]--;\\n        }\\n\\n        //creating union by following the 2 condition given in question\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                    for(int k=0;k<4;k++)\\n                    {\\n                      int x=i+dict[k][0],y=j+dict[k][1];\\n                      if(x>=0 && y>=0 && x<n && y<m && grid[x][y]>0)\\n                      {\\n                         find_union(i*m+j,x*m+y);\\n                      }\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=(int)hits.size()-1;i>=0;i--)\\n        {\\n            int x=hits[i][0],y=hits[i][1];\\n            int flag=0;\\n            if(++grid[x][y]>0)\\n            {\\n                if(x==0) flag=1; // checking if it really attached to top grid\\n                for(int k=0;k<4;k++)\\n                {\\n                    int p=x+dict[k][0],q=y+dict[k][1];\\n                    if(p>=0 && q>=0 && p<n && q<m && grid[p][q]>0)\\n                    {\\n                        if(find_p(p*m+q)<m)  //checking again if its top grid \\n                        flag=1;                  \\n                        else if(find_p(x*m+y)!=find_p(p*m+q))\\n                        vec[i]+=size[find_p(p*m+q)]; //actully pushing no. of components that are connected to it\\n                        find_union(x*m+y,p*m+q);\\n                    }\\n                }\\n            }\\n             vec[i]*=flag;\\n        }\\n        return vec;\\n    }\\n\\n    int find_p(int node)\\n    {\\n        if(parent[node]==node)\\n        return node;\\n\\n        return parent[node]=find_p(parent[node]);\\n    }\\n\\n    void find_union(int u,int v)\\n    {\\n        int ulp_u=find_p(u);\\n        int ulp_v=find_p(v);\\n\\n        if(ulp_u==ulp_v)\\n        return;\\n\\n        if(ulp_u<ulp_v)  // inplace of size we are checking node or its value .. \\n        {                // we are making  smaller as parent so to get exposure of top grid\\n            parent[ulp_v]=ulp_u;\\n            size[ulp_u]+=size[ulp_v];\\n        }\\n        else\\n        {\\n            parent[ulp_u]=ulp_v;\\n            size[ulp_v]+=size[ulp_u];\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>parent,size;\\n    vector<vector<int>>dict={{0,1},{1,0},{0,-1},{-1,0}};\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        parent.resize(m*n,0);\\n        size.resize(m*n,1);\\n        for(int i=0;i<m*n;i++)\\n        {\\n            parent[i]=i;\\n        }\\n        vector<int>vec(hits.size(),0);\\n\\n        //deleting earlier before creating its union\\n        for(auto& x:hits)\\n        {\\n            grid[x[0]][x[1]]--;\\n        }\\n\\n        //creating union by following the 2 condition given in question\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                    for(int k=0;k<4;k++)\\n                    {\\n                      int x=i+dict[k][0],y=j+dict[k][1];\\n                      if(x>=0 && y>=0 && x<n && y<m && grid[x][y]>0)\\n                      {\\n                         find_union(i*m+j,x*m+y);\\n                      }\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=(int)hits.size()-1;i>=0;i--)\\n        {\\n            int x=hits[i][0],y=hits[i][1];\\n            int flag=0;\\n            if(++grid[x][y]>0)\\n            {\\n                if(x==0) flag=1; // checking if it really attached to top grid\\n                for(int k=0;k<4;k++)\\n                {\\n                    int p=x+dict[k][0],q=y+dict[k][1];\\n                    if(p>=0 && q>=0 && p<n && q<m && grid[p][q]>0)\\n                    {\\n                        if(find_p(p*m+q)<m)  //checking again if its top grid \\n                        flag=1;                  \\n                        else if(find_p(x*m+y)!=find_p(p*m+q))\\n                        vec[i]+=size[find_p(p*m+q)]; //actully pushing no. of components that are connected to it\\n                        find_union(x*m+y,p*m+q);\\n                    }\\n                }\\n            }\\n             vec[i]*=flag;\\n        }\\n        return vec;\\n    }\\n\\n    int find_p(int node)\\n    {\\n        if(parent[node]==node)\\n        return node;\\n\\n        return parent[node]=find_p(parent[node]);\\n    }\\n\\n    void find_union(int u,int v)\\n    {\\n        int ulp_u=find_p(u);\\n        int ulp_v=find_p(v);\\n\\n        if(ulp_u==ulp_v)\\n        return;\\n\\n        if(ulp_u<ulp_v)  // inplace of size we are checking node or its value .. \\n        {                // we are making  smaller as parent so to get exposure of top grid\\n            parent[ulp_v]=ulp_u;\\n            size[ulp_u]+=size[ulp_v];\\n        }\\n        else\\n        {\\n            parent[ulp_u]=ulp_v;\\n            size[ulp_v]+=size[ulp_u];\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471330,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool isConnected(vector<vector<bool>>& vis, int& i, int& j){\\n        if(i==0)\\n            return true;\\n        \\n        if(i>0 && vis[i-1][j])\\n            return true;\\n        if(j>0 && vis[i][j-1])\\n            return true;\\n        if(i<vis.size()-1 && vis[i+1][j])\\n            return true;\\n        if(j<vis[0].size()-1 && vis[i][j+1])\\n            return true;\\n        return false;\\n    }\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        vector<int> ans(hits.size(), 0);\\n        vector<vector<int>> mat = grid;\\n        for(int i=0; i<hits.size(); i++)\\n            mat[hits[i][0]][hits[i][1]] = 0;\\n        vector<vector<bool>> vis(grid.size(), vector<bool> (grid[0].size(), false));\\n        queue<pair<int, int>> q;\\n        for(int i=0; i<grid[0].size(); i++){\\n            if(mat[0][i]==1){\\n                vis[0][i] = true;\\n                q.push({0, i});\\n            }\\n        }\\n        while(!q.empty()){\\n            int idx = q.front().first, jdx = q.front().second;\\n            q.pop();\\n            \\n            if(idx>0 && mat[idx-1][jdx]==1){\\n                if(!vis[idx-1][jdx])\\n                    q.push({idx-1, jdx});\\n                vis[idx-1][jdx]=true;\\n            }\\n            if(jdx>0 && mat[idx][jdx-1]==1){\\n                if(!vis[idx][jdx-1])\\n                    q.push({idx, jdx-1});\\n                vis[idx][jdx-1]=true;\\n            }\\n            if(idx<grid.size()-1 && mat[idx+1][jdx]==1){\\n                if(!vis[idx+1][jdx])\\n                    q.push({idx+1, jdx});\\n                vis[idx+1][jdx]=true;\\n            }\\n            if(jdx<grid[0].size()-1 && mat[idx][jdx+1]==1){\\n                if(!vis[idx][jdx+1])\\n                    q.push({idx, jdx+1});\\n                vis[idx][jdx+1]=true;\\n            }\\n        }\\n        for(int i=hits.size()-1; i>=0; i--){\\n            if(grid[hits[i][0]][hits[i][1]]==0)\\n                continue;\\n            mat[hits[i][0]][hits[i][1]] = 1;\\n            if(!isConnected(vis, hits[i][0], hits[i][1]))\\n                continue;\\n            q.push({hits[i][0], hits[i][1]});\\n            vis[hits[i][0]][hits[i][1]] = true;\\n            int cnt=0;\\n            while(!q.empty()){\\n                int idx = q.front().first, jdx = q.front().second;\\n                q.pop();\\n                cnt++;\\n                if(idx>0 && mat[idx-1][jdx]==1 && !vis[idx-1][jdx]){\\n                    q.push({idx-1, jdx});\\n                    vis[idx-1][jdx]=true;\\n                }\\n                if(jdx>0 && mat[idx][jdx-1]==1 && !vis[idx][jdx-1]){\\n                    q.push({idx, jdx-1});\\n                    vis[idx][jdx-1]=true;\\n                }\\n                if(idx<grid.size()-1 && mat[idx+1][jdx]==1 && !vis[idx+1][jdx]){\\n                    q.push({idx+1, jdx});\\n                    vis[idx+1][jdx]=true;\\n                }\\n                if(jdx<grid[0].size()-1 && mat[idx][jdx+1]==1 && !vis[idx][jdx+1]){\\n                    q.push({idx, jdx+1});\\n                    vis[idx][jdx+1]=true;\\n                }\\n            }\\n            ans[i] = cnt-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def hitBricks(\\n        self, grid: List[List[int]], hits: List[List[int]],\\n        exhaust=deque(maxlen=0).extend        \\n    ) -> List[int]:\\n        cells = bytearray(\\n            (cell_cnt := (len(grid) + 2) \\n                      * (col_cnt := (width := len(grid[0])) + 2))\\n        )        \\n        occupied = partial(filter, cells.__getitem__)\\n        for base, row in zip(\\n            count((offset := col_cnt + 1) + col_cnt, col_cnt), \\n            islice(grid, 1, None)\\n        ):\\n            cells[base:base + width] = row\\n        exhaust(map(\\n            (removed := [-40805] * cell_cnt).__setitem__, \\n            (((row * col_cnt) + col + offset) for row, col in hits), \\n            count(-1, -1)\\n        ))\\n        base_removals = tuple(map(\\n            removed.__getitem__, \\n            (bases := tuple(\\n                map(offset.__add__, \\n                    filter(grid[0].__getitem__, range(width)))\\n            ))\\n        ))\\n        dists = 1, col_cnt, -1, -col_cnt\\n        solutions = [0] * len(hits)        \\n        heapify((pending := list(zip(base_removals, bases))))\\n        while pending:\\n            hit, at = heappop(pending)\\n            for to in occupied(map(at.__add__, dists)):\\n                cells[to] = False\\n                if (candidate := removed[to]) < hit:\\n                    solutions[(candidate := hit)] += 1\\n                heappush(pending, (candidate, to))\\n        return reversed(solutions)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[] ans = new int[hits.length];\\n        \\n        for(int[] hit : hits) {\\n            grid[hit[0]][hit[1]] *= -1;\\n        }\\n        for(int i = 0; i < m; i++) {\\n            dfs(grid, 0, i);\\n        }\\n        for(int i = hits.length-1; i >= 0; i--) {\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            if(grid[x][y] == 0) {\\n                continue;\\n            } \\n            grid[x][y] = 1;\\n            if(connected(grid, x, y, n, m)) {\\n                ans[i] = dfs(grid, x, y)-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public int dfs(int[][] grid, int x, int y) {\\n        if(x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != 1) {\\n            return 0;\\n        }\\n        grid[x][y] = 2;\\n        return 1 + dfs(grid, x+1, y) + dfs(grid, x, y+1) + dfs(grid, x-1, y) + dfs(grid, x, y-1);\\n    }\\n    public boolean connected(int[][] grid, int x, int y, int n, int m) {\\n        if(x == 0) {\\n            return true;\\n        }\\n        if(x+1 < n) {\\n            if(grid[x+1][y] == 2) {\\n                return true;\\n            }\\n        }\\n        if(x-1 >= 0) {\\n            if(grid[x-1][y] == 2) {\\n                return true;\\n            }\\n        }\\n        if(y+1 < m) {\\n            if(grid[x][y+1] == 2) {\\n                return true;\\n            }\\n        }\\n        if(y-1 >= 0) {\\n            if(grid[x][y-1] == 2) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isConnected(vector<vector<bool>>& vis, int& i, int& j){\\n        if(i==0)\\n            return true;\\n        \\n        if(i>0 && vis[i-1][j])\\n            return true;\\n        if(j>0 && vis[i][j-1])\\n            return true;\\n        if(i<vis.size()-1 && vis[i+1][j])\\n            return true;\\n        if(j<vis[0].size()-1 && vis[i][j+1])\\n            return true;\\n        return false;\\n    }\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        vector<int> ans(hits.size(), 0);\\n        vector<vector<int>> mat = grid;\\n        for(int i=0; i<hits.size(); i++)\\n            mat[hits[i][0]][hits[i][1]] = 0;\\n        vector<vector<bool>> vis(grid.size(), vector<bool> (grid[0].size(), false));\\n        queue<pair<int, int>> q;\\n        for(int i=0; i<grid[0].size(); i++){\\n            if(mat[0][i]==1){\\n                vis[0][i] = true;\\n                q.push({0, i});\\n            }\\n        }\\n        while(!q.empty()){\\n            int idx = q.front().first, jdx = q.front().second;\\n            q.pop();\\n            \\n            if(idx>0 && mat[idx-1][jdx]==1){\\n                if(!vis[idx-1][jdx])\\n                    q.push({idx-1, jdx});\\n                vis[idx-1][jdx]=true;\\n            }\\n            if(jdx>0 && mat[idx][jdx-1]==1){\\n                if(!vis[idx][jdx-1])\\n                    q.push({idx, jdx-1});\\n                vis[idx][jdx-1]=true;\\n            }\\n            if(idx<grid.size()-1 && mat[idx+1][jdx]==1){\\n                if(!vis[idx+1][jdx])\\n                    q.push({idx+1, jdx});\\n                vis[idx+1][jdx]=true;\\n            }\\n            if(jdx<grid[0].size()-1 && mat[idx][jdx+1]==1){\\n                if(!vis[idx][jdx+1])\\n                    q.push({idx, jdx+1});\\n                vis[idx][jdx+1]=true;\\n            }\\n        }\\n        for(int i=hits.size()-1; i>=0; i--){\\n            if(grid[hits[i][0]][hits[i][1]]==0)\\n                continue;\\n            mat[hits[i][0]][hits[i][1]] = 1;\\n            if(!isConnected(vis, hits[i][0], hits[i][1]))\\n                continue;\\n            q.push({hits[i][0], hits[i][1]});\\n            vis[hits[i][0]][hits[i][1]] = true;\\n            int cnt=0;\\n            while(!q.empty()){\\n                int idx = q.front().first, jdx = q.front().second;\\n                q.pop();\\n                cnt++;\\n                if(idx>0 && mat[idx-1][jdx]==1 && !vis[idx-1][jdx]){\\n                    q.push({idx-1, jdx});\\n                    vis[idx-1][jdx]=true;\\n                }\\n                if(jdx>0 && mat[idx][jdx-1]==1 && !vis[idx][jdx-1]){\\n                    q.push({idx, jdx-1});\\n                    vis[idx][jdx-1]=true;\\n                }\\n                if(idx<grid.size()-1 && mat[idx+1][jdx]==1 && !vis[idx+1][jdx]){\\n                    q.push({idx+1, jdx});\\n                    vis[idx+1][jdx]=true;\\n                }\\n                if(jdx<grid[0].size()-1 && mat[idx][jdx+1]==1 && !vis[idx][jdx+1]){\\n                    q.push({idx, jdx+1});\\n                    vis[idx][jdx+1]=true;\\n                }\\n            }\\n            ans[i] = cnt-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def hitBricks(\\n        self, grid: List[List[int]], hits: List[List[int]],\\n        exhaust=deque(maxlen=0).extend        \\n    ) -> List[int]:\\n        cells = bytearray(\\n            (cell_cnt := (len(grid) + 2) \\n                      * (col_cnt := (width := len(grid[0])) + 2))\\n        )        \\n        occupied = partial(filter, cells.__getitem__)\\n        for base, row in zip(\\n            count((offset := col_cnt + 1) + col_cnt, col_cnt), \\n            islice(grid, 1, None)\\n        ):\\n            cells[base:base + width] = row\\n        exhaust(map(\\n            (removed := [-40805] * cell_cnt).__setitem__, \\n            (((row * col_cnt) + col + offset) for row, col in hits), \\n            count(-1, -1)\\n        ))\\n        base_removals = tuple(map(\\n            removed.__getitem__, \\n            (bases := tuple(\\n                map(offset.__add__, \\n                    filter(grid[0].__getitem__, range(width)))\\n            ))\\n        ))\\n        dists = 1, col_cnt, -1, -col_cnt\\n        solutions = [0] * len(hits)        \\n        heapify((pending := list(zip(base_removals, bases))))\\n        while pending:\\n            hit, at = heappop(pending)\\n            for to in occupied(map(at.__add__, dists)):\\n                cells[to] = False\\n                if (candidate := removed[to]) < hit:\\n                    solutions[(candidate := hit)] += 1\\n                heappush(pending, (candidate, to))\\n        return reversed(solutions)\\n```\n```Java []\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[] ans = new int[hits.length];\\n        \\n        for(int[] hit : hits) {\\n            grid[hit[0]][hit[1]] *= -1;\\n        }\\n        for(int i = 0; i < m; i++) {\\n            dfs(grid, 0, i);\\n        }\\n        for(int i = hits.length-1; i >= 0; i--) {\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            if(grid[x][y] == 0) {\\n                continue;\\n            } \\n            grid[x][y] = 1;\\n            if(connected(grid, x, y, n, m)) {\\n                ans[i] = dfs(grid, x, y)-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public int dfs(int[][] grid, int x, int y) {\\n        if(x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != 1) {\\n            return 0;\\n        }\\n        grid[x][y] = 2;\\n        return 1 + dfs(grid, x+1, y) + dfs(grid, x, y+1) + dfs(grid, x-1, y) + dfs(grid, x, y-1);\\n    }\\n    public boolean connected(int[][] grid, int x, int y, int n, int m) {\\n        if(x == 0) {\\n            return true;\\n        }\\n        if(x+1 < n) {\\n            if(grid[x+1][y] == 2) {\\n                return true;\\n            }\\n        }\\n        if(x-1 >= 0) {\\n            if(grid[x-1][y] == 2) {\\n                return true;\\n            }\\n        }\\n        if(y+1 < m) {\\n            if(grid[x][y+1] == 2) {\\n                return true;\\n            }\\n        }\\n        if(y-1 >= 0) {\\n            if(grid[x][y-1] == 2) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225235,
                "title": "dsuf",
                "content": "\\tclass DisjointSet{\\n    public:\\n    vector<int>parent;\\n    vector<int>sizeP;\\n    int n,m;\\n    \\n    DisjointSet(int size){\\n        parent.resize(size,0);\\n        sizeP.resize(size,1);\\n        for(int i=0;i<size;i++)\\n            parent[i]=i;\\n    }\\n\\n    int find(int x){\\n        return parent[x]=parent[x]==x?x:find(parent[x]);\\n    }\\n    \\n    void Union(int a,int b){\\n        \\n        int p1=find(a);\\n        int p2=find(b);\\n        if(p1!=p2){\\n            parent[p1]=p2;\\n            sizeP[p2]+=sizeP[p1];           \\n        }             \\n    }\\n\\t\\t};\\n\\t\\tclass Solution {\\n\\tpublic:\\n    int n,m;\\n   \\n    int position(int x,int y){\\n    return x*m+y+1;\\n    }\\n    vector<vector<int>>dir={{0,1},{0,-1},{1,0},{-1,0}};\\n    void unionAll(int x,int y,DisjointSet &ds, vector<vector<int>>&grid){\\n        \\n        int pos=position(x,y);\\n        for(auto &k:dir){\\n            int row=x+k[0];\\n            int col=y+k[1];\\n            if(row>=0 && col>=0 && row<n && col<m && grid[row][col]==1)\\n                ds.Union(pos,position(row,col));\\n        }\\n        if(x==0)\\n            ds.Union(pos,0);\\n    }\\n\\t\\tvector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n     //so the absolute parent is 0 we will see how many bricks are connected to 0 at first and than\\n        // one by one we will put the hit bricks and see how many more bricks are connected to 0 \\n        //so the new bricks which are connected to absolute parent are those which will fall if they are not \\n        //connected throgh that one hit brick that brick is the brick which is connecting it to top\\n        n=grid.size();\\n        m=grid[0].size();\\n        //first we will make the hit bricks as 2 \\n        for(auto &x:hits)\\n            if(grid[x[0]][x[1]]==1)\\n                grid[x[0]][x[1]]=2;\\n       \\n        DisjointSet ds(n*m+1);\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid[i][j]==1)\\n                    unionAll(i,j,ds,grid);\\n        \\n        int brickLeftSize=ds.sizeP[ds.find(0)];\\n        vector<int>res(hits.size(),0);\\n        for(int i=hits.size()-1;i>=0;i--){\\n            int row=hits[i][0];\\n            int col=hits[i][1];\\n            if(grid[row][col]!=2)\\n                continue;\\n            grid[row][col]=1;\\n            unionAll(row,col,ds,grid);\\n            int newBrickSize=ds.sizeP[ds.find(0)];\\n            int gone=max(newBrickSize-brickLeftSize-1,0);\\n            res[i]=gone;\\n            brickLeftSize=newBrickSize;\\n        }\\n        return res;\\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int n,m;\\n   \\n    int position(int x,int y){\\n    return x*m+y+1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2061150,
                "title": "simple-bfs-faster-than-90-c",
                "content": "The approach to the problem is explained really nicely in the Solution section of the problem. If you haven\\'t checked that out, do check it.\\n\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    int h[4]={0, 0, -1, 1}, v[4]={-1 ,1, 0, 0};\\n    int bfs(int i, int j, vector<vector<int>> &grid)\\n    {\\n        int cnt=0;\\n        grid[i][j]=2;\\n        for(int k=0; k<4; k++)\\n        {\\n            int ni=i+h[k], nj=j+v[k];\\n            if(ni<0 || nj<0 || ni>=m || nj>=n || grid[ni][nj]!=1)\\n                continue;\\n            grid[ni][nj]=2;\\n            cnt=cnt+1+bfs(ni, nj, grid);\\n        }\\n        return cnt;\\n    }\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hit) {\\n        m=grid.size(), n=grid[0].size();\\n        vector<int> res(hit.size(), 0);\\n        for(int i=0; i<hit.size(); i++)\\n        {\\n            int x=hit[i][0], y=hit[i][1];\\n            if(grid[x][y]==1)\\n                grid[x][y]=0;\\n            else\\n            {\\n                hit[i][1]=-1;\\n                hit[i][0]=-1;\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(grid[0][i])\\n                bfs(0, i, grid);\\n        }\\n        for(int k=hit.size()-1; k>=0; k--)\\n        {\\n            int i=hit[k][0], j=hit[k][1];\\n            if(i==-1 || j==-1)\\n            {\\n                res[k]=0;\\n                continue;\\n            }\\n            grid[i][j]=1;\\n            if(i==0)\\n            {\\n                res[k]=bfs(i, j, grid);\\n                continue;\\n            }\\n            for(int p=0; p<4; p++)\\n            {\\n                int ni=i+h[p], nj=j+v[p];\\n                if(ni<0 || nj<0 || ni>=m || nj>=n || grid[ni][nj]!=2)\\n                    continue;\\n                res[k]=bfs(i, j, grid);\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    int h[4]={0, 0, -1, 1}, v[4]={-1 ,1, 0, 0};\\n    int bfs(int i, int j, vector<vector<int>> &grid)\\n    {\\n        int cnt=0;\\n        grid[i][j]=2;\\n        for(int k=0; k<4; k++)\\n        {\\n            int ni=i+h[k], nj=j+v[k];\\n            if(ni<0 || nj<0 || ni>=m || nj>=n || grid[ni][nj]!=1)\\n                continue;\\n            grid[ni][nj]=2;\\n            cnt=cnt+1+bfs(ni, nj, grid);\\n        }\\n        return cnt;\\n    }\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hit) {\\n        m=grid.size(), n=grid[0].size();\\n        vector<int> res(hit.size(), 0);\\n        for(int i=0; i<hit.size(); i++)\\n        {\\n            int x=hit[i][0], y=hit[i][1];\\n            if(grid[x][y]==1)\\n                grid[x][y]=0;\\n            else\\n            {\\n                hit[i][1]=-1;\\n                hit[i][0]=-1;\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(grid[0][i])\\n                bfs(0, i, grid);\\n        }\\n        for(int k=hit.size()-1; k>=0; k--)\\n        {\\n            int i=hit[k][0], j=hit[k][1];\\n            if(i==-1 || j==-1)\\n            {\\n                res[k]=0;\\n                continue;\\n            }\\n            grid[i][j]=1;\\n            if(i==0)\\n            {\\n                res[k]=bfs(i, j, grid);\\n                continue;\\n            }\\n            for(int p=0; p<4; p++)\\n            {\\n                int ni=i+h[p], nj=j+v[p];\\n                if(ni<0 || nj<0 || ni>=m || nj>=n || grid[ni][nj]!=2)\\n                    continue;\\n                res[k]=bfs(i, j, grid);\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856390,
                "title": "python-union-find-easy-way-to-count-falling-bricks-by-using-size",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        parent = defaultdict()\\n        sz = defaultdict(lambda:1)\\n        empty = set()\\n        def find(i):\\n            if parent[i] != i:\\n                parent[i] = find(parent[i])\\n            return parent[i]\\n        def union(i,j):\\n            pi = find(i)\\n            pj = find(j)\\n            if pi != pj:\\n                parent[pi] = pj\\n                sz[pj] += sz[pi]\\n        row = len(grid)\\n        col = len(grid[0])\\n        for r in range(row):\\n            for c in range(col):\\n                parent[(r,c)] = (r,c)\\n        parent[(row,col)] = (row,col)\\n        for r, c in hits:\\n            if grid[r][c]:\\n                grid[r][c] = 0\\n            else:\\n                empty.add((r,c))\\n        for r in range(row):\\n            for c in range(col):\\n                if not grid[r][c]:\\n                    continue\\n                for dr, dc in [[-1,0],[1,0],[0,1],[0,-1]]:\\n                    if 0 <= r + dr < row and 0 <= c + dc < col and grid[r+dr][c+dc]:\\n                        union((r, c),(r+dr, c+dc))\\n                if r == 0:\\n                    union((r,c),(row,col))\\n        res = [0]*len(hits)            \\n        for i in range(len(hits)-1,-1,-1):\\n            r, c = hits[i]\\n            if (r,c) in empty:\\n                continue\\n            grid[r][c] = 1\\n            curbricks = sz[find((row,col))]\\n            for dr, dc in [[-1,0],[1,0],[0,1],[0,-1]]:\\n                if 0 <= r + dr < row and 0 <= c + dc < col and grid[r+dr][c+dc]:\\n                    union((r,c),(r+dr,c+dc))\\n            if r == 0:\\n                union((r,c),(row,col))\\n            nextbricks = sz[find((row,col))]\\n            if nextbricks > curbricks:\\n                res[i] = nextbricks - curbricks - 1\\n        return res           \\n```\\n\\n                    \\n                    \\n",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        parent = defaultdict()\\n        sz = defaultdict(lambda:1)\\n        empty = set()\\n        def find(i):\\n            if parent[i] != i:\\n                parent[i] = find(parent[i])\\n            return parent[i]\\n        def union(i,j):\\n            pi = find(i)\\n            pj = find(j)\\n            if pi != pj:\\n                parent[pi] = pj\\n                sz[pj] += sz[pi]\\n        row = len(grid)\\n        col = len(grid[0])\\n        for r in range(row):\\n            for c in range(col):\\n                parent[(r,c)] = (r,c)\\n        parent[(row,col)] = (row,col)\\n        for r, c in hits:\\n            if grid[r][c]:\\n                grid[r][c] = 0\\n            else:\\n                empty.add((r,c))\\n        for r in range(row):\\n            for c in range(col):\\n                if not grid[r][c]:\\n                    continue\\n                for dr, dc in [[-1,0],[1,0],[0,1],[0,-1]]:\\n                    if 0 <= r + dr < row and 0 <= c + dc < col and grid[r+dr][c+dc]:\\n                        union((r, c),(r+dr, c+dc))\\n                if r == 0:\\n                    union((r,c),(row,col))\\n        res = [0]*len(hits)            \\n        for i in range(len(hits)-1,-1,-1):\\n            r, c = hits[i]\\n            if (r,c) in empty:\\n                continue\\n            grid[r][c] = 1\\n            curbricks = sz[find((row,col))]\\n            for dr, dc in [[-1,0],[1,0],[0,1],[0,-1]]:\\n                if 0 <= r + dr < row and 0 <= c + dc < col and grid[r+dr][c+dc]:\\n                    union((r,c),(r+dr,c+dc))\\n            if r == 0:\\n                union((r,c),(row,col))\\n            nextbricks = sz[find((row,col))]\\n            if nextbricks > curbricks:\\n                res[i] = nextbricks - curbricks - 1\\n        return res           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509155,
                "title": "c-clean-code",
                "content": "class Solution {\\npublic:\\n    int n,m;\\n    int dx[4]={1,0,-1,0};\\n    int dy[4]={0,1,0,-1};\\n    bool check(int p,int q)\\n    {\\n        if(p>=0&&q>=0&&p<n&&q<m)\\n            return true;\\n        else\\n            return false;\\n    }\\n    int dfs(vector<vector<int>>& grid,int p,int q)\\n    {\\n        grid[p][q]=2;\\n        int sz=1;\\n        for(int i=0;i<4;i++)\\n        {\\n            int p1=p+dx[i],q1=q+dy[i];\\n            if(check(p1,q1)&&grid[p1][q1]==1)\\n                sz+=dfs(grid,p1,q1);\\n        }\\n        return sz;\\n    }\\n    bool isstable(vector<vector<int>>& grid,int p,int q)\\n    {\\n        bool ans=false;\\n        for(int i=0;i<4;i++)\\n        {\\n            int p1=p+dx[i],q1=q+dy[i];\\n            if(check(p1,q1)&&grid[p1][q1]==2)\\n                ans=true;\\n        }\\n        if(p==0)\\n            ans=true;\\n        return ans;\\n    }\\n    \\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<int> ans(hits.size());\\n        \\n        for(int i=0;i<hits.size();i++) \\n        {\\n            int p=hits[i][0];\\n            int q=hits[i][1];\\n            if(grid[p][q]==1)\\n                grid[p][q]=-1;\\n              \\n        }\\n        for(int j=0;j<m;j++) {\\n            if(grid[0][j]==1)\\n                int tmp=dfs(grid,0,j);\\n        }\\n        \\n        for(int i=hits.size()-1;i>=0;i--)\\n        {\\n            int p=hits[i][0];\\n            int q=hits[i][1];\\n            if(grid[p][q]==0)\\n                ans[i]=0;\\n            else {\\n                grid[p][q]=1;\\n                if(!isstable(grid,p,q)) continue;\\n                ans[i]=dfs(grid,p,q)-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int n,m;\\n    int dx[4]={1,0,-1,0}",
                "codeTag": "Java"
            },
            {
                "id": 1391613,
                "title": "c-dsu-code-explaination",
                "content": "```\\n/*\\n\\n\\nLet n = r*c\\n\\nObservations::\\n1) A brick is stable if it is part of a connected component which has atleast one element touching the top\\n\\nBrute Force\\n- When we hit a brick. A chain process starts. Where bricks becoming unstable starts to fall \\n    - For each hit. We run DFS or use DSU to find connected components (ones which have atleast one top row brick) \\n    - It will take O(q*r*c) => 16 * 10^8 -> 1.6*19^9 =>TLE \\n\\n\\nNote: We have to construct the DSU again & again, because going forward (i.e. hitting a brick), needs to remove element from connected components... but DSU only supports the Union operation\\n\\nThis gives us a hint. Going forward is removing operation ... so all operation from final state to initial state will be addition operations... so, can we do something with DSU and reverse traversal\\n\\nLet\\'s See:\\n\\n    1) Remove all bricks which are in the hit array\\n    2) Construct DSU. Find stable bricks.\\n    3) For each hit point in reverse(hit array)\\n        1) Check if hit point is a stable position\\n        2) If hit point is not stable position, then it implies, when we come from forward ... there was no brick\\n        at hit position, thus no brick falls at this hit point\\n        3) If hit point is stable, then we check how many more bricks it will make stable from unstable. Let\\'s say it  \\n        makes x number of bricks stable. Then going forward it will remove x+1 bricks.\\n            a) How to find, numbers of bricks which became stable.\\n                - We maintain a DSU, where some connected components will be stable... some unstable. We map a map of                       which connected components are unstable. \\n                - for each hit point which is stable, we check its four neighbours, and if any of them is unstable we make\\n                it stable\\n\\n*/\\n\\nint n,m;\\nvector<int> ds;\\nvector<int> dirs = {1,0,-1,0,1};\\nint find(int i){ return ds[i]<0?i:ds[i] = find(ds[i]);}\\nbool Union(int i, int j){\\n    i = find(i); j = find(j);\\n    if(i==j) return false;\\n    if(ds[i] > ds[j]) swap(i,j);\\n    ds[i] += ds[j];\\n    ds[j] = i;\\n    return true;\\n}\\n\\nint f(int i, int j){return i*m+j;}    \\nbool is(int i, int j){ return i>=0 && j>=0 && i<n && j<m;}\\n\\nclass Solution {\\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        n = grid.size(), m = grid[0].size();\\n        int q = hits.size();\\n        ds.clear(); ds.resize(n*m, -1);\\n        unordered_map<int, bool> isstable;\\n        \\n        for(int i=0; i<q; ++i) grid[hits[i][0]][hits[i][1]] -= 1; //removing all erased bricks\\n        \\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]!=1) continue;\\n                for(int it=0; it<4; ++it){\\n                    int x = i+dirs[it],y=j+dirs[it+1];\\n                    if(is(x,y) && grid[x][y]==1) {Union(f(i,j),f(x,y));} //generating connected components\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        for(int j=0;j<m;++j){\\n            if(grid[0][j]==1) isstable[find(f(0,j))] = true; //marking stable components\\n        }\\n        \\n        vector<int> ans(q);\\n        for(int k=q-1; k>=0; --k){\\n            int i = hits[k][0], j = hits[k][1], flag = 0;\\n            if(grid[i][j]==-1) continue;\\n            \\n            vector<int> unstable_neighbours;\\n            \\n            //checks whether hitting point is stable or not\\n            if(i==0) flag = 1;\\n            for(int it=0; it<4; ++it){ \\n                int x = i+dirs[it],y=j+dirs[it+1];\\n                //union the hitting point and its stable neighbour\\n                if(is(x,y) && (isstable.count(find(f(x,y))))) {\\n                    flag = 1; \\n                    Union(f(x,y), f(i,j));\\n                }\\n                else if(is(x,y) && !(isstable.count(find(f(x,y))))){\\n                    unstable_neighbours.push_back(f(x,y));\\n                }\\n            }\\n            \\n            \\n            //checking unstable neighbours\\n            int tans = 0;\\n            for(auto ngbh : unstable_neighbours){\\n                int x = ngbh/m, y = ngbh%m;\\n                if(grid[x][y]==1 && find(f(x,y))!=find(f(i,j))){\\n                    tans += -ds[find(f(x,y))];\\n                    Union(f(x,y),f(i,j)); \\n                }\\n                \\n            }\\n            grid[i][j] = 1;\\n            \\n            //marking node as stable\\n            if(flag){\\n                ans[k] = tans;\\n                isstable[find(f(i,j))] = true;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\n\\nLet n = r*c\\n\\nObservations::\\n1) A brick is stable if it is part of a connected component which has atleast one element touching the top\\n\\nBrute Force\\n- When we hit a brick. A chain process starts. Where bricks becoming unstable starts to fall \\n    - For each hit. We run DFS or use DSU to find connected components (ones which have atleast one top row brick) \\n    - It will take O(q*r*c) => 16 * 10^8 -> 1.6*19^9 =>TLE \\n\\n\\nNote: We have to construct the DSU again & again, because going forward (i.e. hitting a brick), needs to remove element from connected components... but DSU only supports the Union operation\\n\\nThis gives us a hint. Going forward is removing operation ... so all operation from final state to initial state will be addition operations... so, can we do something with DSU and reverse traversal\\n\\nLet\\'s See:\\n\\n    1) Remove all bricks which are in the hit array\\n    2) Construct DSU. Find stable bricks.\\n    3) For each hit point in reverse(hit array)\\n        1) Check if hit point is a stable position\\n        2) If hit point is not stable position, then it implies, when we come from forward ... there was no brick\\n        at hit position, thus no brick falls at this hit point\\n        3) If hit point is stable, then we check how many more bricks it will make stable from unstable. Let\\'s say it  \\n        makes x number of bricks stable. Then going forward it will remove x+1 bricks.\\n            a) How to find, numbers of bricks which became stable.\\n                - We maintain a DSU, where some connected components will be stable... some unstable. We map a map of                       which connected components are unstable. \\n                - for each hit point which is stable, we check its four neighbours, and if any of them is unstable we make\\n                it stable\\n\\n*/\\n\\nint n,m;\\nvector<int> ds;\\nvector<int> dirs = {1,0,-1,0,1};\\nint find(int i){ return ds[i]<0?i:ds[i] = find(ds[i]);}\\nbool Union(int i, int j){\\n    i = find(i); j = find(j);\\n    if(i==j) return false;\\n    if(ds[i] > ds[j]) swap(i,j);\\n    ds[i] += ds[j];\\n    ds[j] = i;\\n    return true;\\n}\\n\\nint f(int i, int j){return i*m+j;}    \\nbool is(int i, int j){ return i>=0 && j>=0 && i<n && j<m;}\\n\\nclass Solution {\\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        n = grid.size(), m = grid[0].size();\\n        int q = hits.size();\\n        ds.clear(); ds.resize(n*m, -1);\\n        unordered_map<int, bool> isstable;\\n        \\n        for(int i=0; i<q; ++i) grid[hits[i][0]][hits[i][1]] -= 1; //removing all erased bricks\\n        \\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]!=1) continue;\\n                for(int it=0; it<4; ++it){\\n                    int x = i+dirs[it],y=j+dirs[it+1];\\n                    if(is(x,y) && grid[x][y]==1) {Union(f(i,j),f(x,y));} //generating connected components\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        for(int j=0;j<m;++j){\\n            if(grid[0][j]==1) isstable[find(f(0,j))] = true; //marking stable components\\n        }\\n        \\n        vector<int> ans(q);\\n        for(int k=q-1; k>=0; --k){\\n            int i = hits[k][0], j = hits[k][1], flag = 0;\\n            if(grid[i][j]==-1) continue;\\n            \\n            vector<int> unstable_neighbours;\\n            \\n            //checks whether hitting point is stable or not\\n            if(i==0) flag = 1;\\n            for(int it=0; it<4; ++it){ \\n                int x = i+dirs[it],y=j+dirs[it+1];\\n                //union the hitting point and its stable neighbour\\n                if(is(x,y) && (isstable.count(find(f(x,y))))) {\\n                    flag = 1; \\n                    Union(f(x,y), f(i,j));\\n                }\\n                else if(is(x,y) && !(isstable.count(find(f(x,y))))){\\n                    unstable_neighbours.push_back(f(x,y));\\n                }\\n            }\\n            \\n            \\n            //checking unstable neighbours\\n            int tans = 0;\\n            for(auto ngbh : unstable_neighbours){\\n                int x = ngbh/m, y = ngbh%m;\\n                if(grid[x][y]==1 && find(f(x,y))!=find(f(i,j))){\\n                    tans += -ds[find(f(x,y))];\\n                    Union(f(x,y),f(i,j)); \\n                }\\n                \\n            }\\n            grid[i][j] = 1;\\n            \\n            //marking node as stable\\n            if(flag){\\n                ans[k] = tans;\\n                isstable[find(f(i,j))] = true;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923903,
                "title": "c-simple-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>g;\\n    int m, n;\\n    int count = 0;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    bool is_valid(int i, int j){\\n        if(i >= 0 && i < m && j >= 0 && j < n) return true;\\n        return false;\\n    }\\n    void dfs(int i, int j){\\n        g[i][j] = 2; // 2 means brick in a cluster connected to ceiling  \\n        count++;\\n        for(int k = 0; k < 4; k++){\\n            int x = i + dx[k];\\n            int y = j + dy[k];\\n            if(is_valid(x, y) && g[x][y] == 1){\\n                dfs(x, y);\\n            }\\n        }\\n    }\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        g = grid;\\n        m = grid.size(), n = grid[0].size();\\n        for(auto h : hits){\\n            g[h[0]][h[1]] = 0;\\n        }\\n        for(int j = 0; j < n; j++){\\n            if(g[0][j] == 1){\\n                dfs(0, j);\\n            }\\n        }\\n        vector<int>ans(hits.size());\\n        for(int idx = hits.size() - 1; idx >= 0; idx--){\\n            int i = hits[idx][0];\\n            int j = hits[idx][1];\\n            if(grid[i][j] == 1){\\n                bool connected = false;\\n                for(int k = 0; k < 4; k++){\\n                    int x = i + dx[k], y = j + dy[k];\\n                    if(x == -1 || (is_valid(x, y) && g[x][y] == 2)){// -1 stands for the ROOF\\n                        connected = true;\\n                    }\\n                }\\n                g[i][j] = 1;\\n                if(connected){\\n                    count = 0;\\n                    dfs(i, j);\\n                    ans[idx] = count - 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>>g;\\n    int m, n;\\n    int count = 0;\\n    int dx[4] = {1, 0, -1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 571453,
                "title": "java-dfs-sol",
                "content": "```\\nclass Solution {\\n    //\\u552F\\u4E00\\u7684\\u901A\\u9053\\uFF0C\\u6240\\u4EE5\\u6211\\u4EEC\\u4ECE\\u53CD\\u65B9\\u5411\\u52A0\\u70B9\\u65F6\\uFF0C\\u6389\\u4E0B\\u7684\\u77F3\\u5934\\u53EA\\u80FD\\u901A\\u8FC7\\u8FD9\\u4E2A\\u70B9\\u8FDE\\u63A5\\n    //hit point is the only point for those falling brick can go through and touch the top \\n    int cnt=0;\\n    Set<Integer>set=new HashSet<>();\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int res[]=new int[hits.length];\\n        for(int i=0;i<hits.length;i++){\\n            if(grid[hits[i][0]][hits[i][1]]==0)set.add(i);\\n            grid[hits[i][0]][hits[i][1]]=0;\\n        }\\n\\n        for(int c=0;c<grid[0].length;c++){\\n            if(grid[0][c]!=0)dfscolor(grid,0,c,2);\\n        }\\n        for(int i=hits.length-1;i>=0;i--){\\n            if(set.contains(i))continue;\\n            int r=hits[i][0];int c=hits[i][1];\\n            if(r==0||isconnect(grid,r+1,c)||isconnect(grid,r-1,c)||isconnect(grid,r,c+1)||isconnect(grid,r,c-1)){\\n                grid[r][c]=1;\\n                dfsfind(grid,r,c);\\n                res[i]=cnt-1;\\n                cnt=0;\\n            }else{\\n                grid[r][c]=1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public void dfsfind(int grid[][],int r,int c){\\n         if(r<0||c<0||r>=grid.length||c>=grid[0].length)return;\\n         if(grid[r][c]!=1)return;\\n         grid[r][c]=2;\\n         cnt++;\\n         dfsfind(grid,r+1,c);\\n         dfsfind(grid,r-1,c);\\n         dfsfind(grid,r,c+1);\\n         dfsfind(grid,r,c-1);\\n    }\\n    \\n    public boolean isconnect(int grid[][],int r,int c){\\n        if(r<0||c<0||r>=grid.length||c>=grid[0].length)return false;\\n        if(grid[r][c]==2)return true;\\n        return false;\\n    }\\n    \\n    public void dfscolor(int grid[][],int r,int c,int color){\\n        if(r<0||c<0||r>=grid.length||c>=grid[0].length)return;\\n        if(grid[r][c]!=1)return;\\n        grid[r][c]=color;\\n        dfscolor(grid,r+1,c,color);\\n        dfscolor(grid,r-1,c,color);\\n        dfscolor(grid,r,c+1,color);\\n        dfscolor(grid,r,c-1,color);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //\\u552F\\u4E00\\u7684\\u901A\\u9053\\uFF0C\\u6240\\u4EE5\\u6211\\u4EEC\\u4ECE\\u53CD\\u65B9\\u5411\\u52A0\\u70B9\\u65F6\\uFF0C\\u6389\\u4E0B\\u7684\\u77F3\\u5934\\u53EA\\u80FD\\u901A\\u8FC7\\u8FD9\\u4E2A\\u70B9\\u8FDE\\u63A5\\n    //hit point is the only point for those falling brick can go through and touch the top \\n    int cnt=0;\\n    Set<Integer>set=new HashSet<>();\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int res[]=new int[hits.length];\\n        for(int i=0;i<hits.length;i++){\\n            if(grid[hits[i][0]][hits[i][1]]==0)set.add(i);\\n            grid[hits[i][0]][hits[i][1]]=0;\\n        }\\n\\n        for(int c=0;c<grid[0].length;c++){\\n            if(grid[0][c]!=0)dfscolor(grid,0,c,2);\\n        }\\n        for(int i=hits.length-1;i>=0;i--){\\n            if(set.contains(i))continue;\\n            int r=hits[i][0];int c=hits[i][1];\\n            if(r==0||isconnect(grid,r+1,c)||isconnect(grid,r-1,c)||isconnect(grid,r,c+1)||isconnect(grid,r,c-1)){\\n                grid[r][c]=1;\\n                dfsfind(grid,r,c);\\n                res[i]=cnt-1;\\n                cnt=0;\\n            }else{\\n                grid[r][c]=1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public void dfsfind(int grid[][],int r,int c){\\n         if(r<0||c<0||r>=grid.length||c>=grid[0].length)return;\\n         if(grid[r][c]!=1)return;\\n         grid[r][c]=2;\\n         cnt++;\\n         dfsfind(grid,r+1,c);\\n         dfsfind(grid,r-1,c);\\n         dfsfind(grid,r,c+1);\\n         dfsfind(grid,r,c-1);\\n    }\\n    \\n    public boolean isconnect(int grid[][],int r,int c){\\n        if(r<0||c<0||r>=grid.length||c>=grid[0].length)return false;\\n        if(grid[r][c]==2)return true;\\n        return false;\\n    }\\n    \\n    public void dfscolor(int grid[][],int r,int c,int color){\\n        if(r<0||c<0||r>=grid.length||c>=grid[0].length)return;\\n        if(grid[r][c]!=1)return;\\n        grid[r][c]=color;\\n        dfscolor(grid,r+1,c,color);\\n        dfscolor(grid,r-1,c,color);\\n        dfscolor(grid,r,c+1,color);\\n        dfscolor(grid,r,c-1,color);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498557,
                "title": "python-union-find",
                "content": "```\\nclass Solution(object):\\n    def hitBricks(self, grid, hits):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type hits: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        self.parents = {}\\n        hits2 = {(i,j) for i,j in hits}\\n        \\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 0 or (i,j) in hits2:\\n                    continue\\n                for x,y in [(-1,0), (0,-1)]:\\n                    if (i+x, j+y) in self.parents:\\n                        self.union((i+x, j+y), (i,j))\\n                if (i,j) not in self.parents:\\n                    self.find((i,j))\\n\\n        res = []        \\n        for i,j in hits[::-1]:\\n            if grid[i][j] != 1:\\n                res.append(0)\\n                continue\\n            k = 0\\n            flag = 0\\n            for x,y in [(-1,0), (0,-1), (1,0), (0,1)]:\\n                if (i+x, j+y) in self.parents:\\n                    p, cnt = self.union((i+x, j+y), (i,j))\\n                    if p[0] == 0:\\n                        flag = 1\\n                    else:\\n                        k += cnt\\n            if i == 0:\\n                flag = 1\\n            if (i,j) not in self.parents:\\n                self.find((i,j))\\n            res.append(flag*k)\\n            flag=0\\n            k=0\\n        return res[::-1]\\n                \\n            \\n\\n        \\n    def find(self,a):\\n        if a not in self.parents:\\n            self.parents[a] = (a, 1)\\n        \\n        if a != self.parents[a][0]:\\n            self.parents[a] = self.find(self.parents[a][0])\\n        return self.parents[a]\\n    \\n    def union(self, a, b):\\n        a_p, cnt_a = self.find(a)\\n        b_p, cnt_b = self.find(b)\\n        if a_p[0] == b_p[0] and a_p[1]==b_p[1]:\\n            return a_p, cnt_a\\n            \\n        if a_p[0] <= b_p[0]:\\n            self.parents[b_p] = (a_p, cnt_a+cnt_b)\\n            self.parents[a_p] = (a_p, cnt_a+cnt_b)\\n        else:\\n            self.parents[a_p] = (b_p, cnt_a+cnt_b)\\n            self.parents[b_p] = (b_p, cnt_a+cnt_b)\\n            \\n        return a_p, cnt_a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def hitBricks(self, grid, hits):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type hits: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        self.parents = {}\\n        hits2 = {(i,j) for i,j in hits}\\n        \\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 0 or (i,j) in hits2:\\n                    continue\\n                for x,y in [(-1,0), (0,-1)]:\\n                    if (i+x, j+y) in self.parents:\\n                        self.union((i+x, j+y), (i,j))\\n                if (i,j) not in self.parents:\\n                    self.find((i,j))\\n\\n        res = []        \\n        for i,j in hits[::-1]:\\n            if grid[i][j] != 1:\\n                res.append(0)\\n                continue\\n            k = 0\\n            flag = 0\\n            for x,y in [(-1,0), (0,-1), (1,0), (0,1)]:\\n                if (i+x, j+y) in self.parents:\\n                    p, cnt = self.union((i+x, j+y), (i,j))\\n                    if p[0] == 0:\\n                        flag = 1\\n                    else:\\n                        k += cnt\\n            if i == 0:\\n                flag = 1\\n            if (i,j) not in self.parents:\\n                self.find((i,j))\\n            res.append(flag*k)\\n            flag=0\\n            k=0\\n        return res[::-1]\\n                \\n            \\n\\n        \\n    def find(self,a):\\n        if a not in self.parents:\\n            self.parents[a] = (a, 1)\\n        \\n        if a != self.parents[a][0]:\\n            self.parents[a] = self.find(self.parents[a][0])\\n        return self.parents[a]\\n    \\n    def union(self, a, b):\\n        a_p, cnt_a = self.find(a)\\n        b_p, cnt_b = self.find(b)\\n        if a_p[0] == b_p[0] and a_p[1]==b_p[1]:\\n            return a_p, cnt_a\\n            \\n        if a_p[0] <= b_p[0]:\\n            self.parents[b_p] = (a_p, cnt_a+cnt_b)\\n            self.parents[a_p] = (a_p, cnt_a+cnt_b)\\n        else:\\n            self.parents[a_p] = (b_p, cnt_a+cnt_b)\\n            self.parents[b_p] = (b_p, cnt_a+cnt_b)\\n            \\n        return a_p, cnt_a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468382,
                "title": "commented-and-explained-simple-bfs-solution",
                "content": "```csharp\\npublic int[] HitBricks(int[][] grid, int[][] hits) {\\n\\tif(grid.Length == 0 || grid[0].Length == 0) return new int[] {};\\n\\n\\tint w = grid[0].Length, h = grid.Length;\\n\\n\\tvar locations = from x in Enumerable.Range(0, w)\\n\\t\\t\\t\\t\\tfrom y in Enumerable.Range(0, h)\\n\\t\\t\\t\\t\\tselect (x,y);\\n\\n\\t(int x, int y) ToCoord(int[] v) => (v[1], v[0]);\\n\\n\\tList<(int x, int y)> hitsAsCoord = hits.Select(ToCoord).ToList(); //convert hits to strong type\\n\\n\\tint GetGrid((int x, int y) coord) => grid[coord.y][coord.x];\\n\\tbool IsBlank((int, int) coord) => GetGrid(coord) != 1; //we use 0 for blank, and -1 for removed by hit\\n\\n    //Whether a coordinate is on the grid\\n\\tbool IsValid((int x, int y) coord) => coord.x >= 0 && coord.y >= 0 && coord.x < w && coord.y < h;\\n\\n\\tIEnumerable<(int, int)> GetAdjacentSquares((int x, int y) coord)\\n\\t{\\n\\t\\tyield return (coord.x, coord.y + 1);\\n\\t\\tyield return (coord.x, coord.y - 1);\\n\\t\\tyield return (coord.x - 1, coord.y);\\n\\t\\tyield return (coord.x + 1, coord.y);\\n\\t}\\n\\n\\t//Some hits go to a coordinate which never had a brick. If a hit occurs, we flip the value to -1.\\n\\t//We initially remove all hits from the grid to obtain the result with all stable bricks after all hits\\n\\tforeach(var coord in hitsAsCoord)\\n\\t{\\n\\t\\tgrid[coord.y][coord.x] = -grid[coord.y][coord.x];\\n\\t}\\n\\n\\tvar topLocations = locations.Where(x => x.y == 0).Where(x => !IsBlank(x));\\n\\n\\n\\tHashSet<(int, int)> connectedToTop = new HashSet<(int, int)>();\\n\\n\\tbool IsTop((int x, int y) coord) => coord.y == 0;\\n\\tbool HasAdjacentConnectedToTop((int x, int y) coord) => GetAdjacentSquares(coord).Where(IsValid).Any(connectedToTop.Contains);\\n\\n\\tbool IsConnectedToTop((int x, int y) coord) => IsTop(coord) || HasAdjacentConnectedToTop(coord);\\n\\n    //Perform BFS from the known top nodes to discover all stable bricks.\\n\\t{\\n\\t\\tvar bfs = new Queue<(int, int)>(topLocations);\\n\\n\\t\\twhile(bfs.Any())\\n\\t\\t{\\n\\t\\t\\tvar current = bfs.Dequeue();\\n\\n\\t\\t\\tif(!IsValid(current) || IsBlank(current) || connectedToTop.Contains(current)) { continue; }\\n\\t\\t\\tconnectedToTop.Add(current);\\n\\n\\t\\t\\tforeach(var adjacent in GetAdjacentSquares(current))\\n\\t\\t\\t{\\n\\t\\t\\t\\tbfs.Enqueue(adjacent);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n    //Add the bricks back in in reverse order.\\n\\tIEnumerable<int> AddBricksBackInReverse()\\n\\t{\\n\\t\\tforeach(var brickToAddBackIn in hitsAsCoord.AsEnumerable().Reverse())\\n\\t\\t{\\n\\t\\t\\tint count = 0; \\n\\t\\t\\tvar bfs = new Queue<(int, int)>(new[] { brickToAddBackIn });\\n\\n\\t\\t\\t//Some hits go to a coordinate which never had a brick. If a hit occurs, we flipped the value to -1.\\n\\t\\t\\t//So flip it back, if it was always 0, then nothing happens and the BFS ends early.\\n\\t\\t\\tgrid[brickToAddBackIn.y][brickToAddBackIn.x] = -grid[brickToAddBackIn.y][brickToAddBackIn.x]; \\n\\n\\t\\t\\twhile(bfs.Any())\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar current = bfs.Dequeue();\\n\\n\\t\\t\\t\\t//if we\\'re invalid, blank, or have already processed the node, skip.\\n\\t\\t\\t\\tif(!IsValid(current) || IsBlank(current) || connectedToTop.Contains(current)) { continue; }\\n\\n\\t\\t\\t\\t//added the square in, but it wasn\\'t on the top or adjacent to a connected node.\\n\\t\\t\\t\\tif(!IsConnectedToTop(current)) { continue;  }\\n\\n\\t\\t\\t\\t//we do not want to include the brick that is removed, only the bricks that would drop by the hit.\\n\\t\\t\\t\\tif(connectedToTop.Add(current) && !brickToAddBackIn.Equals(current))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//If the current node drops, adjacent nodes may also have dropped.\\n\\t\\t\\t\\tforeach(var adjacent in GetAdjacentSquares(current))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbfs.Enqueue(adjacent);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tyield return count;\\n\\t\\t}\\n\\t}\\n\\n\\n\\treturn AddBricksBackInReverse().Reverse().ToArray();\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```csharp\\npublic int[] HitBricks(int[][] grid, int[][] hits) {\\n\\tif(grid.Length == 0 || grid[0].Length == 0) return new int[] {};\\n\\n\\tint w = grid[0].Length, h = grid.Length;\\n\\n\\tvar locations = from x in Enumerable.Range(0, w)\\n\\t\\t\\t\\t\\tfrom y in Enumerable.Range(0, h)\\n\\t\\t\\t\\t\\tselect (x,y);\\n\\n\\t(int x, int y) ToCoord(int[] v) => (v[1], v[0]);\\n\\n\\tList<(int x, int y)> hitsAsCoord = hits.Select(ToCoord).ToList(); //convert hits to strong type\\n\\n\\tint GetGrid((int x, int y) coord) => grid[coord.y][coord.x];\\n\\tbool IsBlank((int, int) coord) => GetGrid(coord) != 1; //we use 0 for blank, and -1 for removed by hit\\n\\n    //Whether a coordinate is on the grid\\n\\tbool IsValid((int x, int y) coord) => coord.x >= 0 && coord.y >= 0 && coord.x < w && coord.y < h;\\n\\n\\tIEnumerable<(int, int)> GetAdjacentSquares((int x, int y) coord)\\n\\t{\\n\\t\\tyield return (coord.x, coord.y + 1);\\n\\t\\tyield return (coord.x, coord.y - 1);\\n\\t\\tyield return (coord.x - 1, coord.y);\\n\\t\\tyield return (coord.x + 1, coord.y);\\n\\t}\\n\\n\\t//Some hits go to a coordinate which never had a brick. If a hit occurs, we flip the value to -1.\\n\\t//We initially remove all hits from the grid to obtain the result with all stable bricks after all hits\\n\\tforeach(var coord in hitsAsCoord)\\n\\t{\\n\\t\\tgrid[coord.y][coord.x] = -grid[coord.y][coord.x];\\n\\t}\\n\\n\\tvar topLocations = locations.Where(x => x.y == 0).Where(x => !IsBlank(x));\\n\\n\\n\\tHashSet<(int, int)> connectedToTop = new HashSet<(int, int)>();\\n\\n\\tbool IsTop((int x, int y) coord) => coord.y == 0;\\n\\tbool HasAdjacentConnectedToTop((int x, int y) coord) => GetAdjacentSquares(coord).Where(IsValid).Any(connectedToTop.Contains);\\n\\n\\tbool IsConnectedToTop((int x, int y) coord) => IsTop(coord) || HasAdjacentConnectedToTop(coord);\\n\\n    //Perform BFS from the known top nodes to discover all stable bricks.\\n\\t{\\n\\t\\tvar bfs = new Queue<(int, int)>(topLocations);\\n\\n\\t\\twhile(bfs.Any())\\n\\t\\t{\\n\\t\\t\\tvar current = bfs.Dequeue();\\n\\n\\t\\t\\tif(!IsValid(current) || IsBlank(current) || connectedToTop.Contains(current)) { continue; }\\n\\t\\t\\tconnectedToTop.Add(current);\\n\\n\\t\\t\\tforeach(var adjacent in GetAdjacentSquares(current))\\n\\t\\t\\t{\\n\\t\\t\\t\\tbfs.Enqueue(adjacent);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n    //Add the bricks back in in reverse order.\\n\\tIEnumerable<int> AddBricksBackInReverse()\\n\\t{\\n\\t\\tforeach(var brickToAddBackIn in hitsAsCoord.AsEnumerable().Reverse())\\n\\t\\t{\\n\\t\\t\\tint count = 0; \\n\\t\\t\\tvar bfs = new Queue<(int, int)>(new[] { brickToAddBackIn });\\n\\n\\t\\t\\t//Some hits go to a coordinate which never had a brick. If a hit occurs, we flipped the value to -1.\\n\\t\\t\\t//So flip it back, if it was always 0, then nothing happens and the BFS ends early.\\n\\t\\t\\tgrid[brickToAddBackIn.y][brickToAddBackIn.x] = -grid[brickToAddBackIn.y][brickToAddBackIn.x]; \\n\\n\\t\\t\\twhile(bfs.Any())\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar current = bfs.Dequeue();\\n\\n\\t\\t\\t\\t//if we\\'re invalid, blank, or have already processed the node, skip.\\n\\t\\t\\t\\tif(!IsValid(current) || IsBlank(current) || connectedToTop.Contains(current)) { continue; }\\n\\n\\t\\t\\t\\t//added the square in, but it wasn\\'t on the top or adjacent to a connected node.\\n\\t\\t\\t\\tif(!IsConnectedToTop(current)) { continue;  }\\n\\n\\t\\t\\t\\t//we do not want to include the brick that is removed, only the bricks that would drop by the hit.\\n\\t\\t\\t\\tif(connectedToTop.Add(current) && !brickToAddBackIn.Equals(current))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//If the current node drops, adjacent nodes may also have dropped.\\n\\t\\t\\t\\tforeach(var adjacent in GetAdjacentSquares(current))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbfs.Enqueue(adjacent);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tyield return count;\\n\\t\\t}\\n\\t}\\n\\n\\n\\treturn AddBricksBackInReverse().Reverse().ToArray();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466449,
                "title": "c-o-q-m-n-dfs-is-enough-the-official-disjoint-set-union-find-solution-is-somewhat-misleading",
                "content": "The core idea to solve this problem efficiently is to build the grid **from back to front**.\\nWe don\\'t need to use disjoint set (union find) data structure to over kill this. Normal DFS is enough to find and mark all the \"fallen parts\" to the ceiling.\\n```\\nclass Solution {\\n    static constexpr int offsets[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\\n    int dfs(vector<vector<int>> &state, int r, int c) {\\n        if (r < 0 || r >= state.size() || c < 0 || c >= state[0].size()) {\\n            return 0;\\n        }\\n        if (state[r][c] != 1) {\\n            return 0;\\n        }\\n        state[r][c] = 2;\\n        int result = 1;\\n        for (int i = 0; i < 4; i++) {\\n            int r1 = r + offsets[i][0];\\n            int c1 = c + offsets[i][1];\\n            result += dfs(state, r1, c1);\\n        }\\n        return result;\\n    }\\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        // precondition: the ceiling is stable in the beginning\\n        vector<vector<int>> state = grid;\\t//0: empty, 1: fallen, 2: connected to the ceiling\\n        for (const vector<int> &pos : hits) {\\n            state[pos[0]][pos[1]] = 0;\\n        }\\n        for (int c = 0; c < state[0].size(); c++) {\\n            dfs(state, 0, c);\\n        }\\n        vector<int> result(hits.size());\\n        for (int i = hits.size() - 1; i >= 0; i--) {\\n            int r = hits[i][0];\\n            int c = hits[i][1];\\n            if (grid[r][c] == 0) {\\n                result[i] = 0;\\n                continue;\\n            }\\n            state[r][c] = 1;\\n            bool add = (r == 0);\\n            for (int j = 0; j < 4 && !add; j++) {\\n                int r1 = r + offsets[j][0];\\n                int c1 = c + offsets[j][1];\\n                if (r1 < 0 || r1 >= state.size() || c1 < 0 || c1 >= state[0].size()) {\\n                    continue;\\n                }\\n                if (state[r1][c1] == 2) {\\n                    add = true;\\n                }\\n            }\\n            int count = 0;\\n            if (add) {\\n                count = dfs(state, r, c) - 1;\\n            }\\n            result[i] = count;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static constexpr int offsets[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\\n    int dfs(vector<vector<int>> &state, int r, int c) {\\n        if (r < 0 || r >= state.size() || c < 0 || c >= state[0].size()) {\\n            return 0;\\n        }\\n        if (state[r][c] != 1) {\\n            return 0;\\n        }\\n        state[r][c] = 2;\\n        int result = 1;\\n        for (int i = 0; i < 4; i++) {\\n            int r1 = r + offsets[i][0];\\n            int c1 = c + offsets[i][1];\\n            result += dfs(state, r1, c1);\\n        }\\n        return result;\\n    }\\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        // precondition: the ceiling is stable in the beginning\\n        vector<vector<int>> state = grid;\\t//0: empty, 1: fallen, 2: connected to the ceiling\\n        for (const vector<int> &pos : hits) {\\n            state[pos[0]][pos[1]] = 0;\\n        }\\n        for (int c = 0; c < state[0].size(); c++) {\\n            dfs(state, 0, c);\\n        }\\n        vector<int> result(hits.size());\\n        for (int i = hits.size() - 1; i >= 0; i--) {\\n            int r = hits[i][0];\\n            int c = hits[i][1];\\n            if (grid[r][c] == 0) {\\n                result[i] = 0;\\n                continue;\\n            }\\n            state[r][c] = 1;\\n            bool add = (r == 0);\\n            for (int j = 0; j < 4 && !add; j++) {\\n                int r1 = r + offsets[j][0];\\n                int c1 = c + offsets[j][1];\\n                if (r1 < 0 || r1 >= state.size() || c1 < 0 || c1 >= state[0].size()) {\\n                    continue;\\n                }\\n                if (state[r1][c1] == 2) {\\n                    add = true;\\n                }\\n            }\\n            int count = 0;\\n            if (add) {\\n                count = dfs(state, r, c) - 1;\\n            }\\n            result[i] = count;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465148,
                "title": "c-solution-with-generic-union-find-class",
                "content": "```\\npublic class Solution \\n{\\n    int[] dx = new int[] {0, 1, 0, -1};\\n    int[] dy = new int[] {1, 0, -1, 0};\\n    \\n    public int[] HitBricks(int[][] grid, int[][] hits) \\n    {\\n        if (grid.Length == 0) return new int[0];\\n        int r = grid.Length, c = grid[0].Length;\\n        foreach(var hit in hits) \\n            grid[hit[0]][hit[1]]--;\\n        var uf = new UnionFind<string>();\\n        \\n        for (int i = 0; i < r; i++) \\n            for (int j = 0; j < c; j++)\\n                AddBrick(grid, uf, i, j);\\n        \\n        int[] result = new int[hits.Length];\\n        for (int k = hits.Length - 1; k >= 0; k--) \\n        {\\n            int x = hits[k][0], y = hits[k][1];\\n            if(++grid[x][y] > 0)\\n            {\\n                var before = uf.GetGroupCount(uf.Find(\"ROOF\"));\\n                AddBrick(grid, uf, x, y);\\n                var after = uf.GetGroupCount(uf.Find(\"ROOF\"));\\n                result[k] = before == after ? 0 : after - before - 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void AddBrick(int[][] grid, UnionFind<string> uf, int x, int y)\\n    {\\n        int r = grid.Length, c = grid[0].Length;\\n        if(grid[x][y] == 1)\\n        {\\n            for(int k = 0; k < 4; k++)\\n            {\\n                int nx = x + dx[k], ny = y + dy[k];\\n                if(nx >= 0 && nx < r && ny >= 0 && ny < c && grid[nx][ny] == 1)\\n                    uf.Union(x + \":\" + y, nx + \":\" + ny);\\n            }\\n            \\n            if(x == 0)\\n            {\\n                uf.Union(x + \":\" + y, \"ROOF\");\\n            }\\n        }\\n    }\\n}\\n\\npublic class UnionFind<T>\\n{\\n    private Dictionary<T, T> parentMap;\\n    private Dictionary<T, int> countMap;\\n    private int groupCount;\\n    \\n    public UnionFind()\\n    {\\n        groupCount = 0;\\n        parentMap = new Dictionary<T, T>();\\n        countMap = new Dictionary<T, int>();\\n    }\\n    \\n    public void Union(T item1, T item2)\\n    {\\n        T group1 = Find(item1), group2 = Find(item2);\\n        if(!group1.Equals(group2))\\n        {\\n            parentMap[group1] = group2;\\n            countMap[group2] += countMap[group1];\\n            countMap.Remove(group1);\\n            groupCount--;\\n        }\\n    }\\n    \\n    public T Find(T item)\\n    {\\n        if(!parentMap.ContainsKey(item)) \\n        {\\n            groupCount++;\\n            countMap[item] = 1;\\n            parentMap[item] = item;\\n        }\\n        \\n        if(!parentMap[item].Equals(item)) parentMap[item] = Find(parentMap[item]);\\n        return parentMap[item];\\n    }\\n    \\n    public int GetGroupCount(T item)\\n    {\\n        return countMap.ContainsKey(item) ? countMap[item] : 0;\\n    }\\n    \\n    public int GroupCount()\\n    {\\n        return groupCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    int[] dx = new int[] {0, 1, 0, -1};\\n    int[] dy = new int[] {1, 0, -1, 0};\\n    \\n    public int[] HitBricks(int[][] grid, int[][] hits) \\n    {\\n        if (grid.Length == 0) return new int[0];\\n        int r = grid.Length, c = grid[0].Length;\\n        foreach(var hit in hits) \\n            grid[hit[0]][hit[1]]--;\\n        var uf = new UnionFind<string>();\\n        \\n        for (int i = 0; i < r; i++) \\n            for (int j = 0; j < c; j++)\\n                AddBrick(grid, uf, i, j);\\n        \\n        int[] result = new int[hits.Length];\\n        for (int k = hits.Length - 1; k >= 0; k--) \\n        {\\n            int x = hits[k][0], y = hits[k][1];\\n            if(++grid[x][y] > 0)\\n            {\\n                var before = uf.GetGroupCount(uf.Find(\"ROOF\"));\\n                AddBrick(grid, uf, x, y);\\n                var after = uf.GetGroupCount(uf.Find(\"ROOF\"));\\n                result[k] = before == after ? 0 : after - before - 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void AddBrick(int[][] grid, UnionFind<string> uf, int x, int y)\\n    {\\n        int r = grid.Length, c = grid[0].Length;\\n        if(grid[x][y] == 1)\\n        {\\n            for(int k = 0; k < 4; k++)\\n            {\\n                int nx = x + dx[k], ny = y + dy[k];\\n                if(nx >= 0 && nx < r && ny >= 0 && ny < c && grid[nx][ny] == 1)\\n                    uf.Union(x + \":\" + y, nx + \":\" + ny);\\n            }\\n            \\n            if(x == 0)\\n            {\\n                uf.Union(x + \":\" + y, \"ROOF\");\\n            }\\n        }\\n    }\\n}\\n\\npublic class UnionFind<T>\\n{\\n    private Dictionary<T, T> parentMap;\\n    private Dictionary<T, int> countMap;\\n    private int groupCount;\\n    \\n    public UnionFind()\\n    {\\n        groupCount = 0;\\n        parentMap = new Dictionary<T, T>();\\n        countMap = new Dictionary<T, int>();\\n    }\\n    \\n    public void Union(T item1, T item2)\\n    {\\n        T group1 = Find(item1), group2 = Find(item2);\\n        if(!group1.Equals(group2))\\n        {\\n            parentMap[group1] = group2;\\n            countMap[group2] += countMap[group1];\\n            countMap.Remove(group1);\\n            groupCount--;\\n        }\\n    }\\n    \\n    public T Find(T item)\\n    {\\n        if(!parentMap.ContainsKey(item)) \\n        {\\n            groupCount++;\\n            countMap[item] = 1;\\n            parentMap[item] = item;\\n        }\\n        \\n        if(!parentMap[item].Equals(item)) parentMap[item] = Find(parentMap[item]);\\n        return parentMap[item];\\n    }\\n    \\n    public int GetGroupCount(T item)\\n    {\\n        return countMap.ContainsKey(item) ? countMap[item] : 0;\\n    }\\n    \\n    public int GroupCount()\\n    {\\n        return groupCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312068,
                "title": "java-union-find-9-ms-faster-than-65-76-52-mb-less-than-91-15",
                "content": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        UnionFind uf = new UnionFind(m * n + 1);\\n        for (int[] hit : hits) {\\n            if (grid[hit[0]][hit[1]] == 1) {\\n                grid[hit[0]][hit[1]] = 2;\\n            }\\n        }\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 1) {\\n                    unionAround(i, j, grid, uf, m, n);\\n                }\\n            }\\n        }\\n        int[] res = new int[hits.length];\\n        int cnt = uf.cnts[uf.find(0)];\\n        for (int i = hits.length - 1; i >= 0; --i) {\\n            int[] hit = hits[i];\\n            if (grid[hit[0]][hit[1]] == 2) {\\n                unionAround(hit[0], hit[1], grid, uf, m, n);\\n                grid[hit[0]][hit[1]] = 1;\\n            }\\n            int newCnt = uf.cnts[uf.find(0)];\\n            res[i] = newCnt > cnt ? newCnt - cnt - 1: 0;\\n            cnt = newCnt;\\n        }\\n        return res;\\n    }\\n    \\n    private void unionAround(int r, int c, int[][] grid, UnionFind uf, int m, int n) {\\n        for (int i = 0; i < 4; ++i) {\\n            int x = DX[i] + r;\\n            int y = DY[i] + c;\\n            if (0 <= x && x < m && 0 <= y && y < n && grid[x][y] == 1) {\\n                uf.union(r * n + c + 1, x * n + y + 1);\\n            }\\n        }\\n        if (r == 0) {\\n            uf.union(r * n + c + 1, 0);\\n        }\\n    }\\n    \\n    private static int[] DX = new int[]{0, -1, 0, 1};\\n    private static int[] DY = new int[]{-1, 0, 1, 0};\\n    \\n    private class UnionFind {\\n        int[] fathers;\\n        int[] cnts;\\n        \\n        public UnionFind(int n) {\\n            fathers = new int[n];\\n            cnts = new int[n];\\n            for (int i = 0; i < n; ++i) {\\n                fathers[i] = i;\\n                cnts[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int x) {\\n            int tmp = x;\\n            while (x != fathers[x]) {\\n                x = fathers[x];\\n            }\\n            while (tmp != x) {\\n                int r = fathers[tmp];\\n                fathers[tmp] = x;\\n                tmp = r;\\n            }\\n            return x;\\n        }\\n        \\n        public void union(int a, int b) {\\n            int fa = find(a);\\n            int fb = find(b);\\n            if (fa != fb) {\\n                fathers[fa] = fb;\\n                cnts[fb] += cnts[fa];\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        UnionFind uf = new UnionFind(m * n + 1);\\n        for (int[] hit : hits) {\\n            if (grid[hit[0]][hit[1]] == 1) {\\n                grid[hit[0]][hit[1]] = 2;\\n            }\\n        }\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 1) {\\n                    unionAround(i, j, grid, uf, m, n);\\n                }\\n            }\\n        }\\n        int[] res = new int[hits.length];\\n        int cnt = uf.cnts[uf.find(0)];\\n        for (int i = hits.length - 1; i >= 0; --i) {\\n            int[] hit = hits[i];\\n            if (grid[hit[0]][hit[1]] == 2) {\\n                unionAround(hit[0], hit[1], grid, uf, m, n);\\n                grid[hit[0]][hit[1]] = 1;\\n            }\\n            int newCnt = uf.cnts[uf.find(0)];\\n            res[i] = newCnt > cnt ? newCnt - cnt - 1: 0;\\n            cnt = newCnt;\\n        }\\n        return res;\\n    }\\n    \\n    private void unionAround(int r, int c, int[][] grid, UnionFind uf, int m, int n) {\\n        for (int i = 0; i < 4; ++i) {\\n            int x = DX[i] + r;\\n            int y = DY[i] + c;\\n            if (0 <= x && x < m && 0 <= y && y < n && grid[x][y] == 1) {\\n                uf.union(r * n + c + 1, x * n + y + 1);\\n            }\\n        }\\n        if (r == 0) {\\n            uf.union(r * n + c + 1, 0);\\n        }\\n    }\\n    \\n    private static int[] DX = new int[]{0, -1, 0, 1};\\n    private static int[] DY = new int[]{-1, 0, 1, 0};\\n    \\n    private class UnionFind {\\n        int[] fathers;\\n        int[] cnts;\\n        \\n        public UnionFind(int n) {\\n            fathers = new int[n];\\n            cnts = new int[n];\\n            for (int i = 0; i < n; ++i) {\\n                fathers[i] = i;\\n                cnts[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int x) {\\n            int tmp = x;\\n            while (x != fathers[x]) {\\n                x = fathers[x];\\n            }\\n            while (tmp != x) {\\n                int r = fathers[tmp];\\n                fathers[tmp] = x;\\n                tmp = r;\\n            }\\n            return x;\\n        }\\n        \\n        public void union(int a, int b) {\\n            int fa = find(a);\\n            int fb = find(b);\\n            if (fa != fb) {\\n                fathers[fa] = fb;\\n                cnts[fb] += cnts[fa];\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279454,
                "title": "python-bfs-in-reverse-order-not-remove-but-add-bricks",
                "content": "```\\nclass Solution(object):\\n    def hitBricks(self, grid, hits):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type hits: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        row, col = len(grid), len(grid[0])    \\n        res = []\\n        for x,y in hits:\\n            grid[x][y] -= 1 #remove all the disapeared bricks\\n        live_to_now = set()\\n                \\n        def bfs(node):\\n            seen = set([node])\\n            q = collections.deque()\\n            q.append(node)\\n            while q:\\n                x,y = q.popleft()\\n                for nx,ny in ((x-1,y),(x+1,y),(x,y-1),(x,y+1)):\\n                    if (nx,ny) not in seen and (nx,ny) not in live_to_now and 0<=nx<row and 0<=ny<col and grid[nx][ny]==1:\\n                        seen.add((nx,ny))\\n                        q.append((nx,ny))\\n            return seen        \\n        \\n        tmp = set()\\n        for i in xrange(col):\\n            if grid[0][i]==1 and (0,i) not in tmp:\\n                live = bfs((0,i))\\n                tmp |= live            \\n        live_to_now = tmp  # live to the end\\n            \\n        for x,y in hits[::-1]:  # add bricks in reverse order, we don\\'t have to do redundant work like searching from top\\n            grid[x][y] += 1\\n            if grid[x][y] == 1:\\n                if any(n in live_to_now for n in ((x-1,y), (x+1,y), (x,y-1), (x,y+1))) or x==0:\\n                    new_live = bfs((x,y))\\n                    res.append(len(new_live) - 1)\\n                    live_to_now |= new_live\\n                else: # no connection to the living part\\n                    res.append(0)\\n            else:   # originally, this place is 0\\n                res.append(0)\\n                \\n        return res[::-1]\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def hitBricks(self, grid, hits):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type hits: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        row, col = len(grid), len(grid[0])    \\n        res = []\\n        for x,y in hits:\\n            grid[x][y] -= 1 #remove all the disapeared bricks\\n        live_to_now = set()\\n                \\n        def bfs(node):\\n            seen = set([node])\\n            q = collections.deque()\\n            q.append(node)\\n            while q:\\n                x,y = q.popleft()\\n                for nx,ny in ((x-1,y),(x+1,y),(x,y-1),(x,y+1)):\\n                    if (nx,ny) not in seen and (nx,ny) not in live_to_now and 0<=nx<row and 0<=ny<col and grid[nx][ny]==1:\\n                        seen.add((nx,ny))\\n                        q.append((nx,ny))\\n            return seen        \\n        \\n        tmp = set()\\n        for i in xrange(col):\\n            if grid[0][i]==1 and (0,i) not in tmp:\\n                live = bfs((0,i))\\n                tmp |= live            \\n        live_to_now = tmp  # live to the end\\n            \\n        for x,y in hits[::-1]:  # add bricks in reverse order, we don\\'t have to do redundant work like searching from top\\n            grid[x][y] += 1\\n            if grid[x][y] == 1:\\n                if any(n in live_to_now for n in ((x-1,y), (x+1,y), (x,y-1), (x,y+1))) or x==0:\\n                    new_live = bfs((x,y))\\n                    res.append(len(new_live) - 1)\\n                    live_to_now |= new_live\\n                else: # no connection to the living part\\n                    res.append(0)\\n            else:   # originally, this place is 0\\n                res.append(0)\\n                \\n        return res[::-1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 235997,
                "title": "c-union-find",
                "content": "```\\n\\nclass DSU {\\npublic:\\n    DSU(int N, int B) : N(N), B(B), parent(N, -1), rank(N, 1), size(N, 1), base(N, false) {  \\n        for (int i = 0; i < B; ++i) {\\n            base[i] = true;\\n        }\\n    }\\n    \\n    void addEdge(int i, int j) {\\n        int p1 = doFind(i);\\n        int p2 = doFind(j);\\n        \\n        if (p1 == p2) {\\n            return;\\n        }\\n        \\n        if (rank[p1] < rank[p2]) {\\n            // Put p1 under p2\\n            parent[p1] = p2;\\n            size[p2] += size[p1];\\n            size[p1] = 0;        \\n        } else {\\n            // Put p2 under p1\\n            if (rank[p1] == rank[p2]) {\\n                ++rank[p1];\\n            }\\n            \\n            parent[p2] = p1;\\n            size[p1] += size[p2];\\n            size[p2] = 0;\\n        } \\n        \\n        base[p1] = base[p2] || base[p1];\\n        base[p2] = base[p1] || base[p2];\\n    }\\n   \\n    int getSize(int i) {\\n        return size[doFind(i)];\\n    }\\n    \\n    bool hasBase(int i) {\\n        return base[doFind(i)];\\n    }\\n\\nprivate:\\n    int doFind(int i) {\\n        if (parent[i] == -1) {\\n            return i;\\n        }\\n        \\n        parent[i] = doFind(parent[i]);\\n        \\n        return parent[i];\\n    }\\n    \\n    int N;\\n    int B;\\n    vector<int> parent;\\n    vector<int> rank;\\n    vector<int> size;\\n    vector<bool> base;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        // Dimensions\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        // Set all the brick locations to 0\\n        for (auto& hit: hits) {\\n            if (grid[hit[0]][hit[1]]) {\\n                grid[hit[0]][hit[1]] = 0;\\n            } else {\\n                hit = {-1, -1};\\n            }\\n        }\\n        \\n        // Find connected components\\n        vector<vector<int>> moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        DSU dsu(rows * cols, cols);\\n        \\n        for (int r = 0; r < rows; ++r) {\\n            for (int c = 0; c < cols; ++c) {\\n                if (grid[r][c] == 0) {\\n                    continue;\\n                }\\n                \\n                for (auto& m: moves) {\\n                    int nr = r + m[0];\\n                    int nc = c + m[1];\\n                    \\n                    if (nr < 0 || nr >= rows || nc < 0 || nc >= cols || grid[nr][nc] == 0) {\\n                        continue;\\n                    }\\n                    \\n                    dsu.addEdge(r * cols + c, nr * cols + nc);\\n                }\\n            }\\n        }\\n        \\n        // Set all the brick locations back to 1 in reverse order\\n        vector<int> counts(hits.size(), 0);  \\n        \\n        for (int i = hits.size() - 1; i >= 0; --i) {\\n            // Hit location\\n            int r = hits[i][0];\\n            int c = hits[i][1];\\n            \\n            // Ignore already no brick at this location\\n            if (r == -1 || c == -1) {\\n                continue;\\n            } \\n            \\n            // Put brick back\\n            grid[r][c] = 1;\\n            \\n            // Drop if the hit location is at base or one of the connected component is connected to base\\n            bool drop = r == 0;\\n            \\n            for (auto& m: moves) {\\n                int nr = r + m[0];\\n                int nc = c + m[1];\\n\\n                if (nr < 0 || nr >= rows || nc < 0 || nc >= cols || grid[nr][nc] == 0) {\\n                    continue;\\n                }\\n\\n                if (dsu.hasBase(nr * cols + nc)) {\\n                    // Neighbor is connected to base so drop\\n                    drop = true;\\n                } else {\\n                    // Not connected to base so this component can drop\\n                    counts[i] += dsu.getSize(nr * cols + nc);\\n                }\\n\\n                dsu.addEdge(r * cols + c, nr * cols + nc);\\n            }\\n            \\n            // Reset count if cannot drop bas no base connection\\n            if (!drop) {\\n                counts[i] = 0;\\n            }\\n        }\\n        \\n        return counts;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass DSU {\\npublic:\\n    DSU(int N, int B) : N(N), B(B), parent(N, -1), rank(N, 1), size(N, 1), base(N, false) {  \\n        for (int i = 0; i < B; ++i) {\\n            base[i] = true;\\n        }\\n    }\\n    \\n    void addEdge(int i, int j) {\\n        int p1 = doFind(i);\\n        int p2 = doFind(j);\\n        \\n        if (p1 == p2) {\\n            return;\\n        }\\n        \\n        if (rank[p1] < rank[p2]) {\\n            // Put p1 under p2\\n            parent[p1] = p2;\\n            size[p2] += size[p1];\\n            size[p1] = 0;        \\n        } else {\\n            // Put p2 under p1\\n            if (rank[p1] == rank[p2]) {\\n                ++rank[p1];\\n            }\\n            \\n            parent[p2] = p1;\\n            size[p1] += size[p2];\\n            size[p2] = 0;\\n        } \\n        \\n        base[p1] = base[p2] || base[p1];\\n        base[p2] = base[p1] || base[p2];\\n    }\\n   \\n    int getSize(int i) {\\n        return size[doFind(i)];\\n    }\\n    \\n    bool hasBase(int i) {\\n        return base[doFind(i)];\\n    }\\n\\nprivate:\\n    int doFind(int i) {\\n        if (parent[i] == -1) {\\n            return i;\\n        }\\n        \\n        parent[i] = doFind(parent[i]);\\n        \\n        return parent[i];\\n    }\\n    \\n    int N;\\n    int B;\\n    vector<int> parent;\\n    vector<int> rank;\\n    vector<int> size;\\n    vector<bool> base;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        // Dimensions\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        // Set all the brick locations to 0\\n        for (auto& hit: hits) {\\n            if (grid[hit[0]][hit[1]]) {\\n                grid[hit[0]][hit[1]] = 0;\\n            } else {\\n                hit = {-1, -1};\\n            }\\n        }\\n        \\n        // Find connected components\\n        vector<vector<int>> moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        DSU dsu(rows * cols, cols);\\n        \\n        for (int r = 0; r < rows; ++r) {\\n            for (int c = 0; c < cols; ++c) {\\n                if (grid[r][c] == 0) {\\n                    continue;\\n                }\\n                \\n                for (auto& m: moves) {\\n                    int nr = r + m[0];\\n                    int nc = c + m[1];\\n                    \\n                    if (nr < 0 || nr >= rows || nc < 0 || nc >= cols || grid[nr][nc] == 0) {\\n                        continue;\\n                    }\\n                    \\n                    dsu.addEdge(r * cols + c, nr * cols + nc);\\n                }\\n            }\\n        }\\n        \\n        // Set all the brick locations back to 1 in reverse order\\n        vector<int> counts(hits.size(), 0);  \\n        \\n        for (int i = hits.size() - 1; i >= 0; --i) {\\n            // Hit location\\n            int r = hits[i][0];\\n            int c = hits[i][1];\\n            \\n            // Ignore already no brick at this location\\n            if (r == -1 || c == -1) {\\n                continue;\\n            } \\n            \\n            // Put brick back\\n            grid[r][c] = 1;\\n            \\n            // Drop if the hit location is at base or one of the connected component is connected to base\\n            bool drop = r == 0;\\n            \\n            for (auto& m: moves) {\\n                int nr = r + m[0];\\n                int nc = c + m[1];\\n\\n                if (nr < 0 || nr >= rows || nc < 0 || nc >= cols || grid[nr][nc] == 0) {\\n                    continue;\\n                }\\n\\n                if (dsu.hasBase(nr * cols + nc)) {\\n                    // Neighbor is connected to base so drop\\n                    drop = true;\\n                } else {\\n                    // Not connected to base so this component can drop\\n                    counts[i] += dsu.getSize(nr * cols + nc);\\n                }\\n\\n                dsu.addEdge(r * cols + c, nr * cols + nc);\\n            }\\n            \\n            // Reset count if cannot drop bas no base connection\\n            if (!drop) {\\n                counts[i] = 0;\\n            }\\n        }\\n        \\n        return counts;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180817,
                "title": "c-dfs-reverse-scan-beats-98",
                "content": "I admit I read solution first and realize we can scan from end , but this problem only needs DFS, don\\'t need union find. We introduce a fake parent m\\\\*n. If a node is not connected to roof, its parent is -1, otherwise it is m\\\\*n. \\nWhen we add a node back, we calculate how many nodes are now connected to roof. The difference is the number of nodes that would drop if we remove that node. \\n\\n```\\nclass Solution {\\npublic:\\n    int dx[4] = {-1, 1, 0, 0};\\n    int dy[4] = {0, 0, -1, 1};\\n    void DFS(vector<vector<int>> &A, int x, int y, vector<vector<int>> &all_parents, int parent, int &total_connected, int m, int n){\\n        if(x<0 ||x>=m ||y<0 ||y>=n ||A[x][y] == 0 || all_parents[x][y] != -1)\\n            return;\\n        total_connected++;\\n        all_parents[x][y] = parent;\\n        for(int i=0; i<4; i++){\\n            DFS(A, x+dx[i], y+dy[i], all_parents, parent, total_connected, m, n);\\n        }\\n    }\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        vector<int> retV;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int parent = m*n;\\n        vector<vector<int>> all_parents(m, vector<int>(n, -1)); //initially no parents\\n\\n        vector<vector<int>> A(m, vector<int>(n, 0)); //initially no parents\\n        \\n        for (int i = 0; i < m; ++i)\\n            for(int j=0; j<n; j++)\\n                A[i][j] = grid[i][j];\\n        for (auto &hit: hits)\\n            A[hit[0]][hit[1]] = 0;\\n        \\n        int total_connected = 0;\\n        int i=0;\\n        for (int j=0; j<n; j++){\\n            if (A[i][j]) \\n                DFS(A, i, j, all_parents, parent, total_connected, m, n);\\n        }\\n        \\n        for(int i=hits.size()-1; i>=0; i--){\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            if(grid[x][y] == 0){\\n                retV.push_back(0);\\n                continue;\\n            }\\n            A[x][y] = 1;\\n\\n            int previous_total_connected=total_connected;\\n            \\n            //logic below is to decide if A[x][y] can connect to roof. \\n            if (x==0)\\n                all_parents[x][y] = parent;\\n            else{\\n                for(int k=0; k<4; k++){\\n                    int newx = x+dx[k];\\n                    int newy = y+dy[k];\\n                    if(newx<0 ||newx>=m ||newy<0 ||newy>=n ||A[newx][newy] == 0)\\n                        continue;\\n                    if(all_parents[newx][newy] != -1){\\n                        all_parents[x][y] = parent;\\n                        break;\\n                    }\\n                }\\n            }            \\n            \\n            //if A[x][y] can not connect to roof, no need to scan its neighbors. \\n            if (all_parents[x][y] == -1){\\n                retV.push_back(0);\\n                continue;\\n            }\\n            \\n            for(int k=0; k<4; k++){\\n                int newx = x+dx[k];\\n                int newy = y+dy[k];\\n                DFS(A, newx, newy, all_parents, parent, total_connected, m, n);\\n            }\\n            retV.push_back(total_connected - previous_total_connected);\\n        }\\n        reverse(retV.begin(), retV.end());\\n        return retV;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {-1, 1, 0, 0};\\n    int dy[4] = {0, 0, -1, 1};\\n    void DFS(vector<vector<int>> &A, int x, int y, vector<vector<int>> &all_parents, int parent, int &total_connected, int m, int n){\\n        if(x<0 ||x>=m ||y<0 ||y>=n ||A[x][y] == 0 || all_parents[x][y] != -1)\\n            return;\\n        total_connected++;\\n        all_parents[x][y] = parent;\\n        for(int i=0; i<4; i++){\\n            DFS(A, x+dx[i], y+dy[i], all_parents, parent, total_connected, m, n);\\n        }\\n    }\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        vector<int> retV;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int parent = m*n;\\n        vector<vector<int>> all_parents(m, vector<int>(n, -1)); //initially no parents\\n\\n        vector<vector<int>> A(m, vector<int>(n, 0)); //initially no parents\\n        \\n        for (int i = 0; i < m; ++i)\\n            for(int j=0; j<n; j++)\\n                A[i][j] = grid[i][j];\\n        for (auto &hit: hits)\\n            A[hit[0]][hit[1]] = 0;\\n        \\n        int total_connected = 0;\\n        int i=0;\\n        for (int j=0; j<n; j++){\\n            if (A[i][j]) \\n                DFS(A, i, j, all_parents, parent, total_connected, m, n);\\n        }\\n        \\n        for(int i=hits.size()-1; i>=0; i--){\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            if(grid[x][y] == 0){\\n                retV.push_back(0);\\n                continue;\\n            }\\n            A[x][y] = 1;\\n\\n            int previous_total_connected=total_connected;\\n            \\n            //logic below is to decide if A[x][y] can connect to roof. \\n            if (x==0)\\n                all_parents[x][y] = parent;\\n            else{\\n                for(int k=0; k<4; k++){\\n                    int newx = x+dx[k];\\n                    int newy = y+dy[k];\\n                    if(newx<0 ||newx>=m ||newy<0 ||newy>=n ||A[newx][newy] == 0)\\n                        continue;\\n                    if(all_parents[newx][newy] != -1){\\n                        all_parents[x][y] = parent;\\n                        break;\\n                    }\\n                }\\n            }            \\n            \\n            //if A[x][y] can not connect to roof, no need to scan its neighbors. \\n            if (all_parents[x][y] == -1){\\n                retV.push_back(0);\\n                continue;\\n            }\\n            \\n            for(int k=0; k<4; k++){\\n                int newx = x+dx[k];\\n                int newy = y+dy[k];\\n                DFS(A, newx, newy, all_parents, parent, total_connected, m, n);\\n            }\\n            retV.push_back(total_connected - previous_total_connected);\\n        }\\n        reverse(retV.begin(), retV.end());\\n        return retV;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791741,
                "title": "error",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    class DSU{\\n        \\n        public:\\n        vector<int>par;\\n    vector<int>size;\\n    vector<bool>top;\\n        DSU(int n,int c){\\n            par.resize(n);\\n            size.resize(n,1);\\n            top.resize(n,false);\\n            for(int i=0;i<c;i++) top[i]=true;\\n            for(int i=0;i<n;i++) par[i]=i;\\n        }\\n        int get(int x){\\n            return (x==par[x])?(x):par[x]=(get(par[x]));\\n        }\\n        void merge(int a,int b){\\n            a=get(a);\\n            b=get(b);\\n            if(a==b) return;\\n            if(size[b]>size[a]){\\n                swap(a,b);\\n            }\\n            par[b]=a;\\n            \\n            size[a]+=size[b];\\n            top[a]=top[a]|top[b];\\n            \\n        }\\n        int sz(int x){\\n            x = get(x);\\n            return size[x];\\n        }\\n        bool tp(int x){\\n            x = get(x);\\n            return top[x];\\n        }\\n    };\\n    \\n    vector<int> hitBricks(vector<vector<int>>& g, vector<vector<int>>& h) {\\n        int n = g.size(),m=g[0].size();\\n        vector<vector<int>>dir{{1,0},{-1,0},{0,1},{0,-1}};\\n        DSU *a=new DSU(n*m,m);\\n        for(auto it:h){\\n            int x= it[0],y=it[1];\\n            if(g[x][y]==1) g[x][y]=0;\\n            else g[x][y]=-1;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(g[i][j]<=0) continue;\\n                int cur = i*m+j;\\n                for(auto it:dir){\\n                    int x = i+it[0],y=j+it[1];\\n                    if((x<0)||(y<0)||(x>=n)||(y>=m)||(g[x][y]!=1)) continue;\\n                    int now = x*m+y;\\n                    a->merge(cur,now);\\n                }\\n            }\\n        }\\n        vector<int>ans(h.size(),0);\\n        for(int r=h.size()-1;r>=0;r--){\\n            int i=h[r][0],j=h[r][1];\\n            if(g[i][j]==-1){\\n                g[i][j]=0;\\n                ans[r]=0;\\n                continue;\\n            }\\n            g[i][j]=1;\\n            int cur = i*m+j;\\n            int cnt=0;\\n            for(auto it:dir){\\n                int x = i+it[0],y=j+it[1];\\n                if((x<0)||(y<0)||(x>=n)||(y>=m)||(g[x][y]!=1)) continue;\\n                int now = x*m+y;\\n                if((a->tp(now))==false) cnt+=a->sz(now);\\n                a->merge(cur,now);\\n            }\\n            if(a->tp(cur)) ans[r]=cnt;\\n            // if(i==0) ans[r]++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\'\\'\\'\\n\\nError at test case 33 , please someone help!!",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    class DSU{\\n        \\n        public:\\n        vector<int>par;\\n    vector<int>size;\\n    vector<bool>top;\\n        DSU(int n,int c){\\n            par.resize(n);\\n            size.resize(n,1);\\n            top.resize(n,false);\\n            for(int i=0;i<c;i++) top[i]=true;\\n            for(int i=0;i<n;i++) par[i]=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3700044,
                "title": "dijkstras",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all, record the time at which a brick gets hit in the graph/grid itself.\\nNOW ,  the question becomes AT WHAT TIME DOES A BRICK FALL?\\nA BRICK FALLS AFTER IT\\'S LAST SUPPORT FALLS\\n\\nSo , simply run a dijkstras from the top layer and take the minimum along the path, and update if you find another path with greater time.\\n\\nafter that simply increment the times.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        vector<int> ans(hits.size(),0);\\n        vector<pair<int,int>> adj={{0,1},{1,0},{-1,0},{0,-1}};\\n        // max to max till when is it stable\\n        // set counts on grid about it maybe and then what??\\n        //start a bfs from top row with taking min along the path \\n        // but trying to set the maximum overall\\n        // maybe use dijkstras for it\\n        for(int i=0;i<hits.size();i++){\\n            if(grid[hits[i][0]][hits[i][1]]==0){continue;}\\n            grid[hits[i][0]][hits[i][1]]=i+2;\\n        }\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    grid[i][j]=INT_MAX;\\n                }\\n                // cout<<grid[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }\\n        priority_queue<vector<int>> pq;//{mini,x,y}\\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),0));\\n        for(int i=0;i<grid[0].size();i++){\\n            if(grid[0][i]!=0)pq.push({grid[0][i],0,i});\\n            vis[0][i]=grid[0][i];\\n        }\\n       \\n        while(pq.size()){\\n            auto cur=pq.top();pq.pop();\\n            int cx=cur[1],cy=cur[2];\\n            for(auto [tx,ty]:adj){\\n                int x=tx+cx,y=ty+cy;\\n                if(x<0||y<0||x>=grid.size()||y>=grid[0].size()||grid[x][y]==0){continue;}\\n                int cmin=min(cur[0],grid[x][y]);\\n                if(cmin<=vis[x][y]){continue;}\\n                vis[x][y]=cmin;\\n                pq.push({cmin,x,y});\\n            }\\n        }\\n        // cout<<\"Y\"<<endl;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==0||vis[i][j]-2<0||vis[i][j]-2>=ans.size()){continue;}\\n                // cout<<vis[i][j]<<\" \";\\n                ans[vis[i][j]-2]++;\\n            }\\n            // cout<<endl;\\n        }\\n        for(int i=0;i<ans.size();i++){\\n            if(ans[i]>=1){ans[i]--;}\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        vector<int> ans(hits.size(),0);\\n        vector<pair<int,int>> adj={{0,1},{1,0},{-1,0},{0,-1}};\\n        // max to max till when is it stable\\n        // set counts on grid about it maybe and then what??\\n        //start a bfs from top row with taking min along the path \\n        // but trying to set the maximum overall\\n        // maybe use dijkstras for it\\n        for(int i=0;i<hits.size();i++){\\n            if(grid[hits[i][0]][hits[i][1]]==0){continue;}\\n            grid[hits[i][0]][hits[i][1]]=i+2;\\n        }\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    grid[i][j]=INT_MAX;\\n                }\\n                // cout<<grid[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }\\n        priority_queue<vector<int>> pq;//{mini,x,y}\\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),0));\\n        for(int i=0;i<grid[0].size();i++){\\n            if(grid[0][i]!=0)pq.push({grid[0][i],0,i});\\n            vis[0][i]=grid[0][i];\\n        }\\n       \\n        while(pq.size()){\\n            auto cur=pq.top();pq.pop();\\n            int cx=cur[1],cy=cur[2];\\n            for(auto [tx,ty]:adj){\\n                int x=tx+cx,y=ty+cy;\\n                if(x<0||y<0||x>=grid.size()||y>=grid[0].size()||grid[x][y]==0){continue;}\\n                int cmin=min(cur[0],grid[x][y]);\\n                if(cmin<=vis[x][y]){continue;}\\n                vis[x][y]=cmin;\\n                pq.push({cmin,x,y});\\n            }\\n        }\\n        // cout<<\"Y\"<<endl;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==0||vis[i][j]-2<0||vis[i][j]-2>=ans.size()){continue;}\\n                // cout<<vis[i][j]<<\" \";\\n                ans[vis[i][j]-2]++;\\n            }\\n            // cout<<endl;\\n        }\\n        for(int i=0;i<ans.size();i++){\\n            if(ans[i]>=1){ans[i]--;}\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3692291,
                "title": "my-solutions",
                "content": "**1. Use the Disjoint Set**\\n```\\n/**\\n * the data structure `disjoint set` is employed.\\n * 1. iterate the `hits`,\\n *    if it\\'s a brick, mark it as a `hit brick`,\\n *    which has a different value from the value representing `brick.`\\n * 2. iterate the `hits` from back to front, restore the `hit brick` to `brick`,\\n *    use the `disjoint set` to calculate the number of the stable bricks before\\n *    (`original`) and after (`current`) the action of restoring happens, the value\\n *    of max(0, `current` - `orignal` - 1) is the answer of the current hit.\\n *\\n * Time Complexity: O(rows * cols + n_hits)\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the binary grid `grid`\\n *       `cols` is the number of the columns of the binary grid `grid`\\n */\\nclass Solution {\\n private:\\n  static constexpr int directions[] = {0, 1, 0, -1, 0};\\n  static constexpr int n_direction_rb = 2;\\n  static constexpr int n_directions = 4;\\n  static constexpr int brick = 1;\\n  static constexpr int hit_brick = -1;\\n  static constexpr int imaginary_stable_cell_index = 0;\\n  static constexpr int imaginary_stable_cell_count = 1;\\n  \\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), groups_(n, 1) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (i == parents_[i]) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      const int final_group = groups_[parent_i] + groups_[parent_j];\\n      if (groups_[parent_i] < groups_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n        groups_[parent_j] = final_group;\\n        groups_[parent_i] = 0;\\n      } else {\\n        parents_[parent_j] = parent_i;\\n        groups_[parent_i] = final_group;\\n        groups_[parent_j] = 0;\\n      }\\n      return true;\\n    }\\n    \\n    int group(const int i) {\\n      return groups_[find(i)];\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> groups_;\\n  };\\n\\n public:\\n  vector<int> hitBricks(vector<vector<int>> &grid,\\n                        const vector<vector<int>> &hits) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    for (const vector<int> &hit : hits) {\\n      const int r = hit.front();\\n      const int c = hit.back();\\n      if (grid[r][c] == brick) {\\n        grid[r][c] = hit_brick;\\n      }\\n    }\\n    \\n    auto index = [cols](const int r, const int c) -> int {\\n      return r * cols + c + imaginary_stable_cell_count;\\n    };\\n    \\n    DisjointSet ds(rows * cols + imaginary_stable_cell_count);\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (grid[r][c] != brick) {\\n          continue;\\n        }\\n        \\n        const int i = index(r, c);\\n        for (int d = 0; d < n_direction_rb; ++d) {\\n          const int nr = r + directions[d];\\n          const int nc = c + directions[d + 1];\\n          if (nr < rows && nc < cols && grid[nr][nc] == brick) {\\n            ds.do_union(i, index(nr, nc));\\n          }\\n        }\\n      }\\n    }\\n    \\n    for (int c = 0; c < cols; ++c) {\\n      if (grid[0][c] == brick) {\\n        ds.do_union(imaginary_stable_cell_index, index(0, c));\\n      }\\n    }\\n    \\n    const int n_hits = static_cast<int>(hits.size());\\n    vector<int> ret(n_hits);\\n    for (int i_hit = n_hits - 1; i_hit > -1; --i_hit) {\\n      const int r = hits[i_hit].front();\\n      const int c = hits[i_hit].back();\\n      if (grid[r][c] != hit_brick) {\\n        continue;\\n      }\\n      \\n      grid[r][c] = brick;\\n      const int i = index(r, c);\\n      const int original_group_size = ds.group(imaginary_stable_cell_index);\\n      if (r == 0) {\\n        ds.do_union(imaginary_stable_cell_index, index(0, c));\\n      }\\n      for (int d = 0; d < n_directions; ++d) {\\n        const int nr = r + directions[d];\\n        const int nc = c + directions[d + 1];\\n        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == brick) {\\n          ds.do_union(i, index(nr, nc));\\n        }\\n      }\\n      \\n      ret[i_hit] = max(0, ds.group(imaginary_stable_cell_index) - original_group_size - 1);\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the DFS**\\n```\\n/**\\n * 1. iterate the `hits`,\\n *    if it\\'s a brick, mark it as a `hit brick`,\\n *    which has a different value from the value representing `brick.`\\n * 2. iterate the `hits` from back to front, restore the `hit brick` to `brick`,\\n *    use the `DFS` to get the number of new stable bricks caused by\\n *    the action of restoring, which minus 1 is the answer of the current hit.\\n *\\n * Time Complexity: O(rows * cols + n_hits)\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the binary grid `grid`\\n *       `cols` is the number of the columns of the binary grid `grid`\\n */\\nclass Solution {\\n private:\\n  static constexpr int directions[] = {0, 1, 0, -1, 0};\\n  static constexpr int n_directions = 4;\\n  static constexpr int brick = 1;\\n  static constexpr int hit_brick = -1;\\n  static constexpr int stable_brick = 2;\\n\\n public:\\n  vector<int> hitBricks(vector<vector<int>> &grid,\\n                        const vector<vector<int>> &hits) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    for (const vector<int> &hit : hits) {\\n      const int r = hit.front();\\n      const int c = hit.back();\\n      if (grid[r][c] == brick) {\\n        grid[r][c] = hit_brick;\\n      }\\n    }\\n    \\n    for (int c = 0; c < cols; ++c) {\\n      if (grid[0][c] == brick) {\\n        dfs(grid, 0, c);\\n      }\\n    }\\n    \\n    const int n_hits = static_cast<int>(hits.size());\\n    vector<int> ret(n_hits);\\n    for (int i_hit = n_hits - 1; i_hit > -1; --i_hit) {\\n      const int r = hits[i_hit].front();\\n      const int c = hits[i_hit].back();\\n      if (grid[r][c] != hit_brick) {\\n        continue;\\n      }\\n      \\n      grid[r][c] = brick;\\n      bool stable = r == 0;\\n      for (int d = 0; !stable && d < n_directions; ++d) {\\n        const int nr = r + directions[d];\\n        const int nc = c + directions[d + 1];\\n        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == stable_brick) {\\n          stable = true;\\n          break;\\n        }\\n      }\\n      if (stable) {\\n        ret[i_hit] = dfs(grid, r, c) - 1;\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  /**\\n   * @return the number of the stablized bricks\\n   */\\n  int dfs(vector<vector<int>> &grid, const int r, const int c) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    grid[r][c] = stable_brick;\\n    int ret = 1;\\n    for (int d = 0; d < n_directions; ++d) {\\n      const int nr = r + directions[d];\\n      const int nc = c + directions[d + 1];\\n      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == brick) {\\n        ret += dfs(grid, nr, nc);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * the data structure `disjoint set` is employed.\\n * 1. iterate the `hits`,\\n *    if it\\'s a brick, mark it as a `hit brick`,\\n *    which has a different value from the value representing `brick.`\\n * 2. iterate the `hits` from back to front, restore the `hit brick` to `brick`,\\n *    use the `disjoint set` to calculate the number of the stable bricks before\\n *    (`original`) and after (`current`) the action of restoring happens, the value\\n *    of max(0, `current` - `orignal` - 1) is the answer of the current hit.\\n *\\n * Time Complexity: O(rows * cols + n_hits)\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the binary grid `grid`\\n *       `cols` is the number of the columns of the binary grid `grid`\\n */\\nclass Solution {\\n private:\\n  static constexpr int directions[] = {0, 1, 0, -1, 0};\\n  static constexpr int n_direction_rb = 2;\\n  static constexpr int n_directions = 4;\\n  static constexpr int brick = 1;\\n  static constexpr int hit_brick = -1;\\n  static constexpr int imaginary_stable_cell_index = 0;\\n  static constexpr int imaginary_stable_cell_count = 1;\\n  \\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), groups_(n, 1) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (i == parents_[i]) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      const int final_group = groups_[parent_i] + groups_[parent_j];\\n      if (groups_[parent_i] < groups_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n        groups_[parent_j] = final_group;\\n        groups_[parent_i] = 0;\\n      } else {\\n        parents_[parent_j] = parent_i;\\n        groups_[parent_i] = final_group;\\n        groups_[parent_j] = 0;\\n      }\\n      return true;\\n    }\\n    \\n    int group(const int i) {\\n      return groups_[find(i)];\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> groups_;\\n  };\\n\\n public:\\n  vector<int> hitBricks(vector<vector<int>> &grid,\\n                        const vector<vector<int>> &hits) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    for (const vector<int> &hit : hits) {\\n      const int r = hit.front();\\n      const int c = hit.back();\\n      if (grid[r][c] == brick) {\\n        grid[r][c] = hit_brick;\\n      }\\n    }\\n    \\n    auto index = [cols](const int r, const int c) -> int {\\n      return r * cols + c + imaginary_stable_cell_count;\\n    };\\n    \\n    DisjointSet ds(rows * cols + imaginary_stable_cell_count);\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (grid[r][c] != brick) {\\n          continue;\\n        }\\n        \\n        const int i = index(r, c);\\n        for (int d = 0; d < n_direction_rb; ++d) {\\n          const int nr = r + directions[d];\\n          const int nc = c + directions[d + 1];\\n          if (nr < rows && nc < cols && grid[nr][nc] == brick) {\\n            ds.do_union(i, index(nr, nc));\\n          }\\n        }\\n      }\\n    }\\n    \\n    for (int c = 0; c < cols; ++c) {\\n      if (grid[0][c] == brick) {\\n        ds.do_union(imaginary_stable_cell_index, index(0, c));\\n      }\\n    }\\n    \\n    const int n_hits = static_cast<int>(hits.size());\\n    vector<int> ret(n_hits);\\n    for (int i_hit = n_hits - 1; i_hit > -1; --i_hit) {\\n      const int r = hits[i_hit].front();\\n      const int c = hits[i_hit].back();\\n      if (grid[r][c] != hit_brick) {\\n        continue;\\n      }\\n      \\n      grid[r][c] = brick;\\n      const int i = index(r, c);\\n      const int original_group_size = ds.group(imaginary_stable_cell_index);\\n      if (r == 0) {\\n        ds.do_union(imaginary_stable_cell_index, index(0, c));\\n      }\\n      for (int d = 0; d < n_directions; ++d) {\\n        const int nr = r + directions[d];\\n        const int nc = c + directions[d + 1];\\n        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == brick) {\\n          ds.do_union(i, index(nr, nc));\\n        }\\n      }\\n      \\n      ret[i_hit] = max(0, ds.group(imaginary_stable_cell_index) - original_group_size - 1);\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * 1. iterate the `hits`,\\n *    if it\\'s a brick, mark it as a `hit brick`,\\n *    which has a different value from the value representing `brick.`\\n * 2. iterate the `hits` from back to front, restore the `hit brick` to `brick`,\\n *    use the `DFS` to get the number of new stable bricks caused by\\n *    the action of restoring, which minus 1 is the answer of the current hit.\\n *\\n * Time Complexity: O(rows * cols + n_hits)\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the binary grid `grid`\\n *       `cols` is the number of the columns of the binary grid `grid`\\n */\\nclass Solution {\\n private:\\n  static constexpr int directions[] = {0, 1, 0, -1, 0};\\n  static constexpr int n_directions = 4;\\n  static constexpr int brick = 1;\\n  static constexpr int hit_brick = -1;\\n  static constexpr int stable_brick = 2;\\n\\n public:\\n  vector<int> hitBricks(vector<vector<int>> &grid,\\n                        const vector<vector<int>> &hits) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    for (const vector<int> &hit : hits) {\\n      const int r = hit.front();\\n      const int c = hit.back();\\n      if (grid[r][c] == brick) {\\n        grid[r][c] = hit_brick;\\n      }\\n    }\\n    \\n    for (int c = 0; c < cols; ++c) {\\n      if (grid[0][c] == brick) {\\n        dfs(grid, 0, c);\\n      }\\n    }\\n    \\n    const int n_hits = static_cast<int>(hits.size());\\n    vector<int> ret(n_hits);\\n    for (int i_hit = n_hits - 1; i_hit > -1; --i_hit) {\\n      const int r = hits[i_hit].front();\\n      const int c = hits[i_hit].back();\\n      if (grid[r][c] != hit_brick) {\\n        continue;\\n      }\\n      \\n      grid[r][c] = brick;\\n      bool stable = r == 0;\\n      for (int d = 0; !stable && d < n_directions; ++d) {\\n        const int nr = r + directions[d];\\n        const int nc = c + directions[d + 1];\\n        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == stable_brick) {\\n          stable = true;\\n          break;\\n        }\\n      }\\n      if (stable) {\\n        ret[i_hit] = dfs(grid, r, c) - 1;\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  /**\\n   * @return the number of the stablized bricks\\n   */\\n  int dfs(vector<vector<int>> &grid, const int r, const int c) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    grid[r][c] = stable_brick;\\n    int ret = 1;\\n    for (int d = 0; d < n_directions; ++d) {\\n      const int nr = r + directions[d];\\n      const int nc = c + directions[d + 1];\\n      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == brick) {\\n        ret += dfs(grid, nr, nc);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663242,
                "title": "doubt-in-a-test-cases",
                "content": "Input\\n[[1,0,1],[1,1,1]]\\n[[0,0],[0,2],[1,1]]\\nOutput - [0,0,0]\\nExpected - [0,3,0]\\n\\nIf you remove (0,2) - (1,2) is attached to (1,1) which in turn is attached on (1,0) and (0,0). Hence answer should be [0,0,0]\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        graph = defaultdict(set)\\n        inGraph = defaultdict(set)\\n        \\n        visited = {}\\n        def helperdfs(point,parent):\\n            visited[point]=parent\\n            graph[point].add(parent)\\n            inGraph[parent].add(point)   \\n            \\n            for dx,dy in [[1,0],[-1,0],[0,1],[0,-1]]:\\n                p,q = point[0]+dx,point[1]+dy\\n                if 0<=p<m and 0<=q<n:\\n                    if grid[p][q]==1:\\n                        grid[p][q]=0\\n                        helperdfs((p,q),point)\\n                        grid[p][q]=1\\n                        \\n        for j in range(n):\\n            if grid[0][j]==1:\\n                grid[0][j]=0\\n                helperdfs((0,j),(-1,-1))\\n                grid[0][j]=1\\n                \\n        print(graph)\\n        print(inGraph)\\n        \\n        removeSt = set([])\\n        \\n        self.count = 1\\n        def helperdfsExplore(point): \\n            grid[point[0]][point[1]]=0\\n            for ngbh in list(inGraph[point]):\\n                if len(graph[ngbh])==1 and point in graph[ngbh]:\\n                    graph.pop(ngbh)\\n                    inGraph[point].discard(ngbh)\\n                    self.count+=1\\n                    helperdfsExplore(ngbh)\\n        result = []    \\n        for node in hits:\\n            if grid[node[0]][node[1]]==1:\\n                self.count=0\\n                grid[node[0]][node[1]]=0\\n                graph.pop(tuple(node))\\n                helperdfsExplore(tuple(node))\\n                result.append(self.count)\\n            else:\\n                result.append(0)\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        graph = defaultdict(set)\\n        inGraph = defaultdict(set)\\n        \\n        visited = {}\\n        def helperdfs(point,parent):\\n            visited[point]=parent\\n            graph[point].add(parent)\\n            inGraph[parent].add(point)   \\n            \\n            for dx,dy in [[1,0],[-1,0],[0,1],[0,-1]]:\\n                p,q = point[0]+dx,point[1]+dy\\n                if 0<=p<m and 0<=q<n:\\n                    if grid[p][q]==1:\\n                        grid[p][q]=0\\n                        helperdfs((p,q),point)\\n                        grid[p][q]=1\\n                        \\n        for j in range(n):\\n            if grid[0][j]==1:\\n                grid[0][j]=0\\n                helperdfs((0,j),(-1,-1))\\n                grid[0][j]=1\\n                \\n        print(graph)\\n        print(inGraph)\\n        \\n        removeSt = set([])\\n        \\n        self.count = 1\\n        def helperdfsExplore(point): \\n            grid[point[0]][point[1]]=0\\n            for ngbh in list(inGraph[point]):\\n                if len(graph[ngbh])==1 and point in graph[ngbh]:\\n                    graph.pop(ngbh)\\n                    inGraph[point].discard(ngbh)\\n                    self.count+=1\\n                    helperdfsExplore(ngbh)\\n        result = []    \\n        for node in hits:\\n            if grid[node[0]][node[1]]==1:\\n                self.count=0\\n                grid[node[0]][node[1]]=0\\n                graph.pop(tuple(node))\\n                helperdfsExplore(tuple(node))\\n                result.append(self.count)\\n            else:\\n                result.append(0)\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558537,
                "title": "elegant-way-c-union-find",
                "content": "![image](https://assets.leetcode.com/users/images/5cf85837-37fc-4e78-99d3-aec37c6f22bc_1684925310.2459083.jpeg)\\n```\\nclass DSU{\\n    vector<int> par,rank;\\n    public:\\n    DSU(int n){\\n        par.resize(n,-1);\\n        rank.resize(n,1);\\n    }\\n    int find(int x){\\n\\t\\tif(par[x] == -1)return x;\\n\\t\\treturn par[x] = find(par[x]);\\n\\t}\\n\\n\\tvoid unite(int u,int v){\\n\\t\\tint x = find(u), y = find(v);\\n\\t\\tif(x == y)return;\\n       \\n\\t\\tif(rank[x] < rank[y])swap(x,y);\\n\\t\\t\\n        rank[x] += rank[y];\\n\\t\\tpar[y] = x;\\n\\t}\\n    int getSize(int x){\\n        return rank[find(x)];\\n    }\\n    \\n    int getTopSize(){\\n        return getSize(rank.size()-1) - 1;\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& OldGrid, vector<vector<int>>& hits) {\\n        int dx[4] = {1,0,-1,0};\\n        int dy[4] = {0,1,0,-1};\\n        int R = OldGrid.size(), C = OldGrid[0].size();\\n        vector<vector<int>> NewGrid(R,vector<int>(C,0));\\n        for(int i = 0; i <R; i++){\\n            NewGrid[i] = OldGrid[i];\\n        }\\n        \\n        DSU d(R*C + 1);\\n        \\n        for(auto hit:hits){\\n            NewGrid[hit[0]][hit[1]] = 0;\\n        }\\n        for(int i = 0; i < R; i++){\\n            for(int j = 0; j < C; j++){\\n                if(NewGrid[i][j] == 1){\\n                    int pos = i*C + j;\\n                    if(i == 0)d.unite(pos,R*C);\\n                    if(i >0 && NewGrid[i-1][j] == 1)d.unite(pos,(i-1)*C + j);\\n                    if(j > 0 && NewGrid[i][j-1] == 1)d.unite(pos,i*C + j-1);\\n                }\\n            }\\n        }\\n        int T = hits.size();\\n        vector<int> ans(T,0);\\n        for(int t = T - 1; t >= 0; t--){\\n       \\n            int r = hits[t][0], c = hits[t][1];\\n            if(OldGrid[r][c] == 0){\\n                continue;\\n            }\\n            int InitRoofAttached = d.getTopSize();\\n            int i = r*C + c;\\n            for(int k = 0; k < 4; k++){\\n                int nr = r + dx[k];\\n                int nc = c + dy[k];\\n                if(nr < 0 || nr >= R || nc <0 || nc >= C || NewGrid[nr][nc] == 0)continue;\\n                d.unite(i,nr*C + nc);\\n            }\\n\\t\\t\\t// It is the case when the removed brick is from the 0 th row \\n            if(r == 0)d.unite(i,R*C);\\n            ans[t] = max(0,d.getTopSize() - InitRoofAttached - 1);\\n            NewGrid[r][c] = 1;\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU{\\n    vector<int> par,rank;\\n    public:\\n    DSU(int n){\\n        par.resize(n,-1);\\n        rank.resize(n,1);\\n    }\\n    int find(int x){\\n\\t\\tif(par[x] == -1)return x;\\n\\t\\treturn par[x] = find(par[x]);\\n\\t}\\n\\n\\tvoid unite(int u,int v){\\n\\t\\tint x = find(u), y = find(v);\\n\\t\\tif(x == y)return;\\n       \\n\\t\\tif(rank[x] < rank[y])swap(x,y);\\n\\t\\t\\n        rank[x] += rank[y];\\n\\t\\tpar[y] = x;\\n\\t}\\n    int getSize(int x){\\n        return rank[find(x)];\\n    }\\n    \\n    int getTopSize(){\\n        return getSize(rank.size()-1) - 1;\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& OldGrid, vector<vector<int>>& hits) {\\n        int dx[4] = {1,0,-1,0};\\n        int dy[4] = {0,1,0,-1};\\n        int R = OldGrid.size(), C = OldGrid[0].size();\\n        vector<vector<int>> NewGrid(R,vector<int>(C,0));\\n        for(int i = 0; i <R; i++){\\n            NewGrid[i] = OldGrid[i];\\n        }\\n        \\n        DSU d(R*C + 1);\\n        \\n        for(auto hit:hits){\\n            NewGrid[hit[0]][hit[1]] = 0;\\n        }\\n        for(int i = 0; i < R; i++){\\n            for(int j = 0; j < C; j++){\\n                if(NewGrid[i][j] == 1){\\n                    int pos = i*C + j;\\n                    if(i == 0)d.unite(pos,R*C);\\n                    if(i >0 && NewGrid[i-1][j] == 1)d.unite(pos,(i-1)*C + j);\\n                    if(j > 0 && NewGrid[i][j-1] == 1)d.unite(pos,i*C + j-1);\\n                }\\n            }\\n        }\\n        int T = hits.size();\\n        vector<int> ans(T,0);\\n        for(int t = T - 1; t >= 0; t--){\\n       \\n            int r = hits[t][0], c = hits[t][1];\\n            if(OldGrid[r][c] == 0){\\n                continue;\\n            }\\n            int InitRoofAttached = d.getTopSize();\\n            int i = r*C + c;\\n            for(int k = 0; k < 4; k++){\\n                int nr = r + dx[k];\\n                int nc = c + dy[k];\\n                if(nr < 0 || nr >= R || nc <0 || nc >= C || NewGrid[nr][nc] == 0)continue;\\n                d.unite(i,nr*C + nc);\\n            }\\n\\t\\t\\t// It is the case when the removed brick is from the 0 th row \\n            if(r == 0)d.unite(i,R*C);\\n            ans[t] = max(0,d.getTopSize() - InitRoofAttached - 1);\\n            NewGrid[r][c] = 1;\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477942,
                "title": "simple-dfs-kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun Array<IntArray>.at(i: Int, j: Int) =\\n        if (i < 0) 1 else if (i >= this.size || j < 0 || j >= this.first().size) 0 else this[i][j]\\n\\n    fun hitBricks(grid: Array<IntArray>, hits: Array<IntArray>): IntArray {\\n        val n = grid.size\\n        val m = grid.first().size\\n        val original = Array(n) { IntArray(m) }\\n        for (i in 0 until n) {\\n            System.arraycopy(grid[i], 0, original[i], 0, m)\\n        }\\n        for ((i, j) in hits) {\\n            grid[i][j] = EMPTY\\n        }\\n\\n        fun markStable(i: Int, j: Int): Int {\\n            if (i < 0 || i >= n || j < 0 || j >= m || grid[i][j] != UNSTABLE) return 0\\n            grid[i][j] = STABLE\\n            return 1 + markStable(i + 1, j) +\\n                    markStable(i - 1, j) +\\n                    markStable(i, j + 1) +\\n                    markStable(i, j - 1)\\n        }\\n\\n        for (j in 0 until m) {\\n            markStable(0, j)\\n        }\\n\\n        fun hasStableNeighbors(i: Int, j: Int) = i == 0 ||\\n                grid.at(i + 1, j) == STABLE ||\\n                grid.at(i - 1, j) == STABLE ||\\n                grid.at(i, j + 1) == STABLE ||\\n                grid.at(i, j - 1) == STABLE\\n\\n        fun getUnstableNeighbors(i: Int, j: Int): List<Pair<Int, Int>> {\\n            val result = mutableListOf<Pair<Int, Int>>()\\n            if (grid.at(i + 1, j) == UNSTABLE) result.add(i + 1 to j)\\n            if (grid.at(i - 1, j) == UNSTABLE) result.add(i - 1 to j)\\n            if (grid.at(i, j + 1) == UNSTABLE) result.add(i to j + 1)\\n            if (grid.at(i, j - 1) == UNSTABLE) result.add(i to j - 1)\\n            return result\\n        }\\n\\n        val dropped = mutableListOf<Int>()\\n        for ((x, y) in hits.reversed()) {\\n            if (original[x][y] == UNSTABLE) {\\n                if (hasStableNeighbors(x, y)) {\\n                    grid[x][y] = STABLE\\n                    var currentDropped = 0\\n                    for ((i, j) in getUnstableNeighbors(x, y)) {\\n                        currentDropped += markStable(i, j)\\n                    }\\n                    dropped.add(currentDropped)\\n                } else {\\n                    grid[x][y] = UNSTABLE\\n                    dropped.add(0)\\n                }\\n            } else {\\n                dropped.add(0)\\n            }\\n        }\\n        return dropped.reversed().toIntArray()\\n    }\\n\\n    companion object {\\n        const val EMPTY = 0\\n        const val STABLE = 2\\n        const val UNSTABLE = 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun Array<IntArray>.at(i: Int, j: Int) =\\n        if (i < 0) 1 else if (i >= this.size || j < 0 || j >= this.first().size) 0 else this[i][j]\\n\\n    fun hitBricks(grid: Array<IntArray>, hits: Array<IntArray>): IntArray {\\n        val n = grid.size\\n        val m = grid.first().size\\n        val original = Array(n) { IntArray(m) }\\n        for (i in 0 until n) {\\n            System.arraycopy(grid[i], 0, original[i], 0, m)\\n        }\\n        for ((i, j) in hits) {\\n            grid[i][j] = EMPTY\\n        }\\n\\n        fun markStable(i: Int, j: Int): Int {\\n            if (i < 0 || i >= n || j < 0 || j >= m || grid[i][j] != UNSTABLE) return 0\\n            grid[i][j] = STABLE\\n            return 1 + markStable(i + 1, j) +\\n                    markStable(i - 1, j) +\\n                    markStable(i, j + 1) +\\n                    markStable(i, j - 1)\\n        }\\n\\n        for (j in 0 until m) {\\n            markStable(0, j)\\n        }\\n\\n        fun hasStableNeighbors(i: Int, j: Int) = i == 0 ||\\n                grid.at(i + 1, j) == STABLE ||\\n                grid.at(i - 1, j) == STABLE ||\\n                grid.at(i, j + 1) == STABLE ||\\n                grid.at(i, j - 1) == STABLE\\n\\n        fun getUnstableNeighbors(i: Int, j: Int): List<Pair<Int, Int>> {\\n            val result = mutableListOf<Pair<Int, Int>>()\\n            if (grid.at(i + 1, j) == UNSTABLE) result.add(i + 1 to j)\\n            if (grid.at(i - 1, j) == UNSTABLE) result.add(i - 1 to j)\\n            if (grid.at(i, j + 1) == UNSTABLE) result.add(i to j + 1)\\n            if (grid.at(i, j - 1) == UNSTABLE) result.add(i to j - 1)\\n            return result\\n        }\\n\\n        val dropped = mutableListOf<Int>()\\n        for ((x, y) in hits.reversed()) {\\n            if (original[x][y] == UNSTABLE) {\\n                if (hasStableNeighbors(x, y)) {\\n                    grid[x][y] = STABLE\\n                    var currentDropped = 0\\n                    for ((i, j) in getUnstableNeighbors(x, y)) {\\n                        currentDropped += markStable(i, j)\\n                    }\\n                    dropped.add(currentDropped)\\n                } else {\\n                    grid[x][y] = UNSTABLE\\n                    dropped.add(0)\\n                }\\n            } else {\\n                dropped.add(0)\\n            }\\n        }\\n        return dropped.reversed().toIntArray()\\n    }\\n\\n    companion object {\\n        const val EMPTY = 0\\n        const val STABLE = 2\\n        const val UNSTABLE = 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395020,
                "title": "time-o-mn-hits-log-mn-hits-o-mn-hits-log-mn-hits-space-o-mn-o-mn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind {\\n public:\\n  UnionFind(int n) : id(n), sz(n, 1) {\\n    iota(begin(id), end(id), 0);\\n  }\\n\\n  void unionBySize(int u, int v) {\\n    const int i = find(u);\\n    const int j = find(v);\\n    if (i == j)\\n      return;\\n    if (sz[i] < sz[j]) {\\n      sz[j] += sz[i];\\n      id[i] = j;\\n    } else {\\n      sz[i] += sz[j];\\n      id[j] = i;\\n    }\\n  }\\n\\n  int getStableSize() {\\n    //Bricks connected with 0 (top) are stable\\n    return sz[find(0)];\\n  }\\n\\n private:\\n  vector<int> id;\\n  vector<int> sz;\\n\\n  int find(int u) {\\n    return id[u] == u ? u : id[u] = find(id[u]);\\n  }\\n};\\n\\nclass Solution {\\n public:\\n  vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n    m = grid.size();\\n    n = grid[0].size();\\n\\n    UnionFind uf(m * n + 1);  // 0 := top (stable)\\n\\n    // Mark cells to hit as 2\\n    for (const vector<int>& hit : hits) {\\n      const int i = hit[0];\\n      const int j = hit[1];\\n      if (grid[i][j] == 1)\\n        grid[i][j] = 2;\\n    }\\n\\n    // Union all 1s\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j)\\n        if (grid[i][j] == 1)\\n          unionNeighbors(grid, uf, i, j);\\n\\n    vector<int> ans(hits.size());\\n    int stableSize = uf.getStableSize();\\n\\n    for (int i = hits.size() - 1; i >= 0; --i) {\\n      const int x = hits[i][0];\\n      const int y = hits[i][1];\\n      if (grid[x][y] == 2) {  //Cells marked from 1 to 2\\n        grid[x][y] = 1;       //Unhit, restore back to 1\\n        unionNeighbors(grid, uf, x, y);\\n        const int newStableSize = uf.getStableSize();\\n        if (newStableSize > stableSize)\\n          ans[i] = newStableSize - stableSize - 1;  //1 := the hit cell\\n        stableSize = newStableSize;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n\\n private:\\n  const vector<int> dirs{0, 1, 0, -1, 0};\\n  int m;\\n  int n;\\n\\n  void unionNeighbors(const vector<vector<int>>& grid, UnionFind& uf, int i,\\n                      int j) {\\n    const int hashed = hash(i, j);\\n\\n    for (int k = 0; k < 4; ++k) {\\n      const int x = i + dirs[k];\\n      const int y = j + dirs[k + 1];\\n      if (x < 0 || x == m || y < 0 || y == n)\\n        continue;\\n      if (grid[x][y] != 1)\\n        continue;\\n      uf.unionBySize(hashed, hash(x, y));\\n    }\\n\\n    if (i == 0)\\n      uf.unionBySize(hashed, 0);\\n  }\\n\\n  int hash(int i, int j) {\\n    return i * n + j + 1;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UnionFind {\\n public:\\n  UnionFind(int n) : id(n), sz(n, 1) {\\n    iota(begin(id), end(id), 0);\\n  }\\n\\n  void unionBySize(int u, int v) {\\n    const int i = find(u);\\n    const int j = find(v);\\n    if (i == j)\\n      return;\\n    if (sz[i] < sz[j]) {\\n      sz[j] += sz[i];\\n      id[i] = j;\\n    } else {\\n      sz[i] += sz[j];\\n      id[j] = i;\\n    }\\n  }\\n\\n  int getStableSize() {\\n    //Bricks connected with 0 (top) are stable\\n    return sz[find(0)];\\n  }\\n\\n private:\\n  vector<int> id;\\n  vector<int> sz;\\n\\n  int find(int u) {\\n    return id[u] == u ? u : id[u] = find(id[u]);\\n  }\\n};\\n\\nclass Solution {\\n public:\\n  vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n    m = grid.size();\\n    n = grid[0].size();\\n\\n    UnionFind uf(m * n + 1);  // 0 := top (stable)\\n\\n    // Mark cells to hit as 2\\n    for (const vector<int>& hit : hits) {\\n      const int i = hit[0];\\n      const int j = hit[1];\\n      if (grid[i][j] == 1)\\n        grid[i][j] = 2;\\n    }\\n\\n    // Union all 1s\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j)\\n        if (grid[i][j] == 1)\\n          unionNeighbors(grid, uf, i, j);\\n\\n    vector<int> ans(hits.size());\\n    int stableSize = uf.getStableSize();\\n\\n    for (int i = hits.size() - 1; i >= 0; --i) {\\n      const int x = hits[i][0];\\n      const int y = hits[i][1];\\n      if (grid[x][y] == 2) {  //Cells marked from 1 to 2\\n        grid[x][y] = 1;       //Unhit, restore back to 1\\n        unionNeighbors(grid, uf, x, y);\\n        const int newStableSize = uf.getStableSize();\\n        if (newStableSize > stableSize)\\n          ans[i] = newStableSize - stableSize - 1;  //1 := the hit cell\\n        stableSize = newStableSize;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n\\n private:\\n  const vector<int> dirs{0, 1, 0, -1, 0};\\n  int m;\\n  int n;\\n\\n  void unionNeighbors(const vector<vector<int>>& grid, UnionFind& uf, int i,\\n                      int j) {\\n    const int hashed = hash(i, j);\\n\\n    for (int k = 0; k < 4; ++k) {\\n      const int x = i + dirs[k];\\n      const int y = j + dirs[k + 1];\\n      if (x < 0 || x == m || y < 0 || y == n)\\n        continue;\\n      if (grid[x][y] != 1)\\n        continue;\\n      uf.unionBySize(hashed, hash(x, y));\\n    }\\n\\n    if (i == 0)\\n      uf.unionBySize(hashed, 0);\\n  }\\n\\n  int hash(int i, int j) {\\n    return i * n + j + 1;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130952,
                "title": "reverse-logic-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\"\"\"\\nIntuition:\\nHere we go in the reverse order: We add bricks instead of erasing\\n\\n1-> Remove the bricks which are to be erased from the grid.\\n2-> One by one add the bricks which are to be erased and then check if it is connected to \\n    the top or a component which is connected to the top.\\n    2a-> If yes then run a dfs from this point and whichever nodes are connected to this add them as\\n         potential ans.\\n    2b-> If no then it would not contribute any anything to the ans\\n\\nAt removal time of bricks at the start:\\nIf there is a brick at the given position: then make it 0 otherwise make it -1\\n\"\"\"\\n\\nclass Solution:\\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n\\n        # DFS to mark all connected nodes to top(Not Falling Bricks) at the beginning of the program\\n        # To count the number of bricks connected to a brick which is present in the hits\\n        def dfs(i, j):\\n            # Base Case -> Out Of Bounds or No Brick Exists \\n            if not (i >= 0 and i < m and j >= 0 and j < n) or grid[i][j] != 1:\\n                return 0\\n            \\n            ret = 1\\n            grid[i][j] = 2 # 2 means that this is connected to the top part\\n\\n            # Calling dfs in the four directions\\n            ret += sum(dfs(x,y) for x,y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)])\\n            return ret\\n\\n        # To check if a brick present in hits is connected to the top not falling bricks\\n        def isConnected(i, j):\\n            # To be connected to the top the adjacent grid values four diretionally must have atleast a 2 \\n            # Top connected bricks are marked 2\\n            return i == 0 or any([0<=x<m and 0<=y<n and grid[x][y]==2 for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]])\\n\\n\\n        # At each hit mark if there is a brick present there or not\\n        for i, j in hits:\\n            grid[i][j] -= 1\\n\\n        # Now we run a dfs from every cell of the first row and mark cells which are connected to top\\n        for i in range(n):\\n            dfs(0, i)\\n\\n        # Add the hits in reverse order and store ans for every hit\\n        res = [0]*len(hits)\\n        for k in range(len(hits)-1, -1, -1):\\n            i, j = hits[k]\\n\\n            # Add this brick now -> Make it +1 -> If already this hit place stored -1 then we would\\n            # Not process it as it does not have any brick at any point in time but if it had a brick\\n            # then we would have store 0 at that place which now would have become 1 so process it\\n            # By process I mean -> If this cell is connected to the Top -> (Not Falling Bricks)\\n            # find no. of cells connected to it by running a dfs around it\\n\\n            grid[i][j] += 1\\n\\n            if grid[i][j] == 1 and isConnected(i, j):\\n                res[k] = dfs(i, j) - 1\\n        \\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Union Find",
                    "Matrix"
                ],
                "code": "```\\n\"\"\"\\nIntuition:\\nHere we go in the reverse order: We add bricks instead of erasing\\n\\n1-> Remove the bricks which are to be erased from the grid.\\n2-> One by one add the bricks which are to be erased and then check if it is connected to \\n    the top or a component which is connected to the top.\\n    2a-> If yes then run a dfs from this point and whichever nodes are connected to this add them as\\n         potential ans.\\n    2b-> If no then it would not contribute any anything to the ans\\n\\nAt removal time of bricks at the start:\\nIf there is a brick at the given position: then make it 0 otherwise make it -1\\n\"\"\"\\n\\nclass Solution:\\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n\\n        # DFS to mark all connected nodes to top(Not Falling Bricks) at the beginning of the program\\n        # To count the number of bricks connected to a brick which is present in the hits\\n        def dfs(i, j):\\n            # Base Case -> Out Of Bounds or No Brick Exists \\n            if not (i >= 0 and i < m and j >= 0 and j < n) or grid[i][j] != 1:\\n                return 0\\n            \\n            ret = 1\\n            grid[i][j] = 2 # 2 means that this is connected to the top part\\n\\n            # Calling dfs in the four directions\\n            ret += sum(dfs(x,y) for x,y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)])\\n            return ret\\n\\n        # To check if a brick present in hits is connected to the top not falling bricks\\n        def isConnected(i, j):\\n            # To be connected to the top the adjacent grid values four diretionally must have atleast a 2 \\n            # Top connected bricks are marked 2\\n            return i == 0 or any([0<=x<m and 0<=y<n and grid[x][y]==2 for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]])\\n\\n\\n        # At each hit mark if there is a brick present there or not\\n        for i, j in hits:\\n            grid[i][j] -= 1\\n\\n        # Now we run a dfs from every cell of the first row and mark cells which are connected to top\\n        for i in range(n):\\n            dfs(0, i)\\n\\n        # Add the hits in reverse order and store ans for every hit\\n        res = [0]*len(hits)\\n        for k in range(len(hits)-1, -1, -1):\\n            i, j = hits[k]\\n\\n            # Add this brick now -> Make it +1 -> If already this hit place stored -1 then we would\\n            # Not process it as it does not have any brick at any point in time but if it had a brick\\n            # then we would have store 0 at that place which now would have become 1 so process it\\n            # By process I mean -> If this cell is connected to the Top -> (Not Falling Bricks)\\n            # find no. of cells connected to it by running a dfs around it\\n\\n            grid[i][j] += 1\\n\\n            if grid[i][j] == 1 and isConnected(i, j):\\n                res[k] = dfs(i, j) - 1\\n        \\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920476,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn hit_bricks(grid: Vec<Vec<i32>>, hits: Vec<Vec<i32>>) -> Vec<i32> {\\n        fn find_parents(parents: &mut Vec<usize>, i: usize) -> usize {\\n            if parents[i] != i {\\n                parents[i] = find_parents(parents, parents[i]);\\n            }\\n            parents[i]\\n        }\\n\\n        fn union2(parents: &mut Vec<usize>, _size: &mut [usize], i: usize, j: usize) {\\n            let mut pi = find_parents(parents, i);\\n            let mut pj = find_parents(parents, j);\\n            if pi != pj {\\n                if pi > pj {\\n                    std::mem::swap(&mut pi, &mut pj);\\n                }\\n                _size[pi] += _size[pj];\\n                parents[pj] = pi;\\n            }\\n        }\\n\\n        let mut grid = grid;\\n        let m = grid.len();\\n        let n = grid[0].len();\\n        let mut parents = vec![0; m * n];\\n        let mut _size = vec![1; m * n];\\n        let mut ret = vec![0; hits.len()];\\n        let dirs = vec![vec![0, 1], vec![0, -1], vec![-1, 0], vec![1, 0]];\\n        let c21 = |i: usize, j: usize| -> usize { i * n + j };\\n        for h in hits.iter() {\\n            grid[h[0] as usize][h[1] as usize] -= 1;\\n        }\\n        for (i, item) in parents.iter_mut().enumerate() {\\n            *item = i;\\n        }\\n        for i in 0..m {\\n            for j in 0..n {\\n                if grid[i][j] > 0 {\\n                    for item in dirs.iter().take(4) {\\n                        let x = i as i32 + item[0];\\n                        let y = j as i32 + item[1];\\n                        if x > -1 && x < m as i32 && y > -1 && y < n as i32 && grid[x as usize][y as usize] > 0 {\\n                            union2(&mut parents, &mut _size, c21(i, j), c21(x as usize, y as usize));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for i in (0..hits.len()).rev() {\\n            let point = &mut grid[hits[i][0] as usize][hits[i][1] as usize];\\n            *point += 1;\\n            if *point > 0 {\\n                let _i = hits[i][0] as usize;\\n                let _j = hits[i][1] as usize;\\n                let mut flag = usize::from(_i == 0);\\n                for item in dirs.iter().take(4) {\\n                    let x = _i as i32 + item[0];\\n                    let y = _j as i32 + item[1];\\n                    if x > -1 && x < m as i32 && y > -1 && y < n as i32 && grid[x as usize][y as usize] > 0 {\\n                        if find_parents(&mut parents, c21(x as usize, y as usize)) < n {\\n                            flag = 1;\\n                        } else if find_parents(&mut parents, c21(x as usize, y as usize))\\n                            != find_parents(&mut parents, c21(_i, _j))\\n                        {\\n                            ret[i] += _size[find_parents(&mut parents, c21(x as usize, y as usize))];\\n                        }\\n                        union2(&mut parents, &mut _size, c21(x as usize, y as usize), c21(_i, _j));\\n                    }\\n                }\\n                ret[i] *= flag;\\n            }\\n        }\\n        ret.iter().map(|x| *x as i32).collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn hit_bricks(grid: Vec<Vec<i32>>, hits: Vec<Vec<i32>>) -> Vec<i32> {\\n        fn find_parents(parents: &mut Vec<usize>, i: usize) -> usize {\\n            if parents[i] != i {\\n                parents[i] = find_parents(parents, parents[i]);\\n            }\\n            parents[i]\\n        }\\n\\n        fn union2(parents: &mut Vec<usize>, _size: &mut [usize], i: usize, j: usize) {\\n            let mut pi = find_parents(parents, i);\\n            let mut pj = find_parents(parents, j);\\n            if pi != pj {\\n                if pi > pj {\\n                    std::mem::swap(&mut pi, &mut pj);\\n                }\\n                _size[pi] += _size[pj];\\n                parents[pj] = pi;\\n            }\\n        }\\n\\n        let mut grid = grid;\\n        let m = grid.len();\\n        let n = grid[0].len();\\n        let mut parents = vec![0; m * n];\\n        let mut _size = vec![1; m * n];\\n        let mut ret = vec![0; hits.len()];\\n        let dirs = vec![vec![0, 1], vec![0, -1], vec![-1, 0], vec![1, 0]];\\n        let c21 = |i: usize, j: usize| -> usize { i * n + j };\\n        for h in hits.iter() {\\n            grid[h[0] as usize][h[1] as usize] -= 1;\\n        }\\n        for (i, item) in parents.iter_mut().enumerate() {\\n            *item = i;\\n        }\\n        for i in 0..m {\\n            for j in 0..n {\\n                if grid[i][j] > 0 {\\n                    for item in dirs.iter().take(4) {\\n                        let x = i as i32 + item[0];\\n                        let y = j as i32 + item[1];\\n                        if x > -1 && x < m as i32 && y > -1 && y < n as i32 && grid[x as usize][y as usize] > 0 {\\n                            union2(&mut parents, &mut _size, c21(i, j), c21(x as usize, y as usize));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for i in (0..hits.len()).rev() {\\n            let point = &mut grid[hits[i][0] as usize][hits[i][1] as usize];\\n            *point += 1;\\n            if *point > 0 {\\n                let _i = hits[i][0] as usize;\\n                let _j = hits[i][1] as usize;\\n                let mut flag = usize::from(_i == 0);\\n                for item in dirs.iter().take(4) {\\n                    let x = _i as i32 + item[0];\\n                    let y = _j as i32 + item[1];\\n                    if x > -1 && x < m as i32 && y > -1 && y < n as i32 && grid[x as usize][y as usize] > 0 {\\n                        if find_parents(&mut parents, c21(x as usize, y as usize)) < n {\\n                            flag = 1;\\n                        } else if find_parents(&mut parents, c21(x as usize, y as usize))\\n                            != find_parents(&mut parents, c21(_i, _j))\\n                        {\\n                            ret[i] += _size[find_parents(&mut parents, c21(x as usize, y as usize))];\\n                        }\\n                        union2(&mut parents, &mut _size, c21(x as usize, y as usize), c21(_i, _j));\\n                    }\\n                }\\n                ret[i] *= flag;\\n            }\\n        }\\n        ret.iter().map(|x| *x as i32).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2599151,
                "title": "union-set-solution-c",
                "content": "```c++\\nclass Solution {\\npublic:\\n    /*\\n        grid can be abstracted as a graph\\n        \\n        every time we delete a node and check the connection of the graph ==> which ds?\\n        \\n        change the logic: delete all the node in hits first and then add node from the last one in turn to see\\n        the connected subgraphs ==> union set\\n        \\n        note: two tricks\\n            - change 2d (x, y) to 1d (a) by a = x * m + y \\n            - use sz array to track the size of each subgraph\\n    */\\n    int n, m;\\n    vector<int> p, sz;\\n\\n    int find(int x) {\\n        if (p[x] != x) p[x] = find(p[x]);\\n        return p[x];\\n    }\\n\\n    int get(int x, int y) {\\n        return x * m + y;\\n    }\\n\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        n = grid.size(), m = grid[0].size();\\n        int S = n * m;\\n        for (int i = 0; i <= S; i ++ ) p.push_back(i), sz.push_back(1);\\n\\n        vector<bool> st;\\n        for (auto& p: hits) {\\n            int x = p[0], y = p[1];\\n            if (grid[x][y]) {\\n                grid[x][y] = 0;\\n                st.push_back(true);\\n            } else {\\n                st.push_back(false);\\n            }\\n        }\\n\\n        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\\n        for (int i = 0; i < n; i ++ )\\n            for (int j = 0; j < m; j ++ )\\n                if (grid[i][j]) {\\n                    int a = get(i, j);\\n                    if (!i) {\\n                        if (find(S) != find(a)) {\\n                            sz[find(S)] += sz[find(a)];\\n                            p[find(a)] = find(S);\\n                        }\\n                    }\\n                    for (int k = 0; k < 4; k ++ ) {\\n                        int x = i + dx[k], y = j + dy[k];\\n                        if (x >= 0 && x < n && y >= 0 && y < m && grid[x][y]) {\\n                            int b = get(x, y);\\n                            if (find(a) != find(b)) {\\n                                sz[find(b)] += sz[find(a)];\\n                                p[find(a)] = find(b);\\n                            }\\n                        }\\n                    }\\n                }\\n\\n        vector<int> res(hits.size());\\n        int last = sz[find(S)];\\n        for (int i = hits.size() - 1; i >= 0; i -- )\\n            if (st[i]) {\\n                int x = hits[i][0], y = hits[i][1];\\n                grid[x][y] = 1;\\n                int a = get(x, y);\\n                if (!x) {\\n                    if (find(S) != find(a)) {\\n                        sz[find(S)] += sz[find(a)];\\n                        p[find(a)] = find(S);\\n                    }\\n                }\\n                for (int j = 0; j < 4; j ++ ) {\\n                    int c = x + dx[j], d = y + dy[j];\\n                    if (c >= 0 && c < n && d >= 0 && d < m && grid[c][d]) {\\n                        int b = get(c, d);\\n                        if (find(a) != find(b)) {\\n                            sz[find(b)] += sz[find(a)];\\n                            p[find(a)] = find(b);\\n                        }\\n                    }\\n                }\\n\\n                res[i] = max(0, sz[find(S)] - last - 1);\\n                last = sz[find(S)];\\n            }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    /*\\n        grid can be abstracted as a graph\\n        \\n        every time we delete a node and check the connection of the graph ==> which ds?\\n        \\n        change the logic: delete all the node in hits first and then add node from the last one in turn to see\\n        the connected subgraphs ==> union set\\n        \\n        note: two tricks\\n            - change 2d (x, y) to 1d (a) by a = x * m + y \\n            - use sz array to track the size of each subgraph\\n    */\\n    int n, m;\\n    vector<int> p, sz;\\n\\n    int find(int x) {\\n        if (p[x] != x) p[x] = find(p[x]);\\n        return p[x];\\n    }\\n\\n    int get(int x, int y) {\\n        return x * m + y;\\n    }\\n\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        n = grid.size(), m = grid[0].size();\\n        int S = n * m;\\n        for (int i = 0; i <= S; i ++ ) p.push_back(i), sz.push_back(1);\\n\\n        vector<bool> st;\\n        for (auto& p: hits) {\\n            int x = p[0], y = p[1];\\n            if (grid[x][y]) {\\n                grid[x][y] = 0;\\n                st.push_back(true);\\n            } else {\\n                st.push_back(false);\\n            }\\n        }\\n\\n        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\\n        for (int i = 0; i < n; i ++ )\\n            for (int j = 0; j < m; j ++ )\\n                if (grid[i][j]) {\\n                    int a = get(i, j);\\n                    if (!i) {\\n                        if (find(S) != find(a)) {\\n                            sz[find(S)] += sz[find(a)];\\n                            p[find(a)] = find(S);\\n                        }\\n                    }\\n                    for (int k = 0; k < 4; k ++ ) {\\n                        int x = i + dx[k], y = j + dy[k];\\n                        if (x >= 0 && x < n && y >= 0 && y < m && grid[x][y]) {\\n                            int b = get(x, y);\\n                            if (find(a) != find(b)) {\\n                                sz[find(b)] += sz[find(a)];\\n                                p[find(a)] = find(b);\\n                            }\\n                        }\\n                    }\\n                }\\n\\n        vector<int> res(hits.size());\\n        int last = sz[find(S)];\\n        for (int i = hits.size() - 1; i >= 0; i -- )\\n            if (st[i]) {\\n                int x = hits[i][0], y = hits[i][1];\\n                grid[x][y] = 1;\\n                int a = get(x, y);\\n                if (!x) {\\n                    if (find(S) != find(a)) {\\n                        sz[find(S)] += sz[find(a)];\\n                        p[find(a)] = find(S);\\n                    }\\n                }\\n                for (int j = 0; j < 4; j ++ ) {\\n                    int c = x + dx[j], d = y + dy[j];\\n                    if (c >= 0 && c < n && d >= 0 && d < m && grid[c][d]) {\\n                        int b = get(c, d);\\n                        if (find(a) != find(b)) {\\n                            sz[find(b)] += sz[find(a)];\\n                            p[find(a)] = find(b);\\n                        }\\n                    }\\n                }\\n\\n                res[i] = max(0, sz[find(S)] - last - 1);\\n                last = sz[find(S)];\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556629,
                "title": "brute-force-java",
                "content": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n     \\n        int res [] = new int [hits.length];\\n        for(int i = 0  ;i  < hits.length ; i++){\\n            int  x = hits[i][0];\\n            int  y = hits[i][1];\\n            grid[x][y]  = 0;   \\n            bricksFall(grid);\\n            res[i] = unStabelBricks(grid);//countOne\\n            fallUnStabelBricks(grid);   \\n        }\\n        \\n        return  res;\\n    \\n    }\\n    \\n    public  static void fallUnStabelBricks(int  [][] grid){\\n          for(int  i = 0; i < grid.length ; i++){\\n            for(int  j = 0 ; j < grid[0].length; j++){\\n                if(grid[i][j]== 2){\\n                    grid[i][j] =1;\\n                }else if(grid[i][j]== 1){\\n                    grid[i][j] =0 ;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public  static void bricksFall(int  [][] grid){\\n          for(int  i = 0; i < grid[0].length ; i++){ \\n             if(grid[0][i] == 1){\\n                 stableBricksUpdate(grid, 0, i);\\n             } \\n          }\\n        \\n    }\\n    \\n    public  static void stableBricksUpdate(int  [][] grid, int  i , int  j  ){\\n        if(i >= 0 &&  i< grid.length && j >= 0 && j < grid[0].length && grid[i][j] == 1 ){\\n             grid[i][j] =2; \\n             stableBricksUpdate(grid, i+1,j);\\n             stableBricksUpdate(grid, i-1,j);\\n             stableBricksUpdate(grid, i,j+1);\\n             stableBricksUpdate(grid, i,j-1);\\n        }\\n    }\\n    \\n    public  static int unStabelBricks(int  [][] grid){\\n        int  count1= 0;\\n        for(int  i = 0; i < grid.length ; i++){\\n            for(int  j = 0 ; j < grid[0].length; j++){\\n                if(grid[i][j]== 1){\\n                    count1++;\\n                }\\n            }\\n        }\\n        return  count1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n     \\n        int res [] = new int [hits.length];\\n        for(int i = 0  ;i  < hits.length ; i++){\\n            int  x = hits[i][0];\\n            int  y = hits[i][1];\\n            grid[x][y]  = 0;   \\n            bricksFall(grid);\\n            res[i] = unStabelBricks(grid);//countOne\\n            fallUnStabelBricks(grid);   \\n        }\\n        \\n        return  res;\\n    \\n    }\\n    \\n    public  static void fallUnStabelBricks(int  [][] grid){\\n          for(int  i = 0; i < grid.length ; i++){\\n            for(int  j = 0 ; j < grid[0].length; j++){\\n                if(grid[i][j]== 2){\\n                    grid[i][j] =1;\\n                }else if(grid[i][j]== 1){\\n                    grid[i][j] =0 ;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public  static void bricksFall(int  [][] grid){\\n          for(int  i = 0; i < grid[0].length ; i++){ \\n             if(grid[0][i] == 1){\\n                 stableBricksUpdate(grid, 0, i);\\n             } \\n          }\\n        \\n    }\\n    \\n    public  static void stableBricksUpdate(int  [][] grid, int  i , int  j  ){\\n        if(i >= 0 &&  i< grid.length && j >= 0 && j < grid[0].length && grid[i][j] == 1 ){\\n             grid[i][j] =2; \\n             stableBricksUpdate(grid, i+1,j);\\n             stableBricksUpdate(grid, i-1,j);\\n             stableBricksUpdate(grid, i,j+1);\\n             stableBricksUpdate(grid, i,j-1);\\n        }\\n    }\\n    \\n    public  static int unStabelBricks(int  [][] grid){\\n        int  count1= 0;\\n        for(int  i = 0; i < grid.length ; i++){\\n            for(int  j = 0 ; j < grid[0].length; j++){\\n                if(grid[i][j]== 1){\\n                    count1++;\\n                }\\n            }\\n        }\\n        return  count1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513695,
                "title": "help-please-unable-to-figure-out-the-mistake",
                "content": "class Solution {\\npublic:\\n    int n, m , q;\\n    vector<int> par, sz;\\n    \\n    bool isValid(int x, int y) { return x>=0 && x < n && y>=0 && y < m;}\\n    int find_par(int x) {\\n        while (x!= par[x]) x = par[par[x]];\\n        return x;\\n    }\\n    void unin(int x, int y) {\\n        if (x== n*m || sz[x] > sz[y]) {par[y] = x; sz[x] += sz[y];}\\n        else {par[x] = y; sz[y] += sz[x];}\\n    }\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        n = grid.size(); m = grid[0].size(); q = hits.size();\\n\\n        vector<vector<bool>> a(n+5,vector<bool> (m+5,false));\\n        \\n        \\n        for (int i = 0; i <= n*m+2;i++) {\\n            sz.push_back(1);\\n            par.push_back(i);\\n        }\\n        for (int i = 0; i <hits.size();i++) a[hits[i][0]][hits[i][1]] = 1;\\n      \\n        int x[4] = {-1,0, 0,1}, y[4] = {0,-1,1,0};\\n        for (int i = 0;i < n; i++) {\\n            for (int j = 0; j < m;j++) {\\n\\n                if (grid[i][j] == 0 || a[i][j]) continue;\\n                if (i==0 ) unin(n*m,i*m+j);\\n                for (int k = 0; k < 2; k++) {\\n                    if (!isValid(i+x[k] , j+y[k]) )  continue;\\n                    if (grid[i+x[k]][j+y[k]] == 1 && a[i+x[k]][j+y[k]] == 0) {\\n                    int par1 = find_par(i*m+j);\\n                    int par2 = find_par((i+x[k])*m + (j+y[k]));\\n                    unin( par1, par2);\\n                    }\\n                    // cout << i << \" \" << j << \" \" << i+x[k] << \" \" << j +y[k] << endl; }\\n                }\\n            }\\n        }\\n                    // for (auto x: par ) cout << x << \" \";\\n                    // cout << endl;\\n                    // for (auto x: sz) cout << x << \" \";\\n                    // cout << endl;        \\n        vector<int> ans;\\n        int prev_max;\\n        for (int i = q - 1; i >=0 ; i--) {\\n            int x1 = hits[i][0] , y1 = hits[i][1];\\n            prev_max = sz[n*m];\\n            if (grid[x1][y1] == 0) {ans.push_back(0);continue;}\\n            if (x1 == 0) unin(n*m, y1);\\n            \\n            for (int k = 0; k < 4; k++) {\\n                int x2 = x1+x[k], y2 = y1+y[k];\\n                if (isValid(x2,y2) && a[x2][y2] == 0 &&grid[x2][y2]) {\\n                    int par1 = find_par(x1*m + y1);\\n                    int par2 = find_par(x2*m+y2);\\n                    if (par1 == par2) continue;\\n                    unin(par1, par2);\\n                    // cout << x1 << \" \" << y1 << endl;\\n\\n                }\\n            }\\n            a[x1][y1] = 0;\\n            ans.push_back(max(0, sz[n*m] - prev_max - 1));\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n\\nUnable to fingure out the mistake even after thinking 1 -2 hours.",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int n, m , q;\\n    vector<int> par, sz;\\n    \\n    bool isValid(int x, int y) { return x>=0 && x < n && y>=0 && y < m;}",
                "codeTag": "Java"
            },
            {
                "id": 2497401,
                "title": "ruby-solution",
                "content": "```ruby\\n# @param {Integer[][]} grid\\n# @param {Integer[][]} hits\\n# @return {Integer[]}\\ndef hit_bricks(grid, hits)\\n  hits.each do |(row, col)|\\n    grid[row][col] = :hit if grid[row][col] == 1 \\n  end \\n  \\n  hits.reverse!\\n  \\n  grid.first.each_with_index do |item, col|\\n    check_coordinates(grid, 0, col)\\n  end\\n  \\n  result = []\\n\\n  hits.each do |row, col|\\n    result << 0\\n\\n    next if grid[row][col] == 0\\n\\n    update = false\\n    if grid[row][col] == :hit\\n      if (row > 0 && grid[row - 1][col] == :strong) ||\\n        (row < grid.size - 1 && grid[row + 1][col] == :strong) ||\\n        (col > 0 && grid[row][col - 1] == :strong) ||\\n        (col < grid.first.size - 1 && grid[row][col + 1] == :strong) ||\\n        row == 0\\n        update = true\\n      else\\n        grid[row][col] = 1\\n        next\\n      end\\n      \\n    end\\n    \\n    grid[row][col] = 1\\n    \\n    count_coordinates(grid, row, col, result)\\n    \\n    result[-1] -= 1\\n\\n    if row == 0 || update == true\\n      check_coordinates(grid, row, col)\\n    end\\n    \\n\\n  end\\n\\n  result.reverse\\n\\nend\\n\\ndef count_coordinates(grid, row, col, result)\\n\\n  return unless grid[row][col] == 1\\n  \\n  result[-1] += 1\\n  grid[row][col] = :checked\\n\\n  if row > 0\\n    count_coordinates(grid, row - 1, col, result)\\n  end\\n  \\n  if row < grid.size - 1\\n    count_coordinates(grid, row + 1, col, result)\\n  end\\n  \\n  if col > 0\\n    count_coordinates(grid, row, col - 1 , result)\\n  end\\n  \\n  if col < grid.first.size - 1\\n    count_coordinates(grid, row, col + 1 , result)\\n  end\\n  \\nend\\n\\n\\ndef check_coordinates(grid, row, col)\\n  return unless grid[row][col] == 1 || grid[row][col] == :checked\\n\\n  grid[row][col] = :strong\\n  \\n  if row > 0\\n    check_coordinates(grid, row - 1, col)\\n  end\\n  \\n  if row < grid.size - 1\\n    check_coordinates(grid, row + 1, col)\\n  end\\n  \\n  if col > 0\\n    check_coordinates(grid, row, col - 1 )\\n  end\\n  \\n  if col < grid.first.size - 1\\n    check_coordinates(grid, row, col + 1 )\\n  end\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer[][]} grid\\n# @param {Integer[][]} hits\\n# @return {Integer[]}\\ndef hit_bricks(grid, hits)\\n  hits.each do |(row, col)|\\n    grid[row][col] = :hit if grid[row][col] == 1 \\n  end \\n  \\n  hits.reverse!\\n  \\n  grid.first.each_with_index do |item, col|\\n    check_coordinates(grid, 0, col)\\n  end\\n  \\n  result = []\\n\\n  hits.each do |row, col|\\n    result << 0\\n\\n    next if grid[row][col] == 0\\n\\n    update = false\\n    if grid[row][col] == :hit\\n      if (row > 0 && grid[row - 1][col] == :strong) ||\\n        (row < grid.size - 1 && grid[row + 1][col] == :strong) ||\\n        (col > 0 && grid[row][col - 1] == :strong) ||\\n        (col < grid.first.size - 1 && grid[row][col + 1] == :strong) ||\\n        row == 0\\n        update = true\\n      else\\n        grid[row][col] = 1\\n        next\\n      end\\n      \\n    end\\n    \\n    grid[row][col] = 1\\n    \\n    count_coordinates(grid, row, col, result)\\n    \\n    result[-1] -= 1\\n\\n    if row == 0 || update == true\\n      check_coordinates(grid, row, col)\\n    end\\n    \\n\\n  end\\n\\n  result.reverse\\n\\nend\\n\\ndef count_coordinates(grid, row, col, result)\\n\\n  return unless grid[row][col] == 1\\n  \\n  result[-1] += 1\\n  grid[row][col] = :checked\\n\\n  if row > 0\\n    count_coordinates(grid, row - 1, col, result)\\n  end\\n  \\n  if row < grid.size - 1\\n    count_coordinates(grid, row + 1, col, result)\\n  end\\n  \\n  if col > 0\\n    count_coordinates(grid, row, col - 1 , result)\\n  end\\n  \\n  if col < grid.first.size - 1\\n    count_coordinates(grid, row, col + 1 , result)\\n  end\\n  \\nend\\n\\n\\ndef check_coordinates(grid, row, col)\\n  return unless grid[row][col] == 1 || grid[row][col] == :checked\\n\\n  grid[row][col] = :strong\\n  \\n  if row > 0\\n    check_coordinates(grid, row - 1, col)\\n  end\\n  \\n  if row < grid.size - 1\\n    check_coordinates(grid, row + 1, col)\\n  end\\n  \\n  if col > 0\\n    check_coordinates(grid, row, col - 1 )\\n  end\\n  \\n  if col < grid.first.size - 1\\n    check_coordinates(grid, row, col + 1 )\\n  end\\n\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2388062,
                "title": "c-bfs-solution-beats-69-86",
                "content": "```\\nclass Solution {\\npublic:\\n\\t// Helper function to determine if the passed node is connected to the top of the matrix\\n    bool isConnected(vector<vector<bool>>& vis, int& i, int& j){\\n        if(i==0)\\n            return true;\\n        \\n        if(i>0 && vis[i-1][j])\\n            return true;\\n        if(j>0 && vis[i][j-1])\\n            return true;\\n        if(i<vis.size()-1 && vis[i+1][j])\\n            return true;\\n        if(j<vis[0].size()-1 && vis[i][j+1])\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        vector<int> ans(hits.size(), 0);\\n        \\n\\t\\t//Remove all the bricks which are hit during entire process\\n        vector<vector<int>> mat = grid;\\n        for(int i=0; i<hits.size(); i++)\\n            mat[hits[i][0]][hits[i][1]] = 0;\\n        \\n\\t\\t//Do BFS to determine connected nodes (to top of matrix) and mark them as visited\\n        vector<vector<bool>> vis(grid.size(), vector<bool> (grid[0].size(), false));\\n        queue<pair<int, int>> q;\\n        for(int i=0; i<grid[0].size(); i++){\\n            if(mat[0][i]==1){\\n                vis[0][i] = true;\\n                q.push({0, i});\\n            }\\n        }\\n        while(!q.empty()){\\n            int idx = q.front().first, jdx = q.front().second;\\n            q.pop();\\n            \\n            if(idx>0 && mat[idx-1][jdx]==1){\\n                if(!vis[idx-1][jdx])\\n                    q.push({idx-1, jdx});\\n                vis[idx-1][jdx]=true;\\n            }\\n            if(jdx>0 && mat[idx][jdx-1]==1){\\n                if(!vis[idx][jdx-1])\\n                    q.push({idx, jdx-1});\\n                vis[idx][jdx-1]=true;\\n            }\\n            if(idx<grid.size()-1 && mat[idx+1][jdx]==1){\\n                if(!vis[idx+1][jdx])\\n                    q.push({idx+1, jdx});\\n                vis[idx+1][jdx]=true;\\n            }\\n            if(jdx<grid[0].size()-1 && mat[idx][jdx+1]==1){\\n                if(!vis[idx][jdx+1])\\n                    q.push({idx, jdx+1});\\n                vis[idx][jdx+1]=true;\\n            }\\n        }\\n        \\n        //Traverse the hits array in reverse order to one by one add a brick \\n        for(int i=hits.size()-1; i>=0; i--){\\n\\t\\t\\t//If no brick was present in original grid matrix, continue, otherwise \\n\\t\\t\\t//add brick to that position\\n            if(grid[hits[i][0]][hits[i][1]]==0)\\n                continue;\\n            mat[hits[i][0]][hits[i][1]] = 1;\\n            \\n\\t\\t\\t//If this brick not connected to top of matrix, ans=0 and continue\\n            if(!isConnected(vis, hits[i][0], hits[i][1]))\\n                continue;\\n            \\n\\t\\t\\t//This brick connects between visited nodes and not visited nodes, do BFS\\n\\t\\t\\t//to make all reachable nodes visited and count them\\n            q.push({hits[i][0], hits[i][1]});\\n            vis[hits[i][0]][hits[i][1]] = true;\\n            int cnt=0;\\n            while(!q.empty()){\\n                int idx = q.front().first, jdx = q.front().second;\\n                q.pop();\\n                cnt++;\\n                if(idx>0 && mat[idx-1][jdx]==1 && !vis[idx-1][jdx]){\\n                    q.push({idx-1, jdx});\\n                    vis[idx-1][jdx]=true;\\n                }\\n                if(jdx>0 && mat[idx][jdx-1]==1 && !vis[idx][jdx-1]){\\n                    q.push({idx, jdx-1});\\n                    vis[idx][jdx-1]=true;\\n                }\\n                if(idx<grid.size()-1 && mat[idx+1][jdx]==1 && !vis[idx+1][jdx]){\\n                    q.push({idx+1, jdx});\\n                    vis[idx+1][jdx]=true;\\n                }\\n                if(jdx<grid[0].size()-1 && mat[idx][jdx+1]==1 && !vis[idx][jdx+1]){\\n                    q.push({idx, jdx+1});\\n                    vis[idx][jdx+1]=true;\\n                }\\n            }\\n            ans[i] = cnt-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// Helper function to determine if the passed node is connected to the top of the matrix\\n    bool isConnected(vector<vector<bool>>& vis, int& i, int& j){\\n        if(i==0)\\n            return true;\\n        \\n        if(i>0 && vis[i-1][j])\\n            return true;\\n        if(j>0 && vis[i][j-1])\\n            return true;\\n        if(i<vis.size()-1 && vis[i+1][j])\\n            return true;\\n        if(j<vis[0].size()-1 && vis[i][j+1])\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        vector<int> ans(hits.size(), 0);\\n        \\n\\t\\t//Remove all the bricks which are hit during entire process\\n        vector<vector<int>> mat = grid;\\n        for(int i=0; i<hits.size(); i++)\\n            mat[hits[i][0]][hits[i][1]] = 0;\\n        \\n\\t\\t//Do BFS to determine connected nodes (to top of matrix) and mark them as visited\\n        vector<vector<bool>> vis(grid.size(), vector<bool> (grid[0].size(), false));\\n        queue<pair<int, int>> q;\\n        for(int i=0; i<grid[0].size(); i++){\\n            if(mat[0][i]==1){\\n                vis[0][i] = true;\\n                q.push({0, i});\\n            }\\n        }\\n        while(!q.empty()){\\n            int idx = q.front().first, jdx = q.front().second;\\n            q.pop();\\n            \\n            if(idx>0 && mat[idx-1][jdx]==1){\\n                if(!vis[idx-1][jdx])\\n                    q.push({idx-1, jdx});\\n                vis[idx-1][jdx]=true;\\n            }\\n            if(jdx>0 && mat[idx][jdx-1]==1){\\n                if(!vis[idx][jdx-1])\\n                    q.push({idx, jdx-1});\\n                vis[idx][jdx-1]=true;\\n            }\\n            if(idx<grid.size()-1 && mat[idx+1][jdx]==1){\\n                if(!vis[idx+1][jdx])\\n                    q.push({idx+1, jdx});\\n                vis[idx+1][jdx]=true;\\n            }\\n            if(jdx<grid[0].size()-1 && mat[idx][jdx+1]==1){\\n                if(!vis[idx][jdx+1])\\n                    q.push({idx, jdx+1});\\n                vis[idx][jdx+1]=true;\\n            }\\n        }\\n        \\n        //Traverse the hits array in reverse order to one by one add a brick \\n        for(int i=hits.size()-1; i>=0; i--){\\n\\t\\t\\t//If no brick was present in original grid matrix, continue, otherwise \\n\\t\\t\\t//add brick to that position\\n            if(grid[hits[i][0]][hits[i][1]]==0)\\n                continue;\\n            mat[hits[i][0]][hits[i][1]] = 1;\\n            \\n\\t\\t\\t//If this brick not connected to top of matrix, ans=0 and continue\\n            if(!isConnected(vis, hits[i][0], hits[i][1]))\\n                continue;\\n            \\n\\t\\t\\t//This brick connects between visited nodes and not visited nodes, do BFS\\n\\t\\t\\t//to make all reachable nodes visited and count them\\n            q.push({hits[i][0], hits[i][1]});\\n            vis[hits[i][0]][hits[i][1]] = true;\\n            int cnt=0;\\n            while(!q.empty()){\\n                int idx = q.front().first, jdx = q.front().second;\\n                q.pop();\\n                cnt++;\\n                if(idx>0 && mat[idx-1][jdx]==1 && !vis[idx-1][jdx]){\\n                    q.push({idx-1, jdx});\\n                    vis[idx-1][jdx]=true;\\n                }\\n                if(jdx>0 && mat[idx][jdx-1]==1 && !vis[idx][jdx-1]){\\n                    q.push({idx, jdx-1});\\n                    vis[idx][jdx-1]=true;\\n                }\\n                if(idx<grid.size()-1 && mat[idx+1][jdx]==1 && !vis[idx+1][jdx]){\\n                    q.push({idx+1, jdx});\\n                    vis[idx+1][jdx]=true;\\n                }\\n                if(jdx<grid[0].size()-1 && mat[idx][jdx+1]==1 && !vis[idx][jdx+1]){\\n                    q.push({idx, jdx+1});\\n                    vis[idx][jdx+1]=true;\\n                }\\n            }\\n            ans[i] = cnt-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354485,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n        \\n        //Initialise new array which showing the areas that can be merged\\n        int[][] mergeAreas = new int[rows][columns];\\n        for(int i = 0; i < rows; i++){\\n            for(int j = 0; j < columns; j++){\\n                mergeAreas[i][j] = grid[i][j];\\n            }\\n        }\\n        \\n        //Set the area where bricks have fallen to unmergeable\\n        for(int[] hit: hits){\\n            mergeAreas[hit[0]][hit[1]] = 0;\\n        }\\n        \\n        //Create the holder for the root and every section is its own root initially\\n        //We will provision an extra space for the root node (the last brick space)\\n        int[] root = new int[rows * columns + 1];\\n        for(int i = 0; i < root.length; i++){\\n            root[i] = i;\\n        }\\n        \\n        //Also set the size for the sections which we can assume as 1 initially.\\n        int[] size = new int[rows * columns + 1];\\n        Arrays.fill(size, 1);\\n        \\n        //Now we will group each region so we can get the size of the bricks\\n        for(int i = 0; i < rows; i++){\\n            for(int j = 0; j < columns; j++){\\n                //Merge only in the mergeable regions also since we are traversing\\n                //top to bottom, left to right we only have to care if there are prior\\n                //bricks on top or towards the left\\n                if(mergeAreas[i][j] == 1){\\n                    //The index of the current brick is its row * bricks per row + col no\\n                    int index = i * columns + j;\\n                    //If bricks are connected to roof\\n                    if(i == 0){\\n                        union(root, size, index, rows * columns);\\n                    }\\n                    \\n                    if(i > 0 && mergeAreas[i-1][j] == 1){\\n                        union(root, size, index, index-columns);\\n                    }\\n                    \\n                    //we will need multiple if statements to be able to form\\n                    //the proper connection as a brick can be connected to both\\n                    //regions from left and top not just either or\\n                    if(j > 0 && mergeAreas[i][j-1] == 1){\\n                        union(root, size, index, index-1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int[] toret = new int[hits.length];\\n        int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};\\n        \\n        //Calculate the bricks fallen per hit\\n        for(int i = hits.length-1; i >= 0; i--){\\n            int hitRow = hits[i][0];\\n            int hitCol = hits[i][1];\\n            \\n            //Initial size of brick connections to roof\\n            int initialSize = size[find(root, rows * columns)];\\n            \\n            //We only care if there is a brick struck down in the first place\\n            //If the strike is to a empty area then disregard as no connections will be formed\\n            //Or additional bricks created.\\n            if(grid[hitRow][hitCol] == 1){\\n                int index = hitRow * columns + hitCol;\\n                \\n                //We need to merge the current brick with all the surrounding bricks\\n                for(int[] dir: directions){\\n                    int searchRow = hitRow + dir[0];\\n                    int searchCol = hitCol + dir[1];\\n                    if(0 <= searchRow && 0 <= searchCol &&  searchRow < rows && searchCol < columns && mergeAreas[searchRow][searchCol] == 1){\\n                        union(root, size, searchRow * columns + searchCol, index);\\n                    }\\n                    //Also if the brick that is hit is connected to the roof, we perform\\n                    //another connection to thte roof\\n                    if(hitRow == 0){\\n                        union(root, size, index, rows * columns);\\n                    }\\n                    //Also set region as mergeable\\n                    mergeAreas[hitRow][hitCol] = 1;\\n                    //math.max since the added struck brick might not cause changes to\\n                    //the number of bricks connected to the roof yet since, there\\n                    //could be anoher brick that leads to its connection.\\n                    toret[i] = Math.max(0, size[find(root, rows * columns)] - initialSize -1);\\n                }\\n            }\\n        }\\n        \\n        return toret;\\n    }\\n    \\n    public int find(int[] root, int index){\\n        while(root[index] != root[root[index]]){\\n            root[index] = root[root[index]];\\n            index = root[index];\\n        }\\n        return root[index];\\n    }\\n    \\n    public void union(int[] root, int[] size, int indexOne, int indexTwo){\\n        int rootOne = find(root, indexOne);\\n        int rootTwo = find(root, indexTwo);\\n        \\n        if(rootOne == rootTwo){\\n            return;\\n        }\\n        \\n        //Since now rootTwo becomes the parent node\\n        root[rootOne] = rootTwo;\\n        size[rootTwo] = size[rootTwo] + size[rootOne];\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n        \\n        //Initialise new array which showing the areas that can be merged\\n        int[][] mergeAreas = new int[rows][columns];\\n        for(int i = 0; i < rows; i++){\\n            for(int j = 0; j < columns; j++){\\n                mergeAreas[i][j] = grid[i][j];\\n            }\\n        }\\n        \\n        //Set the area where bricks have fallen to unmergeable\\n        for(int[] hit: hits){\\n            mergeAreas[hit[0]][hit[1]] = 0;\\n        }\\n        \\n        //Create the holder for the root and every section is its own root initially\\n        //We will provision an extra space for the root node (the last brick space)\\n        int[] root = new int[rows * columns + 1];\\n        for(int i = 0; i < root.length; i++){\\n            root[i] = i;\\n        }\\n        \\n        //Also set the size for the sections which we can assume as 1 initially.\\n        int[] size = new int[rows * columns + 1];\\n        Arrays.fill(size, 1);\\n        \\n        //Now we will group each region so we can get the size of the bricks\\n        for(int i = 0; i < rows; i++){\\n            for(int j = 0; j < columns; j++){\\n                //Merge only in the mergeable regions also since we are traversing\\n                //top to bottom, left to right we only have to care if there are prior\\n                //bricks on top or towards the left\\n                if(mergeAreas[i][j] == 1){\\n                    //The index of the current brick is its row * bricks per row + col no\\n                    int index = i * columns + j;\\n                    //If bricks are connected to roof\\n                    if(i == 0){\\n                        union(root, size, index, rows * columns);\\n                    }\\n                    \\n                    if(i > 0 && mergeAreas[i-1][j] == 1){\\n                        union(root, size, index, index-columns);\\n                    }\\n                    \\n                    //we will need multiple if statements to be able to form\\n                    //the proper connection as a brick can be connected to both\\n                    //regions from left and top not just either or\\n                    if(j > 0 && mergeAreas[i][j-1] == 1){\\n                        union(root, size, index, index-1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int[] toret = new int[hits.length];\\n        int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};\\n        \\n        //Calculate the bricks fallen per hit\\n        for(int i = hits.length-1; i >= 0; i--){\\n            int hitRow = hits[i][0];\\n            int hitCol = hits[i][1];\\n            \\n            //Initial size of brick connections to roof\\n            int initialSize = size[find(root, rows * columns)];\\n            \\n            //We only care if there is a brick struck down in the first place\\n            //If the strike is to a empty area then disregard as no connections will be formed\\n            //Or additional bricks created.\\n            if(grid[hitRow][hitCol] == 1){\\n                int index = hitRow * columns + hitCol;\\n                \\n                //We need to merge the current brick with all the surrounding bricks\\n                for(int[] dir: directions){\\n                    int searchRow = hitRow + dir[0];\\n                    int searchCol = hitCol + dir[1];\\n                    if(0 <= searchRow && 0 <= searchCol &&  searchRow < rows && searchCol < columns && mergeAreas[searchRow][searchCol] == 1){\\n                        union(root, size, searchRow * columns + searchCol, index);\\n                    }\\n                    //Also if the brick that is hit is connected to the roof, we perform\\n                    //another connection to thte roof\\n                    if(hitRow == 0){\\n                        union(root, size, index, rows * columns);\\n                    }\\n                    //Also set region as mergeable\\n                    mergeAreas[hitRow][hitCol] = 1;\\n                    //math.max since the added struck brick might not cause changes to\\n                    //the number of bricks connected to the roof yet since, there\\n                    //could be anoher brick that leads to its connection.\\n                    toret[i] = Math.max(0, size[find(root, rows * columns)] - initialSize -1);\\n                }\\n            }\\n        }\\n        \\n        return toret;\\n    }\\n    \\n    public int find(int[] root, int index){\\n        while(root[index] != root[root[index]]){\\n            root[index] = root[root[index]];\\n            index = root[index];\\n        }\\n        return root[index];\\n    }\\n    \\n    public void union(int[] root, int[] size, int indexOne, int indexTwo){\\n        int rootOne = find(root, indexOne);\\n        int rootTwo = find(root, indexTwo);\\n        \\n        if(rootOne == rootTwo){\\n            return;\\n        }\\n        \\n        //Since now rootTwo becomes the parent node\\n        root[rootOne] = rootTwo;\\n        size[rootTwo] = size[rootTwo] + size[rootOne];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333074,
                "title": "java-dsu-33-m-s-size-method",
                "content": "```\\nclass Solution {\\n    int[]parent;\\n    int[]rank;\\n    int[]size;\\n    int m;\\n    int n;\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        parent = new int[m * n + 1];\\n        rank = new int[m * n + 1];\\n        size = new int[m * n + 1];\\n        for(int i=0;i<parent.length;i++){\\n            parent[i] = i;\\n            rank[i] = 0;\\n            size[i] = 1;\\n        }\\n        \\n        //Logic Start\\n        for(int []hit : hits){          //remove bricks from grid\\n            int x = hit[0];\\n            int y = hit[1];\\n            if(grid[x][y] == 1){\\n                grid[x][y] = 2;\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){     //union of all 1\\'s\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1){\\n                    handleUnion(grid,i,j);\\n                }\\n            }\\n        }\\n        \\n        int[]res = new int[hits.length];\\n        \\n        for(int i=hits.length-1;i>=0;i--){      //Add Bricks where they were and calculate size\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            \\n            if(grid[x][y] == 2){\\n                int bricksZ = size[find(0)];\\n                grid[x][y] = 1;\\n                handleUnion(grid,x,y);\\n                int newBricks = size[find(0)];\\n                \\n                if(newBricks > bricksZ){\\n                    res[i] = newBricks - bricksZ - 1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int[][]dirs = {{0,-1},{1,0},{0,1},{-1,0}};\\n    public void handleUnion(int[][]grid,int i,int j){\\n        int bno = i*n + j + 1;\\n        for(int[]dir : dirs){\\n            int ni = i + dir[0];\\n            int nj = j + dir[1];\\n            \\n            if(ni >= 0 && ni<m && nj >= 0 && nj < n && grid[ni][nj] == 1){\\n                int nbno = ni*n + nj + 1;\\n                union(bno,nbno);\\n            }\\n        }\\n        if(i == 0){\\n            union(0,bno);\\n        }\\n    }\\n    \\n    public void union(int X,int Y){\\n        int x = find(X);\\n        int y = find(Y);\\n        \\n        if(x == y){\\n            return;\\n        }\\n        \\n        if(rank[x] < rank[y]){\\n            parent[x] = y;\\n            size[y] += size[x];\\n        }else if(rank[y] < rank[x]){\\n            parent[y] = x;\\n            size[x] += size[y];\\n        }else{\\n            parent[y] = x;\\n            rank[x]++;\\n            size[x] += size[y];\\n        }\\n        \\n        \\n    }\\n    public int find(int x){\\n        if(parent[x] == x){\\n            return x;\\n        }else{\\n            parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[]parent;\\n    int[]rank;\\n    int[]size;\\n    int m;\\n    int n;\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        parent = new int[m * n + 1];\\n        rank = new int[m * n + 1];\\n        size = new int[m * n + 1];\\n        for(int i=0;i<parent.length;i++){\\n            parent[i] = i;\\n            rank[i] = 0;\\n            size[i] = 1;\\n        }\\n        \\n        //Logic Start\\n        for(int []hit : hits){          //remove bricks from grid\\n            int x = hit[0];\\n            int y = hit[1];\\n            if(grid[x][y] == 1){\\n                grid[x][y] = 2;\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){     //union of all 1\\'s\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1){\\n                    handleUnion(grid,i,j);\\n                }\\n            }\\n        }\\n        \\n        int[]res = new int[hits.length];\\n        \\n        for(int i=hits.length-1;i>=0;i--){      //Add Bricks where they were and calculate size\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            \\n            if(grid[x][y] == 2){\\n                int bricksZ = size[find(0)];\\n                grid[x][y] = 1;\\n                handleUnion(grid,x,y);\\n                int newBricks = size[find(0)];\\n                \\n                if(newBricks > bricksZ){\\n                    res[i] = newBricks - bricksZ - 1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int[][]dirs = {{0,-1},{1,0},{0,1},{-1,0}};\\n    public void handleUnion(int[][]grid,int i,int j){\\n        int bno = i*n + j + 1;\\n        for(int[]dir : dirs){\\n            int ni = i + dir[0];\\n            int nj = j + dir[1];\\n            \\n            if(ni >= 0 && ni<m && nj >= 0 && nj < n && grid[ni][nj] == 1){\\n                int nbno = ni*n + nj + 1;\\n                union(bno,nbno);\\n            }\\n        }\\n        if(i == 0){\\n            union(0,bno);\\n        }\\n    }\\n    \\n    public void union(int X,int Y){\\n        int x = find(X);\\n        int y = find(Y);\\n        \\n        if(x == y){\\n            return;\\n        }\\n        \\n        if(rank[x] < rank[y]){\\n            parent[x] = y;\\n            size[y] += size[x];\\n        }else if(rank[y] < rank[x]){\\n            parent[y] = x;\\n            size[x] += size[y];\\n        }else{\\n            parent[y] = x;\\n            rank[x]++;\\n            size[x] += size[y];\\n        }\\n        \\n        \\n    }\\n    public int find(int x){\\n        if(parent[x] == x){\\n            return x;\\n        }else{\\n            parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259514,
                "title": "java-dsu-solution-easy-to-understand",
                "content": "Please upvote, if you find it useful :)\\n\\n```\\nclass Solution {\\n    int n;\\n    int m;\\n    \\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        n = grid.length;\\n        m = grid[0].length;\\n        \\n        parent = new int[n * m + 1];\\n        rank = new int[n * m + 1];\\n        size = new int[n * m + 1];\\n        \\n        for(int i=0; i<parent.length; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n            rank[i] = 0;\\n        }\\n        \\n        for(int[] hit : hits) {\\n            int x = hit[0];\\n            int y = hit[1];\\n            \\n            if(grid[x][y] == 1) {\\n                grid[x][y] = 2;\\n            }\\n        }\\n        \\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    handleUnionOfAllNbrs(grid, i, j);\\n                }\\n            }\\n        }\\n            \\n        int[] res = new int[hits.length];\\n        for(int i=hits.length - 1; i>=0; i--) {\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n\\n            if(grid[x][y] == 2) {\\n                int bricksIn0 = size[find(0)];\\n                grid[x][y] = 1;\\n                handleUnionOfAllNbrs(grid, x, y);\\n\\n                int newBricksIn0 = size[find(0)];\\n                if(newBricksIn0 > bricksIn0) {\\n                    res[i] = newBricksIn0 - bricksIn0 - 1;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }  \\n    \\n    public int[][] dirs = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}};\\n    public void handleUnionOfAllNbrs(int[][] grid, int i, int j) {\\n        int bno = i * m + j + 1 ;\\n        \\n        for(int[] dir : dirs) {\\n            int ni = i + dir[0];\\n            int nj = j + dir[1];\\n            \\n            if(ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] == 1) {\\n                int nbno = ni * m + nj + 1;\\n                union(bno, nbno);\\n            }\\n        }\\n        \\n        if(i == 0) {\\n            union(0, bno);\\n        }\\n    }\\n    \\n    int[] parent;\\n    int[] rank;\\n    int[] size;\\n    \\n    public int find(int x) {\\n        if(parent[x] == x) {\\n            return x;\\n        } else {\\n            parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n    }\\n    \\n    public void union(int X, int Y) {\\n        int x = find(X);\\n        int y = find(Y);\\n        if(x == y) {\\n            return;\\n        }\\n        \\n        if(rank[x] > rank[y]) {\\n            parent[y] = x;\\n            size[x] += size[y];\\n        } else if(rank[y] > rank[x]) {\\n            parent[x] = y;\\n            size[y] += size[x];\\n        } else {\\n            parent[y] = x;\\n            rank[x] += 1;\\n            size[x] += size[y];\\n        }\\n    }\\n}\\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    int m;\\n    \\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        n = grid.length;\\n        m = grid[0].length;\\n        \\n        parent = new int[n * m + 1];\\n        rank = new int[n * m + 1];\\n        size = new int[n * m + 1];\\n        \\n        for(int i=0; i<parent.length; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n            rank[i] = 0;\\n        }\\n        \\n        for(int[] hit : hits) {\\n            int x = hit[0];\\n            int y = hit[1];\\n            \\n            if(grid[x][y] == 1) {\\n                grid[x][y] = 2;\\n            }\\n        }\\n        \\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    handleUnionOfAllNbrs(grid, i, j);\\n                }\\n            }\\n        }\\n            \\n        int[] res = new int[hits.length];\\n        for(int i=hits.length - 1; i>=0; i--) {\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n\\n            if(grid[x][y] == 2) {\\n                int bricksIn0 = size[find(0)];\\n                grid[x][y] = 1;\\n                handleUnionOfAllNbrs(grid, x, y);\\n\\n                int newBricksIn0 = size[find(0)];\\n                if(newBricksIn0 > bricksIn0) {\\n                    res[i] = newBricksIn0 - bricksIn0 - 1;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }  \\n    \\n    public int[][] dirs = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}};\\n    public void handleUnionOfAllNbrs(int[][] grid, int i, int j) {\\n        int bno = i * m + j + 1 ;\\n        \\n        for(int[] dir : dirs) {\\n            int ni = i + dir[0];\\n            int nj = j + dir[1];\\n            \\n            if(ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] == 1) {\\n                int nbno = ni * m + nj + 1;\\n                union(bno, nbno);\\n            }\\n        }\\n        \\n        if(i == 0) {\\n            union(0, bno);\\n        }\\n    }\\n    \\n    int[] parent;\\n    int[] rank;\\n    int[] size;\\n    \\n    public int find(int x) {\\n        if(parent[x] == x) {\\n            return x;\\n        } else {\\n            parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n    }\\n    \\n    public void union(int X, int Y) {\\n        int x = find(X);\\n        int y = find(Y);\\n        if(x == y) {\\n            return;\\n        }\\n        \\n        if(rank[x] > rank[y]) {\\n            parent[y] = x;\\n            size[x] += size[y];\\n        } else if(rank[y] > rank[x]) {\\n            parent[x] = y;\\n            size[y] += size[x];\\n        } else {\\n            parent[y] = x;\\n            rank[x] += 1;\\n            size[x] += size[y];\\n        }\\n    }\\n}\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258822,
                "title": "java-union-by-rank-maintaining-the-size-comment-explained-code",
                "content": "```\\nclass Solution {\\n    \\n    public int[]parent;             // parent stores the parent of the component\\n    public int[]ranks;              // ranks stores the rank of the component\\n    public int[]size;               // size stores the length of the connected component to the given component\\n    \\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // The idea is too first remove all hit bricks from the grid (mark as 2) and then traverse from back\\n        // resubstituting a perfect brick and then check the change in no. of zero-unioned bricks.\\n        \\n        // We mark with 2 as if we din\\'t, we would have ended up substituting bricks in grid places with 0 bricks\\n        // while traversing back and resubstituting.\\n        \\n        // We union elements directly connected to the roof with zero as seen in the unionOfAllNeighbours in the code.\\n        \\n        parent = new int[m*n+1];    // m*n elements + roof at index 0\\n        ranks = new int[m*n+1];     // m*n elements + roof at index 0\\n        size = new int[m*n+1];      // m*n elements + roof at index 0\\n        \\n        for(int i=0; i<parent.length; i++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n        \\n        for(int[]hit:hits) {\\n            int x = hit[0];\\n            int y = hit[1];\\n            if(grid[x][y] == 1){\\n                grid[x][y] = 2;     // removing the hit brick, if present\\n            }\\n        }\\n        \\n        for(int i=0; i < m; i++) { \\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 1){    // for each brick, union it with its neighbours and possibly with the roof.\\n                    unionOfAllNeighbors(grid, i, j, m, n);\\n                }\\n            }\\n        }\\n        \\n        int[]res = new int[hits.length];    // array to store the answer\\n        \\n        for(int i=hits.length-1; i >= 0; i--) {\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            \\n            // If grid[x][y] == 0, it means there was no brick in the original array at the concerned position.\\n            // Hence, number of bricks falling would be zero. Hence, we simply continue.\\n            \\n            if(grid[x][y] == 2) {\\n                int bricksInZero = size[find(0)];       // count initial bricks connected to the roof.\\n                \\n                grid[x][y] = 1;\\n                unionOfAllNeighbors(grid, x, y, m, n);\\n                int newBricksInZero = size[find(0)];    // count final bricks connected to the roof.\\n                \\n                if(newBricksInZero > bricksInZero) {\\n                    res[i] = newBricksInZero - bricksInZero - 1;    // the difference final-initial+1 is the amount of fallen bricks.\\n                                                                    // we decrement by 1 as we don\\'t have to count the hit brick.\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int[][]dirs = {{-1,0}, {0,-1}, {0,1}, {1,0}};\\n    public void unionOfAllNeighbors(int[][]grid, int i, int j, int m, int n) {\\n        int bno = i*n + j + 1;          // 1d box no. for the 2d grid element (add 1 as index 0 is reserved for roof).\\n        for(int[]dir:dirs) {\\n            int ni = i + dir[0];\\n            int nj = j + dir[1];\\n            \\n            if(ni >= 0 && nj >=0 && ni < m && nj < n && grid[ni][nj] == 1) {\\n                int nbno = ni * n + nj + 1;     // 1d box no. for the new 2d grid element.\\n                union(bno, nbno);               // union hit brick with its earlier neighbors.\\n            }\\n        }\\n        if(i == 0){\\n            union(bno, 0);                      // if connected to the roof, union with roof.\\n                                                // (for initially connecting all i=0 elements to the roof).\\n        }\\n    }\\n    \\n    public int find(int x){\\n        if(x == parent[x]) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    public void union(int s1, int s2){      // union by rank, maintaining size\\n        int l1 = find(s1);\\n        int l2 = find(s2);\\n        if(l1 == l2) return;\\n        if(ranks[l1] > ranks[l2]) {\\n            parent[l2] = l1;\\n            size[l1] += size[l2];\\n        } else if(ranks[l2] > ranks[l1]) {\\n            parent[l1] = l2;\\n            size[l2] += size[l1];\\n        } else {\\n            parent[l1] = l2;\\n            size[l2] += size[l1];\\n            ranks[l2]++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int[]parent;             // parent stores the parent of the component\\n    public int[]ranks;              // ranks stores the rank of the component\\n    public int[]size;               // size stores the length of the connected component to the given component\\n    \\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // The idea is too first remove all hit bricks from the grid (mark as 2) and then traverse from back\\n        // resubstituting a perfect brick and then check the change in no. of zero-unioned bricks.\\n        \\n        // We mark with 2 as if we din\\'t, we would have ended up substituting bricks in grid places with 0 bricks\\n        // while traversing back and resubstituting.\\n        \\n        // We union elements directly connected to the roof with zero as seen in the unionOfAllNeighbours in the code.\\n        \\n        parent = new int[m*n+1];    // m*n elements + roof at index 0\\n        ranks = new int[m*n+1];     // m*n elements + roof at index 0\\n        size = new int[m*n+1];      // m*n elements + roof at index 0\\n        \\n        for(int i=0; i<parent.length; i++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n        \\n        for(int[]hit:hits) {\\n            int x = hit[0];\\n            int y = hit[1];\\n            if(grid[x][y] == 1){\\n                grid[x][y] = 2;     // removing the hit brick, if present\\n            }\\n        }\\n        \\n        for(int i=0; i < m; i++) { \\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 1){    // for each brick, union it with its neighbours and possibly with the roof.\\n                    unionOfAllNeighbors(grid, i, j, m, n);\\n                }\\n            }\\n        }\\n        \\n        int[]res = new int[hits.length];    // array to store the answer\\n        \\n        for(int i=hits.length-1; i >= 0; i--) {\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            \\n            // If grid[x][y] == 0, it means there was no brick in the original array at the concerned position.\\n            // Hence, number of bricks falling would be zero. Hence, we simply continue.\\n            \\n            if(grid[x][y] == 2) {\\n                int bricksInZero = size[find(0)];       // count initial bricks connected to the roof.\\n                \\n                grid[x][y] = 1;\\n                unionOfAllNeighbors(grid, x, y, m, n);\\n                int newBricksInZero = size[find(0)];    // count final bricks connected to the roof.\\n                \\n                if(newBricksInZero > bricksInZero) {\\n                    res[i] = newBricksInZero - bricksInZero - 1;    // the difference final-initial+1 is the amount of fallen bricks.\\n                                                                    // we decrement by 1 as we don\\'t have to count the hit brick.\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int[][]dirs = {{-1,0}, {0,-1}, {0,1}, {1,0}};\\n    public void unionOfAllNeighbors(int[][]grid, int i, int j, int m, int n) {\\n        int bno = i*n + j + 1;          // 1d box no. for the 2d grid element (add 1 as index 0 is reserved for roof).\\n        for(int[]dir:dirs) {\\n            int ni = i + dir[0];\\n            int nj = j + dir[1];\\n            \\n            if(ni >= 0 && nj >=0 && ni < m && nj < n && grid[ni][nj] == 1) {\\n                int nbno = ni * n + nj + 1;     // 1d box no. for the new 2d grid element.\\n                union(bno, nbno);               // union hit brick with its earlier neighbors.\\n            }\\n        }\\n        if(i == 0){\\n            union(bno, 0);                      // if connected to the roof, union with roof.\\n                                                // (for initially connecting all i=0 elements to the roof).\\n        }\\n    }\\n    \\n    public int find(int x){\\n        if(x == parent[x]) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    public void union(int s1, int s2){      // union by rank, maintaining size\\n        int l1 = find(s1);\\n        int l2 = find(s2);\\n        if(l1 == l2) return;\\n        if(ranks[l1] > ranks[l2]) {\\n            parent[l2] = l1;\\n            size[l1] += size[l2];\\n        } else if(ranks[l2] > ranks[l1]) {\\n            parent[l1] = l2;\\n            size[l2] += size[l1];\\n        } else {\\n            parent[l1] = l2;\\n            size[l2] += size[l1];\\n            ranks[l2]++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252748,
                "title": "rust-union-find",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl5/lc0803)\\n\\n<b>Problem List</b>\\n#UnionFind - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_algorithm/union_find)\\n#Graph - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/graph)\\n\\n```\\n/// @author: Leon\\n/// https://leetcode.com/problems/bricks-falling-when-hit/\\n/// Time Complexity:    O(amortized(`len_rs` * `len_cs`))\\n/// Space Complexity:   O(`len_rs` * `len_cs`)\\n/// Reference:\\n/// https://leetcode.com/problems/bricks-falling-when-hit/discuss/195781/Union-find-Logical-Thinking\\nimpl Solution {\\n    const DIRS: &\\'static [isize] = &[0, -1, 0, 1, 0];\\n    pub fn hit_bricks(grid: Vec<Vec<i32>>, hits: Vec<Vec<i32>>) -> Vec<i32> {\\n        let len_rs: usize = grid.len();\\n        let len_cs: usize = grid[0].len();\\n        let len_ns: usize = len_rs * len_cs;\\n        let len_hs: usize = hits.len();\\n        let mut grid: Vec<Vec<i32>> = {\\n            let mut grid = grid;\\n            for hit in &hits {\\n                let r: usize = hit[0] as usize;\\n                let c: usize = hit[1] as usize;\\n                if grid[r][c] == 1 {\\n                    grid[r][c] = 2;\\n                }\\n            }\\n            grid\\n        };\\n        let mut roots: Vec<usize> = (0..len_ns + 1).collect(); \\n        let mut sizes: Vec<i32> = vec![1; len_ns + 1];\\n        for r in 0..len_rs {\\n            for c in 0..len_cs {\\n                if grid[r][c] == 1 {\\n                    Self::union_around((r, c), &grid, &mut roots, &mut sizes);\\n                }\\n            }\\n        }\\n        let mut bricks_left = sizes[Self::find(0, &mut roots)];\\n        let mut bricks_dropped: Vec<i32> = vec![0; len_hs];\\n        for (idx, hit) in hits.iter().enumerate().rev() {\\n            let r: usize = hit[0] as usize;\\n            let c: usize = hit[1] as usize;\\n            if grid[r][c] == 2 {\\n                grid[r][c] = 1;\\n                Self::union_around((r, c), &grid, &mut roots, &mut sizes);\\n                let cur_bricks_left = sizes[Self::find(0, &mut roots)];\\n                bricks_dropped[idx] = if cur_bricks_left == bricks_left { 0 } else { cur_bricks_left - bricks_left - 1};\\n                bricks_left = cur_bricks_left;\\n            }\\n        }\\n        bricks_dropped\\n    }\\n    fn union_around(\\n        coord: (usize, usize),\\n        grid: &Vec<Vec<i32>>,\\n        roots: &mut Vec<usize>,\\n        sizes: &mut Vec<i32>,\\n    ) {\\n        let len_rs: usize = grid.len();\\n        let len_cs: usize = grid[0].len();\\n        let (r, c) = coord;\\n        for d in 0..4 {\\n            let r_nxt: isize = r as isize + Self::DIRS[d];\\n            let c_nxt: isize = c as isize + Self::DIRS[d + 1];\\n            if r_nxt < 0\\n                || c_nxt < 0\\n                || r_nxt as usize >= len_rs\\n                || c_nxt as usize >= len_cs\\n                || grid[r_nxt as usize][c_nxt as usize] != 1\\n            {\\n                continue;\\n            }\\n            Self::union(\\n                Self::hash(r, c, len_cs),\\n                Self::hash(r_nxt as usize, c_nxt as usize, len_cs),\\n                roots,\\n                sizes,\\n            );\\n        }\\n        if r == 0 {\\n            Self::union(0, Self::hash(r, c, len_cs), roots, sizes);\\n        }\\n    }\\n    fn union(x: usize, y: usize, roots: &mut Vec<usize>, sizes: &mut Vec<i32>) {\\n        let root_x: usize = Self::find(x, roots);\\n        let root_y: usize = Self::find(y, roots);\\n        if root_x == root_y {\\n            return;\\n        }\\n        if sizes[root_x] > sizes[root_y] {\\n            roots[root_y] = root_x;\\n            sizes[root_x] += sizes[root_y];\\n            sizes[root_y] = 0;\\n        } else {\\n            roots[root_x] = root_y;\\n            sizes[root_y] += sizes[root_x];\\n            sizes[root_x] = 0;\\n        }\\n    }\\n    fn find(mut x: usize, roots: &mut Vec<usize>) -> usize {\\n        while x != roots[x] {\\n            roots[x] = roots[roots[x]];\\n            x = roots[x];\\n        }\\n        x\\n    }\\n    fn hash(r: usize, c: usize, len_cs: usize) -> usize {\\n        r * len_cs + c + 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Union Find"
                ],
                "code": "```\\n/// @author: Leon\\n/// https://leetcode.com/problems/bricks-falling-when-hit/\\n/// Time Complexity:    O(amortized(`len_rs` * `len_cs`))\\n/// Space Complexity:   O(`len_rs` * `len_cs`)\\n/// Reference:\\n/// https://leetcode.com/problems/bricks-falling-when-hit/discuss/195781/Union-find-Logical-Thinking\\nimpl Solution {\\n    const DIRS: &\\'static [isize] = &[0, -1, 0, 1, 0];\\n    pub fn hit_bricks(grid: Vec<Vec<i32>>, hits: Vec<Vec<i32>>) -> Vec<i32> {\\n        let len_rs: usize = grid.len();\\n        let len_cs: usize = grid[0].len();\\n        let len_ns: usize = len_rs * len_cs;\\n        let len_hs: usize = hits.len();\\n        let mut grid: Vec<Vec<i32>> = {\\n            let mut grid = grid;\\n            for hit in &hits {\\n                let r: usize = hit[0] as usize;\\n                let c: usize = hit[1] as usize;\\n                if grid[r][c] == 1 {\\n                    grid[r][c] = 2;\\n                }\\n            }\\n            grid\\n        };\\n        let mut roots: Vec<usize> = (0..len_ns + 1).collect(); \\n        let mut sizes: Vec<i32> = vec![1; len_ns + 1];\\n        for r in 0..len_rs {\\n            for c in 0..len_cs {\\n                if grid[r][c] == 1 {\\n                    Self::union_around((r, c), &grid, &mut roots, &mut sizes);\\n                }\\n            }\\n        }\\n        let mut bricks_left = sizes[Self::find(0, &mut roots)];\\n        let mut bricks_dropped: Vec<i32> = vec![0; len_hs];\\n        for (idx, hit) in hits.iter().enumerate().rev() {\\n            let r: usize = hit[0] as usize;\\n            let c: usize = hit[1] as usize;\\n            if grid[r][c] == 2 {\\n                grid[r][c] = 1;\\n                Self::union_around((r, c), &grid, &mut roots, &mut sizes);\\n                let cur_bricks_left = sizes[Self::find(0, &mut roots)];\\n                bricks_dropped[idx] = if cur_bricks_left == bricks_left { 0 } else { cur_bricks_left - bricks_left - 1};\\n                bricks_left = cur_bricks_left;\\n            }\\n        }\\n        bricks_dropped\\n    }\\n    fn union_around(\\n        coord: (usize, usize),\\n        grid: &Vec<Vec<i32>>,\\n        roots: &mut Vec<usize>,\\n        sizes: &mut Vec<i32>,\\n    ) {\\n        let len_rs: usize = grid.len();\\n        let len_cs: usize = grid[0].len();\\n        let (r, c) = coord;\\n        for d in 0..4 {\\n            let r_nxt: isize = r as isize + Self::DIRS[d];\\n            let c_nxt: isize = c as isize + Self::DIRS[d + 1];\\n            if r_nxt < 0\\n                || c_nxt < 0\\n                || r_nxt as usize >= len_rs\\n                || c_nxt as usize >= len_cs\\n                || grid[r_nxt as usize][c_nxt as usize] != 1\\n            {\\n                continue;\\n            }\\n            Self::union(\\n                Self::hash(r, c, len_cs),\\n                Self::hash(r_nxt as usize, c_nxt as usize, len_cs),\\n                roots,\\n                sizes,\\n            );\\n        }\\n        if r == 0 {\\n            Self::union(0, Self::hash(r, c, len_cs), roots, sizes);\\n        }\\n    }\\n    fn union(x: usize, y: usize, roots: &mut Vec<usize>, sizes: &mut Vec<i32>) {\\n        let root_x: usize = Self::find(x, roots);\\n        let root_y: usize = Self::find(y, roots);\\n        if root_x == root_y {\\n            return;\\n        }\\n        if sizes[root_x] > sizes[root_y] {\\n            roots[root_y] = root_x;\\n            sizes[root_x] += sizes[root_y];\\n            sizes[root_y] = 0;\\n        } else {\\n            roots[root_x] = root_y;\\n            sizes[root_y] += sizes[root_x];\\n            sizes[root_x] = 0;\\n        }\\n    }\\n    fn find(mut x: usize, roots: &mut Vec<usize>) -> usize {\\n        while x != roots[x] {\\n            roots[x] = roots[roots[x]];\\n            x = roots[x];\\n        }\\n        x\\n    }\\n    fn hash(r: usize, c: usize, len_cs: usize) -> usize {\\n        r * len_cs + c + 1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2201334,
                "title": "using-dfs-and-total-nodes-which-has-been-sasfe-upto-that-point",
                "content": "class Solution {\\npublic:\\n    \\n    unordered_set<int> to_remove;\\n    int total;\\n    bool is_safe[201][201];\\n    int n,m;\\n    \\n    bool is_valid(int i,int j){\\n        return i>=0 and j>=0 and i<n and j<m;\\n    }\\n    \\n    void dfs(int i,int j,vector<vector<int>>& arr) {\\n        \\n        is_safe[i][j]=1;\\n        total++;\\n        \\n        int dir[] ={0,1,0,-1,0};\\n        \\n        for(int idx=0;idx<4;idx++) {\\n            \\n            int ni=i+dir[idx];\\n            int nj=j+dir[idx+1];\\n            \\n            int temp = ni*m+nj+1;\\n            \\n            if(is_valid(ni,nj) and arr[ni][nj] == 1 and !is_safe[ni][nj] and to_remove.find(temp) == to_remove.end())\\n                dfs(ni,nj,arr);\\n        }\\n        return ;\\n    }\\n    \\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        \\n        n=grid.size();\\n        m=grid[0].size();\\n        \\n        for(auto it:hits) {\\n            \\n            int x=it[0],y=it[1];\\n            \\n            int temp=x*m+y+1;\\n            to_remove.insert(temp);\\n        }\\n        \\n        \\n        int dir[] ={0,1,0,-1,0};\\n        total=0;\\n        \\n        memset(is_safe,false,sizeof is_safe);\\n        \\n        for(int i=0;i<m;i++) {\\n            \\n            int temp = i+1;\\n            \\n            if(to_remove.find(temp) == to_remove.end() and !is_safe[0][i] and grid[0][i] == 1)\\n                dfs(0,i,grid);\\n        }\\n        \\n        int k = hits.size();\\n        vector<int> ans(k);\\n        \\n        for(int i=k-1;i>=0;i--) {\\n            \\n            int x=hits[i][0],y=hits[i][1];\\n            \\n            int temp = x*m+y+1; // oned coordinate for [x][y]\\n            \\n            to_remove.erase(temp); // deleting it from point which has to be removed\\n            \\n            int prev = total;\\n            \\n            if(x == 0 and grid[x][y] != 0) { // its on top row and a brick it will be safe for sure\\n                dfs(x,y,grid);\\n            }\\n            \\n            else if(grid[x][y] != 0) // making sure its a brick \\n            {\\n                for(int idx=0;idx<4;idx++)\\n                {\\n                    int nx = x+dir[idx];\\n                    int ny = y+dir[idx+1];\\n                \\n                    if(is_valid(nx,ny) and is_safe[nx][ny]) // if any of its neighbours is safe then it will be safe for sure\\n                    {\\n                        dfs(x,y,grid);break; // one safe neighbour is enough to mark current as safe so thats why break\\n                    }\\n                }\\n            }\\n            \\n            int diff = total-prev;\\n            ans[i] = max(0,diff-1);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    unordered_set<int> to_remove;\\n    int total;\\n    bool is_safe[201][201];\\n    int n,m;\\n    \\n    bool is_valid(int i,int j){\\n        return i>=0 and j>=0 and i<n and j<m;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2172323,
                "title": "java-union-by-size-dummy-node-clean-code",
                "content": "- Adding bricks back.\\n\\n- Use union by size. \\n\\n- Have a dummy node on top to connect all cells on the first row.\\n\\n- Edge case: when the brick is added back to the top row. \\nNo need to subtract 1 in this case because the union for up/left/right will all fail due to them having the same parent.\\n```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int[] ans = new int[hits.length];\\n        int m = grid.length, n = grid[0].length;\\n        for (int i = 0; i < hits.length; i++){\\n            if (grid[hits[i][0]][hits[i][1]]==1){\\n                grid[hits[i][0]][hits[i][1]]=0;\\n            }else{\\n                hits[i]=null; // there is no brick here.\\n            }\\n        }\\n        UF uf = new UF(m*n+1, n);\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){ // only union right & down \\n                uf.union(i, j, i + 1, j, grid);\\n                uf.union(i, j, i, j + 1, grid);\\n            }\\n        }\\n        for (int i = hits.length - 1; i >= 0; i--){\\n            if (hits[i]==null){\\n                continue;\\n            }\\n            int a = hits[i][0];\\n            int b = hits[i][1];\\n            grid[a][b]=1;\\n            ans[i] = uf.union(a, b, a + 1, b, grid)\\n                   + uf.union(a, b, a - 1, b, grid)\\n                   + uf.union(a, b, a, b + 1, grid)\\n                   + uf.union(a, b, a, b - 1, grid)\\n                   - (a == 0? 0 : 1); // edge case\\n            ans[i] = Math.max(ans[i], 0);\\n        }\\n        return ans;\\n    }\\n\\n    private class UF {\\n        int[] sz;\\n        int[] parent;\\n        UF (int sz, int n){\\n            parent = IntStream.range(0, sz).toArray();\\n            this.sz = new int[sz];\\n            Arrays.fill(this.sz, 1);\\n            for (int i=1; i<1+n;i++){\\n                parent[i]=0;\\n            }\\n        }\\n\\n        private int find(int x){\\n            return x == parent[x]? x : (parent[x]=find(parent[x]));\\n        }\\n\\n        private boolean withinBounds(int a, int b, int[][] grid){\\n            return !(a < 0 || b < 0 || a == grid.length || b == grid[0].length);\\n        }\\n\\n        private int union(int i, int j, int a, int b, int[][] grid){\\n            if (!withinBounds(i, j, grid) || !withinBounds(a, b, grid))\\n                return 0;\\n            if (grid[i][j]==0 || grid[a][b] == 0)\\n                return 0;\\n\\n            int x = find(1 + i*grid[0].length + j);\\n            int y = find(1 + a*grid[0].length + b);\\n            if (x == y)\\n                return 0;\\n            if (x==0){\\n                parent[y]=x;\\n                sz[x]+=sz[y];\\n                return sz[y];\\n            }else if (y==0){\\n                parent[x]=y;\\n                sz[y]+=sz[x];\\n                return sz[x];\\n            }else{\\n                parent[x]=y;\\n                sz[y]+=sz[x];\\n                return 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int[] ans = new int[hits.length];\\n        int m = grid.length, n = grid[0].length;\\n        for (int i = 0; i < hits.length; i++){\\n            if (grid[hits[i][0]][hits[i][1]]==1){\\n                grid[hits[i][0]][hits[i][1]]=0;\\n            }else{\\n                hits[i]=null; // there is no brick here.\\n            }\\n        }\\n        UF uf = new UF(m*n+1, n);\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){ // only union right & down \\n                uf.union(i, j, i + 1, j, grid);\\n                uf.union(i, j, i, j + 1, grid);\\n            }\\n        }\\n        for (int i = hits.length - 1; i >= 0; i--){\\n            if (hits[i]==null){\\n                continue;\\n            }\\n            int a = hits[i][0];\\n            int b = hits[i][1];\\n            grid[a][b]=1;\\n            ans[i] = uf.union(a, b, a + 1, b, grid)\\n                   + uf.union(a, b, a - 1, b, grid)\\n                   + uf.union(a, b, a, b + 1, grid)\\n                   + uf.union(a, b, a, b - 1, grid)\\n                   - (a == 0? 0 : 1); // edge case\\n            ans[i] = Math.max(ans[i], 0);\\n        }\\n        return ans;\\n    }\\n\\n    private class UF {\\n        int[] sz;\\n        int[] parent;\\n        UF (int sz, int n){\\n            parent = IntStream.range(0, sz).toArray();\\n            this.sz = new int[sz];\\n            Arrays.fill(this.sz, 1);\\n            for (int i=1; i<1+n;i++){\\n                parent[i]=0;\\n            }\\n        }\\n\\n        private int find(int x){\\n            return x == parent[x]? x : (parent[x]=find(parent[x]));\\n        }\\n\\n        private boolean withinBounds(int a, int b, int[][] grid){\\n            return !(a < 0 || b < 0 || a == grid.length || b == grid[0].length);\\n        }\\n\\n        private int union(int i, int j, int a, int b, int[][] grid){\\n            if (!withinBounds(i, j, grid) || !withinBounds(a, b, grid))\\n                return 0;\\n            if (grid[i][j]==0 || grid[a][b] == 0)\\n                return 0;\\n\\n            int x = find(1 + i*grid[0].length + j);\\n            int y = find(1 + a*grid[0].length + b);\\n            if (x == y)\\n                return 0;\\n            if (x==0){\\n                parent[y]=x;\\n                sz[x]+=sz[y];\\n                return sz[y];\\n            }else if (y==0){\\n                parent[x]=y;\\n                sz[y]+=sz[x];\\n                return sz[x];\\n            }else{\\n                parent[x]=y;\\n                sz[y]+=sz[x];\\n                return 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131141,
                "title": "could-someone-tell-me-why-tle-here",
                "content": "```\\nclass Solution {\\n    int father[40005];\\n    int size[40005];\\n    int rank[40005];\\n    void init()\\n    {\\n        for(int i = 0; i < 40005; i++){\\n            father[i] = i;\\n            size[i] = 1;\\n            rank[i] = 0;\\n        }\\n    }\\n    \\n    int fa(int x)\\n    {\\n        return father[x] == x? x : father[x] = fa(father[x]);\\n    }\\n    \\n    void Union(int x, int y)\\n    {\\n        int fx = fa(x), fy = fa(y);\\n        if(fx != fy) \\n        {\\n            if(rank[fx] < rank[fy])\\n            {\\n                father[fx] = fy;\\n                size[fy] += size[fx];\\n            }\\n            else if(rank[fx] > rank[fy])\\n            {\\n                father[fy] = fx;\\n                size[fx] += size[fy];\\n            }\\n            else\\n            {\\n                father[fx] = fy;\\n                size[fy] += size[fx];\\n                rank[fy] += 1;\\n            }\\n        }\\n    }\\n    \\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        vector<int> ans;\\n        int m = grid.size(), n = grid[0].size();\\n        init();\\n        \\n        for(auto& hit: hits)\\n        {\\n            if(grid[hit[0]][hit[1]] == 1)grid[hit[0]][hit[1]] = 2;\\n        }\\n        for(int i = 0; i < m ;i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    if(j > 0 && grid[i][j-1] == 1)Union(i * n + j, i * n + j - 1);\\n                    if(j < n - 1 && grid[i][j+1] == 1)Union(i * n + j, i * n + j + 1);\\n                    if(i > 0 && grid[i-1][j] == 1)Union(i * n + j, (i - 1) * n + j);\\n                    if(i < m - 1 && grid[i+1][j] == 1)Union(i * n + j, (i + 1)*n + j);\\n                }\\n            }\\n        }\\n        int root = 40004;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(grid[0][i] == 1)\\n            {\\n                Union(root, i);\\n            }\\n        }\\n        \\n        \\n        int size_before = size[fa(root)];\\n        \\n        for(int i = hits.size() - 1; i >= 0; i--)\\n        {\\n            int r = hits[i][0], c = hits[i][1];\\n            if(!grid[r][c])\\n            {\\n                ans.insert(ans.begin(), 0);\\n                continue;\\n            }\\n            if(r > 0 && grid[r-1][c] == 1)Union(r*n + c, (r-1)*n + c);\\n            if(r < m - 1 && grid[r+1][c] == 1)Union(r*n + c, (r+1)*n + c);\\n            if(c > 0 && grid[r][c-1] == 1)Union(r*n + c, r*n + c - 1);\\n            if(c < n - 1 && grid[r][c+1] == 1)Union(r*n + c, r*n + c + 1);\\n            if(r == 0)Union(r*n +c, root);\\n            \\n            int size_after = size[fa(root)];\\n            \\n            if(size_before == size_after)ans.insert(ans.begin(), 0);\\n            else ans.insert(ans.begin(), size_after - size_before - 1);\\n            grid[r][c] = 1;\\n            size_before = size_after;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int father[40005];\\n    int size[40005];\\n    int rank[40005];\\n    void init()\\n    {\\n        for(int i = 0; i < 40005; i++){\\n            father[i] = i;\\n            size[i] = 1;\\n            rank[i] = 0;\\n        }\\n    }\\n    \\n    int fa(int x)\\n    {\\n        return father[x] == x? x : father[x] = fa(father[x]);\\n    }\\n    \\n    void Union(int x, int y)\\n    {\\n        int fx = fa(x), fy = fa(y);\\n        if(fx != fy) \\n        {\\n            if(rank[fx] < rank[fy])\\n            {\\n                father[fx] = fy;\\n                size[fy] += size[fx];\\n            }\\n            else if(rank[fx] > rank[fy])\\n            {\\n                father[fy] = fx;\\n                size[fx] += size[fy];\\n            }\\n            else\\n            {\\n                father[fx] = fy;\\n                size[fy] += size[fx];\\n                rank[fy] += 1;\\n            }\\n        }\\n    }\\n    \\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        vector<int> ans;\\n        int m = grid.size(), n = grid[0].size();\\n        init();\\n        \\n        for(auto& hit: hits)\\n        {\\n            if(grid[hit[0]][hit[1]] == 1)grid[hit[0]][hit[1]] = 2;\\n        }\\n        for(int i = 0; i < m ;i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    if(j > 0 && grid[i][j-1] == 1)Union(i * n + j, i * n + j - 1);\\n                    if(j < n - 1 && grid[i][j+1] == 1)Union(i * n + j, i * n + j + 1);\\n                    if(i > 0 && grid[i-1][j] == 1)Union(i * n + j, (i - 1) * n + j);\\n                    if(i < m - 1 && grid[i+1][j] == 1)Union(i * n + j, (i + 1)*n + j);\\n                }\\n            }\\n        }\\n        int root = 40004;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(grid[0][i] == 1)\\n            {\\n                Union(root, i);\\n            }\\n        }\\n        \\n        \\n        int size_before = size[fa(root)];\\n        \\n        for(int i = hits.size() - 1; i >= 0; i--)\\n        {\\n            int r = hits[i][0], c = hits[i][1];\\n            if(!grid[r][c])\\n            {\\n                ans.insert(ans.begin(), 0);\\n                continue;\\n            }\\n            if(r > 0 && grid[r-1][c] == 1)Union(r*n + c, (r-1)*n + c);\\n            if(r < m - 1 && grid[r+1][c] == 1)Union(r*n + c, (r+1)*n + c);\\n            if(c > 0 && grid[r][c-1] == 1)Union(r*n + c, r*n + c - 1);\\n            if(c < n - 1 && grid[r][c+1] == 1)Union(r*n + c, r*n + c + 1);\\n            if(r == 0)Union(r*n +c, root);\\n            \\n            int size_after = size[fa(root)];\\n            \\n            if(size_before == size_after)ans.insert(ans.begin(), 0);\\n            else ans.insert(ans.begin(), size_after - size_before - 1);\\n            grid[r][c] = 1;\\n            size_before = size_after;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983510,
                "title": "go-solution",
                "content": "```\\nfunc find(nums []int, x int) int {//union find => find method\\n    if nums[x] == x {\\n       return x\\n    }\\n    root := find(nums,nums[x])\\n    nums[x] = root\\n    return root\\n}\\n\\nfunc hitBricks(grid [][]int, hits [][]int) []int {\\n    var n, m int = len(grid), len(grid[0])\\n    res := make([]int, len(hits))\\n    nums := make([]int, n * m + 1)\\n    cnt := make([]int, n * m + 1)\\n    dir := [4][2]int{{0, -1}, {-1, 0}, {0, 1}, {1, 0}}\\n    bad := make([]bool, len(hits))\\n    seen := make([]bool, n * m + 1)\\n    \\n    for i := 0; i < len(nums); i++ {\\n        nums[i] = i\\n        cnt[i] = 1\\n    }\\n    \\n    for i := 0; i < len(hits); i++ {\\n        if grid[hits[i][0]][hits[i][1]] == 0 {\\n            bad[i] = true\\n        }\\n        grid[hits[i][0]][hits[i][1]] = 0\\n    }\\n    \\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            if grid[i][j] == 0 {\\n                continue\\n            }\\n            id1 := i * m + j\\n            for x := 0; x < 2; x++ {\\n                var row, col int = i + dir[x][0], j + dir[x][1]\\n                if row < 0 || row >= n || col < 0 || col >= m || grid[row][col] == 0 {\\n                    continue\\n                }\\n                id2 := row * m + col\\n                r1 := find(nums, id1)\\n                r2 := find(nums, id2)\\n                if r1 != r2 {\\n                    nums[r1] = r2\\n                    cnt[r2] += cnt[r1]\\n                }\\n            }\\n        }\\n    }\\n    \\n    for i := 0; i < m; i++ {\\n        if grid[0][i] == 1 {\\n            r1 := find(nums, n * m)\\n            r2 := find(nums, i)\\n            if r1 != r2 {\\n                nums[r2] = r1\\n                cnt[r1] += cnt[r2]\\n            }\\n        }\\n    }\\n    \\n    \\n    for i := len(hits) - 1; i >= 0; i-- {\\n        if bad[i] {\\n            continue\\n        }\\n        \\n        var r, c int = hits[i][0], hits[i][1]\\n        grid[r][c] = 1\\n        connect := false\\n        id1 := r * m + c\\n        if r == 0 {\\n            connect = true\\n        }\\n        \\n        \\n        for x := 0; x < 4; x++ {\\n            var row, col int = r + dir[x][0], c + dir[x][1]\\n            if row < 0 || row >= n || col < 0 || col >= m || grid[row][col] == 0 {\\n                continue\\n            }\\n            id2 := row * m + col\\n            r2 := find(nums, id2)\\n            if r2 == n * m {\\n                connect = true\\n            }\\n        }\\n        \\n        \\n        for x := 0; x < 4; x++ {\\n            var row, col int = r + dir[x][0], c + dir[x][1]\\n            if row < 0 || row >= n || col < 0 || col >= m || grid[row][col] == 0 {\\n                continue\\n            }\\n            id2 := row * m + col\\n            r2 := find(nums, id2)\\n            if connect && r2 != n * m && !seen[r2] {\\n                res[i] += cnt[r2]\\n                seen[r2] = true\\n            }\\n            \\n        }\\n        \\n        for x := 0; x < 4; x++ {\\n            var row, col int = r + dir[x][0], c + dir[x][1]\\n            if row < 0 || row >= n || col < 0 || col >= m || grid[row][col] == 0 {\\n                continue\\n            }\\n            id2 := row * m + col\\n            r1 := find(nums, id1)\\n            r2 := find(nums, id2)\\n            \\n            \\n            seen[r2] = false\\n            if connect {\\n                if r2 != n * m {\\n                    nums[r2] = n * m\\n                    cnt[n * m] += cnt[r2]\\n                }\\n            } else {\\n                if r1 != r2 {\\n                    nums[r1] = r2\\n                    cnt[r2] += cnt[r1]\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        if connect {\\n            r1 := find(nums, id1)\\n            if r1 != n * m {\\n                nums[r1] = n * m\\n                cnt[n * m] += cnt[r1]\\n            }\\n        }\\n    }\\n    return res\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc find(nums []int, x int) int {//union find => find method\\n    if nums[x] == x {\\n       return x\\n    }\\n    root := find(nums,nums[x])\\n    nums[x] = root\\n    return root\\n}\\n\\nfunc hitBricks(grid [][]int, hits [][]int) []int {\\n    var n, m int = len(grid), len(grid[0])\\n    res := make([]int, len(hits))\\n    nums := make([]int, n * m + 1)\\n    cnt := make([]int, n * m + 1)\\n    dir := [4][2]int{{0, -1}, {-1, 0}, {0, 1}, {1, 0}}\\n    bad := make([]bool, len(hits))\\n    seen := make([]bool, n * m + 1)\\n    \\n    for i := 0; i < len(nums); i++ {\\n        nums[i] = i\\n        cnt[i] = 1\\n    }\\n    \\n    for i := 0; i < len(hits); i++ {\\n        if grid[hits[i][0]][hits[i][1]] == 0 {\\n            bad[i] = true\\n        }\\n        grid[hits[i][0]][hits[i][1]] = 0\\n    }\\n    \\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            if grid[i][j] == 0 {\\n                continue\\n            }\\n            id1 := i * m + j\\n            for x := 0; x < 2; x++ {\\n                var row, col int = i + dir[x][0], j + dir[x][1]\\n                if row < 0 || row >= n || col < 0 || col >= m || grid[row][col] == 0 {\\n                    continue\\n                }\\n                id2 := row * m + col\\n                r1 := find(nums, id1)\\n                r2 := find(nums, id2)\\n                if r1 != r2 {\\n                    nums[r1] = r2\\n                    cnt[r2] += cnt[r1]\\n                }\\n            }\\n        }\\n    }\\n    \\n    for i := 0; i < m; i++ {\\n        if grid[0][i] == 1 {\\n            r1 := find(nums, n * m)\\n            r2 := find(nums, i)\\n            if r1 != r2 {\\n                nums[r2] = r1\\n                cnt[r1] += cnt[r2]\\n            }\\n        }\\n    }\\n    \\n    \\n    for i := len(hits) - 1; i >= 0; i-- {\\n        if bad[i] {\\n            continue\\n        }\\n        \\n        var r, c int = hits[i][0], hits[i][1]\\n        grid[r][c] = 1\\n        connect := false\\n        id1 := r * m + c\\n        if r == 0 {\\n            connect = true\\n        }\\n        \\n        \\n        for x := 0; x < 4; x++ {\\n            var row, col int = r + dir[x][0], c + dir[x][1]\\n            if row < 0 || row >= n || col < 0 || col >= m || grid[row][col] == 0 {\\n                continue\\n            }\\n            id2 := row * m + col\\n            r2 := find(nums, id2)\\n            if r2 == n * m {\\n                connect = true\\n            }\\n        }\\n        \\n        \\n        for x := 0; x < 4; x++ {\\n            var row, col int = r + dir[x][0], c + dir[x][1]\\n            if row < 0 || row >= n || col < 0 || col >= m || grid[row][col] == 0 {\\n                continue\\n            }\\n            id2 := row * m + col\\n            r2 := find(nums, id2)\\n            if connect && r2 != n * m && !seen[r2] {\\n                res[i] += cnt[r2]\\n                seen[r2] = true\\n            }\\n            \\n        }\\n        \\n        for x := 0; x < 4; x++ {\\n            var row, col int = r + dir[x][0], c + dir[x][1]\\n            if row < 0 || row >= n || col < 0 || col >= m || grid[row][col] == 0 {\\n                continue\\n            }\\n            id2 := row * m + col\\n            r1 := find(nums, id1)\\n            r2 := find(nums, id2)\\n            \\n            \\n            seen[r2] = false\\n            if connect {\\n                if r2 != n * m {\\n                    nums[r2] = n * m\\n                    cnt[n * m] += cnt[r2]\\n                }\\n            } else {\\n                if r1 != r2 {\\n                    nums[r1] = r2\\n                    cnt[r2] += cnt[r1]\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        if connect {\\n            r1 := find(nums, id1)\\n            if r1 != n * m {\\n                nums[r1] = n * m\\n                cnt[n * m] += cnt[r1]\\n            }\\n        }\\n    }\\n    return res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1964024,
                "title": "modified-dijkstra",
                "content": "```\\nclass Solution {\\npublic:\\n    int MAX = 1000000;\\n    \\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        queue<pair<pair<int, int>, int>> q;\\n        \\n        vector<vector<int>> d(n, vector<int>(m, 0));\\n        vector<vector<int>> values(n, vector<int>(m, MAX));\\n\\n        for(int i = 0; i < hits.size(); i++) {\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            if(grid[x][y]) {\\n                values[x][y] = i + 1;\\n            }\\n        }\\n        \\n        \\n        for(int j = 0; j < m; j++) {\\n            if(grid[0][j]) {\\n                q.push(make_pair(make_pair(0, j), grid[0][j]));\\n                d[0][j] = values[0][j];\\n            }\\n        }\\n        \\n        int X[] = {0, 0, 1, -1};\\n        int Y[] = {1, -1, 0, 0};\\n        while(!q.empty()) {\\n            pair<pair<int, int>, int> p = q.front();\\n            q.pop();\\n            \\n            for(int k = 0; k < 4; k++) {\\n                int x = X[k] + p.first.first;\\n                int y = Y[k] + p.first.second;\\n                if(x < n && x >= 0 && y < m && y >= 0 && grid[x][y]) {\\n                    \\n                    if(d[x][y] < min(values[x][y], d[p.first.first][ p.first.second])) {\\n                            d[x][y] = min(values[x][y], d[p.first.first][ p.first.second]);\\n                            q.push(make_pair(make_pair(x, y), d[x][y]));\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        \\n        vector<int> ans(hits.size());\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j]) {\\n                    int val = d[i][j];\\n                    if(val == MAX || val == 0) continue;\\n                    val--;\\n                    ans[val] += 1;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < hits.size(); i++) {\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            if(d[x][y] == values[x][y])\\n            ans[i]--;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int MAX = 1000000;\\n    \\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        queue<pair<pair<int, int>, int>> q;\\n        \\n        vector<vector<int>> d(n, vector<int>(m, 0));\\n        vector<vector<int>> values(n, vector<int>(m, MAX));\\n\\n        for(int i = 0; i < hits.size(); i++) {\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            if(grid[x][y]) {\\n                values[x][y] = i + 1;\\n            }\\n        }\\n        \\n        \\n        for(int j = 0; j < m; j++) {\\n            if(grid[0][j]) {\\n                q.push(make_pair(make_pair(0, j), grid[0][j]));\\n                d[0][j] = values[0][j];\\n            }\\n        }\\n        \\n        int X[] = {0, 0, 1, -1};\\n        int Y[] = {1, -1, 0, 0};\\n        while(!q.empty()) {\\n            pair<pair<int, int>, int> p = q.front();\\n            q.pop();\\n            \\n            for(int k = 0; k < 4; k++) {\\n                int x = X[k] + p.first.first;\\n                int y = Y[k] + p.first.second;\\n                if(x < n && x >= 0 && y < m && y >= 0 && grid[x][y]) {\\n                    \\n                    if(d[x][y] < min(values[x][y], d[p.first.first][ p.first.second])) {\\n                            d[x][y] = min(values[x][y], d[p.first.first][ p.first.second]);\\n                            q.push(make_pair(make_pair(x, y), d[x][y]));\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        \\n        vector<int> ans(hits.size());\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j]) {\\n                    int val = d[i][j];\\n                    if(val == MAX || val == 0) continue;\\n                    val--;\\n                    ans[val] += 1;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < hits.size(); i++) {\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            if(d[x][y] == values[x][y])\\n            ans[i]--;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934498,
                "title": "intuitive-java-solution-but-tle-need-help-understanding-why",
                "content": "My solution is straightforward: check if each hit would cause the neighbor bricks unstable; if yes, remove unstable bricks and count them.\\n\\nI believe my solution is more intuitive than top voted \"adding bricks back\" solutions. It even has the same time complexity: O(N * M * hits). So I don\\'t understand why Time Limit Exceeded error occured. You help is much appreciated.\\n\\n```\\nclass Solution {\\n    int[][] directions = {{1, 0}, {0, 1}, {0, -1}, {-1, 0}};\\n    \\n    public int[] hitBricks(int[][] grid, int[][] hits) {    \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int len = hits.length;\\n        int[] res = new int[len];\\n        \\n        for (int k = 0; k < len; ++k) {\\n            int i = hits[k][0];\\n            int j = hits[k][1];\\n            \\n            grid[i][j] = 0;\\n            \\n            for (int[] dir : directions) {\\n                int i2 = i + dir[0];\\n                int j2 = j + dir[1];\\n                \\n                if (isInGrid(grid, i2, j2) && grid[i2][j2] == 1 && !isStable(grid, new boolean[m][n], i2, j2)) {\\n                    res[k] += remove(grid, i2, j2);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean isInGrid(int[][] grid, int i, int j) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        if (i >= 0 && i < m && j >= 0 && j < n) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean isStable(int[][] grid, boolean[][] visited, int i, int j) {\\n        if (visited[i][j]) return false;\\n        \\n        if (i == 0) return true; \\n        \\n        visited[i][j] = true;\\n        \\n        for (int[] dir : directions) {\\n            int i2 = i + dir[0];\\n            int j2 = j + dir[1];\\n\\n            if (isInGrid(grid, i2, j2) && grid[i2][j2] == 1 && isStable(grid, visited, i2, j2)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n\\t// Mark unstable bricks and count them\\n    private int remove(int[][] grid, int i, int j) {\\n        if (grid[i][j] == 0) return 0;\\n        \\n        int count = 1;\\n        \\n        grid[i][j] = 0;\\n        \\n        for (int[] dir : directions) {\\n            int i2 = i + dir[0];\\n            int j2 = j + dir[1];\\n\\n            if (isInGrid(grid, i2, j2)) {\\n                count += remove(grid, i2, j2);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] directions = {{1, 0}, {0, 1}, {0, -1}, {-1, 0}};\\n    \\n    public int[] hitBricks(int[][] grid, int[][] hits) {    \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int len = hits.length;\\n        int[] res = new int[len];\\n        \\n        for (int k = 0; k < len; ++k) {\\n            int i = hits[k][0];\\n            int j = hits[k][1];\\n            \\n            grid[i][j] = 0;\\n            \\n            for (int[] dir : directions) {\\n                int i2 = i + dir[0];\\n                int j2 = j + dir[1];\\n                \\n                if (isInGrid(grid, i2, j2) && grid[i2][j2] == 1 && !isStable(grid, new boolean[m][n], i2, j2)) {\\n                    res[k] += remove(grid, i2, j2);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean isInGrid(int[][] grid, int i, int j) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        if (i >= 0 && i < m && j >= 0 && j < n) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean isStable(int[][] grid, boolean[][] visited, int i, int j) {\\n        if (visited[i][j]) return false;\\n        \\n        if (i == 0) return true; \\n        \\n        visited[i][j] = true;\\n        \\n        for (int[] dir : directions) {\\n            int i2 = i + dir[0];\\n            int j2 = j + dir[1];\\n\\n            if (isInGrid(grid, i2, j2) && grid[i2][j2] == 1 && isStable(grid, visited, i2, j2)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n\\t// Mark unstable bricks and count them\\n    private int remove(int[][] grid, int i, int j) {\\n        if (grid[i][j] == 0) return 0;\\n        \\n        int count = 1;\\n        \\n        grid[i][j] = 0;\\n        \\n        for (int[] dir : directions) {\\n            int i2 = i + dir[0];\\n            int j2 = j + dir[1];\\n\\n            if (isInGrid(grid, i2, j2)) {\\n                count += remove(grid, i2, j2);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887420,
                "title": "c-modified-union-find-number-of-island-2",
                "content": "**Reversed Number of Island 2:**\\n* Consider `bricks` as `land` and `erased bricks` as `water`. Here, island is given and land forming island is washing away with water.\\n\\n**Algorithm and Intuition:**\\n\\n1. Mark all the bricks from `hits` list as already erased before performing Union-Find operation.\\n2. Create islands by joining connected components in the grid from remaining bricks using Union-Find operation.\\n3. Modified Union-Find will keep track of size of connected component after each Union operation\\n4. Identify size of island connected to the `roof` (top of the grid) `row = 0`\\n5. Reset erased bricks back in `reverse order` from `hits` list to find out number of bricks that will fall after each brick erasure is applied.\\n\\t* \\tHere, key idea is to identify if each erased brick is breaking connection between `roof` and remaining part of grid, as if connected brick is erased, all the remaining bricks which are now disconnected from `roof` will fall. This can be found by finding below separately:\\n\\t\\t* \\tFind size of connected component connected to `roof`\\n\\t\\t* \\tFind size of connected component NOT connected to `roof`\\n\\t* \\tSo when we reset the erased brick, it will form a bridge to connect these two components\\n\\n**Example 1:**\\ngrid[[1, 0, 0, 0], [1, 1, 1, 0]]\\nhits[[1, 0]]\\n\\nStep 1: Original grid with highlighted brick to be erased\\n\\n1 0 0 0\\n**1** 1 1 0\\n\\nStep 2: Brick to be erased is marked already erased temporarily\\nSize of component connected to `roof` = 1\\nSize of component NOT connected to `roof` = 2\\n\\n**1** 0 0 0\\n**2** **1 1** 0\\n\\nStep 3: Reset erased brick to form connected component\\n`Reset [1,0]`\\nSize of connected component connected to `roof` after brick is erased = 1\\nSize of connected component connected to `roof` with erased brick = 4\\n\\n`Number of falling bricks = Math.Max(4 - 1 - 1, 0); = Math.Max(2 , 0) = 2`\\n\\n**1** 0 0 0\\n**1 1 1** 0\\n\\n**Example 2:**\\n\\ngrid[[1, 0, 0, 0], [1, 1, 0, 0]]\\nhits[[1,1],[1,0]]\\n\\nS1: Original grid with highlighted bricks to be erased\\n\\n1 0 0 0\\n**1** **1** 0 0\\n\\nS2: Brick to be erased is marked already erased temporarily\\nSize of component connected to `roof` = 1\\nSize of component NOT connected to `roof` = 0\\n\\n1 0 0 0\\n**2** **2** 0 0\\n\\nS3: Start reseting erased bricks in reverse order\\n`Reset [1,0]`\\nSize of connected component connected to `roof` after brick is erased = 1\\nSize of connected component connected to `roof` with erased brick = 2\\n\\n`Number of falling bricks = Math.Max(2 - 1 - 1, 0); = Math.Max(0 , 0) = 0`\\n\\n**1** 0 0 0\\n**1** **2** 0 0\\n\\n`Reset [1, 1]`\\nSize of connected component connected to `roof` after brick is erased = 2\\nSize of connected component connected to `roof` with erased brick = 3\\n\\n`Number of falling bricks = Math.Max(3 - 2 - 1, 0); = Math.Max(0 , 0) = 0`\\n\\n**1** 0 0 0\\n**1** **1** 0 0\\n\\nFinal Result: [0, 0]\\n**Final Result Formula:** \\n\\n`numberOfBrickIslands` = Size of connected component connected to `roof` after brick is erased = 1\\n`newBrickIsland` = Size of connected component connected to `roof` with erased brick = 4\\n\\n`Count of falling bricks = newBrickIsland - numberOfBrickIslands - 1` = 4 - 1 - 1 (Exclude erased brick from final result by subtracting 1)\\n\\n```\\npublic class Solution {\\n    private int[][] directions = new int[][]{new int[]{-1, 0}, new int[]{1, 0}, new int[]{0, 1}, new int[]{0, -1}};\\n    private int[][] gridClone;\\n    private int rowCount;\\n    private int colCount;\\n    public int[] HitBricks(int[][] grid, int[][] hits) {\\n        this.rowCount = grid.Length;\\n        this.colCount = grid[0].Length;\\n        this.gridClone = grid;\\n        \\n        UnionFind uniFi = new UnionFind(rowCount * colCount + 1);\\n        \\n        //Step 1: Remove all the brick which are erased fron hits list by marking them to 2\\n        foreach(int[] hit in hits){\\n            if(gridClone[hit[0]][hit[1]] == 1){\\n                gridClone[hit[0]][hit[1]] = 2;\\n            }\\n        }\\n                     \\n        //Step 2: Apply same logic as Number of Islands and perform Union operation on all the remaining 1\\'s in the grid\\n        for(int r = 0; r < rowCount; r++){\\n            for(int c = 0; c < colCount; c++){\\n                if(gridClone[r][c] == 1){\\n                    PerformUnion(r, c, uniFi);\\n                }\\n            }\\n        }\\n        \\n        //Step 3: Find number of bricks drop after each erase\\n        int numberOfBrickIslands = uniFi.size[uniFi.Find(0)];\\n        int hitsCount = hits.Length - 1;\\n        int[] bricksDropped = new int[hits.Length];\\n        \\n        while(hitsCount >= 0){\\n            int row = hits[hitsCount][0];\\n            int col = hits[hitsCount][1];\\n            \\n            //If current brick is marked erased, restore this brick.\\n            //This step is crucial to find out how many brick will drop if marked brick will actually drop.\\n            //Idea: Basically, we have to find out size of island which will be dropped if current brick will be erased \\n            if(gridClone[row][col] == 2){\\n                gridClone[row][col] = 1;\\n                PerformUnion(row, col, uniFi);\\n                int newBrickIsland = uniFi.size[uniFi.Find(0)];\\n                bricksDropped[hitsCount] = Math.Max(newBrickIsland - numberOfBrickIslands - 1, 0);\\n                numberOfBrickIslands = newBrickIsland;\\n            }\\n            hitsCount--;\\n        }\\n        \\n        return bricksDropped;\\n    }\\n    \\n    private void PerformUnion(int row, int col, UnionFind ds){\\n        int root = this.colCount * row + col + 1;\\n        foreach(int[] direction in directions){\\n            int newRow = row + direction[0];\\n            int newColumn = col + direction[1];\\n            int newRoot = this.colCount * newRow + newColumn + 1;\\n\\n            if(newRow >= 0 && newColumn >= 0 && newRow < this.rowCount && newColumn < this.colCount && gridClone[newRow][newColumn] == 1){\\n                ds.Union(root, newRoot);\\n            } \\n        }\\n        //Connect current island to the top if working with first row\\n        if(row == 0){\\n            ds.Union(0, root);\\n        }\\n    }\\n}\\n\\npublic class UnionFind{\\n    public int[] root;\\n    public int[] size;\\n    \\n    public UnionFind(int size){\\n        this.root = new int[size];\\n        this.size = new int[size];\\n        \\n        for (int i = 0; i < size; i++)\\n        {\\n            this.root[i] = i;\\n            this.size[i] = 1;\\n        }\\n    }   \\n    \\n    public int Find(int node){\\n        if(this.root[node] == node){\\n            return node;\\n        }\\n        return this.root[node] = Find(root[node]);\\n    }\\n    \\n    public void Union(int x, int y){\\n        int rootX = Find(x);\\n        int rootY = Find(y);\\n        \\n        if (rootX != rootY) {\\n            this.root[rootX] = rootY;\\n            this.size[rootY] += this.size[rootX];\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    private int[][] directions = new int[][]{new int[]{-1, 0}, new int[]{1, 0}, new int[]{0, 1}, new int[]{0, -1}};\\n    private int[][] gridClone;\\n    private int rowCount;\\n    private int colCount;\\n    public int[] HitBricks(int[][] grid, int[][] hits) {\\n        this.rowCount = grid.Length;\\n        this.colCount = grid[0].Length;\\n        this.gridClone = grid;\\n        \\n        UnionFind uniFi = new UnionFind(rowCount * colCount + 1);\\n        \\n        //Step 1: Remove all the brick which are erased fron hits list by marking them to 2\\n        foreach(int[] hit in hits){\\n            if(gridClone[hit[0]][hit[1]] == 1){\\n                gridClone[hit[0]][hit[1]] = 2;\\n            }\\n        }\\n                     \\n        //Step 2: Apply same logic as Number of Islands and perform Union operation on all the remaining 1\\'s in the grid\\n        for(int r = 0; r < rowCount; r++){\\n            for(int c = 0; c < colCount; c++){\\n                if(gridClone[r][c] == 1){\\n                    PerformUnion(r, c, uniFi);\\n                }\\n            }\\n        }\\n        \\n        //Step 3: Find number of bricks drop after each erase\\n        int numberOfBrickIslands = uniFi.size[uniFi.Find(0)];\\n        int hitsCount = hits.Length - 1;\\n        int[] bricksDropped = new int[hits.Length];\\n        \\n        while(hitsCount >= 0){\\n            int row = hits[hitsCount][0];\\n            int col = hits[hitsCount][1];\\n            \\n            //If current brick is marked erased, restore this brick.\\n            //This step is crucial to find out how many brick will drop if marked brick will actually drop.\\n            //Idea: Basically, we have to find out size of island which will be dropped if current brick will be erased \\n            if(gridClone[row][col] == 2){\\n                gridClone[row][col] = 1;\\n                PerformUnion(row, col, uniFi);\\n                int newBrickIsland = uniFi.size[uniFi.Find(0)];\\n                bricksDropped[hitsCount] = Math.Max(newBrickIsland - numberOfBrickIslands - 1, 0);\\n                numberOfBrickIslands = newBrickIsland;\\n            }\\n            hitsCount--;\\n        }\\n        \\n        return bricksDropped;\\n    }\\n    \\n    private void PerformUnion(int row, int col, UnionFind ds){\\n        int root = this.colCount * row + col + 1;\\n        foreach(int[] direction in directions){\\n            int newRow = row + direction[0];\\n            int newColumn = col + direction[1];\\n            int newRoot = this.colCount * newRow + newColumn + 1;\\n\\n            if(newRow >= 0 && newColumn >= 0 && newRow < this.rowCount && newColumn < this.colCount && gridClone[newRow][newColumn] == 1){\\n                ds.Union(root, newRoot);\\n            } \\n        }\\n        //Connect current island to the top if working with first row\\n        if(row == 0){\\n            ds.Union(0, root);\\n        }\\n    }\\n}\\n\\npublic class UnionFind{\\n    public int[] root;\\n    public int[] size;\\n    \\n    public UnionFind(int size){\\n        this.root = new int[size];\\n        this.size = new int[size];\\n        \\n        for (int i = 0; i < size; i++)\\n        {\\n            this.root[i] = i;\\n            this.size[i] = 1;\\n        }\\n    }   \\n    \\n    public int Find(int node){\\n        if(this.root[node] == node){\\n            return node;\\n        }\\n        return this.root[node] = Find(root[node]);\\n    }\\n    \\n    public void Union(int x, int y){\\n        int rootX = Find(x);\\n        int rootY = Find(y);\\n        \\n        if (rootX != rootY) {\\n            this.root[rootX] = rootY;\\n            this.size[rootY] += this.size[rootX];\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876702,
                "title": "easy-java-solution-removing-hit-entries-first-and-adding-back-to-figure-the-blocks-to-be-removed",
                "content": "\\t// TC: O(mn) + O(hits.length)\\n    int[][] dirs = {{-1,0}, {0,1}, {1,0}, {0,-1}};\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        if(hits.length==0 || grid.length==0){\\n            return new int[hits.length];\\n        }\\n        \\n        // making entries with 0 to be -1 and 1 to be 0 for every hit entries\\n        for(int[] hit : hits){\\n            int i = hit[0];\\n            int j = hit[1];\\n            \\n            grid[i][j]-=1;\\n        }\\n        \\n        // making all the roof connected nodes (column level) to be 2\\n        for(int i=0; i<grid[0].length; i++){\\n            dfs(0, i, grid);\\n        }\\n        \\n        int[] res = new int[hits.length];\\n        \\n        // converting the hit entries back to original value, so that all the blocks under that hit entries will now be connected to roof, and this provides the info of how many blocks can be connected to roof if hit entries are added - which is equivalent to how many blocks can be removed too\\n        for(int k=hits.length-1; k>=0; k--){\\n            int[] hit = hits[k];\\n            int i = hit[0], j = hit[1];\\n            \\n            grid[i][j]+=1;\\n            \\n            if(grid[i][j]==1 && isConnected(i, j, grid)){\\n                res[k] = dfs(i, j, grid) - 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // performing dfs for every roof entry and making it 2\\n    private int dfs(int i, int j, int[][] grid){\\n        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]!=1){\\n            return 0;\\n        }\\n        \\n        grid[i][j] = 2;\\n        \\n        return 1 + dfs(i+1, j, grid) + dfs(i-1, j, grid) + dfs(i, j+1, grid) + dfs(i, j-1, grid);\\n    }\\n    \\n    // checking for all after hit entries from all the directions\\n    private boolean isConnected(int i, int j, int[][] grid){\\n        if(i==0){\\n            return true;\\n        }\\n        \\n        for(int[] dir : dirs){\\n            int r = i + dir[0], c = j + dir[1];\\n            \\n            if(r>=0 && r<grid.length && c>=0 && c<grid[0].length && grid[r][c]==2){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }",
                "solutionTags": [],
                "code": "\\t// TC: O(mn) + O(hits.length)\\n    int[][] dirs = {{-1,0}, {0,1}, {1,0}, {0,-1}};\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        if(hits.length==0 || grid.length==0){\\n            return new int[hits.length];\\n        }\\n        \\n        // making entries with 0 to be -1 and 1 to be 0 for every hit entries\\n        for(int[] hit : hits){\\n            int i = hit[0];\\n            int j = hit[1];\\n            \\n            grid[i][j]-=1;\\n        }\\n        \\n        // making all the roof connected nodes (column level) to be 2\\n        for(int i=0; i<grid[0].length; i++){\\n            dfs(0, i, grid);\\n        }\\n        \\n        int[] res = new int[hits.length];\\n        \\n        // converting the hit entries back to original value, so that all the blocks under that hit entries will now be connected to roof, and this provides the info of how many blocks can be connected to roof if hit entries are added - which is equivalent to how many blocks can be removed too\\n        for(int k=hits.length-1; k>=0; k--){\\n            int[] hit = hits[k];\\n            int i = hit[0], j = hit[1];\\n            \\n            grid[i][j]+=1;\\n            \\n            if(grid[i][j]==1 && isConnected(i, j, grid)){\\n                res[k] = dfs(i, j, grid) - 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // performing dfs for every roof entry and making it 2\\n    private int dfs(int i, int j, int[][] grid){\\n        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]!=1){\\n            return 0;\\n        }\\n        \\n        grid[i][j] = 2;\\n        \\n        return 1 + dfs(i+1, j, grid) + dfs(i-1, j, grid) + dfs(i, j+1, grid) + dfs(i, j-1, grid);\\n    }\\n    \\n    // checking for all after hit entries from all the directions\\n    private boolean isConnected(int i, int j, int[][] grid){\\n        if(i==0){\\n            return true;\\n        }\\n        \\n        for(int[] dir : dirs){\\n            int r = i + dir[0], c = j + dir[1];\\n            \\n            if(r>=0 && r<grid.length && c>=0 && c<grid[0].length && grid[r][c]==2){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1874753,
                "title": "java-20ms-union-find-with-bottom-up-logical-thinking",
                "content": "1) Originally, I tried to  brutal-force, union-find the stable bricks before and after each erasures\\n 2) The logic is pretty simple, find the difference in between the number of bricks having a stable root ( root in first row), however, this result in TLE, rebuilding the sets with union-find after each hit is too cumbersome.\\n3) I then tried the bottom up way to solve the question, however, with the standard union & find template, the time complexity is still annoying.\\n\\t* denote erasures bricks with value 2 (if and only if the erasure spot is a brick originally)\\n4) After reading several posts, I realized that the only way to improve time complexity at this step is to find the `new stable bricks` at the `union` step. So apart from the root record, we shall have another array to record number of items in each set;\\n\\t*  Checking the root of two sets,  if roots are equal, nothing change. \\n\\t*  if only one of the roots is the stable brick root, all items in the other set will be new stable bricks \\n\\t*  if all  roots are / aren\\'t stable brick root, bricks status will not change, just merge two sets and union the roots\\n\\n\\n**Reference and Special Thanks to:** https://leetcode.com/problems/bricks-falling-when-hit/discuss/137465/Java-Union-Find-beats-100\\n```\\nclass Solution {\\n    int[] par;\\n    int[] num;\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        if (grid == null || grid.length == 0){\\n            return new int[]{};\\n        }\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int k = hits.length;\\n        int[] result = new int[k];\\n        \\n        par = new int[m * n];\\n        num = new int[m * n];\\n        \\n        for (int[] hit : hits){\\n            // erase brick only\\n            int x = hit[0];\\n            int y = hit[1];\\n            if (grid[x][y] == 1) grid[x][y] = 2; \\n        }\\n        \\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (grid[i][j] == 1){\\n                    addBrick(grid, m, n, i, j, false);\\n                }\\n            }\\n        }\\n        \\n        //rebuild the wall\\n        for (int i = k - 1; i >= 0; i--){\\n            int[] cur = hits[i];\\n            int x = cur[0];\\n            int y = cur[1];\\n            if (grid[x][y] != 2) {\\n                result[i] = 0;\\n                continue;\\n            }\\n            grid[x][y] = 1;\\n            int increment = addBrick(grid, m, n, x, y, true);\\n            result[i] = increment;\\n        }\\n        return result;\\n    }\\n    \\n    public int addBrick(int[][] grid, int m, int n, int i, int j, boolean checkLower){\\n        int key = i * n + j;\\n        par[key] = key;\\n        num[key] = 1;\\n        // return the number of new stabled brick\\n        int count = key < n ? 1 : 0; \\n        if (i > 0 && grid[i - 1][j] == 1) count += union(key, key - n, n);\\n        if (j > 0 && grid[i][j - 1] == 1) count += union(key, key - 1, n);\\n        if (checkLower && i < m - 1 && grid[i + 1][j] == 1) count += union(key, key + n, n);\\n        if (checkLower && j < n - 1 && grid[i][j + 1] == 1) count += union(key, key + 1, n);\\n        return Math.max(0, count - 1); // erasure brick will not count as falling ones\\n    }\\n    \\n    public int union(int x, int y, int n){\\n        // not union two sets together, but also union the size number, return the increment\\n        int rx = find(x);\\n        int ry = find(y);\\n        \\n        if (rx == ry) return 0;\\n        \\n        // all nodes in ry set will be stabled\\n        if (rx < n && ry >= n) {\\n            par[ry] = par[rx];\\n            num[rx] += num[ry];\\n            return num[ry];\\n        } \\n        else if (rx >= n && ry < n){ // nodes in rx will be stabled\\n            par[rx] = par[ry];\\n            num[ry] += num[rx];\\n            return num[rx];\\n        }\\n        else {  // no change in status\\n            par[rx] = par[ry];\\n            num[ry] += num[rx];\\n            return 0;\\n        }\\n        \\n    }\\n    public int find(int x){\\n        if (par[x] == x) return x;\\n        par[x] = find(par[x]);\\n        return par[x];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] par;\\n    int[] num;\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        if (grid == null || grid.length == 0){\\n            return new int[]{};\\n        }\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int k = hits.length;\\n        int[] result = new int[k];\\n        \\n        par = new int[m * n];\\n        num = new int[m * n];\\n        \\n        for (int[] hit : hits){\\n            // erase brick only\\n            int x = hit[0];\\n            int y = hit[1];\\n            if (grid[x][y] == 1) grid[x][y] = 2; \\n        }\\n        \\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (grid[i][j] == 1){\\n                    addBrick(grid, m, n, i, j, false);\\n                }\\n            }\\n        }\\n        \\n        //rebuild the wall\\n        for (int i = k - 1; i >= 0; i--){\\n            int[] cur = hits[i];\\n            int x = cur[0];\\n            int y = cur[1];\\n            if (grid[x][y] != 2) {\\n                result[i] = 0;\\n                continue;\\n            }\\n            grid[x][y] = 1;\\n            int increment = addBrick(grid, m, n, x, y, true);\\n            result[i] = increment;\\n        }\\n        return result;\\n    }\\n    \\n    public int addBrick(int[][] grid, int m, int n, int i, int j, boolean checkLower){\\n        int key = i * n + j;\\n        par[key] = key;\\n        num[key] = 1;\\n        // return the number of new stabled brick\\n        int count = key < n ? 1 : 0; \\n        if (i > 0 && grid[i - 1][j] == 1) count += union(key, key - n, n);\\n        if (j > 0 && grid[i][j - 1] == 1) count += union(key, key - 1, n);\\n        if (checkLower && i < m - 1 && grid[i + 1][j] == 1) count += union(key, key + n, n);\\n        if (checkLower && j < n - 1 && grid[i][j + 1] == 1) count += union(key, key + 1, n);\\n        return Math.max(0, count - 1); // erasure brick will not count as falling ones\\n    }\\n    \\n    public int union(int x, int y, int n){\\n        // not union two sets together, but also union the size number, return the increment\\n        int rx = find(x);\\n        int ry = find(y);\\n        \\n        if (rx == ry) return 0;\\n        \\n        // all nodes in ry set will be stabled\\n        if (rx < n && ry >= n) {\\n            par[ry] = par[rx];\\n            num[rx] += num[ry];\\n            return num[ry];\\n        } \\n        else if (rx >= n && ry < n){ // nodes in rx will be stabled\\n            par[rx] = par[ry];\\n            num[ry] += num[rx];\\n            return num[rx];\\n        }\\n        else {  // no change in status\\n            par[rx] = par[ry];\\n            num[ry] += num[rx];\\n            return 0;\\n        }\\n        \\n    }\\n    public int find(int x){\\n        if (par[x] == x) return x;\\n        par[x] = find(par[x]);\\n        return par[x];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832814,
                "title": "reason-of-initializing-unionfind-with-m-n-1",
                "content": "If you initialize union find with (m * n), run test case [[1,0,1,1],[1,1,0,0]] hit [[0,0]] you will see the error\\n\\nerror output = 1 = 5 (reverse [0,0] ) - 3 (final) - 1 (the brick that was hit)\\n\\nI finally realize this is wrong because the final state should be 2 since there are only two bricks at ceiling. Reason of getting 3 is when union three bricks at ceiling, I add two bricks to size[0]. This messes up the physical meaning of size[0] - correct concept of element 0 is, 0 is a virtual element, it does not represent any element in matrix. However, the very first element of matrix (0 * columnSize + 0) = 0 is not virtual. It is a concrete element in matrix. Two things get same value 0 but they have different physical meaning.\\n\\nSo shifting elements by 1 avoids messing up the physical meaning. To be more clear, I think in code we should initialize union find with size[0] = 0, and size[i] = 1 (1 <= i <= n). Even though the desired output is diff, this declaration makes the physical meaning more clear. As for example above\\n\\ncorrect output = 2 = 5 (after reverse[0,0], 5 bricks at ceiling) - 2 (final state, only two bricks at ceiling) - 1 (the brick that was hit)",
                "solutionTags": [],
                "code": "If you initialize union find with (m * n), run test case [[1,0,1,1],[1,1,0,0]] hit [[0,0]] you will see the error\\n\\nerror output = 1 = 5 (reverse [0,0] ) - 3 (final) - 1 (the brick that was hit)\\n\\nI finally realize this is wrong because the final state should be 2 since there are only two bricks at ceiling. Reason of getting 3 is when union three bricks at ceiling, I add two bricks to size[0]. This messes up the physical meaning of size[0] - correct concept of element 0 is, 0 is a virtual element, it does not represent any element in matrix. However, the very first element of matrix (0 * columnSize + 0) = 0 is not virtual. It is a concrete element in matrix. Two things get same value 0 but they have different physical meaning.\\n\\nSo shifting elements by 1 avoids messing up the physical meaning. To be more clear, I think in code we should initialize union find with size[0] = 0, and size[i] = 1 (1 <= i <= n). Even though the desired output is diff, this declaration makes the physical meaning more clear. As for example above\\n\\ncorrect output = 2 = 5 (after reverse[0,0], 5 bricks at ceiling) - 2 (final state, only two bricks at ceiling) - 1 (the brick that was hit)",
                "codeTag": "Unknown"
            },
            {
                "id": 1823264,
                "title": "python-union-find-with-reversed-time",
                "content": "```\\nclass Solution:\\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        grid0 = copy.deepcopy(grid)\\n        # step 1, set all hits to zero\\n        for x,y in hits:\\n            grid[x][y] = 0\\n            \\n        # step 2, union find them\\n        m,n = len(grid),len(grid[0])\\n        uf = [i for i in range(200*200)]\\n        size = [1 for i in range(200*200)]\\n        def find(x):\\n            # print(x)\\n            if uf[x] != x:\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n        def union(x,y):\\n            # x = uf[x]\\n            # y = uf[y]\\n            x = find(x)\\n            y = find(y)\\n            if x<y:\\n                uf[y] = x\\n                size[x] += size[y]\\n            else:\\n                uf[x] = y\\n                size[y] += size[x]\\n                \\n        direct = [[0,1],[0,-1],[-1,0],[1,0]]\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    for x,y in direct:\\n                        nx,ny = i + x, j + y\\n                        if -1<nx<m and -1<ny<n and grid[nx][ny] == 1:\\n                            # union(i*n + j, nx*n + ny)\\n                            if find(i*n + j) != find(nx*n + ny):\\n                                union(i*n + j, nx*n + ny)\\n        \\n        ans = []\\n        # step3, iterate hit reversely.\\n        for i,j in hits[::-1]:\\n            if grid0[i][j] == 0:\\n                ans.append(0)\\n                continue\\n            grid[i][j] = 1\\n            count = 0\\n            flag = False\\n            # p1 = find(i*n + j)\\n            ## \\u6700\\u597D\\u4E00\\u76F4find, \\u800C\\u4E0D\\u662F \\u4E3A\\u4E86\\u8282\\u7EA6\\u65F6\\u95F4\\u5148find\\u597D\\uFF0C\\n            for r,c in direct:\\n                x,y = i + r,j + c\\n                if -1<x<m and -1<y<n and grid[x][y] == 1:\\n                    p2 = find(x*n + y)\\n                    if find(i*n + j) != p2:\\n                        if p2 >= n:\\n                            count += size[p2]\\n                        if p2 < n or i == 0:\\n                            flag = True\\n                        union(n*i + j, n*x + y)\\n            if flag:\\n                ans.append(count)\\n            else:\\n                ans.append(0)\\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        grid0 = copy.deepcopy(grid)\\n        # step 1, set all hits to zero\\n        for x,y in hits:\\n            grid[x][y] = 0\\n            \\n        # step 2, union find them\\n        m,n = len(grid),len(grid[0])\\n        uf = [i for i in range(200*200)]\\n        size = [1 for i in range(200*200)]\\n        def find(x):\\n            # print(x)\\n            if uf[x] != x:\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n        def union(x,y):\\n            # x = uf[x]\\n            # y = uf[y]\\n            x = find(x)\\n            y = find(y)\\n            if x<y:\\n                uf[y] = x\\n                size[x] += size[y]\\n            else:\\n                uf[x] = y\\n                size[y] += size[x]\\n                \\n        direct = [[0,1],[0,-1],[-1,0],[1,0]]\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    for x,y in direct:\\n                        nx,ny = i + x, j + y\\n                        if -1<nx<m and -1<ny<n and grid[nx][ny] == 1:\\n                            # union(i*n + j, nx*n + ny)\\n                            if find(i*n + j) != find(nx*n + ny):\\n                                union(i*n + j, nx*n + ny)\\n        \\n        ans = []\\n        # step3, iterate hit reversely.\\n        for i,j in hits[::-1]:\\n            if grid0[i][j] == 0:\\n                ans.append(0)\\n                continue\\n            grid[i][j] = 1\\n            count = 0\\n            flag = False\\n            # p1 = find(i*n + j)\\n            ## \\u6700\\u597D\\u4E00\\u76F4find, \\u800C\\u4E0D\\u662F \\u4E3A\\u4E86\\u8282\\u7EA6\\u65F6\\u95F4\\u5148find\\u597D\\uFF0C\\n            for r,c in direct:\\n                x,y = i + r,j + c\\n                if -1<x<m and -1<y<n and grid[x][y] == 1:\\n                    p2 = find(x*n + y)\\n                    if find(i*n + j) != p2:\\n                        if p2 >= n:\\n                            count += size[p2]\\n                        if p2 < n or i == 0:\\n                            flag = True\\n                        union(n*i + j, n*x + y)\\n            if flag:\\n                ans.append(count)\\n            else:\\n                ans.append(0)\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785155,
                "title": "python-union-find-with-reverse-time",
                "content": "```\\n\"\"\"\\nIdea: Build a disjoint set from the grid, without the hit bricks. Loop over hit bricks backwards and re-insert a hit brick. If re-insertion would connect any component to the ceiling, then the number of cells in that component is the number of bricks being dropped.\\n\\n\\ncustomize our distjoint set data structure:\\n\\nrank \\nparent\\nsize -> gives the size of each connected component\\n\\n1. Create a set of nodes, from grid with brick positions. Remove the nodes that would be erased, by looping over hits. Map each hit brick to the index of its first occurence.\\n\\n2. Merge each node with any neighboring node.\\n   Merge all nodes on the ceiling together.\\n   Add and merge a dummy node (-1, -1) to the ceiling component, to let us query the ceiling component.\\n\\n3. Initialzie outpout array of all 0\\'s.\\nLoop backwards over the indexes of the hit bricks. At each hit brick, with first occurence i:\\n    query neighboring cells for the the size of the components, and whether (-1,-1) is connected to the neighbor.\\n    If (-1,-1) is connected to any neighbor, output[i] = sum of non-ceiling connected neighbors.\\n\\nreturn output\\n\"\"\"\\n\\nclass d_set:\\n    \\n    def __init__(self):\\n        \\n        self.rank = dict()\\n        self.parent = dict()\\n        self.size = dict()\\n    \\n    def add(self, node): #adds node to disjoint set, if it already exists, do nothing\\n        if node in self.rank:\\n            return\\n        self.rank[node] = 0\\n        self.parent[node] = node\\n        self.size[node] = 1\\n    \\n    def find(self, node): #finds root of the tree at node, compresses the path along it\\n        \\n        output = node\\n        path = set()\\n        \\n        while self.parent[output] != output:\\n            path.add(output)\\n            output = self.parent[output]\\n        \\n        for node in path:\\n            self.parent[node] = output\\n        \\n        return output\\n    \\n    def union(self, node, other): #merges two components of node, other by rank. Updates the size of component (size of root)\\n        \\n        # find the compoents of both, if the same, do nothing\\n        node, other = self.find(node), self.find(other)\\n        if node == other:\\n            return\\n        \\n        #reorder nodes so larger rank one comes first. If same rank. Increase rank of the first\\n        if self.rank[other] > self.rank[node]:\\n            node, other = other, node\\n        elif self.rank[other] == self.rank[node]:\\n            self.rank[node] += 1\\n        \\n        #update the parent and size of root of merged components\\n        final_size = self.size[node] + self.size[other]\\n        self.parent[other] = node\\n        self.size[node] = final_size\\n\\n\\nclass Solution:\\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        R, C = len(grid), len(grid[0])\\n        nodes = {(r, c) for r in range(R) for c in range(C) if grid[r][c] == 1}\\n        hit_nodes = dict() #mapping from bricks erased to first time of erasure\\n        \\n        for i in range(len(hits)-1, -1, -1):\\n            r,c = hits[i]\\n            if (r,c) in nodes:\\n                hit_nodes[(r,c)] = i\\n        \\n        nodes.difference_update(hit_nodes)\\n        \\n        house = d_set()\\n        \\n        for node in nodes:\\n            house.add(node)\\n        \\n        def neighbors(r,c): #returns 4-directional neighbors of (r,c) that are 1 on grid.\\n            output = []\\n            for n_r, n_c in [(r+1,c), (r-1,c), (r,c+1), (r,c-1)]:\\n                if 0 <= n_r <= R-1 and 0 <= n_c <= C-1 and (n_r, n_c) in nodes:\\n                    output.append((n_r, n_c))\\n            \\n            return output\\n        \\n        for r,c in nodes:\\n            for n_r, n_c in neighbors(r,c):\\n                house.union((r, c), (n_r, n_c))\\n        \\n        # connect ceiling components to a dummy root vairbale\\n        root = (-1,-1)\\n        house.add(root)\\n        for r, c in nodes:\\n            if r == 0:\\n                house.union(root, (r, c))\\n        \\n        #loop over sorted timestamp of hits backwards, and find the sizes of the components that connect to the ceiling. After that, add the hit brick back to the house, and merge with neighbors\\n        output = [0 for _ in hits]\\n        times = sorted(hit_nodes.values(), reverse=True)\\n        \\n        for t in times:\\n            hit_r, hit_c = hits[t]\\n            nei_components = set()\\n            for nei in neighbors(hit_r, hit_c):\\n                comp = house.find(nei)\\n                nei_components.add(comp)\\n            if house.find(root) in nei_components or hit_r == 0:\\n                nei_components.discard(house.find(root))\\n                sizes = [house.size[comp] for comp in nei_components]\\n                output[t] = sum(sizes)\\n                \\n            hit_node = (hit_r, hit_c)\\n            nodes.add(hit_node)\\n            house.add(hit_node)\\n            for nei in neighbors(hit_r, hit_c):\\n                house.union(hit_node, nei)\\n            if hit_r == 0:\\n                house.union(hit_node, root)\\n        \\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nIdea: Build a disjoint set from the grid, without the hit bricks. Loop over hit bricks backwards and re-insert a hit brick. If re-insertion would connect any component to the ceiling, then the number of cells in that component is the number of bricks being dropped.\\n\\n\\ncustomize our distjoint set data structure:\\n\\nrank \\nparent\\nsize -> gives the size of each connected component\\n\\n1. Create a set of nodes, from grid with brick positions. Remove the nodes that would be erased, by looping over hits. Map each hit brick to the index of its first occurence.\\n\\n2. Merge each node with any neighboring node.\\n   Merge all nodes on the ceiling together.\\n   Add and merge a dummy node (-1, -1) to the ceiling component, to let us query the ceiling component.\\n\\n3. Initialzie outpout array of all 0\\'s.\\nLoop backwards over the indexes of the hit bricks. At each hit brick, with first occurence i:\\n    query neighboring cells for the the size of the components, and whether (-1,-1) is connected to the neighbor.\\n    If (-1,-1) is connected to any neighbor, output[i] = sum of non-ceiling connected neighbors.\\n\\nreturn output\\n\"\"\"\\n\\nclass d_set:\\n    \\n    def __init__(self):\\n        \\n        self.rank = dict()\\n        self.parent = dict()\\n        self.size = dict()\\n    \\n    def add(self, node): #adds node to disjoint set, if it already exists, do nothing\\n        if node in self.rank:\\n            return\\n        self.rank[node] = 0\\n        self.parent[node] = node\\n        self.size[node] = 1\\n    \\n    def find(self, node): #finds root of the tree at node, compresses the path along it\\n        \\n        output = node\\n        path = set()\\n        \\n        while self.parent[output] != output:\\n            path.add(output)\\n            output = self.parent[output]\\n        \\n        for node in path:\\n            self.parent[node] = output\\n        \\n        return output\\n    \\n    def union(self, node, other): #merges two components of node, other by rank. Updates the size of component (size of root)\\n        \\n        # find the compoents of both, if the same, do nothing\\n        node, other = self.find(node), self.find(other)\\n        if node == other:\\n            return\\n        \\n        #reorder nodes so larger rank one comes first. If same rank. Increase rank of the first\\n        if self.rank[other] > self.rank[node]:\\n            node, other = other, node\\n        elif self.rank[other] == self.rank[node]:\\n            self.rank[node] += 1\\n        \\n        #update the parent and size of root of merged components\\n        final_size = self.size[node] + self.size[other]\\n        self.parent[other] = node\\n        self.size[node] = final_size\\n\\n\\nclass Solution:\\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        R, C = len(grid), len(grid[0])\\n        nodes = {(r, c) for r in range(R) for c in range(C) if grid[r][c] == 1}\\n        hit_nodes = dict() #mapping from bricks erased to first time of erasure\\n        \\n        for i in range(len(hits)-1, -1, -1):\\n            r,c = hits[i]\\n            if (r,c) in nodes:\\n                hit_nodes[(r,c)] = i\\n        \\n        nodes.difference_update(hit_nodes)\\n        \\n        house = d_set()\\n        \\n        for node in nodes:\\n            house.add(node)\\n        \\n        def neighbors(r,c): #returns 4-directional neighbors of (r,c) that are 1 on grid.\\n            output = []\\n            for n_r, n_c in [(r+1,c), (r-1,c), (r,c+1), (r,c-1)]:\\n                if 0 <= n_r <= R-1 and 0 <= n_c <= C-1 and (n_r, n_c) in nodes:\\n                    output.append((n_r, n_c))\\n            \\n            return output\\n        \\n        for r,c in nodes:\\n            for n_r, n_c in neighbors(r,c):\\n                house.union((r, c), (n_r, n_c))\\n        \\n        # connect ceiling components to a dummy root vairbale\\n        root = (-1,-1)\\n        house.add(root)\\n        for r, c in nodes:\\n            if r == 0:\\n                house.union(root, (r, c))\\n        \\n        #loop over sorted timestamp of hits backwards, and find the sizes of the components that connect to the ceiling. After that, add the hit brick back to the house, and merge with neighbors\\n        output = [0 for _ in hits]\\n        times = sorted(hit_nodes.values(), reverse=True)\\n        \\n        for t in times:\\n            hit_r, hit_c = hits[t]\\n            nei_components = set()\\n            for nei in neighbors(hit_r, hit_c):\\n                comp = house.find(nei)\\n                nei_components.add(comp)\\n            if house.find(root) in nei_components or hit_r == 0:\\n                nei_components.discard(house.find(root))\\n                sizes = [house.size[comp] for comp in nei_components]\\n                output[t] = sum(sizes)\\n                \\n            hit_node = (hit_r, hit_c)\\n            nodes.add(hit_node)\\n            house.add(hit_node)\\n            for nei in neighbors(hit_r, hit_c):\\n                house.union(hit_node, nei)\\n            if hit_r == 0:\\n                house.union(hit_node, root)\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545931,
                "title": "possibly-wrong-answer-by-leetcode",
                "content": "For example:\\n\\n```\\n[[0],[1],[1]]\\n[[2,0]]\\n```\\n\\nAfter we hit [2,0] cell [1,0] will be not stable and brick must fall. But leetcode running result returns [0] instead of [1].",
                "solutionTags": [],
                "code": "```\\n[[0],[1],[1]]\\n[[2,0]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1520863,
                "title": "python-union-find-reversely-adding-bricks",
                "content": "Time: O((N+H) alpha(N)) where N is almost 1\\nSpace: O(N+H)\\n\\nself.parentsize denotes the number of 1s that are tied to the top.\\n\\n```\\n\\nclass Solution:\\n    \\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        class DSU(object):\\n            \\n            def __init__(self):\\n                self.p = [i for i in range(m*n)]\\n                self.size = [1]*(m*n)\\n                self.parentsize = 0\\n                \\n            def find(self, x):\\n                root = x\\n                while root != self.p[root]:\\n                    root = self.p[root]\\n                \\n                while x != root:\\n                    oldroot = self.p[x]\\n                    self.p[x] = root\\n                    x = oldroot\\n                return root\\n            \\n                \\n            def union(self, x, y):\\n                px, py = self.find(x), self.find(y)\\n                if px == py:\\n                    return False\\n                \\n                if (px < n and py < n) or (px >= n and py >= n):\\n                    if self.size[px] >= self.size[py]:\\n                        self.p[py] = px\\n                        self.size[px] += self.size[py]\\n                    \\n                    else:\\n                        self.p[px] = py\\n                        self.size[py] += self.size[px]\\n                \\n                elif px < n:\\n                    self.p[py] = px\\n                    self.size[px] += self.size[py]\\n                    self.parentsize += self.size[py]\\n                    \\n                else:\\n                    self.p[px] = py\\n                    self.size[py] += self.size[px]\\n                    self.parentsize += self.size[px]\\n                    \\n                return True\\n          \\n        # optimization\\n        ans = []\\n        dsu = DSU()\\n        dummy = set()\\n        for (r,c) in hits:\\n            if grid[r][c] == 0:\\n                dummy.add((r,c))\\n                continue\\n                \\n            grid[r][c] = 0\\n            \\n            \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    if i == 0:\\n                        dsu.parentsize += 1\\n                    \\n                    for dr, dc in [(1,0), (0,1)]:\\n                        nr, nc = i+dr, j+dc\\n                        if nr >= 0 and nc >= 0 and nr < m and nc < n and grid[nr][nc] == 1:\\n                            dsu.union(i*n+j, nr*n+nc)\\n        \\n        for (r,c) in hits[::-1]:\\n            if (r,c) in dummy:\\n                ans.append(0)\\n                continue\\n            \\n            prev = dsu.parentsize\\n            if r == 0:\\n                dsu.parentsize += 1\\n            \\n            grid[r][c] = 1\\n            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                nr, nc = r+dr, c+dc\\n                if nr >= 0 and nc >= 0 and nr < m and nc < n and grid[nr][nc] == 1:\\n                    dsu.union(r*n+c, nr*n+nc)\\n            \\n            ans.append(max(dsu.parentsize - prev - 1, 0))\\n        \\n        return ans[::-1]\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    \\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        class DSU(object):\\n            \\n            def __init__(self):\\n                self.p = [i for i in range(m*n)]\\n                self.size = [1]*(m*n)\\n                self.parentsize = 0\\n                \\n            def find(self, x):\\n                root = x\\n                while root != self.p[root]:\\n                    root = self.p[root]\\n                \\n                while x != root:\\n                    oldroot = self.p[x]\\n                    self.p[x] = root\\n                    x = oldroot\\n                return root\\n            \\n                \\n            def union(self, x, y):\\n                px, py = self.find(x), self.find(y)\\n                if px == py:\\n                    return False\\n                \\n                if (px < n and py < n) or (px >= n and py >= n):\\n                    if self.size[px] >= self.size[py]:\\n                        self.p[py] = px\\n                        self.size[px] += self.size[py]\\n                    \\n                    else:\\n                        self.p[px] = py\\n                        self.size[py] += self.size[px]\\n                \\n                elif px < n:\\n                    self.p[py] = px\\n                    self.size[px] += self.size[py]\\n                    self.parentsize += self.size[py]\\n                    \\n                else:\\n                    self.p[px] = py\\n                    self.size[py] += self.size[px]\\n                    self.parentsize += self.size[px]\\n                    \\n                return True\\n          \\n        # optimization\\n        ans = []\\n        dsu = DSU()\\n        dummy = set()\\n        for (r,c) in hits:\\n            if grid[r][c] == 0:\\n                dummy.add((r,c))\\n                continue\\n                \\n            grid[r][c] = 0\\n            \\n            \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    if i == 0:\\n                        dsu.parentsize += 1\\n                    \\n                    for dr, dc in [(1,0), (0,1)]:\\n                        nr, nc = i+dr, j+dc\\n                        if nr >= 0 and nc >= 0 and nr < m and nc < n and grid[nr][nc] == 1:\\n                            dsu.union(i*n+j, nr*n+nc)\\n        \\n        for (r,c) in hits[::-1]:\\n            if (r,c) in dummy:\\n                ans.append(0)\\n                continue\\n            \\n            prev = dsu.parentsize\\n            if r == 0:\\n                dsu.parentsize += 1\\n            \\n            grid[r][c] = 1\\n            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                nr, nc = r+dr, c+dc\\n                if nr >= 0 and nc >= 0 and nr < m and nc < n and grid[nr][nc] == 1:\\n                    dsu.union(r*n+c, nr*n+nc)\\n            \\n            ans.append(max(dsu.parentsize - prev - 1, 0))\\n        \\n        return ans[::-1]\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1508949,
                "title": "100-fastest-javascript-dfs-reverse-order-easy-to-follow-code",
                "content": "```\\nlet is_connected = [];\\nlet is_erased = [];\\n\\nvar hitBricks = function(grid, hits) {\\n    for(let i = 0; i < grid.length; i++){\\n        is_connected[i] = [];\\n        is_erased[i] = [];\\n        for(let j = 0; j < grid[0].length; j++){\\n            is_connected[i][j] = false;\\n            is_erased[i][j] = grid[i][j] === 0;\\n        }\\n    }\\n    \\n    for(let i = 0; i < hits.length; i++){\\n        let row = hits[i][0];\\n        let col = hits[i][1];\\n        is_erased[row][col] = true;\\n    }\\n    \\n    for(let j = 0; j < grid[0].length; j++){\\n\\t    connect(grid, 0,j);\\n    }\\n\\n    let result = [];\\n\\n    hits.reverse();\\n    for(let i = 0; i < hits.length; i++){\\n        let row = hits[i][0];\\n        let col = hits[i][1];\\n\\n        if(grid[row][col] === 0){ result.push(0); continue;}\\n\\n        is_erased[row][col] = false;\\n\\n        let r = Math.max(0,connect(grid,row,col)-1);\\n        \\n        result.push(r);\\n    }\\n    \\n    return result.reverse();\\n};\\n\\n\\nlet inRange = function(grid,i,j){\\n    return i < grid.length && j < grid[0].length && i >= 0 && j >= 0;\\n}\\n\\nlet neighs = function(i,j){\\n    return [ [i, j-1], [i, j+1], [i+1, j], [i-1, j]];\\n}\\n\\nlet hasConnNeigh = function(grid,i, j){\\n\\tif(i === 0 && !is_erased[i][j]) return true;\\n    \\n    let n = neighs(i,j);\\n    for(let k = 0; k < n.length; k++){\\n        let row = n[k][0];\\n        let col = n[k][1];\\n        if(inRange(grid,row,col) && is_connected[row][col]) return true;\\n    }\\n    return false;\\n}\\n\\n\\nlet connect = function(grid, i, j){\\n    if(!inRange(grid,i,j) || is_connected[i][j] || is_erased[i][j] || grid[i][j] === 0) return 0;\\n\\n\\n    if(!hasConnNeigh(grid,i,j)) return 0;\\n    is_connected[i][j] = true;\\n    let c = 1;\\n    \\n    let n = neighs(i,j);\\n    for(let k = 0; k < n.length; k++){\\n        let row = n[k][0];\\n        let col = n[k][1];\\n        c += connect(grid, row, col);\\n    }\\n    return c;\\n    \\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nlet is_connected = [];\\nlet is_erased = [];\\n\\nvar hitBricks = function(grid, hits) {\\n    for(let i = 0; i < grid.length; i++){\\n        is_connected[i] = [];\\n        is_erased[i] = [];\\n        for(let j = 0; j < grid[0].length; j++){\\n            is_connected[i][j] = false;\\n            is_erased[i][j] = grid[i][j] === 0;\\n        }\\n    }\\n    \\n    for(let i = 0; i < hits.length; i++){\\n        let row = hits[i][0];\\n        let col = hits[i][1];\\n        is_erased[row][col] = true;\\n    }\\n    \\n    for(let j = 0; j < grid[0].length; j++){\\n\\t    connect(grid, 0,j);\\n    }\\n\\n    let result = [];\\n\\n    hits.reverse();\\n    for(let i = 0; i < hits.length; i++){\\n        let row = hits[i][0];\\n        let col = hits[i][1];\\n\\n        if(grid[row][col] === 0){ result.push(0); continue;}\\n\\n        is_erased[row][col] = false;\\n\\n        let r = Math.max(0,connect(grid,row,col)-1);\\n        \\n        result.push(r);\\n    }\\n    \\n    return result.reverse();\\n};\\n\\n\\nlet inRange = function(grid,i,j){\\n    return i < grid.length && j < grid[0].length && i >= 0 && j >= 0;\\n}\\n\\nlet neighs = function(i,j){\\n    return [ [i, j-1], [i, j+1], [i+1, j], [i-1, j]];\\n}\\n\\nlet hasConnNeigh = function(grid,i, j){\\n\\tif(i === 0 && !is_erased[i][j]) return true;\\n    \\n    let n = neighs(i,j);\\n    for(let k = 0; k < n.length; k++){\\n        let row = n[k][0];\\n        let col = n[k][1];\\n        if(inRange(grid,row,col) && is_connected[row][col]) return true;\\n    }\\n    return false;\\n}\\n\\n\\nlet connect = function(grid, i, j){\\n    if(!inRange(grid,i,j) || is_connected[i][j] || is_erased[i][j] || grid[i][j] === 0) return 0;\\n\\n\\n    if(!hasConnNeigh(grid,i,j)) return 0;\\n    is_connected[i][j] = true;\\n    let c = 1;\\n    \\n    let n = neighs(i,j);\\n    for(let k = 0; k < n.length; k++){\\n        let row = n[k][0];\\n        let col = n[k][1];\\n        c += connect(grid, row, col);\\n    }\\n    return c;\\n    \\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428182,
                "title": "c-o-n-m-h-union-find",
                "content": "```\\n\\tvoid merge(int x, int y, vector<int>& uf, vector<int>& sizes){\\n        int a=find(x,uf),b=find(y,uf);\\n        if(a==b){\\n            return;\\n        }\\n        uf[a]=b;\\n        sizes[b]+=sizes[a];\\n    }\\n    int find(int x, vector<int>& uf){\\n        return uf[x]==x?x:uf[x]=find(uf[x],uf);\\n    }\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int> uf(n*m+1),sizes(n*m+1,1);\\n        for(int i=0;i<=n*m;i++){\\n            uf[i]=i;\\n        }\\n        for(auto& h:hits){\\n            if(grid[h[0]][h[1]]==1){\\n                grid[h[0]][h[1]]=0;\\n            }else{\\n                h[0]=h[1]=-1;\\n            }\\n        }\\n        int dr[]={-1,0,1,0},dc[]={0,1,0,-1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    if(i==0){\\n                        merge(i*m+j,n*m,uf,sizes);\\n                    }\\n                    for(int k=0;k<4;k++){\\n                        int x=i+dr[k],y=j+dc[k];\\n                        if(0<=x && x<n && 0<=y && y<m){\\n                            if(grid[x][y]==1){\\n                                merge(i*m+j,x*m+y,uf,sizes);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int curr=sizes[find(n*m,uf)];\\n        vector<int> ans(hits.size());\\n        for(int i=hits.size()-1;i>=0;i--){\\n            auto h=hits[i];\\n            if(h[0]!=-1){\\n                grid[h[0]][h[1]]=1;\\n                if(h[0]==0){\\n                    merge(h[0]*m+h[1],n*m,uf,sizes);\\n                }\\n                for(int k=0;k<4;k++){\\n                    int x=h[0]+dr[k],y=h[1]+dc[k];\\n                    if(0<=x && x<n && 0<=y && y<m){\\n                        if(grid[x][y]==1){\\n                            merge(h[0]*m+h[1],x*m+y,uf,sizes);\\n                        }\\n                    }\\n                }\\n                int s=sizes[find(n*m,uf)];\\n                ans[i]=max(0,s-curr-1);\\n                curr=s;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tvoid merge(int x, int y, vector<int>& uf, vector<int>& sizes){\\n        int a=find(x,uf),b=find(y,uf);\\n        if(a==b){\\n            return;\\n        }\\n        uf[a]=b;\\n        sizes[b]+=sizes[a];\\n    }\\n    int find(int x, vector<int>& uf){\\n        return uf[x]==x?x:uf[x]=find(uf[x],uf);\\n    }\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int> uf(n*m+1),sizes(n*m+1,1);\\n        for(int i=0;i<=n*m;i++){\\n            uf[i]=i;\\n        }\\n        for(auto& h:hits){\\n            if(grid[h[0]][h[1]]==1){\\n                grid[h[0]][h[1]]=0;\\n            }else{\\n                h[0]=h[1]=-1;\\n            }\\n        }\\n        int dr[]={-1,0,1,0},dc[]={0,1,0,-1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    if(i==0){\\n                        merge(i*m+j,n*m,uf,sizes);\\n                    }\\n                    for(int k=0;k<4;k++){\\n                        int x=i+dr[k],y=j+dc[k];\\n                        if(0<=x && x<n && 0<=y && y<m){\\n                            if(grid[x][y]==1){\\n                                merge(i*m+j,x*m+y,uf,sizes);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int curr=sizes[find(n*m,uf)];\\n        vector<int> ans(hits.size());\\n        for(int i=hits.size()-1;i>=0;i--){\\n            auto h=hits[i];\\n            if(h[0]!=-1){\\n                grid[h[0]][h[1]]=1;\\n                if(h[0]==0){\\n                    merge(h[0]*m+h[1],n*m,uf,sizes);\\n                }\\n                for(int k=0;k<4;k++){\\n                    int x=h[0]+dr[k],y=h[1]+dc[k];\\n                    if(0<=x && x<n && 0<=y && y<m){\\n                        if(grid[x][y]==1){\\n                            merge(h[0]*m+h[1],x*m+y,uf,sizes);\\n                        }\\n                    }\\n                }\\n                int s=sizes[find(n*m,uf)];\\n                ans[i]=max(0,s-curr-1);\\n                curr=s;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1411536,
                "title": "c-union-find-solution",
                "content": "Runtime: 300 ms, faster than 90.18% of C++ online submissions for Bricks Falling When Hit.\\nMemory Usage: 105.9 MB, less than 85.09% of C++ online submissions for Bricks Falling When Hit.\\n\\n```\\nWe have to get the number of bricks fall which are not stable after each hit in the hit vector. Instead of\\nmoving from left to right we can assume the last state of hit vector in our grid and check how many\\nbricks are connected to top row using UnionFind approach. Then we move from right to left and unify\\ncurrent hit node with its neighbors and calculate the node count connected  to top row. The difference\\nbetween previous node count and current node count is the number of bricks which will fall in the current\\niteration if current brick is hit. Also we deduct 1 from the difference cause brick that we hit also falls. We\\nalso make copy of given initial grid to perform UnionFind operations so that we can track if there is a hit\\nin an empty space cause then there will be no effect in result which means 0 and so we ignored that hit.  \\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // row and col child offset\\n    int rowchild[4] = {-1,1,0,0};\\n    int colchild[4] = {0,0,1,-1};\\n    \\n    // disjoint set parent track\\n    int mat[40001];\\n    \\n    // disjoint set size\\n    int mat_s[40001];\\n    \\n    // grid row and col size\\n    int row,col;\\n    \\n    // node count connected to top row\\n    int top_count;\\n    \\n    // track nodes of top row already taken\\n    bitset<201>top_nodes;\\n    \\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        \\n        row = grid.size();\\n        col = grid[0].size();\\n        int n = hits.size();\\n        int total = row * col;\\n        top_count = 0;\\n        \\n        // reset all top row track bit\\n        for(int i=0;i<col;i++)top_nodes[i] = 0;\\n        \\n        // all node is parent to itself and has size 1\\n        for(int i=0;i<total;i++)mat[i]=-1,mat_s[i]=1;\\n\\n        // create new grid of same size to perform union find operation\\n        vector<vector<int>>ngrid(row,vector<int>(col));\\n        ngrid = grid;\\n        \\n        // make all hits position 0 in the grid \\n        for(int i=0;i<n;i++)ngrid[hits[i][0]][hits[i][1]] = 0;\\n        \\n        // result vector\\n        vector<int>res(n,0);\\n        \\n        // loop through the grid and perform union find for bricks node with neighbors\\n        // we assign min parent as the parent of max parent node only if they are not both in top row\\n        for(int i=row-1;i>=0;i--)\\n        {\\n            for(int j=col-1;j>=0;j--)\\n            {\\n                if(ngrid[i][j])\\n                    unifyNeighbor(ngrid,i,j);   // Unify current node with brick neighbors \\n            }\\n        }\\n        \\n        // number of node connected to top row after ith operation        \\n        int top_s = top_count;\\n        int nx,ny;\\n        \\n        // We move from right to left of hits vector and mark current hit pos as brick node\\n        // do union find over its neighbor and update top_count\\n        // diff between prev top_count and current top_count is the number of bricks which fallen\\n        // if given grid has no brick in hit position then nothing to fall and so we ignore the step \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            nx = hits[i][0];\\n            ny = hits[i][1];\\n\\n            if(grid[nx][ny]==0)continue;\\n            else\\n            {\\n                // Unify current node with brick neighbors \\n                unifyNeighbor(ngrid,nx,ny);\\n\\n                ngrid[nx][ny] = 1;\\n                \\n                // fallen brick = current top_count - prev top_count - 1\\n                res[i] = max(0,top_count-top_s-1);\\n                top_s = top_count;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // Unify current node with brick neighbors \\n    void unifyNeighbor(vector<vector<int>>&ngrid, int x, int y)\\n    {\\n        int t,p,px,py;\\n        p = t = x * col + y;\\n\\n        for(int k=0;k<4;k++)\\n        {\\n            px = x + rowchild[k];\\n            py = y + colchild[k];\\n            if(px>=0 && px<row && py>=0 && py<col && ngrid[px][py]==1)\\n            {\\n                int v = unify(px*col+py,t,true);\\n                if(v!=-1) t = v;\\n            }\\n        }\\n\\n        // if current node is in top row and not yet taken \\n        // then we update top_count and mark node as taken\\n        // this happens when current top row brick has no neighbor brick                 \\n        if(p<col && top_nodes[p]==0)top_count+=mat_s[p],top_nodes[p]=1;\\n    }\\n    \\n    \\n    // find the parent of the node and do path compression recursively\\n    // if node parent is -1 then node is parent itself\\n    int find(int t)\\n    {\\n        if((mat[t]<0 || t == mat[t]))return t;\\n        \\n        return mat[t] = find(mat[t]);        \\n    }\\n    \\n    // unify node t1 and t2 if they have diff parent or their both parents do not fall in top row\\n    // we assign min parent as parent of max parent node and update size of min parent node\\n    // if min parent node fall in top row then we update top_count \\n    // if min parent node not already taken we directly add the size and mark it as taken\\n    // otherwise we have to deduct the prev min parent size from top_count and then update with new value\\n    int unify(int t1, int t2, bool flag =false)\\n    {\\n        int p1 = find(t1);\\n        int p2 = find(t2);\\n        \\n        // if same parent or both parent in top row then do not unify\\n        if(p1==p2 || (p1<col && p2<col)) return -1;        \\n        \\n        int parent = min(p1,p2);\\n        int child = max(p1,p2);\\n        mat[child] = parent;\\n        \\n        // parent in top row and already taken then deduct prev size from top_count\\n        if(parent<col && top_nodes[parent])top_count-=mat_s[parent];\\n        \\n        // update parent size with child size\\n        mat_s[parent]+=mat_s[child];  \\n        \\n        // parent in top row and so update top_count with latest parent size\\n        if(parent<col)top_count+=mat_s[parent],top_nodes[parent]=1;\\n                    \\n        return parent;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nWe have to get the number of bricks fall which are not stable after each hit in the hit vector. Instead of\\nmoving from left to right we can assume the last state of hit vector in our grid and check how many\\nbricks are connected to top row using UnionFind approach. Then we move from right to left and unify\\ncurrent hit node with its neighbors and calculate the node count connected  to top row. The difference\\nbetween previous node count and current node count is the number of bricks which will fall in the current\\niteration if current brick is hit. Also we deduct 1 from the difference cause brick that we hit also falls. We\\nalso make copy of given initial grid to perform UnionFind operations so that we can track if there is a hit\\nin an empty space cause then there will be no effect in result which means 0 and so we ignored that hit.  \\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // row and col child offset\\n    int rowchild[4] = {-1,1,0,0};\\n    int colchild[4] = {0,0,1,-1};\\n    \\n    // disjoint set parent track\\n    int mat[40001];\\n    \\n    // disjoint set size\\n    int mat_s[40001];\\n    \\n    // grid row and col size\\n    int row,col;\\n    \\n    // node count connected to top row\\n    int top_count;\\n    \\n    // track nodes of top row already taken\\n    bitset<201>top_nodes;\\n    \\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        \\n        row = grid.size();\\n        col = grid[0].size();\\n        int n = hits.size();\\n        int total = row * col;\\n        top_count = 0;\\n        \\n        // reset all top row track bit\\n        for(int i=0;i<col;i++)top_nodes[i] = 0;\\n        \\n        // all node is parent to itself and has size 1\\n        for(int i=0;i<total;i++)mat[i]=-1,mat_s[i]=1;\\n\\n        // create new grid of same size to perform union find operation\\n        vector<vector<int>>ngrid(row,vector<int>(col));\\n        ngrid = grid;\\n        \\n        // make all hits position 0 in the grid \\n        for(int i=0;i<n;i++)ngrid[hits[i][0]][hits[i][1]] = 0;\\n        \\n        // result vector\\n        vector<int>res(n,0);\\n        \\n        // loop through the grid and perform union find for bricks node with neighbors\\n        // we assign min parent as the parent of max parent node only if they are not both in top row\\n        for(int i=row-1;i>=0;i--)\\n        {\\n            for(int j=col-1;j>=0;j--)\\n            {\\n                if(ngrid[i][j])\\n                    unifyNeighbor(ngrid,i,j);   // Unify current node with brick neighbors \\n            }\\n        }\\n        \\n        // number of node connected to top row after ith operation        \\n        int top_s = top_count;\\n        int nx,ny;\\n        \\n        // We move from right to left of hits vector and mark current hit pos as brick node\\n        // do union find over its neighbor and update top_count\\n        // diff between prev top_count and current top_count is the number of bricks which fallen\\n        // if given grid has no brick in hit position then nothing to fall and so we ignore the step \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            nx = hits[i][0];\\n            ny = hits[i][1];\\n\\n            if(grid[nx][ny]==0)continue;\\n            else\\n            {\\n                // Unify current node with brick neighbors \\n                unifyNeighbor(ngrid,nx,ny);\\n\\n                ngrid[nx][ny] = 1;\\n                \\n                // fallen brick = current top_count - prev top_count - 1\\n                res[i] = max(0,top_count-top_s-1);\\n                top_s = top_count;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // Unify current node with brick neighbors \\n    void unifyNeighbor(vector<vector<int>>&ngrid, int x, int y)\\n    {\\n        int t,p,px,py;\\n        p = t = x * col + y;\\n\\n        for(int k=0;k<4;k++)\\n        {\\n            px = x + rowchild[k];\\n            py = y + colchild[k];\\n            if(px>=0 && px<row && py>=0 && py<col && ngrid[px][py]==1)\\n            {\\n                int v = unify(px*col+py,t,true);\\n                if(v!=-1) t = v;\\n            }\\n        }\\n\\n        // if current node is in top row and not yet taken \\n        // then we update top_count and mark node as taken\\n        // this happens when current top row brick has no neighbor brick                 \\n        if(p<col && top_nodes[p]==0)top_count+=mat_s[p],top_nodes[p]=1;\\n    }\\n    \\n    \\n    // find the parent of the node and do path compression recursively\\n    // if node parent is -1 then node is parent itself\\n    int find(int t)\\n    {\\n        if((mat[t]<0 || t == mat[t]))return t;\\n        \\n        return mat[t] = find(mat[t]);        \\n    }\\n    \\n    // unify node t1 and t2 if they have diff parent or their both parents do not fall in top row\\n    // we assign min parent as parent of max parent node and update size of min parent node\\n    // if min parent node fall in top row then we update top_count \\n    // if min parent node not already taken we directly add the size and mark it as taken\\n    // otherwise we have to deduct the prev min parent size from top_count and then update with new value\\n    int unify(int t1, int t2, bool flag =false)\\n    {\\n        int p1 = find(t1);\\n        int p2 = find(t2);\\n        \\n        // if same parent or both parent in top row then do not unify\\n        if(p1==p2 || (p1<col && p2<col)) return -1;        \\n        \\n        int parent = min(p1,p2);\\n        int child = max(p1,p2);\\n        mat[child] = parent;\\n        \\n        // parent in top row and already taken then deduct prev size from top_count\\n        if(parent<col && top_nodes[parent])top_count-=mat_s[parent];\\n        \\n        // update parent size with child size\\n        mat_s[parent]+=mat_s[child];  \\n        \\n        // parent in top row and so update top_count with latest parent size\\n        if(parent<col)top_count+=mat_s[parent],top_nodes[parent]=1;\\n                    \\n        return parent;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335706,
                "title": "javascript-dfs-248ms-71-43",
                "content": "reference: https://leetcode.com/problems/bricks-falling-when-hit/discuss/119829/Python-Solution-by-reversely-adding-hits-bricks-back\\n```\\nlet g, n, m;\\nconst hitBricks = (grid, hits) => {\\n    g = grid;\\n    n = g.length;\\n    m = g[0].length;\\n    let brick = [];\\n    for (const [x, y] of hits) { // Mark whether there is a brick at the each hit\\n        brick.push(g[x][y] == 1);\\n        g[x][y] = 0;\\n    }\\n    for (let i = 1; i < n; i++) { // Get grid after all hits\\n        for (let j = 0; j < m; j++) {\\n            if (g[i][j] == 1) g[i][j] = 2;\\n        }\\n    }\\n    for (let j = 0; j < m; j++) { // Get grid after all hits\\n        if (g[0][j] == 1) dfs(0, j);\\n    }\\n    let res = Array(hits.length).fill(0);\\n    for (let i = hits.length - 1; ~i; i--) { // Reversely add the block of each hits and get count of newly add bricks\\n        let [x, y] = hits[i];\\n        if (brick[i]) {\\n            g[x][y] = 2;\\n            if (!is_connected(x, y)) continue;\\n            res[i] = dfs(x, y) - 1;\\n        }\\n    }\\n    return res;\\n};\\nconst is_connected = (i, j) => { // Check whether (i, j) is connected to Not Falling Bricks\\n    return i == 0 || have(i, j - 1) || have(i, j + 1) || have(i - 1, j) || have(i + 1, j);\\n};\\n\\nconst have = (i, j) => {\\n    if (i < 0 || i >= n || j < 0 || j >= m || g[i][j] != 3) return false;\\n    return true;\\n};\\n\\nconst dfs = (i, j) => { // Connect unconnected bricks\\n    if (i < 0 || i >= n || j < 0 || j >= m || ((g[i][j] + 1) >> 1) != 1) return 0;\\n    g[i][j] = 3;\\n    let res = 1;\\n    res += dfs(i, j - 1);\\n    res += dfs(i, j + 1);\\n    res += dfs(i - 1, j);\\n    res += dfs(i + 1, j);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nlet g, n, m;\\nconst hitBricks = (grid, hits) => {\\n    g = grid;\\n    n = g.length;\\n    m = g[0].length;\\n    let brick = [];\\n    for (const [x, y] of hits) { // Mark whether there is a brick at the each hit\\n        brick.push(g[x][y] == 1);\\n        g[x][y] = 0;\\n    }\\n    for (let i = 1; i < n; i++) { // Get grid after all hits\\n        for (let j = 0; j < m; j++) {\\n            if (g[i][j] == 1) g[i][j] = 2;\\n        }\\n    }\\n    for (let j = 0; j < m; j++) { // Get grid after all hits\\n        if (g[0][j] == 1) dfs(0, j);\\n    }\\n    let res = Array(hits.length).fill(0);\\n    for (let i = hits.length - 1; ~i; i--) { // Reversely add the block of each hits and get count of newly add bricks\\n        let [x, y] = hits[i];\\n        if (brick[i]) {\\n            g[x][y] = 2;\\n            if (!is_connected(x, y)) continue;\\n            res[i] = dfs(x, y) - 1;\\n        }\\n    }\\n    return res;\\n};\\nconst is_connected = (i, j) => { // Check whether (i, j) is connected to Not Falling Bricks\\n    return i == 0 || have(i, j - 1) || have(i, j + 1) || have(i - 1, j) || have(i + 1, j);\\n};\\n\\nconst have = (i, j) => {\\n    if (i < 0 || i >= n || j < 0 || j >= m || g[i][j] != 3) return false;\\n    return true;\\n};\\n\\nconst dfs = (i, j) => { // Connect unconnected bricks\\n    if (i < 0 || i >= n || j < 0 || j >= m || ((g[i][j] + 1) >> 1) != 1) return 0;\\n    g[i][j] = 3;\\n    let res = 1;\\n    res += dfs(i, j - 1);\\n    res += dfs(i, j + 1);\\n    res += dfs(i - 1, j);\\n    res += dfs(i + 1, j);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1265934,
                "title": "java-union-find",
                "content": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n    int[] up;\\n    int m;\\n    int n;\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        \\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        // mark all hits -1\\n        for (int[] hit: hits) grid[hit[0]][hit[1]] *= -1;\\n        \\n        up = new int[m * n + 1]; // the extra index m*n is the father of all bricks on the roof\\n        Arrays.fill(up, -1);\\n        \\n        for (int j = 0; j < n; j++) {\\n            if (grid[0][j] == 1) union(m * n, j);\\n        }\\n        \\n        // group adjacent 1\\'s to create islands to start with\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] != 1) continue;\\n                for (int d = 0; d < 2; d++) {\\n                    int r = i + dirs[d][0];\\n                    int c = j + dirs[d][1];\\n                    if (r < 0 || c < 0) continue;\\n                    if (grid[r][c] != 1) continue;\\n                    int p1 = find(r * n + c);\\n                    int p2 = find(i * n + j);\\n                    if (p1 != p2) union(p1, p2);\\n                }\\n            }\\n        }\\n        \\n        int[] res = new int[hits.length];\\n        for (int k = hits.length - 1; k >= 0; k--) {\\n            int x = hits[k][0];\\n            int y = hits[k][1];\\n            if (grid[x][y] != -1) continue;\\n            grid[x][y] = 1;\\n            boolean flag = false;\\n            if (x == 0) { // if a brick on the roof is hit\\n                flag = true;\\n                union(find(x * n + y), m * n);\\n            }\\n            int count = 0;\\n            for (int d = 0; d < 4; d++) {\\n                int r = x + dirs[d][0];\\n                int c = y + dirs[d][1];\\n                if (r >= m || c >= n || r < 0 || c < 0) continue;\\n                if (grid[r][c] == 1) {\\n                    int p1 = find(x * n + y);\\n                    int p2 = find(r * n + c);\\n                    if (p1 != p2) {\\n                        if (p2 != m * n) { // it is not attached to roof, then update count\\n                            count += up[p2];\\n                        } else { // it is part of roof, then set flag true\\n                            flag = true;\\n                        }\\n                        union(p1, p2);   \\n                    }\\n                }\\n            }\\n            if (flag) res[k] = -count;\\n        }\\n        return res;\\n    }\\n    \\n    private int find(int x) {\\n        int r = x;\\n        while (up[r] >= 0) {\\n            r = up[r];\\n        }\\n        if (r == x) return r;\\n        int p = up[x];\\n        while (p >= 0) {\\n            up[x] = r;\\n            x = p;\\n            p = up[x];\\n        }\\n        return r; \\n    }\\n    \\n    private void union(int x, int y) {\\n        if (x != m * n && y != m * n) {\\n            if (up[x] > up[y]) {\\n                up[y] += up[x];\\n                up[x] = y;\\n            } else {\\n                up[x] += up[y];\\n                up[y] = x;\\n            }\\n        } else {\\n            if (y == m * n) {\\n                up[y] += up[x];\\n                up[x] = y;\\n            } else {\\n                up[x] += up[y];\\n                up[y] = x; \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n    int[] up;\\n    int m;\\n    int n;\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        \\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        // mark all hits -1\\n        for (int[] hit: hits) grid[hit[0]][hit[1]] *= -1;\\n        \\n        up = new int[m * n + 1]; // the extra index m*n is the father of all bricks on the roof\\n        Arrays.fill(up, -1);\\n        \\n        for (int j = 0; j < n; j++) {\\n            if (grid[0][j] == 1) union(m * n, j);\\n        }\\n        \\n        // group adjacent 1\\'s to create islands to start with\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] != 1) continue;\\n                for (int d = 0; d < 2; d++) {\\n                    int r = i + dirs[d][0];\\n                    int c = j + dirs[d][1];\\n                    if (r < 0 || c < 0) continue;\\n                    if (grid[r][c] != 1) continue;\\n                    int p1 = find(r * n + c);\\n                    int p2 = find(i * n + j);\\n                    if (p1 != p2) union(p1, p2);\\n                }\\n            }\\n        }\\n        \\n        int[] res = new int[hits.length];\\n        for (int k = hits.length - 1; k >= 0; k--) {\\n            int x = hits[k][0];\\n            int y = hits[k][1];\\n            if (grid[x][y] != -1) continue;\\n            grid[x][y] = 1;\\n            boolean flag = false;\\n            if (x == 0) { // if a brick on the roof is hit\\n                flag = true;\\n                union(find(x * n + y), m * n);\\n            }\\n            int count = 0;\\n            for (int d = 0; d < 4; d++) {\\n                int r = x + dirs[d][0];\\n                int c = y + dirs[d][1];\\n                if (r >= m || c >= n || r < 0 || c < 0) continue;\\n                if (grid[r][c] == 1) {\\n                    int p1 = find(x * n + y);\\n                    int p2 = find(r * n + c);\\n                    if (p1 != p2) {\\n                        if (p2 != m * n) { // it is not attached to roof, then update count\\n                            count += up[p2];\\n                        } else { // it is part of roof, then set flag true\\n                            flag = true;\\n                        }\\n                        union(p1, p2);   \\n                    }\\n                }\\n            }\\n            if (flag) res[k] = -count;\\n        }\\n        return res;\\n    }\\n    \\n    private int find(int x) {\\n        int r = x;\\n        while (up[r] >= 0) {\\n            r = up[r];\\n        }\\n        if (r == x) return r;\\n        int p = up[x];\\n        while (p >= 0) {\\n            up[x] = r;\\n            x = p;\\n            p = up[x];\\n        }\\n        return r; \\n    }\\n    \\n    private void union(int x, int y) {\\n        if (x != m * n && y != m * n) {\\n            if (up[x] > up[y]) {\\n                up[y] += up[x];\\n                up[x] = y;\\n            } else {\\n                up[x] += up[y];\\n                up[y] = x;\\n            }\\n        } else {\\n            if (y == m * n) {\\n                up[y] += up[x];\\n                up[x] = y;\\n            } else {\\n                up[x] += up[y];\\n                up[y] = x; \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264401,
                "title": "java-dfs-94",
                "content": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    int m;\\n    int n;\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        preprocess(grid, hits);\\n        \\n        int[] res = new int[hits.length];\\n        \\n        for (int k = hits.length - 1; k >= 0; k--) {\\n            int x = hits[k][0];\\n            int y = hits[k][1];\\n            if (grid[x][y] == 0) continue;\\n            grid[x][y] = 1;\\n            if(!isAttachedToRoof(x, y, grid)) continue;\\n            grid[x][y] = 2;\\n            for (int d = 0; d < dirs.length; d++) {\\n                int r = x + dirs[d][0];\\n                int c = y + dirs[d][1];\\n                if (r >= m || c >= n || r < 0 || c < 0) continue;\\n                if (grid[r][c] == 1) res[k] += dfs(grid, r, c);\\n            }  \\n        }\\n        return res;\\n    }\\n    \\n    \\n    private void preprocess(int[][] grid, int[][] hits) {\\n        // erase all bricks knocked off by hits\\n        for (int[] hit: hits) {\\n            grid[hit[0]][hit[1]] *= -1;\\n        }\\n        \\n        // preprocess mark all bricks attached to top with number 2\\n        for (int j = 0; j < n; j++) {\\n            if (grid[0][j] == 1) dfs(grid, 0, j);\\n        }\\n    }\\n    \\n    // return true if an erased brick is attached to roof\\n    private boolean isAttachedToRoof(int x, int y, int[][] grid) {\\n        if (x == 0) return true;\\n        for (int d = 0; d < dirs.length; d++) {\\n                int r = x + dirs[d][0];\\n                int c = y + dirs[d][1];\\n                if (r >= m || c >= n || r < 0 || c < 0) continue;\\n                if (grid[r][c] == 2) return true;\\n        }\\n        return false;\\n    }\\n\\n    // as iterating over all cells, mark them from 1 to 2\\n    private int dfs(int[][] grid, int x, int y) {\\n        int count = 1;\\n        grid[x][y] = 2;\\n        for (int d = 0; d < dirs.length; d++) {\\n            int r = x + dirs[d][0];\\n            int c = y + dirs[d][1];\\n            if (r >= m || c >= n || r < 0 || c < 0) continue;\\n            if (grid[r][c] == 1) {\\n                count += dfs(grid, r, c);          \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    int m;\\n    int n;\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        preprocess(grid, hits);\\n        \\n        int[] res = new int[hits.length];\\n        \\n        for (int k = hits.length - 1; k >= 0; k--) {\\n            int x = hits[k][0];\\n            int y = hits[k][1];\\n            if (grid[x][y] == 0) continue;\\n            grid[x][y] = 1;\\n            if(!isAttachedToRoof(x, y, grid)) continue;\\n            grid[x][y] = 2;\\n            for (int d = 0; d < dirs.length; d++) {\\n                int r = x + dirs[d][0];\\n                int c = y + dirs[d][1];\\n                if (r >= m || c >= n || r < 0 || c < 0) continue;\\n                if (grid[r][c] == 1) res[k] += dfs(grid, r, c);\\n            }  \\n        }\\n        return res;\\n    }\\n    \\n    \\n    private void preprocess(int[][] grid, int[][] hits) {\\n        // erase all bricks knocked off by hits\\n        for (int[] hit: hits) {\\n            grid[hit[0]][hit[1]] *= -1;\\n        }\\n        \\n        // preprocess mark all bricks attached to top with number 2\\n        for (int j = 0; j < n; j++) {\\n            if (grid[0][j] == 1) dfs(grid, 0, j);\\n        }\\n    }\\n    \\n    // return true if an erased brick is attached to roof\\n    private boolean isAttachedToRoof(int x, int y, int[][] grid) {\\n        if (x == 0) return true;\\n        for (int d = 0; d < dirs.length; d++) {\\n                int r = x + dirs[d][0];\\n                int c = y + dirs[d][1];\\n                if (r >= m || c >= n || r < 0 || c < 0) continue;\\n                if (grid[r][c] == 2) return true;\\n        }\\n        return false;\\n    }\\n\\n    // as iterating over all cells, mark them from 1 to 2\\n    private int dfs(int[][] grid, int x, int y) {\\n        int count = 1;\\n        grid[x][y] = 2;\\n        for (int d = 0; d < dirs.length; d++) {\\n            int r = x + dirs[d][0];\\n            int c = y + dirs[d][1];\\n            if (r >= m || c >= n || r < 0 || c < 0) continue;\\n            if (grid[r][c] == 1) {\\n                count += dfs(grid, r, c);          \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174992,
                "title": "doubt",
                "content": "The test case:\\n```\\n[[1 ,1 ,1 ,0 ], [1 ,1 ,0 ,0 ]]\\nhits - [[0,1]]\\n```\\n\\nWhat should be the answer for this test case?\\nI am getting it to be 1 but according to leetcode it is 0",
                "solutionTags": [],
                "code": "```\\n[[1 ,1 ,1 ,0 ], [1 ,1 ,0 ,0 ]]\\nhits - [[0,1]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1111432,
                "title": "golang-disjoint-set-solution-with-inline-explains",
                "content": "```\\nfunc hitBricks (grid [][]int, hits [][]int) []int {\\n    WALL := [2]int{-1, -1}\\n    connections := [][]int{{1,0},{-1,0},{0,1},{0,-1}}\\n    father := make(map[[2]int][2]int)\\n    sizeofSet := make(map[[2]int]int)\\n\\n    //remove all hits bricks\\n    for _, hit := range hits {\\n        grid[hit[0]][hit[1]]--\\n    }\\n    //add WALL into disjoint set\\n    add(father, WALL, sizeofSet)\\n\\n    //add all bricks into disjoint set\\n    for i := 0; i < len(grid); i++ {\\n        for j := 0; j < len(grid[0]); j++ {\\n            if grid[i][j] == 1 {\\n                add(father, [2]int{i, j}, sizeofSet)\\n            }\\n        }\\n    }\\n\\n    //merge row 0 bricks to WALL\\n    for j := 0; j < len(grid[0]); j++ {\\n        if grid[0][j] == 1 {\\n            merge(father, [2]int{0, j}, WALL, sizeofSet)\\n        }\\n    }\\n\\n    //process row 1 to n, merge connections\\n    for i := 1; i < len(grid); i++ {\\n        for j := 0; j < len(grid[0]); j++ {\\n            if grid[i][j] == 1 {\\n                for _, connection := range connections {\\n                    if valid(grid, [2]int{i+connection[0], j+connection[1]}) {\\n                        merge(father, [2]int{i, j}, [2]int{i+connection[0], j+connection[1]}, sizeofSet)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    // fmt.Println(\"father    = \", father)\\n    // fmt.Println(\"sizeofSet = \", sizeofSet)\\n    res := make([]int, 0)\\n\\n    //process hits backwards, merge the hit brick based on connections\\n    for i := len(hits) - 1; i >= 0; i-- {\\n        before := sizeofSet[find(father, WALL)]\\n        grid[hits[i][0]][hits[i][1]]++\\n        if grid[hits[i][0]][hits[i][1]] == 1 {\\n            //add the hit back to fathers\\n            add(father, [2]int{hits[i][0], hits[i][1]}, sizeofSet)\\n            for _, connection := range connections {\\n                if valid(grid, [2]int{hits[i][0]+connection[0], hits[i][1]+connection[1]}) {\\n                    merge(father, [2]int{hits[i][0], hits[i][1]}, [2]int{hits[i][0]+connection[0], hits[i][1]+connection[1]}, sizeofSet)\\n                }\\n            }\\n            //if the hit is on row 0, remember merge it to the wall\\n            if hits[i][0] == 0 {\\n                merge(father, [2]int{hits[i][0], hits[i][1]}, WALL, sizeofSet)\\n            }\\n        }\\n        after := sizeofSet[find(father, WALL)]\\n        diff := max(0, after - before - 1)\\n        res = append(res, diff)\\n    }\\n    result := make([]int, 0)\\n    for i := len(res) - 1; i >= 0; i-- {\\n        result = append(result, res[i])\\n    }\\n    return result\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n\\nfunc valid(grid [][]int, node [2]int)bool {\\n    if node[0] < 0 || node[0] >= len(grid) || node[1] < 0 || node[1] >= len(grid[0]) {\\n        return false\\n    }\\n    if grid[node[0]][node[1]] <= 0 {\\n        return false\\n    }\\n    return true\\n}\\n\\nfunc add(father map[[2]int][2]int, node [2]int, sizeofSet map[[2]int]int) {\\n    if _, found := father[node]; found {\\n        return\\n    }\\n    father[node] = [2]int{-2,-2}\\n    sizeofSet[node] = 1\\n    return\\n}\\n\\nfunc find(father map[[2]int][2]int, node [2]int) [2]int {\\n    root := node\\n    for father[root] != [2]int{-2,-2} {\\n        root = father[root]\\n    }\\n\\n    for node != root {\\n        origFather := father[node]\\n        father[node] = root\\n        node = origFather\\n    }\\n\\n    return root\\n}\\n\\nfunc merge(father map[[2]int][2]int, a, b [2]int, sizeofSet map[[2]int]int) {\\n    rootA := find(father, a)\\n    rootB := find(father, b)\\n    if rootA != rootB {\\n        father[rootA] = rootB\\n        sizeofSet[rootB] += sizeofSet[rootA]\\n    }\\n    return\\n}\\n\\n// func isConnected(father map[[2]int][2]int, a, b [2]int) bool {\\n//     return find(father, a) == find(father, b)\\n// }\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc hitBricks (grid [][]int, hits [][]int) []int {\\n    WALL := [2]int{-1, -1}\\n    connections := [][]int{{1,0},{-1,0},{0,1},{0,-1}}\\n    father := make(map[[2]int][2]int)\\n    sizeofSet := make(map[[2]int]int)\\n\\n    //remove all hits bricks\\n    for _, hit := range hits {\\n        grid[hit[0]][hit[1]]--\\n    }\\n    //add WALL into disjoint set\\n    add(father, WALL, sizeofSet)\\n\\n    //add all bricks into disjoint set\\n    for i := 0; i < len(grid); i++ {\\n        for j := 0; j < len(grid[0]); j++ {\\n            if grid[i][j] == 1 {\\n                add(father, [2]int{i, j}, sizeofSet)\\n            }\\n        }\\n    }\\n\\n    //merge row 0 bricks to WALL\\n    for j := 0; j < len(grid[0]); j++ {\\n        if grid[0][j] == 1 {\\n            merge(father, [2]int{0, j}, WALL, sizeofSet)\\n        }\\n    }\\n\\n    //process row 1 to n, merge connections\\n    for i := 1; i < len(grid); i++ {\\n        for j := 0; j < len(grid[0]); j++ {\\n            if grid[i][j] == 1 {\\n                for _, connection := range connections {\\n                    if valid(grid, [2]int{i+connection[0], j+connection[1]}) {\\n                        merge(father, [2]int{i, j}, [2]int{i+connection[0], j+connection[1]}, sizeofSet)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    // fmt.Println(\"father    = \", father)\\n    // fmt.Println(\"sizeofSet = \", sizeofSet)\\n    res := make([]int, 0)\\n\\n    //process hits backwards, merge the hit brick based on connections\\n    for i := len(hits) - 1; i >= 0; i-- {\\n        before := sizeofSet[find(father, WALL)]\\n        grid[hits[i][0]][hits[i][1]]++\\n        if grid[hits[i][0]][hits[i][1]] == 1 {\\n            //add the hit back to fathers\\n            add(father, [2]int{hits[i][0], hits[i][1]}, sizeofSet)\\n            for _, connection := range connections {\\n                if valid(grid, [2]int{hits[i][0]+connection[0], hits[i][1]+connection[1]}) {\\n                    merge(father, [2]int{hits[i][0], hits[i][1]}, [2]int{hits[i][0]+connection[0], hits[i][1]+connection[1]}, sizeofSet)\\n                }\\n            }\\n            //if the hit is on row 0, remember merge it to the wall\\n            if hits[i][0] == 0 {\\n                merge(father, [2]int{hits[i][0], hits[i][1]}, WALL, sizeofSet)\\n            }\\n        }\\n        after := sizeofSet[find(father, WALL)]\\n        diff := max(0, after - before - 1)\\n        res = append(res, diff)\\n    }\\n    result := make([]int, 0)\\n    for i := len(res) - 1; i >= 0; i-- {\\n        result = append(result, res[i])\\n    }\\n    return result\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n\\nfunc valid(grid [][]int, node [2]int)bool {\\n    if node[0] < 0 || node[0] >= len(grid) || node[1] < 0 || node[1] >= len(grid[0]) {\\n        return false\\n    }\\n    if grid[node[0]][node[1]] <= 0 {\\n        return false\\n    }\\n    return true\\n}\\n\\nfunc add(father map[[2]int][2]int, node [2]int, sizeofSet map[[2]int]int) {\\n    if _, found := father[node]; found {\\n        return\\n    }\\n    father[node] = [2]int{-2,-2}\\n    sizeofSet[node] = 1\\n    return\\n}\\n\\nfunc find(father map[[2]int][2]int, node [2]int) [2]int {\\n    root := node\\n    for father[root] != [2]int{-2,-2} {\\n        root = father[root]\\n    }\\n\\n    for node != root {\\n        origFather := father[node]\\n        father[node] = root\\n        node = origFather\\n    }\\n\\n    return root\\n}\\n\\nfunc merge(father map[[2]int][2]int, a, b [2]int, sizeofSet map[[2]int]int) {\\n    rootA := find(father, a)\\n    rootB := find(father, b)\\n    if rootA != rootB {\\n        father[rootA] = rootB\\n        sizeofSet[rootB] += sizeofSet[rootA]\\n    }\\n    return\\n}\\n\\n// func isConnected(father map[[2]int][2]int, a, b [2]int) bool {\\n//     return find(father, a) == find(father, b)\\n// }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1098069,
                "title": "python3-o-nm-q",
                "content": "actually `O(\\u03B1(nm)(nm+q))` but anyways\\n\\n```\\nclass DSU:\\n    \\n    def __init__(self, a):\\n        self.par = {u:u for u in a}\\n        self.size = {u:1 for u in a}\\n    \\n    \\n    def add(self, u):\\n        self.par[u] = u\\n        self.size[u] = 1\\n    \\n    \\n    def __contains__(self, u):\\n        return u in self.par\\n    \\n    \\n    def find(self, u):\\n        if self.par[u] != u:\\n            self.par[u] = self.find(self.par[u])\\n        return self.par[u]\\n        \\n    \\n    def merge(self, u, v):\\n        ROOT = self.find(u)\\n        root = self.find(v)\\n        \\n        if ROOT == root:\\n            return\\n        \\n        if self.size[root] >= self.size[ROOT]:\\n            ROOT,root = root,ROOT\\n        \\n        self.par[root] = ROOT\\n        self.size[ROOT] += self.size[root]\\n\\n\\nclass Solution:\\n    def hitBricks(self, a: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        \\n        \\n        n = len(a)\\n        m = len(a[0])\\n        \\n        def OOB(i,j):\\n            return i < 0 or i >= n or j < 0 or j >= m\\n        \\n        def children(i,j):\\n            ret = []\\n            \\n            for I,J in (i-1,j),(i+1,j),(i,j-1),(i,j+1):\\n                if I == -1:\\n                    ret.append((-1,-1))\\n                else:\\n                    if not OOB(I,J):\\n                        ret.append((I,J))\\n            \\n            return ret\\n        \\n        # preprocess hits (and post-state of a)\\n        for idx,(i,j) in enumerate(hits):\\n            if a[i][j] == 0:\\n                hits[idx] = None\\n            else:\\n                a[i][j] = 0\\n        \\n        # initialize starting nodes in DSU\\n        starting_elements = [(i,j) for i in range(n) for j in range(m) if a[i][j]]\\n        starting_elements.append((-1,-1))\\n        \\n        dsu = DSU(starting_elements)\\n        \\n        # initialize starting edges in DSU\\n        for i in range(n):\\n            for j in range(m):\\n                for I,J in children(i,j):\\n                    if (i,j) in dsu and (I,J) in dsu:\\n                        dsu.merge((i,j),(I,J))\\n        \\n        \\n        ret = [0]*len(hits)\\n        \\n        for idx,hit in reversed(list(enumerate(hits))):\\n            \\n            if hit is not None:\\n                i,j = hit\\n                \\n                dsu.add((i,j))\\n                \\n                precardinality = dsu.size[dsu.find((-1,-1))]\\n                \\n                for I,J in children(i,j):\\n                    if (I,J) in dsu:\\n                        dsu.merge((i,j), (I,J))\\n                \\n                postcardinality = dsu.size[dsu.find((-1,-1))]\\n                \\n                if postcardinality > precardinality:\\n                    ret[idx] = postcardinality - precardinality - 1\\n        \\n        \\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU:\\n    \\n    def __init__(self, a):\\n        self.par = {u:u for u in a}\\n        self.size = {u:1 for u in a}\\n    \\n    \\n    def add(self, u):\\n        self.par[u] = u\\n        self.size[u] = 1\\n    \\n    \\n    def __contains__(self, u):\\n        return u in self.par\\n    \\n    \\n    def find(self, u):\\n        if self.par[u] != u:\\n            self.par[u] = self.find(self.par[u])\\n        return self.par[u]\\n        \\n    \\n    def merge(self, u, v):\\n        ROOT = self.find(u)\\n        root = self.find(v)\\n        \\n        if ROOT == root:\\n            return\\n        \\n        if self.size[root] >= self.size[ROOT]:\\n            ROOT,root = root,ROOT\\n        \\n        self.par[root] = ROOT\\n        self.size[ROOT] += self.size[root]\\n\\n\\nclass Solution:\\n    def hitBricks(self, a: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        \\n        \\n        n = len(a)\\n        m = len(a[0])\\n        \\n        def OOB(i,j):\\n            return i < 0 or i >= n or j < 0 or j >= m\\n        \\n        def children(i,j):\\n            ret = []\\n            \\n            for I,J in (i-1,j),(i+1,j),(i,j-1),(i,j+1):\\n                if I == -1:\\n                    ret.append((-1,-1))\\n                else:\\n                    if not OOB(I,J):\\n                        ret.append((I,J))\\n            \\n            return ret\\n        \\n        # preprocess hits (and post-state of a)\\n        for idx,(i,j) in enumerate(hits):\\n            if a[i][j] == 0:\\n                hits[idx] = None\\n            else:\\n                a[i][j] = 0\\n        \\n        # initialize starting nodes in DSU\\n        starting_elements = [(i,j) for i in range(n) for j in range(m) if a[i][j]]\\n        starting_elements.append((-1,-1))\\n        \\n        dsu = DSU(starting_elements)\\n        \\n        # initialize starting edges in DSU\\n        for i in range(n):\\n            for j in range(m):\\n                for I,J in children(i,j):\\n                    if (i,j) in dsu and (I,J) in dsu:\\n                        dsu.merge((i,j),(I,J))\\n        \\n        \\n        ret = [0]*len(hits)\\n        \\n        for idx,hit in reversed(list(enumerate(hits))):\\n            \\n            if hit is not None:\\n                i,j = hit\\n                \\n                dsu.add((i,j))\\n                \\n                precardinality = dsu.size[dsu.find((-1,-1))]\\n                \\n                for I,J in children(i,j):\\n                    if (I,J) in dsu:\\n                        dsu.merge((i,j), (I,J))\\n                \\n                postcardinality = dsu.size[dsu.find((-1,-1))]\\n                \\n                if postcardinality > precardinality:\\n                    ret[idx] = postcardinality - precardinality - 1\\n        \\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810799,
                "title": "java-clear-code",
                "content": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] finalGrid = new int[m][n];\\n        \\n        for (int i = 0 ; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                finalGrid[i][j] = grid[i][j];\\n            }\\n        }\\n        for (int[] hit : hits) {\\n            finalGrid[hit[0]][hit[1]] = 0;\\n        }\\n        int[] parents = new int[m * n + 1];\\n        for (int i = 0; i < parents.length; i++) {\\n            parents[i] = i;\\n        }\\n        int[] children = new int[m*n + 1];\\n        Arrays.fill(children, 1);\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (finalGrid[i][j] == 1) {\\n                    int index = i * n + j;\\n                    if (i == 0) {\\n                        merge(parents, m*n, index, children);\\n                    } \\n                    if (i > 0 && finalGrid[i - 1][j] == 1) {\\n                        merge(parents, index, index - n, children);\\n                    } \\n                    if (j > 0 && finalGrid[i][j - 1] == 1) {\\n                        merge(parents, index, index - 1, children);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int totalLinked = children[m * n];\\n        int[] result = new int[hits.length];\\n        for (int i = hits.length - 1; i >= 0; i--) {\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            //System.out.println(\"Processing \" + i);\\n            if (finalGrid[x][y] == 0 && grid[x][y] == 1) {\\n                finalGrid[x][y] = 1;\\n                int index = x * n + y;\\n                // System.out.println(x + \" \" + y);\\n                // System.out.println(\"parents :\" + Arrays.toString(parents));\\n                // System.out.println(\"children :\" + Arrays.toString(children));\\n                if (x == 0) {\\n                    merge(parents, m*n, index, children);\\n                }\\n                if (x > 0 && finalGrid[x - 1][y] == 1) {\\n                    merge(parents, index, index - n, children);\\n                }\\n                if (y > 0 && finalGrid[x][y - 1] == 1) {\\n                    merge(parents, index, index - 1, children);\\n                }\\n                if (x < m - 1 && finalGrid[x + 1][y] == 1) {\\n                    merge(parents, index, index + n, children);\\n                }\\n                if (y < n - 1 && finalGrid[x][y + 1] == 1) {\\n                    merge(parents, index, index + 1, children);\\n                }\\n                // System.out.println(\"parents :\" + Arrays.toString(parents));\\n                // System.out.println(\"children :\" + Arrays.toString(children));\\n                int newLinkedNode = children[m * n];\\n                result[i] = Math.max(newLinkedNode - totalLinked - 1, 0);\\n                totalLinked = newLinkedNode;\\n            } else {\\n                result[i] = 0;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    int getParent(int[] parents, int i, int[] children) {\\n        if (parents[i] != i) {\\n            int parent = getParent(parents, parents[i], children);\\n            parents[i] = parent;\\n        }\\n        return parents[i];\\n    }\\n    \\n    void merge(int[] parents, int i, int j, int[] children) {\\n        int parent1 = getParent(parents, i, children);\\n        int parent2 = getParent(parents, j, children);\\n        \\n        int small = Math.min(parent2, parent1);\\n        int big = Math.max(parent2, parent1);\\n        if (parents[small] != parents[big]) {\\n            parents[small] = parents[big];\\n            children[big] += children[small];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] finalGrid = new int[m][n];\\n        \\n        for (int i = 0 ; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                finalGrid[i][j] = grid[i][j];\\n            }\\n        }\\n        for (int[] hit : hits) {\\n            finalGrid[hit[0]][hit[1]] = 0;\\n        }\\n        int[] parents = new int[m * n + 1];\\n        for (int i = 0; i < parents.length; i++) {\\n            parents[i] = i;\\n        }\\n        int[] children = new int[m*n + 1];\\n        Arrays.fill(children, 1);\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (finalGrid[i][j] == 1) {\\n                    int index = i * n + j;\\n                    if (i == 0) {\\n                        merge(parents, m*n, index, children);\\n                    } \\n                    if (i > 0 && finalGrid[i - 1][j] == 1) {\\n                        merge(parents, index, index - n, children);\\n                    } \\n                    if (j > 0 && finalGrid[i][j - 1] == 1) {\\n                        merge(parents, index, index - 1, children);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int totalLinked = children[m * n];\\n        int[] result = new int[hits.length];\\n        for (int i = hits.length - 1; i >= 0; i--) {\\n            int x = hits[i][0];\\n            int y = hits[i][1];\\n            //System.out.println(\"Processing \" + i);\\n            if (finalGrid[x][y] == 0 && grid[x][y] == 1) {\\n                finalGrid[x][y] = 1;\\n                int index = x * n + y;\\n                // System.out.println(x + \" \" + y);\\n                // System.out.println(\"parents :\" + Arrays.toString(parents));\\n                // System.out.println(\"children :\" + Arrays.toString(children));\\n                if (x == 0) {\\n                    merge(parents, m*n, index, children);\\n                }\\n                if (x > 0 && finalGrid[x - 1][y] == 1) {\\n                    merge(parents, index, index - n, children);\\n                }\\n                if (y > 0 && finalGrid[x][y - 1] == 1) {\\n                    merge(parents, index, index - 1, children);\\n                }\\n                if (x < m - 1 && finalGrid[x + 1][y] == 1) {\\n                    merge(parents, index, index + n, children);\\n                }\\n                if (y < n - 1 && finalGrid[x][y + 1] == 1) {\\n                    merge(parents, index, index + 1, children);\\n                }\\n                // System.out.println(\"parents :\" + Arrays.toString(parents));\\n                // System.out.println(\"children :\" + Arrays.toString(children));\\n                int newLinkedNode = children[m * n];\\n                result[i] = Math.max(newLinkedNode - totalLinked - 1, 0);\\n                totalLinked = newLinkedNode;\\n            } else {\\n                result[i] = 0;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    int getParent(int[] parents, int i, int[] children) {\\n        if (parents[i] != i) {\\n            int parent = getParent(parents, parents[i], children);\\n            parents[i] = parent;\\n        }\\n        return parents[i];\\n    }\\n    \\n    void merge(int[] parents, int i, int j, int[] children) {\\n        int parent1 = getParent(parents, i, children);\\n        int parent2 = getParent(parents, j, children);\\n        \\n        int small = Math.min(parent2, parent1);\\n        int big = Math.max(parent2, parent1);\\n        if (parents[small] != parents[big]) {\\n            parents[small] = parents[big];\\n            children[big] += children[small];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 792183,
                "title": "java-reversed-dfs",
                "content": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int[] res = new int[hits.length];\\n\\n        // step-1\\n        for(int[] hit: hits) grid[hit[0]][hit[1]] -= 1;\\n        // step-2   mark all 1s to 2\\n        for(int j=0; j<grid[0].length; j++){\\n            if(grid[0][j] > 0) dfs(0, j, grid);  // O(N^2)\\n        }\\n        // step-3   O(N^2)\\n        for(int k=hits.length-1; k>-1; k--){\\n            int[] hit = hits[k];\\n            grid[hit[0]][hit[1]] += 1;\\n            if(grid[hit[0]][hit[1]] == 1 && check(hit[0], hit[1], grid)){\\n                res[k] = dfs(hit[0], hit[1], grid) - 1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(int i, int j, int[][] grid){\\n        if((i<0 || i>=grid.length) || (j<0 || j>=grid[0].length) || (grid[i][j] != 1)) return 0;\\n        grid[i][j] = 2;\\n        int cnt = 1;\\n        for(int[] nxt: new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}) cnt += dfs(i+nxt[0], j+nxt[1], grid);\\n        return cnt;\\n    }\\n    \\n    private boolean check(int i, int j, int[][] grid){\\n        for(int[] nxt: new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0,-1}}){\\n            if((i+nxt[0]>=0 && i+nxt[0]<grid.length) && (j+nxt[1]>=0 && j+nxt[1]<grid[0].length) && grid[i+nxt[0]][j+nxt[1]] == 2) return true;\\n        }\\n        return i==0;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int[] res = new int[hits.length];\\n\\n        // step-1\\n        for(int[] hit: hits) grid[hit[0]][hit[1]] -= 1;\\n        // step-2   mark all 1s to 2\\n        for(int j=0; j<grid[0].length; j++){\\n            if(grid[0][j] > 0) dfs(0, j, grid);  // O(N^2)\\n        }\\n        // step-3   O(N^2)\\n        for(int k=hits.length-1; k>-1; k--){\\n            int[] hit = hits[k];\\n            grid[hit[0]][hit[1]] += 1;\\n            if(grid[hit[0]][hit[1]] == 1 && check(hit[0], hit[1], grid)){\\n                res[k] = dfs(hit[0], hit[1], grid) - 1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(int i, int j, int[][] grid){\\n        if((i<0 || i>=grid.length) || (j<0 || j>=grid[0].length) || (grid[i][j] != 1)) return 0;\\n        grid[i][j] = 2;\\n        int cnt = 1;\\n        for(int[] nxt: new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}) cnt += dfs(i+nxt[0], j+nxt[1], grid);\\n        return cnt;\\n    }\\n    \\n    private boolean check(int i, int j, int[][] grid){\\n        for(int[] nxt: new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0,-1}}){\\n            if((i+nxt[0]>=0 && i+nxt[0]<grid.length) && (j+nxt[1]>=0 && j+nxt[1]<grid[0].length) && grid[i+nxt[0]][j+nxt[1]] == 2) return true;\\n        }\\n        return i==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772285,
                "title": "c-union-find",
                "content": "```\\nclass UnionFindSet{\\npublic:\\n    UnionFindSet(int n) {\\n        rank = vector<int> (n);\\n        parent = vector<int> (n);\\n        count = vector<int> (n, 1);\\n        for(int i = 0; i < n; ++i)\\n            parent[i] = i;\\n    }\\n    \\n    bool Union(int i, int j) {\\n        int pi = Find(i);\\n        int pj = Find(j);\\n        \\n        if(pi == pj)\\n            return(false);\\n        int ri = rank[pi];\\n        int rj = rank[pj];\\n        \\n        if(ri < rj) {\\n            parent[pi] = pj;\\n            count[pj] += count[pi];\\n        } else if(rj < ri) {\\n            parent[pj] = pi;\\n            count[pi] += count[pj];\\n        } else {\\n            rank[i]++;\\n            parent[pj] = pi;\\n            count[pi] += count[pj];\\n        }\\n        \\n        return(true);\\n    }\\n    \\n    int Find(int i) {\\n        int pi = parent[i];\\n        \\n        if(pi != i) \\n            parent[i] = Find(pi);\\n        \\n        return(parent[i]);\\n    }\\n    \\n    int Count(int i) {\\n        int pi = Find(i);\\n        \\n        return(count[pi]);\\n    }\\n    \\nprivate:\\n    vector<int> rank;\\n    vector<int> parent;\\n    vector<int> count;\\n}\\n;\\n\\nclass Solution {\\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        int k = hits.size();\\n        vector<int> ret(k, 0);\\n        int m = grid.size();\\n        if(m <= 0)\\n            return(ret);\\n        int n = grid[0].size();\\n        \\n        int ceil = m * n;\\n        int N = m * n + 1;\\n        \\n        UnionFindSet UF = UnionFindSet(N);\\n        \\n        vector<int> is_valid_hit(k , false);\\n        // remove all hits values\\n        for(int i = 0; i < k; ++i) {\\n            auto e = hits[i];\\n            \\n            if(grid[e[0]][e[1]]) {\\n                is_valid_hit[i] = 1;\\n                grid[e[0]][e[1]] = 0;\\n            }\\n            \\n        }\\n        \\n        // add all top most grid with values\\n        for(int j = 0; j < n; ++j) {\\n            if(grid[0][j]) {\\n                UF.Union(ceil, j);\\n            }\\n                \\n        }\\n        \\n        \\n        \\n        \\n        \\n        vector<int> dx = {1, 0, -1, 0};\\n        vector<int> dy = {0, 1, 0, -1};\\n        \\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(grid[i][j]) {\\n                    int cur_index =  i * n + j;\\n                    \\n                    for(int dir = 0; dir < 4; ++dir) {\\n                        int x = i + dx[dir];\\n                        int y = j + dy[dir];\\n                \\n                        if(x < 0 || y < 0 || x >= m || y >= n || grid[x][y] == 0)\\n                            continue;\\n                \\n                         int nxt_index = x * n + y;\\n                \\n                        (void) UF.Union(cur_index, nxt_index);\\n                     }\\n                }\\n            }\\n        }\\n        \\n        int prv_size = UF.Count(ceil);\\n        for(int i = k - 1; i >= 0; --i) {\\n            if(!is_valid_hit[i])\\n                continue;\\n            \\n            int ki = hits[i][0];\\n            int kj = hits[i][1];\\n            grid[ki][kj] = 1;\\n            int cur_index = ki * n + kj;\\n            if(ki == 0)\\n                (void) UF.Union(cur_index, ceil);\\n            \\n            for(int dir = 0; dir < 4; ++dir) {\\n                int x = ki + dx[dir];\\n                int y = kj + dy[dir];\\n                \\n                if(x < 0 || y < 0 || x >= m || y >= n || grid[x][y] == 0)\\n                    continue;\\n                \\n                int nxt_index = x * n + y;\\n                \\n                (void) UF.Union(cur_index, nxt_index);\\n            }\\n            \\n            int tmp_size = UF.Count(ceil);\\n            if(tmp_size > prv_size)\\n                ret[i] = tmp_size - prv_size - 1;\\n            \\n            prv_size = tmp_size;\\n        }\\n        \\n        return(ret);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFindSet{\\npublic:\\n    UnionFindSet(int n) {\\n        rank = vector<int> (n);\\n        parent = vector<int> (n);\\n        count = vector<int> (n, 1);\\n        for(int i = 0; i < n; ++i)\\n            parent[i] = i;\\n    }\\n    \\n    bool Union(int i, int j) {\\n        int pi = Find(i);\\n        int pj = Find(j);\\n        \\n        if(pi == pj)\\n            return(false);\\n        int ri = rank[pi];\\n        int rj = rank[pj];\\n        \\n        if(ri < rj) {\\n            parent[pi] = pj;\\n            count[pj] += count[pi];\\n        } else if(rj < ri) {\\n            parent[pj] = pi;\\n            count[pi] += count[pj];\\n        } else {\\n            rank[i]++;\\n            parent[pj] = pi;\\n            count[pi] += count[pj];\\n        }\\n        \\n        return(true);\\n    }\\n    \\n    int Find(int i) {\\n        int pi = parent[i];\\n        \\n        if(pi != i) \\n            parent[i] = Find(pi);\\n        \\n        return(parent[i]);\\n    }\\n    \\n    int Count(int i) {\\n        int pi = Find(i);\\n        \\n        return(count[pi]);\\n    }\\n    \\nprivate:\\n    vector<int> rank;\\n    vector<int> parent;\\n    vector<int> count;\\n}\\n;\\n\\nclass Solution {\\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        int k = hits.size();\\n        vector<int> ret(k, 0);\\n        int m = grid.size();\\n        if(m <= 0)\\n            return(ret);\\n        int n = grid[0].size();\\n        \\n        int ceil = m * n;\\n        int N = m * n + 1;\\n        \\n        UnionFindSet UF = UnionFindSet(N);\\n        \\n        vector<int> is_valid_hit(k , false);\\n        // remove all hits values\\n        for(int i = 0; i < k; ++i) {\\n            auto e = hits[i];\\n            \\n            if(grid[e[0]][e[1]]) {\\n                is_valid_hit[i] = 1;\\n                grid[e[0]][e[1]] = 0;\\n            }\\n            \\n        }\\n        \\n        // add all top most grid with values\\n        for(int j = 0; j < n; ++j) {\\n            if(grid[0][j]) {\\n                UF.Union(ceil, j);\\n            }\\n                \\n        }\\n        \\n        \\n        \\n        \\n        \\n        vector<int> dx = {1, 0, -1, 0};\\n        vector<int> dy = {0, 1, 0, -1};\\n        \\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(grid[i][j]) {\\n                    int cur_index =  i * n + j;\\n                    \\n                    for(int dir = 0; dir < 4; ++dir) {\\n                        int x = i + dx[dir];\\n                        int y = j + dy[dir];\\n                \\n                        if(x < 0 || y < 0 || x >= m || y >= n || grid[x][y] == 0)\\n                            continue;\\n                \\n                         int nxt_index = x * n + y;\\n                \\n                        (void) UF.Union(cur_index, nxt_index);\\n                     }\\n                }\\n            }\\n        }\\n        \\n        int prv_size = UF.Count(ceil);\\n        for(int i = k - 1; i >= 0; --i) {\\n            if(!is_valid_hit[i])\\n                continue;\\n            \\n            int ki = hits[i][0];\\n            int kj = hits[i][1];\\n            grid[ki][kj] = 1;\\n            int cur_index = ki * n + kj;\\n            if(ki == 0)\\n                (void) UF.Union(cur_index, ceil);\\n            \\n            for(int dir = 0; dir < 4; ++dir) {\\n                int x = ki + dx[dir];\\n                int y = kj + dy[dir];\\n                \\n                if(x < 0 || y < 0 || x >= m || y >= n || grid[x][y] == 0)\\n                    continue;\\n                \\n                int nxt_index = x * n + y;\\n                \\n                (void) UF.Union(cur_index, nxt_index);\\n            }\\n            \\n            int tmp_size = UF.Count(ceil);\\n            if(tmp_size > prv_size)\\n                ret[i] = tmp_size - prv_size - 1;\\n            \\n            prv_size = tmp_size;\\n        }\\n        \\n        return(ret);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 641474,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> grid;\\n    int counter = 0;\\n    const int CONNECTED_TO_ROOF = 2;\\n\\n    bool valid_cell(int i, int j){\\n        return i >= 0 && i < n && j >= 0 && j < m;\\n    }\\n\\n    void dfs(int i, int j){\\n        if(i == -1){\\n            for(int k = 0; k < m; k++)\\n                if(grid[0][k] == 1)\\n                    dfs(0, k);\\n        }else{\\n            counter += 1;\\n            grid[i][j] = CONNECTED_TO_ROOF;\\n            int x[4] = {i+1, i-1, i, i};\\n            int y[4] = {j, j, j-1, j+1};\\n\\n            for(int k = 0; k < 4; k++){\\n                if(valid_cell(x[k], y[k]) && grid[x[k]][y[k]] == 1) dfs(x[k], y[k]);\\n            }\\n        }\\n    }\\n\\n    vector<int> hitBricks(vector<vector<int>>& gridPassed, vector<vector<int>>& hits){\\n        grid = gridPassed;\\n        n = grid.size();\\n        m = grid[0].size();\\n\\n        for(auto cell: hits)\\n            grid[cell[0]][cell[1]] = 0;\\n\\n        dfs(-1, -1);\\n\\n        vector<int> ans(hits.size());\\n\\n        for(int r_ind = hits.size()-1; r_ind >= 0; r_ind--){\\n            int i = hits[r_ind][0];\\n            int j = hits[r_ind][1];\\n\\n            if(gridPassed[i][j] == 1){\\n                bool exist_neighbor_connected_to_roof = false;\\n                int x[4] = {i+1, i-1, i, i};\\n                int y[4] = {j, j, j-1, j+1};\\n\\n                for(int k = 0; k < 4; k++)\\n                    if(x[k] == -1 || (valid_cell(x[k], y[k]) && grid[x[k]][y[k]] == CONNECTED_TO_ROOF))\\n                        exist_neighbor_connected_to_roof = true;\\n\\n                grid[i][j] = 1;\\n                if(exist_neighbor_connected_to_roof){\\n                    counter = 0;\\n                    dfs(i, j);\\n\\n                    ans[r_ind] = counter - 1;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> grid;\\n    int counter = 0;\\n    const int CONNECTED_TO_ROOF = 2;\\n\\n    bool valid_cell(int i, int j){\\n        return i >= 0 && i < n && j >= 0 && j < m;\\n    }\\n\\n    void dfs(int i, int j){\\n        if(i == -1){\\n            for(int k = 0; k < m; k++)\\n                if(grid[0][k] == 1)\\n                    dfs(0, k);\\n        }else{\\n            counter += 1;\\n            grid[i][j] = CONNECTED_TO_ROOF;\\n            int x[4] = {i+1, i-1, i, i};\\n            int y[4] = {j, j, j-1, j+1};\\n\\n            for(int k = 0; k < 4; k++){\\n                if(valid_cell(x[k], y[k]) && grid[x[k]][y[k]] == 1) dfs(x[k], y[k]);\\n            }\\n        }\\n    }\\n\\n    vector<int> hitBricks(vector<vector<int>>& gridPassed, vector<vector<int>>& hits){\\n        grid = gridPassed;\\n        n = grid.size();\\n        m = grid[0].size();\\n\\n        for(auto cell: hits)\\n            grid[cell[0]][cell[1]] = 0;\\n\\n        dfs(-1, -1);\\n\\n        vector<int> ans(hits.size());\\n\\n        for(int r_ind = hits.size()-1; r_ind >= 0; r_ind--){\\n            int i = hits[r_ind][0];\\n            int j = hits[r_ind][1];\\n\\n            if(gridPassed[i][j] == 1){\\n                bool exist_neighbor_connected_to_roof = false;\\n                int x[4] = {i+1, i-1, i, i};\\n                int y[4] = {j, j, j-1, j+1};\\n\\n                for(int k = 0; k < 4; k++)\\n                    if(x[k] == -1 || (valid_cell(x[k], y[k]) && grid[x[k]][y[k]] == CONNECTED_TO_ROOF))\\n                        exist_neighbor_connected_to_roof = true;\\n\\n                grid[i][j] = 1;\\n                if(exist_neighbor_connected_to_roof){\\n                    counter = 0;\\n                    dfs(i, j);\\n\\n                    ans[r_ind] = counter - 1;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599022,
                "title": "clean-java-dfs-solution",
                "content": "Idea is we mark all cells that connected to top ``2``, and go through hits in the reverse order to mark additional cells if possible.\\n\\n```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        for (int[] hit : hits) {\\n            if (grid[hit[0]][hit[1]] == 1) grid[hit[0]][hit[1]] = -1;\\n        }\\n        for (int j = 0; j < grid[0].length; j++) {\\n            connect(grid, 0, j);\\n        }\\n        int[] res = new int[hits.length];\\n        for (int i = hits.length - 1; i >= 0; i--) {\\n            int row = hits[i][0];\\n            int col = hits[i][1];\\n            if (grid[row][col] == -1) {\\n                grid[row][col] = 1;\\n                if (connectedToTop(grid, row, col)) {\\n                    res[i] = connect(grid, row, col) - 1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean connectedToTop(int[][] grid, int i, int j) {\\n        if (i == 0) return true;\\n        if (i - 1 >= 0 && grid[i - 1][j] == 2) return true;\\n        if (j - 1 >= 0 && grid[i][j - 1] == 2) return true;\\n        if (i + 1 < grid.length && grid[i + 1][j] == 2) return true;\\n        if (j + 1 < grid[0].length && grid[i][j + 1] == 2) return true;\\n        return false;\\n    }\\n    \\n    private int connect(int[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != 1) return 0;\\n        grid[i][j] = 2;\\n        int res = 1;\\n        res += connect(grid, i - 1, j);\\n        res += connect(grid, i + 1, j);\\n        res += connect(grid, i, j + 1);\\n        res += connect(grid, i, j - 1);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        for (int[] hit : hits) {\\n            if (grid[hit[0]][hit[1]] == 1) grid[hit[0]][hit[1]] = -1;\\n        }\\n        for (int j = 0; j < grid[0].length; j++) {\\n            connect(grid, 0, j);\\n        }\\n        int[] res = new int[hits.length];\\n        for (int i = hits.length - 1; i >= 0; i--) {\\n            int row = hits[i][0];\\n            int col = hits[i][1];\\n            if (grid[row][col] == -1) {\\n                grid[row][col] = 1;\\n                if (connectedToTop(grid, row, col)) {\\n                    res[i] = connect(grid, row, col) - 1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean connectedToTop(int[][] grid, int i, int j) {\\n        if (i == 0) return true;\\n        if (i - 1 >= 0 && grid[i - 1][j] == 2) return true;\\n        if (j - 1 >= 0 && grid[i][j - 1] == 2) return true;\\n        if (i + 1 < grid.length && grid[i + 1][j] == 2) return true;\\n        if (j + 1 < grid[0].length && grid[i][j + 1] == 2) return true;\\n        return false;\\n    }\\n    \\n    private int connect(int[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != 1) return 0;\\n        grid[i][j] = 2;\\n        int res = 1;\\n        res += connect(grid, i - 1, j);\\n        res += connect(grid, i + 1, j);\\n        res += connect(grid, i, j + 1);\\n        res += connect(grid, i, j - 1);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 569537,
                "title": "go-using-union-find",
                "content": "```\\nfunc hitBricks(grid [][]int, hits [][]int) []int {\\n\\tif len(grid) == 0 {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\trowCount := len(grid)\\n\\tcolumnCount := len(grid[0])\\n\\n\\tgridClone := cloneGrid(grid, hits)\\n\\tuf := newUF(grid, rowCount*columnCount+1)\\n\\n\\tfor r := range gridClone {\\n\\t\\tfor c := range gridClone[0] {\\n\\t\\t\\tif gridClone[r][c] == 1 {\\n\\t\\t\\t\\tindex := coordinatesToIndex(r, c, columnCount)\\n\\t\\t\\t\\tfor _, n := range connectedNeighbours(r, c, gridClone) {\\n\\t\\t\\t\\t\\tuf.add(index, n)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif r == 0 {\\n\\t\\t\\t\\t\\tuf.add(index, rowCount*columnCount)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tdroppedBricks := make([]int, len(hits))\\n\\tfor i := len(hits) - 1; i >= 0; i-- {\\n\\t\\tr := hits[i][0]\\n\\t\\tc := hits[i][1]\\n\\t\\tif grid[r][c] == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tgridClone[r][c] = 1\\n\\t\\tsizeBefore := uf.componentSize(rowCount * columnCount)\\n\\t\\tindex := coordinatesToIndex(r, c, columnCount)\\n\\t\\tif r == 0 {\\n\\t\\t\\tuf.add(index, rowCount*columnCount)\\n\\t\\t}\\n\\t\\tfor _, n := range connectedNeighbours(r, c, gridClone) {\\n\\t\\t\\tuf.add(index, n)\\n\\t\\t\\tif r == 0 {\\n\\t\\t\\t\\tuf.add(index, rowCount*columnCount)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsizeAfter := uf.componentSize(rowCount * columnCount)\\n\\t\\tif sizeAfter > sizeBefore {\\n\\t\\t\\tdroppedBricks[i] = sizeAfter - sizeBefore - 1\\n\\t\\t}\\n\\t}\\n\\treturn droppedBricks\\n}\\n\\nfunc cloneGrid(grid, hits [][]int) [][]int {\\n\\tclonedGrid := make([][]int, len(grid))\\n\\tfor i := range clonedGrid {\\n\\t\\tclonedGrid[i] = make([]int, len(grid[0]))\\n\\t}\\n\\tfor r := range grid {\\n\\t\\tfor c := range grid[0] {\\n\\t\\t\\tclonedGrid[r][c] = grid[r][c]\\n\\t\\t}\\n\\t}\\n\\tfor _, hit := range hits {\\n\\t\\tclonedGrid[hit[0]][hit[1]] = 0\\n\\t}\\n\\treturn clonedGrid\\n}\\n\\nfunc connectedNeighbours(r, c int, grid [][]int) []int {\\n\\trowCount := len(grid)\\n\\tcolumnCount := len(grid[0])\\n\\n\\tneighbours := make([]int, 0)\\n\\tif r > 0 && grid[r-1][c] == 1 {\\n\\t\\tneighbours = append(neighbours, coordinatesToIndex(r-1, c, columnCount))\\n\\t}\\n\\n\\tif r < rowCount-1 && grid[r+1][c] == 1 {\\n\\t\\tneighbours = append(neighbours, coordinatesToIndex(r+1, c, columnCount))\\n\\t}\\n\\n\\tif c > 0 && grid[r][c-1] == 1 {\\n\\t\\tneighbours = append(neighbours, coordinatesToIndex(r, c-1, columnCount))\\n\\t}\\n\\n\\tif c < columnCount-1 && grid[r][c+1] == 1 {\\n\\t\\tneighbours = append(neighbours, coordinatesToIndex(r, c+1, columnCount))\\n\\t}\\n\\n\\treturn neighbours\\n}\\n\\nfunc coordinatesToIndex(r, c, columnCount int) int {\\n\\treturn r*columnCount + c\\n}\\n\\ntype unionFind struct {\\n\\tparents []int\\n\\tsize    []int\\n}\\n\\nfunc newUF(grid [][]int, size int) *unionFind {\\n\\tuf := &unionFind{\\n\\t\\tparents: make([]int, size),\\n\\t\\tsize:    make([]int, size),\\n\\t}\\n\\tfor i := range uf.parents {\\n\\t\\tuf.parents[i] = i\\n\\t}\\n\\tfor r := range grid {\\n\\t\\tfor c := range grid[0] {\\n\\t\\t\\tif grid[r][c] == 1 {\\n\\t\\t\\t\\tuf.size[coordinatesToIndex(r, c, len(grid[0]))] = 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn uf\\n}\\n\\nfunc (uf *unionFind) root(u int) int {\\n\\tfor true {\\n\\t\\tcount := 0\\n\\t\\tfor u != uf.parents[u] {\\n\\t\\t\\tuf.parents[u] = uf.parents[uf.parents[u]]\\n\\t\\t\\tu = uf.parents[u]\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t\\tif count == 0 {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\treturn u\\n}\\n\\nfunc (uf *unionFind) add(u, v int) {\\n\\tuRoot := uf.root(u)\\n\\tvRoot := uf.root(v)\\n\\n\\tif uRoot == vRoot {\\n\\t\\treturn\\n\\t}\\n\\n\\tuSize := uf.size[uRoot]\\n\\tvSize := uf.size[vRoot]\\n\\n\\tif uSize > vSize {\\n\\t\\tuf.parents[vRoot] = uRoot\\n\\t\\tuf.size[uRoot] += vSize\\n\\t} else {\\n\\t\\tuf.parents[uRoot] = vRoot\\n\\t\\tuf.size[vRoot] += uSize\\n\\t}\\n}\\n\\nfunc (uf *unionFind) connected(u, v int) bool {\\n\\treturn uf.root(u) == uf.root(v)\\n}\\n\\nfunc (uf *unionFind) componentSize(u int) int {\\n\\treturn uf.size[uf.root(u)]\\n}\\n\\nfunc (uf *unionFind) top() int {\\n\\treturn uf.size[len(uf.size)-1] - 1\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find"
                ],
                "code": "```\\nfunc hitBricks(grid [][]int, hits [][]int) []int {\\n\\tif len(grid) == 0 {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\trowCount := len(grid)\\n\\tcolumnCount := len(grid[0])\\n\\n\\tgridClone := cloneGrid(grid, hits)\\n\\tuf := newUF(grid, rowCount*columnCount+1)\\n\\n\\tfor r := range gridClone {\\n\\t\\tfor c := range gridClone[0] {\\n\\t\\t\\tif gridClone[r][c] == 1 {\\n\\t\\t\\t\\tindex := coordinatesToIndex(r, c, columnCount)\\n\\t\\t\\t\\tfor _, n := range connectedNeighbours(r, c, gridClone) {\\n\\t\\t\\t\\t\\tuf.add(index, n)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif r == 0 {\\n\\t\\t\\t\\t\\tuf.add(index, rowCount*columnCount)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tdroppedBricks := make([]int, len(hits))\\n\\tfor i := len(hits) - 1; i >= 0; i-- {\\n\\t\\tr := hits[i][0]\\n\\t\\tc := hits[i][1]\\n\\t\\tif grid[r][c] == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tgridClone[r][c] = 1\\n\\t\\tsizeBefore := uf.componentSize(rowCount * columnCount)\\n\\t\\tindex := coordinatesToIndex(r, c, columnCount)\\n\\t\\tif r == 0 {\\n\\t\\t\\tuf.add(index, rowCount*columnCount)\\n\\t\\t}\\n\\t\\tfor _, n := range connectedNeighbours(r, c, gridClone) {\\n\\t\\t\\tuf.add(index, n)\\n\\t\\t\\tif r == 0 {\\n\\t\\t\\t\\tuf.add(index, rowCount*columnCount)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsizeAfter := uf.componentSize(rowCount * columnCount)\\n\\t\\tif sizeAfter > sizeBefore {\\n\\t\\t\\tdroppedBricks[i] = sizeAfter - sizeBefore - 1\\n\\t\\t}\\n\\t}\\n\\treturn droppedBricks\\n}\\n\\nfunc cloneGrid(grid, hits [][]int) [][]int {\\n\\tclonedGrid := make([][]int, len(grid))\\n\\tfor i := range clonedGrid {\\n\\t\\tclonedGrid[i] = make([]int, len(grid[0]))\\n\\t}\\n\\tfor r := range grid {\\n\\t\\tfor c := range grid[0] {\\n\\t\\t\\tclonedGrid[r][c] = grid[r][c]\\n\\t\\t}\\n\\t}\\n\\tfor _, hit := range hits {\\n\\t\\tclonedGrid[hit[0]][hit[1]] = 0\\n\\t}\\n\\treturn clonedGrid\\n}\\n\\nfunc connectedNeighbours(r, c int, grid [][]int) []int {\\n\\trowCount := len(grid)\\n\\tcolumnCount := len(grid[0])\\n\\n\\tneighbours := make([]int, 0)\\n\\tif r > 0 && grid[r-1][c] == 1 {\\n\\t\\tneighbours = append(neighbours, coordinatesToIndex(r-1, c, columnCount))\\n\\t}\\n\\n\\tif r < rowCount-1 && grid[r+1][c] == 1 {\\n\\t\\tneighbours = append(neighbours, coordinatesToIndex(r+1, c, columnCount))\\n\\t}\\n\\n\\tif c > 0 && grid[r][c-1] == 1 {\\n\\t\\tneighbours = append(neighbours, coordinatesToIndex(r, c-1, columnCount))\\n\\t}\\n\\n\\tif c < columnCount-1 && grid[r][c+1] == 1 {\\n\\t\\tneighbours = append(neighbours, coordinatesToIndex(r, c+1, columnCount))\\n\\t}\\n\\n\\treturn neighbours\\n}\\n\\nfunc coordinatesToIndex(r, c, columnCount int) int {\\n\\treturn r*columnCount + c\\n}\\n\\ntype unionFind struct {\\n\\tparents []int\\n\\tsize    []int\\n}\\n\\nfunc newUF(grid [][]int, size int) *unionFind {\\n\\tuf := &unionFind{\\n\\t\\tparents: make([]int, size),\\n\\t\\tsize:    make([]int, size),\\n\\t}\\n\\tfor i := range uf.parents {\\n\\t\\tuf.parents[i] = i\\n\\t}\\n\\tfor r := range grid {\\n\\t\\tfor c := range grid[0] {\\n\\t\\t\\tif grid[r][c] == 1 {\\n\\t\\t\\t\\tuf.size[coordinatesToIndex(r, c, len(grid[0]))] = 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn uf\\n}\\n\\nfunc (uf *unionFind) root(u int) int {\\n\\tfor true {\\n\\t\\tcount := 0\\n\\t\\tfor u != uf.parents[u] {\\n\\t\\t\\tuf.parents[u] = uf.parents[uf.parents[u]]\\n\\t\\t\\tu = uf.parents[u]\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t\\tif count == 0 {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\treturn u\\n}\\n\\nfunc (uf *unionFind) add(u, v int) {\\n\\tuRoot := uf.root(u)\\n\\tvRoot := uf.root(v)\\n\\n\\tif uRoot == vRoot {\\n\\t\\treturn\\n\\t}\\n\\n\\tuSize := uf.size[uRoot]\\n\\tvSize := uf.size[vRoot]\\n\\n\\tif uSize > vSize {\\n\\t\\tuf.parents[vRoot] = uRoot\\n\\t\\tuf.size[uRoot] += vSize\\n\\t} else {\\n\\t\\tuf.parents[uRoot] = vRoot\\n\\t\\tuf.size[vRoot] += uSize\\n\\t}\\n}\\n\\nfunc (uf *unionFind) connected(u, v int) bool {\\n\\treturn uf.root(u) == uf.root(v)\\n}\\n\\nfunc (uf *unionFind) componentSize(u int) int {\\n\\treturn uf.size[uf.root(u)]\\n}\\n\\nfunc (uf *unionFind) top() int {\\n\\treturn uf.size[len(uf.size)-1] - 1\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 530599,
                "title": "accepted-c-solution-dfs-single-set-instead-of-union-find",
                "content": "```\\n\\n    public class Solution\\n    {\\n        private static readonly (int di, int dj)[] _directions = { (0, 1), (1, 0), (0, -1), (-1, 0) };\\n\\n        private int Join(int node, int[,] backward, ISet<int> stableCells)\\n        {\\n            if (!stableCells.Add(node))\\n            {\\n                return 0;\\n            }\\n\\n            int res = 1;\\n            int n = backward.GetLength(0);\\n            int m = backward.GetLength(1);\\n\\n            int r = node / m;\\n            int c = node % m;\\n\\n            foreach (var dir in _directions)\\n            {\\n                int newI = r + dir.di;\\n                int newJ = c + dir.dj;\\n                int l = newI * m + newJ;\\n\\n                if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && backward[newI, newJ] == 1 && !stableCells.Contains(l) && newI != 0)\\n                {\\n                    res += Join(l, backward, stableCells);\\n                }\\n            }\\n\\n            return res;\\n        }\\n\\n        public int[] HitBricks(int[][] grid, int[][] hits)\\n        {\\n            int n = grid.Length;\\n            int[] res = new int[hits.Length];\\n            int m = grid[0].Length;\\n            int[,] backward = new int[n,m];\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    backward[i, j] = grid[i][j];\\n                }\\n            }\\n\\n            foreach (var hit in hits)\\n            {\\n                backward[hit[0], hit[1]] = 0;\\n            }\\n\\n            ISet<int> stableCells = new HashSet<int>();\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (backward[0, j] == 1)\\n                {\\n                    Join(j, backward, stableCells);\\n                }\\n            }\\n\\n            for (int i = hits.Length - 1; i >= 0; i--)\\n            {\\n                var hit = hits[i];\\n                var linear = hit[0] * m + hit[1];\\n\\n                if (grid[hit[0]][hit[1]] == 0)\\n                {\\n                    continue;\\n                }\\n\\n                backward[hit[0], hit[1]] = 1;\\n\\n                if (hit[0] == 0)\\n                {\\n                    res[i] = Join(linear, backward, stableCells) - 1;\\n                    continue;\\n                }\\n\\n                foreach (var dir in _directions)\\n                {\\n                    int newI = hit[0] + dir.di;\\n                    int newJ = hit[1] + dir.dj;\\n                    int l = newI * m + newJ;\\n\\n                    if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && backward[newI, newJ] == 1 && stableCells.Contains(l))\\n                    {\\n                        res[i] = Join(linear, backward, stableCells) - 1;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    public class Solution\\n    {\\n        private static readonly (int di, int dj)[] _directions = { (0, 1), (1, 0), (0, -1), (-1, 0) };\\n\\n        private int Join(int node, int[,] backward, ISet<int> stableCells)\\n        {\\n            if (!stableCells.Add(node))\\n            {\\n                return 0;\\n            }\\n\\n            int res = 1;\\n            int n = backward.GetLength(0);\\n            int m = backward.GetLength(1);\\n\\n            int r = node / m;\\n            int c = node % m;\\n\\n            foreach (var dir in _directions)\\n            {\\n                int newI = r + dir.di;\\n                int newJ = c + dir.dj;\\n                int l = newI * m + newJ;\\n\\n                if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && backward[newI, newJ] == 1 && !stableCells.Contains(l) && newI != 0)\\n                {\\n                    res += Join(l, backward, stableCells);\\n                }\\n            }\\n\\n            return res;\\n        }\\n\\n        public int[] HitBricks(int[][] grid, int[][] hits)\\n        {\\n            int n = grid.Length;\\n            int[] res = new int[hits.Length];\\n            int m = grid[0].Length;\\n            int[,] backward = new int[n,m];\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    backward[i, j] = grid[i][j];\\n                }\\n            }\\n\\n            foreach (var hit in hits)\\n            {\\n                backward[hit[0], hit[1]] = 0;\\n            }\\n\\n            ISet<int> stableCells = new HashSet<int>();\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (backward[0, j] == 1)\\n                {\\n                    Join(j, backward, stableCells);\\n                }\\n            }\\n\\n            for (int i = hits.Length - 1; i >= 0; i--)\\n            {\\n                var hit = hits[i];\\n                var linear = hit[0] * m + hit[1];\\n\\n                if (grid[hit[0]][hit[1]] == 0)\\n                {\\n                    continue;\\n                }\\n\\n                backward[hit[0], hit[1]] = 1;\\n\\n                if (hit[0] == 0)\\n                {\\n                    res[i] = Join(linear, backward, stableCells) - 1;\\n                    continue;\\n                }\\n\\n                foreach (var dir in _directions)\\n                {\\n                    int newI = hit[0] + dir.di;\\n                    int newJ = hit[1] + dir.dj;\\n                    int l = newI * m + newJ;\\n\\n                    if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && backward[newI, newJ] == 1 && stableCells.Contains(l))\\n                    {\\n                        res[i] = Join(linear, backward, stableCells) - 1;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504358,
                "title": "c-union-find",
                "content": "```\\npublic class Subset {\\n    public int size;\\n    public (int,int)? parent;\\n}\\n\\npublic class Solution {\\n    \\n    int[,] grid;\\n    int[][] original;\\n    \\n    int H;\\n    int W;\\n    \\n    int[][] hits;\\n    \\n    Subset[,] subsets;\\n    \\n    int unionAdj(int i, int j) {\\n        return union(i,j,i+1,j) + union(i,j,i,j+1) + union(i,j,i-1,j) + union(i,j,i,j-1);\\n    }\\n    \\n    // find set parent\\n    (int,int) find(int i, int j) {\\n        var s = subsets[i,j];\\n        if (s == null) {\\n            s = new Subset { size = 1, parent = null };\\n            subsets[i,j] = s;\\n        }\\n        while (s.parent != null) {\\n            (i, j) = s.parent.Value;\\n            s = subsets[i,j];\\n        }\\n        \\n        return (i,j);\\n    }\\n    \\n    int union(int i1, int j1, int i2, int j2) {\\n        if (i2 < 0 || i2 > H || j2 < 0 || j2 >= W) return 0;\\n        if (grid[i2,j2] == 0 || grid[i1,j1] == 0) return 0;\\n        \\n        (int pi1, int pj1) = find(i1, j1);\\n        (int pi2, int pj2) = find(i2, j2);\\n        \\n        if (pi1 == pi2 && pj1 == pj2) return 0; //same group\\n        \\n        if (pi1 == 0) {\\n            subsets[pi2,pj2].parent = (pi1,pj1);\\n            subsets[pi1,pj1].size += subsets[pi2,pj2].size;\\n            return subsets[pi2,pj2].size;\\n        }\\n        if (pi2 == 0) {\\n            subsets[pi1,pj1].parent = (pi2,pj2);\\n            subsets[pi2,pj2].size += subsets[pi1,pj1].size;\\n            return subsets[pi1,pj1].size;\\n        }\\n\\n        subsets[pi1,pj1].parent = (pi2,pj2);\\n        subsets[pi2,pj2].size += subsets[pi1,pj1].size;\\n        \\n        return 0;\\n    }\\n    \\n    public int[] HitBricks(int[][] original, int[][] hits) {\\n        this.original = original;\\n        H = original.Length;\\n        W = original[0].Length;\\n        this.hits = hits;\\n        this.grid = new int[H + 1,W];\\n        \\n        for (int j = 0; j < W; j++) {\\n            this.grid[0,j] = 1;\\n        }\\n        for (int i = 0; i < H; i++) {\\n            for (int j = 0; j < W; j++) {\\n                this.grid[i+1,j] = original[i][j];\\n            }\\n        }\\n        \\n        subsets = new Subset[H+1,W];\\n        \\n        for (int i = 0; i < hits.Length; i++) {\\n            grid[hits[i][0]+1,hits[i][1]] = 0;\\n        }\\n        \\n        for (int i = 0; i < H + 1; i++) {\\n            for (int j = 0; j < W; j++) {\\n                unionAdj(i,j);\\n            }\\n        }\\n        \\n        int[] total = new int[hits.Length];\\n        \\n        for (int i = hits.Length - 1; i >= 0; i--) {\\n            if (original[hits[i][0]][hits[i][1]] == 1) {\\n                grid[hits[i][0] + 1,hits[i][1]] = 1;\\n                total[i] = unionAdj(hits[i][0]+1, hits[i][1]);\\n                total[i] = Math.Max(0, total[i] - 1);\\n            }\\n            else {\\n                total[i] = 0;\\n            }\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Subset {\\n    public int size;\\n    public (int,int)? parent;\\n}\\n\\npublic class Solution {\\n    \\n    int[,] grid;\\n    int[][] original;\\n    \\n    int H;\\n    int W;\\n    \\n    int[][] hits;\\n    \\n    Subset[,] subsets;\\n    \\n    int unionAdj(int i, int j) {\\n        return union(i,j,i+1,j) + union(i,j,i,j+1) + union(i,j,i-1,j) + union(i,j,i,j-1);\\n    }\\n    \\n    // find set parent\\n    (int,int) find(int i, int j) {\\n        var s = subsets[i,j];\\n        if (s == null) {\\n            s = new Subset { size = 1, parent = null };\\n            subsets[i,j] = s;\\n        }\\n        while (s.parent != null) {\\n            (i, j) = s.parent.Value;\\n            s = subsets[i,j];\\n        }\\n        \\n        return (i,j);\\n    }\\n    \\n    int union(int i1, int j1, int i2, int j2) {\\n        if (i2 < 0 || i2 > H || j2 < 0 || j2 >= W) return 0;\\n        if (grid[i2,j2] == 0 || grid[i1,j1] == 0) return 0;\\n        \\n        (int pi1, int pj1) = find(i1, j1);\\n        (int pi2, int pj2) = find(i2, j2);\\n        \\n        if (pi1 == pi2 && pj1 == pj2) return 0; //same group\\n        \\n        if (pi1 == 0) {\\n            subsets[pi2,pj2].parent = (pi1,pj1);\\n            subsets[pi1,pj1].size += subsets[pi2,pj2].size;\\n            return subsets[pi2,pj2].size;\\n        }\\n        if (pi2 == 0) {\\n            subsets[pi1,pj1].parent = (pi2,pj2);\\n            subsets[pi2,pj2].size += subsets[pi1,pj1].size;\\n            return subsets[pi1,pj1].size;\\n        }\\n\\n        subsets[pi1,pj1].parent = (pi2,pj2);\\n        subsets[pi2,pj2].size += subsets[pi1,pj1].size;\\n        \\n        return 0;\\n    }\\n    \\n    public int[] HitBricks(int[][] original, int[][] hits) {\\n        this.original = original;\\n        H = original.Length;\\n        W = original[0].Length;\\n        this.hits = hits;\\n        this.grid = new int[H + 1,W];\\n        \\n        for (int j = 0; j < W; j++) {\\n            this.grid[0,j] = 1;\\n        }\\n        for (int i = 0; i < H; i++) {\\n            for (int j = 0; j < W; j++) {\\n                this.grid[i+1,j] = original[i][j];\\n            }\\n        }\\n        \\n        subsets = new Subset[H+1,W];\\n        \\n        for (int i = 0; i < hits.Length; i++) {\\n            grid[hits[i][0]+1,hits[i][1]] = 0;\\n        }\\n        \\n        for (int i = 0; i < H + 1; i++) {\\n            for (int j = 0; j < W; j++) {\\n                unionAdj(i,j);\\n            }\\n        }\\n        \\n        int[] total = new int[hits.Length];\\n        \\n        for (int i = hits.Length - 1; i >= 0; i--) {\\n            if (original[hits[i][0]][hits[i][1]] == 1) {\\n                grid[hits[i][0] + 1,hits[i][1]] = 1;\\n                total[i] = unionAdj(hits[i][0]+1, hits[i][1]);\\n                total[i] = Math.Max(0, total[i] - 1);\\n            }\\n            else {\\n                total[i] = 0;\\n            }\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371386,
                "title": "question-bricks-doesn-t-disappear-if-dropped",
                "content": "If bricks that get dropped would stack on the last row, how would you solve this question?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 350952,
                "title": "golang-dsu-tc-sc100-clearcode",
                "content": "```\\ntype dsu struct {\\n\\tparent []int\\n\\tsize   []int\\n\\tcount  int\\n}\\n\\nfunc NewDsu(n int) dsu {\\n\\tp := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tp[i] = i\\n\\t}\\n\\ts := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\ts[i] = 1\\n\\t}\\n\\treturn dsu{\\n\\t\\tparent: p,\\n\\t\\tsize:   s,\\n\\t\\tcount:  n,\\n\\t}\\n}\\n\\nfunc (d *dsu) find(p int) int {\\n\\tif d.parent[p] != p {\\n\\t\\td.parent[p] = d.find(d.parent[p])\\n\\t}\\n\\treturn d.parent[p]\\n}\\n\\nfunc (d *dsu) Union(p, q int) {\\n\\tpr := d.find(p)\\n\\tqr := d.find(q)\\n\\tif pr == qr {\\n\\t\\treturn\\n\\t}\\n\\t// if d.size[pr] <= d.size[qr] {\\n\\t// \\tpr, qr = qr, pr\\n\\t// }\\n\\n\\td.parent[qr] = pr\\n\\td.size[pr] += d.size[qr]\\n\\td.count--\\n}\\n\\nfunc (d *dsu) Size(p int) int {\\n\\treturn d.size[d.find(p)]\\n}\\n\\nfunc rc2key(col, r, c int) int {\\n\\treturn r*col + c\\n}\\n\\nfunc reverse(s []int) {\\n\\tfor i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\\n\\t\\ts[i], s[j] = s[j], s[i]\\n\\t}\\n}\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t} else {\\n\\t\\treturn b\\n\\t}\\n}\\n\\nvar DIRECT = []int{-1, 0, 1, 0, -1}\\n\\nfunc hitBricks(grid [][]int, hits [][]int) []int {\\n\\trow := len(grid)\\n\\tif row == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\tcol := len(grid[0])\\n\\tpreservedGird := make(map[int]int)\\n\\tfor _, h := range hits {\\n\\t\\thr := h[0]\\n\\t\\thc := h[1]\\n\\t\\thk := rc2key(col, hr, hc)\\n\\t\\tpreservedGird[hk] = grid[hr][hc]\\n\\t\\tgrid[hr][hc] = 0\\n\\t}\\n\\n\\tdsu := NewDsu(row*col + 1)\\n\\troof := row * col\\n\\tfor r := 0; r < row; r++ {\\n\\t\\tfor c := 0; c < col; c++ {\\n\\t\\t\\tk := rc2key(col, r, c)\\n\\t\\t\\tif grid[r][c] == 1 {\\n\\t\\t\\t\\tif r == 0 {\\n\\t\\t\\t\\t\\tdsu.Union(roof, k)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif r > 0 && grid[r-1][c] == 1 {\\n\\t\\t\\t\\t\\tupK := rc2key(col, r-1, c)\\n\\t\\t\\t\\t\\tdsu.Union(upK, k)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif c > 0 && grid[r][c-1] == 1 {\\n\\t\\t\\t\\t\\tleftK := rc2key(col, r, c-1)\\n\\t\\t\\t\\t\\tdsu.Union(leftK, k)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tans := make([]int, 0, len(hits))\\n\\tfor i := len(hits) - 1; i >= 0; i-- {\\n\\t\\th := hits[i]\\n\\t\\thr, hc := h[0], h[1]\\n\\t\\thk := rc2key(col, hr, hc)\\n\\t\\tif preservedGird[hk] == 0 {\\n\\t\\t\\tans = append(ans, 0)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tprevTop := dsu.Size(roof) - 1\\n\\n\\t\\tfor i := 0; i < 4; i++ {\\n\\t\\t\\tnr := hr + DIRECT[i]\\n\\t\\t\\tnc := hc + DIRECT[i+1]\\n\\n\\t\\t\\tif nr < 0 || nr >= row || nc < 0 || nc >= col {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif grid[nr][nc] == 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tnk := rc2key(col, nr, nc)\\n\\t\\t\\tdsu.Union(hk, nk)\\n\\t\\t}\\n\\t\\tif hr == 0 {\\n\\t\\t\\tdsu.Union(roof, hk)\\n\\t\\t}\\n\\t\\tgrid[hr][hc] = 1\\n\\n\\t\\tcurTop := dsu.Size(roof) - 1\\n\\t\\tdrop := max(curTop-prevTop-1, 0)\\n\\t\\tans = append(ans, drop)\\n\\t}\\n\\treverse(ans)\\n\\treturn ans\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype dsu struct {\\n\\tparent []int\\n\\tsize   []int\\n\\tcount  int\\n}\\n\\nfunc NewDsu(n int) dsu {\\n\\tp := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tp[i] = i\\n\\t}\\n\\ts := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\ts[i] = 1\\n\\t}\\n\\treturn dsu{\\n\\t\\tparent: p,\\n\\t\\tsize:   s,\\n\\t\\tcount:  n,\\n\\t}\\n}\\n\\nfunc (d *dsu) find(p int) int {\\n\\tif d.parent[p] != p {\\n\\t\\td.parent[p] = d.find(d.parent[p])\\n\\t}\\n\\treturn d.parent[p]\\n}\\n\\nfunc (d *dsu) Union(p, q int) {\\n\\tpr := d.find(p)\\n\\tqr := d.find(q)\\n\\tif pr == qr {\\n\\t\\treturn\\n\\t}\\n\\t// if d.size[pr] <= d.size[qr] {\\n\\t// \\tpr, qr = qr, pr\\n\\t// }\\n\\n\\td.parent[qr] = pr\\n\\td.size[pr] += d.size[qr]\\n\\td.count--\\n}\\n\\nfunc (d *dsu) Size(p int) int {\\n\\treturn d.size[d.find(p)]\\n}\\n\\nfunc rc2key(col, r, c int) int {\\n\\treturn r*col + c\\n}\\n\\nfunc reverse(s []int) {\\n\\tfor i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\\n\\t\\ts[i], s[j] = s[j], s[i]\\n\\t}\\n}\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t} else {\\n\\t\\treturn b\\n\\t}\\n}\\n\\nvar DIRECT = []int{-1, 0, 1, 0, -1}\\n\\nfunc hitBricks(grid [][]int, hits [][]int) []int {\\n\\trow := len(grid)\\n\\tif row == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\tcol := len(grid[0])\\n\\tpreservedGird := make(map[int]int)\\n\\tfor _, h := range hits {\\n\\t\\thr := h[0]\\n\\t\\thc := h[1]\\n\\t\\thk := rc2key(col, hr, hc)\\n\\t\\tpreservedGird[hk] = grid[hr][hc]\\n\\t\\tgrid[hr][hc] = 0\\n\\t}\\n\\n\\tdsu := NewDsu(row*col + 1)\\n\\troof := row * col\\n\\tfor r := 0; r < row; r++ {\\n\\t\\tfor c := 0; c < col; c++ {\\n\\t\\t\\tk := rc2key(col, r, c)\\n\\t\\t\\tif grid[r][c] == 1 {\\n\\t\\t\\t\\tif r == 0 {\\n\\t\\t\\t\\t\\tdsu.Union(roof, k)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif r > 0 && grid[r-1][c] == 1 {\\n\\t\\t\\t\\t\\tupK := rc2key(col, r-1, c)\\n\\t\\t\\t\\t\\tdsu.Union(upK, k)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif c > 0 && grid[r][c-1] == 1 {\\n\\t\\t\\t\\t\\tleftK := rc2key(col, r, c-1)\\n\\t\\t\\t\\t\\tdsu.Union(leftK, k)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tans := make([]int, 0, len(hits))\\n\\tfor i := len(hits) - 1; i >= 0; i-- {\\n\\t\\th := hits[i]\\n\\t\\thr, hc := h[0], h[1]\\n\\t\\thk := rc2key(col, hr, hc)\\n\\t\\tif preservedGird[hk] == 0 {\\n\\t\\t\\tans = append(ans, 0)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tprevTop := dsu.Size(roof) - 1\\n\\n\\t\\tfor i := 0; i < 4; i++ {\\n\\t\\t\\tnr := hr + DIRECT[i]\\n\\t\\t\\tnc := hc + DIRECT[i+1]\\n\\n\\t\\t\\tif nr < 0 || nr >= row || nc < 0 || nc >= col {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif grid[nr][nc] == 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tnk := rc2key(col, nr, nc)\\n\\t\\t\\tdsu.Union(hk, nk)\\n\\t\\t}\\n\\t\\tif hr == 0 {\\n\\t\\t\\tdsu.Union(roof, hk)\\n\\t\\t}\\n\\t\\tgrid[hr][hc] = 1\\n\\n\\t\\tcurTop := dsu.Size(roof) - 1\\n\\t\\tdrop := max(curTop-prevTop-1, 0)\\n\\t\\tans = append(ans, drop)\\n\\t}\\n\\treverse(ans)\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 296301,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        inf = float(\\'inf\\')\\n        for (i, j) in hits:\\n            if grid[i][j] == 1:\\n                grid[i][j] = -1\\n        \\n        def nbrs(i, j):\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if ci < 0 or ci >= m or cj < 0 or cj >= n: continue\\n                yield ci, cj\\n        \\n        def stick(i, j):\\n            grid[i][j] = inf\\n            for ni, nj in nbrs(i, j):\\n                if grid[ni][nj] == 1:\\n                    stick(ni, nj)\\n        \\n        for j in range(n):\\n            if grid[0][j] == 1: stick(0, j)\\n        ans = []\\n        def put_back(i, j, visited):\\n            grid[i][j] = inf if i == 0 or any(grid[ni][nj] == inf for ni, nj in nbrs(i, j)) else 1\\n            ans = 1 if grid[i][j] == inf else 0\\n            for ni, nj in nbrs(i, j):\\n                if grid[ni][nj] != 1 or (ni, nj) in visited: continue\\n                visited.add((ni, nj))\\n                ans += put_back(ni, nj, visited)\\n            return ans\\n        for (i, j) in hits[::-1]:\\n            ans.append(put_back(i, j, set([(i, j)]))-(grid[i][j] == inf) if grid[i][j] == -1 else 0)\\n        return ans[::-1]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        inf = float(\\'inf\\')\\n        for (i, j) in hits:\\n            if grid[i][j] == 1:\\n                grid[i][j] = -1\\n        \\n        def nbrs(i, j):\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if ci < 0 or ci >= m or cj < 0 or cj >= n: continue\\n                yield ci, cj\\n        \\n        def stick(i, j):\\n            grid[i][j] = inf\\n            for ni, nj in nbrs(i, j):\\n                if grid[ni][nj] == 1:\\n                    stick(ni, nj)\\n        \\n        for j in range(n):\\n            if grid[0][j] == 1: stick(0, j)\\n        ans = []\\n        def put_back(i, j, visited):\\n            grid[i][j] = inf if i == 0 or any(grid[ni][nj] == inf for ni, nj in nbrs(i, j)) else 1\\n            ans = 1 if grid[i][j] == inf else 0\\n            for ni, nj in nbrs(i, j):\\n                if grid[ni][nj] != 1 or (ni, nj) in visited: continue\\n                visited.add((ni, nj))\\n                ans += put_back(ni, nj, visited)\\n            return ans\\n        for (i, j) in hits[::-1]:\\n            ans.append(put_back(i, j, set([(i, j)]))-(grid[i][j] == inf) if grid[i][j] == -1 else 0)\\n        return ans[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 278156,
                "title": "why-does-my-solution-get-time-limit-exceeded",
                "content": "Instead of doing union-find, I just do BFS to explore all connected bricks. After bfs-exploring if I see that none of the bricks reached the top, I delete them all. Asymptotically, to process every hit I achieve O(R*C) (Row * Column) complexity. \\n\\nIt actually seem better than in the provided solution, where the complexity is R * C *  (inverse-ackerman-function for union-find lookups).\\n\\nCan anyone explain me what\\'s wrong with BFS in my case?\\n\\n```\\nvoid clean(vector<pair<int, int>>& vec, vector<vector<int>>& grid) {\\n        for (auto& pair : vec)\\n            grid[pair.first][pair.second] = 0;\\n    }\\n    \\nint countDrops(vector<vector<int>>& grid, int x, int y, vector<vector<int>>& visited) {\\n\\tint offsets[][2] = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};\\n\\tvector<pair<int, int>> to_clean;\\n\\tqueue<pair<int, int>> st;\\n\\tst.push({x, y});\\n\\tbool top_r = false;\\n\\twhile (!st.empty()) {\\n\\t\\tauto p = st.front();\\n\\t\\tst.pop();\\n\\t\\tint x1 = p.first;\\n\\t\\tint y1 = p.second;\\n\\t\\tif (x1 < 0 || x1 == grid.size() || y1 < 0 || y1 == grid[0].size())\\n\\t\\t\\tcontinue;\\n\\t\\tif (visited[x1][y1] || grid[x1][y1] == 0)\\n\\t\\t\\tcontinue;\\n\\t\\tif (x1 == 0)\\n\\t\\t\\ttop_r = true;\\n\\t\\tto_clean.push_back(p);\\n\\t\\tvisited[x1][y1] = 1;\\n\\t\\tfor (auto& offset : offsets)\\n\\t\\t\\tst.push({x1 + offset[0], y1 + offset[1]});\\n\\t}\\n\\tif (top_r)\\n\\t\\treturn 0;\\n\\tclean(to_clean, grid);\\n\\treturn to_clean.size();\\n}\\n\\nvector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n\\tvector<int> res;\\n\\tint offsets[][2] = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};\\n\\tfor (auto& hit : hits) {\\n\\t\\tvector<vector<int>> visited (grid.size(), vector<int> (grid[0].size(), 0));\\n\\t\\tint x = hit[0];\\n\\t\\tint y = hit[1];\\n\\t\\tgrid[x][y] = 0;\\n\\t\\tint counter = 0;\\n\\t\\tfor (auto& offset : offsets) {\\n\\t\\t\\tcounter += countDrops(grid, x + offset[0], y + offset[1], visited);\\n\\t\\t}\\n\\t\\tres.push_back(counter);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid clean(vector<pair<int, int>>& vec, vector<vector<int>>& grid) {\\n        for (auto& pair : vec)\\n            grid[pair.first][pair.second] = 0;\\n    }\\n    \\nint countDrops(vector<vector<int>>& grid, int x, int y, vector<vector<int>>& visited) {\\n\\tint offsets[][2] = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};\\n\\tvector<pair<int, int>> to_clean;\\n\\tqueue<pair<int, int>> st;\\n\\tst.push({x, y});\\n\\tbool top_r = false;\\n\\twhile (!st.empty()) {\\n\\t\\tauto p = st.front();\\n\\t\\tst.pop();\\n\\t\\tint x1 = p.first;\\n\\t\\tint y1 = p.second;\\n\\t\\tif (x1 < 0 || x1 == grid.size() || y1 < 0 || y1 == grid[0].size())\\n\\t\\t\\tcontinue;\\n\\t\\tif (visited[x1][y1] || grid[x1][y1] == 0)\\n\\t\\t\\tcontinue;\\n\\t\\tif (x1 == 0)\\n\\t\\t\\ttop_r = true;\\n\\t\\tto_clean.push_back(p);\\n\\t\\tvisited[x1][y1] = 1;\\n\\t\\tfor (auto& offset : offsets)\\n\\t\\t\\tst.push({x1 + offset[0], y1 + offset[1]});\\n\\t}\\n\\tif (top_r)\\n\\t\\treturn 0;\\n\\tclean(to_clean, grid);\\n\\treturn to_clean.size();\\n}\\n\\nvector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n\\tvector<int> res;\\n\\tint offsets[][2] = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};\\n\\tfor (auto& hit : hits) {\\n\\t\\tvector<vector<int>> visited (grid.size(), vector<int> (grid[0].size(), 0));\\n\\t\\tint x = hit[0];\\n\\t\\tint y = hit[1];\\n\\t\\tgrid[x][y] = 0;\\n\\t\\tint counter = 0;\\n\\t\\tfor (auto& offset : offsets) {\\n\\t\\t\\tcounter += countDrops(grid, x + offset[0], y + offset[1], visited);\\n\\t\\t}\\n\\t\\tres.push_back(counter);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 220266,
                "title": "python-solution-beat-100-60ms-faster-than-all-others",
                "content": "using dfs\\n\\n```\\nclass Solution(object):\\n    def hitBricks(self, grid, hits):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type hits: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(hits) == 0 or len(hits[0]) == 0:\\n            return []\\n        self.removeHitBrick(grid, hits)\\n        self.markRemainBricks(grid)\\n        return self.searchFallingBrick(grid, hits)\\n    \\n    def removeHitBrick(self, grid, hits):\\n        for i in range(len(hits)):\\n            grid[hits[i][0]][hits[i][1]] = grid[hits[i][0]][hits[i][1]] - 1\\n    \\n    def markRemainBricks(self, grid):\\n        for i in range(len(grid[0])):\\n            self.dfs(grid, 0, i)\\n    \\n    def dfs(self, grid, row, column):\\n        m, n = len(grid), len(grid[0])\\n        effectBricks = 0\\n        if row < 0 or row >= m:\\n            return effectBricks\\n        if column < 0 or column >= n:\\n            return effectBricks\\n        if grid[row][column] == 1:\\n            grid[row][column] = 2\\n            effectBricks = 1\\n            effectBricks += self.dfs(grid, row - 1, column)\\n            effectBricks += self.dfs(grid, row + 1, column)\\n            effectBricks += self.dfs(grid, row, column - 1)\\n            effectBricks += self.dfs(grid, row, column + 1)\\n        return effectBricks\\n            \\n    def searchFallingBrick(self, grid, hits):\\n        ans = [0]*len(hits)\\n        for i in range(len(hits) - 1, -1, -1):\\n            if grid[hits[i][0]][hits[i][1]] == 0:\\n                grid[hits[i][0]][hits[i][1]] = 1\\n                if self.isConnectToTop(grid, hits[i][0], hits[i][1]):\\n                    ans[i] = self.dfs(grid, hits[i][0], hits[i][1]) - 1\\n                else:\\n                    ans[i] = 0\\n        return ans\\n    \\n    \\n    \\n    def isConnectToTop(self, grid, i, j):\\n        if i == 0:\\n            return True\\n        if i - 1 >= 0 and grid[i - 1][j] == 2:\\n            return True\\n        if i + 1 < len(grid) and grid[i + 1][j] == 2:\\n            return True\\n        if j - 1 >= 0 and grid[i][j - 1] == 2:\\n            return True\\n        if j + 1 < len(grid[0]) and grid[i][j + 1] == 2:\\n            return True\\n        return False\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def hitBricks(self, grid, hits):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type hits: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(hits) == 0 or len(hits[0]) == 0:\\n            return []\\n        self.removeHitBrick(grid, hits)\\n        self.markRemainBricks(grid)\\n        return self.searchFallingBrick(grid, hits)\\n    \\n    def removeHitBrick(self, grid, hits):\\n        for i in range(len(hits)):\\n            grid[hits[i][0]][hits[i][1]] = grid[hits[i][0]][hits[i][1]] - 1\\n    \\n    def markRemainBricks(self, grid):\\n        for i in range(len(grid[0])):\\n            self.dfs(grid, 0, i)\\n    \\n    def dfs(self, grid, row, column):\\n        m, n = len(grid), len(grid[0])\\n        effectBricks = 0\\n        if row < 0 or row >= m:\\n            return effectBricks\\n        if column < 0 or column >= n:\\n            return effectBricks\\n        if grid[row][column] == 1:\\n            grid[row][column] = 2\\n            effectBricks = 1\\n            effectBricks += self.dfs(grid, row - 1, column)\\n            effectBricks += self.dfs(grid, row + 1, column)\\n            effectBricks += self.dfs(grid, row, column - 1)\\n            effectBricks += self.dfs(grid, row, column + 1)\\n        return effectBricks\\n            \\n    def searchFallingBrick(self, grid, hits):\\n        ans = [0]*len(hits)\\n        for i in range(len(hits) - 1, -1, -1):\\n            if grid[hits[i][0]][hits[i][1]] == 0:\\n                grid[hits[i][0]][hits[i][1]] = 1\\n                if self.isConnectToTop(grid, hits[i][0], hits[i][1]):\\n                    ans[i] = self.dfs(grid, hits[i][0], hits[i][1]) - 1\\n                else:\\n                    ans[i] = 0\\n        return ans\\n    \\n    \\n    \\n    def isConnectToTop(self, grid, i, j):\\n        if i == 0:\\n            return True\\n        if i - 1 >= 0 and grid[i - 1][j] == 2:\\n            return True\\n        if i + 1 < len(grid) and grid[i + 1][j] == 2:\\n            return True\\n        if j - 1 >= 0 and grid[i][j - 1] == 2:\\n            return True\\n        if j + 1 < len(grid[0]) and grid[i][j + 1] == 2:\\n            return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201573,
                "title": "union-find-java",
                "content": "reference: https://leetcode.com/problems/bricks-falling-when-hit/discuss/193781/UnionFind\\n\\n```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int[] res = new int[hits.length];\\n        int m = grid.length, n = grid[0].length;\\n        //mark the to-hit bricks to 2\\n        for (int[] hit: hits) {\\n            int x = hit[0], y = hit[1];\\n            if (grid[x][y] == 1) grid[x][y] = 2;\\n        }\\n        //m*n for grid elements, 1 for a virtual top \"0\"\\n        UnionFind uf = new UnionFind(m*n+1);\\n        //after bricks hitted, union the ones left\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) unionAround(grid, i, j, uf);\\n            }\\n        }\\n        \\n        //the count of bricks left\\n        int count = uf.sizes[uf.find(0)];\\n        \\n        for (int i = hits.length-1; i >= 0; i--) {\\n            int[] hit = hits[i];\\n            int x = hit[0], y = hit[1];\\n            if (grid[x][y] == 2) {\\n                unionAround(grid, x, y, uf);\\n                grid[x][y] = 1;\\n            }\\n            int newSize = uf.sizes[uf.find(0)];\\n            res[i] = newSize-count > 0 ? newSize-count-1 : 0;\\n            count = newSize;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void unionAround(int[][] grid, int x, int y, UnionFind uf) {\\n        int m = grid.length, n = grid[0].length;\\n        int[] dx = new int[]{-1, 1, 0, 0};\\n        int[] dy = new int[]{0, 0, -1, 1};\\n        for (int i = 0; i < 4; i++) {\\n            int nx = x+dx[i];\\n            int ny = y+dy[i];\\n            if (nx < 0 || nx >= m || ny < 0 || ny >= n) continue;\\n            if (grid[nx][ny] == 1) {\\n                uf.union(x*n+y+1, nx*n+ny+1);\\n            }\\n        }\\n        if (x == 0) uf.union(x*n+y+1, 0);\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] parents;\\n    int[] sizes;\\n    public UnionFind(int n) {\\n        parents = new int[n];\\n        sizes = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parents[i] = i;\\n            sizes[i] = 1;\\n        }\\n    }\\n    public int find(int i) {\\n        if (parents[i] != i) {\\n            return find(parents[i]);\\n        } else {\\n            return i;\\n        }\\n    }\\n    public void union(int a, int b) {\\n        int pA = find(a);\\n        int pB = find(b);\\n        if (pA != pB) {\\n            parents[pA] = pB;\\n            sizes[pB] += sizes[pA];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int[] res = new int[hits.length];\\n        int m = grid.length, n = grid[0].length;\\n        //mark the to-hit bricks to 2\\n        for (int[] hit: hits) {\\n            int x = hit[0], y = hit[1];\\n            if (grid[x][y] == 1) grid[x][y] = 2;\\n        }\\n        //m*n for grid elements, 1 for a virtual top \"0\"\\n        UnionFind uf = new UnionFind(m*n+1);\\n        //after bricks hitted, union the ones left\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) unionAround(grid, i, j, uf);\\n            }\\n        }\\n        \\n        //the count of bricks left\\n        int count = uf.sizes[uf.find(0)];\\n        \\n        for (int i = hits.length-1; i >= 0; i--) {\\n            int[] hit = hits[i];\\n            int x = hit[0], y = hit[1];\\n            if (grid[x][y] == 2) {\\n                unionAround(grid, x, y, uf);\\n                grid[x][y] = 1;\\n            }\\n            int newSize = uf.sizes[uf.find(0)];\\n            res[i] = newSize-count > 0 ? newSize-count-1 : 0;\\n            count = newSize;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void unionAround(int[][] grid, int x, int y, UnionFind uf) {\\n        int m = grid.length, n = grid[0].length;\\n        int[] dx = new int[]{-1, 1, 0, 0};\\n        int[] dy = new int[]{0, 0, -1, 1};\\n        for (int i = 0; i < 4; i++) {\\n            int nx = x+dx[i];\\n            int ny = y+dy[i];\\n            if (nx < 0 || nx >= m || ny < 0 || ny >= n) continue;\\n            if (grid[nx][ny] == 1) {\\n                uf.union(x*n+y+1, nx*n+ny+1);\\n            }\\n        }\\n        if (x == 0) uf.union(x*n+y+1, 0);\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] parents;\\n    int[] sizes;\\n    public UnionFind(int n) {\\n        parents = new int[n];\\n        sizes = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parents[i] = i;\\n            sizes[i] = 1;\\n        }\\n    }\\n    public int find(int i) {\\n        if (parents[i] != i) {\\n            return find(parents[i]);\\n        } else {\\n            return i;\\n        }\\n    }\\n    public void union(int a, int b) {\\n        int pA = find(a);\\n        int pB = find(b);\\n        if (pA != pB) {\\n            parents[pA] = pB;\\n            sizes[pB] += sizes[pA];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200303,
                "title": "c-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        vector<int>res;\\n        int m = grid.size(), n = grid[0].size();\\n        for (auto& v: hits) {\\n            int r = v[0], c = v[1], count = 0;\\n            grid[r][c] = 0;\\n            if(!reachTop(grid, r - 1, c, m, n)) {\\n                erase(grid, r - 1, c, m, n, count);\\n            }\\n            if(!reachTop(grid, r + 1, c, m, n)) {\\n                erase(grid, r + 1, c, m, n, count);\\n            }\\n            if(!reachTop(grid, r, c - 1, m, n)) {\\n                erase(grid, r, c - 1, m, n, count);\\n            }\\n            if(!reachTop(grid, r, c + 1, m, n)) {\\n                erase(grid, r, c + 1, m, n, count);\\n            }\\n            res.push_back(count);\\n        }\\n        return res;\\n    }\\n    \\n    bool reachTop(vector<vector<int>>& grid, int r, int c, int m, int n) {\\n        if (r < 0 || c < 0 || r == m || c == n || grid[r][c] == 0) {\\n            return false;\\n        }\\n        if (r == 0) {\\n            return true;\\n        }\\n        int tmp = grid[r][c];\\n        grid[r][c] = 0;\\n        bool res = reachTop(grid, r + 1, c, m, n) || reachTop(grid, r, c + 1, m, n)\\n                || reachTop(grid, r - 1, c, m, n) || reachTop(grid, r, c - 1, m, n);\\n        grid[r][c] = tmp;\\n        return res;\\n    }\\n    \\n    void erase(vector<vector<int>>& grid, int r, int c, int m, int n, int& count) {\\n        if (r < 0 || c < 0 || r == m || c == n || grid[r][c] == 0) {\\n            return;\\n        }\\n        ++count;\\n        grid[r][c] = 0;\\n        erase(grid, r + 1, c, m, n, count);\\n        erase(grid, r - 1, c, m, n, count);\\n        erase(grid, r, c + 1, m, n, count);\\n        erase(grid, r, c - 1, m, n, count);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        vector<int>res;\\n        int m = grid.size(), n = grid[0].size();\\n        for (auto& v: hits) {\\n            int r = v[0], c = v[1], count = 0;\\n            grid[r][c] = 0;\\n            if(!reachTop(grid, r - 1, c, m, n)) {\\n                erase(grid, r - 1, c, m, n, count);\\n            }\\n            if(!reachTop(grid, r + 1, c, m, n)) {\\n                erase(grid, r + 1, c, m, n, count);\\n            }\\n            if(!reachTop(grid, r, c - 1, m, n)) {\\n                erase(grid, r, c - 1, m, n, count);\\n            }\\n            if(!reachTop(grid, r, c + 1, m, n)) {\\n                erase(grid, r, c + 1, m, n, count);\\n            }\\n            res.push_back(count);\\n        }\\n        return res;\\n    }\\n    \\n    bool reachTop(vector<vector<int>>& grid, int r, int c, int m, int n) {\\n        if (r < 0 || c < 0 || r == m || c == n || grid[r][c] == 0) {\\n            return false;\\n        }\\n        if (r == 0) {\\n            return true;\\n        }\\n        int tmp = grid[r][c];\\n        grid[r][c] = 0;\\n        bool res = reachTop(grid, r + 1, c, m, n) || reachTop(grid, r, c + 1, m, n)\\n                || reachTop(grid, r - 1, c, m, n) || reachTop(grid, r, c - 1, m, n);\\n        grid[r][c] = tmp;\\n        return res;\\n    }\\n    \\n    void erase(vector<vector<int>>& grid, int r, int c, int m, int n, int& count) {\\n        if (r < 0 || c < 0 || r == m || c == n || grid[r][c] == 0) {\\n            return;\\n        }\\n        ++count;\\n        grid[r][c] = 0;\\n        erase(grid, r + 1, c, m, n, count);\\n        erase(grid, r - 1, c, m, n, count);\\n        erase(grid, r, c + 1, m, n, count);\\n        erase(grid, r, c - 1, m, n, count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191367,
                "title": "python-reverse-union-find-solution",
                "content": "```\nclass Solution(object):\n    def hitBricks(self, grid, hits):\n        o_grid=[]\n        for i in xrange(len(grid)):\n            o_grid.append([0]*len(grid[0]))\n            o_grid[i][:]=grid[i]\n        for i in xrange(len(hits)): \n            x,y=hits[i]\n            grid[x][y]=0\n        fa={}\n        edge={}\n        son={}\n        dx=[0,0,1,-1]\n        dy=[1,-1,0,0]\n        fa[-1,-1]=(-1,-1)\n        son[-1,-1]=0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if grid[i][j]==1:\n                    fa[i,j]=(i,j)\n                    son[i,j]=1\n                    if i==0: edge[i,j,-1,-1]=True\n                    for k in xrange(4):\n                        ni,nj=i+dx[k],j+dy[k]\n                        if ni>=0 and ni<len(grid) and nj>=0 and nj<len(grid[0]) and grid[ni][nj]==1:\n                            edge[i,j,ni,nj]=True\n\n        def find(node):\n            x,y=node\n            if fa[x,y]==(x,y): return (x,y)\n            t=find(fa[x,y])\n            if t!=fa[x,y]:\n                son[t]+=son[fa[x,y]]\n                son[fa[x,y]]=0\n                fa[x,y]=t\n            return fa[x,y]\n\n        def merge(x1,y1,x2,y2):\n            fa1=find((x1,y1))\n            fa2=find((x2,y2))\n            if fa1==fa2: return\n            if fa1==(-1,-1): \n                fa[fa2]=fa1\n                son[fa1]+=son[fa2]\n                son[fa2]=0\n            elif fa2==(-1,-1): \n                fa[fa1]=fa2\n                son[fa2]+=son[fa1]\n                son[fa1]=0\n            else:\n                fa[fa1]=fa2\n                son[fa2]+=son[fa1] \n                son[fa1]=0\n                      \n        for e in edge:\n            x1,y1,x2,y2=e\n            merge(x1,y1,x2,y2)\n        result=[]\n        for i in xrange(len(hits)-1,-1,-1):\n            tot_pre=son[-1,-1]\n            x,y=hits[i]\n            if o_grid[x][y]==0:\n                result.append(0)\n                continue\n            grid[x][y]=1\n            son[x,y]=1\n            fa[x,y]=(x,y)\n            if x==0: merge(x,y,-1,-1)\n            for k in xrange(4):\n                ni,nj=x+dx[k],y+dy[k]\n                if ni>=0 and ni<len(grid) and nj>=0 and nj<len(grid[0]) and grid[ni][nj]==1:\n                    merge(x,y,ni,nj)\n            result.append(max(son[-1,-1]-tot_pre-1,0))\n        result.reverse()\n        return result\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def hitBricks(self, grid, hits):\n        o_grid=[]\n        for i in xrange(len(grid)):\n            o_grid.append([0]*len(grid[0]))\n            o_grid[i][:]=grid[i]\n        for i in xrange(len(hits)): \n            x,y=hits[i]\n            grid[x][y]=0\n        fa={}\n        edge={}\n        son={}\n        dx=[0,0,1,-1]\n        dy=[1,-1,0,0]\n        fa[-1,-1]=(-1,-1)\n        son[-1,-1]=0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if grid[i][j]==1:\n                    fa[i,j]=(i,j)\n                    son[i,j]=1\n                    if i==0: edge[i,j,-1,-1]=True\n                    for k in xrange(4):\n                        ni,nj=i+dx[k],j+dy[k]\n                        if ni>=0 and ni<len(grid) and nj>=0 and nj<len(grid[0]) and grid[ni][nj]==1:\n                            edge[i,j,ni,nj]=True\n\n        def find(node):\n            x,y=node\n            if fa[x,y]==(x,y): return (x,y)\n            t=find(fa[x,y])\n            if t!=fa[x,y]:\n                son[t]+=son[fa[x,y]]\n                son[fa[x,y]]=0\n                fa[x,y]=t\n            return fa[x,y]\n\n        def merge(x1,y1,x2,y2):\n            fa1=find((x1,y1))\n            fa2=find((x2,y2))\n            if fa1==fa2: return\n            if fa1==(-1,-1): \n                fa[fa2]=fa1\n                son[fa1]+=son[fa2]\n                son[fa2]=0\n            elif fa2==(-1,-1): \n                fa[fa1]=fa2\n                son[fa2]+=son[fa1]\n                son[fa1]=0\n            else:\n                fa[fa1]=fa2\n                son[fa2]+=son[fa1] \n                son[fa1]=0\n                      \n        for e in edge:\n            x1,y1,x2,y2=e\n            merge(x1,y1,x2,y2)\n        result=[]\n        for i in xrange(len(hits)-1,-1,-1):\n            tot_pre=son[-1,-1]\n            x,y=hits[i]\n            if o_grid[x][y]==0:\n                result.append(0)\n                continue\n            grid[x][y]=1\n            son[x,y]=1\n            fa[x,y]=(x,y)\n            if x==0: merge(x,y,-1,-1)\n            for k in xrange(4):\n                ni,nj=x+dx[k],y+dy[k]\n                if ni>=0 and ni<len(grid) and nj>=0 and nj<len(grid[0]) and grid[ni][nj]==1:\n                    merge(x,y,ni,nj)\n            result.append(max(son[-1,-1]-tot_pre-1,0))\n        result.reverse()\n        return result\n```",
                "codeTag": "Java"
            },
            {
                "id": 187601,
                "title": "test-cases-contain-hitting-at-empty-cell",
                "content": "Test cases contain hitting at empty cell >_<",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 176179,
                "title": "c-solution-by-adding-bricks-back",
                "content": "Thanks to the thought from: https://leetcode.com/problems/bricks-falling-when-hit/discuss/122758/Tricky-problem-that-reverses-LC305\\n```\\nclass Solution {\\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        len= grid.size(), wid= grid[0].size();\\n        n.swap(grid);\\n        vector<int> res;\\n        for(int i= 0; i< hits.size(); i++)\\n            n[hits[i][0]][hits[i][1]]*= -1;\\n        for(int i= 0; i< wid; i++)\\n            if(n[0][i]== 1)\\n                find_conn(0, i);\\n        for(int i= hits.size()- 1; i>= 0; i--){\\n            if(n[hits[i][0]][hits[i][1]]== 0){\\n                res.insert(res.begin(), 0);\\n                continue;\\n            }\\n            \\n            num= -1;\\n            bool can_conn= false;\\n            for(int j= 0; j< 4; j++){\\n                int h= hits[i][0]+ ho[j], v= hits[i][1]+ ve[j];\\n                if(is_valid(h, v) && n[h][v]== 2){\\n                    can_conn= true;\\n                    break;\\n                }\\n            }\\n            if(can_conn || !hits[i][0])\\n                find_conn(hits[i][0], hits[i][1]);\\n            else\\n                n[hits[i][0]][hits[i][1]]= 1;\\n            res.insert(res.begin(), num> 0? num: 0);\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    int len, wid, num;\\n    vector<int> ho{-1, 1, 0, 0};\\n    vector<int> ve{0, 0, -1, 1};\\n    vector<vector<int>> n;\\n    \\n    void find_conn(int x, int y){\\n        n[x][y]= 2;\\n        num++;\\n        for(int i= 0; i< 4; i++){\\n            int h= x+ ho[i], v= y+ ve[i];\\n            if(is_valid(h, v) && n[h][v]== 1)\\n                find_conn(h, v);\\n        }\\n    }\\n    \\n    bool is_valid(int x, int y){\\n        return x>= 0 && x< len && y>= 0 && y< wid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {\\n        len= grid.size(), wid= grid[0].size();\\n        n.swap(grid);\\n        vector<int> res;\\n        for(int i= 0; i< hits.size(); i++)\\n            n[hits[i][0]][hits[i][1]]*= -1;\\n        for(int i= 0; i< wid; i++)\\n            if(n[0][i]== 1)\\n                find_conn(0, i);\\n        for(int i= hits.size()- 1; i>= 0; i--){\\n            if(n[hits[i][0]][hits[i][1]]== 0){\\n                res.insert(res.begin(), 0);\\n                continue;\\n            }\\n            \\n            num= -1;\\n            bool can_conn= false;\\n            for(int j= 0; j< 4; j++){\\n                int h= hits[i][0]+ ho[j], v= hits[i][1]+ ve[j];\\n                if(is_valid(h, v) && n[h][v]== 2){\\n                    can_conn= true;\\n                    break;\\n                }\\n            }\\n            if(can_conn || !hits[i][0])\\n                find_conn(hits[i][0], hits[i][1]);\\n            else\\n                n[hits[i][0]][hits[i][1]]= 1;\\n            res.insert(res.begin(), num> 0? num: 0);\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    int len, wid, num;\\n    vector<int> ho{-1, 1, 0, 0};\\n    vector<int> ve{0, 0, -1, 1};\\n    vector<vector<int>> n;\\n    \\n    void find_conn(int x, int y){\\n        n[x][y]= 2;\\n        num++;\\n        for(int i= 0; i< 4; i++){\\n            int h= x+ ho[i], v= y+ ve[i];\\n            if(is_valid(h, v) && n[h][v]== 1)\\n                find_conn(h, v);\\n        }\\n    }\\n    \\n    bool is_valid(int x, int y){\\n        return x>= 0 && x< len && y>= 0 && y< wid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175771,
                "title": "java-dfs-bfs-inspired-by-reverse-hint-inline-explanation",
                "content": "My implementation based on hints from https://leetcode.com/problems/bricks-falling-when-hit/discuss/122758/Tricky-problem-that-reverses-LC305\\n\\nOptimize it using bitwise operations.\\n\\n```\\n    int[] rm = new int[]{-1,1,0,0};\\n    int[] cm = new int[]{0,0,1,-1};\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int[] ret = new int[hits.length];\\n        boolean[] valid = new boolean[hits.length];\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for (int i = 0; i < hits.length; i++) {\\n            int[] hit = hits[i];\\n\\t\\t\\t\\t\\t\\t//We only care about hits with 1 in the grid\\n            if (grid[hit[0]][hit[1]] == 1) {\\n                grid[hit[0]][hit[1]] = 0;\\n                valid[i] = true;\\n            }\\n        }\\n        Queue<Integer> rq = new LinkedList<Integer>();\\n        Queue<Integer> cq = new LinkedList<Integer>();\\n        for (int i = 0; i < n; i++) {\\n            if (grid[0][i] == 1) {\\n                rq.offer(0);\\n                cq.offer(i);\\n                grid[0][i] |= 2;\\n            }\\n\\t\\t\\t\\t\\t\\t//Use bfs to mark the second bit as 1 if it\\'s connected to the top\\n            bfs(grid, rq, cq);\\n        }\\n        for (int i = hits.length-1; i >= 0; i--) {\\n            if (!valid[i])\\n                continue;\\n            int[] hit = hits[i];\\n\\t\\t\\t\\t\\t\\t//Use dfs to check if current position is connected to the top, use the third bit to track visited state.\\n            if (dfs(grid, hit[0], hit[1])) {\\n                rq.offer(hit[0]);\\n                cq.offer(hit[1]);\\n                grid[hit[0]][hit[1]] |= 2;\\n\\t\\t\\t\\t\\t\\t\\t\\t//Use bfs to count the number of positions where it\\'s previously not connected\\n                ret[i] = bfs(grid, rq, cq);\\n            }\\n            grid[hit[0]][hit[1]] |= 1;\\n        }\\n        return ret;\\n    }\\n\\n    private boolean dfs(int[][] grid, int i, int j) {\\n        if (i == 0 || (grid[i][j] & 2) > 0)\\n            return true;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = i + rm[k];\\n            int nc = j + cm[k];\\n            if (nr >= 0 && nc >= 0 && nr < grid.length && nc < grid[0].length && grid[nr][nc] >= 1 && (grid[nr][nc]&4) == 0) {\\n                grid[nr][nc] ^= 4;\\n                if (dfs(grid, nr, nc)) {\\n                    grid[nr][nc] ^= 4;\\n                    return true;\\n                }\\n                grid[nr][nc] ^= 4;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private int bfs(int[][] grid, Queue<Integer> rq, Queue<Integer> cq) {\\n        int ret = 0;\\n        while (!rq.isEmpty()) {\\n            int r = rq.poll();\\n            int c = cq.poll();\\n            for (int k = 0; k < 4; k++) {\\n                int nr = r + rm[k];\\n                int nc = c + cm[k];\\n                if (nr >= 0 && nc >= 0 && nr < grid.length && nc < grid[0].length && grid[nr][nc] == 1) {\\n                    rq.offer(nr);\\n                    cq.offer(nc);\\n                    grid[nr][nc] |= 2;\\n                    ret++;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int[] rm = new int[]{-1,1,0,0};\\n    int[] cm = new int[]{0,0,1,-1};\\n    public int[] hitBricks(int[][] grid, int[][] hits) {\\n        int[] ret = new int[hits.length];\\n        boolean[] valid = new boolean[hits.length];\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for (int i = 0; i < hits.length; i++) {\\n            int[] hit = hits[i];\\n\\t\\t\\t\\t\\t\\t//We only care about hits with 1 in the grid\\n            if (grid[hit[0]][hit[1]] == 1) {\\n                grid[hit[0]][hit[1]] = 0;\\n                valid[i] = true;\\n            }\\n        }\\n        Queue<Integer> rq = new LinkedList<Integer>();\\n        Queue<Integer> cq = new LinkedList<Integer>();\\n        for (int i = 0; i < n; i++) {\\n            if (grid[0][i] == 1) {\\n                rq.offer(0);\\n                cq.offer(i);\\n                grid[0][i] |= 2;\\n            }\\n\\t\\t\\t\\t\\t\\t//Use bfs to mark the second bit as 1 if it\\'s connected to the top\\n            bfs(grid, rq, cq);\\n        }\\n        for (int i = hits.length-1; i >= 0; i--) {\\n            if (!valid[i])\\n                continue;\\n            int[] hit = hits[i];\\n\\t\\t\\t\\t\\t\\t//Use dfs to check if current position is connected to the top, use the third bit to track visited state.\\n            if (dfs(grid, hit[0], hit[1])) {\\n                rq.offer(hit[0]);\\n                cq.offer(hit[1]);\\n                grid[hit[0]][hit[1]] |= 2;\\n\\t\\t\\t\\t\\t\\t\\t\\t//Use bfs to count the number of positions where it\\'s previously not connected\\n                ret[i] = bfs(grid, rq, cq);\\n            }\\n            grid[hit[0]][hit[1]] |= 1;\\n        }\\n        return ret;\\n    }\\n\\n    private boolean dfs(int[][] grid, int i, int j) {\\n        if (i == 0 || (grid[i][j] & 2) > 0)\\n            return true;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = i + rm[k];\\n            int nc = j + cm[k];\\n            if (nr >= 0 && nc >= 0 && nr < grid.length && nc < grid[0].length && grid[nr][nc] >= 1 && (grid[nr][nc]&4) == 0) {\\n                grid[nr][nc] ^= 4;\\n                if (dfs(grid, nr, nc)) {\\n                    grid[nr][nc] ^= 4;\\n                    return true;\\n                }\\n                grid[nr][nc] ^= 4;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private int bfs(int[][] grid, Queue<Integer> rq, Queue<Integer> cq) {\\n        int ret = 0;\\n        while (!rq.isEmpty()) {\\n            int r = rq.poll();\\n            int c = cq.poll();\\n            for (int k = 0; k < 4; k++) {\\n                int nr = r + rm[k];\\n                int nc = c + cm[k];\\n                if (nr >= 0 && nc >= 0 && nr < grid.length && nc < grid[0].length && grid[nr][nc] == 1) {\\n                    rq.offer(nr);\\n                    cq.offer(nc);\\n                    grid[nr][nc] |= 2;\\n                    ret++;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564794,
                "content": [
                    {
                        "username": "wanglu",
                        "content": "I just want to share my thoughts here. \\n\\nIf no bircks drop, then after all operations. The grid will be look like a pool with multi islands.\\nfor example:\\n0010000100\\n0111001110\\n1111111111\\nafter operations: [0,2], [2,4], [1,2], [0,7]\\n0000000000\\n0101001110\\n1111011111\\nso total 2 islands. \\n\\nThen add bricks back reversely.\\n[0,7]\\n0000000100\\n0101001110\\n1111011111\\nthe right island attaches top, and its size is 9, which means 8 bricks drop in this operation.\\n\\n[1,2]\\n0000000100\\n0111001110\\n1111011111\\nthe left island does not reach the top, so no brick drops. \\n\\n[2,4]\\n0000000100\\n0111001110\\n1111111111\\nthe left island connects to right island and acttaches top, and left island is original 7, which means 7 bricks drop in this operation.\\n\\n[0,2]\\n0010000100\\n0111001110\\n1111111111\\nthe island size is just enlarged by 1, which means no brick drops. \\n\\nHope this helps:)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "markalavin",
                        "content": "Can we assume that all initial bricks are stable?"
                    },
                    {
                        "username": "preeti3",
                        "content": "The problem with \"hard\" problems is understanding the problem is itself hard :-)"
                    },
                    {
                        "username": "user5693U",
                        "content": "How do you know? You got no xp"
                    },
                    {
                        "username": "Msey",
                        "content": "why in solution we need to reversely add bricks back?"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "you can delete the bricks from the beginning but the time complexity wil be queries*(timecomplexity of bfs or bfs) which will give you TLE. If you reverse the direction, you can solve in queries + (time complexity of bfs or bfs) "
                    },
                    {
                        "username": "markalavin",
                        "content": "If you are asking about ```sizeOfComponentIfUnstable( self, grid, row_col )```, we are not adding bricks to the grid, but we are adding the indices of bricks to a set of indices that make up a particular connected component.  Does that help?"
                    }
                ]
            },
            {
                "id": 1802527,
                "content": [
                    {
                        "username": "wanglu",
                        "content": "I just want to share my thoughts here. \\n\\nIf no bircks drop, then after all operations. The grid will be look like a pool with multi islands.\\nfor example:\\n0010000100\\n0111001110\\n1111111111\\nafter operations: [0,2], [2,4], [1,2], [0,7]\\n0000000000\\n0101001110\\n1111011111\\nso total 2 islands. \\n\\nThen add bricks back reversely.\\n[0,7]\\n0000000100\\n0101001110\\n1111011111\\nthe right island attaches top, and its size is 9, which means 8 bricks drop in this operation.\\n\\n[1,2]\\n0000000100\\n0111001110\\n1111011111\\nthe left island does not reach the top, so no brick drops. \\n\\n[2,4]\\n0000000100\\n0111001110\\n1111111111\\nthe left island connects to right island and acttaches top, and left island is original 7, which means 7 bricks drop in this operation.\\n\\n[0,2]\\n0010000100\\n0111001110\\n1111111111\\nthe island size is just enlarged by 1, which means no brick drops. \\n\\nHope this helps:)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "markalavin",
                        "content": "Can we assume that all initial bricks are stable?"
                    },
                    {
                        "username": "preeti3",
                        "content": "The problem with \"hard\" problems is understanding the problem is itself hard :-)"
                    },
                    {
                        "username": "user5693U",
                        "content": "How do you know? You got no xp"
                    },
                    {
                        "username": "Msey",
                        "content": "why in solution we need to reversely add bricks back?"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "you can delete the bricks from the beginning but the time complexity wil be queries*(timecomplexity of bfs or bfs) which will give you TLE. If you reverse the direction, you can solve in queries + (time complexity of bfs or bfs) "
                    },
                    {
                        "username": "markalavin",
                        "content": "If you are asking about ```sizeOfComponentIfUnstable( self, grid, row_col )```, we are not adding bricks to the grid, but we are adding the indices of bricks to a set of indices that make up a particular connected component.  Does that help?"
                    }
                ]
            },
            {
                "id": 1949292,
                "content": [
                    {
                        "username": "wanglu",
                        "content": "I just want to share my thoughts here. \\n\\nIf no bircks drop, then after all operations. The grid will be look like a pool with multi islands.\\nfor example:\\n0010000100\\n0111001110\\n1111111111\\nafter operations: [0,2], [2,4], [1,2], [0,7]\\n0000000000\\n0101001110\\n1111011111\\nso total 2 islands. \\n\\nThen add bricks back reversely.\\n[0,7]\\n0000000100\\n0101001110\\n1111011111\\nthe right island attaches top, and its size is 9, which means 8 bricks drop in this operation.\\n\\n[1,2]\\n0000000100\\n0111001110\\n1111011111\\nthe left island does not reach the top, so no brick drops. \\n\\n[2,4]\\n0000000100\\n0111001110\\n1111111111\\nthe left island connects to right island and acttaches top, and left island is original 7, which means 7 bricks drop in this operation.\\n\\n[0,2]\\n0010000100\\n0111001110\\n1111111111\\nthe island size is just enlarged by 1, which means no brick drops. \\n\\nHope this helps:)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "markalavin",
                        "content": "Can we assume that all initial bricks are stable?"
                    },
                    {
                        "username": "preeti3",
                        "content": "The problem with \"hard\" problems is understanding the problem is itself hard :-)"
                    },
                    {
                        "username": "user5693U",
                        "content": "How do you know? You got no xp"
                    },
                    {
                        "username": "Msey",
                        "content": "why in solution we need to reversely add bricks back?"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "you can delete the bricks from the beginning but the time complexity wil be queries*(timecomplexity of bfs or bfs) which will give you TLE. If you reverse the direction, you can solve in queries + (time complexity of bfs or bfs) "
                    },
                    {
                        "username": "markalavin",
                        "content": "If you are asking about ```sizeOfComponentIfUnstable( self, grid, row_col )```, we are not adding bricks to the grid, but we are adding the indices of bricks to a set of indices that make up a particular connected component.  Does that help?"
                    }
                ]
            },
            {
                "id": 1933226,
                "content": [
                    {
                        "username": "wanglu",
                        "content": "I just want to share my thoughts here. \\n\\nIf no bircks drop, then after all operations. The grid will be look like a pool with multi islands.\\nfor example:\\n0010000100\\n0111001110\\n1111111111\\nafter operations: [0,2], [2,4], [1,2], [0,7]\\n0000000000\\n0101001110\\n1111011111\\nso total 2 islands. \\n\\nThen add bricks back reversely.\\n[0,7]\\n0000000100\\n0101001110\\n1111011111\\nthe right island attaches top, and its size is 9, which means 8 bricks drop in this operation.\\n\\n[1,2]\\n0000000100\\n0111001110\\n1111011111\\nthe left island does not reach the top, so no brick drops. \\n\\n[2,4]\\n0000000100\\n0111001110\\n1111111111\\nthe left island connects to right island and acttaches top, and left island is original 7, which means 7 bricks drop in this operation.\\n\\n[0,2]\\n0010000100\\n0111001110\\n1111111111\\nthe island size is just enlarged by 1, which means no brick drops. \\n\\nHope this helps:)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "markalavin",
                        "content": "Can we assume that all initial bricks are stable?"
                    },
                    {
                        "username": "preeti3",
                        "content": "The problem with \"hard\" problems is understanding the problem is itself hard :-)"
                    },
                    {
                        "username": "user5693U",
                        "content": "How do you know? You got no xp"
                    },
                    {
                        "username": "Msey",
                        "content": "why in solution we need to reversely add bricks back?"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "you can delete the bricks from the beginning but the time complexity wil be queries*(timecomplexity of bfs or bfs) which will give you TLE. If you reverse the direction, you can solve in queries + (time complexity of bfs or bfs) "
                    },
                    {
                        "username": "markalavin",
                        "content": "If you are asking about ```sizeOfComponentIfUnstable( self, grid, row_col )```, we are not adding bricks to the grid, but we are adding the indices of bricks to a set of indices that make up a particular connected component.  Does that help?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Snapshot Array",
        "question_content": "<p>Implement a SnapshotArray that supports the following interface:</p>\n\n<ul>\n\t<li><code>SnapshotArray(int length)</code> initializes an array-like data structure with the given length. <strong>Initially, each element equals 0</strong>.</li>\n\t<li><code>void set(index, val)</code> sets the element at the given <code>index</code> to be equal to <code>val</code>.</li>\n\t<li><code>int snap()</code> takes a snapshot of the array and returns the <code>snap_id</code>: the total number of times we called <code>snap()</code> minus <code>1</code>.</li>\n\t<li><code>int get(index, snap_id)</code> returns the value at the given <code>index</code>, at the time we took the snapshot with the given <code>snap_id</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> [&quot;SnapshotArray&quot;,&quot;set&quot;,&quot;snap&quot;,&quot;set&quot;,&quot;get&quot;]\n[[3],[0,5],[],[0,6],[0,0]]\n<strong>Output:</strong> [null,null,0,null,5]\n<strong>Explanation: </strong>\nSnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3\nsnapshotArr.set(0,5);  // Set array[0] = 5\nsnapshotArr.snap();  // Take a snapshot, return snap_id = 0\nsnapshotArr.set(0,6);\nsnapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= index &lt; length</code></li>\n\t<li><code>0 &lt;= val &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= snap_id &lt; </code>(the total number of times we call <code>snap()</code>)</li>\n\t<li>At most <code>5 * 10<sup>4</sup></code> calls will be made to <code>set</code>, <code>snap</code>, and <code>get</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 350562,
                "title": "java-python-binary-search",
                "content": "## **Intuition**\\nInstead of copy the whole array,\\nwe can only record the changes of `set`.\\n<br>\\n\\n## **Explanation**\\nThe idea is, the whole array can be large,\\nand we may take the `snap` tons of times.\\n(Like you may always ctrl + S twice)\\n\\nInstead of record the history of the whole array,\\nwe will record the history of each cell.\\nAnd this is the minimum space that we need to record all information.\\n\\nFor each `A[i]`, we will record its history.\\nWith a `snap_id` and a its value.\\n\\nWhen we want to `get` the value in history, just binary search the time point.\\n<br>\\n\\n## **Complexity**\\nTime `O(logS)`\\nSpace `O(S)`\\nwhere `S` is the number of `set` called.\\n\\n`SnapshotArray(int length)` is `O(N)` time\\n`set(int index, int val)` is O(1) in Python and `O(logSnap)` in Java\\n`snap()` is `O(1)`\\n`get(int index, int snap_id)` is `O(logSnap)`\\n<br>\\n\\n**Java**\\n```java\\nclass SnapshotArray {\\n    TreeMap<Integer, Integer>[] A;\\n    int snap_id = 0;\\n    public SnapshotArray(int length) {\\n        A = new TreeMap[length];\\n        for (int i = 0; i < length; i++) {\\n            A[i] = new TreeMap<Integer, Integer>();\\n            A[i].put(0, 0);\\n        }\\n    }\\n\\n    public void set(int index, int val) {\\n        A[index].put(snap_id, val);\\n    }\\n\\n    public int snap() {\\n        return snap_id++;\\n    }\\n\\n    public int get(int index, int snap_id) {\\n        return A[index].floorEntry(snap_id).getValue();\\n    }\\n}\\n```\\n**C++**\\nfrom @vikas007\\n```\\nclass SnapshotArray {\\nprivate:\\n    map<int, map<int, int>> snaps;\\n    int snapId = 0;\\npublic:\\n    SnapshotArray(int length) {\\n        for (int i = 0; i < length; i++) {\\n            map<int, int> mp; mp[0] = 0;\\n            snaps[i] = mp;\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        snaps[index][snapId] = val;\\n    }\\n    \\n    int snap() {\\n        return snapId++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it = snaps[index].upper_bound(snap_id); it--;\\n        return it->second;\\n    }\\n};\\n```\\n\\n**Python:**\\n```python\\nclass SnapshotArray(object):\\n\\n    def __init__(self, n):\\n        self.A = [[[-1, 0]] for _ in xrange(n)]\\n        self.snap_id = 0\\n\\n    def set(self, index, val):\\n        self.A[index].append([self.snap_id, val])\\n\\n    def snap(self):\\n        self.snap_id += 1\\n        return self.snap_id - 1\\n\\n    def get(self, index, snap_id):\\n        i = bisect.bisect(self.A[index], [snap_id + 1]) - 1\\n        return self.A[index][i][1]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\nclass SnapshotArray {\\n    TreeMap<Integer, Integer>[] A;\\n    int snap_id = 0;\\n    public SnapshotArray(int length) {\\n        A = new TreeMap[length];\\n        for (int i = 0; i < length; i++) {\\n            A[i] = new TreeMap<Integer, Integer>();\\n            A[i].put(0, 0);\\n        }\\n    }\\n\\n    public void set(int index, int val) {\\n        A[index].put(snap_id, val);\\n    }\\n\\n    public int snap() {\\n        return snap_id++;\\n    }\\n\\n    public int get(int index, int snap_id) {\\n        return A[index].floorEntry(snap_id).getValue();\\n    }\\n}\\n```\n```\\nclass SnapshotArray {\\nprivate:\\n    map<int, map<int, int>> snaps;\\n    int snapId = 0;\\npublic:\\n    SnapshotArray(int length) {\\n        for (int i = 0; i < length; i++) {\\n            map<int, int> mp; mp[0] = 0;\\n            snaps[i] = mp;\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        snaps[index][snapId] = val;\\n    }\\n    \\n    int snap() {\\n        return snapId++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it = snaps[index].upper_bound(snap_id); it--;\\n        return it->second;\\n    }\\n};\\n```\n```python\\nclass SnapshotArray(object):\\n\\n    def __init__(self, n):\\n        self.A = [[[-1, 0]] for _ in xrange(n)]\\n        self.snap_id = 0\\n\\n    def set(self, index, val):\\n        self.A[index].append([self.snap_id, val])\\n\\n    def snap(self):\\n        self.snap_id += 1\\n        return self.snap_id - 1\\n\\n    def get(self, index, snap_id):\\n        i = bisect.bisect(self.A[index], [snap_id + 1]) - 1\\n        return self.A[index][i][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350656,
                "title": "c-hash-map-vector",
                "content": "It\\'s similar to [981. Time Based Key-Value Store](https://leetcode.com/problems/time-based-key-value-store/discuss/226664/C%2B%2B-3-lines-hash-map-%2B-map).\\n\\nFor each index, we store values in the map for each snap id. We maintain the current snap id and use it in ```set```. When we do ```snap```, we just increase snap id. Therefore, our map will only contain snap ids when the value was set.\\n\\nFor ```get```, we use binary search to find the most recent value for the requested snap id.\\n\\n> Note that we can achieve O(1) complexity for the get operation, but it won\\'t be memory-efficient if we populate all indices and then make a lot of snaps (without modifying much).\\n\\n**C++**\\n```\\nunordered_map<int, map<int, int>> a;\\nint cur_snap = 0;\\nSnapshotArray(int length) {}\\nint snap() { return cur_snap++; }\\nvoid set(int index, int val) { \\n  a[index][cur_snap] = val; \\n}\\nint get(int index, int snap_id) {\\n  auto it = a[index].upper_bound(snap_id);\\n  return it == begin(a[index]) ? 0 : prev(it)->second;\\n}\\n```\\nSince our timestamps are only increasing, we can use a vector instead of a map, though it\\'s not as concise.\\n\\n**C++**\\n```\\nvector<vector<pair<int, int>>> m;\\nint cur_snap = 0;\\nSnapshotArray(int length) {\\n    m = vector<vector<pair<int, int>>>(length);\\n}\\nint snap() { return cur_snap++; }\\nvoid set(int index, int val) {\\n  if (m[index].empty() || m[index].back().first != cur_snap)\\n    m[index].push_back({ cur_snap, val });\\n  else m[index].back().second = val;\\n}\\nint get(int index, int snap_id) {\\n  auto it = upper_bound(begin(m[index]), end(m[index]), pair<int, int>(snap_id, INT_MAX));\\n  return it == begin(m[index]) ? 0 : prev(it)->second;\\n}};\\n```\\n# Complexity analysis\\nAssuming ```n``` is the number of ```set``` + ```snap``` operations, and ```m``` is the number of get operations:\\n> Note: for the complexity analysis, we consider  ```set``` + ```snap``` as one operation. Otherwise, neither ```set``` nor ```snap``` alone increases the number of values we need to consider for the ```get``` operation.\\n\\n- Time Complexity: \\n    - Set: ```O(1)``` single operation, and total ```O(n)```.\\n    - Get: ```O(log n)``` for a single operation, and total ```O(m log n)```.\\n- Space Complexity: ```O(n)```",
                "solutionTags": [],
                "code": "```set```\n```snap```\n```get```\n```\\nunordered_map<int, map<int, int>> a;\\nint cur_snap = 0;\\nSnapshotArray(int length) {}\\nint snap() { return cur_snap++; }\\nvoid set(int index, int val) { \\n  a[index][cur_snap] = val; \\n}\\nint get(int index, int snap_id) {\\n  auto it = a[index].upper_bound(snap_id);\\n  return it == begin(a[index]) ? 0 : prev(it)->second;\\n}\\n```\n```\\nvector<vector<pair<int, int>>> m;\\nint cur_snap = 0;\\nSnapshotArray(int length) {\\n    m = vector<vector<pair<int, int>>>(length);\\n}\\nint snap() { return cur_snap++; }\\nvoid set(int index, int val) {\\n  if (m[index].empty() || m[index].back().first != cur_snap)\\n    m[index].push_back({ cur_snap, val });\\n  else m[index].back().second = val;\\n}\\nint get(int index, int snap_id) {\\n  auto it = upper_bound(begin(m[index]), end(m[index]), pair<int, int>(snap_id, INT_MAX));\\n  return it == begin(m[index]) ? 0 : prev(it)->second;\\n}};\\n```\n```n```\n```set```\n```snap```\n```m```\n```set```\n```snap```\n```set```\n```snap```\n```get```\n```O(1)```\n```O(n)```\n```O(log n)```\n```O(m log n)```\n```O(n)```",
                "codeTag": "Unknown"
            },
            {
                "id": 1335346,
                "title": "python-hashmap-binary-search-clean-concise",
                "content": "**Idea**\\n- We map `index` with `(snapId, val)`, let name it `map`.\\n- For `get(index, snapId)`:\\n\\t- Get versions from the map based on `index`, `arr = map[index]`.\\n\\t- We binary search on `arr` to find the version, which has largest snapId <= `snapId`.\\n\\t- For example: \\n\\t\\t- set(index=1, val=9), snapId = 0\\n\\t\\t- snap(), snapId = 1\\n\\t\\t- snap(), snapId = 2\\n\\t\\t- get(index=1, snapId=2)\\n```python\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.map = defaultdict(list)\\n        self.snapId = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        if self.map[index] and self.map[index][-1][0] == self.snapId:\\n            self.map[index][-1][1] = val\\n            return\\n        self.map[index].append([self.snapId, val])\\n\\n    def snap(self) -> int:\\n        self.snapId += 1\\n        return self.snapId - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        arr = self.map[index]\\n        left, right, ans = 0, len(arr) - 1, -1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if arr[mid][0] <= snap_id:\\n                ans = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        if ans == -1: return 0\\n        return arr[ans][1]\\n```\\nComplexity:\\n- Time: \\n\\t- Constructor, set, snap: `O(1)`\\n\\t- get: `O(logN)`\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.map = defaultdict(list)\\n        self.snapId = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        if self.map[index] and self.map[index][-1][0] == self.snapId:\\n            self.map[index][-1][1] = val\\n            return\\n        self.map[index].append([self.snapId, val])\\n\\n    def snap(self) -> int:\\n        self.snapId += 1\\n        return self.snapId - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        arr = self.map[index]\\n        left, right, ans = 0, len(arr) - 1, -1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if arr[mid][0] <= snap_id:\\n                ans = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        if ans == -1: return 0\\n        return arr[ans][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623538,
                "title": "simple-java-c-python-easy-to-understand",
                "content": "# Please Vote up :))\\n**For this problem we need to optimize on space so we can\\'t tradeoff memory for time. If you save the whole array for every snapshot there will be \"Memory limit exceeded\" error.\\n\\nEssentially we are interested only in history of changes for the index, and it could be only few changes of one index. This means we need to lookup effectively value by index and save only those that changed. We can use Map for this, use index as key, value as a value.\\n\\nWe keep such map for every snapshot, each consequence change will override previous value but this is perfectly fine - we care only about last value. We keep maps in a list, index of the element is a snapshot index.\\n\\nOn value lookup we start scanning list elements starting from the passed snapshot_id back to 0. Return first value for the index that we found - this means the most recent change up to this snapshot_id. If we haven\\'t found anything it means there were no changes and we can return initial value which is 0 for all elements.\\n\\nO(1) for set - lookup for the map is O(1), put to the map is O(1) (average).\\nO(snap_id) for get() - we can potentially search up to snap_id snapshots (maps in our list), then O(1) for the lookup by index.\\nO(length^2) for space - we can save every element in map, then change every element for every snapshot**\\n\\n# Approach\\nHere\\'s a brief explanation of the approach:\\n\\n    The array variable is initialized as a list of lists, where each element represents the history of a specific index. Each history entry is a tuple (snap_id, value) that records the value at that index and the snapshot ID when it was set.\\n\\n    The set method appends a new history entry to the corresponding index in the array, using the current snap_id and the provided value.\\n\\n    The snap method increments the snap_id and returns the previous snap_id, which represents the total number of snapshots taken minus 1.\\n\\n    The get method searches for the closest snapshot index in the history of the specified index using binary search. It then returns the value recorded at that snapshot index.\\n\\nThis implementation provides efficient snapshots by only storing the changed values at each index and using binary search for retrieval, resulting in O(log N) time complexity for the get method, where N is the number of snapshots taken.\\n\\n\\n\\n#  JAVA Code\\n```\\nclass SnapshotArray {\\n    TreeMap<Integer, Integer>[] Tm;\\n    int snap_id = 0;\\n    public SnapshotArray(int length) {\\n        Tm = new TreeMap[length];\\n        for (int i = 0; i < length; i++) {\\n            Tm[i] = new TreeMap<Integer, Integer>();\\n            Tm[i].put(0, 0);\\n        }\\n    }\\n\\n    public void set(int index, int val) {\\n        Tm[index].put(snap_id, val);\\n    }\\n\\n    public int snap() {\\n        return snap_id++;\\n    }\\n\\n    public int get(int index, int snap_id) {\\n        return Tm[index].floorEntry(snap_id).getValue();\\n    }\\n}\\n\\n\\n```\\n\\n\\n\\n\\n# C++ Code\\n\\n\\n```\\nclass SnapshotArray {\\n    vector<vector<pair<int, int>>>updates;\\n    int curSnap;\\n\\npublic:\\n    SnapshotArray(int length) {\\n        updates.resize(length);\\n        curSnap = 0;\\n    }\\n\\n    void set(int index, int val) {\\n        if (!updates[index].empty() && updates[index].back().first == curSnap)\\n            updates[index].back().second = val;\\n        else\\n            updates[index].push_back({curSnap, val});\\n    }\\n\\n    int snap() {\\n        curSnap++;\\n        return curSnap - 1;\\n    }\\n\\n    int get(int index, int snap_id) {\\n        int idx = upper_bound(updates[index].begin(), updates[index].end(), make_pair(snap_id,INT_MAX)) - updates[index].begin();\\n        if (idx == 0) return 0;\\n        return updates[index][idx - 1].second;\\n    }\\n};\\n\\n```\\n\\n\\n# Python Code\\n\\n\\n```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.cur_id = 0\\n        self.curVals = [0] * length\\n        self.snapIdArr = [[-1] for _ in range(length)]\\n        self.arrVal = [[0] for _ in range(length)]\\n        self.modified = set()\\n\\n    def set(self, index: int, val: int) -> None:\\n        if val == self.arrVal[index][-1]:\\n            if index in self.modified: self.modified.remove(index)\\n            return\\n        self.curVals[index] = val\\n        if index not in self.modified: self.modified.add(index)\\n\\n    def snap(self) -> int:\\n        for idx in self.modified:\\n            self.snapIdArr[idx].append(self.cur_id)\\n            self.arrVal[idx].append(self.curVals[idx])\\n        self.modified.clear()\\n        self.cur_id += 1\\n        return self.cur_id - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        arr = self.snapIdArr[index]\\n        l, r = 0, len(arr)\\n        while l < r:\\n            m = (l + r) // 2\\n            if arr[m] <= snap_id:\\n                l = m + 1\\n            else: r = m\\n        return self.arrVal[index][l-1]\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass SnapshotArray {\\n    TreeMap<Integer, Integer>[] Tm;\\n    int snap_id = 0;\\n    public SnapshotArray(int length) {\\n        Tm = new TreeMap[length];\\n        for (int i = 0; i < length; i++) {\\n            Tm[i] = new TreeMap<Integer, Integer>();\\n            Tm[i].put(0, 0);\\n        }\\n    }\\n\\n    public void set(int index, int val) {\\n        Tm[index].put(snap_id, val);\\n    }\\n\\n    public int snap() {\\n        return snap_id++;\\n    }\\n\\n    public int get(int index, int snap_id) {\\n        return Tm[index].floorEntry(snap_id).getValue();\\n    }\\n}\\n\\n\\n```\n```\\nclass SnapshotArray {\\n    vector<vector<pair<int, int>>>updates;\\n    int curSnap;\\n\\npublic:\\n    SnapshotArray(int length) {\\n        updates.resize(length);\\n        curSnap = 0;\\n    }\\n\\n    void set(int index, int val) {\\n        if (!updates[index].empty() && updates[index].back().first == curSnap)\\n            updates[index].back().second = val;\\n        else\\n            updates[index].push_back({curSnap, val});\\n    }\\n\\n    int snap() {\\n        curSnap++;\\n        return curSnap - 1;\\n    }\\n\\n    int get(int index, int snap_id) {\\n        int idx = upper_bound(updates[index].begin(), updates[index].end(), make_pair(snap_id,INT_MAX)) - updates[index].begin();\\n        if (idx == 0) return 0;\\n        return updates[index][idx - 1].second;\\n    }\\n};\\n\\n```\n```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.cur_id = 0\\n        self.curVals = [0] * length\\n        self.snapIdArr = [[-1] for _ in range(length)]\\n        self.arrVal = [[0] for _ in range(length)]\\n        self.modified = set()\\n\\n    def set(self, index: int, val: int) -> None:\\n        if val == self.arrVal[index][-1]:\\n            if index in self.modified: self.modified.remove(index)\\n            return\\n        self.curVals[index] = val\\n        if index not in self.modified: self.modified.add(index)\\n\\n    def snap(self) -> int:\\n        for idx in self.modified:\\n            self.snapIdArr[idx].append(self.cur_id)\\n            self.arrVal[idx].append(self.curVals[idx])\\n        self.modified.clear()\\n        self.cur_id += 1\\n        return self.cur_id - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        arr = self.snapIdArr[index]\\n        l, r = 0, len(arr)\\n        while l < r:\\n            m = (l + r) // 2\\n            if arr[m] <= snap_id:\\n                l = m + 1\\n            else: r = m\\n        return self.arrVal[index][l-1]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350648,
                "title": "java-o-1-snap-o-logn-get-set-using-treemap",
                "content": "```\\nclass SnapshotArray {\\n    \\n    List<TreeMap<Integer, Integer>> arr;\\n    int currId = 0;\\n\\n    public SnapshotArray(int length) {\\n        arr = new ArrayList();\\n        \\n        for (int i = 0; i < length; i++) {\\n            arr.add(i, new TreeMap<Integer, Integer>());\\n            arr.get(i).put(0, 0);\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        arr.get(index).put(currId, val);\\n    }\\n    \\n    public int snap() {\\n        return currId++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        return arr.get(index).floorEntry(snap_id).getValue();\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n    \\n    List<TreeMap<Integer, Integer>> arr;\\n    int currId = 0;\\n\\n    public SnapshotArray(int length) {\\n        arr = new ArrayList();\\n        \\n        for (int i = 0; i < length; i++) {\\n            arr.add(i, new TreeMap<Integer, Integer>());\\n            arr.get(i).put(0, 0);\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        arr.get(index).put(currId, val);\\n    }\\n    \\n    public int snap() {\\n        return currId++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        return arr.get(index).floorEntry(snap_id).getValue();\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350574,
                "title": "java-python-3-3-codes-w-analysis-store-difference-by-hashmap-and-treemap-respectively",
                "content": "**Method 1: HashMap**\\nStore to a HashMap the `set()` results since previous snapshot.\\n\\n**Analysis:**\\nTime: Each call of `get()` cost `O(snap_id)`,  others` O(1)`;\\nSpace: Total cost `O(n + length)`, where `n` is number of calls of `set()`.\\n\\n```    \\n    private List<Map<Integer, Integer>> shot;\\n    private Map<Integer, Integer> diff;\\n    \\n    public SnapshotArray(int length) {\\n        shot  = new ArrayList<>(length);\\n        diff  = new HashMap<>(length);\\n    }\\n    \\n    public void set(int index, int val) {\\n        diff.put(index, val);\\n    }\\n    \\n    public int snap() {\\n        shot.add(diff);\\n        diff = new HashMap<>();\\n        return shot.size() - 1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        for (int i = snap_id; i >= 0; --i)\\n             if (shot.get(i).containsKey(index))   \\n                 return shot.get(i).get(index); \\n        return 0;\\n    }\\n```\\n----\\n**Method 2: TreeMap**\\nStore the `set()` result together with current snapshot `count` to the TreeMap of the specified index.\\n\\n**Analysis:**\\nTime: Instantiation cost `O(length)`, each call of `get()/set()` cost `O(log(count))`, `snap() O(1)`;\\nSpace: Total cost `O(length + count)`.\\n```\\n    private int count;\\n    private List<TreeMap<Integer, Integer>> shot = new ArrayList<>();\\n    \\n    public SnapshotArray(int length) {\\n        IntStream.range(0, length).forEach(i -> { shot.add(new TreeMap<>()); });\\n    }\\n    \\n    public void set(int index, int val) {\\n        shot.get(index).put(count, val);\\n    }\\n    \\n    public int snap() {\\n        return count++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        Integer key = shot.get(index).floorKey(snap_id);\\n        return key == null ? 0 : shot.get(index).get(key);\\n    }\\n```\\n\\n----\\n\\n**Method 3: Binary Search**\\n\\n```python\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.snap_id = 0\\n        self.shot = [[[-1, 0]] for _ in range(length)]\\n\\n    def set(self, index: int, val: int) -> None:\\n        a = self.shot[index]\\n        if a[-1][0] == self.snap_id:\\n            a[-1][1] = val\\n        else:\\n            a.append([self.snap_id, val])\\n\\n    def snap(self) -> int:\\n        self.snap_id += 1\\n        return self.snap_id - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        a = self.shot[index]\\n        id = bisect.bisect(a, [snap_id + 1, ]) - 1\\n        return a[id][1]\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```    \\n    private List<Map<Integer, Integer>> shot;\\n    private Map<Integer, Integer> diff;\\n    \\n    public SnapshotArray(int length) {\\n        shot  = new ArrayList<>(length);\\n        diff  = new HashMap<>(length);\\n    }\\n    \\n    public void set(int index, int val) {\\n        diff.put(index, val);\\n    }\\n    \\n    public int snap() {\\n        shot.add(diff);\\n        diff = new HashMap<>();\\n        return shot.size() - 1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        for (int i = snap_id; i >= 0; --i)\\n             if (shot.get(i).containsKey(index))   \\n                 return shot.get(i).get(index); \\n        return 0;\\n    }\\n```\n```\\n    private int count;\\n    private List<TreeMap<Integer, Integer>> shot = new ArrayList<>();\\n    \\n    public SnapshotArray(int length) {\\n        IntStream.range(0, length).forEach(i -> { shot.add(new TreeMap<>()); });\\n    }\\n    \\n    public void set(int index, int val) {\\n        shot.get(index).put(count, val);\\n    }\\n    \\n    public int snap() {\\n        return count++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        Integer key = shot.get(index).floorKey(snap_id);\\n        return key == null ? 0 : shot.get(index).get(key);\\n    }\\n```\n```python\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.snap_id = 0\\n        self.shot = [[[-1, 0]] for _ in range(length)]\\n\\n    def set(self, index: int, val: int) -> None:\\n        a = self.shot[index]\\n        if a[-1][0] == self.snap_id:\\n            a[-1][1] = val\\n        else:\\n            a.append([self.snap_id, val])\\n\\n    def snap(self) -> int:\\n        self.snap_id += 1\\n        return self.snap_id - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        a = self.shot[index]\\n        id = bisect.bisect(a, [snap_id + 1, ]) - 1\\n        return a[id][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850249,
                "title": "python-3-three-methods-explanations",
                "content": "### Approach \\\\#1. Brutal Force\\n- Straight forward solution, actual do snap very time `snap` is called\\n- This is quick to access, but take lots of extra space and it takes time to take snap shot, as we need to make a copy\\n```\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.cache = []\\n        self.d = dict()\\n        self.i = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.d[index] = val\\n\\n    def snap(self) -> int:\\n        self.cache.append(dict(self.d))\\n        self.i += 1\\n        return self.i-1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        snap = self.cache[snap_id]\\n        return snap[index] if index in snap else 0\\n```\\n\\n### Approach \\\\#2. `defaultdict` + `OrderedDict` + Binary Search\\n- Take individual snap shot when `set` is called, increment snap id (`self.i`), when `snap` is called\\n- This is fast to `set` & `snap` but relatively slow when you do an get\\n\\t- even if it\\'s binary search, make `keys` indexable take time \\n- It save space too\\n```\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.cache = collections.defaultdict(lambda : collections.OrderedDict())\\n        self.i = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.cache[index][self.i] = val\\n\\n    def snap(self) -> int:\\n        self.i += 1\\n        return self.i-1\\n        \\n    @lru_cache(maxsize=None)    \\n    def get(self, index: int, snap_id: int) -> int:\\n        if index not in self.cache: return 0\\n        else:\\n            idx_cache = self.cache[index]\\n            if snap_id in idx_cache: return idx_cache[snap_id]\\n            else:\\n                keys = list(idx_cache.keys()) \\n                i = bisect.bisect(keys, snap_id)\\n                if snap_id > keys[-1]: return idx_cache[keys[-1]]\\n                elif i == 0: return 0\\n                else: return idx_cache[keys[i-1]]\\n```\\n### Approach \\\\#3. List of list + Binary Search\\n- A little combination of two above\\n- Space used in greater than approach \\\\#2 and less than approach \\\\#1\\n- Fast to `set` and `snap`, `get` speed should be faster than apporach \\\\#2 but slower than approach \\\\#1\\n```\\nclass SnapshotArray(object):\\n    def __init__(self, n):\\n        self.cache = [[[-1, 0]] for _ in range(n)]\\n        self.i = 0\\n\\n    def set(self, index, val):\\n        self.cache[index].append([self.i, val])\\n\\n    def snap(self):\\n        self.i += 1\\n        return self.i - 1\\n\\n    @lru_cache(maxsize=None)\\n    def get(self, index, snap_id):\\n        i = bisect.bisect(self.cache[index], [snap_id + 1]) - 1\\n        return self.cache[index][i][1]    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.cache = []\\n        self.d = dict()\\n        self.i = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.d[index] = val\\n\\n    def snap(self) -> int:\\n        self.cache.append(dict(self.d))\\n        self.i += 1\\n        return self.i-1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        snap = self.cache[snap_id]\\n        return snap[index] if index in snap else 0\\n```\n```\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.cache = collections.defaultdict(lambda : collections.OrderedDict())\\n        self.i = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.cache[index][self.i] = val\\n\\n    def snap(self) -> int:\\n        self.i += 1\\n        return self.i-1\\n        \\n    @lru_cache(maxsize=None)    \\n    def get(self, index: int, snap_id: int) -> int:\\n        if index not in self.cache: return 0\\n        else:\\n            idx_cache = self.cache[index]\\n            if snap_id in idx_cache: return idx_cache[snap_id]\\n            else:\\n                keys = list(idx_cache.keys()) \\n                i = bisect.bisect(keys, snap_id)\\n                if snap_id > keys[-1]: return idx_cache[keys[-1]]\\n                elif i == 0: return 0\\n                else: return idx_cache[keys[i-1]]\\n```\n```\\nclass SnapshotArray(object):\\n    def __init__(self, n):\\n        self.cache = [[[-1, 0]] for _ in range(n)]\\n        self.i = 0\\n\\n    def set(self, index, val):\\n        self.cache[index].append([self.i, val])\\n\\n    def snap(self):\\n        self.i += 1\\n        return self.i - 1\\n\\n    @lru_cache(maxsize=None)\\n    def get(self, index, snap_id):\\n        i = bisect.bisect(self.cache[index], [snap_id + 1]) - 1\\n        return self.cache[index][i][1]    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 454280,
                "title": "java-list-and-map-explained-clean-beats-95",
                "content": "For this problem we need to optimize on space so we can\\'t tradeoff memory for time. If you save the whole array for every snapshot there will be \"Memory limit exceeded\" error. \\n\\nEssentially we are interested only in history of changes for the index, and it could be only few changes of one index. This means we need to lookup effectively value by index and save only those that changed. We can use Map for this, use index as key, value as a value. \\n\\nWe keep such map for every snapshot, each consequence change will override previous value but this is perfectly fine - we care only about last value. We keep maps in a list, index of the element is a snapshot index.\\n\\nOn value lookup we start scanning list elements starting from the passed snapshot_id back to 0. Return first value for the index that we found - this means the most recent change up to this snapshot_id. If we haven\\'t found anything it means there were no changes and we can return initial value which is 0 for all elements.\\n\\nO(1) for set - lookup for the map is O(1), put to the map is O(1) (average). \\nO(snap_id) for get() - we can potentially search up to snap_id snapshots (maps in our list), then O(1) for the lookup by index.\\nO(length^2) for space - we can save every element in map, then change every element for every snapshot\\n\\n```\\n    List<Map<Integer, Integer>> list;\\n    \\n    public SnapshotArray(int length) {\\n        list = new ArrayList();\\n        list.add(new HashMap());\\n    }\\n    \\n    public void set(int index, int val) {\\n        int snapId = list.size() - 1;\\n        list.get(snapId).put(index, val);\\n    }\\n    \\n    public int snap() {\\n        list.add(new HashMap());\\n        return list.size() - 2;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        for (int snap = snap_id; snap >= 0; snap--) {\\n            if (list.get(snap).containsKey(index))\\n                return list.get(snap).get(index);\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    List<Map<Integer, Integer>> list;\\n    \\n    public SnapshotArray(int length) {\\n        list = new ArrayList();\\n        list.add(new HashMap());\\n    }\\n    \\n    public void set(int index, int val) {\\n        int snapId = list.size() - 1;\\n        list.get(snapId).put(index, val);\\n    }\\n    \\n    public int snap() {\\n        list.add(new HashMap());\\n        return list.size() - 2;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        for (int snap = snap_id; snap >= 0; snap--) {\\n            if (list.get(snap).containsKey(index))\\n                return list.get(snap).get(index);\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350639,
                "title": "python-dictionary",
                "content": "The idea is to capture the changes for a current version (`snap_cnt`) in a dictionary. Each snapshot is stored in another dictionary which holds the `snap_cnt` as a key and the changes as a value.\\n\\nWhen retrieving a value (`get(...) method`), it will travel back to previous versions until a value for a requested index is found. If value is not found, return a default value `0`.\\n\\n```py\\nfrom collections import defaultdict\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.snaps = defaultdict(defaultdict)\\n        self.snap_cnt = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.snaps[self.snap_cnt][index] = val\\n\\n    def snap(self) -> int:\\n        self.snap_cnt += 1\\n        return self.snap_cnt - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        cur = snap_id\\n        while cur > 0 and index not in self.snaps[cur]:\\n            cur -= 1\\n        if index in self.snaps[cur]:\\n            return self.snaps[cur][index]\\n        return 0\\n```\\t\\t",
                "solutionTags": [],
                "code": "```py\\nfrom collections import defaultdict\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.snaps = defaultdict(defaultdict)\\n        self.snap_cnt = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.snaps[self.snap_cnt][index] = val\\n\\n    def snap(self) -> int:\\n        self.snap_cnt += 1\\n        return self.snap_cnt - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        cur = snap_id\\n        while cur > 0 and index not in self.snaps[cur]:\\n            cur -= 1\\n        if index in self.snaps[cur]:\\n            return self.snaps[cur][index]\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532304,
                "title": "c-easy-implementation-using-stl-methods",
                "content": "```\\nclass SnapshotArray {\\npublic:\\n    vector<vector<pair<int, int>>> data;\\n    int snapIdx;\\n    SnapshotArray(int length) {\\n        data.resize(length);\\n        snapIdx = 0;\\n    }\\n    \\n    void set(int index, int val) {\\n        if (data[index].empty() || data[index].back().first < snapIdx)\\n            data[index].emplace_back(snapIdx, val);\\n        else\\n            data[index].back().second = val;\\n    }\\n    \\n    int snap() {\\n        return snapIdx++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it = upper_bound(data[index].begin(), data[index].end(), make_pair(snap_id, INT_MAX));\\n        if (it == data[index].begin())  // no data at snap_id\\n            return 0;\\n        else    // return the data with snapIdx <= snap_id, which is the prev of upper_bound\\n            return prev(it)->second;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n    vector<vector<pair<int, int>>> data;\\n    int snapIdx;\\n    SnapshotArray(int length) {\\n        data.resize(length);\\n        snapIdx = 0;\\n    }\\n    \\n    void set(int index, int val) {\\n        if (data[index].empty() || data[index].back().first < snapIdx)\\n            data[index].emplace_back(snapIdx, val);\\n        else\\n            data[index].back().second = val;\\n    }\\n    \\n    int snap() {\\n        return snapIdx++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it = upper_bound(data[index].begin(), data[index].end(), make_pair(snap_id, INT_MAX));\\n        if (it == data[index].begin())  // no data at snap_id\\n            return 0;\\n        else    // return the data with snapIdx <= snap_id, which is the prev of upper_bound\\n            return prev(it)->second;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1429705,
                "title": "js-initial-and-optimised-solution",
                "content": "**Solution 1:**\\n\\nModified Solution 2 to use **Hashmap** instead of an array for each element. This will reduce the space complexity, as only one value will be stored for each `snap_id`.\\n\\n```\\n// TC = O(s * n); SC = O(n + s * n)\\nclass SnapshotArray {\\n    constructor(length) {\\n        this.elements = Array(length).fill(0);    // TC: O(n); SC = O(n)\\n        this.snapshots = new Map();    // SC: O(s * n)\\n        this.snapId = -1;\\n    }\\n    set(index, val) {   // TC: O(1)\\n        this.elements[index] = val;\\n    }\\n    snap() {    // TC: O(n)\\n        ++this.snapId;\\n        this.snapshots.set(this.snapId, [...this.elements]);    // TC: O(n) [create deep copy of the array each time snapshot is called]\\n        return this.snapId;\\n    }\\n    get(index, snap_id) {   // TC: O(1)\\n        const snapshot = this.snapshots.has(snap_id) ? this.snapshots.get(snap_id) : [];\\n        return index < snapshot.length ? snapshot[index] : -1;\\n    }\\n}\\n```\\nTime Complexity:\\n`constructor - O(n)`\\n`set - O(1)`\\n`snap - O(n)`\\n`get - O(1)`\\n\\nSpace Complexity: O(n + s * n) ~ `O(s * n)`\\n[n - number of elements; s - number of snapshots taken]\\n\\n----\\n\\n**Solution 2:**\\n\\n```\\nclass SnapshotArray {\\n    constructor(length) {\\n        // each element will be an array of [val, snapId] values\\n        this.elements = Array(length).fill(null).map(el => []);    // O(n)\\n        this.snapId = 0;\\n    }\\n    set(index, val) {   // O(1)\\n        this.elements[index].push([val, this.snapId]);\\n    }\\n    snap() {    // O(1)\\n        ++this.snapId;\\n        return this.snapId - 1;\\n    }\\n\\t// find the value for snapId <= snap_id. in case no value is found, return 0\\n    get(index, snap_id) {   // O(log(s))\\n        const element = this.elements[index];\\n        let left = 0,\\n            right = element.length - 1,\\n            mid, id = -1;\\n        \\n        while(left <= right) {\\n            mid = left + Math.floor((right - left) / 2);\\n            if(element[mid][1] <= snap_id) {\\n                id = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return id === -1 ? 0 : element[id][0];\\n    }\\n}\\n```\\nTime Complexity:\\n`constructor - O(n)`\\n`set - O(1)`\\n`snap - O(1)`\\n`get - O(log(s))`\\n\\nSpace Complexity: `O(n)`\\n[n - number of elements; s - number of snapshots taken]\\n\\n----\\n\\n**Solution 3:**\\n\\n```\\nclass SnapshotArray {\\n    constructor(length) {\\n        // each element will be an array of Map\\n        this.elements = Array(length).fill(null).map(el => new Map());   // max O(n + s)\\n        this.snapId = 0;\\n    }\\n    set(index, val) {   // O(1)\\n        this.elements[index].set(this.snapId, val);\\n    }\\n    snap() {    // O(1)\\n        ++this.snapId;\\n        return this.snapId - 1;\\n    }\\n    get(index, snap_id) {   // O(log(s) + s)\\n        const element = Array.from(this.elements[index].keys());    // O(s)\\n        let left = 0,\\n            right = element.length - 1,\\n            mid, id = -1;\\n        \\n        while(left <= right) {\\n            mid = left + Math.floor((right - left) / 2);\\n            if(element[mid] <= snap_id) {\\n                id = element[mid];\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return id === -1 ? 0 : this.elements[index].get(id);\\n    }\\n}\\n```\\nTime Complexity:\\n`constructor - O(n)`\\n`set - O(1)`\\n`snap - O(1)`\\n`get - O(log(s) + s) ~ O(s)`\\n\\nSpace Complexity: `O(n)`\\n[n - number of elements; s - number of snapshots taken]",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\n// TC = O(s * n); SC = O(n + s * n)\\nclass SnapshotArray {\\n    constructor(length) {\\n        this.elements = Array(length).fill(0);    // TC: O(n); SC = O(n)\\n        this.snapshots = new Map();    // SC: O(s * n)\\n        this.snapId = -1;\\n    }\\n    set(index, val) {   // TC: O(1)\\n        this.elements[index] = val;\\n    }\\n    snap() {    // TC: O(n)\\n        ++this.snapId;\\n        this.snapshots.set(this.snapId, [...this.elements]);    // TC: O(n) [create deep copy of the array each time snapshot is called]\\n        return this.snapId;\\n    }\\n    get(index, snap_id) {   // TC: O(1)\\n        const snapshot = this.snapshots.has(snap_id) ? this.snapshots.get(snap_id) : [];\\n        return index < snapshot.length ? snapshot[index] : -1;\\n    }\\n}\\n```\n```\\nclass SnapshotArray {\\n    constructor(length) {\\n        // each element will be an array of [val, snapId] values\\n        this.elements = Array(length).fill(null).map(el => []);    // O(n)\\n        this.snapId = 0;\\n    }\\n    set(index, val) {   // O(1)\\n        this.elements[index].push([val, this.snapId]);\\n    }\\n    snap() {    // O(1)\\n        ++this.snapId;\\n        return this.snapId - 1;\\n    }\\n\\t// find the value for snapId <= snap_id. in case no value is found, return 0\\n    get(index, snap_id) {   // O(log(s))\\n        const element = this.elements[index];\\n        let left = 0,\\n            right = element.length - 1,\\n            mid, id = -1;\\n        \\n        while(left <= right) {\\n            mid = left + Math.floor((right - left) / 2);\\n            if(element[mid][1] <= snap_id) {\\n                id = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return id === -1 ? 0 : element[id][0];\\n    }\\n}\\n```\n```\\nclass SnapshotArray {\\n    constructor(length) {\\n        // each element will be an array of Map\\n        this.elements = Array(length).fill(null).map(el => new Map());   // max O(n + s)\\n        this.snapId = 0;\\n    }\\n    set(index, val) {   // O(1)\\n        this.elements[index].set(this.snapId, val);\\n    }\\n    snap() {    // O(1)\\n        ++this.snapId;\\n        return this.snapId - 1;\\n    }\\n    get(index, snap_id) {   // O(log(s) + s)\\n        const element = Array.from(this.elements[index].keys());    // O(s)\\n        let left = 0,\\n            right = element.length - 1,\\n            mid, id = -1;\\n        \\n        while(left <= right) {\\n            mid = left + Math.floor((right - left) / 2);\\n            if(element[mid] <= snap_id) {\\n                id = element[mid];\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return id === -1 ? 0 : this.elements[index].get(id);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032202,
                "title": "java-binary-search-without-treemap",
                "content": "Use a **List<int[]>[]** data structure to save [**snap_id**, **val**] pair. Each time when the **set**(int index, int val) method is called, adding the new [snap_id, val] pair into corresponding list.\\n```\\nclass SnapshotArray {\\n    public List<int[]>[] h;\\n    public int snap = 0;\\n    public SnapshotArray(int length) {\\n        h = new List[length];\\n        for (int i = 0; i < length; i++) {\\n            h[i] = new ArrayList<>();\\n            // add an initial [snap_id, val] pair, very important\\n            h[i].add(new int[]{-1, 0});\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        h[index].add(new int[]{snap, val});\\n    }\\n    \\n    public int snap() {\\n        return snap++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        List<int[]> temp = h[index];\\n        int l = 0, r = temp.size() - 1;\\n        // binary search rightmost\\n        while (l < r) {\\n            int m = r - (r - l) / 2;\\n            if (temp.get(m)[0] <= snap_id) l = m;\\n            else r = m - 1;\\n        }\\n        return temp.get(l)[1];\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass SnapshotArray {\\n    public List<int[]>[] h;\\n    public int snap = 0;\\n    public SnapshotArray(int length) {\\n        h = new List[length];\\n        for (int i = 0; i < length; i++) {\\n            h[i] = new ArrayList<>();\\n            // add an initial [snap_id, val] pair, very important\\n            h[i].add(new int[]{-1, 0});\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        h[index].add(new int[]{snap, val});\\n    }\\n    \\n    public int snap() {\\n        return snap++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        List<int[]> temp = h[index];\\n        int l = 0, r = temp.size() - 1;\\n        // binary search rightmost\\n        while (l < r) {\\n            int m = r - (r - l) / 2;\\n            if (temp.get(m)[0] <= snap_id) l = m;\\n            else r = m - 1;\\n        }\\n        return temp.get(l)[1];\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959890,
                "title": "python3-binary-search",
                "content": "We simply add [snap_id, val] to each the list at each index. When we retrive the value at snap_id, we use binary search to find the value.\\nNotice that we are trying to locat the right most value for each snap_id. e.g. [1, 4], [1, 3], [1, 6], we want to get 6 because it is the latest at the snap_id = 1.\\n```\\nclass SnapshotArray(object):\\n\\n    def __init__(self, length):\\n        \"\"\"\\n        :type length: int\\n        \"\"\"\\n        self.snap_id = 0\\n        self.list = [[[-1, 0]] for _ in range(length)]\\n\\n    def set(self, index, val):\\n        \"\"\"\\n        :type index: int\\n        :type val: int\\n        :rtype: None\\n        \"\"\"\\n        \\n        self.list[index].append([self.snap_id, val])\\n        \\n    def snap(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        ans = self.snap_id\\n        self.snap_id += 1\\n        return ans\\n    \\n    def get(self, index, snap_id):\\n        \"\"\"\\n        :type index: int\\n        :type snap_id: int\\n        :rtype: int\\n        \"\"\"\\n        #print(self.list)\\n        li = self.list[index]\\n        left, right = 0, len(li) - 1\\n        while left + 1 < right:\\n            mid = (left + right) // 2\\n            if li[mid][0] <= snap_id:\\n                left = mid\\n            else:\\n                right = mid\\n        if li[right][0] <= snap_id:\\n            return li[right][1]\\n        return li[left][1]\\n```\\n\\nPlease upvote if you find it helpful. Thanks!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass SnapshotArray(object):\\n\\n    def __init__(self, length):\\n        \"\"\"\\n        :type length: int\\n        \"\"\"\\n        self.snap_id = 0\\n        self.list = [[[-1, 0]] for _ in range(length)]\\n\\n    def set(self, index, val):\\n        \"\"\"\\n        :type index: int\\n        :type val: int\\n        :rtype: None\\n        \"\"\"\\n        \\n        self.list[index].append([self.snap_id, val])\\n        \\n    def snap(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        ans = self.snap_id\\n        self.snap_id += 1\\n        return ans\\n    \\n    def get(self, index, snap_id):\\n        \"\"\"\\n        :type index: int\\n        :type snap_id: int\\n        :rtype: int\\n        \"\"\"\\n        #print(self.list)\\n        li = self.list[index]\\n        left, right = 0, len(li) - 1\\n        while left + 1 < right:\\n            mid = (left + right) // 2\\n            if li[mid][0] <= snap_id:\\n                left = mid\\n            else:\\n                right = mid\\n        if li[right][0] <= snap_id:\\n            return li[right][1]\\n        return li[left][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758050,
                "title": "javascript-hashmap-solution",
                "content": "Straightforward Hashmap implementation. All functions run in O(1) but memory is O(nK) where K is number of snapshots. \\n\\n```\\n/**\\n * @param {number} length\\n */\\nvar SnapshotArray = function(length) {\\n    this.arr = []\\n    this.snapCount = 0;\\n    this.snapMap = new Map(); // id -> array\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} val\\n * @return {void}\\n */\\nSnapshotArray.prototype.set = function(index, val) {\\n    this.arr[index] = val;\\n};\\n\\n/**\\n * @return {number}\\n */\\nSnapshotArray.prototype.snap = function() {\\n    this.snapCount++;\\n    let snap_id = this.snapCount-1;\\n    let snapshot = [...this.arr] // make a copy of the snapshot\\n    this.snapMap.set(snap_id, snapshot);\\n    return snap_id;\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} snap_id\\n * @return {number}\\n */\\nSnapshotArray.prototype.get = function(index, snap_id) {\\n    let arrAtSnapID = this.snapMap.get(snap_id);\\n    return arrAtSnapID[index] === undefined ? null : arrAtSnapID[index]\\n};\\n\\n/** \\n * Your SnapshotArray object will be instantiated and called as such:\\n * var obj = new SnapshotArray(length)\\n * obj.set(index,val)\\n * var param_2 = obj.snap()\\n * var param_3 = obj.get(index,snap_id)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} length\\n */\\nvar SnapshotArray = function(length) {\\n    this.arr = []\\n    this.snapCount = 0;\\n    this.snapMap = new Map(); // id -> array\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} val\\n * @return {void}\\n */\\nSnapshotArray.prototype.set = function(index, val) {\\n    this.arr[index] = val;\\n};\\n\\n/**\\n * @return {number}\\n */\\nSnapshotArray.prototype.snap = function() {\\n    this.snapCount++;\\n    let snap_id = this.snapCount-1;\\n    let snapshot = [...this.arr] // make a copy of the snapshot\\n    this.snapMap.set(snap_id, snapshot);\\n    return snap_id;\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} snap_id\\n * @return {number}\\n */\\nSnapshotArray.prototype.get = function(index, snap_id) {\\n    let arrAtSnapID = this.snapMap.get(snap_id);\\n    return arrAtSnapID[index] === undefined ? null : arrAtSnapID[index]\\n};\\n\\n/** \\n * Your SnapshotArray object will be instantiated and called as such:\\n * var obj = new SnapshotArray(length)\\n * obj.set(index,val)\\n * var param_2 = obj.snap()\\n * var param_3 = obj.get(index,snap_id)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 611220,
                "title": "java-hashmap-solution-optimal-concept-explained-and-commented",
                "content": "There\\'s different method\\'s we can go about this problem. The first, most intuitive way would be to create an array and keep updating that array, then store a copy of that array in a hashmap for each snapshot. But, we would be storing a lot of unnecessary information, wasting memory. If we never update index 0, do we really need to store the information about index 0? \\n\\nWe really just need to keep track of any changes that are made to the array in each snapshot. Let\\'s call this a deltaUpdate. We also need a history of updates made to each index everytime it was saved. Let\\'s keep track of the value of each index at each snapshot. How do we do that? Lets keep a HashMap, mapping each snap_id to the value AT EACH index. But lets only update that history when there is an update between two snapshots (using our deltaUpdate which keeps track of changes made between snapshots). Otherwise, we know that its value should\\'ve been stored at its most recent snapshot before the current snapshot, if it was ever updated. \\n\\n```\\nclass SnapshotArray {\\n    //map <Snap_id , Value> for each index (array of maps)\\n    HashMap<Integer,Integer> [] snapShotHistory;\\n    \\n    //totalSnaps taken\\n    int totalSnaps;\\n\\n    //map of delta updates made <index, value>\\n    HashMap<Integer,Integer> deltaUpdate;\\n    \\n    public SnapshotArray(int length) {\\n        //keep track of the delta updates made in each iteration\\n        deltaUpdate=new HashMap<>();\\n        \\n        //initialize a snapshot history\\n        snapShotHistory=new HashMap[length];\\n        for(int i=0; i<length; i++){\\n            snapShotHistory[i]=new HashMap<>();\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        //add a delta update for this index, value pair\\n        deltaUpdate.put(index,val);\\n    }\\n    \\n    public int snap() {\\n        //add the current mapping at each index, value pair\\n        for (int key: deltaUpdate.keySet()){\\n            HashMap<Integer, Integer> snapHistoryAtIndex = snapShotHistory[key];\\n            //add a snapshot of the <snapId, value> to the index updated\\n            snapHistoryAtIndex.put(totalSnaps, deltaUpdate.get(key));\\n        }\\n        \\n        //reset out delta update map\\n        deltaUpdate=new HashMap<>();\\n        \\n        //incremement our total snaps and return the snap id\\n        totalSnaps++;\\n        return totalSnaps-1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        //find the most recent update to that index from the snapId specified and before\\n        while(snap_id>=0){\\n            if(snapShotHistory[index].containsKey(snap_id))\\n                 return snapShotHistory[index].get(snap_id);\\n            snap_id--;\\n        }\\n        \\n        //if there was never an update to that index, it will just be equal to 0\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SnapshotArray {\\n    //map <Snap_id , Value> for each index (array of maps)\\n    HashMap<Integer,Integer> [] snapShotHistory;\\n    \\n    //totalSnaps taken\\n    int totalSnaps;\\n\\n    //map of delta updates made <index, value>\\n    HashMap<Integer,Integer> deltaUpdate;\\n    \\n    public SnapshotArray(int length) {\\n        //keep track of the delta updates made in each iteration\\n        deltaUpdate=new HashMap<>();\\n        \\n        //initialize a snapshot history\\n        snapShotHistory=new HashMap[length];\\n        for(int i=0; i<length; i++){\\n            snapShotHistory[i]=new HashMap<>();\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        //add a delta update for this index, value pair\\n        deltaUpdate.put(index,val);\\n    }\\n    \\n    public int snap() {\\n        //add the current mapping at each index, value pair\\n        for (int key: deltaUpdate.keySet()){\\n            HashMap<Integer, Integer> snapHistoryAtIndex = snapShotHistory[key];\\n            //add a snapshot of the <snapId, value> to the index updated\\n            snapHistoryAtIndex.put(totalSnaps, deltaUpdate.get(key));\\n        }\\n        \\n        //reset out delta update map\\n        deltaUpdate=new HashMap<>();\\n        \\n        //incremement our total snaps and return the snap id\\n        totalSnaps++;\\n        return totalSnaps-1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        //find the most recent update to that index from the snapId specified and before\\n        while(snap_id>=0){\\n            if(snapShotHistory[index].containsKey(snap_id))\\n                 return snapShotHistory[index].get(snap_id);\\n            snap_id--;\\n        }\\n        \\n        //if there was never an update to that index, it will just be equal to 0\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1002579,
                "title": "python-hash-map-352ms-100",
                "content": "```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.d = {}\\n        self.snap_d = {}\\n        self.snap_times = -1\\n        \\n\\n    def set(self, index: int, val: int) -> None:\\n        self.d[index] = val\\n\\n    def snap(self) -> int:\\n        self.snap_times += 1\\n        self.snap_d[self.snap_times] = self.d.copy()\\n        return self.snap_times\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        if snap_id in self.snap_d:\\n            d_at_snap = self.snap_d[snap_id]\\n            if index in d_at_snap:\\n                return d_at_snap[index]\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.d = {}\\n        self.snap_d = {}\\n        self.snap_times = -1\\n        \\n\\n    def set(self, index: int, val: int) -> None:\\n        self.d[index] = val\\n\\n    def snap(self) -> int:\\n        self.snap_times += 1\\n        self.snap_d[self.snap_times] = self.d.copy()\\n        return self.snap_times\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        if snap_id in self.snap_d:\\n            d_at_snap = self.snap_d[snap_id]\\n            if index in d_at_snap:\\n                return d_at_snap[index]\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624213,
                "title": "c-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Upon reviewing the code, it appears that the `SnapshotArray` class is designed to create an array-like structure that supports snapshots of its elements. Each element can be set using the `set` function, and snapshots can be taken using the `snap` function. The `get` function allows retrieving the value of an element at a specific index and snapshot ID.\\n\\nTo solve this problem, I would consider implementing the following steps:\\n\\n1. Initialize the `v` vector: In the constructor `SnapshotArray`, create a vector `v` of length `length` and initialize each element as an empty map. This will represent the array and its snapshots.\\n\\n2. Setting element values: The `set` function takes an index and a value as input. Use the index to access the corresponding map in `v` and set the value at the current snapshot ID (`s`). This can be done by assigning `v[index][s] = val`.\\n\\n3. Taking snapshots: The `snap` function increments the `s` counter and returns the current snapshot ID (`s-1`).\\n\\n4. Retrieving element values: The `get` function takes an index and a snapshot ID as input. First, check if the map at the given index contains the snapshot ID. If it does not, find the closest snapshot ID using `lower_bound`. Subtract 1 from the iterator to get the previous snapshot ID and access the corresponding value.\\n\\n5. Analyzing time and space complexity: Evaluate the time and space complexity of the code to understand its efficiency.\\n\\nOverall, the steps involve initializing the data structure, setting values, taking snapshots, and retrieving values based on the given index and snapshot ID.\\n\\n# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->Upon analyzing the code, it seems that the `SnapshotArray` class aims to provide a data structure that supports setting and retrieving values at different indices, as well as taking snapshots of the array\\'s state at any given point. \\n\\nTo solve this problem, I would approach it by utilizing a combination of data structures and algorithms. Here\\'s a step-by-step plan based on my initial thoughts:\\n\\n1. Data structure: The core data structure to store the array and its snapshots could be a vector of maps. Each element of the vector would represent an index, and the associated map would store the values at different snapshot IDs. This structure allows efficient retrieval of values at specific indices and snapshot IDs.\\n\\n2. Initialization: In the constructor `SnapshotArray(int length)`, create a vector of size `length`. Iterate over the vector and initialize each element as an empty map. This ensures that each index in the array is represented, and initially, all values are set to 0.\\n\\n3. Setting values: The `set` function takes an index and a value as input. Access the map at the given index and set the value at the current snapshot ID (`s`). If the map doesn\\'t have an entry for the current snapshot ID, create one and assign the value. This approach ensures that only the relevant snapshots have their values stored.\\n\\n4. Taking snapshots: The `snap` function increments the `s` counter and returns the current snapshot ID. Simply increment `s` by 1, which represents the total number of snapshots taken so far, and return `s-1`.\\n\\n5. Retrieving values: The `get` function takes an index and a snapshot ID as input. Check if the map at the given index has an entry for the specified snapshot ID. If it does, return the value directly. If not, use `lower_bound` to find the iterator pointing to the closest snapshot ID that is less than or equal to the given ID. Subtract 1 from the iterator to obtain the previous snapshot ID and retrieve the value associated with it.\\n\\n6. Analyzing complexity: Evaluate the time and space complexity of the code to determine its efficiency and potential for optimization.\\n\\nBy following this plan, we can effectively implement the functionality provided by the `SnapshotArray` class, allowing for efficient setting, retrieving, and snapshotting of array values.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n# Code\\n```\\nclass SnapshotArray {\\npublic:vector<map<int,int>>v;\\nint s=0;\\n    SnapshotArray(int length)\\n     {\\n        v.resize(length);\\n        for(int i=0;i<length;i++)\\n        {\\n            v[i][0]=0;\\n        }\\n    }\\n    void set(int index, int val)\\n     {\\n        v[index][s]=val;\\n    }   \\n    int snap()\\n     {\\n        s++;\\n       return s-1;\\n    }   \\n    int get(int index, int snap_id) \\n    {\\n        if(v[index].find(snap_id)==v[index].end())\\n        {\\n            auto it= --v[index].lower_bound(snap_id);\\n            return it->second;\\n        }\\n        return v[index][snap_id];\\n    }\\n};\\n\\n//Must Upvote\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Ordered Map"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:vector<map<int,int>>v;\\nint s=0;\\n    SnapshotArray(int length)\\n     {\\n        v.resize(length);\\n        for(int i=0;i<length;i++)\\n        {\\n            v[i][0]=0;\\n        }\\n    }\\n    void set(int index, int val)\\n     {\\n        v[index][s]=val;\\n    }   \\n    int snap()\\n     {\\n        s++;\\n       return s-1;\\n    }   \\n    int get(int index, int snap_id) \\n    {\\n        if(v[index].find(snap_id)==v[index].end())\\n        {\\n            auto it= --v[index].lower_bound(snap_id);\\n            return it->second;\\n        }\\n        return v[index][snap_id];\\n    }\\n};\\n\\n//Must Upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 437181,
                "title": "22-line-python-beats-95",
                "content": "`snapArr` is a list of dictionary, each dictionary records the time when value is set for the particular index. The key in the dictionary is the given version and the value is the `val`.\\nTake `[{1: 2, 10: 4}, {9:12} ]` as example, if we want to find version 5 for index 0, it would be 2 because between version 1 and version 10, the value at index 1 has always been 2.\\n```\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.cur_ver = 0\\n        self.snapArr = [{} for _ in range(length)]\\n        \\n    def set(self, index: int, val: int) -> None:\\n        self.snapArr[index][self.cur_ver] = val\\n        \\n    def snap(self) -> int:\\n        self.cur_ver += 1\\n        return self.cur_ver - 1\\n    \\n    def get(self, index: int, snap_id: int) -> int:\\n        if snap_id in self.snapArr[index]:\\n            return self.snapArr[index][snap_id]\\n        last_val = 0\\n        for i in range(0, self.cur_ver+1):\\n            if i in self.snapArr[index]:\\n                last_val = self.snapArr[index][i]\\n            if i >= snap_id:\\n                return last_val\\n        return last_val\\n",
                "solutionTags": [],
                "code": "`snapArr` is a list of dictionary, each dictionary records the time when value is set for the particular index. The key in the dictionary is the given version and the value is the `val`.\\nTake `[{1: 2, 10: 4}, {9:12} ]` as example, if we want to find version 5 for index 0, it would be 2 because between version 1 and version 10, the value at index 1 has always been 2.\\n```\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.cur_ver = 0\\n        self.snapArr = [{} for _ in range(length)]\\n        \\n    def set(self, index: int, val: int) -> None:\\n        self.snapArr[index][self.cur_ver] = val\\n        \\n    def snap(self) -> int:\\n        self.cur_ver += 1\\n        return self.cur_ver - 1\\n    \\n    def get(self, index: int, snap_id: int) -> int:\\n        if snap_id in self.snapArr[index]:\\n            return self.snapArr[index][snap_id]\\n        last_val = 0\\n        for i in range(0, self.cur_ver+1):\\n            if i in self.snapArr[index]:\\n                last_val = self.snapArr[index][i]\\n            if i >= snap_id:\\n                return last_val\\n        return last_val\\n",
                "codeTag": "Java"
            },
            {
                "id": 1769405,
                "title": "c-short-and-simple",
                "content": "```\\nclass SnapshotArray {\\npublic:\\n    vector<map<int,int>>A;\\n    int s_id = 0;\\n    SnapshotArray(int length) {\\n        A.resize(length);\\n        for(int i = 0; i < length; i++)\\n            A[i][0] = 0;\\n        \\n    }\\n    \\n    void set(int index, int val) {\\n        A[index][s_id] = val;\\n    }\\n    \\n    int snap() {\\n        s_id++;\\n        return  s_id - 1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(A[index].find(snap_id) == A[index].end())\\n        {\\n            auto it = --A[index].lower_bound(snap_id);\\n            return it->second;\\n        }\\n        return A[index][snap_id];\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n    vector<map<int,int>>A;\\n    int s_id = 0;\\n    SnapshotArray(int length) {\\n        A.resize(length);\\n        for(int i = 0; i < length; i++)\\n            A[i][0] = 0;\\n        \\n    }\\n    \\n    void set(int index, int val) {\\n        A[index][s_id] = val;\\n    }\\n    \\n    int snap() {\\n        s_id++;\\n        return  s_id - 1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(A[index].find(snap_id) == A[index].end())\\n        {\\n            auto it = --A[index].lower_bound(snap_id);\\n            return it->second;\\n        }\\n        return A[index][snap_id];\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545444,
                "title": "python-brute-force-improved-code",
                "content": "#### Brute Force | \\tMemory Limit Exceeded\\n\\nMemory usage needs to be more efficient. In this code snippet, too many unused `0` element were stored in the dictionary value. Instead, only store used index and value. A nested dictionary does the trick\\n\\n```python\\nclass SnapshotArray(object):\\n\\n    def __init__(self, length):\\n        self.length = length\\n        self.arr = [0] * self.length\\n        self.snap_id = -1\\n        self.dic = {}\\n        \\n\\n    def set(self, index, val):\\n        if index >= 0 and index < len(self.arr):\\n            self.arr[index] = val\\n\\n    def snap(self):\\n        self.snap_id += 1\\n        self.dic[self.snap_id] = self.arr[:]\\n        return self.snap_id\\n        \\n\\n    def get(self, index, snap_id):\\n        if snap_id in self.dic:\\n            return self.dic[snap_id][index]\\n```\\n\\n\\n#### Hashmap + Deepcopy\\n\\nThis code snippet still duplicates previous `snap_array`, thus create redundency in elements. for example:\\n![image](https://user-images.githubusercontent.com/6414741/77181181-dbad7880-6ac2-11ea-80fa-5b1e5ba0f3a1.png)\\nInstead of making a copy to all elements, we only need to make new copies of the elements that has been modified.\\nFor the remaining unchanged elements, we can query them by a backward while loop, which increase the time complexity back to O(N)\\n\\nHowever the time complexity is GREAT\\n\\n`set() O(1)`\\n`set() O(1)`\\n`get() O(1)`\\n\\n```python\\nfrom collections import defaultdict\\nclass SnapshotArray(object):\\n    def __init__(self, length):\\n        self.dic = defaultdict(dict)\\n        self.snap_id = 0\\n        \\n        \\n    def set(self, index, val):\\n        self.dic[self.snap_id][index] = val\\n        \\n\\n    def snap(self):\\n        self.snap_id += 1\\n        self.dic[self.snap_id] = self.dic[self.snap_id - 1].copy()\\n        return self.snap_id -1\\n        \\n\\n    def get(self, index, snap_id):\\n        if index in self.dic[snap_id]:\\n            return self.dic[snap_id][index]\\n        else:\\n            return 0\\n```\\n\\n\\n#### Backward While Loop\\n\\nWe can make this search faster by replacing linear query with a binary search\\n\\n```python\\nfrom collections import defaultdict\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.snap_id = 0\\n        self.history = defaultdict(dict)\\n    \\n    def set(self, index: int, val: int) -> None:\\n        self.history[self.snap_id][index] = val\\n    \\n    def snap(self) -> int:\\n        self.snap_id += 1\\n        return self.snap_id - 1\\n    \\n    def get(self, index: int, snap_id: int) -> int:\\n        copy_id = snap_id\\n        while copy_id > 0 and index not in self.history[copy_id]:\\n            copy_id -= 1\\n        if index in self.history[copy_id]:\\n            return self.history[copy_id][index]\\n        return 0\\n```\\n\\n\\n#### Backward Binary Search\\n\\nCode Snippet from @lee215\\n\\n```python\\n    def __init__(self, n):\\n        self.A = [[[-1, 0]] for _ in xrange(n)]\\n        self.snap_id = 0\\n\\n    def set(self, index, val):\\n        self.A[index].append([self.snap_id, val])\\n\\n    def snap(self):\\n        self.snap_id += 1\\n        return self.snap_id - 1\\n\\n    def get(self, index, snap_id):\\n        i = bisect.bisect(self.A[index], [snap_id + 1]) - 1\\n        return self.A[index][i][1]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass SnapshotArray(object):\\n\\n    def __init__(self, length):\\n        self.length = length\\n        self.arr = [0] * self.length\\n        self.snap_id = -1\\n        self.dic = {}\\n        \\n\\n    def set(self, index, val):\\n        if index >= 0 and index < len(self.arr):\\n            self.arr[index] = val\\n\\n    def snap(self):\\n        self.snap_id += 1\\n        self.dic[self.snap_id] = self.arr[:]\\n        return self.snap_id\\n        \\n\\n    def get(self, index, snap_id):\\n        if snap_id in self.dic:\\n            return self.dic[snap_id][index]\\n```\n```python\\nfrom collections import defaultdict\\nclass SnapshotArray(object):\\n    def __init__(self, length):\\n        self.dic = defaultdict(dict)\\n        self.snap_id = 0\\n        \\n        \\n    def set(self, index, val):\\n        self.dic[self.snap_id][index] = val\\n        \\n\\n    def snap(self):\\n        self.snap_id += 1\\n        self.dic[self.snap_id] = self.dic[self.snap_id - 1].copy()\\n        return self.snap_id -1\\n        \\n\\n    def get(self, index, snap_id):\\n        if index in self.dic[snap_id]:\\n            return self.dic[snap_id][index]\\n        else:\\n            return 0\\n```\n```python\\nfrom collections import defaultdict\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.snap_id = 0\\n        self.history = defaultdict(dict)\\n    \\n    def set(self, index: int, val: int) -> None:\\n        self.history[self.snap_id][index] = val\\n    \\n    def snap(self) -> int:\\n        self.snap_id += 1\\n        return self.snap_id - 1\\n    \\n    def get(self, index: int, snap_id: int) -> int:\\n        copy_id = snap_id\\n        while copy_id > 0 and index not in self.history[copy_id]:\\n            copy_id -= 1\\n        if index in self.history[copy_id]:\\n            return self.history[copy_id][index]\\n        return 0\\n```\n```python\\n    def __init__(self, n):\\n        self.A = [[[-1, 0]] for _ in xrange(n)]\\n        self.snap_id = 0\\n\\n    def set(self, index, val):\\n        self.A[index].append([self.snap_id, val])\\n\\n    def snap(self):\\n        self.snap_id += 1\\n        return self.snap_id - 1\\n\\n    def get(self, index, snap_id):\\n        i = bisect.bisect(self.A[index], [snap_id + 1]) - 1\\n        return self.A[index][i][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625837,
                "title": "js-beats-98-stuck-on-runtime-errors-read-this-detailed-approach",
                "content": "# Intuition\\nThe fisrt thought is to create an array and fill it with zeros. DON\\'T DO THAT, as it will probably lead to memory-related runtime errors becouse of many copies (snapshots):\\n![Screenshot 2023-06-11 104118.png](https://assets.leetcode.com/users/images/f328b71d-4757-4188-b2e8-a3189eadd10c_1686490990.0145652.png)\\n\\nreading the description carefully gives us a hint:\\n> `SnapshotArray(int length)` initializes an array-like data structure with the given length. Initially, each element equals 0.\\n\\ntwo important insights on this quote:\\n***array-like data structure***: It dont have to be an array. As we will not be iterating over the array, and only acccessing indexes directly, we could use a hash-map-like structure, such as a pure js object, where the index is the key that holds a value\\n***\"Initially, each element equals 0\"***: - DOOON\\'T. It does\\'t has to be. As we will be using a key-value data structure, the absense of a value in our data structure can be seen as an empty space, so we return `0` when `data[idx] === undefined`.\\n\\n# Approach\\nEven doing the optimizations above, you can still fall into one or another runtime error. This could happen if you are **always** copying the current data when `snap()` is called.\\n\\nYou have to copy *only* when the data changed between an `snap()` call and another. \\n\\nWhen `snap()` is called without `set()` in between, the new snapshot will be the same as the previous one, so it can just point to the last snapshot doing something like `snaps.push(snaps[snaps.length-1])`, instead of copying the current data.\\n\\nWe will track changes with a simple flag `hasChanges`, that we sets to true everytime that `set()` is called.\\n\\nSo lets go to the code:\\n\\n\\n# Code\\n```\\nvar SnapshotArray = function(length) {\\n    this.curr = {};\\n    this.snaps = [];\\n    this.hasChanges = false;\\n};\\n\\nSnapshotArray.prototype.set = function(idx, val) {\\n    this.curr[idx] = val;\\n    this.hasChanges = true;\\n};\\n\\nSnapshotArray.prototype.snap = function() {\\n    if (this.hasChanges || this.snaps.length  === 0) {\\n        this.snaps.push({...this.curr});\\n    } else {\\n        this.snaps.push(this.snaps[this.snaps.length - 1])\\n    }\\n    this.hasChanges = false;\\n    return this.snaps.length - 1;\\n};\\n\\nSnapshotArray.prototype.get = function(idx, snap_id) {\\n    return this.snaps[snap_id][idx] || 0\\n};\\n````\\n\\n![Screenshot 2023-06-11 110334.png](https://assets.leetcode.com/users/images/016a80dd-63cc-4018-bf27-7b79faa9ae70_1686492632.1015654.png)\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "```\\nvar SnapshotArray = function(length) {\\n    this.curr = {};\\n    this.snaps = [];\\n    this.hasChanges = false;\\n};\\n\\nSnapshotArray.prototype.set = function(idx, val) {\\n    this.curr[idx] = val;\\n    this.hasChanges = true;\\n};\\n\\nSnapshotArray.prototype.snap = function() {\\n    if (this.hasChanges || this.snaps.length  === 0) {\\n        this.snaps.push({...this.curr});\\n    } else {\\n        this.snaps.push(this.snaps[this.snaps.length - 1])\\n    }\\n    this.hasChanges = false;\\n    return this.snaps.length - 1;\\n};\\n\\nSnapshotArray.prototype.get = function(idx, snap_id) {\\n    return this.snaps[snap_id][idx] || 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3624293,
                "title": "c-using-map-and-upper-bound",
                "content": "# Code\\n```\\nclass SnapshotArray {\\nprivate:\\n    map<int, map<int, int>> snaps;\\n    int snapId = 0;\\npublic:\\n    SnapshotArray(int length) {\\n        for (int i = 0; i < length; i++) {\\n            map<int, int> mp; mp[0] = 0;\\n            snaps[i] = mp;\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        snaps[index][snapId] = val;\\n    }\\n    \\n    int snap() {\\n        return snapId++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it = snaps[index].upper_bound(snap_id); it--;\\n        return it->second;\\n    }\\n};\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SnapshotArray {\\nprivate:\\n    map<int, map<int, int>> snaps;\\n    int snapId = 0;\\npublic:\\n    SnapshotArray(int length) {\\n        for (int i = 0; i < length; i++) {\\n            map<int, int> mp; mp[0] = 0;\\n            snaps[i] = mp;\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        snaps[index][snapId] = val;\\n    }\\n    \\n    int snap() {\\n        return snapId++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it = snaps[index].upper_bound(snap_id); it--;\\n        return it->second;\\n    }\\n};\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624784,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation-easy-to-understand",
                "content": "# Intuition\\nWe have to create a class that maintains a history of element values for each snapshot using a vector of maps. Each time a snapshot is taken, the current values of the elements are stored in their respective maps with the current snapshot ID.\\nIf we store the entire array at the time of the snapshot, the space required for such and operation will exceed the memory limit. So we need to look for an optimised approach. This pushes our thought process towards map data structure as we need to store the values at a given index and update them with the set function. So we create a map for each element of the array and modify them accordingly.\\nWhen retrieving a value for a specific snapshot ID, the class performs a binary search in the map for the given index to find the closest previous snapshot ID and returns the corresponding value.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize the SnapshotArray object with a specified length. Create a vector of maps to store the snapshots for each array element. Each map is initialized with a single entry for snapshot ID 0.\\n\\n- Use the set() function to set the value of an element at a given index. This function updates the map at the specified index with the new value for the current snapshot ID.\\n\\n- Call the snap() function to take a snapshot of the current array state. This function returns the current snapshot ID and increments it for the next snapshot.\\n\\n- Retrieve the value of an element at a given index for a specific snapshot ID using the get() function. This function searches for the closest previous snapshot ID in the map using binary search (using upper_bound) and returns the corresponding value.\\n\\n# Complexity\\n- Time complexity: O(1) for set() and snap(). O(log snapshots) for get() since it performs a binary search using upper_bound to find the snapshot ID.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(length * snapshots) since it uses a vector of maps to store snapshots.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass SnapshotArray {\\n    vector<map<int,int>> vector;\\n    int snap_id;\\npublic:\\n    SnapshotArray(int length) {\\n        vector.resize(length);\\n        for(auto& it:vector){\\n            it[0]=0;\\n        }\\n        snap_id=0;\\n    }\\n    \\n    void set(int index, int val) {\\n        vector[index][snap_id]=val;\\n    }\\n    \\n    int snap() {\\n        return snap_id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        map<int,int>& m=vector[index];\\n        auto i=m.upper_bound(snap_id);\\n        return (--i)->second;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SnapshotArray {\\n    vector<map<int,int>> vector;\\n    int snap_id;\\npublic:\\n    SnapshotArray(int length) {\\n        vector.resize(length);\\n        for(auto& it:vector){\\n            it[0]=0;\\n        }\\n        snap_id=0;\\n    }\\n    \\n    void set(int index, int val) {\\n        vector[index][snap_id]=val;\\n    }\\n    \\n    int snap() {\\n        return snap_id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        map<int,int>& m=vector[index];\\n        auto i=m.upper_bound(snap_id);\\n        return (--i)->second;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323432,
                "title": "simple-c-binary-search-with-comments",
                "content": "typedef pair<int,int> pii;\\n\\nclass SnapshotArray {\\n    \\nprivate:\\n    \\n    int n = 0;\\n    vector<vector<pii>> m;\\n    \\npublic:\\n    \\n    \\n    SnapshotArray(int length) {\\n        m = vector<vector<pii>>(length, vector<pii>(1, {0 , 0})); // every element is 0 in beginning\\n    }\\n    \\n    void set(int index, int val) {\\n        \\n        int x = m[index].size();\\n        \\n        if(m[index][x-1].second == n)   // if no new snaps were taken after last entry\\n            m[index][x-1].first = val;  // then update the last entry\\n        else \\n            m[index].push_back({val , n});       // else make a new entry with new snap_id\\n        \\n    }\\n    \\n    int snap() {\\n        n++;\\n        return n-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        \\n        int l = 0, h = m[index].size()-1;\\n        \\n        while(l <= h){                 // binary search for first index with snap_id equal or lower\\n            \\n            int mid = l+(h-l)/2;\\n            \\n            if(m[index][mid].second == snap_id)\\n                return m[index][mid].first;\\n            else if(m[index][mid].second > snap_id)\\n                h = mid-1;\\n            else \\n                l = mid+1;\\n            \\n        }\\n        \\n        return m[index][h].first;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "typedef pair<int,int> pii;\\n\\nclass SnapshotArray {\\n    \\nprivate:\\n    \\n    int n = 0;\\n    vector<vector<pii>> m;\\n    \\npublic:\\n    \\n    \\n    SnapshotArray(int length) {\\n        m = vector<vector<pii>>(length, vector<pii>(1, {0 , 0})); // every element is 0 in beginning\\n    }\\n    \\n    void set(int index, int val) {\\n        \\n        int x = m[index].size();\\n        \\n        if(m[index][x-1].second == n)   // if no new snaps were taken after last entry\\n            m[index][x-1].first = val;  // then update the last entry\\n        else \\n            m[index].push_back({val , n});       // else make a new entry with new snap_id\\n        \\n    }\\n    \\n    int snap() {\\n        n++;\\n        return n-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        \\n        int l = 0, h = m[index].size()-1;\\n        \\n        while(l <= h){                 // binary search for first index with snap_id equal or lower\\n            \\n            int mid = l+(h-l)/2;\\n            \\n            if(m[index][mid].second == snap_id)\\n                return m[index][mid].first;\\n            else if(m[index][mid].second > snap_id)\\n                h = mid-1;\\n            else \\n                l = mid+1;\\n            \\n        }\\n        \\n        return m[index][h].first;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1813871,
                "title": "java-3-solutions-binary-search-treemap-arraycopy",
                "content": "List + Binary Search Solution\\n```\\n// List + Binary Search Solution\\n// Space complexity: O(C), where C is the number of changes\\nclass SnapshotArray {\\n    private List<int[]>[] records;  // list of record, record the (snap_id, value) tuple. snap_id increased.\\n    private int snapIdx;\\n    \\n    public SnapshotArray(int length) {\\n        records = new ArrayList[length];\\n        for (int i = 0; i < length; i++) {\\n            records[i] = new ArrayList<>();\\n            records[i].add(new int[]{0, 0});\\n        }\\n    }\\n    \\n    // Time complexity: O(1)\\n    public void set(int index, int val) {\\n        List<int[]> record = records[index];\\n        int[] last = record.get(record.size() - 1);\\n        if (last[0] == snapIdx) {\\n            last[1] = val;\\n        } else {\\n            record.add(new int[]{snapIdx, val});\\n        }\\n    }\\n    \\n    // Time complexity: O(1)\\n    public int snap() {\\n        return snapIdx++;\\n    }\\n    \\n    // Time complexity: O(logN)\\n    public int get(int index, int snap_id) {\\n        List<int[]> record = records[index];\\n        int idx = Collections.binarySearch(record, \\n                                           new int[]{snap_id, 0},\\n                                           (r1, r2) -> Integer.compare(r1[0], r2[0]));\\n        if (idx < 0) idx = -idx - 2;\\n        return record.get(idx)[1];\\n    }\\n}\\n```\\n\\nTreeMap Solution\\n```\\n// TreeMap Solution\\n// Space complexity: O(C), where C is the number of changes\\nclass SnapshotArray {\\n    private TreeMap<Integer, Integer>[] maps;  // index: <snap_id, val>\\n    private int snapIdx;\\n\\n    // Time complexity: O(N)\\n    public SnapshotArray(int length) {\\n        maps = new TreeMap[length];\\n        for (int i = 0; i < length; i++) {\\n            maps[i] = new TreeMap<>();\\n            maps[i].put(0, 0);\\n        }\\n    }\\n    \\n    // Time complexity: O(logN)\\n    public void set(int index, int val) {\\n        TreeMap<Integer, Integer> map = maps[index];\\n        map.put(snapIdx, val);\\n    }\\n    \\n    // Time complexity: O(1)\\n    public int snap() {\\n        return snapIdx++;\\n    }\\n    \\n    // Time complexity: O(logN)\\n    public int get(int index, int snap_id) {\\n        TreeMap<Integer, Integer> map = maps[index];\\n        return map.floorEntry(snap_id).getValue();\\n    }\\n}\\n```\\n\\nArrayCopy Solution\\n```\\n// ArrayCopy Solution: no enough memory\\n// Space complexity: O(N * S), where S is the number of snaps\\nclass SnapshotArray {\\n    private int snapId;\\n    private int[] arr;\\n    private Map<Integer, int[]> map;\\n\\n    // Time complexity: O(N)\\n    public SnapshotArray(int length) {\\n        arr = new int[length];\\n        map = new HashMap<>();\\n    }\\n    \\n    // Time complexity: O(1)\\n    public void set(int index, int val) {\\n        // ask what if index is out of bound.\\n        arr[index] = val;\\n    }\\n    \\n    // Time complexity: O(N)\\n    public int snap() {\\n        int id = snapId;\\n        snapId++;\\n        int[] snapArr = new int[arr.length];\\n        System.arraycopy(arr, 0, snapArr, 0, arr.length);\\n        map.put(id, snapArr);\\n        return id;\\n    }\\n    \\n    // Time complexity: O(1)\\n    public int get(int index, int snap_id) {\\n        // ask what if snap_id is not exist.\\n        // ask what if index is out of bound.\\n        int[] snapArr = map.get(snap_id);\\n        return snapArr[index];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// List + Binary Search Solution\\n// Space complexity: O(C), where C is the number of changes\\nclass SnapshotArray {\\n    private List<int[]>[] records;  // list of record, record the (snap_id, value) tuple. snap_id increased.\\n    private int snapIdx;\\n    \\n    public SnapshotArray(int length) {\\n        records = new ArrayList[length];\\n        for (int i = 0; i < length; i++) {\\n            records[i] = new ArrayList<>();\\n            records[i].add(new int[]{0, 0});\\n        }\\n    }\\n    \\n    // Time complexity: O(1)\\n    public void set(int index, int val) {\\n        List<int[]> record = records[index];\\n        int[] last = record.get(record.size() - 1);\\n        if (last[0] == snapIdx) {\\n            last[1] = val;\\n        } else {\\n            record.add(new int[]{snapIdx, val});\\n        }\\n    }\\n    \\n    // Time complexity: O(1)\\n    public int snap() {\\n        return snapIdx++;\\n    }\\n    \\n    // Time complexity: O(logN)\\n    public int get(int index, int snap_id) {\\n        List<int[]> record = records[index];\\n        int idx = Collections.binarySearch(record, \\n                                           new int[]{snap_id, 0},\\n                                           (r1, r2) -> Integer.compare(r1[0], r2[0]));\\n        if (idx < 0) idx = -idx - 2;\\n        return record.get(idx)[1];\\n    }\\n}\\n```\n```\\n// TreeMap Solution\\n// Space complexity: O(C), where C is the number of changes\\nclass SnapshotArray {\\n    private TreeMap<Integer, Integer>[] maps;  // index: <snap_id, val>\\n    private int snapIdx;\\n\\n    // Time complexity: O(N)\\n    public SnapshotArray(int length) {\\n        maps = new TreeMap[length];\\n        for (int i = 0; i < length; i++) {\\n            maps[i] = new TreeMap<>();\\n            maps[i].put(0, 0);\\n        }\\n    }\\n    \\n    // Time complexity: O(logN)\\n    public void set(int index, int val) {\\n        TreeMap<Integer, Integer> map = maps[index];\\n        map.put(snapIdx, val);\\n    }\\n    \\n    // Time complexity: O(1)\\n    public int snap() {\\n        return snapIdx++;\\n    }\\n    \\n    // Time complexity: O(logN)\\n    public int get(int index, int snap_id) {\\n        TreeMap<Integer, Integer> map = maps[index];\\n        return map.floorEntry(snap_id).getValue();\\n    }\\n}\\n```\n```\\n// ArrayCopy Solution: no enough memory\\n// Space complexity: O(N * S), where S is the number of snaps\\nclass SnapshotArray {\\n    private int snapId;\\n    private int[] arr;\\n    private Map<Integer, int[]> map;\\n\\n    // Time complexity: O(N)\\n    public SnapshotArray(int length) {\\n        arr = new int[length];\\n        map = new HashMap<>();\\n    }\\n    \\n    // Time complexity: O(1)\\n    public void set(int index, int val) {\\n        // ask what if index is out of bound.\\n        arr[index] = val;\\n    }\\n    \\n    // Time complexity: O(N)\\n    public int snap() {\\n        int id = snapId;\\n        snapId++;\\n        int[] snapArr = new int[arr.length];\\n        System.arraycopy(arr, 0, snapArr, 0, arr.length);\\n        map.put(id, snapArr);\\n        return id;\\n    }\\n    \\n    // Time complexity: O(1)\\n    public int get(int index, int snap_id) {\\n        // ask what if snap_id is not exist.\\n        // ask what if index is out of bound.\\n        int[] snapArr = map.get(snap_id);\\n        return snapArr[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739566,
                "title": "c-simple-map-of-map-space-optimized",
                "content": "simple c++ code with map of map\\n```\\nclass SnapshotArray {\\n    unordered_map<int,unordered_map<int,int>> hmap;\\n    int snapid=0;\\npublic:\\n    SnapshotArray(int length) {\\n        \\n    }\\n    \\n    void set(int index, int val) {\\n        hmap[snapid][index]=val;\\n        \\n    }\\n    \\n    int snap() {\\n        snapid++;\\n        return snapid-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        \\n        for(int i=snap_id;i>=0;i--)\\n        {\\n            if(hmap[i].count(index)==1)\\n                return hmap[i][index];\\n        }\\n        return 0;\\n    }\\n};```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass SnapshotArray {\\n    unordered_map<int,unordered_map<int,int>> hmap;\\n    int snapid=0;\\npublic:\\n    SnapshotArray(int length) {\\n        \\n    }\\n    \\n    void set(int index, int val) {\\n        hmap[snapid][index]=val;\\n        \\n    }\\n    \\n    int snap() {\\n        snapid++;\\n        return snapid-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        \\n        for(int i=snap_id;i>=0;i--)\\n        {\\n            if(hmap[i].count(index)==1)\\n                return hmap[i][index];\\n        }\\n        return 0;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 483571,
                "title": "c-92-68-time-100-memory-with-explanation",
                "content": "```\\nclass SnapshotArray {\\n    vector<vector<pair<int, int>>> history; // pair<snap_id, val>\\n    int curSnap;\\npublic:\\n    SnapshotArray(const int& length) { // O(length)\\n        history.resize(length, {{-1, 0}});\\n        curSnap = 0;\\n    }\\n    \\n    void set(const int& index, const int& val) { // amortized O(1)\\n        if (history[index].back().first < curSnap)\\n            history[index].push_back({curSnap, val});\\n        else\\n            history[index].back().second = val;\\n    }\\n    \\n    int snap() { // O(1)\\n        return curSnap++;\\n    }\\n    \\n    int get(const int& index, const int& snap_id) { // O(log curSnap)\\n        return (upper_bound(history[index].begin(), history[index].end(), make_pair(snap_id, INT_MAX)) - 1)->second;\\n    }\\n};\\n```\\nWe store the history of snapshots. ```history[index]``` is the list of snapshots of the element at ```index```. Each elements of ```history[index]``` is a pair of the time we set the value of element[index] (```snap_id```) & ```val```. We only add an element to ```history[index]``` when there\\'s at least 1 time we set the value at ```index```. There will be no new element of ```history[index]``` until we set a value for element[index] with a new ```snap_id```.\\n\\nEach ```history[index]``` is increasing according to ```snap_id```. To get the value of element[index] with a ```snap_id```, we can use binary search.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass SnapshotArray {\\n    vector<vector<pair<int, int>>> history; // pair<snap_id, val>\\n    int curSnap;\\npublic:\\n    SnapshotArray(const int& length) { // O(length)\\n        history.resize(length, {{-1, 0}});\\n        curSnap = 0;\\n    }\\n    \\n    void set(const int& index, const int& val) { // amortized O(1)\\n        if (history[index].back().first < curSnap)\\n            history[index].push_back({curSnap, val});\\n        else\\n            history[index].back().second = val;\\n    }\\n    \\n    int snap() { // O(1)\\n        return curSnap++;\\n    }\\n    \\n    int get(const int& index, const int& snap_id) { // O(log curSnap)\\n        return (upper_bound(history[index].begin(), history[index].end(), make_pair(snap_id, INT_MAX)) - 1)->second;\\n    }\\n};\\n```\n```history[index]```\n```index```\n```history[index]```\n```snap_id```\n```val```\n```history[index]```\n```index```\n```history[index]```\n```snap_id```\n```history[index]```\n```snap_id```\n```snap_id```",
                "codeTag": "Java"
            },
            {
                "id": 3626636,
                "title": "explained-simple-and-clear-python3-code",
                "content": "\\n\\n\\n# Code\\n```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.saved=[  [] for _ in range(length)]\\n        self.unsaved=[]\\n        self.count=0\\n        \\n\\n    def set(self, index: int, val: int) -> None:\\n        self.unsaved.append([index,val])\\n        \\n\\n    def snap(self) -> int:\\n        for item in self.unsaved:\\n            self.saved[item[0]].insert(0,[self.count, item[1]])\\n        self.unsaved.clear()\\n        self.count+=1\\n        return self.count-1\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        his=self.saved[index]\\n        for i in his:\\n            if i[0]<=snap_id:\\n                return i[1]\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.saved=[  [] for _ in range(length)]\\n        self.unsaved=[]\\n        self.count=0\\n        \\n\\n    def set(self, index: int, val: int) -> None:\\n        self.unsaved.append([index,val])\\n        \\n\\n    def snap(self) -> int:\\n        for item in self.unsaved:\\n            self.saved[item[0]].insert(0,[self.count, item[1]])\\n        self.unsaved.clear()\\n        self.count+=1\\n        return self.count-1\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        his=self.saved[index]\\n        for i in his:\\n            if i[0]<=snap_id:\\n                return i[1]\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624495,
                "title": "simple-java-solution-using-hashmap",
                "content": "\\n# Approach\\nSaving in memory changes from a snapshot to another.\\nCan replace hashmap with Pair\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SnapshotArray {\\n    List<Map<Integer, Integer>> list;\\n    \\n    public SnapshotArray(int length) {\\n        list = new ArrayList();\\n        list.add(new HashMap());\\n    }\\n    \\n    public void set(int index, int val) {\\n        int snapId = list.size() - 1;\\n        list.get(snapId).put(index, val);\\n    }\\n    \\n    public int snap() {\\n        list.add(new HashMap());\\n        return list.size() - 2;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        for (int snap = snap_id; snap >= 0; snap--) {\\n            if (list.get(snap).containsKey(index))\\n                return list.get(snap).get(index);\\n        }\\n        return 0;\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SnapshotArray {\\n    List<Map<Integer, Integer>> list;\\n    \\n    public SnapshotArray(int length) {\\n        list = new ArrayList();\\n        list.add(new HashMap());\\n    }\\n    \\n    public void set(int index, int val) {\\n        int snapId = list.size() - 1;\\n        list.get(snapId).put(index, val);\\n    }\\n    \\n    public int snap() {\\n        list.add(new HashMap());\\n        return list.size() - 2;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        for (int snap = snap_id; snap >= 0; snap--) {\\n            if (list.get(snap).containsKey(index))\\n                return list.get(snap).get(index);\\n        }\\n        return 0;\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623624,
                "title": "c-list-of-dictionaries",
                "content": "# Approach\\n- Using `List<Dictionary<int, int>>` to store `snapId` and value.\\n- When getting value, if the `snapId` in not in the dictionary go back to previuous snapshot\\n\\n# Code\\n```\\npublic class SnapshotArray\\n{\\n    private readonly List<Dictionary<int, int>> _array;\\n    private int _snapshotId;\\n\\n    public SnapshotArray(int length)\\n    {\\n        _array = new List<Dictionary<int, int>>(length);\\n        for (var i = 0; i < length; i++)\\n        {\\n            _array.Add(new Dictionary<int, int> {[0] = 0});\\n        }\\n    }\\n\\n    public void Set(int index, int val)\\n    {\\n        _array[index][_snapshotId] = val;\\n    }\\n\\n    public int Snap()\\n    {\\n        return _snapshotId++;\\n    }\\n\\n    public int Get(int index, int snapId)\\n    {\\n        var dictionary = _array[index];\\n        \\n        // If snapId is not in the dictionary we should go back to previous snapshot\\n        while (!dictionary.ContainsKey(snapId))\\n        {\\n            --snapId;\\n        }\\n\\n        return dictionary[snapId];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class SnapshotArray\\n{\\n    private readonly List<Dictionary<int, int>> _array;\\n    private int _snapshotId;\\n\\n    public SnapshotArray(int length)\\n    {\\n        _array = new List<Dictionary<int, int>>(length);\\n        for (var i = 0; i < length; i++)\\n        {\\n            _array.Add(new Dictionary<int, int> {[0] = 0});\\n        }\\n    }\\n\\n    public void Set(int index, int val)\\n    {\\n        _array[index][_snapshotId] = val;\\n    }\\n\\n    public int Snap()\\n    {\\n        return _snapshotId++;\\n    }\\n\\n    public int Get(int index, int snapId)\\n    {\\n        var dictionary = _array[index];\\n        \\n        // If snapId is not in the dictionary we should go back to previous snapshot\\n        while (!dictionary.ContainsKey(snapId))\\n        {\\n            --snapId;\\n        }\\n\\n        return dictionary[snapId];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499917,
                "title": "java-solution-only-save-the-delta-changes-o-1-lookup",
                "content": "```\\nclass SnapshotArray {\\n\\n    Map<Integer, Integer> pair;\\n    Map<Integer, Map<Integer, Integer>> map;\\n    public SnapshotArray(int length) {\\n        this.pair = new HashMap<Integer, Integer>();\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void set(int index, int val) {\\n        this.pair.put(index, val);\\n    }\\n    \\n    public int snap() {\\n        int snapId = map.size();\\n        map.put(snapId, new HashMap<Integer, Integer>(this.pair));\\n        return snapId;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        if(map.containsKey(snap_id)) {\\n            return map.get(snap_id).containsKey(index) ? map.get(snap_id).get(index) : 0;\\n        }\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n\\n    Map<Integer, Integer> pair;\\n    Map<Integer, Map<Integer, Integer>> map;\\n    public SnapshotArray(int length) {\\n        this.pair = new HashMap<Integer, Integer>();\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void set(int index, int val) {\\n        this.pair.put(index, val);\\n    }\\n    \\n    public int snap() {\\n        int snapId = map.size();\\n        map.put(snapId, new HashMap<Integer, Integer>(this.pair));\\n        return snapId;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        if(map.containsKey(snap_id)) {\\n            return map.get(snap_id).containsKey(index) ? map.get(snap_id).get(index) : 0;\\n        }\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274834,
                "title": "c-clean-solution-using-map",
                "content": "```cpp\\nclass SnapshotArray {\\npublic:\\n    unordered_map<int, map<int, int>> m; // { index : { snap_id_ : val }}\\n    int snap_id_ = 0;\\n\\n    SnapshotArray(int length) {}\\n\\n    void set(int index, int val) {\\n        m[index][snap_id_] = val;\\n    }\\n\\n    int snap() {\\n        return snap_id_++;\\n    }\\n\\n    int get(int index, int snap_id) {\\n        auto itr = m[index].upper_bound(snap_id);\\n        if (itr == m[index].begin()) return 0;\\n        return (*prev(itr)).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass SnapshotArray {\\npublic:\\n    unordered_map<int, map<int, int>> m; // { index : { snap_id_ : val }}\\n    int snap_id_ = 0;\\n\\n    SnapshotArray(int length) {}\\n\\n    void set(int index, int val) {\\n        m[index][snap_id_] = val;\\n    }\\n\\n    int snap() {\\n        return snap_id_++;\\n    }\\n\\n    int get(int index, int snap_id) {\\n        auto itr = m[index].upper_bound(snap_id);\\n        if (itr == m[index].begin()) return 0;\\n        return (*prev(itr)).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253739,
                "title": "python-binary-search",
                "content": "The correct solution to this is using binary search. Please ignore all the people using `.copy()`. If you do that in an interview, you will definitely fail.\\n```\\n# nums = {}\\n# nums[index] = []\\n# nums[index][i] = (snap_id, val)\\n# set replaces current val if snap_id == nums[index][-1][0]\\n# else set appends current val and snap_id\\n# snap just increments snap_id and returns old snap_id\\n# get does a binary search on nums[index] for the target snap_id and returns the associated value\\n\\n# nums[5] = [(15, 4)]\\n# get(5, 13) => 0\\n# get(5, 16) => 4\\n\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.snap_id = 0\\n        self.nums = defaultdict(list)\\n\\n    def set(self, index: int, val: int) -> None:\\n        if not self.nums[index] or self.nums[index][-1][0] < self.snap_id:\\n            self.nums[index].append((self.snap_id, val))\\n        else:\\n            self.nums[index][-1] = (self.snap_id, val)\\n\\n    def snap(self) -> int:\\n        self.snap_id += 1\\n        return self.snap_id - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        l, r = 0, len(self.nums[index])\\n        while l < r:\\n            m = (l + r) // 2\\n            if self.nums[index][m][0] == snap_id:\\n                return self.nums[index][m][1]\\n            elif self.nums[index][m][0] < snap_id:\\n                l = m + 1\\n            else:\\n                r = m\\n        if l == 0:\\n            return 0\\n        return self.nums[index][l-1][1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n# nums = {}\\n# nums[index] = []\\n# nums[index][i] = (snap_id, val)\\n# set replaces current val if snap_id == nums[index][-1][0]\\n# else set appends current val and snap_id\\n# snap just increments snap_id and returns old snap_id\\n# get does a binary search on nums[index] for the target snap_id and returns the associated value\\n\\n# nums[5] = [(15, 4)]\\n# get(5, 13) => 0\\n# get(5, 16) => 4\\n\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.snap_id = 0\\n        self.nums = defaultdict(list)\\n\\n    def set(self, index: int, val: int) -> None:\\n        if not self.nums[index] or self.nums[index][-1][0] < self.snap_id:\\n            self.nums[index].append((self.snap_id, val))\\n        else:\\n            self.nums[index][-1] = (self.snap_id, val)\\n\\n    def snap(self) -> int:\\n        self.snap_id += 1\\n        return self.snap_id - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        l, r = 0, len(self.nums[index])\\n        while l < r:\\n            m = (l + r) // 2\\n            if self.nums[index][m][0] == snap_id:\\n                return self.nums[index][m][1]\\n            elif self.nums[index][m][0] < snap_id:\\n                l = m + 1\\n            else:\\n                r = m\\n        if l == 0:\\n            return 0\\n        return self.nums[index][l-1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377900,
                "title": "100-memory-88-74-hash-of-hash-map",
                "content": "```\\nclass SnapshotArray(object):\\n\\n    def __init__(self, length):\\n        \"\"\"\\n        :type length: int\\n        \"\"\"\\n        self.snaps = 0\\n        self.store = dict()\\n        self.store[0] = dict()\\n        \\n        \\n\\n    def set(self, index, val):\\n        \"\"\"\\n        :type index: int\\n        :type val: int\\n        :rtype: None\\n        \"\"\"\\n        self.store[self.snaps][index] = val\\n        \\n\\n    def snap(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        self.snaps += 1\\n        a = (self.store[self.snaps -1]).copy()\\n        self.store[self.snaps] = a\\n        return self.snaps -1\\n            \\n\\n    def get(self, index, snap_id):\\n        \"\"\"\\n        :type index: int\\n        :type snap_id: int\\n        :rtype: int\\n        \"\"\"\\n        if index in self.store[snap_id]:\\n            return self.store[snap_id][index]\\n        else:\\n            return 0\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SnapshotArray(object):\\n\\n    def __init__(self, length):\\n        \"\"\"\\n        :type length: int\\n        \"\"\"\\n        self.snaps = 0\\n        self.store = dict()\\n        self.store[0] = dict()\\n        \\n        \\n\\n    def set(self, index, val):\\n        \"\"\"\\n        :type index: int\\n        :type val: int\\n        :rtype: None\\n        \"\"\"\\n        self.store[self.snaps][index] = val\\n        \\n\\n    def snap(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        self.snaps += 1\\n        a = (self.store[self.snaps -1]).copy()\\n        self.store[self.snaps] = a\\n        return self.snaps -1\\n            \\n\\n    def get(self, index, snap_id):\\n        \"\"\"\\n        :type index: int\\n        :type snap_id: int\\n        :rtype: int\\n        \"\"\"\\n        if index in self.store[snap_id]:\\n            return self.store[snap_id][index]\\n        else:\\n            return 0\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352365,
                "title": "100-faster-in-c-solutions",
                "content": "```\\npublic class SnapshotArray {\\n\\n           private int SnapID = 0;\\n            private Dictionary<int, int>[] dicArray;\\n\\n            public SnapshotArray(int length)\\n            {\\n                dicArray = new Dictionary<int, int>[length];\\n            }\\n\\n            public void Set(int index, int val)\\n            {\\n                if (dicArray[index] == null)\\n                    dicArray[index] = new Dictionary<int, int>();\\n\\n                if (dicArray[index].ContainsKey(SnapID))\\n                    dicArray[index][SnapID] = val;\\n                else dicArray[index].Add(SnapID, val);\\n            }\\n\\n            public int Snap()\\n            {\\n                return SnapID++;\\n            }\\n\\n            public int Get(int index, int snap_id)\\n            {\\n                if (dicArray[index] == null)\\n                    return 0;\\n\\n                if (dicArray[index].ContainsKey(snap_id))\\n                    return dicArray[index][snap_id];\\n\\n                while (!dicArray[index].ContainsKey(snap_id) && snap_id != -1)\\n                    snap_id--;\\n\\n                return snap_id == -1 ? 0 : dicArray[index][snap_id];\\n            }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class SnapshotArray {\\n\\n           private int SnapID = 0;\\n            private Dictionary<int, int>[] dicArray;\\n\\n            public SnapshotArray(int length)\\n            {\\n                dicArray = new Dictionary<int, int>[length];\\n            }\\n\\n            public void Set(int index, int val)\\n            {\\n                if (dicArray[index] == null)\\n                    dicArray[index] = new Dictionary<int, int>();\\n\\n                if (dicArray[index].ContainsKey(SnapID))\\n                    dicArray[index][SnapID] = val;\\n                else dicArray[index].Add(SnapID, val);\\n            }\\n\\n            public int Snap()\\n            {\\n                return SnapID++;\\n            }\\n\\n            public int Get(int index, int snap_id)\\n            {\\n                if (dicArray[index] == null)\\n                    return 0;\\n\\n                if (dicArray[index].ContainsKey(snap_id))\\n                    return dicArray[index][snap_id];\\n\\n                while (!dicArray[index].ContainsKey(snap_id) && snap_id != -1)\\n                    snap_id--;\\n\\n                return snap_id == -1 ? 0 : dicArray[index][snap_id];\\n            }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624763,
                "title": "simple-c-solutions-map-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo different solutions are provided, each using a different data structure. One solution utilizes the C++ map data structure, while the other uses the set data structure. Both of these data structures have a defined order, i.e. \"<\". This allows the binary search function lower_bound to work correctly. In contrast, the unordered versions of these data structures (unordered_map and unordered_set) do not have a defined order, which makes it impossible to use lower_bound for binary search\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe set version needs an extra parameter for recording the sequence number for set() method, so tuple<int, int, int> is used.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SnapshotArray {\\n   int id=0; \\n   vector<map<int, int>> id_v;\\n\\npublic:\\n    SnapshotArray(int length) { \\n        id_v.assign(length, {{0,0}});   \\n    }\\n    \\n    void set(int index, int val) {\\n        id_v[index][id]=val;\\n    }\\n    \\n    int snap() {\\n       return id++; \\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if (id_v[index].count(snap_id)==0){\\n            auto it=prev(id_v[index].lower_bound(snap_id));\\n            return it->second;\\n        }\\n        return  id_v[index][snap_id];\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```\\n\\n```\\nclass SnapshotArray {\\n   int id=0;\\n   int set_seq=0; \\n   vector<set<tuple<int, int, int>>> id_v;\\n\\npublic:\\n    SnapshotArray(int length) { \\n        id_v.assign(length, {{0,0,0}});   \\n    }\\n    \\n    void set(int index, int val) {\\n        id_v[index].insert({id, set_seq++, val});\\n    }\\n    \\n    int snap() {\\n       return id++; \\n    }\\n    \\n    int get(int index, int snap_id) { \\n        auto it=prev(id_v[index].lower_bound({snap_id,set_seq,INT_MAX}));\\n        auto [id, _, v]=*it;\\n    //    cout<< id<<\",\"<<set_seq<<\",\"<<v<<endl;\\n        return v;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass SnapshotArray {\\n   int id=0; \\n   vector<map<int, int>> id_v;\\n\\npublic:\\n    SnapshotArray(int length) { \\n        id_v.assign(length, {{0,0}});   \\n    }\\n    \\n    void set(int index, int val) {\\n        id_v[index][id]=val;\\n    }\\n    \\n    int snap() {\\n       return id++; \\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if (id_v[index].count(snap_id)==0){\\n            auto it=prev(id_v[index].lower_bound(snap_id));\\n            return it->second;\\n        }\\n        return  id_v[index][snap_id];\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```\n```\\nclass SnapshotArray {\\n   int id=0;\\n   int set_seq=0; \\n   vector<set<tuple<int, int, int>>> id_v;\\n\\npublic:\\n    SnapshotArray(int length) { \\n        id_v.assign(length, {{0,0,0}});   \\n    }\\n    \\n    void set(int index, int val) {\\n        id_v[index].insert({id, set_seq++, val});\\n    }\\n    \\n    int snap() {\\n       return id++; \\n    }\\n    \\n    int get(int index, int snap_id) { \\n        auto it=prev(id_v[index].lower_bound({snap_id,set_seq,INT_MAX}));\\n        auto [id, _, v]=*it;\\n    //    cout<< id<<\",\"<<set_seq<<\",\"<<v<<endl;\\n        return v;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3624692,
                "title": "easy-c-explanation-binary-search-using-vector",
                "content": "# Intuition\\nWe don\\'t need to save the whole array at the time of snapshot. It would be sufficient to store the changed value at a given snap time, and if we want to reduce time complecity then we need to have a tradeoff between the given 3 queries and store the values in such a mannner that our queries can be handled in the desired time constraint.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCreating a vector<vector<pair<int,int> > > which will store the initial values and then at the time of set, we push an element to this vector containg the snap time and the changed value. \\n\\nWe will use a **binary search** on the set query to find the most recent snap with respect to given time/snapId.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n+m) where m is number of times set() is called\\nwhich is at most 5*10^4 calls.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SnapshotArray {\\npublic:\\n    vector< vector<pair<int,int> > >v;\\n    int id;\\n    SnapshotArray(int length) {\\n        v.resize(length);\\n        id=-1;\\n        for(int i=0;i<length;i++)\\n        {\\n            v[i].push_back({id,0});\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        v[index].push_back({id,val});\\n    }\\n    \\n    int snap() {\\n        id++;\\n        return id;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        int l=0,r=v[index].size()-1;\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            int mid=(r-l)/2+l;\\n            if(v[index][mid].first<snap_id)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            r=mid-1;\\n        }\\n        return v[index][ans].second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n    vector< vector<pair<int,int> > >v;\\n    int id;\\n    SnapshotArray(int length) {\\n        v.resize(length);\\n        id=-1;\\n        for(int i=0;i<length;i++)\\n        {\\n            v[i].push_back({id,0});\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        v[index].push_back({id,val});\\n    }\\n    \\n    int snap() {\\n        id++;\\n        return id;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        int l=0,r=v[index].size()-1;\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            int mid=(r-l)/2+l;\\n            if(v[index][mid].first<snap_id)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            r=mid-1;\\n        }\\n        return v[index][ans].second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979773,
                "title": "simple-js-solution-using-arrays",
                "content": "```\\nconst SnapshotArray = function (length) {\\n\\tthis.data = [];\\n\\tthis.snaps = [];\\n};\\n\\nSnapshotArray.prototype.set = function (index, val) {\\n\\tthis.data[index] = val;\\n};\\n\\nSnapshotArray.prototype.snap = function () {\\n\\tthis.snaps.push([...this.data]);\\n\\treturn this.snaps.length - 1;\\n};\\n\\nSnapshotArray.prototype.get = function (index, snap_id) {\\n\\tconst value = this.snaps[snap_id][index];\\n\\treturn value === undefined ? 0 : value;\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst SnapshotArray = function (length) {\\n\\tthis.data = [];\\n\\tthis.snaps = [];\\n};\\n\\nSnapshotArray.prototype.set = function (index, val) {\\n\\tthis.data[index] = val;\\n};\\n\\nSnapshotArray.prototype.snap = function () {\\n\\tthis.snaps.push([...this.data]);\\n\\treturn this.snaps.length - 1;\\n};\\n\\nSnapshotArray.prototype.get = function (index, snap_id) {\\n\\tconst value = this.snaps[snap_id][index];\\n\\treturn value === undefined ? 0 : value;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1772937,
                "title": "java-easy-clean-and-concise-solution-using-array-of-hashmap",
                "content": "```\\nclass SnapshotArray {\\n\\tHashMap<Integer, Integer>[] snaps;\\n\\tint snapno;\\n\\n    public SnapshotArray(int length) {\\n        snaps = new HashMap[length];\\n        for(int i = 0; i < length; i++)\\n            snaps[i] = new HashMap<>();\\n        snapno = 0;\\n    }\\n    \\n    public void set(int index, int val) {\\n        snaps[index].put(snapno, val);\\n    }\\n    \\n    public int snap() {\\n        snapno++;\\n        return snapno - 1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        while(snap_id >= 0){\\n            if(snaps[index].containsKey(snap_id))\\n                return snaps[index].get(snap_id);\\n            else\\n                snap_id--;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SnapshotArray {\\n\\tHashMap<Integer, Integer>[] snaps;\\n\\tint snapno;\\n\\n    public SnapshotArray(int length) {\\n        snaps = new HashMap[length];\\n        for(int i = 0; i < length; i++)\\n            snaps[i] = new HashMap<>();\\n        snapno = 0;\\n    }\\n    \\n    public void set(int index, int val) {\\n        snaps[index].put(snapno, val);\\n    }\\n    \\n    public int snap() {\\n        snapno++;\\n        return snapno - 1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        while(snap_id >= 0){\\n            if(snaps[index].containsKey(snap_id))\\n                return snaps[index].get(snap_id);\\n            else\\n                snap_id--;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482819,
                "title": "c-196ms-82-simple-easy-small-stl",
                "content": "Runtime: 196 ms, faster than 82.30% of C++ online submissions for Snapshot Array.\\nMemory Usage: 93.6 MB, less than 54.41% of C++ online submissions for Snapshot Array.\\n```\\nclass SnapshotArray {\\npublic:\\n  vector<vector<pair<int,int>>> v;\\n  int sn;\\n  \\n  SnapshotArray(int length){\\n    v.resize(length, vector<pair<int,int>>(1, pair<int,int>({0,0})));\\n    sn = 0;\\n  }\\n    \\n  void set(int index, int val){\\n    v[index].push_back({sn, val});\\n  }\\n    \\n  int snap() {\\n    return sn++;  \\n  }\\n    \\n  int get(int i, int s_id){\\n    return v [i] [upper_bound(v[i].begin(), v[i].end(), s_id, comp) - v[i].begin() - 1] .second;  \\n  }\\n  \\n  static bool comp(int n, pair<int,int> &p){\\n    return p.first > n;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n  vector<vector<pair<int,int>>> v;\\n  int sn;\\n  \\n  SnapshotArray(int length){\\n    v.resize(length, vector<pair<int,int>>(1, pair<int,int>({0,0})));\\n    sn = 0;\\n  }\\n    \\n  void set(int index, int val){\\n    v[index].push_back({sn, val});\\n  }\\n    \\n  int snap() {\\n    return sn++;  \\n  }\\n    \\n  int get(int i, int s_id){\\n    return v [i] [upper_bound(v[i].begin(), v[i].end(), s_id, comp) - v[i].begin() - 1] .second;  \\n  }\\n  \\n  static bool comp(int n, pair<int,int> &p){\\n    return p.first > n;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482345,
                "title": "cpp",
                "content": "```\\nclass SnapshotArray {\\n    vector<map<int, int>> array;\\n    int snapCnt;\\npublic:\\n    SnapshotArray(int length) {\\n        array.resize(length);\\n        snapCnt=0;\\n        for(int i=0; i<length; i++){\\n            array[i][snapCnt] = 0;\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        array[index][snapCnt] = val;\\n    }\\n    \\n    int snap() {\\n        return snapCnt++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it = array[index].find(snap_id);\\n        if(it != array[index].end()) {\\n            return it->second;\\n        } else {            \\n            auto it = array[index].upper_bound(snap_id);\\n            it--;\\n            return it->second;\\n        }\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n    vector<map<int, int>> array;\\n    int snapCnt;\\npublic:\\n    SnapshotArray(int length) {\\n        array.resize(length);\\n        snapCnt=0;\\n        for(int i=0; i<length; i++){\\n            array[i][snapCnt] = 0;\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        array[index][snapCnt] = val;\\n    }\\n    \\n    int snap() {\\n        return snapCnt++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it = array[index].find(snap_id);\\n        if(it != array[index].end()) {\\n            return it->second;\\n        } else {            \\n            auto it = array[index].upper_bound(snap_id);\\n            it--;\\n            return it->second;\\n        }\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410270,
                "title": "java-arraylist-solution",
                "content": "The main idea is that we can utilize the indices of the array list for each index to correspond to the id. \\n\\nIn the get() method:\\n* If we cannot find the id, it means that at this specific snapshot it was never modifed. So we either pull the last changed value for this index, or return 0 if it was never modified at all (i.e. list is empty)\\n\\nIn the set() method:\\n* We will fill the gap between the last snap_id and the current one with the latest changed (last snap_id) and then replace the value with the given value in the method parameter for this current snap_id.\\n\\n\\n```\\nclass SnapshotArray {\\n    \\n    private int id;\\n    private List<Integer>[] array;\\n    \\n    public SnapshotArray(int length) {\\n        array = new List[length];\\n        for(int i = 0; i < array.length; i++) array[i] = new ArrayList<>();\\n        id = 0;\\n    }\\n    \\n    public void set(int index, int val) {\\n        List<Integer> list = array[index];\\n        int valueRepeat = (list.isEmpty()) ? 0 : list.get(list.size()-1);\\n        for(int i = list.size() - 1; i < id; i++) list.add(valueRepeat);\\n        list.set(id, val);\\n    }\\n    \\n    public int snap() {\\n        return id++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        List<Integer> list = array[index];\\n        if(list.isEmpty()) return 0;\\n        if(list.size()-1 < snap_id) return list.get(list.size()-1);\\n        return list.get(snap_id);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n    \\n    private int id;\\n    private List<Integer>[] array;\\n    \\n    public SnapshotArray(int length) {\\n        array = new List[length];\\n        for(int i = 0; i < array.length; i++) array[i] = new ArrayList<>();\\n        id = 0;\\n    }\\n    \\n    public void set(int index, int val) {\\n        List<Integer> list = array[index];\\n        int valueRepeat = (list.isEmpty()) ? 0 : list.get(list.size()-1);\\n        for(int i = list.size() - 1; i < id; i++) list.add(valueRepeat);\\n        list.set(id, val);\\n    }\\n    \\n    public int snap() {\\n        return id++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        List<Integer> list = array[index];\\n        if(list.isEmpty()) return 0;\\n        if(list.size()-1 < snap_id) return list.get(list.size()-1);\\n        return list.get(snap_id);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626862,
                "title": "java-treemap-10-lines-beats-95-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ for the `get` method, where n = number of snaps generated so far. $$O(1)$$ for all other methods.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$ where m = length of the snapshot array, n = number of snaps generated.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SnapshotArray {\\n  TreeMap<Integer, Integer>[] map;\\n  int snap_id;\\n\\n  public SnapshotArray(int length) {\\n    map = new TreeMap[length];\\n    snap_id = 0;\\n  }\\n  \\n  public void set(int index, int val) {\\n    if (map[index] == null) map[index] = new TreeMap<>();\\n\\n    map[index].put(snap_id, val);\\n  }\\n  \\n  public int snap() {\\n    return snap_id++;\\n  }\\n  \\n  public int get(int index, int snap_id) {\\n    if (map[index] == null) return 0;\\n    \\n    var entry = map[index].floorEntry(snap_id);\\n\\n    return entry == null ? 0 : entry.getValue();\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass SnapshotArray {\\n  TreeMap<Integer, Integer>[] map;\\n  int snap_id;\\n\\n  public SnapshotArray(int length) {\\n    map = new TreeMap[length];\\n    snap_id = 0;\\n  }\\n  \\n  public void set(int index, int val) {\\n    if (map[index] == null) map[index] = new TreeMap<>();\\n\\n    map[index].put(snap_id, val);\\n  }\\n  \\n  public int snap() {\\n    return snap_id++;\\n  }\\n  \\n  public int get(int index, int snap_id) {\\n    if (map[index] == null) return 0;\\n    \\n    var entry = map[index].floorEntry(snap_id);\\n\\n    return entry == null ? 0 : entry.getValue();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624465,
                "title": "javascript-simple-hash-table-solution-without-memory-overflow",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe trick is to increament the snap_id. if you create new array for each snapId. You\\'ll get a memory error. You need to create an array for each snap_id IF IT\\'S NECESSARY.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, create an object which will store the arrays associated with the snap id.\\nSecond, create a snap_id variable in construction function. Like so this.snap_id\\n\\nset(index, val): for set method check if the current array with the snap_id exists. If it does then append the value at the index of that array. If it doesn\\'t exist then create a new array and add the value at the given index.\\n\\nsnap(): This one is the esieast. just store the current snap_id from this.snap_id in some variable. return that variable. But, before returning from the function also increament this.snap_id so we have new snap_id when we try to set some value.\\n \\nget(index, snap_id): this is the tricky one(but not too bad). start looping from the snap_id till 0. If we have an existing array with current snap_id then return the index at that snap_id.\\n\\nSOORY FOR THE LONG ANSWER.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    set: this will have time complexity of O(1)\\n    snap: this will have time complexity of O(1)\\n    get: this will have time complexity of O(n).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} length\\n */\\nvar SnapshotArray = function(length) {\\n    this.snapId = 0;\\n    this.snapShots = {};\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} val\\n * @return {void}\\n */\\nSnapshotArray.prototype.set = function(index, val) {\\n    if(this.snapShots[this.snapId]) {\\n        this.snapShots[this.snapId][index] = val;\\n    } else {\\n        this.snapShots[this.snapId] = [];\\n        this.snapShots[this.snapId][index] = val;\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nSnapshotArray.prototype.snap = function() {\\n    const snapId = this.snapId;\\n    this.snapId += 1;\\n    return snapId;\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} snap_id\\n * @return {number}\\n */\\nSnapshotArray.prototype.get = function(index, snap_id) {\\n\\n    for(let  i = snap_id; i > -1; i--) {\\n        if(this.snapShots[i] && this.snapShots[i][index] !== undefined) return this.snapShots[i][index];\\n    }\\n    return 0;\\n};\\n\\n/** \\n * Your SnapshotArray object will be instantiated and called as such:\\n * var obj = new SnapshotArray(length)\\n * obj.set(index,val)\\n * var param_2 = obj.snap()\\n * var param_3 = obj.get(index,snap_id)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {number} length\\n */\\nvar SnapshotArray = function(length) {\\n    this.snapId = 0;\\n    this.snapShots = {};\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} val\\n * @return {void}\\n */\\nSnapshotArray.prototype.set = function(index, val) {\\n    if(this.snapShots[this.snapId]) {\\n        this.snapShots[this.snapId][index] = val;\\n    } else {\\n        this.snapShots[this.snapId] = [];\\n        this.snapShots[this.snapId][index] = val;\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nSnapshotArray.prototype.snap = function() {\\n    const snapId = this.snapId;\\n    this.snapId += 1;\\n    return snapId;\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} snap_id\\n * @return {number}\\n */\\nSnapshotArray.prototype.get = function(index, snap_id) {\\n\\n    for(let  i = snap_id; i > -1; i--) {\\n        if(this.snapShots[i] && this.snapShots[i][index] !== undefined) return this.snapShots[i][index];\\n    }\\n    return 0;\\n};\\n\\n/** \\n * Your SnapshotArray object will be instantiated and called as such:\\n * var obj = new SnapshotArray(length)\\n * obj.set(index,val)\\n * var param_2 = obj.snap()\\n * var param_3 = obj.get(index,snap_id)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3624111,
                "title": "easy-python-solution-using-binary-search-2-d-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*n*2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SnapshotArray:\\n    def bs(self,lt,rt,tr,lst):\\n        ps=0\\n        while lt<=rt:\\n            mid=(lt+rt)//2\\n            if lst[mid][1]<=tr:\\n                ps=mid\\n                lt=mid+1\\n            else:\\n                rt=mid-1\\n        return ps\\n\\n\\n    def __init__(self, length: int):\\n        self.lst=[0]*length\\n        self._id=0\\n        self.nums=[[(0,0)] for _ in range(length)]\\n        \\n\\n    def set(self, index: int, val: int) -> None:\\n        self.lst[index]=val\\n        if self.nums[index][-1][1]==self._id:\\n            self.nums[index][-1]=(val,self._id)\\n        elif self.nums[index][-1][1]<self._id:\\n            self.nums[index].append((val,self._id))\\n        \\n\\n    def snap(self) -> int:\\n        x=self._id\\n        self._id+=1\\n        return x\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        x=self.bs(0,len(self.nums[index])-1,snap_id,self.nums[index])\\n        return self.nums[index][x][0]\\n\\n        \\n\\n\\n# Your SnapshotArray object will be instantiated and called as such:\\n# obj = SnapshotArray(length)\\n# obj.set(index,val)\\n# param_2 = obj.snap()\\n# param_3 = obj.get(index,snap_id)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass SnapshotArray:\\n    def bs(self,lt,rt,tr,lst):\\n        ps=0\\n        while lt<=rt:\\n            mid=(lt+rt)//2\\n            if lst[mid][1]<=tr:\\n                ps=mid\\n                lt=mid+1\\n            else:\\n                rt=mid-1\\n        return ps\\n\\n\\n    def __init__(self, length: int):\\n        self.lst=[0]*length\\n        self._id=0\\n        self.nums=[[(0,0)] for _ in range(length)]\\n        \\n\\n    def set(self, index: int, val: int) -> None:\\n        self.lst[index]=val\\n        if self.nums[index][-1][1]==self._id:\\n            self.nums[index][-1]=(val,self._id)\\n        elif self.nums[index][-1][1]<self._id:\\n            self.nums[index].append((val,self._id))\\n        \\n\\n    def snap(self) -> int:\\n        x=self._id\\n        self._id+=1\\n        return x\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        x=self.bs(0,len(self.nums[index])-1,snap_id,self.nums[index])\\n        return self.nums[index][x][0]\\n\\n        \\n\\n\\n# Your SnapshotArray object will be instantiated and called as such:\\n# obj = SnapshotArray(length)\\n# obj.set(index,val)\\n# param_2 = obj.snap()\\n# param_3 = obj.get(index,snap_id)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623621,
                "title": "2-easy-to-understand-c-solution-fastest",
                "content": "\\n# Approach : HashMap\\nCreate a Unique Hashmap\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code 1\\n```\\nclass SnapshotArray {\\npublic:\\n\\nvector<map<int,int ,greater<int>>> mp;\\nint id=0;\\n    SnapshotArray(int length) {\\n        mp.resize(length);\\n    }\\n    \\n    void set(int index, int val) {\\n        mp[index][id]=val;\\n    }\\n    \\n    int snap() {\\n    return id++;\\n}\\n    \\n    int get(int index, int snap_id) {\\n        auto i=mp[index].lower_bound(snap_id);\\n        return i->second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```\\n\\n# Approach : Binary Search\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code 1\\n```\\nclass SnapshotArray {\\npublic:\\n    SnapshotArray(int length) : len(length) {\\n        \\n    }\\n    \\n    void set(int index, int val) {\\n        if (index >= len) {\\n            return;\\n        }\\n                \\n        snapArray[index][snapCount] = val;\\n    }\\n    \\n    int snap() {\\n        ++snapCount;\\n        return snapCount - 1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if (index >= len || snap_id > snapCount) {\\n            return -1;\\n        }\\n        if (snapArray[index].empty()) {\\n            return 0;\\n        }\\n        auto pos = snapArray[index].lower_bound(snap_id);\\n        if (pos == snapArray[index].end()) {\\n            return 0;\\n        }\\n\\n        return pos->second;\\n    }\\n    private:\\n    using SMap = std::map<int, int, greater<int>>;\\n    std::unordered_map<int, SMap> snapArray;\\n    int snapCount = 0;\\n    int len = 0;\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n\\nvector<map<int,int ,greater<int>>> mp;\\nint id=0;\\n    SnapshotArray(int length) {\\n        mp.resize(length);\\n    }\\n    \\n    void set(int index, int val) {\\n        mp[index][id]=val;\\n    }\\n    \\n    int snap() {\\n    return id++;\\n}\\n    \\n    int get(int index, int snap_id) {\\n        auto i=mp[index].lower_bound(snap_id);\\n        return i->second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```\n```\\nclass SnapshotArray {\\npublic:\\n    SnapshotArray(int length) : len(length) {\\n        \\n    }\\n    \\n    void set(int index, int val) {\\n        if (index >= len) {\\n            return;\\n        }\\n                \\n        snapArray[index][snapCount] = val;\\n    }\\n    \\n    int snap() {\\n        ++snapCount;\\n        return snapCount - 1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if (index >= len || snap_id > snapCount) {\\n            return -1;\\n        }\\n        if (snapArray[index].empty()) {\\n            return 0;\\n        }\\n        auto pos = snapArray[index].lower_bound(snap_id);\\n        if (pos == snapArray[index].end()) {\\n            return 0;\\n        }\\n\\n        return pos->second;\\n    }\\n    private:\\n    using SMap = std::map<int, int, greater<int>>;\\n    std::unordered_map<int, SMap> snapArray;\\n    int snapCount = 0;\\n    int len = 0;\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623570,
                "title": "optimized-solution-0ms-runtime",
                "content": "```\\nclass SnapshotArray {\\n    vector<vector<pair<int, int>>> snaps;\\n    int currentSnap;\\npublic:\\n    SnapshotArray(int length) {\\n        snaps.resize(length);\\n        currentSnap = 0;\\n    }\\n    \\n    void set(int index, int val) {\\n        snaps[index].emplace_back(currentSnap, val);\\n    }\\n    \\n    int snap() {\\n        return currentSnap++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it = upper_bound(snaps[index].begin(), snaps[index].end(), make_pair(snap_id, INT_MAX));\\n        if (it == snaps[index].begin())\\n            return 0;\\n        return prev(it)->second;\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE :)**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass SnapshotArray {\\n    vector<vector<pair<int, int>>> snaps;\\n    int currentSnap;\\npublic:\\n    SnapshotArray(int length) {\\n        snaps.resize(length);\\n        currentSnap = 0;\\n    }\\n    \\n    void set(int index, int val) {\\n        snaps[index].emplace_back(currentSnap, val);\\n    }\\n    \\n    int snap() {\\n        return currentSnap++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it = upper_bound(snaps[index].begin(), snaps[index].end(), make_pair(snap_id, INT_MAX));\\n        if (it == snaps[index].begin())\\n            return 0;\\n        return prev(it)->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286872,
                "title": "c-code",
                "content": "# Intuition\\nIn the intuition method, we can store every number in every snaphot.\\nConsequently, we would encounter timeout results.\\n\\n# Approach\\nWe need to use hash table to \"only\" store value when \"set\" function has been called.\\n\\nThis question is very easy when we apply the C++ language.\\nHowever, it is very hard by C language, because we have to control the memory usage and allocation. Otherwise, we would get timeout result.\\n\\n# Complexity\\n- Time complexity:\\nIn the get function, it would be O(LogN).\\nIn the set function, it would be O(1).\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\n\\n#define INIT_SNAP_SIZE 10\\n\\ntypedef struct {\\n    int ***table;\\n    int *size;\\n    int snap_id;\\n    int snap_size;\\n} SnapshotArray;\\n\\n\\nSnapshotArray* snapshotArrayCreate(int length) {\\n    int i, j;\\n    SnapshotArray *obj = (SnapshotArray *)malloc(sizeof(SnapshotArray));\\n    obj->snap_id = 0;\\n    obj->snap_size = INIT_SNAP_SIZE;\\n    obj->table = (int ***)malloc(sizeof(int **) * length);\\n    for (i=0; i<length; i++) {\\n        obj->table[i] = (int **)malloc(sizeof(int *) * obj->snap_size);\\n        for (j=0; j<obj->snap_size; j++) {\\n            obj->table[i][j] = calloc(2, sizeof(int));\\n        }\\n    }\\n    obj->size = (int *)malloc(sizeof(int) * length);\\n    for (i=0; i<length; i++)\\n        obj->size[i] = 1;\\n    return obj;\\n}\\n\\nvoid snapshotArraySet(SnapshotArray* obj, int index, int val) {\\n    int i, size = obj->size[index];\\n\\n    if (obj->table[index][size-1][0] == obj->snap_id) {\\n        obj->table[index][size-1][1] = val;\\n        return;\\n    }\\n\\n    if (obj->size[index] == obj->snap_size) {\\n         obj->table[index] = (int **)realloc(obj->table[index], sizeof(int *) * (obj->snap_size * 2));\\n         for (i=obj->snap_size; i<obj->snap_size*2; i++)\\n            obj->table[index][i] = calloc(2, sizeof(int));\\n\\n        obj->snap_size *= 2;\\n    }\\n\\n    obj->table[index][size][0] = obj->snap_id;\\n    obj->table[index][size][1] = val;\\n    obj->size[index]++;\\n}\\n\\nint snapshotArraySnap(SnapshotArray* obj) {\\n    return obj->snap_id++;\\n}\\n\\nint snapshotArrayGet(SnapshotArray* obj, int index, int snap_id) {\\n    int left, right, mid;\\n\\n    left = 0;\\n    right = obj->size[index] - 1;\\n    while (left < right) {\\n        mid = left + (right - left + 1) / 2;\\n        if (obj->table[index][mid][0] <= snap_id)\\n            left = mid;\\n        else\\n            right = mid - 1;\\n    }\\n\\n    return obj->table[index][left][1];\\n}\\n\\nvoid snapshotArrayFree(SnapshotArray* obj) {\\n    free(obj);\\n}\\n\\n/**\\n * Your SnapshotArray struct will be instantiated and called as such:\\n * SnapshotArray* obj = snapshotArrayCreate(length);\\n * snapshotArraySet(obj, index, val);\\n \\n * int param_2 = snapshotArraySnap(obj);\\n \\n * int param_3 = snapshotArrayGet(obj, index, snap_id);\\n \\n * snapshotArrayFree(obj);\\n*/\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n#define INIT_SNAP_SIZE 10\\n\\ntypedef struct {\\n    int ***table;\\n    int *size;\\n    int snap_id;\\n    int snap_size;\\n} SnapshotArray;\\n\\n\\nSnapshotArray* snapshotArrayCreate(int length) {\\n    int i, j;\\n    SnapshotArray *obj = (SnapshotArray *)malloc(sizeof(SnapshotArray));\\n    obj->snap_id = 0;\\n    obj->snap_size = INIT_SNAP_SIZE;\\n    obj->table = (int ***)malloc(sizeof(int **) * length);\\n    for (i=0; i<length; i++) {\\n        obj->table[i] = (int **)malloc(sizeof(int *) * obj->snap_size);\\n        for (j=0; j<obj->snap_size; j++) {\\n            obj->table[i][j] = calloc(2, sizeof(int));\\n        }\\n    }\\n    obj->size = (int *)malloc(sizeof(int) * length);\\n    for (i=0; i<length; i++)\\n        obj->size[i] = 1;\\n    return obj;\\n}\\n\\nvoid snapshotArraySet(SnapshotArray* obj, int index, int val) {\\n    int i, size = obj->size[index];\\n\\n    if (obj->table[index][size-1][0] == obj->snap_id) {\\n        obj->table[index][size-1][1] = val;\\n        return;\\n    }\\n\\n    if (obj->size[index] == obj->snap_size) {\\n         obj->table[index] = (int **)realloc(obj->table[index], sizeof(int *) * (obj->snap_size * 2));\\n         for (i=obj->snap_size; i<obj->snap_size*2; i++)\\n            obj->table[index][i] = calloc(2, sizeof(int));\\n\\n        obj->snap_size *= 2;\\n    }\\n\\n    obj->table[index][size][0] = obj->snap_id;\\n    obj->table[index][size][1] = val;\\n    obj->size[index]++;\\n}\\n\\nint snapshotArraySnap(SnapshotArray* obj) {\\n    return obj->snap_id++;\\n}\\n\\nint snapshotArrayGet(SnapshotArray* obj, int index, int snap_id) {\\n    int left, right, mid;\\n\\n    left = 0;\\n    right = obj->size[index] - 1;\\n    while (left < right) {\\n        mid = left + (right - left + 1) / 2;\\n        if (obj->table[index][mid][0] <= snap_id)\\n            left = mid;\\n        else\\n            right = mid - 1;\\n    }\\n\\n    return obj->table[index][left][1];\\n}\\n\\nvoid snapshotArrayFree(SnapshotArray* obj) {\\n    free(obj);\\n}\\n\\n/**\\n * Your SnapshotArray struct will be instantiated and called as such:\\n * SnapshotArray* obj = snapshotArrayCreate(length);\\n * snapshotArraySet(obj, index, val);\\n \\n * int param_2 = snapshotArraySnap(obj);\\n \\n * int param_3 = snapshotArrayGet(obj, index, snap_id);\\n \\n * snapshotArrayFree(obj);\\n*/\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2690147,
                "title": "c-binary-search-hashmap-clean-concise",
                "content": "```\\n  map< int , map< int , int >> mp;\\n    \\n    int count=0;\\n    \\n    SnapshotArray(int length) {\\n        \\n    }\\n    \\n    void set(int index, int val) {\\n        \\n        mp[index][count]=val;\\n        \\n    }\\n    \\n    int snap() {\\n        \\n        count++;\\n        \\n        return count-1;\\n        \\n    }\\n    \\n    int get(int index, int snap_id) {\\n        \\n        auto it = mp[index].lower_bound(snap_id+1);\\n        \\n        int v=0;\\n        \\n        if(it!=mp[index].begin())\\n        {\\n            it--;\\n            v = it->second;\\n        }\\n        \\n        return v;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n  map< int , map< int , int >> mp;\\n    \\n    int count=0;\\n    \\n    SnapshotArray(int length) {\\n        \\n    }\\n    \\n    void set(int index, int val) {\\n        \\n        mp[index][count]=val;\\n        \\n    }\\n    \\n    int snap() {\\n        \\n        count++;\\n        \\n        return count-1;\\n        \\n    }\\n    \\n    int get(int index, int snap_id) {\\n        \\n        auto it = mp[index].lower_bound(snap_id+1);\\n        \\n        int v=0;\\n        \\n        if(it!=mp[index].begin())\\n        {\\n            it--;\\n            v = it->second;\\n        }\\n        \\n        return v;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2050407,
                "title": "simple-java-solution-using-hashmap-36ms-faster-than-90-38",
                "content": "Please upvote, if you find it useful :)\\n\\n```\\nclass SnapshotArray {\\n\\n    public HashMap<Integer, Integer>[] snapshotMap;\\n    public int snapID;\\n    \\n    public SnapshotArray(int length) {\\n        snapID = 0;\\n        snapshotMap = new HashMap[length];\\n        \\n        for(int i=0; i<length; i++) {\\n            snapshotMap[i] = new HashMap<>();\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        snapshotMap[index].put(snapID, val);\\n    }\\n    \\n    public int snap() {\\n        snapID += 1;\\n        return snapID - 1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        while(snap_id >= 0) {\\n            if(snapshotMap[index].containsKey(snap_id)) {\\n                return snapshotMap[index].get(snap_id);\\n            }\\n\\n            snap_id -= 1;\\n        }\\n        \\n        return 0;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SnapshotArray {\\n\\n    public HashMap<Integer, Integer>[] snapshotMap;\\n    public int snapID;\\n    \\n    public SnapshotArray(int length) {\\n        snapID = 0;\\n        snapshotMap = new HashMap[length];\\n        \\n        for(int i=0; i<length; i++) {\\n            snapshotMap[i] = new HashMap<>();\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        snapshotMap[index].put(snapID, val);\\n    }\\n    \\n    public int snap() {\\n        snapID += 1;\\n        return snapID - 1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        while(snap_id >= 0) {\\n            if(snapshotMap[index].containsKey(snap_id)) {\\n                return snapshotMap[index].get(snap_id);\\n            }\\n\\n            snap_id -= 1;\\n        }\\n        \\n        return 0;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756248,
                "title": "python-maintaining-history-binary-search-o-log-n-get-o-1-snap-o-1-set",
                "content": "# Idea\\nMaintain the history of every index.\\n# Brute force solution\\nCopy the entire array for every snapshot. This has O(1) get and set, but O(n) for every snapshot.\\n# Faster snapshot solution (this solution)\\nMaintain the _history_ for every index, by storing for every set the current snapshot id, and appending it to the history. To take a snapshot, just update the snapshot id, and to find the value of an index element for a certain snapshot id, perform a binary search, since the history is sorted by snapshot id. This gives O(1) set and snap, and O(log(n)) get.\\n\\n# Code\\n```\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.snap_id = -1\\n        self.history = [[(self.snap_id, 0)] for _ in range(length)] # list of histories (snap_id, value)\\n        self.snap_id = 0\\n       \\n\\n    def set(self, index: int, val: int) -> None:\\n        self.history[index].append((self.snap_id, val))\\n        \\n\\n    def snap(self) -> int:\\n        self.snap_id += 1\\n        return self.snap_id - 1\\n\\n   \\n    def get(self, index: int, snap_id: int) -> int:\\n        history = self.history[index]\\n        lower, upper = 0, len(history) - 1\\n        while lower != upper:\\n            mid = (upper + lower) // 2 + 1\\n            if history[mid][0] <= snap_id:\\n                lower = mid\\n            else: # history[mid][0] > snap_id implying history[mid-1][0] is >= snap_id - 1\\n                upper = mid - 1\\n            \\n        return history[lower][1]\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.snap_id = -1\\n        self.history = [[(self.snap_id, 0)] for _ in range(length)] # list of histories (snap_id, value)\\n        self.snap_id = 0\\n       \\n\\n    def set(self, index: int, val: int) -> None:\\n        self.history[index].append((self.snap_id, val))\\n        \\n\\n    def snap(self) -> int:\\n        self.snap_id += 1\\n        return self.snap_id - 1\\n\\n   \\n    def get(self, index: int, snap_id: int) -> int:\\n        history = self.history[index]\\n        lower, upper = 0, len(history) - 1\\n        while lower != upper:\\n            mid = (upper + lower) // 2 + 1\\n            if history[mid][0] <= snap_id:\\n                lower = mid\\n            else: # history[mid][0] > snap_id implying history[mid-1][0] is >= snap_id - 1\\n                upper = mid - 1\\n            \\n        return history[lower][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533636,
                "title": "java-single-map-composite-index",
                "content": "\\n* Current snap id is already decided\\n* Doesn\\'t store any 0s or empty records. Stores only the index and value.\\n* In the get(index, snap_id) function, do lookup in the same HashMap\\n\\n\\n```\\nclass SnapshotArray {\\n    HashMap<String, Integer> snaps = new HashMap<String, Integer>();\\n    int currentSnapId = 0;\\n        \\n    public SnapshotArray(int length) {\\n    }\\n    \\n    public void set(int index, int val) {\\n        snaps.put(\"\" + currentSnapId + \",\" + index, val);\\n    }\\n    \\n    \\n    public int snap(){\\n        return currentSnapId++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        if(snap_id > currentSnapId) return 0;\\n        \\n        for(int i=snap_id; i >=0; i--)\\n            if (snaps.containsKey(\"\" + i + \",\" + index)) \\n                return snaps.get(\"\" + i + \",\" + index).intValue();       \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n    HashMap<String, Integer> snaps = new HashMap<String, Integer>();\\n    int currentSnapId = 0;\\n        \\n    public SnapshotArray(int length) {\\n    }\\n    \\n    public void set(int index, int val) {\\n        snaps.put(\"\" + currentSnapId + \",\" + index, val);\\n    }\\n    \\n    \\n    public int snap(){\\n        return currentSnapId++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        if(snap_id > currentSnapId) return 0;\\n        \\n        for(int i=snap_id; i >=0; i--)\\n            if (snaps.containsKey(\"\" + i + \",\" + index)) \\n                return snaps.get(\"\" + i + \",\" + index).intValue();       \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530937,
                "title": "python-1-5-lines-per-function-bests-98-89-with-explanation",
                "content": "The idea is simple. \\n1. The array-like data structure with default value 0 can be implemented as a default dictionary `self.dict` with default value 0.\\n2. The snapshots `self.snap_arr` is a list of such default dictionaries. \\n3. The `snap()` function appends one element to `self.snap_arr`, whose length is exactly the \"total number of times we called `snap()`\".\\n```\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.dict = defaultdict(int)\\n        self.snap_arr = []\\n\\t\\t\\n    def set(self, index: int, val: int) -> None:\\n        self.dict[index] = val\\n\\t\\t\\n    def snap(self) -> int:\\n        self.snap_arr.append(self.dict.copy())\\n        return len(self.snap_arr) - 1\\n\\t\\t\\n    def get(self, index: int, snap_id: int) -> int:\\n        return self.snap_arr[snap_id][index]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.dict = defaultdict(int)\\n        self.snap_arr = []\\n\\t\\t\\n    def set(self, index: int, val: int) -> None:\\n        self.dict[index] = val\\n\\t\\t\\n    def snap(self) -> int:\\n        self.snap_arr.append(self.dict.copy())\\n        return len(self.snap_arr) - 1\\n\\t\\t\\n    def get(self, index: int, snap_id: int) -> int:\\n        return self.snap_arr[snap_id][index]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370440,
                "title": "go-slice-bin-search-faster-than-96",
                "content": "```\\ntype Snapshot struct {\\n\\tid  int\\n\\tval int\\n}\\n\\ntype SnapshotsHistory struct {\\n\\tsnapshots *[]Snapshot\\n\\tcurrVal   int\\n}\\n\\ntype SnapshotArray struct {\\n\\tarray      *[]*SnapshotsHistory\\n\\tsnapshotId int\\n}\\n\\nfunc Constructor(length int) SnapshotArray {\\n\\tarr := make([]*SnapshotsHistory, length)\\n\\tres := SnapshotArray{&arr, 0}\\n\\n\\tfor i := 0; i < length; i++ {\\n\\t\\thist := make([]Snapshot, 0)\\n\\t\\t(*res.array)[i] = &SnapshotsHistory{&hist, 0}\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc (this *SnapshotArray) Set(index int, val int) {\\n\\thist := (*this.array)[index]\\n\\n\\tif this.snapshotId > 0 && (len(*hist.snapshots) == 0 || (*hist.snapshots)[len(*hist.snapshots)-1].id < this.snapshotId) {\\n\\t\\t*hist.snapshots = append(*hist.snapshots, Snapshot{this.snapshotId - 1, hist.currVal})\\n\\t}\\n\\n\\thist.currVal = val\\n}\\n\\nfunc (this *SnapshotArray) Snap() int {\\n\\tdefer func() {\\n\\t\\tthis.snapshotId++\\n\\t}()\\n\\treturn this.snapshotId\\n}\\n\\nfunc (this *SnapshotArray) Get(index int, snapId int) int {\\n\\thist := (*this.array)[index]\\n\\n\\tif len(*hist.snapshots) == 0 || (*hist.snapshots)[len(*hist.snapshots)-1].id < snapId {\\n\\t\\treturn hist.currVal\\n\\t}\\n\\n\\tl := 0\\n\\tr := len(*hist.snapshots)\\n\\tm := 0\\n\\n\\tfor l < r {\\n\\t\\tm = (l + r) / 2\\n\\n\\t\\tmId := (*hist.snapshots)[m].id\\n\\n\\t\\tif m == l && mId >= snapId || m > l && mId >= snapId && (*hist.snapshots)[m-1].id < snapId {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif mId < snapId {\\n\\t\\t\\tl = m + 1\\n\\t\\t} else {\\n\\t\\t\\tr = m\\n\\t\\t}\\n\\t}\\n\\n\\treturn (*hist.snapshots)[m].val\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Snapshot struct {\\n\\tid  int\\n\\tval int\\n}\\n\\ntype SnapshotsHistory struct {\\n\\tsnapshots *[]Snapshot\\n\\tcurrVal   int\\n}\\n\\ntype SnapshotArray struct {\\n\\tarray      *[]*SnapshotsHistory\\n\\tsnapshotId int\\n}\\n\\nfunc Constructor(length int) SnapshotArray {\\n\\tarr := make([]*SnapshotsHistory, length)\\n\\tres := SnapshotArray{&arr, 0}\\n\\n\\tfor i := 0; i < length; i++ {\\n\\t\\thist := make([]Snapshot, 0)\\n\\t\\t(*res.array)[i] = &SnapshotsHistory{&hist, 0}\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc (this *SnapshotArray) Set(index int, val int) {\\n\\thist := (*this.array)[index]\\n\\n\\tif this.snapshotId > 0 && (len(*hist.snapshots) == 0 || (*hist.snapshots)[len(*hist.snapshots)-1].id < this.snapshotId) {\\n\\t\\t*hist.snapshots = append(*hist.snapshots, Snapshot{this.snapshotId - 1, hist.currVal})\\n\\t}\\n\\n\\thist.currVal = val\\n}\\n\\nfunc (this *SnapshotArray) Snap() int {\\n\\tdefer func() {\\n\\t\\tthis.snapshotId++\\n\\t}()\\n\\treturn this.snapshotId\\n}\\n\\nfunc (this *SnapshotArray) Get(index int, snapId int) int {\\n\\thist := (*this.array)[index]\\n\\n\\tif len(*hist.snapshots) == 0 || (*hist.snapshots)[len(*hist.snapshots)-1].id < snapId {\\n\\t\\treturn hist.currVal\\n\\t}\\n\\n\\tl := 0\\n\\tr := len(*hist.snapshots)\\n\\tm := 0\\n\\n\\tfor l < r {\\n\\t\\tm = (l + r) / 2\\n\\n\\t\\tmId := (*hist.snapshots)[m].id\\n\\n\\t\\tif m == l && mId >= snapId || m > l && mId >= snapId && (*hist.snapshots)[m-1].id < snapId {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif mId < snapId {\\n\\t\\t\\tl = m + 1\\n\\t\\t} else {\\n\\t\\t\\tr = m\\n\\t\\t}\\n\\t}\\n\\n\\treturn (*hist.snapshots)[m].val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1219737,
                "title": "python-solution-binary-search",
                "content": "Time complexity\\n* set: O(1)\\n* snap: O(1)\\n* get: O(#set operations on the given index)\\n\\nSpace complexity O(#set operations)\\n```\\nimport bisect\\nimport collections\\n\\n\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.map = collections.defaultdict(list)\\n        self.cur_snap = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.map[index].append(((self.cur_snap, val)))\\n\\n    def snap(self) -> int:\\n        self.cur_snap += 1\\n        return self.cur_snap - 1\\n        \\n    def get(self, index: int, snap_id: int) -> int:\\n        snap_list = self.map.get(index, None)\\n        if snap_list is None:\\n            return 0\\n        index = bisect.bisect_right(snap_list, (snap_id, float(\\'inf\\'))) - 1\\n        return snap_list[index][1] if index >= 0 else 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nimport bisect\\nimport collections\\n\\n\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.map = collections.defaultdict(list)\\n        self.cur_snap = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.map[index].append(((self.cur_snap, val)))\\n\\n    def snap(self) -> int:\\n        self.cur_snap += 1\\n        return self.cur_snap - 1\\n        \\n    def get(self, index: int, snap_id: int) -> int:\\n        snap_list = self.map.get(index, None)\\n        if snap_list is None:\\n            return 0\\n        index = bisect.bisect_right(snap_list, (snap_id, float(\\'inf\\'))) - 1\\n        return snap_list[index][1] if index >= 0 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 795388,
                "title": "c-beats-100-no-built-in-data-structures-etc-simple-n-short",
                "content": "```\\n#define SZ  50000\\n\\nstruct v {\\n    int v, i;\\n    struct v *n;\\n};\\n\\ntypedef struct {\\n    struct v *vl[SZ];\\n    int i;\\n} SnapshotArray;\\n\\nSnapshotArray* snapshotArrayCreate(int length) {\\n    return calloc(1, sizeof(SnapshotArray));\\n}\\n\\nvoid snapshotArraySet(SnapshotArray* obj, int index, int val) {\\n    SnapshotArray *s = obj;\\n    struct v *v = s->vl[s->i], *p = NULL;\\n    for (; v && index > v->i ; p = v, v = v->n);\\n    if (v && index == v->i)\\n        v->v = val;    \\n    else {\\n        struct v *n = calloc(1, sizeof *n);\\n        n->v = val;\\n        n->i = index;    \\n        n->n = v;\\n        p ? p->n = n : (s->vl[s->i] = n);\\n    }\\n}\\n\\nint snapshotArraySnap(SnapshotArray* obj) {\\n    SnapshotArray *s = obj;\\n    struct v *h = s->vl[s->i++];\\n    for (struct v **p = &s->vl[s->i] ; h ; h = h->n) {\\n        (*p = calloc(1, sizeof **p))->v = h->v;\\n        (*p)->i = h->i;\\n        p = &(*p)->n;\\n    }\\n    return s->i - 1;\\n}\\n\\nint snapshotArrayGet(SnapshotArray* obj, int index, int snap_id) {\\n    SnapshotArray *s = obj;\\n    struct v *h;\\n    for (h = s->vl[snap_id] ; h && h->i < index ; h = h->n);\\n    return h && h->i == index ? h->v : 0;\\n}\\n\\nvoid snapshotArrayFree(SnapshotArray* obj) {\\n    free(obj);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define SZ  50000\\n\\nstruct v {\\n    int v, i;\\n    struct v *n;\\n};\\n\\ntypedef struct {\\n    struct v *vl[SZ];\\n    int i;\\n} SnapshotArray;\\n\\nSnapshotArray* snapshotArrayCreate(int length) {\\n    return calloc(1, sizeof(SnapshotArray));\\n}\\n\\nvoid snapshotArraySet(SnapshotArray* obj, int index, int val) {\\n    SnapshotArray *s = obj;\\n    struct v *v = s->vl[s->i], *p = NULL;\\n    for (; v && index > v->i ; p = v, v = v->n);\\n    if (v && index == v->i)\\n        v->v = val;    \\n    else {\\n        struct v *n = calloc(1, sizeof *n);\\n        n->v = val;\\n        n->i = index;    \\n        n->n = v;\\n        p ? p->n = n : (s->vl[s->i] = n);\\n    }\\n}\\n\\nint snapshotArraySnap(SnapshotArray* obj) {\\n    SnapshotArray *s = obj;\\n    struct v *h = s->vl[s->i++];\\n    for (struct v **p = &s->vl[s->i] ; h ; h = h->n) {\\n        (*p = calloc(1, sizeof **p))->v = h->v;\\n        (*p)->i = h->i;\\n        p = &(*p)->n;\\n    }\\n    return s->i - 1;\\n}\\n\\nint snapshotArrayGet(SnapshotArray* obj, int index, int snap_id) {\\n    SnapshotArray *s = obj;\\n    struct v *h;\\n    for (h = s->vl[snap_id] ; h && h->i < index ; h = h->n);\\n    return h && h->i == index ? h->v : 0;\\n}\\n\\nvoid snapshotArrayFree(SnapshotArray* obj) {\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 557904,
                "title": "go-85-binary-search",
                "content": "```go\\ntype SnapshotArray struct {\\n\\tmetadata [][][]int\\n\\tseq      int\\n}\\n\\nfunc Constructor(length int) SnapshotArray {\\n\\treturn SnapshotArray{\\n\\t\\tmetadata: make([][][]int, length),\\n\\t\\tseq:      0,\\n\\t}\\n}\\n\\nfunc (sa *SnapshotArray) Set(index int, val int)  {\\n\\tif len(sa.metadata[index]) == 0 || sa.metadata[index][len(sa.metadata[index]) - 1][0] != sa.seq {\\n\\t\\tsa.metadata[index] = append(sa.metadata[index], []int{sa.seq, val})\\n\\t\\treturn\\n\\t}\\n\\tsa.metadata[index][len(sa.metadata[index]) - 1][1] = val\\n}\\n\\nfunc (sa *SnapshotArray) Snap() int {\\n\\tsa.seq++\\n\\treturn sa.seq-1\\n}\\n\\nfunc (sa *SnapshotArray) Get(index int, snapID int) int {\\n\\treturn findLE(sa.metadata[index], snapID)\\n}\\n\\nfunc findLE(data [][]int, snapID int) int {\\n\\tif len(data) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tif data[0][0] > snapID {\\n\\t\\treturn 0\\n\\t}\\n\\tif data[len(data)-1][0] <= snapID {\\n\\t\\treturn data[len(data)-1][1]\\n\\t}\\n\\tl, r := 0, len(data)-1\\n\\tfor l <= r {\\n\\t\\tm := (l+r)>>1\\n\\t\\tif data[m][0] == snapID {\\n\\t\\t\\treturn data[m][1]\\n\\t\\t} else if data[m][0] < snapID {\\n\\t\\t\\tl = m + 1\\n\\t\\t} else {\\n\\t\\t\\tr = m - 1\\n\\t\\t}\\n\\t}\\n\\treturn data[r][1]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```go\\ntype SnapshotArray struct {\\n\\tmetadata [][][]int\\n\\tseq      int\\n}\\n\\nfunc Constructor(length int) SnapshotArray {\\n\\treturn SnapshotArray{\\n\\t\\tmetadata: make([][][]int, length),\\n\\t\\tseq:      0,\\n\\t}\\n}\\n\\nfunc (sa *SnapshotArray) Set(index int, val int)  {\\n\\tif len(sa.metadata[index]) == 0 || sa.metadata[index][len(sa.metadata[index]) - 1][0] != sa.seq {\\n\\t\\tsa.metadata[index] = append(sa.metadata[index], []int{sa.seq, val})\\n\\t\\treturn\\n\\t}\\n\\tsa.metadata[index][len(sa.metadata[index]) - 1][1] = val\\n}\\n\\nfunc (sa *SnapshotArray) Snap() int {\\n\\tsa.seq++\\n\\treturn sa.seq-1\\n}\\n\\nfunc (sa *SnapshotArray) Get(index int, snapID int) int {\\n\\treturn findLE(sa.metadata[index], snapID)\\n}\\n\\nfunc findLE(data [][]int, snapID int) int {\\n\\tif len(data) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tif data[0][0] > snapID {\\n\\t\\treturn 0\\n\\t}\\n\\tif data[len(data)-1][0] <= snapID {\\n\\t\\treturn data[len(data)-1][1]\\n\\t}\\n\\tl, r := 0, len(data)-1\\n\\tfor l <= r {\\n\\t\\tm := (l+r)>>1\\n\\t\\tif data[m][0] == snapID {\\n\\t\\t\\treturn data[m][1]\\n\\t\\t} else if data[m][0] < snapID {\\n\\t\\t\\tl = m + 1\\n\\t\\t} else {\\n\\t\\t\\tr = m - 1\\n\\t\\t}\\n\\t}\\n\\treturn data[r][1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 491858,
                "title": "python-copy-vs-incremental-store-binary-search",
                "content": "Suppose there will be `k` snapshot, for each snapshot `n` element\\n\\n# Copy: \\ntime `O(1)` space `O(kn)`, actual Runtime: 416 ms beats 85.74 %, Memory Usage: 37.4 MB\\n\\n```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.d=collections.defaultdict(dict)\\n        self.snap_id=0\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.d[self.snap_id][index]=val\\n\\n    def snap(self) -> int:\\n        self.d[self.snap_id+1]=self.d[self.snap_id].copy()\\n        self.snap_id+=1\\n        return self.snap_id-1\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        return self.d[snap_id].get(index, 0)\\n```\\n\\n# Incremental store (Binary search): \\n\\ntime `O(logn)` space `O(k*avg increamental number)`, actual Runtime: 652 ms beats 14.36 %, Memory Usage: 34.2 MB\\n\\n```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.d=collections.defaultdict(list)\\n        self.c={}\\n        self.snap_id=0\\n        self.l=length\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.c[index]=val\\n\\n    def snap(self) -> int:\\n        snap_id=self.snap_id\\n        for i, v in self.c.items():\\n            self.d[i].append((snap_id, v))\\n        \\n        self.snap_id+=1\\n        self.c={}\\n        return snap_id\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        if index not in self.d:\\n            return 0\\n        history=self.d[index]\\n        if snap_id<history[0][0]:\\n            return 0\\n        st, en=0, len(history)-1\\n        while st<=en:\\n            mid=int((st+en)/2)\\n            if(history[mid][0]==snap_id):\\n                return history[mid][1]\\n            elif(history[mid][0]<snap_id):\\n                st=mid+1\\n            else:\\n                en=mid-1\\n        #0,1,5\\n\\n        return history[st-1][1]\\n```\\n\\n# Another copy implementation: \\nShould be same time/space complexity with first copy implemtation, however cost 932 ms\\t37.4 MB. I bet may due to wierd memory locality implementation in Python vm.\\n```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.d={}\\n        self.c={}\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.c[index]=val\\n\\n    def snap(self) -> int:\\n        snap_id = len(self.d)\\n        self.d[snap_id]=self.c.copy()\\n        return snap_id\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        return self.d[snap_id].get(index, 0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.d=collections.defaultdict(dict)\\n        self.snap_id=0\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.d[self.snap_id][index]=val\\n\\n    def snap(self) -> int:\\n        self.d[self.snap_id+1]=self.d[self.snap_id].copy()\\n        self.snap_id+=1\\n        return self.snap_id-1\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        return self.d[snap_id].get(index, 0)\\n```\n```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.d=collections.defaultdict(list)\\n        self.c={}\\n        self.snap_id=0\\n        self.l=length\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.c[index]=val\\n\\n    def snap(self) -> int:\\n        snap_id=self.snap_id\\n        for i, v in self.c.items():\\n            self.d[i].append((snap_id, v))\\n        \\n        self.snap_id+=1\\n        self.c={}\\n        return snap_id\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        if index not in self.d:\\n            return 0\\n        history=self.d[index]\\n        if snap_id<history[0][0]:\\n            return 0\\n        st, en=0, len(history)-1\\n        while st<=en:\\n            mid=int((st+en)/2)\\n            if(history[mid][0]==snap_id):\\n                return history[mid][1]\\n            elif(history[mid][0]<snap_id):\\n                st=mid+1\\n            else:\\n                en=mid-1\\n        #0,1,5\\n\\n        return history[st-1][1]\\n```\n```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.d={}\\n        self.c={}\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.c[index]=val\\n\\n    def snap(self) -> int:\\n        snap_id = len(self.d)\\n        self.d[snap_id]=self.c.copy()\\n        return snap_id\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        return self.d[snap_id].get(index, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485953,
                "title": "runtime-faster-than-95-18-memory-usage-less-than-100-00-python3-hashmap",
                "content": "```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.data = {}\\n        self.ver = 0\\n        self.data[self.ver] = {}\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.data[self.ver][index] = val\\n\\n    def snap(self) -> int:\\n        self.ver += 1\\n        self.data[self.ver] = self.data[self.ver - 1].copy()\\n        return (self.ver - 1)\\n        \\n    def get(self, index: int, snap_id: int) -> int:\\n        # print(self.data)\\n        return self.data[snap_id].get(index, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.data = {}\\n        self.ver = 0\\n        self.data[self.ver] = {}\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.data[self.ver][index] = val\\n\\n    def snap(self) -> int:\\n        self.ver += 1\\n        self.data[self.ver] = self.data[self.ver - 1].copy()\\n        return (self.ver - 1)\\n        \\n    def get(self, index: int, snap_id: int) -> int:\\n        # print(self.data)\\n        return self.data[snap_id].get(index, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352672,
                "title": "java-binary-search-solution-without-treemap",
                "content": "Java Binary Search Solution without TreeMap\\n\\nTime Complexity: \\n*  SnapshotArray(int length): O(n)\\n*  set(int index, int val): O(1)\\n*  snap(): O(1)\\n*  get(int index, int snap_id): O(log(Set))\\n```\\nclass SnapshotArray {\\n    List<int[]>[] record;\\n    int sid;\\n\\n    public SnapshotArray(int length) {\\n        record = new List[length];\\n        sid = 0;\\n        for (int i = 0; i < length; i++) {\\n            record[i] = new ArrayList<>();\\n            record[i].add(new int[]{0, 0});\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        if (record[index].get(record[index].size() - 1)[0] == sid) {\\n            record[index].get(record[index].size() - 1)[1] = val;\\n        } else \\n            record[index].add(new int[]{sid, val});\\n    }\\n    \\n    public int snap() {\\n        return sid++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        int idx = Collections.binarySearch(record[index], new int[]{snap_id, 0}, \\n                                           (a, b) -> Integer.compare(a[0], b[0]));\\n        if (idx < 0) idx = - idx - 2;\\n        return record[index].get(idx)[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass SnapshotArray {\\n    List<int[]>[] record;\\n    int sid;\\n\\n    public SnapshotArray(int length) {\\n        record = new List[length];\\n        sid = 0;\\n        for (int i = 0; i < length; i++) {\\n            record[i] = new ArrayList<>();\\n            record[i].add(new int[]{0, 0});\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        if (record[index].get(record[index].size() - 1)[0] == sid) {\\n            record[index].get(record[index].size() - 1)[1] = val;\\n        } else \\n            record[index].add(new int[]{sid, val});\\n    }\\n    \\n    public int snap() {\\n        return sid++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        int idx = Collections.binarySearch(record[index], new int[]{snap_id, 0}, \\n                                           (a, b) -> Integer.compare(a[0], b[0]));\\n        if (idx < 0) idx = - idx - 2;\\n        return record[index].get(idx)[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351749,
                "title": "kotlin-simple-treemap-solution",
                "content": "```\\nimport java.util.*\\n\\nclass SnapshotArray(length: Int) {\\n\\n    private val snaps = Array(length) { TreeMap<Int, Int>() }\\n    private var snapId: Int = 0\\n\\n    fun set(index: Int, value: Int) {\\n        snaps[index][snapId] = value\\n    }\\n\\n    fun snap(): Int {\\n        return snapId++\\n    }\\n\\n    fun get(index: Int, snap_id: Int): Int {\\n        val versions = snaps[index]\\n        return versions.floorEntry(snap_id)?.value ?: 0\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*\\n\\nclass SnapshotArray(length: Int) {\\n\\n    private val snaps = Array(length) { TreeMap<Int, Int>() }\\n    private var snapId: Int = 0\\n\\n    fun set(index: Int, value: Int) {\\n        snaps[index][snapId] = value\\n    }\\n\\n    fun snap(): Int {\\n        return snapId++\\n    }\\n\\n    fun get(index: Int, snap_id: Int): Int {\\n        val versions = snaps[index]\\n        return versions.floorEntry(snap_id)?.value ?: 0\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351097,
                "title": "python-simple-solution",
                "content": "The thought is quite straight forward.\\n\\nFirst, we temporarily record the modifications made by `set`.\\nOnce we snapshot (`snap`), we save the modifications in the snapshots array and remove our temporary record.\\n\\nTo get the required value (`get`), we look into the specified snapshot first.\\nIf we could not find it, we look backward to get the latest modification of the required value.\\n\\nIn one word, we use time (looking backward) to save space.\\n\\n\\n```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self._snaps = []\\n        self._set = {}\\n        \\n    def set(self, index: int, val: int) -> None:\\n        self._set[index] = val\\n\\n    def snap(self) -> int:\\n        self._snaps += [self._set]\\n        self._set = {}\\n        return len(self._snaps) - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        for i in reversed(range(snap_id + 1)):\\n            if index in self._snaps[i]:\\n                return self._snaps[i][index]\\n        return 0\\n```\\n\\nResult: (2019/08/04)\\n- Runtime: 452 ms, faster than 100.00% of Python3 online submissions for Snapshot Array.\\n- Memory Usage: 36.7 MB, less than 100.00% of Python3 online submissions for Snapshot Array.\\n",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self._snaps = []\\n        self._set = {}\\n        \\n    def set(self, index: int, val: int) -> None:\\n        self._set[index] = val\\n\\n    def snap(self) -> int:\\n        self._snaps += [self._set]\\n        self._set = {}\\n        return len(self._snaps) - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        for i in reversed(range(snap_id + 1)):\\n            if index in self._snaps[i]:\\n                return self._snaps[i][index]\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006706,
                "title": "snapshot-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SnapshotArray {\\npublic:\\n    vector<vector<pair<int,int>>> vec;\\n    int num = 0;\\n    SnapshotArray(int length) {\\n        vec.resize(length);\\n    }\\n    \\n    void set(int index, int val) {\\n        if(vec[index].empty() || vec[index].back().second != num)\\n            vec[index].push_back({val,num});\\n        else\\n            vec[index].back().first = val;\\n    }\\n    \\n    int snap() {\\n        num++;\\n        return num - 1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        int n = vec[index].size();\\n        int low = 0,high = n - 1,mid;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            int y = vec[index][mid].second;\\n            if(y > snap_id)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;\\n\\n        }\\n        if(high == -1)\\n            return 0;\\n        return vec[index][high].first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n    vector<vector<pair<int,int>>> vec;\\n    int num = 0;\\n    SnapshotArray(int length) {\\n        vec.resize(length);\\n    }\\n    \\n    void set(int index, int val) {\\n        if(vec[index].empty() || vec[index].back().second != num)\\n            vec[index].push_back({val,num});\\n        else\\n            vec[index].back().first = val;\\n    }\\n    \\n    int snap() {\\n        num++;\\n        return num - 1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        int n = vec[index].size();\\n        int low = 0,high = n - 1,mid;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            int y = vec[index][mid].second;\\n            if(y > snap_id)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;\\n\\n        }\\n        if(high == -1)\\n            return 0;\\n        return vec[index][high].first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627272,
                "title": "python-beats-97-without-using-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.snapshots_idx = []\\n        self.snapshots = {}\\n        self.current = {} \\n        self.latest_idx = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.current[index] = val\\n        self.latest_idx = len(self.snapshots_idx)\\n\\n    def snap(self) -> int:\\n        if self.latest_idx == len(self.snapshots_idx):\\n            self.snapshots[self.latest_idx] = self.current.copy()\\n\\n        self.snapshots_idx.append(self.latest_idx)\\n        return len(self.snapshots_idx) - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        return self.snapshots[self.snapshots_idx[snap_id]][index] if index in self.snapshots[self.snapshots_idx[snap_id]] else 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.snapshots_idx = []\\n        self.snapshots = {}\\n        self.current = {} \\n        self.latest_idx = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.current[index] = val\\n        self.latest_idx = len(self.snapshots_idx)\\n\\n    def snap(self) -> int:\\n        if self.latest_idx == len(self.snapshots_idx):\\n            self.snapshots[self.latest_idx] = self.current.copy()\\n\\n        self.snapshots_idx.append(self.latest_idx)\\n        return len(self.snapshots_idx) - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        return self.snapshots[self.snapshots_idx[snap_id]][index] if index in self.snapshots[self.snapshots_idx[snap_id]] else 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626648,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SnapshotArray {\\n    List<Map<Integer, Integer>> list;\\n    \\n    public SnapshotArray(int length) {\\n        list = new ArrayList();\\n        list.add(new HashMap());\\n    }\\n    \\n    public void set(int index, int val) {\\n        int snapId = list.size() - 1;\\n        list.get(snapId).put(index, val);\\n    }\\n    \\n    public int snap() {\\n        list.add(new HashMap());\\n        return list.size() - 2;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        for (int snap = snap_id; snap >= 0; snap--) {\\n            if (list.get(snap).containsKey(index))\\n                return list.get(snap).get(index);\\n        }\\n        return 0;\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SnapshotArray {\\n    List<Map<Integer, Integer>> list;\\n    \\n    public SnapshotArray(int length) {\\n        list = new ArrayList();\\n        list.add(new HashMap());\\n    }\\n    \\n    public void set(int index, int val) {\\n        int snapId = list.size() - 1;\\n        list.get(snapId).put(index, val);\\n    }\\n    \\n    public int snap() {\\n        list.add(new HashMap());\\n        return list.size() - 2;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        for (int snap = snap_id; snap >= 0; snap--) {\\n            if (list.get(snap).containsKey(index))\\n                return list.get(snap).get(index);\\n        }\\n        return 0;\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625557,
                "title": "cpp-solution-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Code\\n```\\nclass SnapshotArray {\\npublic:\\n    unordered_map<int, map<int, int>> mp;\\n    int s = 0;\\n    SnapshotArray(int length) {\\n        for(int i = 0; i < length; i++){\\n            map<int, int> tmp;\\n            tmp[0] = 0;\\n            mp[i] = tmp;\\n        }\\n    }\\n\\n    void set(int index, int val) {\\n        mp[index][s] = val;\\n    }\\n    \\n    int snap() {\\n        return s++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto i = mp[index].upper_bound(snap_id); \\n        i--;\\n        return i -> second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n    unordered_map<int, map<int, int>> mp;\\n    int s = 0;\\n    SnapshotArray(int length) {\\n        for(int i = 0; i < length; i++){\\n            map<int, int> tmp;\\n            tmp[0] = 0;\\n            mp[i] = tmp;\\n        }\\n    }\\n\\n    void set(int index, int val) {\\n        mp[index][s] = val;\\n    }\\n    \\n    int snap() {\\n        return s++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto i = mp[index].upper_bound(snap_id); \\n        i--;\\n        return i -> second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625401,
                "title": "rust-time-complexity-o-log-s-space-complexity-o-n",
                "content": "# Intuition\\n\\nAt a first glance the problem can be solved by duplicating the array every time you get a snap, and then looking for a value in the corresponding snap.\\n\\nIn this case every operation (both reads and writes) would have a constant time complexity `O(1)`.\\n\\nThe problem with this naive approach is it consumes a lot of memory, becasue even though nothing can be changed between snaps you\\'d have to duplicate the array.\\n\\nThe memory complexity would be `O(N * S)` where the `N` is the size of the array, and the `S` is the number of snaps been taken.\\n\\nSo the **challenge** we face is how to store only the necessary changes, and at the same time keep the r/w operations fast enough.\\n\\nBecause each value changes individually, the natural approach is to store the stream of changes of **every individual item** as an array-like structure (`Vec` in Rust, or `Array` in Ruby).\\n\\nThe array as a whole can be represented as `Vec<Vec<(usize, i32)>>` where `usize` keeps `snap_id`, `i32` keeps the corresponding value.\\n\\n# Approach\\n\\nTo keep the corresponding `snap_id` for every snapshot value, you can either use the same structure (`Vec<(usize, i32)>`), or 2 parallel structures for `values` and `snap_ids`, having the same length.\\n\\nThat said, in our structure we have to keep:\\n- the snapshot values as `Vec<Vec<i32>>`\\n- the corresponding snapshot ids `Vec<Vec<usize>>`\\n- the current `snap_id: usize`\\n\\nExample:\\n\\n```rust\\n#[derive(Debug)]\\nstruct SnapshotArray {\\n    // the list of snapshot values for every array element\\n    // a new value is either overwrite the last snapshot\\n    // if the snap hasn\\'t changed, or add the new one\\n    values:   Vec<Vec<i32>>,\\n    // the list of snapshot ids for every individual value\\n    snap_ids: Vec<Vec<usize>>,\\n    // the list of \\n    snap_id:  usize,\\n}\\n```\\n\\nThe algorithms are simple\\n\\n- **Initialize** the structure with \\n    - `vec![vec![0i32]; lenght]`, keeping the first `0i32` for every element\\n    - `vec![vec![0usize; length]]` keeping the `0usize` snap_id for every snapshot value\\n    - `0usize` as the current `snap_id`\\n\\n- **Take the snap** by increasing `snap_id`\\n\\n- **Insert the value** by checking if the last snapshot in the `snap_ids[index]` equals the current `snap_id`. If yes, we overwrite the last value in `values[index]`, otherwise add new snapshot to the `values[index]` and new snap_id to the `snap_ids[index]`.\\n\\n- **Look for the value** requires to find the `snap`, not greater, than an interesting version, in the `snap_ids[index]`. Then take the value from `values[index][snap]`.\\n\\n# Complexity\\n- Time complexity:\\n\\n    - initialize `O(1)`\\n    - take a snap `O(1)`\\n    - insert value `O(1)` (either update or insert a value to the tail of the list / `Vec`)\\n    - find value `O(log S)` (binary search of the `snap_id` in the corresponding `snap_ids[index]`)\\n\\n- Space complexity:\\n\\n    `O(M)` where `M` is the total number of changes of elements between snaps.\\n\\n# Code\\n\\n```rust\\n#[derive(Debug)]\\nstruct SnapshotArray {\\n    values:   Vec<Vec<i32>>,\\n    snap_ids: Vec<Vec<usize>>,\\n    snap_id:  usize,\\n}\\n\\nimpl SnapshotArray {\\n    fn new(length: i32) -> Self {\\n        let length = length as usize;\\n        Self {\\n            values:   vec![vec![0]; length],\\n            snap_ids: vec![vec![0]; length],\\n            snap_id:  0,\\n        }        \\n    }\\n    \\n    fn set(&mut self, index: i32, val: i32) {\\n        let index = index as usize;\\n        let last_snap = self.snap_ids[index].len() - 1;\\n\\n        if self.snap_ids[index][last_snap] == self.snap_id {\\n            self.values[index][last_snap] = val;\\n        } else {\\n            self.snap_ids[index].push(self.snap_id);\\n            self.values[index].push(val);\\n        }\\n    }\\n    \\n    fn snap(&mut self) -> i32 {\\n        self.snap_id += 1;\\n        self.snap_id as i32 - 1\\n    }\\n    \\n    fn get(&self, index: i32, snap_id: i32) -> i32 {\\n        let (index, snap_id) = (index as usize, snap_id as usize);\\n\\n        match self.snap_ids[index].binary_search(&snap_id) {\\n            Err(snap) => self.values[index][snap-1],\\n            Ok(snap)  => self.values[index][snap],\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\n#[derive(Debug)]\\nstruct SnapshotArray {\\n    // the list of snapshot values for every array element\\n    // a new value is either overwrite the last snapshot\\n    // if the snap hasn\\'t changed, or add the new one\\n    values:   Vec<Vec<i32>>,\\n    // the list of snapshot ids for every individual value\\n    snap_ids: Vec<Vec<usize>>,\\n    // the list of \\n    snap_id:  usize,\\n}\\n```\n```rust\\n#[derive(Debug)]\\nstruct SnapshotArray {\\n    values:   Vec<Vec<i32>>,\\n    snap_ids: Vec<Vec<usize>>,\\n    snap_id:  usize,\\n}\\n\\nimpl SnapshotArray {\\n    fn new(length: i32) -> Self {\\n        let length = length as usize;\\n        Self {\\n            values:   vec![vec![0]; length],\\n            snap_ids: vec![vec![0]; length],\\n            snap_id:  0,\\n        }        \\n    }\\n    \\n    fn set(&mut self, index: i32, val: i32) {\\n        let index = index as usize;\\n        let last_snap = self.snap_ids[index].len() - 1;\\n\\n        if self.snap_ids[index][last_snap] == self.snap_id {\\n            self.values[index][last_snap] = val;\\n        } else {\\n            self.snap_ids[index].push(self.snap_id);\\n            self.values[index].push(val);\\n        }\\n    }\\n    \\n    fn snap(&mut self) -> i32 {\\n        self.snap_id += 1;\\n        self.snap_id as i32 - 1\\n    }\\n    \\n    fn get(&self, index: i32, snap_id: i32) -> i32 {\\n        let (index, snap_id) = (index as usize, snap_id as usize);\\n\\n        match self.snap_ids[index].binary_search(&snap_id) {\\n            Err(snap) => self.values[index][snap-1],\\n            Ok(snap)  => self.values[index][snap],\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3625294,
                "title": "simple-lists-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe only save the value (and the snap_id) on \\'Set\\'.\\nThen for \\'Get\\' we search the list in reverse order to find the right value for the given snap_id.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nHaving:\\nn - The length of the array.\\nm - The number of ```Set()``` calls.\\n- Time complexity: ```Get()```: O(m).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n + m).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class SnapshotArray {\\n    int m_snap_id;\\n    List<(int snap_id, int value)>[] values;\\n\\n    public SnapshotArray(int length) {\\n        m_snap_id = 0;\\n        values = new List<(int snap_id, int value)>[length];\\n        for (int i = 0; i < length; i++) {\\n            values[i] = new List<(int snap_id, int value)>();\\n        }\\n    }\\n    \\n    public void Set(int index, int val) {\\n        values[index].Add((m_snap_id, val));\\n    }\\n    \\n    public int Snap() {\\n        return m_snap_id++;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        var list = values[index];\\n        for (int i = list.Count - 1; i >= 0; i--) {\\n            if (list[i].snap_id <= snap_id) {\\n                return list[i].value;\\n            }\\n        }\\n        // Return the initial value.\\n        return 0;\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.Set(index,val);\\n * int param_2 = obj.Snap();\\n * int param_3 = obj.Get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```Set()```\n```Get()```\n```\\npublic class SnapshotArray {\\n    int m_snap_id;\\n    List<(int snap_id, int value)>[] values;\\n\\n    public SnapshotArray(int length) {\\n        m_snap_id = 0;\\n        values = new List<(int snap_id, int value)>[length];\\n        for (int i = 0; i < length; i++) {\\n            values[i] = new List<(int snap_id, int value)>();\\n        }\\n    }\\n    \\n    public void Set(int index, int val) {\\n        values[index].Add((m_snap_id, val));\\n    }\\n    \\n    public int Snap() {\\n        return m_snap_id++;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        var list = values[index];\\n        for (int i = list.Count - 1; i >= 0; i--) {\\n            if (list[i].snap_id <= snap_id) {\\n                return list[i].value;\\n            }\\n        }\\n        // Return the initial value.\\n        return 0;\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.Set(index,val);\\n * int param_2 = obj.Snap();\\n * int param_3 = obj.Get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624843,
                "title": "java-solution-for-snapshot-array-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to efficiently store the changes made to the array over time and retrieve the correct value based on the provided snap_id. By using TreeMap, we can efficiently retrieve the closest snap_id that is less than or equal to the given snap_id.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe SnapshotArray class is implemented using a list of TreeMap objects to store snapshots of the array. Each TreeMap represents the snapshots taken for a specific index in the array. The key in the TreeMap represents the snap_id, and the corresponding value represents the value of the element at that index for that particular snap_id.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the set operation is O(log n), where n is the number of snapshots taken so far. This is because we need to update the TreeMap for the specific index with the new snap_id and value.\\n\\nThe time complexity of the snap operation is O(1) since we only increment the snap_id.\\n\\nThe time complexity of the get operation is O(log n) as we need to find the closest snap_id less than or equal to the given snap_id using the floorEntry method of TreeMap.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the SnapshotArray class is O(n * m), where n is the length of the array and m is the number of snapshots taken so far. We store a TreeMap for each index in the array, and each TreeMap can have a maximum of m entries.\\n\\n# Code\\n```\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.TreeMap;\\n\\nclass SnapshotArray {\\n    private int snapId;\\n    private List<TreeMap<Integer, Integer>> snapshots;\\n\\n\\n    public SnapshotArray(int length) {\\n        snapId = 0;\\n        snapshots = new ArrayList<>();\\n        for (int i = 0; i < length; i++) \\n        {\\n            TreeMap<Integer, Integer> map = new TreeMap<>();\\n            map.put(0, 0);\\n            snapshots.add(map);\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        TreeMap<Integer, Integer> snapshot = snapshots.get(index);\\n        snapshot.put(snapId, val);\\n    }\\n    \\n    public int snap() {\\n         return snapId++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        TreeMap<Integer, Integer> snapshot = snapshots.get(index);\\n        Map.Entry<Integer, Integer> entry = snapshot.floorEntry(snap_id);\\n        return entry.getValue();\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.TreeMap;\\n\\nclass SnapshotArray {\\n    private int snapId;\\n    private List<TreeMap<Integer, Integer>> snapshots;\\n\\n\\n    public SnapshotArray(int length) {\\n        snapId = 0;\\n        snapshots = new ArrayList<>();\\n        for (int i = 0; i < length; i++) \\n        {\\n            TreeMap<Integer, Integer> map = new TreeMap<>();\\n            map.put(0, 0);\\n            snapshots.add(map);\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        TreeMap<Integer, Integer> snapshot = snapshots.get(index);\\n        snapshot.put(snapId, val);\\n    }\\n    \\n    public int snap() {\\n         return snapId++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        TreeMap<Integer, Integer> snapshot = snapshots.get(index);\\n        Map.Entry<Integer, Integer> entry = snapshot.floorEntry(snap_id);\\n        return entry.getValue();\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624491,
                "title": "python-short-and-clean",
                "content": "# Approach\\nTL;DR, Similar to [Editorial solution](https://leetcode.com/problems/snapshot-array/editorial/).\\n\\n# Complexity\\n- Time complexity:\\n    `__init__, set, snap`: $$O(1)$$\\n    `get`: $$O(log(snap\\\\_id))$$\\n\\n- Space complexity:\\n    `__init__, snap, get`: $$O(1)$$ after `n` calls.\\n    `set`: $$O(n)$$ after `n` calls.\\n\\n# Code\\n```python\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.id = 0\\n        self.history = defaultdict(lambda: [[self.id, 0]])\\n\\n    def set(self, index: int, val: int) -> None:\\n        h = self.history[index]\\n        if  self.id > h[-1][0]: h.append([self.id, val])\\n        else: h[-1][1] = val\\n\\n    def snap(self) -> int:\\n        self.id += 1\\n        return self.id - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        snap_index = bisect_right(self.history[index], snap_id, key=itemgetter(0))\\n        return self.history[index][snap_index - 1][1]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Binary Search",
                    "Design"
                ],
                "code": "```python\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.id = 0\\n        self.history = defaultdict(lambda: [[self.id, 0]])\\n\\n    def set(self, index: int, val: int) -> None:\\n        h = self.history[index]\\n        if  self.id > h[-1][0]: h.append([self.id, val])\\n        else: h[-1][1] = val\\n\\n    def snap(self) -> int:\\n        self.id += 1\\n        return self.id - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        snap_index = bisect_right(self.history[index], snap_id, key=itemgetter(0))\\n        return self.history[index][snap_index - 1][1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623525,
                "title": "daily-leetcoding-challenge-june-day-11",
                "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/snapshot-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/snapshot-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3169908,
                "title": "beats-100-java-code",
                "content": "# Java Code\\n```\\nclass SnapshotArray {\\n    int len;\\n    List<int[]> shot;\\n    int[] list;\\n    int snap_id;\\n    int maxlen;\\n    public SnapshotArray(int length) {\\n        list = new int[length];\\n        \\n        shot = new ArrayList<>();\\n        len = length;\\n        snap_id = 0;\\n        maxlen = 0;\\n    }\\n    \\n    public void set(int index, int val) {\\n        if (index <len) {\\n            list[index] = val;\\n            maxlen = Math.max(maxlen, index);\\n        }\\n    }\\n    \\n    public int snap() {\\n        shot.add(Arrays.copyOf(list, maxlen+1));\\n        snap_id++;\\n        return snap_id-1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        int[] shotArray = shot.get(snap_id);\\n        if (index >= shotArray.length)\\n            return 0;\\n        return shotArray[index];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Design"
                ],
                "code": "```\\nclass SnapshotArray {\\n    int len;\\n    List<int[]> shot;\\n    int[] list;\\n    int snap_id;\\n    int maxlen;\\n    public SnapshotArray(int length) {\\n        list = new int[length];\\n        \\n        shot = new ArrayList<>();\\n        len = length;\\n        snap_id = 0;\\n        maxlen = 0;\\n    }\\n    \\n    public void set(int index, int val) {\\n        if (index <len) {\\n            list[index] = val;\\n            maxlen = Math.max(maxlen, index);\\n        }\\n    }\\n    \\n    public int snap() {\\n        shot.add(Arrays.copyOf(list, maxlen+1));\\n        snap_id++;\\n        return snap_id-1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        int[] shotArray = shot.get(snap_id);\\n        if (index >= shotArray.length)\\n            return 0;\\n        return shotArray[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755296,
                "title": "databricks-go-solution-with-binary-search",
                "content": "# Intuition\\n\\nInitial intuition pushed me to use maps with version and a lookup in them, but then I understood that I missed a conditions of how we needed to look for elements with earlier snapshots.\\n\\nI tried to implement binary search on map of version, only to realise that I need to do it over an array of versions.\\n\\nAnd then I was sloppy not to update the element at the top of the array if the version didn\\'t change.\\n\\n# Approach\\n\\n## Structure\\n\\nAn array of arrays. Every array stores elemenet values at snapshots.\\n\\n## Get\\n\\nBinary search over that array, finding exact version or the first before it.\\n\\n# Complexity\\n- Time complexity:\\nSet is $$O(1)$$ and Get is $$O(LogN)$$ for binary search.\\n\\n- Space complexity:\\n$$O(Length * Snapshots Count)$$\\n\\n# Code\\n```\\ntype Elem struct {\\n    val int\\n    version int\\n}\\n\\ntype SnapshotArray struct {\\n    data [][]Elem\\n    version int\\n}\\n\\nfunc Constructor(length int) SnapshotArray {\\n    return SnapshotArray{ make([][]Elem, length), 0 }\\n}\\n\\nfunc (sa *SnapshotArray) Set(index int, val int)  {\\n    // Update value if we are at the same version\\n    if len(sa.data[index]) > 0 {\\n        arr := sa.data[index]\\n        if arr[len(arr)-1].version == sa.version {\\n            sa.data[index][len(arr)-1].val = val\\n            return\\n        }\\n    }\\n    // Add new record if we are at the higher version\\n    sa.data[index] = append(sa.data[index], Elem{val, sa.version})\\n}\\n\\nfunc (sa *SnapshotArray) Snap() int {\\n    old := sa.version\\n    sa.version++\\n    return int(old)\\n}\\n\\nfunc (sa *SnapshotArray) Get(index int, snap_id int) int {\\n    // Binary search for the exact snap_id or the first below it\\n    arr := sa.data[index]\\n    l, r := 0, len(arr) - 1\\n    for l <= r {\\n        m := (l + r) / 2\\n        if arr[m].version == snap_id {\\n            return arr[m].val\\n        } else if arr[m].version < snap_id {\\n            l, r = m + 1, r\\n        } else {\\n            l, r = l, m - 1\\n        }\\n    }\\n    if l - 1 <= len(arr) && l - 1 >= 0 {\\n        return arr[l-1].val\\n    }\\n    return 0\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\ntype Elem struct {\\n    val int\\n    version int\\n}\\n\\ntype SnapshotArray struct {\\n    data [][]Elem\\n    version int\\n}\\n\\nfunc Constructor(length int) SnapshotArray {\\n    return SnapshotArray{ make([][]Elem, length), 0 }\\n}\\n\\nfunc (sa *SnapshotArray) Set(index int, val int)  {\\n    // Update value if we are at the same version\\n    if len(sa.data[index]) > 0 {\\n        arr := sa.data[index]\\n        if arr[len(arr)-1].version == sa.version {\\n            sa.data[index][len(arr)-1].val = val\\n            return\\n        }\\n    }\\n    // Add new record if we are at the higher version\\n    sa.data[index] = append(sa.data[index], Elem{val, sa.version})\\n}\\n\\nfunc (sa *SnapshotArray) Snap() int {\\n    old := sa.version\\n    sa.version++\\n    return int(old)\\n}\\n\\nfunc (sa *SnapshotArray) Get(index int, snap_id int) int {\\n    // Binary search for the exact snap_id or the first below it\\n    arr := sa.data[index]\\n    l, r := 0, len(arr) - 1\\n    for l <= r {\\n        m := (l + r) / 2\\n        if arr[m].version == snap_id {\\n            return arr[m].val\\n        } else if arr[m].version < snap_id {\\n            l, r = m + 1, r\\n        } else {\\n            l, r = l, m - 1\\n        }\\n    }\\n    if l - 1 <= len(arr) && l - 1 >= 0 {\\n        return arr[l-1].val\\n    }\\n    return 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2378526,
                "title": "python-without-lists-only-hashmap-easy-to-understand-get-in-o-1",
                "content": "Most systems are read heavy and making assumption here we need fast `get()` compared to `snap()`\\n\\n```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.hashmap = {0 : defaultdict(int)}\\n        self.snapId = 0\\n        \\n    def set(self, index: int, val: int) -> None:\\n        self.hashmap[self.snapId][index] = val\\n\\n    def snap(self) -> int:\\n        self.snapId += 1\\n        self.hashmap[self.snapId] = defaultdict(int)\\n        \\n        for index, val in self.hashmap[self.snapId - 1].items():\\n            self.hashmap[self.snapId][index] = val\\n        \\n        return self.snapId - 1\\n        \\n    def get(self, index: int, snap_id: int) -> int:\\n        return self.hashmap[snap_id][index]\\n\\n```\\n`get()` in O(1)\\n`snap()` in O(n) worst case",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.hashmap = {0 : defaultdict(int)}\\n        self.snapId = 0\\n        \\n    def set(self, index: int, val: int) -> None:\\n        self.hashmap[self.snapId][index] = val\\n\\n    def snap(self) -> int:\\n        self.snapId += 1\\n        self.hashmap[self.snapId] = defaultdict(int)\\n        \\n        for index, val in self.hashmap[self.snapId - 1].items():\\n            self.hashmap[self.snapId][index] = val\\n        \\n        return self.snapId - 1\\n        \\n    def get(self, index: int, snap_id: int) -> int:\\n        return self.hashmap[snap_id][index]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2231506,
                "title": "simple-and-easy-to-understand-c-solution",
                "content": "```\\nclass SnapshotArray {\\npublic:\\n    int n;\\n    map<int, int> mp;\\n    vector<map<int, int>> v;\\n    SnapshotArray(int length) {\\n        n = -1;\\n    }\\n    \\n    void set(int index, int val) {\\n        mp[index] = val;\\n    }\\n    \\n    int snap() {\\n        n++;\\n        v.push_back(mp);\\n        return n;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        return v[snap_id][index];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n    int n;\\n    map<int, int> mp;\\n    vector<map<int, int>> v;\\n    SnapshotArray(int length) {\\n        n = -1;\\n    }\\n    \\n    void set(int index, int val) {\\n        mp[index] = val;\\n    }\\n    \\n    int snap() {\\n        n++;\\n        v.push_back(mp);\\n        return n;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        return v[snap_id][index];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156356,
                "title": "c-solution-using-hashmap",
                "content": "```\\nclass SnapshotArray {\\npublic:\\n    unordered_map<int,int> snapArray;  // it stores <index, val>\\n    unordered_map<int,unordered_map<int,int>> mp;  // it stores <id, map<index,val>>\\n    int id;\\n    \\n    SnapshotArray(int length) {\\n        id = 0;\\n    }\\n    \\n    void set(int index, int val) {\\n        snapArray[index] = val;\\n    }\\n    \\n    int snap() {\\n        mp[id] = snapArray;\\n        return id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        return mp[snap_id][index];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n    unordered_map<int,int> snapArray;  // it stores <index, val>\\n    unordered_map<int,unordered_map<int,int>> mp;  // it stores <id, map<index,val>>\\n    int id;\\n    \\n    SnapshotArray(int length) {\\n        id = 0;\\n    }\\n    \\n    void set(int index, int val) {\\n        snapArray[index] = val;\\n    }\\n    \\n    int snap() {\\n        mp[id] = snapArray;\\n        return id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        return mp[snap_id][index];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092346,
                "title": "python-easy-solution-store-only-the-updates-for-each-index-binary-search-o-logk",
                "content": "The idea is to store only the updates for each index, and when a `get` action is performanced, binary search on the index changes list.\\n\\nTime:\\nConstruct: O(n)\\nSet, Snap: O(1)\\nGet: O(logk) where k is number of updates for the index\\nSpace: O(n) + O(#of Set by snapshot)\\n\\n```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.array = [[(0,0)] for _ in range(length)]\\n        self.curSnapshot = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        snapId, _ = self.array[index][-1]\\n\\t\\t# Overwrite the number if within same snapshot, else add new value with latest Id\\n        if self.curSnapshot == snapId:\\n            self.array[index][-1] = (snapId, val)\\n        else:\\n            self.array[index].append((self.curSnapshot, val))\\n\\n    def snap(self) -> int:\\n\\t\\t# Increment the lastest snapshot Id\\n        self.curSnapshot += 1\\n        return self.curSnapshot - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n\\t\\t# Only need to search on the index updates\\n        ss = self.array[index]\\n\\t\\t# Binary search for the latest change by snapshot id\\n        i = bisect_left(ss, snap_id, key = lambda x: x[0])\\n\\t\\t# If the asked snapshot happened after latest snapshot of this index, take latest change\\n        if i == len(ss):\\n            return ss[-1][1]\\n\\t\\t# If the found index is that snapshot, return the value, or return last value\\n        return ss[i][1] if ss[i][0] == snap_id else ss[i-1][1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.array = [[(0,0)] for _ in range(length)]\\n        self.curSnapshot = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        snapId, _ = self.array[index][-1]\\n\\t\\t# Overwrite the number if within same snapshot, else add new value with latest Id\\n        if self.curSnapshot == snapId:\\n            self.array[index][-1] = (snapId, val)\\n        else:\\n            self.array[index].append((self.curSnapshot, val))\\n\\n    def snap(self) -> int:\\n\\t\\t# Increment the lastest snapshot Id\\n        self.curSnapshot += 1\\n        return self.curSnapshot - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n\\t\\t# Only need to search on the index updates\\n        ss = self.array[index]\\n\\t\\t# Binary search for the latest change by snapshot id\\n        i = bisect_left(ss, snap_id, key = lambda x: x[0])\\n\\t\\t# If the asked snapshot happened after latest snapshot of this index, take latest change\\n        if i == len(ss):\\n            return ss[-1][1]\\n\\t\\t# If the found index is that snapshot, return the value, or return last value\\n        return ss[i][1] if ss[i][0] == snap_id else ss[i-1][1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062665,
                "title": "c-solution-hash-map-simple",
                "content": "```\\nclass SnapshotArray {\\n    vector<unordered_map<int, int>> data;\\npublic:\\n    SnapshotArray(int length) {\\n        data.push_back(unordered_map<int, int>());\\n    }\\n    \\n    void set(int index, int val) {\\n        data[data.size() - 1][index] = val;\\n    }\\n    \\n    int snap() {\\n        int current = data.size() - 1;\\n        data.push_back(data[current]);\\n        return current;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if (data[snap_id].find(index) == data[snap_id].end()) {\\n            return 0;\\n        }\\n        return data[snap_id][index];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n    vector<unordered_map<int, int>> data;\\npublic:\\n    SnapshotArray(int length) {\\n        data.push_back(unordered_map<int, int>());\\n    }\\n    \\n    void set(int index, int val) {\\n        data[data.size() - 1][index] = val;\\n    }\\n    \\n    int snap() {\\n        int current = data.size() - 1;\\n        data.push_back(data[current]);\\n        return current;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if (data[snap_id].find(index) == data[snap_id].end()) {\\n            return 0;\\n        }\\n        return data[snap_id][index];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990478,
                "title": "100-0ms-treemap-of-array-easy-simple-fast-concise",
                "content": "```\\nclass SnapshotArray {\\n    TreeMap<Integer, Integer>[] A;\\n    int snap_id = 0;\\n    public SnapshotArray(int length) {\\n        A = new TreeMap[length];\\n        for (int i = 0; i < length; i++) {\\n            A[i] = new TreeMap<Integer, Integer>();\\n            A[i].put(0, 0);\\n        }\\n    }\\n\\n    public void set(int index, int val) {\\n        A[index].put(snap_id, val);\\n    }\\n\\n    public int snap() {\\n        return snap_id++;\\n    }\\n\\n    public int get(int index, int snap_id) {\\n        return A[index].floorEntry(snap_id).getValue();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Go",
                    "PHP"
                ],
                "code": "```\\nclass SnapshotArray {\\n    TreeMap<Integer, Integer>[] A;\\n    int snap_id = 0;\\n    public SnapshotArray(int length) {\\n        A = new TreeMap[length];\\n        for (int i = 0; i < length; i++) {\\n            A[i] = new TreeMap<Integer, Integer>();\\n            A[i].put(0, 0);\\n        }\\n    }\\n\\n    public void set(int index, int val) {\\n        A[index].put(snap_id, val);\\n    }\\n\\n    public int snap() {\\n        return snap_id++;\\n    }\\n\\n    public int get(int index, int snap_id) {\\n        return A[index].floorEntry(snap_id).getValue();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983530,
                "title": "c-binary-search-easy-to-understand-solution",
                "content": "```\\n/* \\n    Time:\\n            O(1) | set\\n            O(1) | snap\\n            O(logn) | get, where n is number of snaps taken on that index\\n    Space: O(n*i), where i is length of array n is maximum number of snaps taken\\n    Tag: Binary Search (Upper Bound)\\n    Difficulty: M\\n*/\\n\\nclass SnapshotArray {\\n    vector<vector<pair<int, int>>>updates;\\n    int curSnap;\\n\\npublic:\\n    SnapshotArray(int length) {\\n        updates.resize(length);\\n        curSnap = 0;\\n    }\\n\\n    void set(int index, int val) {\\n        if (!updates[index].empty() && updates[index].back().first == curSnap)\\n            updates[index].back().second = val;\\n        else\\n            updates[index].push_back({curSnap, val});\\n    }\\n\\n    int snap() {\\n        curSnap++;\\n        return curSnap - 1;\\n    }\\n\\n    int get(int index, int snap_id) {\\n        int idx = upper_bound(updates[index].begin(), updates[index].end(), make_pair(snap_id,INT_MAX)) - updates[index].begin();\\n        if (idx == 0) return 0;\\n        return updates[index][idx - 1].second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n/* \\n    Time:\\n            O(1) | set\\n            O(1) | snap\\n            O(logn) | get, where n is number of snaps taken on that index\\n    Space: O(n*i), where i is length of array n is maximum number of snaps taken\\n    Tag: Binary Search (Upper Bound)\\n    Difficulty: M\\n*/\\n\\nclass SnapshotArray {\\n    vector<vector<pair<int, int>>>updates;\\n    int curSnap;\\n\\npublic:\\n    SnapshotArray(int length) {\\n        updates.resize(length);\\n        curSnap = 0;\\n    }\\n\\n    void set(int index, int val) {\\n        if (!updates[index].empty() && updates[index].back().first == curSnap)\\n            updates[index].back().second = val;\\n        else\\n            updates[index].push_back({curSnap, val});\\n    }\\n\\n    int snap() {\\n        curSnap++;\\n        return curSnap - 1;\\n    }\\n\\n    int get(int index, int snap_id) {\\n        int idx = upper_bound(updates[index].begin(), updates[index].end(), make_pair(snap_id,INT_MAX)) - updates[index].begin();\\n        if (idx == 0) return 0;\\n        return updates[index][idx - 1].second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882721,
                "title": "most-optimal-solution-using-binary-search",
                "content": "```\\nclass SnapshotArray {\\n    vector<vector<pair<int, int>>> nums;\\n    int snapId = 0;\\npublic:\\n    SnapshotArray(int length) {\\n        nums = vector<vector<pair<int, int>>>(length); //snapId, val\\n        for(int i=0; i<length; i++){\\n            nums[i].push_back({0, 0});\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        auto itr = nums[index].back();\\n        if(itr.first == snapId){\\n            nums[index].back().second = val;\\n        }else{\\n            nums[index].push_back({snapId, val});\\n        }\\n    }\\n    \\n    int snap() {\\n        snapId++;\\n        return (snapId - 1);\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto itr = lower_bound(nums[index].begin(), nums[index].end(), make_pair(snap_id, INT_MIN));\\n        if(itr == nums[index].end() || itr->first > snap_id){\\n            itr--;\\n        }\\n        return itr->second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass SnapshotArray {\\n    vector<vector<pair<int, int>>> nums;\\n    int snapId = 0;\\npublic:\\n    SnapshotArray(int length) {\\n        nums = vector<vector<pair<int, int>>>(length); //snapId, val\\n        for(int i=0; i<length; i++){\\n            nums[i].push_back({0, 0});\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        auto itr = nums[index].back();\\n        if(itr.first == snapId){\\n            nums[index].back().second = val;\\n        }else{\\n            nums[index].push_back({snapId, val});\\n        }\\n    }\\n    \\n    int snap() {\\n        snapId++;\\n        return (snapId - 1);\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto itr = lower_bound(nums[index].begin(), nums[index].end(), make_pair(snap_id, INT_MIN));\\n        if(itr == nums[index].end() || itr->first > snap_id){\\n            itr--;\\n        }\\n        return itr->second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763803,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number} length\\n */\\nvar SnapshotArray = function(length) {\\n    this.snaps = [...Array(length)].map(()=>new Map());\\n    this.snapId = 0;\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} val\\n * @return {void}\\n */\\nSnapshotArray.prototype.set = function(index, val) {\\n    this.snaps[index].set(this.snapId, val);\\n};\\n\\n/**\\n * @return {number}\\n */\\nSnapshotArray.prototype.snap = function() {\\n    return this.snapId++;\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} snap_id\\n * @return {number}\\n */\\nSnapshotArray.prototype.get = function(index, snap_id) {\\n    while(snap_id >= 0) {\\n        if(this.snaps[index].has(snap_id)) {\\n            return this.snaps[index].get(snap_id);\\n        }\\n        snap_id--;\\n    }\\n    return 0;\\n};\\n\\n/** \\n * Your SnapshotArray object will be instantiated and called as such:\\n * var obj = new SnapshotArray(length)\\n * obj.set(index,val)\\n * var param_2 = obj.snap()\\n * var param_3 = obj.get(index,snap_id)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} length\\n */\\nvar SnapshotArray = function(length) {\\n    this.snaps = [...Array(length)].map(()=>new Map());\\n    this.snapId = 0;\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} val\\n * @return {void}\\n */\\nSnapshotArray.prototype.set = function(index, val) {\\n    this.snaps[index].set(this.snapId, val);\\n};\\n\\n/**\\n * @return {number}\\n */\\nSnapshotArray.prototype.snap = function() {\\n    return this.snapId++;\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} snap_id\\n * @return {number}\\n */\\nSnapshotArray.prototype.get = function(index, snap_id) {\\n    while(snap_id >= 0) {\\n        if(this.snaps[index].has(snap_id)) {\\n            return this.snaps[index].get(snap_id);\\n        }\\n        snap_id--;\\n    }\\n    return 0;\\n};\\n\\n/** \\n * Your SnapshotArray object will be instantiated and called as such:\\n * var obj = new SnapshotArray(length)\\n * obj.set(index,val)\\n * var param_2 = obj.snap()\\n * var param_3 = obj.get(index,snap_id)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1746079,
                "title": "nested-map-java-solution-easy-to-understand",
                "content": "```\\nclass SnapshotArray {\\n    Map<Integer,Map<Integer,Integer>> map =  new HashMap<>();\\n    int cnt =0;\\n    public SnapshotArray(int length) {\\n        \\n    }\\n    \\n    public void set(int index, int val) {\\n        map.putIfAbsent(cnt,new HashMap<>());\\n        map.get(cnt).put(index,val);\\n    }\\n    \\n    public int snap() {\\n        cnt++;\\n        return cnt-1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        for(int i=snap_id;i>=0;i--){\\n             if(map.containsKey(i) && map.get(i).containsKey(index))\\n                 return map.get(i).get(index);\\n        }\\n        return 0;\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n    Map<Integer,Map<Integer,Integer>> map =  new HashMap<>();\\n    int cnt =0;\\n    public SnapshotArray(int length) {\\n        \\n    }\\n    \\n    public void set(int index, int val) {\\n        map.putIfAbsent(cnt,new HashMap<>());\\n        map.get(cnt).put(index,val);\\n    }\\n    \\n    public int snap() {\\n        cnt++;\\n        return cnt-1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        for(int i=snap_id;i>=0;i--){\\n             if(map.containsKey(i) && map.get(i).containsKey(index))\\n                 return map.get(i).get(index);\\n        }\\n        return 0;\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683673,
                "title": "java-solution-with-treemap-snap-o-1-get-set-o-lgn",
                "content": "```\\nclass SnapshotArray {\\n    int snapshotid;\\n    TreeMap[] arr;\\n    public SnapshotArray(int length) {\\n        snapshotid = 0;\\n        arr = new TreeMap[length];\\n        for(int i = 0; i < length; i++)\\n        {\\n            arr[i] = new TreeMap<Integer, Integer>();\\n        }\\n    }\\n    \\n    public void set(int i, int val) {\\n        TreeMap<Integer, Integer> map = (TreeMap<Integer, Integer>)arr[i];\\n        arr[i].put(snapshotid, val);\\n    }\\n    \\n    public int snap() {\\n        return snapshotid++;\\n    }\\n    \\n    public int get(int i, int snap_id) {\\n        TreeMap<Integer, Integer> map = (TreeMap<Integer, Integer>)arr[i];\\n        Integer target = map.floorKey(snap_id);\\n        if(target==null)return 0;\\n        return map.get(target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n    int snapshotid;\\n    TreeMap[] arr;\\n    public SnapshotArray(int length) {\\n        snapshotid = 0;\\n        arr = new TreeMap[length];\\n        for(int i = 0; i < length; i++)\\n        {\\n            arr[i] = new TreeMap<Integer, Integer>();\\n        }\\n    }\\n    \\n    public void set(int i, int val) {\\n        TreeMap<Integer, Integer> map = (TreeMap<Integer, Integer>)arr[i];\\n        arr[i].put(snapshotid, val);\\n    }\\n    \\n    public int snap() {\\n        return snapshotid++;\\n    }\\n    \\n    public int get(int i, int snap_id) {\\n        TreeMap<Integer, Integer> map = (TreeMap<Integer, Integer>)arr[i];\\n        Integer target = map.floorKey(snap_id);\\n        if(target==null)return 0;\\n        return map.get(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668471,
                "title": "python-faster-than-93-solution-very-easy-to-understand",
                "content": "The idea is to keep a dictionary of the (snapID: value) at each index, such that we can record the history of each index, such as:\\n\\n`self.collection[0] -> {0: 3, 5: 6, 6: 7}` tells us between `snap_id`s 0 and 4, `array[0]` had a value of 3. At `snap_id` 5, it had a value of 6, and so on and so forth...\\n\\n```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.collection = [{0: 0} for i in range(length)]\\n        self.currID = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.collection[index][self.currID] = val\\n        \\n    def snap(self) -> int:\\n        self.currID += 1\\n        return self.currID - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        dct = self.collection[index]\\n        while snap_id not in dct:\\n            snap_id -= 1\\n        return dct[snap_id]\\n\\n\\n# Your SnapshotArray object will be instantiated and called as such:\\n# obj = SnapshotArray(length)\\n# obj.set(index,val)\\n# param_2 = obj.snap()\\n# param_3 = obj.get(index,snap_id)",
                "solutionTags": [],
                "code": "The idea is to keep a dictionary of the (snapID: value) at each index, such that we can record the history of each index, such as:\\n\\n`self.collection[0] -> {0: 3, 5: 6, 6: 7}` tells us between `snap_id`s 0 and 4, `array[0]` had a value of 3. At `snap_id` 5, it had a value of 6, and so on and so forth...\\n\\n```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.collection = [{0: 0} for i in range(length)]\\n        self.currID = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.collection[index][self.currID] = val\\n        \\n    def snap(self) -> int:\\n        self.currID += 1\\n        return self.currID - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        dct = self.collection[index]\\n        while snap_id not in dct:\\n            snap_id -= 1\\n        return dct[snap_id]\\n\\n\\n# Your SnapshotArray object will be instantiated and called as such:\\n# obj = SnapshotArray(length)\\n# obj.set(index,val)\\n# param_2 = obj.snap()\\n# param_3 = obj.get(index,snap_id)",
                "codeTag": "Java"
            },
            {
                "id": 1606278,
                "title": "java-no-treemap-no-binary-search",
                "content": "I don\\'t like fancy method, because most of the time we might forget when we are being asked this question in an interview.\\nSo, this one is easy to understand and bring up into interview if we met this question.\\n\\n```\\nclass SnapshotArray {\\n    \\n    // Use a list to record down every snapshot information\\n    List<HashMap<Integer, Integer>> snapshot = new ArrayList<>();\\n    \\n    // Use a map to recode down the current data\\n    // and this map only be stored when snap() function is trigger\\n    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n    \\n    // Used to create a corresponding size array\\n    int [] current;\\n\\n    public SnapshotArray(int length) {\\n        this.current = new int[length];\\n    }\\n    \\n    // The current data will be saved into snapshot if and only if the snap() is being called\\n    public void set(int index, int val) {\\n        map.put(index, val);\\n    }\\n    \\n    // Store the map into snapshot list\\n    public int snap() {\\n        \\n        snapshot.add(new HashMap<>(map));\\n        \\n        return snapshot.size() - 1;\\n    }\\n    \\n    // Get the data based on the index and the snap_id\\n    /* For example, \\n       [\"SnapshotArray\",\"set\",\"snap\",\"set\",\"get\",\"snap\",\"get\"]\\n       [[3],[0,5],[],[0,6],[0,0],[],[0,1]]\\n       \\n       Here take 2 times of snap(), so \\n                       (index, value)\\n       snap_id = 0 --> (0, 5)\\'s data  --> and then get it\\'s index\\'s value --> return 5, else return 0\\n       snap_id = 1 --> (0, 6)\\'s data  --> and then get it\\'s index\\'s value --> return 6, else return 0\\n    */\\n    public int get(int index, int snap_id) {\\n        return snapshot.get(snap_id).getOrDefault(index, 0);\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n    \\n    // Use a list to record down every snapshot information\\n    List<HashMap<Integer, Integer>> snapshot = new ArrayList<>();\\n    \\n    // Use a map to recode down the current data\\n    // and this map only be stored when snap() function is trigger\\n    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n    \\n    // Used to create a corresponding size array\\n    int [] current;\\n\\n    public SnapshotArray(int length) {\\n        this.current = new int[length];\\n    }\\n    \\n    // The current data will be saved into snapshot if and only if the snap() is being called\\n    public void set(int index, int val) {\\n        map.put(index, val);\\n    }\\n    \\n    // Store the map into snapshot list\\n    public int snap() {\\n        \\n        snapshot.add(new HashMap<>(map));\\n        \\n        return snapshot.size() - 1;\\n    }\\n    \\n    // Get the data based on the index and the snap_id\\n    /* For example, \\n       [\"SnapshotArray\",\"set\",\"snap\",\"set\",\"get\",\"snap\",\"get\"]\\n       [[3],[0,5],[],[0,6],[0,0],[],[0,1]]\\n       \\n       Here take 2 times of snap(), so \\n                       (index, value)\\n       snap_id = 0 --> (0, 5)\\'s data  --> and then get it\\'s index\\'s value --> return 5, else return 0\\n       snap_id = 1 --> (0, 6)\\'s data  --> and then get it\\'s index\\'s value --> return 6, else return 0\\n    */\\n    public int get(int index, int snap_id) {\\n        return snapshot.get(snap_id).getOrDefault(index, 0);\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596413,
                "title": "java-list-map-only-explained-faster-than-97",
                "content": "// There are multiple solutions where we have a List<Map> and a Map which we either clear() or initialize again when snap() happens. Both of these operations take O(N) time (clear() takes O(N) time and for new HashMap<>(), Garbage collection takes O(N) time)\\n\\n// I am just having a List<Map> which will have an empty Map initialized initially (at snapId 0). This save our work of re-initializing the Map which has overhead.\\n\\n// Each Map inside the List at index \\'i\\' corresponds the snapshot with snap_id \\'i\\'\\n\\n// TC : SnapshotArray() -> O(1), set() -> O(1), snap -> O(1), get -> O(snap_id)\\n// SC : O(N) -> List\\n\\n```\\nclass SnapshotArray {\\n\\n    List<Map<Integer, Integer>> snapshot;\\n    \\n    int snapId;\\n    \\n    public SnapshotArray(int length) {\\n        snapId = 0;\\n        snapshot = new ArrayList<>(length);\\n        snapshot.add(new HashMap<>());\\n    }\\n    \\n    public void set(int index, int val) {\\n        snapshot.get(snapId).put(index, val);\\n    }\\n    \\n    public int snap() {\\n        snapshot.add(new HashMap<>());\\n        return snapId++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        for(int i = snap_id; i >= 0; i--) {\\n            if(snapshot.get(i).containsKey(index)) {\\n                return snapshot.get(i).get(index);\\n            }\\n        }\\n        return 0;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n\\n    List<Map<Integer, Integer>> snapshot;\\n    \\n    int snapId;\\n    \\n    public SnapshotArray(int length) {\\n        snapId = 0;\\n        snapshot = new ArrayList<>(length);\\n        snapshot.add(new HashMap<>());\\n    }\\n    \\n    public void set(int index, int val) {\\n        snapshot.get(snapId).put(index, val);\\n    }\\n    \\n    public int snap() {\\n        snapshot.add(new HashMap<>());\\n        return snapId++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        for(int i = snap_id; i >= 0; i--) {\\n            if(snapshot.get(i).containsKey(index)) {\\n                return snapshot.get(i).get(index);\\n            }\\n        }\\n        return 0;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575251,
                "title": "c-short-solution-using-maps",
                "content": "OG solution: https://leetcode.com/problems/snapshot-array/discuss/350656/C%2B%2B-Hash-Map-%2B-Vector\\nSo idea behind the solution is to store values of various instances by their snap ids. Now, we do not need to store value of every index at every snap, as maybe at that snap its value had changed or hasnt changed. \\nWe make a unordered_map that will map the indexes to map of snap ids and its value. We are using map here because we need to implement upper_bound function later.\\nNow coming back to the point, why we dont need to store value of every index at every snap, because consider we have a list of 3 elements, we change element 1 and take a snap (snap_id=0). Then we change element 2 and take a snap (snap_id=1). Notice that element has never changed so making the copy of its value at every snap is waste of memory. \\nHence, we currently in map we have { 0: [], 1:[1 : value], 2:[2 : value]}\\nIf we need to find the value of element 1 at snap 2, we first search for the instance that is just greater than 2. In the map with key 1, you can notice upperbound(2) = map.end(). Hence now choose the previous snap (that might be less than or equal to 2 (here it is 1) and return its value = 1. Correct cause, if element 1 never changed between taking snap 1 and 2, the value at snap2  =  value at snap 1.\\n```\\nclass SnapshotArray {\\n    unordered_map<int, map<int, int>> A;\\n    int snap_no = 0;\\npublic:\\n    SnapshotArray(int length) {\\n        \\n    }\\n    \\n    void set(int index, int val) {\\n        A[index][snap_no] = val;\\n    }\\n    \\n    int snap() {\\n        return snap_no++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it = A[index].upper_bound(snap_id); //returns value (snap id) from MAP greater than snap_id\\n        return it==begin(A[index])?0:prev(it)->second; //If no value greater, i.e. iterator still pointing at start = return 0, else return the prev of upperbound-> that can equal or less than snap_id we want ->second (value)\\n    }\\n};\\n```\\nTime complexity: O(mlogn), n = number of call made to get\\nSpace complexity: O(m), m = number of calls made to set",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass SnapshotArray {\\n    unordered_map<int, map<int, int>> A;\\n    int snap_no = 0;\\npublic:\\n    SnapshotArray(int length) {\\n        \\n    }\\n    \\n    void set(int index, int val) {\\n        A[index][snap_no] = val;\\n    }\\n    \\n    int snap() {\\n        return snap_no++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it = A[index].upper_bound(snap_id); //returns value (snap id) from MAP greater than snap_id\\n        return it==begin(A[index])?0:prev(it)->second; //If no value greater, i.e. iterator still pointing at start = return 0, else return the prev of upperbound-> that can equal or less than snap_id we want ->second (value)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440254,
                "title": "simple-java-solution-with-one-map",
                "content": "```\\nclass SnapshotArray {\\n    private int snapId = 0;\\n    Map<String, Integer> array = new HashMap<>();\\n    private int len = 0;\\n    public SnapshotArray(int length) {\\n        this.len = length;\\n    }\\n    \\n    public void set(int index, int val) {\\n        if (index < len) {\\n            array.put(snapId+\":\"+index, val);\\n        }\\n    }\\n    \\n    public int snap() {\\n        return snapId++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        for (int i = snap_id; i >=0; i--) {\\n            String key = i+\":\"+index;\\n            if (array.containsKey(key)) {\\n                return array.get(key);\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n    private int snapId = 0;\\n    Map<String, Integer> array = new HashMap<>();\\n    private int len = 0;\\n    public SnapshotArray(int length) {\\n        this.len = length;\\n    }\\n    \\n    public void set(int index, int val) {\\n        if (index < len) {\\n            array.put(snapId+\":\"+index, val);\\n        }\\n    }\\n    \\n    public int snap() {\\n        return snapId++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        for (int i = snap_id; i >=0; i--) {\\n            String key = i+\":\"+index;\\n            if (array.containsKey(key)) {\\n                return array.get(key);\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437703,
                "title": "python-easy-solution-with-hashmap-and-binary-search",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.length = length\\n        self.snapshot = defaultdict(list)\\n        self.curr_snapshot_id = 0\\n        \\n\\n    def set(self, index: int, val: int) -> None:\\n        if index in self.snapshot:\\n            last =  self.snapshot[index][-1]\\n            if last[0] == self.curr_snapshot_id:\\n                self.snapshot[index][-1] = (self.curr_snapshot_id, val)\\n                return \\n        self.snapshot[index].append((self.curr_snapshot_id, val))\\n        return \\n                \\n        \\n\\n    def snap(self) -> int:\\n        self.curr_snapshot_id += 1\\n        return self.curr_snapshot_id-1\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n\\n        if index not in self.snapshot:\\n            return 0\\n        \\n        arr = self.snapshot[index]\\n        i = self.getIdx(arr, snap_id)\\n        \\n        if i == -1:\\n            return 0\\n        \\n        return arr[i][1]\\n        \\n    def getIdx(self, arr, snap_id):\\n        if len(arr) == 0:\\n            return -1\\n        \\n        start = 0\\n        end = len(arr)-1\\n        \\n        while start <= end:\\n            mid = (start+end)//2\\n            \\n            if arr[mid][0] == snap_id:\\n                return mid\\n            elif arr[mid][0] > snap_id:\\n                end = mid -1\\n            else:\\n                start = mid + 1\\n                \\n        return end\\n        \\n\\n\\n# Your SnapshotArray object will be instantiated and called as such:\\n# obj = SnapshotArray(length)\\n# obj.set(index,val)\\n# param_2 = obj.snap()\\n# param_3 = obj.get(index,snap_id)\\n\\n\\'\\'\\'\\n\\n\\'\\'\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.length = length\\n        self.snapshot = defaultdict(list)\\n        self.curr_snapshot_id = 0\\n        \\n\\n    def set(self, index: int, val: int) -> None:\\n        if index in self.snapshot:\\n            last =  self.snapshot[index][-1]\\n            if last[0] == self.curr_snapshot_id:\\n                self.snapshot[index][-1] = (self.curr_snapshot_id, val)\\n                return \\n        self.snapshot[index].append((self.curr_snapshot_id, val))\\n        return \\n                \\n        \\n\\n    def snap(self) -> int:\\n        self.curr_snapshot_id += 1\\n        return self.curr_snapshot_id-1\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n\\n        if index not in self.snapshot:\\n            return 0\\n        \\n        arr = self.snapshot[index]\\n        i = self.getIdx(arr, snap_id)\\n        \\n        if i == -1:\\n            return 0\\n        \\n        return arr[i][1]\\n        \\n    def getIdx(self, arr, snap_id):\\n        if len(arr) == 0:\\n            return -1\\n        \\n        start = 0\\n        end = len(arr)-1\\n        \\n        while start <= end:\\n            mid = (start+end)//2\\n            \\n            if arr[mid][0] == snap_id:\\n                return mid\\n            elif arr[mid][0] > snap_id:\\n                end = mid -1\\n            else:\\n                start = mid + 1\\n                \\n        return end\\n        \\n\\n\\n# Your SnapshotArray object will be instantiated and called as such:\\n# obj = SnapshotArray(length)\\n# obj.set(index,val)\\n# param_2 = obj.snap()\\n# param_3 = obj.get(index,snap_id)\\n\\n\\'\\'\\'\\n\\n\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437566,
                "title": "c-o-1-set-and-o-1-get-operation",
                "content": "```\\nclass SnapshotArray \\n{\\n\\tvector<unordered_map<int, int> > d_db;\\n\\t\\n\\tpublic:\\n\\t\\tSnapshotArray(int length) \\t\\t\\n\\t\\t{\\n\\t\\t\\td_db.push_back(unordered_map<int, int>());\\n\\t\\t}\\n    \\n\\t\\tvoid set(int index, int val) \\n\\t\\t{\\n\\t\\t\\td_db[d_db.size() - 1][index] = val;\\n\\t\\t}\\n    \\n\\t\\tint snap() \\n\\t\\t{\\n\\t\\t\\tint currSize = d_db.size();\\n\\t\\t\\t\\n\\t\\t\\td_db.push_back(d_db[d_db.size() - 1]);\\n\\t\\t\\t\\n\\t\\t\\treturn currSize - 1;\\n\\t\\t}\\n    \\n\\t\\tint get(int index, int snap_id) \\n\\t\\t{\\n\\t\\t\\tif (d_db[snap_id].find(index) == d_db[snap_id].end())\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\n\\t\\t\\treturn d_db[snap_id][index];\\n\\t\\t}\\n};",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray \\n{\\n\\tvector<unordered_map<int, int> > d_db;\\n\\t\\n\\tpublic:\\n\\t\\tSnapshotArray(int length) \\t\\t\\n\\t\\t{\\n\\t\\t\\td_db.push_back(unordered_map<int, int>());\\n\\t\\t}\\n    \\n\\t\\tvoid set(int index, int val) \\n\\t\\t{\\n\\t\\t\\td_db[d_db.size() - 1][index] = val;\\n\\t\\t}\\n    \\n\\t\\tint snap() \\n\\t\\t{\\n\\t\\t\\tint currSize = d_db.size();\\n\\t\\t\\t\\n\\t\\t\\td_db.push_back(d_db[d_db.size() - 1]);\\n\\t\\t\\t\\n\\t\\t\\treturn currSize - 1;\\n\\t\\t}\\n    \\n\\t\\tint get(int index, int snap_id) \\n\\t\\t{\\n\\t\\t\\tif (d_db[snap_id].find(index) == d_db[snap_id].end())\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\n\\t\\t\\treturn d_db[snap_id][index];\\n\\t\\t}\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1291277,
                "title": "c-unordered-map-without-binary-search-tle",
                "content": "Get function time complexity  is O(1), but still it\\'s giving TLE for one test case.\\n   \\n    int totalSnaps;\\n    unordered_map<int, vector<int>> unmap;\\n    vector<int> cur_arr;\\n    \\n    SnapshotArray(int length) {\\n        cur_arr = vector<int>(length,0);\\n        totalSnaps = 0;\\n    }\\n    \\n    void set(int index, int val) {\\n        cur_arr[index] = val;\\n    }\\n    \\n    int snap() {\\n        unmap[totalSnaps] = cur_arr;\\n        int id = totalSnaps;\\n        totalSnaps += 1;\\n        return id;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(unmap.find(snap_id) != unmap.end()){\\n            return unmap[snap_id][index];\\n        }\\n        return 0;\\n     }\\n\\t \\n\\t \\nEdit:  https://stackoverflow.com/questions/56097653/what-is-the-time-complexity-of-mapping-a-vector\\nFound the issue, Copying vector complexity is O(N). That\\'s why snap operation complexity is O(N).",
                "solutionTags": [
                    "C"
                ],
                "code": "Get function time complexity  is O(1), but still it\\'s giving TLE for one test case.\\n   \\n    int totalSnaps;\\n    unordered_map<int, vector<int>> unmap;\\n    vector<int> cur_arr;\\n    \\n    SnapshotArray(int length) {\\n        cur_arr = vector<int>(length,0);\\n        totalSnaps = 0;\\n    }\\n    \\n    void set(int index, int val) {\\n        cur_arr[index] = val;\\n    }\\n    \\n    int snap() {\\n        unmap[totalSnaps] = cur_arr;\\n        int id = totalSnaps;\\n        totalSnaps += 1;\\n        return id;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(unmap.find(snap_id) != unmap.end()){\\n            return unmap[snap_id][index];\\n        }\\n        return 0;\\n     }\\n\\t \\n\\t \\nEdit:  https://stackoverflow.com/questions/56097653/what-is-the-time-complexity-of-mapping-a-vector\\nFound the issue, Copying vector complexity is O(N). That\\'s why snap operation complexity is O(N).",
                "codeTag": "Unknown"
            },
            {
                "id": 1226306,
                "title": "java-solution-using-hashmap-81-time-98-space",
                "content": "```\\nclass SnapshotArray {\\n    List<Map<Integer,Integer>> snaps;\\n    \\n    public SnapshotArray(int length) {\\n        snaps = new ArrayList<>();\\n        Map<Integer,Integer> firstSnap = new HashMap<>();\\n        snaps.add(firstSnap);\\n    }\\n    \\n    \\n    public void set(int index, int val) {\\n        Map<Integer,Integer> currentSnap = snaps.get(snaps.size()-1);\\n        currentSnap.put(index,val);\\n        snaps.set(snaps.size()-1,currentSnap);\\n    }\\n    \\n    public int snap() {\\n        int currentSnapId = snaps.size()-1;\\n        Map<Integer,Integer> nextSnap = new HashMap<>(snaps.get(snaps.size()-1));\\n        snaps.add(nextSnap);\\n        return currentSnapId;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        Map<Integer,Integer> snap = snaps.get(snap_id);\\n        return snap.getOrDefault(index,0);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n    List<Map<Integer,Integer>> snaps;\\n    \\n    public SnapshotArray(int length) {\\n        snaps = new ArrayList<>();\\n        Map<Integer,Integer> firstSnap = new HashMap<>();\\n        snaps.add(firstSnap);\\n    }\\n    \\n    \\n    public void set(int index, int val) {\\n        Map<Integer,Integer> currentSnap = snaps.get(snaps.size()-1);\\n        currentSnap.put(index,val);\\n        snaps.set(snaps.size()-1,currentSnap);\\n    }\\n    \\n    public int snap() {\\n        int currentSnapId = snaps.size()-1;\\n        Map<Integer,Integer> nextSnap = new HashMap<>(snaps.get(snaps.size()-1));\\n        snaps.add(nextSnap);\\n        return currentSnapId;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        Map<Integer,Integer> snap = snaps.get(snap_id);\\n        return snap.getOrDefault(index,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170534,
                "title": "easy-java-solution-using-treemap",
                "content": "```\\n    List<TreeMap<Integer, Integer>> map;\\n    int snap_id = 0;\\n\\t\\n    public SnapshotArray(int length) {\\n        map = new ArrayList<>();\\n        for(int i=0; i< length; i++){\\n            map.add(new TreeMap<>());\\n            map.get(i).put(0,0);\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        map.get(index).put(snap_id, val);\\n    }\\n    \\n    public int snap() {\\n        return snap_id++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        return map.get(index).floorEntry(snap_id).getValue();\\n    }",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n    List<TreeMap<Integer, Integer>> map;\\n    int snap_id = 0;\\n\\t\\n    public SnapshotArray(int length) {\\n        map = new ArrayList<>();\\n        for(int i=0; i< length; i++){\\n            map.add(new TreeMap<>());\\n            map.get(i).put(0,0);\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        map.get(index).put(snap_id, val);\\n    }\\n    \\n    public int snap() {\\n        return snap_id++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        return map.get(index).floorEntry(snap_id).getValue();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1145491,
                "title": "treemap-solution-in-java",
                "content": "```\\nclass SnapshotArray {\\n    // Map<Index, Map<SnapId,value>>\\n    Map<Integer, TreeMap<Integer,Integer>> indexTosnapValuesMap ; \\n    int snap_id;\\n    \\n    public SnapshotArray(int length) {\\n        indexTosnapValuesMap= new HashMap<>();\\n        for(int i=0;i<length;i++){\\n            indexTosnapValuesMap.put(i,new TreeMap<>());\\n            indexTosnapValuesMap.get(i).put(0,0);\\n        }\\n        snap_id=0;\\n    }\\n    \\n    public void set(int index, int val) {\\n        \\n        indexTosnapValuesMap.get(index).put(snap_id,val);\\n    }\\n    \\n    public int snap() {\\n        snap_id++;\\n        return snap_id-1;\\n        \\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        Integer lastUpdatedSnapShot=indexTosnapValuesMap.get(index).floorKey(snap_id);\\n        return indexTosnapValuesMap.get(index).get(lastUpdatedSnapShot);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n    // Map<Index, Map<SnapId,value>>\\n    Map<Integer, TreeMap<Integer,Integer>> indexTosnapValuesMap ; \\n    int snap_id;\\n    \\n    public SnapshotArray(int length) {\\n        indexTosnapValuesMap= new HashMap<>();\\n        for(int i=0;i<length;i++){\\n            indexTosnapValuesMap.put(i,new TreeMap<>());\\n            indexTosnapValuesMap.get(i).put(0,0);\\n        }\\n        snap_id=0;\\n    }\\n    \\n    public void set(int index, int val) {\\n        \\n        indexTosnapValuesMap.get(index).put(snap_id,val);\\n    }\\n    \\n    public int snap() {\\n        snap_id++;\\n        return snap_id-1;\\n        \\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        Integer lastUpdatedSnapShot=indexTosnapValuesMap.get(index).floorKey(snap_id);\\n        return indexTosnapValuesMap.get(index).get(lastUpdatedSnapShot);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100198,
                "title": "c-99-faster-o-1-snap-o-1-set-o-logn-get",
                "content": "I am using a jagged 2D array SnapShot to store the changes happening for every index.\\ne.g. snapShot[3] = { {2, 4}, {5, 7} } means that for index 3 of original array, the value for \\nsnap_id 2 = 4,\\nsnap_id 5 = 7,\\nsnap_id < 2 = 0\\n2 < snap_id < 5 = 4\\nsnap_id > 5 = 7\\n\\nThe list is sorted as snapIds are created in sorted way, so we use binary search for get.\\nHere, snapId is the id of last snapshot taken. The key here is that when we do a set operation, we are creating/ updating an entry of future snapshot.  e.g. in our example, if snapId = 4, that means the last entry {5, 7} corresponds to the future snapId that needsto happen, this makes snap O(1). If snapId = 6, this means no change was done after snap 5.\\n\\nHope this helps!\\n\\n```\\nclass SnapshotArray {    \\npublic:\\n    vector<vector<pair<int, int>>> snapShot;\\n    int snapId;\\n    SnapshotArray(int length) {\\n        vector<vector<pair<int, int>>> x(length, vector<pair<int, int>>());\\n        this->snapShot = x;\\n        this->snapId = -1;\\n    }\\n    \\n    void set(int index, int val) {\\n        if (!snapShot[index].empty() && snapShot[index].back().first == snapId + 1) {\\n            snapShot[index].back().second = val;\\n            return;\\n        }\\n        \\n        snapShot[index].push_back(make_pair(snapId + 1, val));\\n    }\\n    \\n    int snap() {\\n        snapId = snapId + 1;\\n        return snapId;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if (snap_id > this->snapId) {\\n            return -1;\\n        }\\n        \\n        if (snapShot[index].empty()) {\\n            return 0;\\n        }        \\n       \\n        if (snap_id > snapShot[index].back().first) {\\n            return snapShot[index].back().second;\\n        }\\n        \\n        int idx = lower_bound(snapShot[index].begin(), snapShot[index].end(), make_pair(snap_id, -1)) - snapShot[index].begin();\\n        idx += snapShot[index][idx].first == snap_id ? 0 : -1;\\n        return idx < 0 ? 0 : snapShot[index][idx].second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass SnapshotArray {    \\npublic:\\n    vector<vector<pair<int, int>>> snapShot;\\n    int snapId;\\n    SnapshotArray(int length) {\\n        vector<vector<pair<int, int>>> x(length, vector<pair<int, int>>());\\n        this->snapShot = x;\\n        this->snapId = -1;\\n    }\\n    \\n    void set(int index, int val) {\\n        if (!snapShot[index].empty() && snapShot[index].back().first == snapId + 1) {\\n            snapShot[index].back().second = val;\\n            return;\\n        }\\n        \\n        snapShot[index].push_back(make_pair(snapId + 1, val));\\n    }\\n    \\n    int snap() {\\n        snapId = snapId + 1;\\n        return snapId;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if (snap_id > this->snapId) {\\n            return -1;\\n        }\\n        \\n        if (snapShot[index].empty()) {\\n            return 0;\\n        }        \\n       \\n        if (snap_id > snapShot[index].back().first) {\\n            return snapShot[index].back().second;\\n        }\\n        \\n        int idx = lower_bound(snapShot[index].begin(), snapShot[index].end(), make_pair(snap_id, -1)) - snapShot[index].begin();\\n        idx += snapShot[index][idx].first == snap_id ? 0 : -1;\\n        return idx < 0 ? 0 : snapShot[index][idx].second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953894,
                "title": "simple-java-solution-using-list-data-structure-and-binary-search-for-slow-learners-like-myself",
                "content": "Runtime\\n- Constructor -> O(n) and n is length\\n- set -> O(1)\\n- snap -> O(1)\\n- get -> O(log m) where m is number of snaps\\n\\nSpace:\\nO(nm) where n is length of array and m is number of snaps\\n```\\nclass SnapshotArray {\\n    \\n    private final List<List<int[]>> lists;\\n    private int snapId = -1;\\n\\n    public SnapshotArray(int length) {\\n        this.lists = new ArrayList<>();\\n        for (int i = 0; i < length; i++)\\n            lists.add(new ArrayList<>());\\n    }\\n    \\n    public void set(int index, int val) {\\n        if (index >= lists.size())\\n            return;\\n        \\n        //int[] -> 0index = snapId, 1index = val\\n        List<int[]> list = lists.get(index);\\n        if (list.isEmpty() || list.get(list.size() - 1)[0] < (snapId + 1))\\n            list.add(new int[] {snapId + 1, val});\\n        else \\n            list.get(list.size() - 1)[1] = val;\\n    }\\n    \\n    public int snap() {\\n        return ++snapId;\\n    }\\n    \\n    public int get(int index, int snapId) {\\n        if (index >= lists.size())\\n            return 0;\\n        return search(lists.get(index), snapId);\\n    }\\n    \\n    private int search(List<int[]> list, int id) {\\n        int left = 0, right = list.size();\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (list.get(mid)[0] <= id)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n\\n        return left - 1 == -1 ? 0 : list.get(left - 1)[1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n    \\n    private final List<List<int[]>> lists;\\n    private int snapId = -1;\\n\\n    public SnapshotArray(int length) {\\n        this.lists = new ArrayList<>();\\n        for (int i = 0; i < length; i++)\\n            lists.add(new ArrayList<>());\\n    }\\n    \\n    public void set(int index, int val) {\\n        if (index >= lists.size())\\n            return;\\n        \\n        //int[] -> 0index = snapId, 1index = val\\n        List<int[]> list = lists.get(index);\\n        if (list.isEmpty() || list.get(list.size() - 1)[0] < (snapId + 1))\\n            list.add(new int[] {snapId + 1, val});\\n        else \\n            list.get(list.size() - 1)[1] = val;\\n    }\\n    \\n    public int snap() {\\n        return ++snapId;\\n    }\\n    \\n    public int get(int index, int snapId) {\\n        if (index >= lists.size())\\n            return 0;\\n        return search(lists.get(index), snapId);\\n    }\\n    \\n    private int search(List<int[]> list, int id) {\\n        int left = 0, right = list.size();\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (list.get(mid)[0] <= id)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n\\n        return left - 1 == -1 ? 0 : list.get(left - 1)[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940403,
                "title": "extremly-simple-swift",
                "content": "```\\n\\nclass SnapshotArray {\\n    \\n    private var arrDic = [Int : Int]()\\n    private var dic = [Int : [Int : Int]]()\\n    private var snapsNum = 0\\n\\n    init(_ length: Int) {}\\n    \\n    func set(_ index: Int, _ val: Int) {\\n        arrDic[index] = val\\n    }\\n    \\n    func snap() -> Int {\\n                \\n        let snapId = snapsNum\\n        snapsNum += 1\\n        dic[snapId] = arrDic\\n        return snapId\\n    }\\n    \\n    func get(_ index: Int, _ snap_id: Int) -> Int {\\n        \\n        return dic[snap_id]?[index] ?? 0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass SnapshotArray {\\n    \\n    private var arrDic = [Int : Int]()\\n    private var dic = [Int : [Int : Int]]()\\n    private var snapsNum = 0\\n\\n    init(_ length: Int) {}\\n    \\n    func set(_ index: Int, _ val: Int) {\\n        arrDic[index] = val\\n    }\\n    \\n    func snap() -> Int {\\n                \\n        let snapId = snapsNum\\n        snapsNum += 1\\n        dic[snapId] = arrDic\\n        return snapId\\n    }\\n    \\n    func get(_ index: Int, _ snap_id: Int) -> Int {\\n        \\n        return dic[snap_id]?[index] ?? 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916134,
                "title": "python-solution-o-n-get-o-1-set-snap-using-only-hash-map",
                "content": "Given that all values are zero unless stated, we can assume that the get function only matters for indexes which have been set, \\nalso taking two snap back to back should be disregarded as it only waist\\'s space. Therfore, the way I approached this problem is by generating a dictionary like this { (snap_id, index) : val }. the trick here is that snap_id is not updated everytime we take a snap, but everytime we define a new value. This way when we snap() all we do is update the snapCount value.\\nLastly, the function that does all the work is get(), where we look up in O(1) time complexity for the index and value requested, if not found, we decrease the value of the snap_id, hence looking for the last existing copy of the item before the given snap_id.\\nIf no value is found, we return 0 since all unset index values are 0.\\n note: using a tuple as hash, decreases the for loop iteration time, because I am aware the worst case is significantly big.\\n \\n ```\\n class SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.snapShot = {}\\n        self.snapCount = 0\\n        \\n\\n    def set(self, index: int, val: int) -> None:\\n        self.snapShot[(self.snapCount, index)] = val\\n        \\n\\n    def snap(self) -> int:\\n        self.snapCount += 1\\n        return self.snapCount -1\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        for snapId in range(snap_id, -1, -1):\\n            if (snapId, index) in self.snapShot:\\n                return self.snapShot[(snapId, index)]\\n        return 0\\n ```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n class SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.snapShot = {}\\n        self.snapCount = 0\\n        \\n\\n    def set(self, index: int, val: int) -> None:\\n        self.snapShot[(self.snapCount, index)] = val\\n        \\n\\n    def snap(self) -> int:\\n        self.snapCount += 1\\n        return self.snapCount -1\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        for snapId in range(snap_id, -1, -1):\\n            if (snapId, index) in self.snapShot:\\n                return self.snapShot[(snapId, index)]\\n        return 0\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 909644,
                "title": "javascript-binary-search",
                "content": "For `set`: To save space, we store a new version of data only when the current version is higher than the oldest version present in an index\\'s history. If the latest version in an index\\'s history matches our current version, then we simply update what\\'s in our history in-place.\\n\\nFor `get`: Now that we are storing historical values and their version numbers in each index-specific array, the problem can be reworded as, \"given a target number and a sorted array, return the floor value, i.e., the largest number that is either the same or smaller than the target.\" For example, imagine that we were given an array of version numbers, like this: `[0,3,4,5]` . If the target were `3`, we\\'d just return `3`. But if the target were `2`, then we need to return `0`, because that\\'s the latest version up until `3`.  \\n\\nAs an exercise, I recommend you to try to implement the above task using binary search. You\\'ll notice that it\\'s not possible (or at least really hard) to find the floor value directly by binary search. You should instead find the ceiling value, i.e., the smallest number that is either the same or larger than the target, and then try to find the floor value (which is either the same as the ceiling value -- if the target is present in the array -- or is located directly on the left of the ceiling val).\\n\\nOne edge case is if the array were  `[0,3,4,5]`, and the version we\\'re looking for is `7`. In this case, the array does not contain the ceiling value. So before doing binary search, we should check that the target version isn\\'t greater than the latest version in history.\\n\\n```js\\nvar SnapshotArray = function(length) {\\n    this.snapId = 0\\n    this.arr = new Array(length)\\n    for (let i = 0; i < this.arr.length; i++) {\\n        this.arr[i] = [[0,0]] // add snapId, val\\n    }\\n};\\n\\nSnapshotArray.prototype.set = function(index, val) {\\n    const arrAtIdx = this.arr[index]\\n    const lastIdx = arrAtIdx.length - 1\\n    const lastSnapId = arrAtIdx[lastIdx][0]\\n    if (lastSnapId === this.snapId) {\\n        // update\\n        arrAtIdx[lastIdx][1] = val\\n    } else {\\n        // push new\\n        arrAtIdx.push([this.snapId, val])\\n    }\\n};\\n\\nSnapshotArray.prototype.snap = function() {\\n    this.snapId++\\n    \\n    return this.snapId - 1\\n};\\n\\nSnapshotArray.prototype.get = function(index, snap_id) {\\n    // find floor val (aka the largest snap_id in history that is smaller or equal to the target snap_id)\\n    // in order to find floor val, we need to first find ceiling val (aka the smallest snap_id in history that is larger or equal to the target snap_id)\\n    const arrAtIdx = this.arr[index]\\n    \\n    // edge case:\\n    // this means everything in the arrAtIdx has lower snap_id than the target snap_id,\\n    // so just return the latest version\\n    if (arrAtIdx[arrAtIdx.length - 1][0] < snap_id) {\\n        return arrAtIdx[arrAtIdx.length - 1][1]\\n    }\\n    \\n    let lo = 0\\n    let hi = arrAtIdx.length - 1\\n    while (lo < hi) {\\n        const mid = lo + Math.floor((hi - lo) /2)\\n        if (arrAtIdx[mid][0] >= snap_id) {\\n            hi = mid\\n        } else {\\n            lo = mid + 1\\n        }\\n    }\\n\\n    // hi is at ceiling\\n    if (arrAtIdx[hi][0] === snap_id || hi === 0) {\\n        return arrAtIdx[hi][1]   \\n    }\\n    \\n    // hi - 1 must be the floor\\n    return arrAtIdx[hi - 1][1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar SnapshotArray = function(length) {\\n    this.snapId = 0\\n    this.arr = new Array(length)\\n    for (let i = 0; i < this.arr.length; i++) {\\n        this.arr[i] = [[0,0]] // add snapId, val\\n    }\\n};\\n\\nSnapshotArray.prototype.set = function(index, val) {\\n    const arrAtIdx = this.arr[index]\\n    const lastIdx = arrAtIdx.length - 1\\n    const lastSnapId = arrAtIdx[lastIdx][0]\\n    if (lastSnapId === this.snapId) {\\n        // update\\n        arrAtIdx[lastIdx][1] = val\\n    } else {\\n        // push new\\n        arrAtIdx.push([this.snapId, val])\\n    }\\n};\\n\\nSnapshotArray.prototype.snap = function() {\\n    this.snapId++\\n    \\n    return this.snapId - 1\\n};\\n\\nSnapshotArray.prototype.get = function(index, snap_id) {\\n    // find floor val (aka the largest snap_id in history that is smaller or equal to the target snap_id)\\n    // in order to find floor val, we need to first find ceiling val (aka the smallest snap_id in history that is larger or equal to the target snap_id)\\n    const arrAtIdx = this.arr[index]\\n    \\n    // edge case:\\n    // this means everything in the arrAtIdx has lower snap_id than the target snap_id,\\n    // so just return the latest version\\n    if (arrAtIdx[arrAtIdx.length - 1][0] < snap_id) {\\n        return arrAtIdx[arrAtIdx.length - 1][1]\\n    }\\n    \\n    let lo = 0\\n    let hi = arrAtIdx.length - 1\\n    while (lo < hi) {\\n        const mid = lo + Math.floor((hi - lo) /2)\\n        if (arrAtIdx[mid][0] >= snap_id) {\\n            hi = mid\\n        } else {\\n            lo = mid + 1\\n        }\\n    }\\n\\n    // hi is at ceiling\\n    if (arrAtIdx[hi][0] === snap_id || hi === 0) {\\n        return arrAtIdx[hi][1]   \\n    }\\n    \\n    // hi - 1 must be the floor\\n    return arrAtIdx[hi - 1][1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 843846,
                "title": "python3-5-lines",
                "content": "```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        \\n        self.snapshot = [{}]\\n    \\n    def set(self, index: int, val: int) -> None:\\n        \\n        self.snapshot[-1][index] = val\\n\\n    def snap(self) -> int:\\n        \\n        self.snapshot.append(self.snapshot[-1].copy())\\n        return len(self.snapshot) -2\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        return self.snapshot[snap_id].get(index, 0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        \\n        self.snapshot = [{}]\\n    \\n    def set(self, index: int, val: int) -> None:\\n        \\n        self.snapshot[-1][index] = val\\n\\n    def snap(self) -> int:\\n        \\n        self.snapshot.append(self.snapshot[-1].copy())\\n        return len(self.snapshot) -2\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        return self.snapshot[snap_id].get(index, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733171,
                "title": "simple-java-solution-98",
                "content": "```\\nclass SnapshotArray {\\n    List<HashMap<Integer,Integer>> store= new ArrayList<>();\\n    HashMap<Integer,Integer> map;\\n    public SnapshotArray(int length) {\\n        map= new HashMap<>();\\n        \\n    }\\n    \\n    public void set(int index, int val) {\\n        map.put(index,val);\\n        //System.out.println(map);\\n    }\\n    \\n    public int snap() {\\n        store.add(map);\\n        map=new HashMap<>();\\n        return store.size()-1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        for(int i=snap_id;i>=0;i--){\\n            if(store.get(i).containsKey(index))\\n                return store.get(i).get(index);\\n        }\\n        return 0;\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n    List<HashMap<Integer,Integer>> store= new ArrayList<>();\\n    HashMap<Integer,Integer> map;\\n    public SnapshotArray(int length) {\\n        map= new HashMap<>();\\n        \\n    }\\n    \\n    public void set(int index, int val) {\\n        map.put(index,val);\\n        //System.out.println(map);\\n    }\\n    \\n    public int snap() {\\n        store.add(map);\\n        map=new HashMap<>();\\n        return store.size()-1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        for(int i=snap_id;i>=0;i--){\\n            if(store.get(i).containsKey(index))\\n                return store.get(i).get(index);\\n        }\\n        return 0;\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726289,
                "title": "c-mock-interview-practice-on-july-8-2020",
                "content": "July 8, 2020\\n\\n1146. Snapshot Array\\n\\n**Introduction**\\n\\nI failed two times to pass online judge in my mock interview; The first one I have TLE bug, so that I modified the design to avoid copy whole array into dictionary called snapHistory. Second one is to provide default value 0 if the index asked is not in snapHistory. \\n\\nIn general, record every set operation into snap dictionary, either adding a new entry or modify existing entry. \\n\\n**Short and quick review class design**\\nI just quickly defined properties snap, array, snapId, snapHistory; after I failed first TLE, I modified the design, so array variable is no longer needed. \\n\\n```\\npublic class SnapshotArray {\\n\\n    private Dictionary<int, int> snap = new Dictionary<int, int>(); \\n    \\n    private int[] array;  // obsolete - it should be removed\\n    private int snapId = 0; \\n    private Dictionary<int, int>[] snapHistory = new Dictionary<int, int>[50000 + 1];\\n    \\n    public SnapshotArray(int length) {\\n        if(length <= 0)\\n            return; \\n        \\n        array = new int[length];        \\n        snapId = 0; \\n    }\\n    \\n    public void Set(int index, int val) {\\n        if(index < 0 || index >= array.Length)\\n            return;\\n        \\n        array[index] = val;\\n        if(!snap.ContainsKey(index))\\n        {\\n            snap.Add(index, val);\\n        }\\n        \\n        snap[index] = val; \\n    }\\n    \\n    public int Snap() {\\n        var snapCopy = new Dictionary<int, int>(snap); \\n        snapHistory[snapId] = snapCopy;         \\n        \\n        snapId++; \\n        return snapId - 1; \\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        if(index < 0 || index >= array.Length || snap_id < 0 ||\\n          snap_id >= snapId)\\n        {\\n            return -1; \\n        }\\n        \\n        if(!snapHistory[snap_id].ContainsKey(index))\\n        {\\n            return 0;\\n        }\\n        \\n        return snapHistory[snap_id][index];\\n        \\n    }\\n}\\n```\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.Set(index,val);\\n * int param_2 = obj.Snap();\\n * int param_3 = obj.Get(index,snap_id);\\n */\\n",
                "solutionTags": [],
                "code": "```\\npublic class SnapshotArray {\\n\\n    private Dictionary<int, int> snap = new Dictionary<int, int>(); \\n    \\n    private int[] array;  // obsolete - it should be removed\\n    private int snapId = 0; \\n    private Dictionary<int, int>[] snapHistory = new Dictionary<int, int>[50000 + 1];\\n    \\n    public SnapshotArray(int length) {\\n        if(length <= 0)\\n            return; \\n        \\n        array = new int[length];        \\n        snapId = 0; \\n    }\\n    \\n    public void Set(int index, int val) {\\n        if(index < 0 || index >= array.Length)\\n            return;\\n        \\n        array[index] = val;\\n        if(!snap.ContainsKey(index))\\n        {\\n            snap.Add(index, val);\\n        }\\n        \\n        snap[index] = val; \\n    }\\n    \\n    public int Snap() {\\n        var snapCopy = new Dictionary<int, int>(snap); \\n        snapHistory[snapId] = snapCopy;         \\n        \\n        snapId++; \\n        return snapId - 1; \\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        if(index < 0 || index >= array.Length || snap_id < 0 ||\\n          snap_id >= snapId)\\n        {\\n            return -1; \\n        }\\n        \\n        if(!snapHistory[snap_id].ContainsKey(index))\\n        {\\n            return 0;\\n        }\\n        \\n        return snapHistory[snap_id][index];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703998,
                "title": "javascript-es6-map-solution",
                "content": "```\\nclass SnapshotArray{\\n    constructor(length) {\\n        this.indexMap = new Map();\\n        this.id = 0;\\n    }\\n    set(index, val) {\\n        if(this.indexMap.has(index)) {\\n            const map = this.indexMap.get(index);\\n            map.set(this.id, val);\\n        } else {\\n            const map = new Map();\\n            map.set(this.id, val);\\n            this.indexMap.set(index, map);\\n        }\\n    }\\n    snap() {\\n        this.id++;\\n        return this.id - 1;\\n    }\\n    get(index, snap_id) {\\n        const map = this.indexMap.get(index);\\n        if(!map) return 0;\\n        let i = snap_id;\\n        while(map.get(i) === undefined && i > 0) {\\n            i--;\\n        }\\n        return map.get(i) || 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass SnapshotArray{\\n    constructor(length) {\\n        this.indexMap = new Map();\\n        this.id = 0;\\n    }\\n    set(index, val) {\\n        if(this.indexMap.has(index)) {\\n            const map = this.indexMap.get(index);\\n            map.set(this.id, val);\\n        } else {\\n            const map = new Map();\\n            map.set(this.id, val);\\n            this.indexMap.set(index, map);\\n        }\\n    }\\n    snap() {\\n        this.id++;\\n        return this.id - 1;\\n    }\\n    get(index, snap_id) {\\n        const map = this.indexMap.get(index);\\n        if(!map) return 0;\\n        let i = snap_id;\\n        while(map.get(i) === undefined && i > 0) {\\n            i--;\\n        }\\n        return map.get(i) || 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681404,
                "title": "c-vector-binary-search",
                "content": "```\\nclass SnapshotArray {\\npublic:\\n    vector<vector<pair<int,int>>> arr;\\n    int curr_snap = 0;\\n    SnapshotArray(int length) {\\n        //O(length)\\n        arr.resize(length);\\n        for(int i=0;i<length;i++) arr[i].push_back({0, curr_snap});\\n    }\\n    \\n    void set(int index, int val) {\\n        //O(1)\\n        arr[index].push_back({val, curr_snap});\\n    }\\n    \\n    int snap() {\\n        //O(1)\\n        curr_snap++;\\n        return curr_snap-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        //O(log(curr_snap))\\n        int low = 0;\\n        int high = arr[index].size()-1;\\n        int idx = -1;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            if(arr[index][mid].second > snap_id) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n                idx = mid;\\n            }\\n        }\\n        return arr[index][idx].first;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n    vector<vector<pair<int,int>>> arr;\\n    int curr_snap = 0;\\n    SnapshotArray(int length) {\\n        //O(length)\\n        arr.resize(length);\\n        for(int i=0;i<length;i++) arr[i].push_back({0, curr_snap});\\n    }\\n    \\n    void set(int index, int val) {\\n        //O(1)\\n        arr[index].push_back({val, curr_snap});\\n    }\\n    \\n    int snap() {\\n        //O(1)\\n        curr_snap++;\\n        return curr_snap-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        //O(log(curr_snap))\\n        int low = 0;\\n        int high = arr[index].size()-1;\\n        int idx = -1;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            if(arr[index][mid].second > snap_id) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n                idx = mid;\\n            }\\n        }\\n        return arr[index][idx].first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 675725,
                "title": "java-simple-list-of-treemap",
                "content": "```\\nclass SnapshotArray {\\n    List<TreeMap<Integer, Integer>> maps = new ArrayList<>();\\n    int id;\\n    public SnapshotArray(int length) {\\n        id = 0;\\n        for (int i = 0; i < length; i++) {\\n            maps.add(new TreeMap<>());\\n            maps.get(i).put(0, 0);\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        maps.get(index).put(id, val);\\n    }\\n    \\n    public int snap() {\\n        id++;\\n        return id - 1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        Integer key = maps.get(index).floorKey(snap_id);\\n        return maps.get(index).get(key);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n    List<TreeMap<Integer, Integer>> maps = new ArrayList<>();\\n    int id;\\n    public SnapshotArray(int length) {\\n        id = 0;\\n        for (int i = 0; i < length; i++) {\\n            maps.add(new TreeMap<>());\\n            maps.get(i).put(0, 0);\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        maps.get(index).put(id, val);\\n    }\\n    \\n    public int snap() {\\n        id++;\\n        return id - 1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        Integer key = maps.get(index).floorKey(snap_id);\\n        return maps.get(index).get(key);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572624,
                "title": "c-easy-short-using-lower-bound-100-sc",
                "content": "```\\nclass SnapshotArray {\\npublic:\\n    unordered_map<int,map<int,int>> m;\\n    int id;\\n    SnapshotArray(int length) {\\n        id = 0;\\n    }\\n    \\n    void set(int index, int val) {\\n        m[index][id] = val;\\n    }\\n    \\n    int snap() {\\n        int x = id;\\n        id++;\\n        return x;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(m.find(index) == m.end())return 0;\\n        auto pos = m[index].lower_bound(snap_id);\\n        if(pos->first != snap_id && pos == m[index].begin())return 0;\\n        if(pos->first != snap_id )pos--;\\n        if(pos == m[index].end())pos--;\\n        return pos->second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n    unordered_map<int,map<int,int>> m;\\n    int id;\\n    SnapshotArray(int length) {\\n        id = 0;\\n    }\\n    \\n    void set(int index, int val) {\\n        m[index][id] = val;\\n    }\\n    \\n    int snap() {\\n        int x = id;\\n        id++;\\n        return x;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(m.find(index) == m.end())return 0;\\n        auto pos = m[index].lower_bound(snap_id);\\n        if(pos->first != snap_id && pos == m[index].begin())return 0;\\n        if(pos->first != snap_id )pos--;\\n        if(pos == m[index].end())pos--;\\n        return pos->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552743,
                "title": "java-solution-beats-100-space-90-runtime",
                "content": "The idea is to use a map where key is snapId and value is another map that keeps tracking of index-value pair, rather than having an array of maps. One side benefit is that we are not restricted by a fixed length.\\n\\nIt takes O(1) time for  `SnapshotArray()`, `set()` and `snap()`, and uses O(N) memory. However, the `get()` could be pretty expensive, especially when there are tons of snapshots and certain elements only get set in the first several snapshots but then was never updated. An improvement I can come up with is that we could have another map, where key stores index, and value is a treeSet stores snapshot ids recording when the elements were set; so we could use this map to quickly navigate to closest snapId for `get()` which reduces the TC for `get()` to O(logK) where K is number of snap ids for an element.\\n\\nThe code at below is pretty self-explainning.\\n\\n```\\nclass SnapshotArray {\\n    \\n    private Map<Integer, Map<Integer, Integer>> map;\\n    private int snapId;\\n\\n    public SnapshotArray(int length) {\\n        this.map = new HashMap<>();\\n        this.snapId = 0;\\n        map.put(snapId, new HashMap<>());\\n    }\\n    \\n    public void set(int index, int val) {\\n        map.get(snapId).put(index, val);\\n    }\\n    \\n    public int snap() {\\n        map.put(++snapId, new HashMap<>());\\n        return snapId - 1;\\n    }\\n    \\n    public int get(int index, int snapId) {\\n        while(snapId >= 0) {\\n            if(map.get(snapId).containsKey(index)) {\\n                return map.get(snapId).get(index);\\n            }\\n            snapId--;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n    \\n    private Map<Integer, Map<Integer, Integer>> map;\\n    private int snapId;\\n\\n    public SnapshotArray(int length) {\\n        this.map = new HashMap<>();\\n        this.snapId = 0;\\n        map.put(snapId, new HashMap<>());\\n    }\\n    \\n    public void set(int index, int val) {\\n        map.get(snapId).put(index, val);\\n    }\\n    \\n    public int snap() {\\n        map.put(++snapId, new HashMap<>());\\n        return snapId - 1;\\n    }\\n    \\n    public int get(int index, int snapId) {\\n        while(snapId >= 0) {\\n            if(map.get(snapId).containsKey(index)) {\\n                return map.get(snapId).get(index);\\n            }\\n            snapId--;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497665,
                "title": "java-99-100",
                "content": "```\\nclass SnapshotArray {\\n\\n    List<Integer>[] arr;\\n    int currentSnapId = 0;\\n    \\n    public SnapshotArray(int length) {\\n        arr = new List[length];\\n        for (int i = 0; i < length; i++) {\\n            arr[i] = new ArrayList<Integer>();\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        List<Integer> list = arr[index];\\n        while (list.size() <= currentSnapId) {\\n            list.add(null);\\n        }\\n        // System.out.println(index + \" \" + list.size() + \" \" + val + \" \" + currentSnapId);\\n        \\n        list.set(currentSnapId, val);\\n    }\\n    \\n    public int snap() {\\n        return currentSnapId++;    \\n    }\\n    \\n    public int get(int index, int snapId) {\\n        List<Integer> list = arr[index];\\n        if (list.size() <= snapId) {\\n            snapId = list.size() - 1; \\n        }\\n        \\n        while (snapId >= 0 && list.get(snapId) == null) {\\n            snapId--;    \\n        }\\n        \\n        if (snapId < 0) {\\n            return 0;\\n        } else {\\n            return list.get(snapId);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n\\n    List<Integer>[] arr;\\n    int currentSnapId = 0;\\n    \\n    public SnapshotArray(int length) {\\n        arr = new List[length];\\n        for (int i = 0; i < length; i++) {\\n            arr[i] = new ArrayList<Integer>();\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        List<Integer> list = arr[index];\\n        while (list.size() <= currentSnapId) {\\n            list.add(null);\\n        }\\n        // System.out.println(index + \" \" + list.size() + \" \" + val + \" \" + currentSnapId);\\n        \\n        list.set(currentSnapId, val);\\n    }\\n    \\n    public int snap() {\\n        return currentSnapId++;    \\n    }\\n    \\n    public int get(int index, int snapId) {\\n        List<Integer> list = arr[index];\\n        if (list.size() <= snapId) {\\n            snapId = list.size() - 1; \\n        }\\n        \\n        while (snapId >= 0 && list.get(snapId) == null) {\\n            snapId--;    \\n        }\\n        \\n        if (snapId < 0) {\\n            return 0;\\n        } else {\\n            return list.get(snapId);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440502,
                "title": "javascript-binary-search",
                "content": "Meantain a snapshot_id property in the instance defaults to -1.\\nEverytime snap() is called, snapshot_id += 1.\\nEverytime get() is called, use binary search to find the **last element** with the snapshot_id **smaller** than given snapshot_id.\\n\\n```\\n/**\\n * @param {number} length\\n */\\nvar SnapshotArray = function(length) {\\n    this.storage = new Array(length);\\n    this.snapShot = -1;\\n    for (let i = 0; i < length; i++) {\\n        this.storage[i] = [{val: 0, snapShot: -1}];\\n    }\\n    \\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} val\\n * @return {void}\\n */\\nSnapshotArray.prototype.set = function(index, val) {\\n    if (index >= this.storage.length) {\\n        throw Error(\\'invalid index\\');\\n    }\\n    this.storage[index].push({val, snapShot: this.snapShot});\\n    \\n};\\n\\n/**\\n * @return {number}\\n */\\nSnapshotArray.prototype.snap = function() {\\n    this.snapShot += 1;\\n    return this.snapShot;\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} snap_id\\n * @return {number}\\n */\\nSnapshotArray.prototype.get = function(index, snap_id) {\\n    const nums = this.storage[index];\\n    \\n    let i = 0;\\n    let j = nums.length - 1;\\n    let mid;\\n    \\n    while (i + 1 < j) {\\n        mid = Math.floor((i + j) / 2);\\n        if (nums[mid].snapShot < snap_id) {\\n            i = mid;\\n        } else {\\n            j = mid;\\n        }\\n    }\\n    \\n    if (nums[j].snapShot < snap_id) {\\n        return nums[j].val;\\n    } else {\\n        return nums[i].val;\\n    }\\n    \\n};\\n\\n/** \\n * Your SnapshotArray object will be instantiated and called as such:\\n * var obj = new SnapshotArray(length)\\n * obj.set(index,val)\\n * var param_2 = obj.snap()\\n * var param_3 = obj.get(index,snap_id)\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} length\\n */\\nvar SnapshotArray = function(length) {\\n    this.storage = new Array(length);\\n    this.snapShot = -1;\\n    for (let i = 0; i < length; i++) {\\n        this.storage[i] = [{val: 0, snapShot: -1}];\\n    }\\n    \\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} val\\n * @return {void}\\n */\\nSnapshotArray.prototype.set = function(index, val) {\\n    if (index >= this.storage.length) {\\n        throw Error(\\'invalid index\\');\\n    }\\n    this.storage[index].push({val, snapShot: this.snapShot});\\n    \\n};\\n\\n/**\\n * @return {number}\\n */\\nSnapshotArray.prototype.snap = function() {\\n    this.snapShot += 1;\\n    return this.snapShot;\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} snap_id\\n * @return {number}\\n */\\nSnapshotArray.prototype.get = function(index, snap_id) {\\n    const nums = this.storage[index];\\n    \\n    let i = 0;\\n    let j = nums.length - 1;\\n    let mid;\\n    \\n    while (i + 1 < j) {\\n        mid = Math.floor((i + j) / 2);\\n        if (nums[mid].snapShot < snap_id) {\\n            i = mid;\\n        } else {\\n            j = mid;\\n        }\\n    }\\n    \\n    if (nums[j].snapShot < snap_id) {\\n        return nums[j].val;\\n    } else {\\n        return nums[i].val;\\n    }\\n    \\n};\\n\\n/** \\n * Your SnapshotArray object will be instantiated and called as such:\\n * var obj = new SnapshotArray(length)\\n * obj.set(index,val)\\n * var param_2 = obj.snap()\\n * var param_3 = obj.get(index,snap_id)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 405855,
                "title": "c-super-clean-and-neat-in",
                "content": "```\\nclass SnapshotArray\\n{\\npublic:    \\n    int N_ = 0;    \\n    vector<map<int,int>> data_;\\n    SnapshotArray(int length)\\n        :data_(length, {{0,0}})\\n    {}\\n    \\n    void set(int index, int val)\\n    {\\n       auto& snapshot = data_[index];\\n       snapshot[N_]=val;\\n    }\\n    \\n    int snap() { return N_++; }    \\n    int get(int index, int snap_id)\\n    {\\n        auto& snapshot = data_[index];\\n        auto it = snapshot.lower_bound(snap_id);        \\n             if (it == snapshot.end() || it->first != snap_id) \\n                 return prev(it)->second;\\n            else\\n                 return it->second;\\n        \\n    }\\n};``\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray\\n{\\npublic:    \\n    int N_ = 0;    \\n    vector<map<int,int>> data_;\\n    SnapshotArray(int length)\\n        :data_(length, {{0,0}})\\n    {}\\n    \\n    void set(int index, int val)\\n    {\\n       auto& snapshot = data_[index];\\n       snapshot[N_]=val;\\n    }\\n    \\n    int snap() { return N_++; }    \\n    int get(int index, int snap_id)\\n    {\\n        auto& snapshot = data_[index];\\n        auto it = snapshot.lower_bound(snap_id);        \\n             if (it == snapshot.end() || it->first != snap_id) \\n                 return prev(it)->second;\\n            else\\n                 return it->second;\\n        \\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404680,
                "title": "python-binary-search-keep-last-value",
                "content": "Use `self.record` to store the set values for each index. For each snapshot, we only keep the last set values.\\n\\n```\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.record = [[[0, 0]] for i in range(length)]\\n        self.snap_ind = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        if self.record[index][-1][0] == self.snap_ind:\\n            self.record[index][-1][1] = val\\n        else:\\n            self.record[index].append([self.snap_ind, val])\\n\\n    def snap(self) -> int:\\n        self.snap_ind += 1\\n        return self.snap_ind - 1\\n        \\n    def get(self, index: int, snap_id: int) -> int:\\n        pos = bisect.bisect_right(self.record[index], [snap_id, float(\\'inf\\')])\\n        return self.record[index][pos - 1][1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.record = [[[0, 0]] for i in range(length)]\\n        self.snap_ind = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        if self.record[index][-1][0] == self.snap_ind:\\n            self.record[index][-1][1] = val\\n        else:\\n            self.record[index].append([self.snap_ind, val])\\n\\n    def snap(self) -> int:\\n        self.snap_ind += 1\\n        return self.snap_ind - 1\\n        \\n    def get(self, index: int, snap_id: int) -> int:\\n        pos = bisect.bisect_right(self.record[index], [snap_id, float(\\'inf\\')])\\n        return self.record[index][pos - 1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374414,
                "title": "c-three-different-solutions-out-of-mem-slow-and-slower-linked-list-and-binary-search",
                "content": "My first attempt was just to make a copy of the limit for each snap. Eventually failed on test 57 with memory list exceeded.\\n\\n```\\npublic class SnapshotArray {\\n\\n    private List<IList<int>> items = new List<IList<int>>();\\n    \\n    public SnapshotArray(int length) {\\n        items.Add(new int[length]);\\n    }\\n    \\n    public void Set(int index, int val) {\\n        items[items.Count - 1][index] = val;\\n    }\\n    \\n    public int Snap() {\\n        var i = items.Count - 1;\\n        items.Add(items[items.Count - 1].ToList());\\n        return i;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        return items[snap_id][index];\\n    }\\n}\\n```\\n\\nSecond attempt was to use a linked list\\n\\n```\\npublic class SnapshotArray {\\n\\n    private IList<Node> items;\\n    private int snapCount = 0;\\n    \\n    public SnapshotArray(int length) {\\n        items = new Node[length];\\n        for (int i = 0; i < items.Count; i++){\\n            items[i] = new Node(0, null, 0);\\n        }\\n    }\\n    \\n    public void Set(int index, int val) {\\n        if (items[index].Index == this.snapCount){\\n            items[index].Value = val;\\n        }\\n        else{\\n            Node n = new Node(val, items[index], snapCount);\\n            items[index] = n;\\n        }\\n    }\\n    \\n    public int Snap() {\\n        snapCount++;\\n        return snapCount - 1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        Node n = items[index];\\n        \\n        while (n.Previous != null){\\n            if (n.Index <= snap_id){\\n                break;\\n            }\\n            \\n            n = n.Previous;\\n        }\\n        \\n        return n.Value;\\n    }\\n    \\n    private class Node {\\n        public Node(int value, Node previous, int index){\\n            this.Value = value;\\n            this.Index = index;\\n            this.Previous = previous;\\n        }\\n        \\n        public int Value { get; set; }\\n        public int Index { get; }\\n        public Node Previous { get ;}\\n    }\\n}\\n```\\n\\nThird attempt was to keep a list of items with index and do a binary search. Much faster the linear search but still under 20%\\n\\n```\\npublic class SnapshotArray {\\n\\n    private IList<Node> items;\\n    private int snapCount = 0;\\n    \\n    public SnapshotArray(int length) {\\n        items = new Node[length];\\n        for (int i = 0; i < items.Count; i++){\\n            items[i] = new Node();\\n        }\\n    }\\n    \\n    public void Set(int index, int val) {\\n        items[index].Set(snapCount, val);\\n    }\\n    \\n    public int Snap() {\\n        ++snapCount;\\n        return snapCount - 1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        return items[index].Get(snap_id);\\n    }\\n    \\n    private class Node {\\n        public Node(){\\n            this.Values = new List<NodeValue>();\\n            this.Values.Add(new NodeValue(0, 0));\\n        }\\n        \\n        public List<NodeValue> Values { get; }\\n        \\n        public int Latest { get => this.Values[this.Values.Count - 1].Index; }\\n        \\n        public void Set(int snap, int value){\\n            if (snap == Latest){\\n                this.Values[this.Values.Count - 1] = new NodeValue(snap, value);\\n            }\\n            else{\\n                this.Values.Add(new NodeValue(snap, value));\\n            }\\n        }\\n        \\n        public int Get(int snap){\\n            int i = this.Values.BinarySearch(new NodeValue(snap, 0), NodeValueComparer.Instance);\\n            \\n            if (i < 0){\\n                i = ~i;\\n                \\n                if (--i < 0){\\n                    i = 0;\\n                }\\n                else if (i >= this.Values.Count){\\n                    i = this.Values.Count - 1;\\n                }\\n            }\\n\\n            return this.Values[i].Value;\\n        }\\n    }\\n    \\n    private class NodeValueComparer : IComparer<NodeValue> {\\n        public static readonly NodeValueComparer Instance = new NodeValueComparer();\\n        \\n        public int Compare(NodeValue x, NodeValue y)\\n        {\\n            return x.Index.CompareTo(y.Index);\\n        }\\n    }\\n\\n    private struct NodeValue {\\n        public NodeValue(int index, int value){\\n            this.Index = index;\\n            this.Value = value;\\n        }\\n        \\n        public int Index { get; }\\n        public int Value { get; }\\n    }\\n}\\n```\\n\\nremoved uneeded class wrapping list, now 65%\\n\\n```\\npublic class SnapshotArray {\\n\\n    private IList<List<NodeValue>> items;\\n    private int snapCount = 0;\\n    \\n    public SnapshotArray(int length) {\\n        items = new List<NodeValue>[length];\\n        for (int i = 0; i < items.Count; i++){\\n            items[i] = new List<NodeValue>();\\n            items[i].Add(new NodeValue(0, 0));\\n        }\\n    }\\n    \\n    public void Set(int index, int val) {\\n        int latest = items[index][items[index].Count - 1].Index;\\n        if (snapCount == latest){\\n            items[index][items[index].Count - 1] = new NodeValue(snapCount, val);\\n        }\\n        else{\\n            items[index].Add(new NodeValue(snapCount, val));\\n        }        \\n    }\\n    \\n    public int Snap() {\\n        ++snapCount;\\n        return snapCount - 1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n                \\n        int i = items[index].BinarySearch(new NodeValue(snap_id, 0), NodeValueComparer.Instance);\\n\\n        if (i < 0){\\n            i = ~i;\\n\\n            if (--i < 0){\\n                i = 0;\\n            }\\n            else if (i >= items[index].Count){\\n                i = items[index].Count - 1;\\n            }\\n        }\\n\\n        return items[index][i].Value;        \\n    }\\n    \\n    private class NodeValueComparer : IComparer<NodeValue> {\\n        public static readonly NodeValueComparer Instance = new NodeValueComparer();\\n        \\n        public int Compare(NodeValue x, NodeValue y)\\n        {\\n            return x.Index.CompareTo(y.Index);\\n        }\\n    }\\n\\n    private struct NodeValue {\\n        public NodeValue(int index, int value){\\n            this.Index = index;\\n            this.Value = value;\\n        }\\n        \\n        public int Index { get; }\\n        public int Value { get; }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class SnapshotArray {\\n\\n    private List<IList<int>> items = new List<IList<int>>();\\n    \\n    public SnapshotArray(int length) {\\n        items.Add(new int[length]);\\n    }\\n    \\n    public void Set(int index, int val) {\\n        items[items.Count - 1][index] = val;\\n    }\\n    \\n    public int Snap() {\\n        var i = items.Count - 1;\\n        items.Add(items[items.Count - 1].ToList());\\n        return i;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        return items[snap_id][index];\\n    }\\n}\\n```\n```\\npublic class SnapshotArray {\\n\\n    private IList<Node> items;\\n    private int snapCount = 0;\\n    \\n    public SnapshotArray(int length) {\\n        items = new Node[length];\\n        for (int i = 0; i < items.Count; i++){\\n            items[i] = new Node(0, null, 0);\\n        }\\n    }\\n    \\n    public void Set(int index, int val) {\\n        if (items[index].Index == this.snapCount){\\n            items[index].Value = val;\\n        }\\n        else{\\n            Node n = new Node(val, items[index], snapCount);\\n            items[index] = n;\\n        }\\n    }\\n    \\n    public int Snap() {\\n        snapCount++;\\n        return snapCount - 1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        Node n = items[index];\\n        \\n        while (n.Previous != null){\\n            if (n.Index <= snap_id){\\n                break;\\n            }\\n            \\n            n = n.Previous;\\n        }\\n        \\n        return n.Value;\\n    }\\n    \\n    private class Node {\\n        public Node(int value, Node previous, int index){\\n            this.Value = value;\\n            this.Index = index;\\n            this.Previous = previous;\\n        }\\n        \\n        public int Value { get; set; }\\n        public int Index { get; }\\n        public Node Previous { get ;}\\n    }\\n}\\n```\n```\\npublic class SnapshotArray {\\n\\n    private IList<Node> items;\\n    private int snapCount = 0;\\n    \\n    public SnapshotArray(int length) {\\n        items = new Node[length];\\n        for (int i = 0; i < items.Count; i++){\\n            items[i] = new Node();\\n        }\\n    }\\n    \\n    public void Set(int index, int val) {\\n        items[index].Set(snapCount, val);\\n    }\\n    \\n    public int Snap() {\\n        ++snapCount;\\n        return snapCount - 1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        return items[index].Get(snap_id);\\n    }\\n    \\n    private class Node {\\n        public Node(){\\n            this.Values = new List<NodeValue>();\\n            this.Values.Add(new NodeValue(0, 0));\\n        }\\n        \\n        public List<NodeValue> Values { get; }\\n        \\n        public int Latest { get => this.Values[this.Values.Count - 1].Index; }\\n        \\n        public void Set(int snap, int value){\\n            if (snap == Latest){\\n                this.Values[this.Values.Count - 1] = new NodeValue(snap, value);\\n            }\\n            else{\\n                this.Values.Add(new NodeValue(snap, value));\\n            }\\n        }\\n        \\n        public int Get(int snap){\\n            int i = this.Values.BinarySearch(new NodeValue(snap, 0), NodeValueComparer.Instance);\\n            \\n            if (i < 0){\\n                i = ~i;\\n                \\n                if (--i < 0){\\n                    i = 0;\\n                }\\n                else if (i >= this.Values.Count){\\n                    i = this.Values.Count - 1;\\n                }\\n            }\\n\\n            return this.Values[i].Value;\\n        }\\n    }\\n    \\n    private class NodeValueComparer : IComparer<NodeValue> {\\n        public static readonly NodeValueComparer Instance = new NodeValueComparer();\\n        \\n        public int Compare(NodeValue x, NodeValue y)\\n        {\\n            return x.Index.CompareTo(y.Index);\\n        }\\n    }\\n\\n    private struct NodeValue {\\n        public NodeValue(int index, int value){\\n            this.Index = index;\\n            this.Value = value;\\n        }\\n        \\n        public int Index { get; }\\n        public int Value { get; }\\n    }\\n}\\n```\n```\\npublic class SnapshotArray {\\n\\n    private IList<List<NodeValue>> items;\\n    private int snapCount = 0;\\n    \\n    public SnapshotArray(int length) {\\n        items = new List<NodeValue>[length];\\n        for (int i = 0; i < items.Count; i++){\\n            items[i] = new List<NodeValue>();\\n            items[i].Add(new NodeValue(0, 0));\\n        }\\n    }\\n    \\n    public void Set(int index, int val) {\\n        int latest = items[index][items[index].Count - 1].Index;\\n        if (snapCount == latest){\\n            items[index][items[index].Count - 1] = new NodeValue(snapCount, val);\\n        }\\n        else{\\n            items[index].Add(new NodeValue(snapCount, val));\\n        }        \\n    }\\n    \\n    public int Snap() {\\n        ++snapCount;\\n        return snapCount - 1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n                \\n        int i = items[index].BinarySearch(new NodeValue(snap_id, 0), NodeValueComparer.Instance);\\n\\n        if (i < 0){\\n            i = ~i;\\n\\n            if (--i < 0){\\n                i = 0;\\n            }\\n            else if (i >= items[index].Count){\\n                i = items[index].Count - 1;\\n            }\\n        }\\n\\n        return items[index][i].Value;        \\n    }\\n    \\n    private class NodeValueComparer : IComparer<NodeValue> {\\n        public static readonly NodeValueComparer Instance = new NodeValueComparer();\\n        \\n        public int Compare(NodeValue x, NodeValue y)\\n        {\\n            return x.Index.CompareTo(y.Index);\\n        }\\n    }\\n\\n    private struct NodeValue {\\n        public NodeValue(int index, int value){\\n            this.Index = index;\\n            this.Value = value;\\n        }\\n        \\n        public int Index { get; }\\n        public int Value { get; }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355439,
                "title": "java-treemap",
                "content": "```java\\nList<TreeMap<Integer, Integer>> L;\\nint snaps = 0;\\n\\npublic SnapshotArray(int n) {\\n\\tL = new ArrayList<>(n);\\n\\tfor (int i = 0; i < n; ++i) {\\n\\t\\tL.add(new TreeMap<>());\\n\\t\\tL.get(i).put(snaps, 0);\\n\\t}\\n}\\n\\npublic void set(int i, int v) {\\n\\tL.get(i).put(snaps, v);\\n}\\n\\npublic int snap() {\\n\\treturn snaps++;\\n}\\n\\npublic int get(int i, int si) {\\n\\treturn L.get(i).floorEntry(si).getValue();\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nList<TreeMap<Integer, Integer>> L;\\nint snaps = 0;\\n\\npublic SnapshotArray(int n) {\\n\\tL = new ArrayList<>(n);\\n\\tfor (int i = 0; i < n; ++i) {\\n\\t\\tL.add(new TreeMap<>());\\n\\t\\tL.get(i).put(snaps, 0);\\n\\t}\\n}\\n\\npublic void set(int i, int v) {\\n\\tL.get(i).put(snaps, v);\\n}\\n\\npublic int snap() {\\n\\treturn snaps++;\\n}\\n\\npublic int get(int i, int si) {\\n\\treturn L.get(i).floorEntry(si).getValue();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350991,
                "title": "dictionary-for-set-and-list-of-dictionary-to-save-snapshots",
                "content": "``` csharp\\npublic class SnapshotArray \\n{\\n    int length;   \\n    int version;\\n    List<Dictionary<int, int>> snaps;\\n    Dictionary<int, int> diffs;\\n        \\n    public SnapshotArray(int length) \\n    {\\n        this.length = length;\\n        diffs = new Dictionary<int, int>(length);\\n        snaps = new List<Dictionary<int, int>>();\\n        version = 0;\\n    }\\n    \\n    public void Set(int index, int val)\\n    {\\n        diffs[index] = val;\\n    }\\n    \\n    public int Snap() \\n    {\\n        snaps.Add(diffs);\\n        version++;\\n        diffs = new Dictionary<int, int>(diffs);\\n        return version - 1;\\n    }\\n    \\n    public int Get(int index, int snap_id) \\n    {        \\n        var snappedDiffs = snaps[snap_id];\\n        if(snappedDiffs.TryGetValue(index, out int value))\\n        {\\n            return value;\\n        }\\n        \\n        return 0;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "``` csharp\\npublic class SnapshotArray \\n{\\n    int length;   \\n    int version;\\n    List<Dictionary<int, int>> snaps;\\n    Dictionary<int, int> diffs;\\n        \\n    public SnapshotArray(int length) \\n    {\\n        this.length = length;\\n        diffs = new Dictionary<int, int>(length);\\n        snaps = new List<Dictionary<int, int>>();\\n        version = 0;\\n    }\\n    \\n    public void Set(int index, int val)\\n    {\\n        diffs[index] = val;\\n    }\\n    \\n    public int Snap() \\n    {\\n        snaps.Add(diffs);\\n        version++;\\n        diffs = new Dictionary<int, int>(diffs);\\n        return version - 1;\\n    }\\n    \\n    public int Get(int index, int snap_id) \\n    {        \\n        var snappedDiffs = snaps[snap_id];\\n        if(snappedDiffs.TryGetValue(index, out int value))\\n        {\\n            return value;\\n        }\\n        \\n        return 0;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633530,
                "title": "c-super-easy-using-vector-hot-and-trending-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SnapshotArray {\\nprivate:\\n    int s_id;\\n    vector<vector<pair<int,int>>> track;\\npublic:\\n    SnapshotArray(int length) {\\n        s_id = 0;\\n        track.resize(length);\\n        for(int i=0; i<length; i++){\\n            track[i].push_back({0,0});\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        track[index].push_back({s_id,val});\\n    }\\n    \\n    int snap() {\\n        return s_id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it = upper_bound(track[index].begin(),track[index].end(),make_pair(snap_id,INT_MAX));\\n        it--;\\n        return it->second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SnapshotArray {\\nprivate:\\n    int s_id;\\n    vector<vector<pair<int,int>>> track;\\npublic:\\n    SnapshotArray(int length) {\\n        s_id = 0;\\n        track.resize(length);\\n        for(int i=0; i<length; i++){\\n            track[i].push_back({0,0});\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        track[index].push_back({s_id,val});\\n    }\\n    \\n    int snap() {\\n        return s_id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it = upper_bound(track[index].begin(),track[index].end(),make_pair(snap_id,INT_MAX));\\n        it--;\\n        return it->second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631671,
                "title": "my-java-solution-without-treemap-98-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SnapshotArray {\\n    List<Info>[] arr;\\n    int snap = 0;\\n    public SnapshotArray(int length) {\\n        arr = new ArrayList[length];\\n    }\\n    \\n    public void set(int index, int val) {\\n        if(arr[index] == null){\\n            arr[index] = new ArrayList<>();\\n        }\\n        int size = arr[index].size();\\n        if(size == 0){\\n            arr[index].add(new Info(val, snap));\\n        }else{\\n            if(arr[index].get(size - 1).snap == snap){\\n                arr[index].get(size - 1).val = val;\\n            }else{\\n                arr[index].add(new Info(val, snap));\\n            }\\n        }\\n    }\\n    \\n    public int snap() {\\n        return snap++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        if(arr[index] == null || arr[index].size() == 0){\\n            return 0;\\n        }\\n        return bs(0, arr[index].size() - 1, index, arr, snap_id);\\n    }\\n\\n    public int bs(int low, int high, int idx, List<Info>[] arr, int target){\\n\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(arr[idx].get(mid).snap == target){\\n                return arr[idx].get(mid).val;\\n            }else if(arr[idx].get(mid).snap < target){\\n                low = mid + 1;\\n            }else{\\n                high = mid - 1;\\n            }\\n        }\\n        if(high < 0){\\n           return 0;\\n        }\\n        return arr[idx].get(high).val;\\n    }\\n\\n    public class Info{\\n        int val;\\n        int snap;\\n\\n        public Info(int val, int snap){\\n            this.val = val;\\n            this.snap = snap;\\n        }\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SnapshotArray {\\n    List<Info>[] arr;\\n    int snap = 0;\\n    public SnapshotArray(int length) {\\n        arr = new ArrayList[length];\\n    }\\n    \\n    public void set(int index, int val) {\\n        if(arr[index] == null){\\n            arr[index] = new ArrayList<>();\\n        }\\n        int size = arr[index].size();\\n        if(size == 0){\\n            arr[index].add(new Info(val, snap));\\n        }else{\\n            if(arr[index].get(size - 1).snap == snap){\\n                arr[index].get(size - 1).val = val;\\n            }else{\\n                arr[index].add(new Info(val, snap));\\n            }\\n        }\\n    }\\n    \\n    public int snap() {\\n        return snap++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        if(arr[index] == null || arr[index].size() == 0){\\n            return 0;\\n        }\\n        return bs(0, arr[index].size() - 1, index, arr, snap_id);\\n    }\\n\\n    public int bs(int low, int high, int idx, List<Info>[] arr, int target){\\n\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(arr[idx].get(mid).snap == target){\\n                return arr[idx].get(mid).val;\\n            }else if(arr[idx].get(mid).snap < target){\\n                low = mid + 1;\\n            }else{\\n                high = mid - 1;\\n            }\\n        }\\n        if(high < 0){\\n           return 0;\\n        }\\n        return arr[idx].get(high).val;\\n    }\\n\\n    public class Info{\\n        int val;\\n        int snap;\\n\\n        public Info(int val, int snap){\\n            this.val = val;\\n            this.snap = snap;\\n        }\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629362,
                "title": "the-length-does-not-matter-at-all",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWell, it is eas to have acccess to any value by key, and of course there is no need to create (occupy) memory of redudant values whgic hwere not changed at all.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsoooo, here we go:\\n\\n1. we create kinda empty object were we keep our indices\\n2. inside of the each index we have another map which maintains [snapId] to [val] mapping\\n3. another important thing is the array of direct sets. this array used for stroring snapshot values but in non-compressed way. It means that we set any value by index and there we may have empty items between of any snap ids.\\n4. the `set` method does pretty straing-forward things:\\n    - get the corresponding index value\\n    - set the value using the runtime `snapshotId`\\n    - set the snapshotId by the same index as its value is (order is maintained + we keep the uniquniess)\\n5. the `sanp` just increase runtime `snapshotId`\\n6. here is the magick inside the `get` method:\\n    - if there is no such index yet -> outcome is 0 (default val)\\n    - if the index exists and value is set by the requesting `snap_id` -> return it\\n    - any greater `snap_id` than the runtime one -> return the latest value of the index\\n    - lastly, we use the `_directSnapIds` array of snapshot ids and we just find the closes behind the requesting `snap_id` and the value would be exactyl what we need.\\n\\nand that\\'s it!\\n\\n# Complexity\\n- Time complexity: n/a\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n/a\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} length\\n */\\nvar SnapshotArray = function(length) {\\n  /*\\n    prototype:\\n    {\\n      [index]: {\\n        _directSnapIds: [0, 1, 8],\\n        [snapId]: val,\\n        0: 0,\\n        1: 5,\\n        2,3,4,5,6,7: is 5 (same as #1),\\n        8: 6,\\n      },\\n      get (snapId = 3) {\\n        return 5; 5 is since snapId=1 till snapId=8\\n      }\\n    }\\n\\n  */\\n  this.arrayLike = {};\\n  this.runtimeSnapShotId = 0;\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} val\\n * @return {void}\\n */\\nSnapshotArray.prototype.set = function(index, val) {\\n  this.arrayLike[index] = this.arrayLike[index] || { _directSnapIds: [], };\\n  this.arrayLike[index][this.runtimeSnapShotId] = val;\\n  this.arrayLike[index]._directSnapIds[this.runtimeSnapShotId] = this.runtimeSnapShotId;\\n};\\n\\n/**\\n * @return {number}\\n */\\nSnapshotArray.prototype.snap = function() {\\n  return this.runtimeSnapShotId++;\\n};\\n\\nSnapshotArray.prototype.reset = function () { this.arrayLike = {}; this.runtimeSnapShotId = 0; }\\n\\n/** \\n * @param {number} index \\n * @param {number} snap_id\\n * @return {number}\\n */\\nSnapshotArray.prototype.get = function(index, snap_id) {\\n\\n  // no index in store -> default 0\\n  if (!(index in this.arrayLike)) { return 0; }\\n\\n  const indexStore = this.arrayLike[index] || { };\\n\\n  // exact match by snap id\\n  if (snap_id in indexStore) {\\n    return indexStore[snap_id];\\n  }\\n\\n  // unknown snap id or greater then the latest one\\n  if (snap_id > indexStore._directSnapIds.at(-1) || snap_id > this.runtimeSnapShotId) {\\n    return indexStore[indexStore._directSnapIds.at(-1)];\\n  }\\n\\n  // get the nearest value of sanpshot\\n  const prevDirectSetSnapId = indexStore._directSnapIds.slice().reverse().find(v => v <= snap_id);\\n  return indexStore[prevDirectSetSnapId] ?? 0;\\n};\\n\\n/** \\n * Your SnapshotArray object will be instantiated and called as such:\\n * var obj = new SnapshotArray(0)\\n * obj.set(index,val)\\n * var param_2 = obj.snap()\\n * var param_3 = obj.get(index,snap_id)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * @param {number} length\\n */\\nvar SnapshotArray = function(length) {\\n  /*\\n    prototype:\\n    {\\n      [index]: {\\n        _directSnapIds: [0, 1, 8],\\n        [snapId]: val,\\n        0: 0,\\n        1: 5,\\n        2,3,4,5,6,7: is 5 (same as #1),\\n        8: 6,\\n      },\\n      get (snapId = 3) {\\n        return 5; 5 is since snapId=1 till snapId=8\\n      }\\n    }\\n\\n  */\\n  this.arrayLike = {};\\n  this.runtimeSnapShotId = 0;\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} val\\n * @return {void}\\n */\\nSnapshotArray.prototype.set = function(index, val) {\\n  this.arrayLike[index] = this.arrayLike[index] || { _directSnapIds: [], };\\n  this.arrayLike[index][this.runtimeSnapShotId] = val;\\n  this.arrayLike[index]._directSnapIds[this.runtimeSnapShotId] = this.runtimeSnapShotId;\\n};\\n\\n/**\\n * @return {number}\\n */\\nSnapshotArray.prototype.snap = function() {\\n  return this.runtimeSnapShotId++;\\n};\\n\\nSnapshotArray.prototype.reset = function () { this.arrayLike = {}; this.runtimeSnapShotId = 0; }\\n\\n/** \\n * @param {number} index \\n * @param {number} snap_id\\n * @return {number}\\n */\\nSnapshotArray.prototype.get = function(index, snap_id) {\\n\\n  // no index in store -> default 0\\n  if (!(index in this.arrayLike)) { return 0; }\\n\\n  const indexStore = this.arrayLike[index] || { };\\n\\n  // exact match by snap id\\n  if (snap_id in indexStore) {\\n    return indexStore[snap_id];\\n  }\\n\\n  // unknown snap id or greater then the latest one\\n  if (snap_id > indexStore._directSnapIds.at(-1) || snap_id > this.runtimeSnapShotId) {\\n    return indexStore[indexStore._directSnapIds.at(-1)];\\n  }\\n\\n  // get the nearest value of sanpshot\\n  const prevDirectSetSnapId = indexStore._directSnapIds.slice().reverse().find(v => v <= snap_id);\\n  return indexStore[prevDirectSetSnapId] ?? 0;\\n};\\n\\n/** \\n * Your SnapshotArray object will be instantiated and called as such:\\n * var obj = new SnapshotArray(0)\\n * obj.set(index,val)\\n * var param_2 = obj.snap()\\n * var param_3 = obj.get(index,snap_id)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3627803,
                "title": "1146-snapshot-array-java",
                "content": "```\\nclass SnapshotArray {\\n    HashMap<Integer,Integer>[] Map;\\n    int id=0;\\n    public SnapshotArray(int length) {\\n        Map=new HashMap[length];\\n        for(int i=0;i<length;i++)\\n            Map[i]=new HashMap <>();\\n    }\\n    \\n    public void set(int index, int val) {\\n        Map[index].put(id,val);\\n    }\\n    \\n    public int snap() {\\n        id++;\\n        return id-1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        while(snap_id>-1 && !Map[index].containsKey(snap_id))\\n        {\\n            snap_id--;\\n            if(snap_id==-1)\\n                return 0;\\n        }\\n        return Map[index].get(snap_id); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SnapshotArray {\\n    HashMap<Integer,Integer>[] Map;\\n    int id=0;\\n    public SnapshotArray(int length) {\\n        Map=new HashMap[length];\\n        for(int i=0;i<length;i++)\\n            Map[i]=new HashMap <>();\\n    }\\n    \\n    public void set(int index, int val) {\\n        Map[index].put(id,val);\\n    }\\n    \\n    public int snap() {\\n        id++;\\n        return id-1;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        while(snap_id>-1 && !Map[index].containsKey(snap_id))\\n        {\\n            snap_id--;\\n            if(snap_id==-1)\\n                return 0;\\n        }\\n        return Map[index].get(snap_id); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626594,
                "title": "easiest-c-solution-using-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all I thought of brute force method to make array for each every snap id but it will take very large storage.\\nSo I used simple unordered map to store each and every snap id as a key and array as the value of the map. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a nordered and store key as a snap id and array as the value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SnapshotArray {\\npublic:\\n    vector<unordered_map<int,int>>A;\\n    int snap_id= -1;\\n\\n    SnapshotArray(int length) {\\n        A.clear();\\n        A=vector<unordered_map<int,int>>(length);\\n        \\n    }\\n    \\n    void set(int index, int val) {\\n        A[index][snap_id]=val;\\n        \\n    }\\n    \\n    int snap() {\\n        snap_id++;\\n        return snap_id;\\n        \\n    }\\n    \\n    int get(int index, int snap_id) {\\n        int temp=snap_id-1;\\n        while(temp>=-1)\\n        {\\n            if(A[index].find(temp)==A[index].end())\\n            {\\n                temp--;\\n            }\\n            else\\n            {\\n                return A[index][temp];\\n            }\\n        }\\n\\n        return 0;\\n\\n        \\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n\\n \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n    vector<unordered_map<int,int>>A;\\n    int snap_id= -1;\\n\\n    SnapshotArray(int length) {\\n        A.clear();\\n        A=vector<unordered_map<int,int>>(length);\\n        \\n    }\\n    \\n    void set(int index, int val) {\\n        A[index][snap_id]=val;\\n        \\n    }\\n    \\n    int snap() {\\n        snap_id++;\\n        return snap_id;\\n        \\n    }\\n    \\n    int get(int index, int snap_id) {\\n        int temp=snap_id-1;\\n        while(temp>=-1)\\n        {\\n            if(A[index].find(temp)==A[index].end())\\n            {\\n                temp--;\\n            }\\n            else\\n            {\\n                return A[index][temp];\\n            }\\n        }\\n\\n        return 0;\\n\\n        \\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626591,
                "title": "solution-deathevil",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SnapshotArray {\\npublic:\\n    vector<unordered_map<int,int>>A;\\n    int snap_id= -1;\\n\\n    SnapshotArray(int length) {\\n        A.clear();\\n        A=vector<unordered_map<int,int>>(length);\\n        \\n    }\\n    \\n    void set(int index, int val) {\\n        A[index][snap_id]=val;\\n        \\n    }\\n    \\n    int snap() {\\n        snap_id++;\\n        return snap_id;\\n        \\n    }\\n    \\n    int get(int index, int snap_id) {\\n        int temp=snap_id-1;\\n        while(temp>=-1)\\n        {\\n            if(A[index].find(temp)==A[index].end())\\n            {\\n                temp--;\\n            }\\n            else\\n            {\\n                return A[index][temp];\\n            }\\n        }\\n\\n        return 0;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n    vector<unordered_map<int,int>>A;\\n    int snap_id= -1;\\n\\n    SnapshotArray(int length) {\\n        A.clear();\\n        A=vector<unordered_map<int,int>>(length);\\n        \\n    }\\n    \\n    void set(int index, int val) {\\n        A[index][snap_id]=val;\\n        \\n    }\\n    \\n    int snap() {\\n        snap_id++;\\n        return snap_id;\\n        \\n    }\\n    \\n    int get(int index, int snap_id) {\\n        int temp=snap_id-1;\\n        while(temp>=-1)\\n        {\\n            if(A[index].find(temp)==A[index].end())\\n            {\\n                temp--;\\n            }\\n            else\\n            {\\n                return A[index][temp];\\n            }\\n        }\\n\\n        return 0;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626425,
                "title": "binary-search-c",
                "content": "# Code\\n```\\nclass SnapshotArray {\\n    int snapId;\\n    vector<vector<pair<int, int>>> history;\\npublic:\\n    SnapshotArray(int length) {\\n        snapId = 0;\\n        history.resize(length);\\n        for(int i=0; i<length; i++){\\n            history[i].push_back({0, 0});\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        history[index].push_back({snapId, val});\\n    }\\n    \\n    int snap() {\\n        return snapId++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it = upper_bound(history[index].begin(), history[index].end(), make_pair(snap_id, INT_MAX));\\n        return prev(it)->second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass SnapshotArray {\\n    int snapId;\\n    vector<vector<pair<int, int>>> history;\\npublic:\\n    SnapshotArray(int length) {\\n        snapId = 0;\\n        history.resize(length);\\n        for(int i=0; i<length; i++){\\n            history[i].push_back({0, 0});\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        history[index].push_back({snapId, val});\\n    }\\n    \\n    int snap() {\\n        return snapId++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it = upper_bound(history[index].begin(), history[index].end(), make_pair(snap_id, INT_MAX));\\n        return prev(it)->second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626304,
                "title": "binary-search-c",
                "content": "```\\nclass SnapshotArray {\\n   vector<vector<pair<int, int>>> v;\\n    int snapCnt = 0;\\npublic:\\n    SnapshotArray(int length) {\\n        for(int i=0; i<length; i++) v.push_back({});\\n    }\\n    \\n    void set(int index, int val) {\\n       v[index].push_back({snapCnt, val});\\n    }\\n    \\n    int snap() {\\n       return ++snapCnt - 1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n       int s = 0, e = v[index].size() - 1, ans;\\n       while(s <= e) {\\n           int m = (s + e) / 2;\\n           if(v[index][m].first <= snap_id) {\\n               ans = v[index][m].second;\\n               s = m + 1;\\n           }\\n           else e = m - 1;\\n       }\\n       return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass SnapshotArray {\\n   vector<vector<pair<int, int>>> v;\\n    int snapCnt = 0;\\npublic:\\n    SnapshotArray(int length) {\\n        for(int i=0; i<length; i++) v.push_back({});\\n    }\\n    \\n    void set(int index, int val) {\\n       v[index].push_back({snapCnt, val});\\n    }\\n    \\n    int snap() {\\n       return ++snapCnt - 1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n       int s = 0, e = v[index].size() - 1, ans;\\n       while(s <= e) {\\n           int m = (s + e) / 2;\\n           if(v[index][m].first <= snap_id) {\\n               ans = v[index][m].second;\\n               s = m + 1;\\n           }\\n           else e = m - 1;\\n       }\\n       return ans;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3626151,
                "title": "c-dictionary-array-binarysearch-beats-100",
                "content": "![image.png](https://assets.leetcode.com/users/images/75a27bb1-4944-4caf-88d5-cf2be79e5001_1686499462.3492978.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry to minimize the time complexity when doing binary search.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore the records in the dictionary with index, so we can treat the dictionary as list but with O(1) random access.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class SnapshotArray\\n{\\n    private readonly Dictionary<int, (int snapId, int val)>[] _snapShots;\\n    private int _snapId;\\n\\n    public SnapshotArray(int length)\\n    {\\n        _snapShots = new Dictionary<int, (int snapId, int val)>[length];\\n    }\\n\\n    public void Set(int index, int val)\\n    {\\n\\n        _snapShots[index] ??= new Dictionary<int, (int snapId, int val)> { { 0, (_snapId,val) } };\\n        var key = _snapShots[index].Count - 1;\\n        if (_snapShots[index][key].snapId == _snapId)\\n        {\\n            _snapShots[index][key] = (_snapId, val);\\n        }\\n        else\\n        {\\n            _snapShots[index].Add(key + 1, (_snapId, val));\\n        }\\n    }\\n\\n    public int Snap()\\n    {\\n        return _snapId++;\\n    }\\n\\n    public int Get(int index, int snapId)\\n    {\\n        if (_snapShots[index] == null) return 0;\\n        var records = _snapShots[index];\\n        var position = BinarySearch(records, snapId);\\n        var record = records[position];\\n        return record.snapId > snapId ? position > 0 ? records[position - 1].val : 0 : record.val;\\n    }\\n\\n    private int BinarySearch(IDictionary<int, (int snapId, int val)> records, int target)\\n    {\\n        var left = 0;\\n        var right = records.Count - 1;\\n        while (left < right)\\n        {\\n            var mid = left + (right - left) / 2;\\n            if (records[mid].snapId == target) return mid;\\n            if (records[mid].snapId < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n\\n        return left;\\n    }\\n}\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.Set(index,val);\\n * int param_2 = obj.Snap();\\n * int param_3 = obj.Get(index,snap_id);\\n */\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class SnapshotArray\\n{\\n    private readonly Dictionary<int, (int snapId, int val)>[] _snapShots;\\n    private int _snapId;\\n\\n    public SnapshotArray(int length)\\n    {\\n        _snapShots = new Dictionary<int, (int snapId, int val)>[length];\\n    }\\n\\n    public void Set(int index, int val)\\n    {\\n\\n        _snapShots[index] ??= new Dictionary<int, (int snapId, int val)> { { 0, (_snapId,val) } };\\n        var key = _snapShots[index].Count - 1;\\n        if (_snapShots[index][key].snapId == _snapId)\\n        {\\n            _snapShots[index][key] = (_snapId, val);\\n        }\\n        else\\n        {\\n            _snapShots[index].Add(key + 1, (_snapId, val));\\n        }\\n    }\\n\\n    public int Snap()\\n    {\\n        return _snapId++;\\n    }\\n\\n    public int Get(int index, int snapId)\\n    {\\n        if (_snapShots[index] == null) return 0;\\n        var records = _snapShots[index];\\n        var position = BinarySearch(records, snapId);\\n        var record = records[position];\\n        return record.snapId > snapId ? position > 0 ? records[position - 1].val : 0 : record.val;\\n    }\\n\\n    private int BinarySearch(IDictionary<int, (int snapId, int val)> records, int target)\\n    {\\n        var left = 0;\\n        var right = records.Count - 1;\\n        while (left < right)\\n        {\\n            var mid = left + (right - left) / 2;\\n            if (records[mid].snapId == target) return mid;\\n            if (records[mid].snapId < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n\\n        return left;\\n    }\\n}\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.Set(index,val);\\n * int param_2 = obj.Snap();\\n * int param_3 = obj.Get(index,snap_id);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626107,
                "title": "c-solution-using-vector-of-map",
                "content": "\\n\\n# Code\\n```\\nclass SnapshotArray {\\npublic:\\n   int snapNo=0;\\n   vector<map<int,int>> ar;\\n\\n    SnapshotArray(int length) {\\n        ar.resize(length);\\n        for(int i=0;i<length;i++){\\n            ar[i][0]=0;\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        \\n        ar[index][snapNo]=val;\\n    }\\n    \\n    int snap() {\\n        snapNo++;\\n        return snapNo-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n    // we will check that if a given snap_id exists in a snapshot\\n    // ar[index] and returns the value associated with that snap_id\\n    //  if found. If the snap_id is not present, it returns the \\n    //  closest value that is less than the snap_id from the\\n    //  previous snapshots.\\n      if(ar[index].find(snap_id)==ar[index].end()){\\n\\n          auto i= --ar[index].lower_bound(snap_id);\\n          return i->second;\\n      }\\n        return ar[index][snap_id];\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n   int snapNo=0;\\n   vector<map<int,int>> ar;\\n\\n    SnapshotArray(int length) {\\n        ar.resize(length);\\n        for(int i=0;i<length;i++){\\n            ar[i][0]=0;\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        \\n        ar[index][snapNo]=val;\\n    }\\n    \\n    int snap() {\\n        snapNo++;\\n        return snapNo-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n    // we will check that if a given snap_id exists in a snapshot\\n    // ar[index] and returns the value associated with that snap_id\\n    //  if found. If the snap_id is not present, it returns the \\n    //  closest value that is less than the snap_id from the\\n    //  previous snapshots.\\n      if(ar[index].find(snap_id)==ar[index].end()){\\n\\n          auto i= --ar[index].lower_bound(snap_id);\\n          return i->second;\\n      }\\n        return ar[index][snap_id];\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625899,
                "title": "1146-snapshot-array",
                "content": "```\\n#include<bits/stdc++.h>\\n\\nclass SnapshotArray {\\npublic:\\n    \\n    int id;\\n    vector<vector<pair<int, int>>>v;\\n\\n    SnapshotArray(int n) {\\n        id =0;\\n        v.resize(n);\\n\\n         for(int i =0; i<n; i++ ){\\n             v[i].push_back({0,0});\\n         }\\n    }\\n    \\n    void set(int index, int val) {\\n        v[index].push_back({id, val});\\n    }\\n    \\n    int snap() {\\n        return id++;\\n    }\\n    \\n    int get(int index, int id) {\\n\\n        auto it = upper_bound(v[index].begin(), v[index].end(), make_pair(id, 1000000001));\\n\\n        it--;\\n\\n        return it->second;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\n\\nclass SnapshotArray {\\npublic:\\n    \\n    int id;\\n    vector<vector<pair<int, int>>>v;\\n\\n    SnapshotArray(int n) {\\n        id =0;\\n        v.resize(n);\\n\\n         for(int i =0; i<n; i++ ){\\n             v[i].push_back({0,0});\\n         }\\n    }\\n    \\n    void set(int index, int val) {\\n        v[index].push_back({id, val});\\n    }\\n    \\n    int snap() {\\n        return id++;\\n    }\\n    \\n    int get(int index, int id) {\\n\\n        auto it = upper_bound(v[index].begin(), v[index].end(), make_pair(id, 1000000001));\\n\\n        it--;\\n\\n        return it->second;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3625588,
                "title": "c-most-detailed-explanation-codestorywithmik",
                "content": "YouTube Link - [Snapshot Array](https://www.youtube.com/watch?v=yEYoNCom72Q)\\nMy Github Treasure - [Snapshot Array](https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Design/Snapshot%20Array.cpp)\\n\\n```\\n//Approach-1 : Brute Force - Store all states of array for all snap ids\\n//You can write it on your own. A very simple one.\\n```\\n\\n```\\n//Approach-2 : Use Own Binary Search - O(nlogn)\\nclass SnapshotArray {\\npublic:\\n    \\n    int snap_id;\\n    \\n    vector<vector<pair<int, int>>> vec;\\n    \\n    SnapshotArray(int length) {\\n        snap_id = 0;\\n        \\n        vec.resize(length);\\n        \\n        for(int i = 0; i < length; i++) {\\n            \\n            vec[i].push_back(make_pair(0, 0));\\n            \\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        \\n        vec[index].push_back(make_pair(snap_id, val));\\n        \\n    }\\n    \\n    int snap() {\\n        return snap_id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        \\n        int l = 0, r = vec[index].size()-1;\\n        \\n        int result = 0;\\n        while(l <= r) {\\n            \\n            int mid = l + (r-l)/2;\\n            \\n            if(vec[index][mid].first <= snap_id) {\\n                result = vec[index][mid].second;\\n                l = mid+1;\\n            } else {\\n                r = mid-1;\\n            }\\n            \\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```\\n\\n\\n```\\n//Approach-3 : Use upper_bound - O(nlogn)\\nclass SnapshotArray {\\npublic:\\n    \\n    int snap_id;\\n    \\n    vector<vector<pair<int, int>>> vec;\\n    \\n    SnapshotArray(int length) {\\n        snap_id = 0;\\n        \\n        vec.resize(length);\\n        \\n        for(int i = 0; i < length; i++) {\\n            \\n            vec[i].push_back(make_pair(0, 0));\\n            \\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        \\n        vec[index].push_back(make_pair(snap_id, val));\\n        \\n    }\\n    \\n    int snap() {\\n        return snap_id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        \\n        auto it = upper_bound(begin(vec[index]), end(vec[index]), make_pair(snap_id, INT_MAX));\\n        //pair(snap_id, val)\\n        \\n        return prev(it)->second;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 : Brute Force - Store all states of array for all snap ids\\n//You can write it on your own. A very simple one.\\n```\n```\\n//Approach-2 : Use Own Binary Search - O(nlogn)\\nclass SnapshotArray {\\npublic:\\n    \\n    int snap_id;\\n    \\n    vector<vector<pair<int, int>>> vec;\\n    \\n    SnapshotArray(int length) {\\n        snap_id = 0;\\n        \\n        vec.resize(length);\\n        \\n        for(int i = 0; i < length; i++) {\\n            \\n            vec[i].push_back(make_pair(0, 0));\\n            \\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        \\n        vec[index].push_back(make_pair(snap_id, val));\\n        \\n    }\\n    \\n    int snap() {\\n        return snap_id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        \\n        int l = 0, r = vec[index].size()-1;\\n        \\n        int result = 0;\\n        while(l <= r) {\\n            \\n            int mid = l + (r-l)/2;\\n            \\n            if(vec[index][mid].first <= snap_id) {\\n                result = vec[index][mid].second;\\n                l = mid+1;\\n            } else {\\n                r = mid-1;\\n            }\\n            \\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```\n```\\n//Approach-3 : Use upper_bound - O(nlogn)\\nclass SnapshotArray {\\npublic:\\n    \\n    int snap_id;\\n    \\n    vector<vector<pair<int, int>>> vec;\\n    \\n    SnapshotArray(int length) {\\n        snap_id = 0;\\n        \\n        vec.resize(length);\\n        \\n        for(int i = 0; i < length; i++) {\\n            \\n            vec[i].push_back(make_pair(0, 0));\\n            \\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        \\n        vec[index].push_back(make_pair(snap_id, val));\\n        \\n    }\\n    \\n    int snap() {\\n        return snap_id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        \\n        auto it = upper_bound(begin(vec[index]), end(vec[index]), make_pair(snap_id, INT_MAX));\\n        //pair(snap_id, val)\\n        \\n        return prev(it)->second;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625423,
                "title": "kotlin-easy-o-log-n-kotlin-solution-using-treemap",
                "content": "# Intuition\\nWe don\\'t need to copy and store full state on each `snap`, we just need to be able to find value set on greatest `snap`, less or equal to `snap_id`.\\n\\n# Approach\\nWe can store each new value in TreeMap for each index in array, so we can `get` value for `snap_id` in `O(log(N))`. We don\\'t need to initialize each element of the array at construction and can just check if entry we found is `null` or not.\\n\\n# Complexity\\n- Time complexity:\\n    - snap: `O(1)`. We just increment `currSnap`\\n    - set: `O(log(N))`. We store each new value to TreeMap\\n    - get: `O(log(N))`. We need to get `floorEntry` from TreeMap\\n\\n- Space complexity:\\n    - We store each new value on `set` to map, so space complexity will be `O(N)`\\n\\n# Code\\n```\\nclass SnapshotArray(length: Int) {\\n    private val array = Array<TreeMap<Int, Int>?>(length) { null }\\n    private var currSnap = 0\\n\\n    fun set(index: Int, `val`: Int) {\\n        if (array[index] == null) {\\n            array[index] = TreeMap()\\n        }\\n        val map = array[index]!!\\n        map[currSnap] = `val`\\n    }\\n\\n    fun snap(): Int {\\n        return currSnap++\\n    }\\n\\n    fun get(index: Int, snap_id: Int): Int {\\n        val entry = array[index]?.floorEntry(snap_id)\\n            ?: return 0\\n        return entry.value\\n    }\\n\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * var obj = SnapshotArray(length)\\n * obj.set(index,`val`)\\n * var param_2 = obj.snap()\\n * var param_3 = obj.get(index,snap_id)\\n */\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass SnapshotArray(length: Int) {\\n    private val array = Array<TreeMap<Int, Int>?>(length) { null }\\n    private var currSnap = 0\\n\\n    fun set(index: Int, `val`: Int) {\\n        if (array[index] == null) {\\n            array[index] = TreeMap()\\n        }\\n        val map = array[index]!!\\n        map[currSnap] = `val`\\n    }\\n\\n    fun snap(): Int {\\n        return currSnap++\\n    }\\n\\n    fun get(index: Int, snap_id: Int): Int {\\n        val entry = array[index]?.floorEntry(snap_id)\\n            ?: return 0\\n        return entry.value\\n    }\\n\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * var obj = SnapshotArray(length)\\n * obj.set(index,`val`)\\n * var param_2 = obj.snap()\\n * var param_3 = obj.get(index,snap_id)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625329,
                "title": "beginner-friendly-java-map-easy-to-understand-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n#  ***Using Map***\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SnapshotArray {\\n    int snapId;\\n    Map<Integer,Integer>[] array;\\n    public SnapshotArray(int length) {\\n        \\n        array=new Map[length];\\n        for( int i=0;i<length;i++){\\n            array[i]=new HashMap<Integer,Integer>();\\n            array[i].put(0,0);\\n        } \\n        snapId=0;\\n    }\\n    \\n    public void set(int index, int val) {     \\n        array[index].put(snapId,val);\\n        \\n    }\\n    \\n    public int snap() {\\n        return snapId++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        while(!array[index].containsKey(snap_id)) snap_id--;\\n        return  array[index].get(snap_id);\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SnapshotArray {\\n    int snapId;\\n    Map<Integer,Integer>[] array;\\n    public SnapshotArray(int length) {\\n        \\n        array=new Map[length];\\n        for( int i=0;i<length;i++){\\n            array[i]=new HashMap<Integer,Integer>();\\n            array[i].put(0,0);\\n        } \\n        snapId=0;\\n    }\\n    \\n    public void set(int index, int val) {     \\n        array[index].put(snapId,val);\\n        \\n    }\\n    \\n    public int snap() {\\n        return snapId++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        while(!array[index].containsKey(snap_id)) snap_id--;\\n        return  array[index].get(snap_id);\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625234,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SnapshotArray {\\npublic:\\nvector<vector<pair<int,int>>> v;\\nint id;\\n    SnapshotArray(int length) {\\n        v=vector<vector<pair<int,int>>>(length,vector<pair<int,int>>(1,{0,0}));\\n        id=0;\\n\\n    }\\n    void set(int index, int val) {\\n        if( v[index][v[index].size()-1].first<id)\\n        v[index].push_back({id,val});\\n        else{\\n            v[index][v[index].size()-1].second=val;\\n        }\\n    }\\n    \\n    int snap() {\\n        int turn=id;\\n        id++;\\n        return turn;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        int low=0,high=v[index].size()-1;\\n        if(v[index][v[index].size()-1].first<=snap_id)return v[index][v[index].size()-1].second;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(v[index][mid].first<=snap_id && v[index][mid+1].first>snap_id)return v[index][mid].second;\\n            if(v[index][mid].first<snap_id)low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:\\nvector<vector<pair<int,int>>> v;\\nint id;\\n    SnapshotArray(int length) {\\n        v=vector<vector<pair<int,int>>>(length,vector<pair<int,int>>(1,{0,0}));\\n        id=0;\\n\\n    }\\n    void set(int index, int val) {\\n        if( v[index][v[index].size()-1].first<id)\\n        v[index].push_back({id,val});\\n        else{\\n            v[index][v[index].size()-1].second=val;\\n        }\\n    }\\n    \\n    int snap() {\\n        int turn=id;\\n        id++;\\n        return turn;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        int low=0,high=v[index].size()-1;\\n        if(v[index][v[index].size()-1].first<=snap_id)return v[index][v[index].size()-1].second;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(v[index][mid].first<=snap_id && v[index][mid+1].first>snap_id)return v[index][mid].second;\\n            if(v[index][mid].first<snap_id)low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625007,
                "title": "simple-hashmap-solution-c",
                "content": "# Code\\n```\\nclass SnapshotArray {\\npublic:\\n    \\n    unordered_map<int, map<int, int>> mp; \\n    int id;\\n    SnapshotArray(int length) {\\n        id = 0;\\n    }\\n    \\n    void set(int index, int val) {\\n        mp[index][id] = val;\\n    }\\n    \\n    int snap() {\\n        return id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(mp.find(index) == mp.end()) return 0;\\n        \\n        // auto itr = upper_bound(mp[index].begin(), mp[index].end(), snap_id);\\n        auto itr = mp[index].upper_bound(snap_id);\\n        if(itr == mp[index].begin()) return 0;\\n        itr = prev(itr);\\n        return itr->second;\\n        \\n        // return mp[index][snap_id];\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n    \\n    unordered_map<int, map<int, int>> mp; \\n    int id;\\n    SnapshotArray(int length) {\\n        id = 0;\\n    }\\n    \\n    void set(int index, int val) {\\n        mp[index][id] = val;\\n    }\\n    \\n    int snap() {\\n        return id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(mp.find(index) == mp.end()) return 0;\\n        \\n        // auto itr = upper_bound(mp[index].begin(), mp[index].end(), snap_id);\\n        auto itr = mp[index].upper_bound(snap_id);\\n        if(itr == mp[index].begin()) return 0;\\n        itr = prev(itr);\\n        return itr->second;\\n        \\n        // return mp[index][snap_id];\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624936,
                "title": "best-python3-solution-100-time-90-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep only necessary things!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse dictionary for current values of array and use list for snapshot. Dictionary is also fine for snapshot.\\n\\nKey here is to save space when taking snapshot. **Use new memory for new snapshot only if it is different from old snapshot.**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ for copying current array to snapshot\\notherwise $$O(1)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(k * n)$$ where k is the number of snapshots taken and n is the number of unique indexes that have been set\\n\\n# Code\\n```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.arr = dict()\\n        self.snapshot = []\\n        self.updated = True\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.arr[index] = val\\n        self.updated = True\\n\\n    def snap(self) -> int:            \\n        if self.updated:\\n            self.snapshot.append({**self.arr})\\n        else:\\n            self.snapshot.append(self.snapshot[-1])\\n        self.updated = False\\n        return len(self.snapshot)-1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        return self.snapshot[snap_id].get(index, 0)\\n\\n\\n# Your SnapshotArray object will be instantiated and called as such:\\n# obj = SnapshotArray(length)\\n# obj.set(index,val)\\n# param_2 = obj.snap()\\n# param_3 = obj.get(index,snap_id)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.arr = dict()\\n        self.snapshot = []\\n        self.updated = True\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.arr[index] = val\\n        self.updated = True\\n\\n    def snap(self) -> int:            \\n        if self.updated:\\n            self.snapshot.append({**self.arr})\\n        else:\\n            self.snapshot.append(self.snapshot[-1])\\n        self.updated = False\\n        return len(self.snapshot)-1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        return self.snapshot[snap_id].get(index, 0)\\n\\n\\n# Your SnapshotArray object will be instantiated and called as such:\\n# obj = SnapshotArray(length)\\n# obj.set(index,val)\\n# param_2 = obj.snap()\\n# param_3 = obj.get(index,snap_id)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624872,
                "title": "ruby-solution",
                "content": "# Code\\n```ruby []\\nclass SnapshotArray\\n\\n=begin\\n  :type length: Integer\\n=end\\n  def initialize(length)\\n    @current_snapshot_id = 0\\n    @arr = Array.new(length) { [[-1, 0]]}\\n  end\\n\\n\\n=begin\\n  :type index: Integer\\n  :type val: Integer\\n  :rtype: Void\\n=end\\n  def set(index, val)\\n    @arr[index] << [@current_snapshot_id, val]\\n  end\\n\\n\\n=begin\\n  :rtype: Integer\\n=end\\n  def snap()\\n    @current_snapshot_id += 1\\n    @current_snapshot_id - 1\\n  end\\n\\n\\n=begin\\n  :type index: Integer\\n  :type snap_id: Integer\\n  :rtype: Integer\\n=end\\n  def get(index, snap_id)\\n    snap_index = (@arr[index].bsearch_index {|saved_snapshot_id, _| saved_snapshot_id > snap_id } || @arr[index].size) - 1\\n    @arr[index][snap_index].last\\n  end\\n\\n\\nend\\n\\n# Your SnapshotArray object will be instantiated and called as such:\\n# obj = SnapshotArray.new(length)\\n# obj.set(index, val)\\n# param_2 = obj.snap()\\n# param_3 = obj.get(index, snap_id)\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby []\\nclass SnapshotArray\\n\\n=begin\\n  :type length: Integer\\n=end\\n  def initialize(length)\\n    @current_snapshot_id = 0\\n    @arr = Array.new(length) { [[-1, 0]]}\\n  end\\n\\n\\n=begin\\n  :type index: Integer\\n  :type val: Integer\\n  :rtype: Void\\n=end\\n  def set(index, val)\\n    @arr[index] << [@current_snapshot_id, val]\\n  end\\n\\n\\n=begin\\n  :rtype: Integer\\n=end\\n  def snap()\\n    @current_snapshot_id += 1\\n    @current_snapshot_id - 1\\n  end\\n\\n\\n=begin\\n  :type index: Integer\\n  :type snap_id: Integer\\n  :rtype: Integer\\n=end\\n  def get(index, snap_id)\\n    snap_index = (@arr[index].bsearch_index {|saved_snapshot_id, _| saved_snapshot_id > snap_id } || @arr[index].size) - 1\\n    @arr[index][snap_index].last\\n  end\\n\\n\\nend\\n\\n# Your SnapshotArray object will be instantiated and called as such:\\n# obj = SnapshotArray.new(length)\\n# obj.set(index, val)\\n# param_2 = obj.snap()\\n# param_3 = obj.get(index, snap_id)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624842,
                "title": "c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n logn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class SnapshotArray {\\n\\n    public List<List<(int, int)>> List;\\n\\n    public int CurrentSnap = 0;\\n\\n    public SnapshotArray(int length) {\\n        List = new List<List<(int, int)>>(length);\\n        for (int i = 0; i < length; i++)\\n        {\\n            List.Add(new List<(int, int)>());\\n            List[i].Add((0, 0));\\n        }\\n    }\\n    \\n    public void Set(int index, int val) {\\n        List[index].Add((CurrentSnap, val));\\n    }\\n    \\n    public int Snap() {\\n        CurrentSnap++;\\n        return CurrentSnap - 1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        var values = List[index];\\n\\n        // find max snapshot, which is <= snap_id\\n\\n        var l = 0;\\n        var r = values.Count - 1;\\n        while (l < r)\\n        {\\n            var mid = (l + r + 1) / 2;\\n            if (values[mid].Item1 <= snap_id)\\n            {\\n                l = mid;\\n            }\\n            else\\n            {\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return values[l].Item2;\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.Set(index,val);\\n * int param_2 = obj.Snap();\\n * int param_3 = obj.Get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class SnapshotArray {\\n\\n    public List<List<(int, int)>> List;\\n\\n    public int CurrentSnap = 0;\\n\\n    public SnapshotArray(int length) {\\n        List = new List<List<(int, int)>>(length);\\n        for (int i = 0; i < length; i++)\\n        {\\n            List.Add(new List<(int, int)>());\\n            List[i].Add((0, 0));\\n        }\\n    }\\n    \\n    public void Set(int index, int val) {\\n        List[index].Add((CurrentSnap, val));\\n    }\\n    \\n    public int Snap() {\\n        CurrentSnap++;\\n        return CurrentSnap - 1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        var values = List[index];\\n\\n        // find max snapshot, which is <= snap_id\\n\\n        var l = 0;\\n        var r = values.Count - 1;\\n        while (l < r)\\n        {\\n            var mid = (l + r + 1) / 2;\\n            if (values[mid].Item1 <= snap_id)\\n            {\\n                l = mid;\\n            }\\n            else\\n            {\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return values[l].Item2;\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.Set(index,val);\\n * int param_2 = obj.Snap();\\n * int param_3 = obj.Get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624665,
                "title": "c-easy-binary-search",
                "content": "## Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo store the array elements in the least possible space, a list of lists is the ideal approach. To increase the efficiency of the searching algorithm (particularly the ```get()``` function), use binary search.\\nThis approach uses a map to increase the efficiency of the searching (indexing) process. You can use a ```vector<vector<pair<int,int>>>``` as well for the same purpose.\\n\\n## Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a list of lists of pairs of integers (done here using ```map<int,vector<pair<int,int>>>```) to store the elements and the corresponding snap_id for each change introduced to the elements.\\n2. Initialise a variable, ```sn```, to store the latest snap_id.\\n3. For the constructor, push a new pair ```{0,0}``` to each list in the parent list.\\n4. For the ```set()``` function, corresponding to the given index, check if the last entry corresponds to the current snap:\\n    - If yes, the value previously stored (i.e. the last element of ```m[index]```) is not important and can be erased. So overwrite the element entry to store the new value.\\n    - Else, push a new value, ```{value,sn}``` to the list corresponding to index (i.e. ```m[index]```).\\n5. For the ```snap()``` function, return ```sn``` and increment it by 1.\\n6. For the ```get()``` function:\\n    - If the first element ```m[index]``` corresponds to the required ```snap_id``` then return ```m[index][0].first```\\n    - Else, perform a binary search on the list ```m[index]``` and find the element corresponding to the required ```snap_id``` as either ```m[index][i].second==snap_id```, or ```m[index][i].second<snap_id && m[index][i+1].second>snap_id```.\\n    - If the binary search terminates without finding the required element, return ```m[index][m.size()-1].first``` i.e. the last element of the list corresponding to ```index``` (since this means that the element has not been updated between the last snap and this snap).\\n\\n## Complexity\\n- Time complexity: *O(log(length))*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(length.sn)*\\n*(Here sn represents the highest snap_id)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```cpp []\\n/*\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n*/\\n\\nclass SnapshotArray {\\n    map<int,vector<pair<int,int>>> m;\\n    int sn = 0;\\npublic:\\n    SnapshotArray(int length) {\\n        for(int i=0; i<length; i++) m[i].push_back({0,sn});\\n    }\\n    \\n    void set(int index, int val) {\\n        if(m[index][m[index].size()-1].second==sn)\\n            m[index][m[index].size()-1].first = val;\\n        else\\n            m[index].push_back({val,sn});\\n    }\\n    \\n    int snap() {\\n        return sn++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(m[index].size()==1 || m[index][0].second==snap_id)\\n            return m[index][0].first;\\n        \\n        int l = 0, r = m[index].size()-1;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(mid==m[index].size()-1)\\n                return m[index][m[index].size()-1].first;\\n            if(m[index][mid].second<=snap_id && m[index][mid+1].second>snap_id)\\n                return m[index][mid].first;\\n            else if(m[index][mid].second>snap_id)\\n                r = mid-1;\\n            else\\n                l = mid+1;\\n        }\\n\\n        return m[index][m[index].size()-1].first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Design"
                ],
                "code": "```get()```\n```vector<vector<pair<int,int>>>```\n```map<int,vector<pair<int,int>>>```\n```sn```\n```{0,0}```\n```set()```\n```m[index]```\n```{value,sn}```\n```m[index]```\n```snap()```\n```sn```\n```get()```\n```m[index]```\n```snap_id```\n```m[index][0].first```\n```m[index]```\n```snap_id```\n```m[index][i].second==snap_id```\n```m[index][i].second<snap_id && m[index][i+1].second>snap_id```\n```m[index][m.size()-1].first```\n```index```\n```cpp []\\n/*\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n*/\\n\\nclass SnapshotArray {\\n    map<int,vector<pair<int,int>>> m;\\n    int sn = 0;\\npublic:\\n    SnapshotArray(int length) {\\n        for(int i=0; i<length; i++) m[i].push_back({0,sn});\\n    }\\n    \\n    void set(int index, int val) {\\n        if(m[index][m[index].size()-1].second==sn)\\n            m[index][m[index].size()-1].first = val;\\n        else\\n            m[index].push_back({val,sn});\\n    }\\n    \\n    int snap() {\\n        return sn++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(m[index].size()==1 || m[index][0].second==snap_id)\\n            return m[index][0].first;\\n        \\n        int l = 0, r = m[index].size()-1;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(mid==m[index].size()-1)\\n                return m[index][m[index].size()-1].first;\\n            if(m[index][mid].second<=snap_id && m[index][mid+1].second>snap_id)\\n                return m[index][mid].first;\\n            else if(m[index][mid].second>snap_id)\\n                r = mid-1;\\n            else\\n                l = mid+1;\\n        }\\n\\n        return m[index][m[index].size()-1].first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624612,
                "title": "rust-binary-search",
                "content": "# Code\\n```\\nstruct SnapshotArray {\\n    history: Vec<Vec<(i32, i32)>>,\\n    cur_snap: i32,\\n}\\n\\n/**\\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl SnapshotArray {\\n    fn new(length: i32) -> Self {\\n        let mut history = vec![vec![(0, 0)]; length as usize];\\n        Self {\\n            history,\\n            cur_snap: 0,\\n        }\\n    }\\n\\n    fn set(&mut self, index: i32, val: i32) {\\n        if self.history[index as usize].last().unwrap().0 == self.cur_snap {\\n            self.history[index as usize].pop();\\n        }\\n        self.history[index as usize].push((self.cur_snap, val));\\n    }\\n\\n    fn snap(&mut self) -> i32 {\\n        self.cur_snap += 1;\\n        return self.cur_snap - 1;\\n    }\\n\\n    fn get(&self, index: i32, snap_id: i32) -> i32 {\\n        let res = self.history[index as usize].binary_search(&(snap_id, i32::MAX));\\n        match res {\\n            Ok(pos) => self.history[index as usize][pos].1,\\n            Err(pos) => self.history[index as usize][pos - 1].1\\n        }\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * let obj = SnapshotArray::new(length);\\n * obj.set(index, val);\\n * let ret_2: i32 = obj.snap();\\n * let ret_3: i32 = obj.get(index, snap_id);\\n */\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct SnapshotArray {\\n    history: Vec<Vec<(i32, i32)>>,\\n    cur_snap: i32,\\n}\\n\\n/**\\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl SnapshotArray {\\n    fn new(length: i32) -> Self {\\n        let mut history = vec![vec![(0, 0)]; length as usize];\\n        Self {\\n            history,\\n            cur_snap: 0,\\n        }\\n    }\\n\\n    fn set(&mut self, index: i32, val: i32) {\\n        if self.history[index as usize].last().unwrap().0 == self.cur_snap {\\n            self.history[index as usize].pop();\\n        }\\n        self.history[index as usize].push((self.cur_snap, val));\\n    }\\n\\n    fn snap(&mut self) -> i32 {\\n        self.cur_snap += 1;\\n        return self.cur_snap - 1;\\n    }\\n\\n    fn get(&self, index: i32, snap_id: i32) -> i32 {\\n        let res = self.history[index as usize].binary_search(&(snap_id, i32::MAX));\\n        match res {\\n            Ok(pos) => self.history[index as usize][pos].1,\\n            Err(pos) => self.history[index as usize][pos - 1].1\\n        }\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * let obj = SnapshotArray::new(length);\\n * obj.set(index, val);\\n * let ret_2: i32 = obj.snap();\\n * let ret_3: i32 = obj.get(index, snap_id);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3624443,
                "title": "snapshot-array-java-using-tree-map-easy-to-understand-beats-69-9",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply follow the question accordingly.. whatever we have to implement in a function.. Mapping is a perfect choice but which one? That\\'s your presence of mind.\\uD83E\\uDD2F\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDefined a TreeMap where we can store key-val pair in a sorting order. Approach for following functions are:\\n\\n    SnapshotArray(int length) function all value upto length with value (0,0);\\n\\n    In set(index, val) function simply using TreeMap method put to set value at a particular index.\\n\\n    In snap() returned the incremented value snap_id++;\\n\\n    Int get(index, snap_id) function returned the flootEntry of snap_id from the desired index value.. \\n\\n**floorEntry(): It returns a key-value mapping associated with the greatest key less than or equal to the given key, or null if there is no such key.**\\n(POV: Review code for more clearity)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n^2)\\n**Thank You For reviewing my code... PLEASE UPVOTE!\\uD83D\\uDC40**\\n\\n# Code\\n```\\nclass SnapshotArray {\\n    private int snap_id;\\n    private TreeMap<Integer,Integer>[] snapshotArray;\\n\\n    public SnapshotArray(int length) {\\n        snap_id = 0;\\n        snapshotArray = new TreeMap[length];\\n        for(int i=0; i<length; i++){\\n            snapshotArray[i]=new TreeMap<>();\\n            snapshotArray[i].put(0,0);\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        snapshotArray[index].put(snap_id,val);\\n    }\\n    \\n    public int snap() {\\n        return snap_id++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        return snapshotArray[index].floorEntry(snap_id).getValue();\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass SnapshotArray {\\n    private int snap_id;\\n    private TreeMap<Integer,Integer>[] snapshotArray;\\n\\n    public SnapshotArray(int length) {\\n        snap_id = 0;\\n        snapshotArray = new TreeMap[length];\\n        for(int i=0; i<length; i++){\\n            snapshotArray[i]=new TreeMap<>();\\n            snapshotArray[i].put(0,0);\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        snapshotArray[index].put(snap_id,val);\\n    }\\n    \\n    public int snap() {\\n        return snap_id++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        return snapshotArray[index].floorEntry(snap_id).getValue();\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624317,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SnapshotArray {\\npublic:\\n    vector<map<int,int>> v;\\n    int sid, n;\\n    SnapshotArray(int length) {\\n        sid = 0;\\n        n = length;\\n        v.resize(5*1e4);\\n    }\\n    \\n    void set(int index, int val) {\\n        v[sid][index]=val;\\n    }\\n    \\n    int snap() {\\n        return sid++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        for(int i = snap_id; i >= 0; --i){\\n            if(v[i].count(index)) return v[i][index];\\n        }\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n    vector<map<int,int>> v;\\n    int sid, n;\\n    SnapshotArray(int length) {\\n        sid = 0;\\n        n = length;\\n        v.resize(5*1e4);\\n    }\\n    \\n    void set(int index, int val) {\\n        v[sid][index]=val;\\n    }\\n    \\n    int snap() {\\n        return sid++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        for(int i = snap_id; i >= 0; --i){\\n            if(v[i].count(index)) return v[i][index];\\n        }\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624115,
                "title": "c-i-learned-and-then-wrote",
                "content": "\\n# Code\\n```\\nclass SnapshotArray {\\npublic:\\n  int snapId;\\n  vector<vector<pair<int,int>>>history;\\n    SnapshotArray(int length) {\\n        history.resize(length);\\n        snapId=0;\\n        for(int i=0;i<length;i++){\\n            history[i].push_back({0,0});\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        history[index].push_back({snapId,val});\\n    }\\n    \\n    int snap() {\\n       return snapId++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it=upper_bound(history[index].begin(),history[index].end(),make_pair(snap_id,INT_MAX));\\n        return prev(it)->second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Design"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n  int snapId;\\n  vector<vector<pair<int,int>>>history;\\n    SnapshotArray(int length) {\\n        history.resize(length);\\n        snapId=0;\\n        for(int i=0;i<length;i++){\\n            history[i].push_back({0,0});\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        history[index].push_back({snapId,val});\\n    }\\n    \\n    int snap() {\\n       return snapId++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        auto it=upper_bound(history[index].begin(),history[index].end(),make_pair(snap_id,INT_MAX));\\n        return prev(it)->second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624050,
                "title": "best-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SnapshotArray {\\n\\n TreeMap<Integer, Integer>[] snapshotArray;\\n int snap_id;\\n\\n public SnapshotArray(int length) {\\n     this.snapshotArray = new TreeMap[length];\\n     this.snap_id = 0;\\n     for (int i = 0; i < length; i++) {\\n         snapshotArray[i] = new TreeMap<>();\\n         snapshotArray[i].put(0, 0);\\n     }\\n }\\n\\n public void set(int index, int val) {\\n     snapshotArray[index].put(snap_id, val);\\n }\\n\\n public int snap() {\\n     return snap_id++;\\n }\\n\\n public int get(int index, int snap_id) {\\n     return snapshotArray[index].floorEntry(snap_id).getValue();\\n }\\n}\\n\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SnapshotArray {\\n\\n TreeMap<Integer, Integer>[] snapshotArray;\\n int snap_id;\\n\\n public SnapshotArray(int length) {\\n     this.snapshotArray = new TreeMap[length];\\n     this.snap_id = 0;\\n     for (int i = 0; i < length; i++) {\\n         snapshotArray[i] = new TreeMap<>();\\n         snapshotArray[i].put(0, 0);\\n     }\\n }\\n\\n public void set(int index, int val) {\\n     snapshotArray[index].put(snap_id, val);\\n }\\n\\n public int snap() {\\n     return snap_id++;\\n }\\n\\n public int get(int index, int snap_id) {\\n     return snapshotArray[index].floorEntry(snap_id).getValue();\\n }\\n}\\n\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623754,
                "title": "explained-solution",
                "content": "\\n\\n# Approach\\nThis implementation uses a vector of unordered maps called snapshots to store the snapshots for each index. Each map represents a snapshot, where the key is the snapshot id and the value is the value at that snapshot. We also have a snapId variable to keep track of the total number of snapshots taken.\\n\\nIn the set function, we update the value for the given index in the current snapshot (identified by snapId).\\n\\nThe snap function increments the snapId and returns the previous snapId value, which represents the snapshot id.\\n\\nIn the get function, we iterate backward from the given snap_id until we find the closest previous snapshot for the given index. If no previous snapshot is found, we return 0. Otherwise, we return the value stored in the snapshot.\\n\\n\\n\\n# Code\\n```\\nclass SnapshotArray {\\nprivate:\\n    std::vector<std::unordered_map<int, int>> snapshots;\\n    int snapId;\\n    \\npublic:\\n    SnapshotArray(int length) {\\n        snapshots.resize(length);\\n        snapId = 0;\\n    }\\n    \\n    void set(int index, int val) {\\n        snapshots[index][snapId] = val;\\n    }\\n    \\n    int snap() {\\n        return snapId++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        // Find the closest previous snapshot for the given index\\n        while (snap_id >= 0 && snapshots[index].find(snap_id) == snapshots[index].end()) {\\n            snap_id--;\\n        }\\n        \\n        // If no previous snapshot found, return 0\\n        if (snap_id < 0) {\\n            return 0;\\n        }\\n        \\n        return snapshots[index][snap_id];\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass SnapshotArray {\\nprivate:\\n    std::vector<std::unordered_map<int, int>> snapshots;\\n    int snapId;\\n    \\npublic:\\n    SnapshotArray(int length) {\\n        snapshots.resize(length);\\n        snapId = 0;\\n    }\\n    \\n    void set(int index, int val) {\\n        snapshots[index][snapId] = val;\\n    }\\n    \\n    int snap() {\\n        return snapId++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        // Find the closest previous snapshot for the given index\\n        while (snap_id >= 0 && snapshots[index].find(snap_id) == snapshots[index].end()) {\\n            snap_id--;\\n        }\\n        \\n        // If no previous snapshot found, return 0\\n        if (snap_id < 0) {\\n            return 0;\\n        }\\n        \\n        return snapshots[index][snap_id];\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623746,
                "title": "rust-search",
                "content": "```\\nstruct SnapshotArray {\\n    snap_id: i32,\\n    snap: Vec<Vec<(i32, i32)>>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl SnapshotArray {\\n\\n    fn new(length: i32) -> Self {\\n        Self {\\n            snap_id: 0,\\n            snap: vec![vec![(0, 0)]; length as usize],\\n        }\\n    }\\n    \\n    fn set(&mut self, index: i32, val: i32) {\\n        self.snap[index as usize].push((self.snap_id, val));\\n    }\\n    \\n    fn snap(&mut self) -> i32 {\\n        let n = self.snap_id;\\n        self.snap_id += 1;\\n        n\\n    }\\n    \\n    fn get(&self, index: i32, snap_id: i32) -> i32 {\\n        let a: &Vec<(i32, i32)> = self.snap[index as usize].as_ref();\\n        let mut l = 0;\\n        let mut r = a.len();\\n        while l < r {\\n            let mid = l + ((r - l) >> 1);\\n            if a[mid].0 <= snap_id {\\n                l = mid + 1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        a[l - 1].1\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * let obj = SnapshotArray::new(length);\\n * obj.set(index, val);\\n * let ret_2: i32 = obj.snap();\\n * let ret_3: i32 = obj.get(index, snap_id);\\n */\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct SnapshotArray {\\n    snap_id: i32,\\n    snap: Vec<Vec<(i32, i32)>>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl SnapshotArray {\\n\\n    fn new(length: i32) -> Self {\\n        Self {\\n            snap_id: 0,\\n            snap: vec![vec![(0, 0)]; length as usize],\\n        }\\n    }\\n    \\n    fn set(&mut self, index: i32, val: i32) {\\n        self.snap[index as usize].push((self.snap_id, val));\\n    }\\n    \\n    fn snap(&mut self) -> i32 {\\n        let n = self.snap_id;\\n        self.snap_id += 1;\\n        n\\n    }\\n    \\n    fn get(&self, index: i32, snap_id: i32) -> i32 {\\n        let a: &Vec<(i32, i32)> = self.snap[index as usize].as_ref();\\n        let mut l = 0;\\n        let mut r = a.len();\\n        while l < r {\\n            let mid = l + ((r - l) >> 1);\\n            if a[mid].0 <= snap_id {\\n                l = mid + 1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        a[l - 1].1\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * let obj = SnapshotArray::new(length);\\n * obj.set(index, val);\\n * let ret_2: i32 = obj.snap();\\n * let ret_3: i32 = obj.get(index, snap_id);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3623739,
                "title": "c-map-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SnapshotArray {\\npublic:vector<map<int,int>>v;\\nint s=0;\\n    SnapshotArray(int length) {\\n        v.resize(length);\\n\\n        for(int i=0;i<length;i++){\\n            v[i][0]=0;\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        v[index][s]=val;\\n    }\\n    \\n    int snap() {\\n        s++;\\n       return s-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(v[index].find(snap_id)==v[index].end()){\\n            auto it= --v[index].lower_bound(snap_id);\\n            return it->second;\\n        }\\n        return v[index][snap_id];\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Design"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:vector<map<int,int>>v;\\nint s=0;\\n    SnapshotArray(int length) {\\n        v.resize(length);\\n\\n        for(int i=0;i<length;i++){\\n            v[i][0]=0;\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        v[index][s]=val;\\n    }\\n    \\n    int snap() {\\n        s++;\\n       return s-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(v[index].find(snap_id)==v[index].end()){\\n            auto it= --v[index].lower_bound(snap_id);\\n            return it->second;\\n        }\\n        return v[index][snap_id];\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623729,
                "title": "easy-solution-java",
                "content": "\\n\\n# Code\\n```\\nclass SnapshotArray {\\n    TreeMap<Integer, Integer>[] A;\\n    int snap_id = 0;\\n    public SnapshotArray(int length) {\\n        A = new TreeMap[length];\\n        for(int i=0;i<length;i++){\\n            A[i]=new TreeMap<Integer,Integer>();\\n            A[i].put(0,0);\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        A[index].put(snap_id,val);\\n    }\\n    \\n    public int snap() {\\n        return snap_id++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        return A[index].floorEntry(snap_id).getValue();\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SnapshotArray {\\n    TreeMap<Integer, Integer>[] A;\\n    int snap_id = 0;\\n    public SnapshotArray(int length) {\\n        A = new TreeMap[length];\\n        for(int i=0;i<length;i++){\\n            A[i]=new TreeMap<Integer,Integer>();\\n            A[i].put(0,0);\\n        }\\n    }\\n    \\n    public void set(int index, int val) {\\n        A[index].put(snap_id,val);\\n    }\\n    \\n    public int snap() {\\n        return snap_id++;\\n    }\\n    \\n    public int get(int index, int snap_id) {\\n        return A[index].floorEntry(snap_id).getValue();\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.set(index,val);\\n * int param_2 = obj.snap();\\n * int param_3 = obj.get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623703,
                "title": "python-3-pretty-production-ready-solution",
                "content": "\\n\\n# Code\\n```\\nfrom dataclasses import dataclass\\n\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.arr = [VersionedItem(0) for _ in range(length)]\\n        self.cur_snapshot = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.arr[index].set(self.cur_snapshot, val)\\n\\n    def snap(self) -> int:\\n        self.cur_snapshot += 1\\n        return self.cur_snapshot - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        return self.arr[index].get(snap_id)\\n\\n\\nclass VersionedItem:\\n    def __init__(self, init_value: int):\\n        self.snapshots = [Item(-1, init_value)]\\n    \\n    def get(self, snapshot_id):\\n        l = 0\\n        r = len(self.snapshots)\\n        while r - l > 1:\\n            m = l + (r - l) // 2\\n            if self.snapshots[m].snapshot_id <= snapshot_id:\\n                l = m\\n            else:\\n                r = m\\n        return self.snapshots[l].value\\n    \\n    def set(self, snapshot_id, value):\\n        self.snapshots.append(Item(snapshot_id, value))\\n\\n\\n@dataclass\\nclass Item:\\n    snapshot_id: int\\n    value: int\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\n  - `set` \\u2014 $O(1)$\\n  - `snap` \\u2014 $O(1)$\\n  - `get` \\u2014 $O(\\\\log n)$\\n\\n- Space complexity: $O(n)$",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom dataclasses import dataclass\\n\\nclass SnapshotArray:\\n    def __init__(self, length: int):\\n        self.arr = [VersionedItem(0) for _ in range(length)]\\n        self.cur_snapshot = 0\\n\\n    def set(self, index: int, val: int) -> None:\\n        self.arr[index].set(self.cur_snapshot, val)\\n\\n    def snap(self) -> int:\\n        self.cur_snapshot += 1\\n        return self.cur_snapshot - 1\\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        return self.arr[index].get(snap_id)\\n\\n\\nclass VersionedItem:\\n    def __init__(self, init_value: int):\\n        self.snapshots = [Item(-1, init_value)]\\n    \\n    def get(self, snapshot_id):\\n        l = 0\\n        r = len(self.snapshots)\\n        while r - l > 1:\\n            m = l + (r - l) // 2\\n            if self.snapshots[m].snapshot_id <= snapshot_id:\\n                l = m\\n            else:\\n                r = m\\n        return self.snapshots[l].value\\n    \\n    def set(self, snapshot_id, value):\\n        self.snapshots.append(Item(snapshot_id, value))\\n\\n\\n@dataclass\\nclass Item:\\n    snapshot_id: int\\n    value: int\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623687,
                "title": "python3-solution",
                "content": "\\n```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.array=[[[-1,0]] for _ in range(length)]\\n        self.snap_id=0\\n        \\n        \\n\\n    def set(self, index: int, val: int) -> None:\\n        self.array[index].append([self.snap_id,val])\\n\\n    def snap(self) -> int:\\n        self.snap_id+=1\\n        return self.snap_id-1\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        i=bisect.bisect(self.array[index],[snap_id+1])-1\\n        return self.array[index][i][1]       \\n\\n\\n# Your SnapshotArray object will be instantiated and called as such:\\n# obj = SnapshotArray(length)\\n# obj.set(index,val)\\n# param_2 = obj.snap()\\n# param_3 = obj.get(index,snap_id)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass SnapshotArray:\\n\\n    def __init__(self, length: int):\\n        self.array=[[[-1,0]] for _ in range(length)]\\n        self.snap_id=0\\n        \\n        \\n\\n    def set(self, index: int, val: int) -> None:\\n        self.array[index].append([self.snap_id,val])\\n\\n    def snap(self) -> int:\\n        self.snap_id+=1\\n        return self.snap_id-1\\n        \\n\\n    def get(self, index: int, snap_id: int) -> int:\\n        i=bisect.bisect(self.array[index],[snap_id+1])-1\\n        return self.array[index][i][1]       \\n\\n\\n# Your SnapshotArray object will be instantiated and called as such:\\n# obj = SnapshotArray(length)\\n# obj.set(index,val)\\n# param_2 = obj.snap()\\n# param_3 = obj.get(index,snap_id)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623683,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe SnapshotArray class is an implementation of an array that supports snapshots and versioning. The __init__ method initializes the array with n elements, each element being a list containing a tuple representing the first snapshot (-1) and its corresponding value (0).\\n\\nThe set method updates the value of an element at a particular index by appending a new tuple to the list at that index. The tuple contains the current snapshot id and the new value.\\n\\nThe snap method takes a snapshot of the array and returns the id of the snapshot. The id is incremented by 1 every time a new snapshot is taken.\\n\\nThe get method retrieves the value of an element at a particular index at a specific snapshot id. It uses the bisect module to find the correct position in the list of tuples for the given snapshot id, then returns the value associated with that snapshot.\\n\\nBy using this implementation, we can efficiently store and retrieve multiple versions/snapshots of an array without having to create a new copy of the entire array for each snapshot. This can be useful in scenarios where we need to keep track of changes made to an array over time or maintain a history of past states of an array.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe approach to implementing the SnapshotArray class involves maintaining a list of lists where each inner list represents the history of an element in the array. Each tuple stored in the inner list contains information about a particular snapshot, including the snapshot id and the value of the element at that snapshot.\\n\\nTo set the value of an element at a particular index, we simply append a new tuple to the corresponding inner list with the current snapshot id and the new value.\\n\\nTo take a snapshot of the array, we just increment the snapshot id counter by 1 and return the new snapshot id. We don\\'t need to create a copy of the entire array for each snapshot.\\n\\nTo retrieve the value of an element at a particular index at a specific snapshot id, we use binary search to find the correct position in the inner list of that element for the given snapshot id. We then return the value associated with that snapshot.\\n\\nThis approach allows us to efficiently store and retrieve multiple versions/snapshots of an array without having to create a new copy of the entire array for each snapshot. It also has a relatively small memory footprint compared to other approaches that require storing a copy of the entire array for each snapshot.\\n\\n<!--\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n<!--\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport bisect\\n\\nclass SnapshotArray(object):\\n\\n    def __init__(self, n):\\n        self.A = [[[-1, 0]] for _ in xrange(n)]\\n        self.snap_id = 0\\n\\n    def set(self, index, val):\\n        self.A[index].append([self.snap_id, val])\\n\\n    def snap(self):\\n        self.snap_id += 1\\n        return self.snap_id - 1\\n\\n    def get(self, index, snap_id):\\n        i = bisect.bisect(self.A[index], [snap_id + 1]) - 1\\n        return self.A[index][i][1]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Design"
                ],
                "code": "```\\nimport bisect\\n\\nclass SnapshotArray(object):\\n\\n    def __init__(self, n):\\n        self.A = [[[-1, 0]] for _ in xrange(n)]\\n        self.snap_id = 0\\n\\n    def set(self, index, val):\\n        self.A[index].append([self.snap_id, val])\\n\\n    def snap(self):\\n        self.snap_id += 1\\n        return self.snap_id - 1\\n\\n    def get(self, index, snap_id):\\n        i = bisect.bisect(self.A[index], [snap_id + 1]) - 1\\n        return self.A[index][i][1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623669,
                "title": "binary-search-fully-explained-approach-with-clean-code-o-log-snaps-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is a binary search approach here.\\nHere we are storing values at index as a vector of pair, with first value denoting the time at which value was changed, and second value denoting the value at that time till the next snap at which this index\\'s value is changed.\\n# Set\\nInsert a new element for an index with the {current time,val} as a pair **if** the last element for the index is taken before current time, else just update the last element second value.\\n# Snap\\nreturn current time and increment time by 1\\n# Get\\nDo a binary search in the index\\'s array, to find the time equivalent to snap_id or just next smaller value to snap_id, to find the desired value at desired time.\\n\\n# Code\\n```\\nclass SnapshotArray {\\npublic:\\n    int time;\\n    vector<vector<pair<int,int>>> arr;\\n    SnapshotArray(int length) {\\n        time=0;\\n        for(int i=0;i<length;i++){\\n            arr.push_back(vector<pair<int,int>>(1,{0,0}));\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        if(arr[index][arr[index].size()-1].first<time){\\n            arr[index].push_back({time,val});\\n        }\\n        else{\\n            arr[index][arr[index].size()-1].second = val;\\n        }\\n    }\\n    \\n    int snap() {\\n        time++;\\n        return time-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        int i=0,j=arr[index].size()-1;\\n        int ans;\\n        while(i<=j){\\n            int mid = (i+j)/2;\\n            if(arr[index][mid].first>snap_id){\\n                j = mid-1;\\n            }\\n            else{\\n                ans = mid;\\n                i = mid+1;\\n            }\\n        }\\n        return arr[index][ans].second;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: \\n  1. set: O(1)\\n  2. snap: O(1)\\n  3. get: O(log (total_snaps))\\n- Space complexity: O(length*total_snaps)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Design"
                ],
                "code": "```\\nclass SnapshotArray {\\npublic:\\n    int time;\\n    vector<vector<pair<int,int>>> arr;\\n    SnapshotArray(int length) {\\n        time=0;\\n        for(int i=0;i<length;i++){\\n            arr.push_back(vector<pair<int,int>>(1,{0,0}));\\n        }\\n    }\\n    \\n    void set(int index, int val) {\\n        if(arr[index][arr[index].size()-1].first<time){\\n            arr[index].push_back({time,val});\\n        }\\n        else{\\n            arr[index][arr[index].size()-1].second = val;\\n        }\\n    }\\n    \\n    int snap() {\\n        time++;\\n        return time-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        int i=0,j=arr[index].size()-1;\\n        int ans;\\n        while(i<=j){\\n            int mid = (i+j)/2;\\n            if(arr[index][mid].first>snap_id){\\n                j = mid-1;\\n            }\\n            else{\\n                ans = mid;\\n                i = mid+1;\\n            }\\n        }\\n        return arr[index][ans].second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623645,
                "title": "building-the-solution-step-by-step-c",
                "content": "# Read the Question\\nThe problem at hand asks us to design an array-like structure, which is initially all 0s. At each step we can perform one of three operations:\\n1. set(index, val);\\n2. get(index, snap_id);\\n3. snap();\\n\\nThe `set` operation sets the value of the element at the index in the current snapshot.\\nThe `get` operation gets the value of the element at index in the particular given snapshot with id = snap_id.\\nThe `snap` operation saves the current snapshot for later use and returns its id.\\n\\n# Naive Approach\\nSince we need to reference the array as snapshots at different times, we can store the array for each snapshot and then return answer quickly.\\nInitially we begin with an array of length `len` with all 0s. Whenever `snap` is called, we copy the current array and push it to our snaps 2D array. The id returned will be the second last index of the array.\\n\\nAlthough this approach has the best time complexity ever, it is very naive, as it incurs a space complexity of $$O(len * maxCalls(snap)$$, which is $$25 * 10^8$$ according to the given constraints. Hence this approach is not viable.\\n\\n# Some Optimizations\\n## 1. No Need to Store the Whole Array\\nSince we start with all 0s initially, and a change in the array can only be brought one element at a time, we don\\'t need to store the whole array for each snapshot.\\nWe can just store the non-zero elements, because all the other elements are guaranteed to be 0.\\nThis doesn\\'t bring our space complexity down, but is still an improvement.\\n\\n## 2. Avoid Unnecessary Copies of Snapshots\\nIt is also not necessary that each element change in each snapshot, hence we only need to store the value of the element at the snapshots in which it changes. This way, we only incur space complexity of the order of the number of changes (or `set` calls) made in the structure.\\nThis can be done by maintaining a map indexed by the array indices and storing an array of pairs of `{snap_id, val}`.\\n\\n# Approach\\nTaking all the above optimizations into account, we can build our approach.\\n\\nWe maintain a map of array of pairs of `{snap_id, val}`, where we can `arr[index]` contains all the snapshots at which its value changes and the values themselves.\\n\\n## Set Operation\\nFor the set operation, we append the pair `{curr_snap_id, val}` to `arr[index]`. \\n\\n## Snap Operation\\nFor the snap operation, the only thing we need to do is to increment the curr_snap_id, and return the old one.\\n\\n## Get Operation\\nFor the get operation, we need to find the value of the element at index, the snapshot before or at `snap_id` where its value changed.\\nThis can be accomplished by finding the lower bound of `{snap_id, INT_MAX}` in the reversed array of `arr[index]`, using the opposite comparison operator.\\nThis will find the first snapshot $<=$ snap_id which has updated the value at index. If the lower bound can\\'t be found, it means that this element had never been updateed till the given snap_id, and hence the value is guaranteed to be 0.\\nOtherwise, we return the requisite value, which is the second element of the pair found above.\\n\\n\\n# Complexity\\n## Time complexity:\\n**get(index, snap_id)**: $$O(log n)$$ where $n$ is the size of `arr[index]` which can be up to $5 * 10^4$ (maximum number of set calls).\\n**set(index, val)**: $$O(1)$$, just one push back operation is done.\\n**snap()**: $$O(1)$$, just one increment operation is done. \\n\\nHence the total time complexity is $$O(maxCalls(get) * log(maxCalls(set))$$\\n   \\n\\n## Space complexity:\\nThe total space complexity is incurred by the 2D map, which is $$O(maxCalls(set))$$.\\n\\n# Code\\n```\\nclass SnapshotArray {\\n    int currSnapId = 0;\\n    unordered_map<int, vector<pair<int,int>>> arr;\\n    int len;\\npublic:\\n    SnapshotArray(int length) {\\n        len = length;\\n    }\\n    \\n    void set(int index, int val) {\\n        if(!arr[index].empty() && arr[index].back().first == currSnapId) {\\n            arr[index].pop_back();\\n        }\\n        arr[index].push_back({currSnapId, val});\\n    }\\n    \\n    int snap() {\\n        currSnapId++;\\n        return currSnapId-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n\\n        auto it = lower_bound(arr[index].rbegin(), arr[index].rend(), make_pair(snap_id, INT_MAX), [](const pair<int, int>& a, const pair<int, int>& b) {\\n            return a > b;\\n        });\\n        if(it == arr[index].rend()) return 0;\\n        else return it->second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass SnapshotArray {\\n    int currSnapId = 0;\\n    unordered_map<int, vector<pair<int,int>>> arr;\\n    int len;\\npublic:\\n    SnapshotArray(int length) {\\n        len = length;\\n    }\\n    \\n    void set(int index, int val) {\\n        if(!arr[index].empty() && arr[index].back().first == currSnapId) {\\n            arr[index].pop_back();\\n        }\\n        arr[index].push_back({currSnapId, val});\\n    }\\n    \\n    int snap() {\\n        currSnapId++;\\n        return currSnapId-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n\\n        auto it = lower_bound(arr[index].rbegin(), arr[index].rend(), make_pair(snap_id, INT_MAX), [](const pair<int, int>& a, const pair<int, int>& b) {\\n            return a > b;\\n        });\\n        if(it == arr[index].rend()) return 0;\\n        else return it->second;\\n    }\\n};\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray* obj = new SnapshotArray(length);\\n * obj->set(index,val);\\n * int param_2 = obj->snap();\\n * int param_3 = obj->get(index,snap_id);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623615,
                "title": "typescript-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Don\\'t save the whole array in each snap, only keep the changes. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Form a map to log value of elenebt at `index` at each snap. \\n- If specific snap of element at `index` doesn\\'t exist, should look for most recent one. \\n\\n# Complexity\\n- Time complexity:\\n$$O\\\\ (n_{snap})$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O\\\\ (n_{snap} * n_{set})$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SnapshotArray {\\n    ary: number[];\\n    snapCount: number;\\n    snapshotMap: Map<number, Map<number, number>>; // {index: {snap_id: val}}\\n\\n    constructor(length: number) {\\n        this.snapCount = 0;\\n        this.snapshotMap = new Map<number, Map<number, number>>();\\n    }\\n\\n    set(index: number, val: number): void {\\n        if(this.snapshotMap.has(index)){\\n            this.snapshotMap.get(index).set(this.snapCount, val);\\n        }else{\\n            this.snapshotMap.set(index, new Map([[this.snapCount, val]]))\\n        }\\n    }\\n\\n    snap(): number {\\n        this.snapCount++;\\n        return this.snapCount-1\\n    }\\n\\n    get(index: number, snap_id: number): number {\\n        if(this.snapshotMap.has(index)){\\n            if(this.snapshotMap.get(index).has(snap_id)){\\n                return this.snapshotMap.get(index).get(snap_id);\\n            }else{\\n                const snapIds = [...this.snapshotMap.get(index).keys()];\\n                let res = 0;\\n                for(let i=0; i<snapIds.length; i++){\\n                    const snapId = snapIds[i];\\n                    if(snapId>snap_id){\\n                        break;\\n                    }\\n                    res = this.snapshotMap.get(index).get(snapId);\\n                }\\n                return res;\\n            }\\n\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "```\\nclass SnapshotArray {\\n    ary: number[];\\n    snapCount: number;\\n    snapshotMap: Map<number, Map<number, number>>; // {index: {snap_id: val}}\\n\\n    constructor(length: number) {\\n        this.snapCount = 0;\\n        this.snapshotMap = new Map<number, Map<number, number>>();\\n    }\\n\\n    set(index: number, val: number): void {\\n        if(this.snapshotMap.has(index)){\\n            this.snapshotMap.get(index).set(this.snapCount, val);\\n        }else{\\n            this.snapshotMap.set(index, new Map([[this.snapCount, val]]))\\n        }\\n    }\\n\\n    snap(): number {\\n        this.snapCount++;\\n        return this.snapCount-1\\n    }\\n\\n    get(index: number, snap_id: number): number {\\n        if(this.snapshotMap.has(index)){\\n            if(this.snapshotMap.get(index).has(snap_id)){\\n                return this.snapshotMap.get(index).get(snap_id);\\n            }else{\\n                const snapIds = [...this.snapshotMap.get(index).keys()];\\n                let res = 0;\\n                for(let i=0; i<snapIds.length; i++){\\n                    const snapId = snapIds[i];\\n                    if(snapId>snap_id){\\n                        break;\\n                    }\\n                    res = this.snapshotMap.get(index).get(snapId);\\n                }\\n                return res;\\n            }\\n\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1924688,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1925090,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1924376,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1925349,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1924427,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1679432,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1925051,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1924667,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1924946,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1924953,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1924688,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1925090,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1924376,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1925349,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1924427,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1679432,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1925051,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1924667,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1924946,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1924953,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**are you here, after crying in contest?**"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Yess :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Dattebayo "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Yes sir. Crying since last night."
                    },
                    {
                        "username": "tungpham",
                        "content": "lol"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "uhh"
                    },
                    {
                        "username": "palak-agg",
                        "content": "And it sucks when u get a MLE at 69/74 inputs :("
                    },
                    {
                        "username": "Dominator3727",
                        "content": "[@Gauravgeekp](/Gauravgeekp) same here\\n"
                    },
                    {
                        "username": "Icari_Lav0118",
                        "content": "looks like *somebody* installed a surveillance camera in my room (jk"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "I m getting at 72"
                    },
                    {
                        "username": "omegablue",
                        "content": "Just started working on it and although I thought it looked clean... got the same MLE at 69/74."
                    },
                    {
                        "username": "feng3245",
                        "content": "[@poiuyt123](/poiuyt123) Trick is to see that they are never asking for the full snapshot. So in a way you want to save the sparse data. 9 hr ago so am guessing you probably figured it out by now."
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@faiq--](/faiq--) I feel you bruh :)"
                    },
                    {
                        "username": "faiq--",
                        "content": "tle at 73 :\\')\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@m-d-nabeel](/m-d-nabeel) But iam getting tle"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@poiuyt123](/poiuyt123) Try using index as the main key\\ni used unordered_map<int, map<int, int>> after getting MLE got accepted but runtime was seriously bad"
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": "Same Berro\\uD83E\\uDD72 "
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@parthbansal2047](/parthbansal2047) I used a HashMap with int, int[] to store snapshots T_T"
                    },
                    {
                        "username": "parthbansal2047",
                        "content": "Did you also use vector of vector to store snapshots?"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Received the same, how did you resolve it?"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "Good Morning :)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "morning dude"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The problem I\\'ve collected both **MLE** and **TLE**"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Join the club. I got 4 different solutions boiled up, 2 times TLE, 2 times MLE "
                    },
                    {
                        "username": "NesaPrasath",
                        "content": "can anyone pls explain what is snapshot?"
                    },
                    {
                        "username": "cadornajansen",
                        "content": "It's like taking a picture of the array to capture its current state. Imagine you have a group of people, and each person represents an element in the array. It allows you to remember and retrieve that specific moment later, even if the array changes afterwards. so, with the SnapshotArray, you can freeze the array's values at a particular point in time and go back to that frozen state whenever you want."
                    },
                    {
                        "username": "eddy66",
                        "content": "snapshot here means a record (snap) of all element values in the array corresponding to the `snap_id`.\nso a user can store a record (snap) of all current element values by `snap()`, the user will get the corresponding `snap_id`, and then the user can query a specific element value in that record (snap) by `get(index, snap_id)` later."
                    },
                    {
                        "username": "abhi5heklal",
                        "content": "Snapshot is the state of the array i.e. if you set the value at index 0 to say 10 take a snapshot of it and then change the value at index 0 to 12 then snapshot will help you get the initial value of 10 using the get method and snap_id"
                    },
                    {
                        "username": "caje99",
                        "content": "Why can't use just a dictionary?\n(In comparison to the solution which uses array of arrays to note just the change)\n\nIf I set the key as `(snap_id, index)` and value as `Value` \n\nThe time complexity would be O(1) for get operations!\n\nI executed the above operation, but I got a space limit exceeded error! "
                    },
                    {
                        "username": "_SID_",
                        "content": "[@Jason-Law](/Jason-Law) you can optimize it to O(1) "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Because you\\'re storing the full snapshot even if there\\'s not diff. Try storing the diffs instead of whole dictionary. Here\\'s a java solution: https://leetcode.com/problems/snapshot-array/submissions/968631036/"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "But the time complexity for `snap` is O(n), each time `snap` is called, you need to add an the entry for each index. By the way, it is better to post your code here."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I don't really understand what to do. Some OOP problem is very difficult to  figure out what should be done. \nThe problem here is something like this kind of problem!  Test and error better than nothing!\n```\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\n```"
                    },
                    {
                        "username": "andreigabrielpopescu556",
                        "content": "For anyone having problems with this one: you have the first snap with [15]. Snaps are copies of the actual array at a given time. So we will have the following list of snapshots: [15], [15], [15] // all copies in chain, then two other snapshots: [15], [15]. "
                    },
                    {
                        "username": "mlazic",
                        "content": "nvm I think I misunderstood the problem definition..."
                    },
                    {
                        "username": "danielmascena",
                        "content": "same here, this test case is no joke"
                    },
                    {
                        "username": "mlazic",
                        "content": "I think the test case might be broken as the expected output is shown as follows:\\n[null,null,0,1,2,15,3,4,15]\\nThe value 15 was set only once, yet it\\'s expected that get() returns it for two different snap_id\\'s "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "What is so unclear here? Immediately after initialization the value 15 is set to index 0. The whole bunch of `snap` calls after that does not change the stored value in any way. So it should be 15 for all snapshots."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "I am also get stuck on this"
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "This test case seems wrong\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Please Leetcode !!!. Totally Exhausted in Consecutively two contest in 24 Hours."
                    },
                    {
                        "username": "oneupwallstreet",
                        "content": "Painfully solved it using LinkedList but got TLE, still happy that it worked lol "
                    },
                    {
                        "username": "x-ider",
                        "content": "Not gonna lie, this is one of the times when implementing in Go makes me sad writing all these walls of code"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had given up tweaking binary search and solved with `sort.Search()`"
                    }
                ]
            },
            {
                "id": 1576071,
                "content": [
                    {
                        "username": "meakub",
                        "content": "With same input, if I run it gives expected result but if submit shows incorrect result.\\n![image](https://assets.leetcode.com/users/images/caac6003-fb6e-4afe-b0d1-c65f84b3f0d5_1639195063.85086.png)\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "Do not use global variables or static variables, the system is performing all of the tests using multiple threads in a shared memory environment, meaning your code needs to be re-entrant safe. In other words, your global variable can be used by other threads. Since there is just a single thread when you run it using \"run\", you don\\'t see the issue."
                    },
                    {
                        "username": "breathermachine",
                        "content": "snapCount shouldn\\'t have to be declared as static. It effectively makes snapCount a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "ehmyitayew",
                        "content": "A couple of things that weren\\'t clear from the questions:\\n- if snap isn\\'t called, changes aren\\'t persisted. I.e if you for instance you have a set() followed by a get() before any snaps that should result with a 0\\n- when getting, you don\\'t need to have have the exact snap_id, it is more like the latest snapshot <= snap_id"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I did what the questions asked, but got testcases checking for more than described!\\nWhy not showing a constraing that memory allocation must be smaller smaller O(Snaps,Length)=O(N*M)?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I agree with this. If there are specific (strong) memory, or time constraints for that matter, it would be good to have that shown in the description as well"
                    },
                    {
                        "username": "devtiwari",
                        "content": "![image](https://assets.leetcode.com/users/images/fde5914d-de7c-4351-b4bc-b609d2301f02_1598803315.1373239.png)\\nsee this image carefully  and you will understand what is wrong with this question."
                    },
                    {
                        "username": "breathermachine",
                        "content": "`cnt` shouldn\\'t have to be declared as static. It effectively makes `cnt` a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Bruh ! it\\'s still the same"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "some more hints to avoid TLE\\nHINT 1 : no need to store each new value when set is called. ( just store the latest value for current snapid)\\nHINT 2 : no need to store values of all index at each snap. ( store new snapid with new value if set after snap )"
                    },
                    {
                        "username": "jackconvolution",
                        "content": "You saved my day! Thanks!"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Woooo, i thought it\\'s simple Hash Map problem, but it turns out to be a binary search problem\\nNow Everyday I get to know some new way to use binary search"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Bro it is a Simple Hash map problem."
                    },
                    {
                        "username": "feng3245",
                        "content": "The last question too... it was optional but how many of us can math wiz a question during interview.."
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "Whats wrong with my approach?\\n\\n ``` class SnapshotArray {\\npublic:\\n    int snapno = 0;\\n    vector<vector<int>> vec;\\n    int col = 0;\\n    SnapshotArray(int length) {\\n        vec.resize(1,vector<int>(length,0));\\n        col = length;\\n    }\\n    void set(int index, int val) {\\n        vec[snapno][index] = val;\\n    }\\n    int snap() {\\n        snapno++;\\n        vec.push_back(vector<int>(col,0));\\n        return snapno-1;\\n    }\\n    int get(int index, int snap_id) {\\n        return vec[snap_id][index];\\n    \\n    }\\n}; ```\\n\\nIt is giving error on the test case\\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\\n\\n\\nI think test case is itself faulty."
                    },
                    {
                        "username": "thegameworden",
                        "content": "I run out of memory with this one... I pass almost all test cases though. Can anyone assist me in this?\\n\\n `public class SnapshotArray {\\n    Dictionary<int, int[]> snap;\\n    int snapCount;\\n    int[] snapArr;\\n    \\n    public SnapshotArray(int length) {\\n        snap= new Dictionary<int, int[]>();\\n        snapCount =0;\\n        snapArr= new int[length];\\n    }\\n    \\n    public void Set(int index, int val) {\\n        snapArr[index]=val;\\n    }\\n    \\n    public int Snap() {\\n        int[] copy = new int[snapArr.Length];\\n        snapArr.CopyTo(copy,0);\\n        snap.Add(snapCount,copy);\\n        snapCount++;\\n        return snapCount-1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        return snap[snap_id][index];\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.Set(index,val);\\n * int param_2 = obj.Snap();\\n * int param_3 = obj.Get(index,snap_id);\\n */`"
                    },
                    {
                        "username": "swadesh-vaibhav",
                        "content": "[@dkochetov](/dkochetov)  Git is a bad example, as it does not store differences. It stores entire snapshots of files."
                    },
                    {
                        "username": "dkochetov",
                        "content": "Don't create full clones of the array each time `snap()` is called. Look at how `Git` works, it keeps the information only about the changes, and doesn't waste memory on duplicating parts that haven't changed. Here `git commit` -> `snapshot`, `lines with code` -> `array elements`."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "site1997",
                        "content": "I use nested vector during contest, and it didn\\'t pass because of MLE.\\nAfter the contest, I changed all the **pass by value** to **pass by reference**, and it got AC..."
                    },
                    {
                        "username": "sriram7507",
                        "content": "first mle now tle (\\'\\'....\\'\\')"
                    }
                ]
            },
            {
                "id": 1928592,
                "content": [
                    {
                        "username": "meakub",
                        "content": "With same input, if I run it gives expected result but if submit shows incorrect result.\\n![image](https://assets.leetcode.com/users/images/caac6003-fb6e-4afe-b0d1-c65f84b3f0d5_1639195063.85086.png)\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "Do not use global variables or static variables, the system is performing all of the tests using multiple threads in a shared memory environment, meaning your code needs to be re-entrant safe. In other words, your global variable can be used by other threads. Since there is just a single thread when you run it using \"run\", you don\\'t see the issue."
                    },
                    {
                        "username": "breathermachine",
                        "content": "snapCount shouldn\\'t have to be declared as static. It effectively makes snapCount a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "ehmyitayew",
                        "content": "A couple of things that weren\\'t clear from the questions:\\n- if snap isn\\'t called, changes aren\\'t persisted. I.e if you for instance you have a set() followed by a get() before any snaps that should result with a 0\\n- when getting, you don\\'t need to have have the exact snap_id, it is more like the latest snapshot <= snap_id"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I did what the questions asked, but got testcases checking for more than described!\\nWhy not showing a constraing that memory allocation must be smaller smaller O(Snaps,Length)=O(N*M)?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I agree with this. If there are specific (strong) memory, or time constraints for that matter, it would be good to have that shown in the description as well"
                    },
                    {
                        "username": "devtiwari",
                        "content": "![image](https://assets.leetcode.com/users/images/fde5914d-de7c-4351-b4bc-b609d2301f02_1598803315.1373239.png)\\nsee this image carefully  and you will understand what is wrong with this question."
                    },
                    {
                        "username": "breathermachine",
                        "content": "`cnt` shouldn\\'t have to be declared as static. It effectively makes `cnt` a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Bruh ! it\\'s still the same"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "some more hints to avoid TLE\\nHINT 1 : no need to store each new value when set is called. ( just store the latest value for current snapid)\\nHINT 2 : no need to store values of all index at each snap. ( store new snapid with new value if set after snap )"
                    },
                    {
                        "username": "jackconvolution",
                        "content": "You saved my day! Thanks!"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Woooo, i thought it\\'s simple Hash Map problem, but it turns out to be a binary search problem\\nNow Everyday I get to know some new way to use binary search"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Bro it is a Simple Hash map problem."
                    },
                    {
                        "username": "feng3245",
                        "content": "The last question too... it was optional but how many of us can math wiz a question during interview.."
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "Whats wrong with my approach?\\n\\n ``` class SnapshotArray {\\npublic:\\n    int snapno = 0;\\n    vector<vector<int>> vec;\\n    int col = 0;\\n    SnapshotArray(int length) {\\n        vec.resize(1,vector<int>(length,0));\\n        col = length;\\n    }\\n    void set(int index, int val) {\\n        vec[snapno][index] = val;\\n    }\\n    int snap() {\\n        snapno++;\\n        vec.push_back(vector<int>(col,0));\\n        return snapno-1;\\n    }\\n    int get(int index, int snap_id) {\\n        return vec[snap_id][index];\\n    \\n    }\\n}; ```\\n\\nIt is giving error on the test case\\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\\n\\n\\nI think test case is itself faulty."
                    },
                    {
                        "username": "thegameworden",
                        "content": "I run out of memory with this one... I pass almost all test cases though. Can anyone assist me in this?\\n\\n `public class SnapshotArray {\\n    Dictionary<int, int[]> snap;\\n    int snapCount;\\n    int[] snapArr;\\n    \\n    public SnapshotArray(int length) {\\n        snap= new Dictionary<int, int[]>();\\n        snapCount =0;\\n        snapArr= new int[length];\\n    }\\n    \\n    public void Set(int index, int val) {\\n        snapArr[index]=val;\\n    }\\n    \\n    public int Snap() {\\n        int[] copy = new int[snapArr.Length];\\n        snapArr.CopyTo(copy,0);\\n        snap.Add(snapCount,copy);\\n        snapCount++;\\n        return snapCount-1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        return snap[snap_id][index];\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.Set(index,val);\\n * int param_2 = obj.Snap();\\n * int param_3 = obj.Get(index,snap_id);\\n */`"
                    },
                    {
                        "username": "swadesh-vaibhav",
                        "content": "[@dkochetov](/dkochetov)  Git is a bad example, as it does not store differences. It stores entire snapshots of files."
                    },
                    {
                        "username": "dkochetov",
                        "content": "Don't create full clones of the array each time `snap()` is called. Look at how `Git` works, it keeps the information only about the changes, and doesn't waste memory on duplicating parts that haven't changed. Here `git commit` -> `snapshot`, `lines with code` -> `array elements`."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "site1997",
                        "content": "I use nested vector during contest, and it didn\\'t pass because of MLE.\\nAfter the contest, I changed all the **pass by value** to **pass by reference**, and it got AC..."
                    },
                    {
                        "username": "sriram7507",
                        "content": "first mle now tle (\\'\\'....\\'\\')"
                    }
                ]
            },
            {
                "id": 1925818,
                "content": [
                    {
                        "username": "meakub",
                        "content": "With same input, if I run it gives expected result but if submit shows incorrect result.\\n![image](https://assets.leetcode.com/users/images/caac6003-fb6e-4afe-b0d1-c65f84b3f0d5_1639195063.85086.png)\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "Do not use global variables or static variables, the system is performing all of the tests using multiple threads in a shared memory environment, meaning your code needs to be re-entrant safe. In other words, your global variable can be used by other threads. Since there is just a single thread when you run it using \"run\", you don\\'t see the issue."
                    },
                    {
                        "username": "breathermachine",
                        "content": "snapCount shouldn\\'t have to be declared as static. It effectively makes snapCount a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "ehmyitayew",
                        "content": "A couple of things that weren\\'t clear from the questions:\\n- if snap isn\\'t called, changes aren\\'t persisted. I.e if you for instance you have a set() followed by a get() before any snaps that should result with a 0\\n- when getting, you don\\'t need to have have the exact snap_id, it is more like the latest snapshot <= snap_id"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I did what the questions asked, but got testcases checking for more than described!\\nWhy not showing a constraing that memory allocation must be smaller smaller O(Snaps,Length)=O(N*M)?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I agree with this. If there are specific (strong) memory, or time constraints for that matter, it would be good to have that shown in the description as well"
                    },
                    {
                        "username": "devtiwari",
                        "content": "![image](https://assets.leetcode.com/users/images/fde5914d-de7c-4351-b4bc-b609d2301f02_1598803315.1373239.png)\\nsee this image carefully  and you will understand what is wrong with this question."
                    },
                    {
                        "username": "breathermachine",
                        "content": "`cnt` shouldn\\'t have to be declared as static. It effectively makes `cnt` a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Bruh ! it\\'s still the same"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "some more hints to avoid TLE\\nHINT 1 : no need to store each new value when set is called. ( just store the latest value for current snapid)\\nHINT 2 : no need to store values of all index at each snap. ( store new snapid with new value if set after snap )"
                    },
                    {
                        "username": "jackconvolution",
                        "content": "You saved my day! Thanks!"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Woooo, i thought it\\'s simple Hash Map problem, but it turns out to be a binary search problem\\nNow Everyday I get to know some new way to use binary search"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Bro it is a Simple Hash map problem."
                    },
                    {
                        "username": "feng3245",
                        "content": "The last question too... it was optional but how many of us can math wiz a question during interview.."
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "Whats wrong with my approach?\\n\\n ``` class SnapshotArray {\\npublic:\\n    int snapno = 0;\\n    vector<vector<int>> vec;\\n    int col = 0;\\n    SnapshotArray(int length) {\\n        vec.resize(1,vector<int>(length,0));\\n        col = length;\\n    }\\n    void set(int index, int val) {\\n        vec[snapno][index] = val;\\n    }\\n    int snap() {\\n        snapno++;\\n        vec.push_back(vector<int>(col,0));\\n        return snapno-1;\\n    }\\n    int get(int index, int snap_id) {\\n        return vec[snap_id][index];\\n    \\n    }\\n}; ```\\n\\nIt is giving error on the test case\\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\\n\\n\\nI think test case is itself faulty."
                    },
                    {
                        "username": "thegameworden",
                        "content": "I run out of memory with this one... I pass almost all test cases though. Can anyone assist me in this?\\n\\n `public class SnapshotArray {\\n    Dictionary<int, int[]> snap;\\n    int snapCount;\\n    int[] snapArr;\\n    \\n    public SnapshotArray(int length) {\\n        snap= new Dictionary<int, int[]>();\\n        snapCount =0;\\n        snapArr= new int[length];\\n    }\\n    \\n    public void Set(int index, int val) {\\n        snapArr[index]=val;\\n    }\\n    \\n    public int Snap() {\\n        int[] copy = new int[snapArr.Length];\\n        snapArr.CopyTo(copy,0);\\n        snap.Add(snapCount,copy);\\n        snapCount++;\\n        return snapCount-1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        return snap[snap_id][index];\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.Set(index,val);\\n * int param_2 = obj.Snap();\\n * int param_3 = obj.Get(index,snap_id);\\n */`"
                    },
                    {
                        "username": "swadesh-vaibhav",
                        "content": "[@dkochetov](/dkochetov)  Git is a bad example, as it does not store differences. It stores entire snapshots of files."
                    },
                    {
                        "username": "dkochetov",
                        "content": "Don't create full clones of the array each time `snap()` is called. Look at how `Git` works, it keeps the information only about the changes, and doesn't waste memory on duplicating parts that haven't changed. Here `git commit` -> `snapshot`, `lines with code` -> `array elements`."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "site1997",
                        "content": "I use nested vector during contest, and it didn\\'t pass because of MLE.\\nAfter the contest, I changed all the **pass by value** to **pass by reference**, and it got AC..."
                    },
                    {
                        "username": "sriram7507",
                        "content": "first mle now tle (\\'\\'....\\'\\')"
                    }
                ]
            },
            {
                "id": 1574302,
                "content": [
                    {
                        "username": "meakub",
                        "content": "With same input, if I run it gives expected result but if submit shows incorrect result.\\n![image](https://assets.leetcode.com/users/images/caac6003-fb6e-4afe-b0d1-c65f84b3f0d5_1639195063.85086.png)\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "Do not use global variables or static variables, the system is performing all of the tests using multiple threads in a shared memory environment, meaning your code needs to be re-entrant safe. In other words, your global variable can be used by other threads. Since there is just a single thread when you run it using \"run\", you don\\'t see the issue."
                    },
                    {
                        "username": "breathermachine",
                        "content": "snapCount shouldn\\'t have to be declared as static. It effectively makes snapCount a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "ehmyitayew",
                        "content": "A couple of things that weren\\'t clear from the questions:\\n- if snap isn\\'t called, changes aren\\'t persisted. I.e if you for instance you have a set() followed by a get() before any snaps that should result with a 0\\n- when getting, you don\\'t need to have have the exact snap_id, it is more like the latest snapshot <= snap_id"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I did what the questions asked, but got testcases checking for more than described!\\nWhy not showing a constraing that memory allocation must be smaller smaller O(Snaps,Length)=O(N*M)?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I agree with this. If there are specific (strong) memory, or time constraints for that matter, it would be good to have that shown in the description as well"
                    },
                    {
                        "username": "devtiwari",
                        "content": "![image](https://assets.leetcode.com/users/images/fde5914d-de7c-4351-b4bc-b609d2301f02_1598803315.1373239.png)\\nsee this image carefully  and you will understand what is wrong with this question."
                    },
                    {
                        "username": "breathermachine",
                        "content": "`cnt` shouldn\\'t have to be declared as static. It effectively makes `cnt` a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Bruh ! it\\'s still the same"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "some more hints to avoid TLE\\nHINT 1 : no need to store each new value when set is called. ( just store the latest value for current snapid)\\nHINT 2 : no need to store values of all index at each snap. ( store new snapid with new value if set after snap )"
                    },
                    {
                        "username": "jackconvolution",
                        "content": "You saved my day! Thanks!"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Woooo, i thought it\\'s simple Hash Map problem, but it turns out to be a binary search problem\\nNow Everyday I get to know some new way to use binary search"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Bro it is a Simple Hash map problem."
                    },
                    {
                        "username": "feng3245",
                        "content": "The last question too... it was optional but how many of us can math wiz a question during interview.."
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "Whats wrong with my approach?\\n\\n ``` class SnapshotArray {\\npublic:\\n    int snapno = 0;\\n    vector<vector<int>> vec;\\n    int col = 0;\\n    SnapshotArray(int length) {\\n        vec.resize(1,vector<int>(length,0));\\n        col = length;\\n    }\\n    void set(int index, int val) {\\n        vec[snapno][index] = val;\\n    }\\n    int snap() {\\n        snapno++;\\n        vec.push_back(vector<int>(col,0));\\n        return snapno-1;\\n    }\\n    int get(int index, int snap_id) {\\n        return vec[snap_id][index];\\n    \\n    }\\n}; ```\\n\\nIt is giving error on the test case\\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\\n\\n\\nI think test case is itself faulty."
                    },
                    {
                        "username": "thegameworden",
                        "content": "I run out of memory with this one... I pass almost all test cases though. Can anyone assist me in this?\\n\\n `public class SnapshotArray {\\n    Dictionary<int, int[]> snap;\\n    int snapCount;\\n    int[] snapArr;\\n    \\n    public SnapshotArray(int length) {\\n        snap= new Dictionary<int, int[]>();\\n        snapCount =0;\\n        snapArr= new int[length];\\n    }\\n    \\n    public void Set(int index, int val) {\\n        snapArr[index]=val;\\n    }\\n    \\n    public int Snap() {\\n        int[] copy = new int[snapArr.Length];\\n        snapArr.CopyTo(copy,0);\\n        snap.Add(snapCount,copy);\\n        snapCount++;\\n        return snapCount-1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        return snap[snap_id][index];\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.Set(index,val);\\n * int param_2 = obj.Snap();\\n * int param_3 = obj.Get(index,snap_id);\\n */`"
                    },
                    {
                        "username": "swadesh-vaibhav",
                        "content": "[@dkochetov](/dkochetov)  Git is a bad example, as it does not store differences. It stores entire snapshots of files."
                    },
                    {
                        "username": "dkochetov",
                        "content": "Don't create full clones of the array each time `snap()` is called. Look at how `Git` works, it keeps the information only about the changes, and doesn't waste memory on duplicating parts that haven't changed. Here `git commit` -> `snapshot`, `lines with code` -> `array elements`."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "site1997",
                        "content": "I use nested vector during contest, and it didn\\'t pass because of MLE.\\nAfter the contest, I changed all the **pass by value** to **pass by reference**, and it got AC..."
                    },
                    {
                        "username": "sriram7507",
                        "content": "first mle now tle (\\'\\'....\\'\\')"
                    }
                ]
            },
            {
                "id": 1928464,
                "content": [
                    {
                        "username": "meakub",
                        "content": "With same input, if I run it gives expected result but if submit shows incorrect result.\\n![image](https://assets.leetcode.com/users/images/caac6003-fb6e-4afe-b0d1-c65f84b3f0d5_1639195063.85086.png)\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "Do not use global variables or static variables, the system is performing all of the tests using multiple threads in a shared memory environment, meaning your code needs to be re-entrant safe. In other words, your global variable can be used by other threads. Since there is just a single thread when you run it using \"run\", you don\\'t see the issue."
                    },
                    {
                        "username": "breathermachine",
                        "content": "snapCount shouldn\\'t have to be declared as static. It effectively makes snapCount a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "ehmyitayew",
                        "content": "A couple of things that weren\\'t clear from the questions:\\n- if snap isn\\'t called, changes aren\\'t persisted. I.e if you for instance you have a set() followed by a get() before any snaps that should result with a 0\\n- when getting, you don\\'t need to have have the exact snap_id, it is more like the latest snapshot <= snap_id"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I did what the questions asked, but got testcases checking for more than described!\\nWhy not showing a constraing that memory allocation must be smaller smaller O(Snaps,Length)=O(N*M)?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I agree with this. If there are specific (strong) memory, or time constraints for that matter, it would be good to have that shown in the description as well"
                    },
                    {
                        "username": "devtiwari",
                        "content": "![image](https://assets.leetcode.com/users/images/fde5914d-de7c-4351-b4bc-b609d2301f02_1598803315.1373239.png)\\nsee this image carefully  and you will understand what is wrong with this question."
                    },
                    {
                        "username": "breathermachine",
                        "content": "`cnt` shouldn\\'t have to be declared as static. It effectively makes `cnt` a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Bruh ! it\\'s still the same"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "some more hints to avoid TLE\\nHINT 1 : no need to store each new value when set is called. ( just store the latest value for current snapid)\\nHINT 2 : no need to store values of all index at each snap. ( store new snapid with new value if set after snap )"
                    },
                    {
                        "username": "jackconvolution",
                        "content": "You saved my day! Thanks!"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Woooo, i thought it\\'s simple Hash Map problem, but it turns out to be a binary search problem\\nNow Everyday I get to know some new way to use binary search"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Bro it is a Simple Hash map problem."
                    },
                    {
                        "username": "feng3245",
                        "content": "The last question too... it was optional but how many of us can math wiz a question during interview.."
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "Whats wrong with my approach?\\n\\n ``` class SnapshotArray {\\npublic:\\n    int snapno = 0;\\n    vector<vector<int>> vec;\\n    int col = 0;\\n    SnapshotArray(int length) {\\n        vec.resize(1,vector<int>(length,0));\\n        col = length;\\n    }\\n    void set(int index, int val) {\\n        vec[snapno][index] = val;\\n    }\\n    int snap() {\\n        snapno++;\\n        vec.push_back(vector<int>(col,0));\\n        return snapno-1;\\n    }\\n    int get(int index, int snap_id) {\\n        return vec[snap_id][index];\\n    \\n    }\\n}; ```\\n\\nIt is giving error on the test case\\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\\n\\n\\nI think test case is itself faulty."
                    },
                    {
                        "username": "thegameworden",
                        "content": "I run out of memory with this one... I pass almost all test cases though. Can anyone assist me in this?\\n\\n `public class SnapshotArray {\\n    Dictionary<int, int[]> snap;\\n    int snapCount;\\n    int[] snapArr;\\n    \\n    public SnapshotArray(int length) {\\n        snap= new Dictionary<int, int[]>();\\n        snapCount =0;\\n        snapArr= new int[length];\\n    }\\n    \\n    public void Set(int index, int val) {\\n        snapArr[index]=val;\\n    }\\n    \\n    public int Snap() {\\n        int[] copy = new int[snapArr.Length];\\n        snapArr.CopyTo(copy,0);\\n        snap.Add(snapCount,copy);\\n        snapCount++;\\n        return snapCount-1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        return snap[snap_id][index];\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.Set(index,val);\\n * int param_2 = obj.Snap();\\n * int param_3 = obj.Get(index,snap_id);\\n */`"
                    },
                    {
                        "username": "swadesh-vaibhav",
                        "content": "[@dkochetov](/dkochetov)  Git is a bad example, as it does not store differences. It stores entire snapshots of files."
                    },
                    {
                        "username": "dkochetov",
                        "content": "Don't create full clones of the array each time `snap()` is called. Look at how `Git` works, it keeps the information only about the changes, and doesn't waste memory on duplicating parts that haven't changed. Here `git commit` -> `snapshot`, `lines with code` -> `array elements`."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "site1997",
                        "content": "I use nested vector during contest, and it didn\\'t pass because of MLE.\\nAfter the contest, I changed all the **pass by value** to **pass by reference**, and it got AC..."
                    },
                    {
                        "username": "sriram7507",
                        "content": "first mle now tle (\\'\\'....\\'\\')"
                    }
                ]
            },
            {
                "id": 1925852,
                "content": [
                    {
                        "username": "meakub",
                        "content": "With same input, if I run it gives expected result but if submit shows incorrect result.\\n![image](https://assets.leetcode.com/users/images/caac6003-fb6e-4afe-b0d1-c65f84b3f0d5_1639195063.85086.png)\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "Do not use global variables or static variables, the system is performing all of the tests using multiple threads in a shared memory environment, meaning your code needs to be re-entrant safe. In other words, your global variable can be used by other threads. Since there is just a single thread when you run it using \"run\", you don\\'t see the issue."
                    },
                    {
                        "username": "breathermachine",
                        "content": "snapCount shouldn\\'t have to be declared as static. It effectively makes snapCount a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "ehmyitayew",
                        "content": "A couple of things that weren\\'t clear from the questions:\\n- if snap isn\\'t called, changes aren\\'t persisted. I.e if you for instance you have a set() followed by a get() before any snaps that should result with a 0\\n- when getting, you don\\'t need to have have the exact snap_id, it is more like the latest snapshot <= snap_id"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I did what the questions asked, but got testcases checking for more than described!\\nWhy not showing a constraing that memory allocation must be smaller smaller O(Snaps,Length)=O(N*M)?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I agree with this. If there are specific (strong) memory, or time constraints for that matter, it would be good to have that shown in the description as well"
                    },
                    {
                        "username": "devtiwari",
                        "content": "![image](https://assets.leetcode.com/users/images/fde5914d-de7c-4351-b4bc-b609d2301f02_1598803315.1373239.png)\\nsee this image carefully  and you will understand what is wrong with this question."
                    },
                    {
                        "username": "breathermachine",
                        "content": "`cnt` shouldn\\'t have to be declared as static. It effectively makes `cnt` a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Bruh ! it\\'s still the same"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "some more hints to avoid TLE\\nHINT 1 : no need to store each new value when set is called. ( just store the latest value for current snapid)\\nHINT 2 : no need to store values of all index at each snap. ( store new snapid with new value if set after snap )"
                    },
                    {
                        "username": "jackconvolution",
                        "content": "You saved my day! Thanks!"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Woooo, i thought it\\'s simple Hash Map problem, but it turns out to be a binary search problem\\nNow Everyday I get to know some new way to use binary search"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Bro it is a Simple Hash map problem."
                    },
                    {
                        "username": "feng3245",
                        "content": "The last question too... it was optional but how many of us can math wiz a question during interview.."
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "Whats wrong with my approach?\\n\\n ``` class SnapshotArray {\\npublic:\\n    int snapno = 0;\\n    vector<vector<int>> vec;\\n    int col = 0;\\n    SnapshotArray(int length) {\\n        vec.resize(1,vector<int>(length,0));\\n        col = length;\\n    }\\n    void set(int index, int val) {\\n        vec[snapno][index] = val;\\n    }\\n    int snap() {\\n        snapno++;\\n        vec.push_back(vector<int>(col,0));\\n        return snapno-1;\\n    }\\n    int get(int index, int snap_id) {\\n        return vec[snap_id][index];\\n    \\n    }\\n}; ```\\n\\nIt is giving error on the test case\\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\\n\\n\\nI think test case is itself faulty."
                    },
                    {
                        "username": "thegameworden",
                        "content": "I run out of memory with this one... I pass almost all test cases though. Can anyone assist me in this?\\n\\n `public class SnapshotArray {\\n    Dictionary<int, int[]> snap;\\n    int snapCount;\\n    int[] snapArr;\\n    \\n    public SnapshotArray(int length) {\\n        snap= new Dictionary<int, int[]>();\\n        snapCount =0;\\n        snapArr= new int[length];\\n    }\\n    \\n    public void Set(int index, int val) {\\n        snapArr[index]=val;\\n    }\\n    \\n    public int Snap() {\\n        int[] copy = new int[snapArr.Length];\\n        snapArr.CopyTo(copy,0);\\n        snap.Add(snapCount,copy);\\n        snapCount++;\\n        return snapCount-1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        return snap[snap_id][index];\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.Set(index,val);\\n * int param_2 = obj.Snap();\\n * int param_3 = obj.Get(index,snap_id);\\n */`"
                    },
                    {
                        "username": "swadesh-vaibhav",
                        "content": "[@dkochetov](/dkochetov)  Git is a bad example, as it does not store differences. It stores entire snapshots of files."
                    },
                    {
                        "username": "dkochetov",
                        "content": "Don't create full clones of the array each time `snap()` is called. Look at how `Git` works, it keeps the information only about the changes, and doesn't waste memory on duplicating parts that haven't changed. Here `git commit` -> `snapshot`, `lines with code` -> `array elements`."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "site1997",
                        "content": "I use nested vector during contest, and it didn\\'t pass because of MLE.\\nAfter the contest, I changed all the **pass by value** to **pass by reference**, and it got AC..."
                    },
                    {
                        "username": "sriram7507",
                        "content": "first mle now tle (\\'\\'....\\'\\')"
                    }
                ]
            },
            {
                "id": 1925261,
                "content": [
                    {
                        "username": "meakub",
                        "content": "With same input, if I run it gives expected result but if submit shows incorrect result.\\n![image](https://assets.leetcode.com/users/images/caac6003-fb6e-4afe-b0d1-c65f84b3f0d5_1639195063.85086.png)\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "Do not use global variables or static variables, the system is performing all of the tests using multiple threads in a shared memory environment, meaning your code needs to be re-entrant safe. In other words, your global variable can be used by other threads. Since there is just a single thread when you run it using \"run\", you don\\'t see the issue."
                    },
                    {
                        "username": "breathermachine",
                        "content": "snapCount shouldn\\'t have to be declared as static. It effectively makes snapCount a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "ehmyitayew",
                        "content": "A couple of things that weren\\'t clear from the questions:\\n- if snap isn\\'t called, changes aren\\'t persisted. I.e if you for instance you have a set() followed by a get() before any snaps that should result with a 0\\n- when getting, you don\\'t need to have have the exact snap_id, it is more like the latest snapshot <= snap_id"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I did what the questions asked, but got testcases checking for more than described!\\nWhy not showing a constraing that memory allocation must be smaller smaller O(Snaps,Length)=O(N*M)?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I agree with this. If there are specific (strong) memory, or time constraints for that matter, it would be good to have that shown in the description as well"
                    },
                    {
                        "username": "devtiwari",
                        "content": "![image](https://assets.leetcode.com/users/images/fde5914d-de7c-4351-b4bc-b609d2301f02_1598803315.1373239.png)\\nsee this image carefully  and you will understand what is wrong with this question."
                    },
                    {
                        "username": "breathermachine",
                        "content": "`cnt` shouldn\\'t have to be declared as static. It effectively makes `cnt` a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Bruh ! it\\'s still the same"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "some more hints to avoid TLE\\nHINT 1 : no need to store each new value when set is called. ( just store the latest value for current snapid)\\nHINT 2 : no need to store values of all index at each snap. ( store new snapid with new value if set after snap )"
                    },
                    {
                        "username": "jackconvolution",
                        "content": "You saved my day! Thanks!"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Woooo, i thought it\\'s simple Hash Map problem, but it turns out to be a binary search problem\\nNow Everyday I get to know some new way to use binary search"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Bro it is a Simple Hash map problem."
                    },
                    {
                        "username": "feng3245",
                        "content": "The last question too... it was optional but how many of us can math wiz a question during interview.."
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "Whats wrong with my approach?\\n\\n ``` class SnapshotArray {\\npublic:\\n    int snapno = 0;\\n    vector<vector<int>> vec;\\n    int col = 0;\\n    SnapshotArray(int length) {\\n        vec.resize(1,vector<int>(length,0));\\n        col = length;\\n    }\\n    void set(int index, int val) {\\n        vec[snapno][index] = val;\\n    }\\n    int snap() {\\n        snapno++;\\n        vec.push_back(vector<int>(col,0));\\n        return snapno-1;\\n    }\\n    int get(int index, int snap_id) {\\n        return vec[snap_id][index];\\n    \\n    }\\n}; ```\\n\\nIt is giving error on the test case\\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\\n\\n\\nI think test case is itself faulty."
                    },
                    {
                        "username": "thegameworden",
                        "content": "I run out of memory with this one... I pass almost all test cases though. Can anyone assist me in this?\\n\\n `public class SnapshotArray {\\n    Dictionary<int, int[]> snap;\\n    int snapCount;\\n    int[] snapArr;\\n    \\n    public SnapshotArray(int length) {\\n        snap= new Dictionary<int, int[]>();\\n        snapCount =0;\\n        snapArr= new int[length];\\n    }\\n    \\n    public void Set(int index, int val) {\\n        snapArr[index]=val;\\n    }\\n    \\n    public int Snap() {\\n        int[] copy = new int[snapArr.Length];\\n        snapArr.CopyTo(copy,0);\\n        snap.Add(snapCount,copy);\\n        snapCount++;\\n        return snapCount-1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        return snap[snap_id][index];\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.Set(index,val);\\n * int param_2 = obj.Snap();\\n * int param_3 = obj.Get(index,snap_id);\\n */`"
                    },
                    {
                        "username": "swadesh-vaibhav",
                        "content": "[@dkochetov](/dkochetov)  Git is a bad example, as it does not store differences. It stores entire snapshots of files."
                    },
                    {
                        "username": "dkochetov",
                        "content": "Don't create full clones of the array each time `snap()` is called. Look at how `Git` works, it keeps the information only about the changes, and doesn't waste memory on duplicating parts that haven't changed. Here `git commit` -> `snapshot`, `lines with code` -> `array elements`."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "site1997",
                        "content": "I use nested vector during contest, and it didn\\'t pass because of MLE.\\nAfter the contest, I changed all the **pass by value** to **pass by reference**, and it got AC..."
                    },
                    {
                        "username": "sriram7507",
                        "content": "first mle now tle (\\'\\'....\\'\\')"
                    }
                ]
            },
            {
                "id": 1712400,
                "content": [
                    {
                        "username": "meakub",
                        "content": "With same input, if I run it gives expected result but if submit shows incorrect result.\\n![image](https://assets.leetcode.com/users/images/caac6003-fb6e-4afe-b0d1-c65f84b3f0d5_1639195063.85086.png)\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "Do not use global variables or static variables, the system is performing all of the tests using multiple threads in a shared memory environment, meaning your code needs to be re-entrant safe. In other words, your global variable can be used by other threads. Since there is just a single thread when you run it using \"run\", you don\\'t see the issue."
                    },
                    {
                        "username": "breathermachine",
                        "content": "snapCount shouldn\\'t have to be declared as static. It effectively makes snapCount a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "ehmyitayew",
                        "content": "A couple of things that weren\\'t clear from the questions:\\n- if snap isn\\'t called, changes aren\\'t persisted. I.e if you for instance you have a set() followed by a get() before any snaps that should result with a 0\\n- when getting, you don\\'t need to have have the exact snap_id, it is more like the latest snapshot <= snap_id"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I did what the questions asked, but got testcases checking for more than described!\\nWhy not showing a constraing that memory allocation must be smaller smaller O(Snaps,Length)=O(N*M)?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I agree with this. If there are specific (strong) memory, or time constraints for that matter, it would be good to have that shown in the description as well"
                    },
                    {
                        "username": "devtiwari",
                        "content": "![image](https://assets.leetcode.com/users/images/fde5914d-de7c-4351-b4bc-b609d2301f02_1598803315.1373239.png)\\nsee this image carefully  and you will understand what is wrong with this question."
                    },
                    {
                        "username": "breathermachine",
                        "content": "`cnt` shouldn\\'t have to be declared as static. It effectively makes `cnt` a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Bruh ! it\\'s still the same"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "some more hints to avoid TLE\\nHINT 1 : no need to store each new value when set is called. ( just store the latest value for current snapid)\\nHINT 2 : no need to store values of all index at each snap. ( store new snapid with new value if set after snap )"
                    },
                    {
                        "username": "jackconvolution",
                        "content": "You saved my day! Thanks!"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Woooo, i thought it\\'s simple Hash Map problem, but it turns out to be a binary search problem\\nNow Everyday I get to know some new way to use binary search"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Bro it is a Simple Hash map problem."
                    },
                    {
                        "username": "feng3245",
                        "content": "The last question too... it was optional but how many of us can math wiz a question during interview.."
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "Whats wrong with my approach?\\n\\n ``` class SnapshotArray {\\npublic:\\n    int snapno = 0;\\n    vector<vector<int>> vec;\\n    int col = 0;\\n    SnapshotArray(int length) {\\n        vec.resize(1,vector<int>(length,0));\\n        col = length;\\n    }\\n    void set(int index, int val) {\\n        vec[snapno][index] = val;\\n    }\\n    int snap() {\\n        snapno++;\\n        vec.push_back(vector<int>(col,0));\\n        return snapno-1;\\n    }\\n    int get(int index, int snap_id) {\\n        return vec[snap_id][index];\\n    \\n    }\\n}; ```\\n\\nIt is giving error on the test case\\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\\n\\n\\nI think test case is itself faulty."
                    },
                    {
                        "username": "thegameworden",
                        "content": "I run out of memory with this one... I pass almost all test cases though. Can anyone assist me in this?\\n\\n `public class SnapshotArray {\\n    Dictionary<int, int[]> snap;\\n    int snapCount;\\n    int[] snapArr;\\n    \\n    public SnapshotArray(int length) {\\n        snap= new Dictionary<int, int[]>();\\n        snapCount =0;\\n        snapArr= new int[length];\\n    }\\n    \\n    public void Set(int index, int val) {\\n        snapArr[index]=val;\\n    }\\n    \\n    public int Snap() {\\n        int[] copy = new int[snapArr.Length];\\n        snapArr.CopyTo(copy,0);\\n        snap.Add(snapCount,copy);\\n        snapCount++;\\n        return snapCount-1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        return snap[snap_id][index];\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.Set(index,val);\\n * int param_2 = obj.Snap();\\n * int param_3 = obj.Get(index,snap_id);\\n */`"
                    },
                    {
                        "username": "swadesh-vaibhav",
                        "content": "[@dkochetov](/dkochetov)  Git is a bad example, as it does not store differences. It stores entire snapshots of files."
                    },
                    {
                        "username": "dkochetov",
                        "content": "Don't create full clones of the array each time `snap()` is called. Look at how `Git` works, it keeps the information only about the changes, and doesn't waste memory on duplicating parts that haven't changed. Here `git commit` -> `snapshot`, `lines with code` -> `array elements`."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "site1997",
                        "content": "I use nested vector during contest, and it didn\\'t pass because of MLE.\\nAfter the contest, I changed all the **pass by value** to **pass by reference**, and it got AC..."
                    },
                    {
                        "username": "sriram7507",
                        "content": "first mle now tle (\\'\\'....\\'\\')"
                    }
                ]
            },
            {
                "id": 1572886,
                "content": [
                    {
                        "username": "meakub",
                        "content": "With same input, if I run it gives expected result but if submit shows incorrect result.\\n![image](https://assets.leetcode.com/users/images/caac6003-fb6e-4afe-b0d1-c65f84b3f0d5_1639195063.85086.png)\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "Do not use global variables or static variables, the system is performing all of the tests using multiple threads in a shared memory environment, meaning your code needs to be re-entrant safe. In other words, your global variable can be used by other threads. Since there is just a single thread when you run it using \"run\", you don\\'t see the issue."
                    },
                    {
                        "username": "breathermachine",
                        "content": "snapCount shouldn\\'t have to be declared as static. It effectively makes snapCount a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "ehmyitayew",
                        "content": "A couple of things that weren\\'t clear from the questions:\\n- if snap isn\\'t called, changes aren\\'t persisted. I.e if you for instance you have a set() followed by a get() before any snaps that should result with a 0\\n- when getting, you don\\'t need to have have the exact snap_id, it is more like the latest snapshot <= snap_id"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I did what the questions asked, but got testcases checking for more than described!\\nWhy not showing a constraing that memory allocation must be smaller smaller O(Snaps,Length)=O(N*M)?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I agree with this. If there are specific (strong) memory, or time constraints for that matter, it would be good to have that shown in the description as well"
                    },
                    {
                        "username": "devtiwari",
                        "content": "![image](https://assets.leetcode.com/users/images/fde5914d-de7c-4351-b4bc-b609d2301f02_1598803315.1373239.png)\\nsee this image carefully  and you will understand what is wrong with this question."
                    },
                    {
                        "username": "breathermachine",
                        "content": "`cnt` shouldn\\'t have to be declared as static. It effectively makes `cnt` a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Bruh ! it\\'s still the same"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "some more hints to avoid TLE\\nHINT 1 : no need to store each new value when set is called. ( just store the latest value for current snapid)\\nHINT 2 : no need to store values of all index at each snap. ( store new snapid with new value if set after snap )"
                    },
                    {
                        "username": "jackconvolution",
                        "content": "You saved my day! Thanks!"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Woooo, i thought it\\'s simple Hash Map problem, but it turns out to be a binary search problem\\nNow Everyday I get to know some new way to use binary search"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Bro it is a Simple Hash map problem."
                    },
                    {
                        "username": "feng3245",
                        "content": "The last question too... it was optional but how many of us can math wiz a question during interview.."
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "Whats wrong with my approach?\\n\\n ``` class SnapshotArray {\\npublic:\\n    int snapno = 0;\\n    vector<vector<int>> vec;\\n    int col = 0;\\n    SnapshotArray(int length) {\\n        vec.resize(1,vector<int>(length,0));\\n        col = length;\\n    }\\n    void set(int index, int val) {\\n        vec[snapno][index] = val;\\n    }\\n    int snap() {\\n        snapno++;\\n        vec.push_back(vector<int>(col,0));\\n        return snapno-1;\\n    }\\n    int get(int index, int snap_id) {\\n        return vec[snap_id][index];\\n    \\n    }\\n}; ```\\n\\nIt is giving error on the test case\\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\\n\\n\\nI think test case is itself faulty."
                    },
                    {
                        "username": "thegameworden",
                        "content": "I run out of memory with this one... I pass almost all test cases though. Can anyone assist me in this?\\n\\n `public class SnapshotArray {\\n    Dictionary<int, int[]> snap;\\n    int snapCount;\\n    int[] snapArr;\\n    \\n    public SnapshotArray(int length) {\\n        snap= new Dictionary<int, int[]>();\\n        snapCount =0;\\n        snapArr= new int[length];\\n    }\\n    \\n    public void Set(int index, int val) {\\n        snapArr[index]=val;\\n    }\\n    \\n    public int Snap() {\\n        int[] copy = new int[snapArr.Length];\\n        snapArr.CopyTo(copy,0);\\n        snap.Add(snapCount,copy);\\n        snapCount++;\\n        return snapCount-1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        return snap[snap_id][index];\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.Set(index,val);\\n * int param_2 = obj.Snap();\\n * int param_3 = obj.Get(index,snap_id);\\n */`"
                    },
                    {
                        "username": "swadesh-vaibhav",
                        "content": "[@dkochetov](/dkochetov)  Git is a bad example, as it does not store differences. It stores entire snapshots of files."
                    },
                    {
                        "username": "dkochetov",
                        "content": "Don't create full clones of the array each time `snap()` is called. Look at how `Git` works, it keeps the information only about the changes, and doesn't waste memory on duplicating parts that haven't changed. Here `git commit` -> `snapshot`, `lines with code` -> `array elements`."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "site1997",
                        "content": "I use nested vector during contest, and it didn\\'t pass because of MLE.\\nAfter the contest, I changed all the **pass by value** to **pass by reference**, and it got AC..."
                    },
                    {
                        "username": "sriram7507",
                        "content": "first mle now tle (\\'\\'....\\'\\')"
                    }
                ]
            },
            {
                "id": 2050318,
                "content": [
                    {
                        "username": "meakub",
                        "content": "With same input, if I run it gives expected result but if submit shows incorrect result.\\n![image](https://assets.leetcode.com/users/images/caac6003-fb6e-4afe-b0d1-c65f84b3f0d5_1639195063.85086.png)\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "Do not use global variables or static variables, the system is performing all of the tests using multiple threads in a shared memory environment, meaning your code needs to be re-entrant safe. In other words, your global variable can be used by other threads. Since there is just a single thread when you run it using \"run\", you don\\'t see the issue."
                    },
                    {
                        "username": "breathermachine",
                        "content": "snapCount shouldn\\'t have to be declared as static. It effectively makes snapCount a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "ehmyitayew",
                        "content": "A couple of things that weren\\'t clear from the questions:\\n- if snap isn\\'t called, changes aren\\'t persisted. I.e if you for instance you have a set() followed by a get() before any snaps that should result with a 0\\n- when getting, you don\\'t need to have have the exact snap_id, it is more like the latest snapshot <= snap_id"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I did what the questions asked, but got testcases checking for more than described!\\nWhy not showing a constraing that memory allocation must be smaller smaller O(Snaps,Length)=O(N*M)?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I agree with this. If there are specific (strong) memory, or time constraints for that matter, it would be good to have that shown in the description as well"
                    },
                    {
                        "username": "devtiwari",
                        "content": "![image](https://assets.leetcode.com/users/images/fde5914d-de7c-4351-b4bc-b609d2301f02_1598803315.1373239.png)\\nsee this image carefully  and you will understand what is wrong with this question."
                    },
                    {
                        "username": "breathermachine",
                        "content": "`cnt` shouldn\\'t have to be declared as static. It effectively makes `cnt` a global variable and will not be initialized to 0 for each test case"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Bruh ! it\\'s still the same"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "some more hints to avoid TLE\\nHINT 1 : no need to store each new value when set is called. ( just store the latest value for current snapid)\\nHINT 2 : no need to store values of all index at each snap. ( store new snapid with new value if set after snap )"
                    },
                    {
                        "username": "jackconvolution",
                        "content": "You saved my day! Thanks!"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Woooo, i thought it\\'s simple Hash Map problem, but it turns out to be a binary search problem\\nNow Everyday I get to know some new way to use binary search"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Bro it is a Simple Hash map problem."
                    },
                    {
                        "username": "feng3245",
                        "content": "The last question too... it was optional but how many of us can math wiz a question during interview.."
                    },
                    {
                        "username": "iamprogrammer47",
                        "content": "Whats wrong with my approach?\\n\\n ``` class SnapshotArray {\\npublic:\\n    int snapno = 0;\\n    vector<vector<int>> vec;\\n    int col = 0;\\n    SnapshotArray(int length) {\\n        vec.resize(1,vector<int>(length,0));\\n        col = length;\\n    }\\n    void set(int index, int val) {\\n        vec[snapno][index] = val;\\n    }\\n    int snap() {\\n        snapno++;\\n        vec.push_back(vector<int>(col,0));\\n        return snapno-1;\\n    }\\n    int get(int index, int snap_id) {\\n        return vec[snap_id][index];\\n    \\n    }\\n}; ```\\n\\nIt is giving error on the test case\\n[\"SnapshotArray\",\"set\",\"snap\",\"snap\",\"snap\",\"get\",\"snap\",\"snap\",\"get\"]\\n[[1],[0,15],[],[],[],[0,2],[],[],[0,0]]\\n\\n\\nI think test case is itself faulty."
                    },
                    {
                        "username": "thegameworden",
                        "content": "I run out of memory with this one... I pass almost all test cases though. Can anyone assist me in this?\\n\\n `public class SnapshotArray {\\n    Dictionary<int, int[]> snap;\\n    int snapCount;\\n    int[] snapArr;\\n    \\n    public SnapshotArray(int length) {\\n        snap= new Dictionary<int, int[]>();\\n        snapCount =0;\\n        snapArr= new int[length];\\n    }\\n    \\n    public void Set(int index, int val) {\\n        snapArr[index]=val;\\n    }\\n    \\n    public int Snap() {\\n        int[] copy = new int[snapArr.Length];\\n        snapArr.CopyTo(copy,0);\\n        snap.Add(snapCount,copy);\\n        snapCount++;\\n        return snapCount-1;\\n    }\\n    \\n    public int Get(int index, int snap_id) {\\n        return snap[snap_id][index];\\n    }\\n}\\n\\n/**\\n * Your SnapshotArray object will be instantiated and called as such:\\n * SnapshotArray obj = new SnapshotArray(length);\\n * obj.Set(index,val);\\n * int param_2 = obj.Snap();\\n * int param_3 = obj.Get(index,snap_id);\\n */`"
                    },
                    {
                        "username": "swadesh-vaibhav",
                        "content": "[@dkochetov](/dkochetov)  Git is a bad example, as it does not store differences. It stores entire snapshots of files."
                    },
                    {
                        "username": "dkochetov",
                        "content": "Don't create full clones of the array each time `snap()` is called. Look at how `Git` works, it keeps the information only about the changes, and doesn't waste memory on duplicating parts that haven't changed. Here `git commit` -> `snapshot`, `lines with code` -> `array elements`."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I actually raised it earlier, as many solutions were using the approach that could lead to MLE.. You may checkout details here..\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/11892\\n\\nOr may checkout better solution here too..\\n\\nhttps://leetcode.com/problems/snapshot-array/submissions/902049066/"
                    },
                    {
                        "username": "site1997",
                        "content": "I use nested vector during contest, and it didn\\'t pass because of MLE.\\nAfter the contest, I changed all the **pass by value** to **pass by reference**, and it got AC..."
                    },
                    {
                        "username": "sriram7507",
                        "content": "first mle now tle (\\'\\'....\\'\\')"
                    }
                ]
            },
            {
                "id": 1989806,
                "content": [
                    {
                        "username": "Neroli08",
                        "content": "Curious.. Which number I should pass to the get() as the snap_id If I never call the snap()? -1 or 0? The snap_id is 0, does that mean I have called the snap()  once since snap_id: the total number of times we called snap() minus 1."
                    },
                    {
                        "username": "who_rules",
                        "content": "Leetcode: Use a list of lists, adding both the element and the snap_id to each index.\\nMe: Following suggestion\\nLeetcode: Memory Limit Exceeded"
                    },
                    {
                        "username": "MaAsh99",
                        "content": "it is not clear to me what to do when a constraint broken. Do I just create nothing when given length is > 50000 or do I make one with the length = 50000? and what do I return when an invalid index or snap_id are given? do I just return NULL or -1 or do I throw an error? how did you guys know what to do? "
                    },
                    {
                        "username": "weselyong",
                        "content": "Before I started, I'd like to know which one is more important `space` or `time` from the description.\nOr by user cases : would it be write a lot or snap very often?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "*The interviewer is clearly confused, not expecting such a question.\\n\\u2013 Ummm, let\\'s consider all the possibilities?.."
                    },
                    {
                        "username": "piskaryovnikita",
                        "content": "This logic of getting value with snap_id is kind of similar to what snapshot isolation in DBs does[more info: Data Intensive Applications, Snapshot Isolation and Repeatable Read, p237].\\nSo the problem useful anyway :)"
                    },
                    {
                        "username": "drgIv",
                        "content": "for js\\nbro,remember that you can uses object like  pointer"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "I dont think the treemap is expected to be used in an interview as its inbuilt floorEntry function is used"
                    },
                    {
                        "username": "shux0223",
                        "content": "class SnapshotArray {\\npublic:\\n    unordered_map<int, int> changes;\\n    vector<unordered_map<int, int>>snapshots;\\n    SnapshotArray(int length) {\\n    }\\n    void set(int index, int val) {\\n        changes.insert({index,val});\\n    }\\n    \\n    int snap() {\\n        snapshots.push_back(changes);\\n        changes.clear();\\n        return snapshots.size()-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        for(int i = snap_id; i>=0; i--) {\\n            auto snap = snapshots[i];\\n            if(snap.find(index) != snap.end()) return snap[index];\\n        }\\n        return 0;\\n    }\\n};\\nwhy am i getting a mle when i m using o(set operations) of memory\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline!\\n\\nThe size of the data made this an interesting problem. There was no way that you would be able to save a copy of the array at each snapshot and you couldn\\'t hash the snapshots because a linear search of the snapshots will take too long."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\\u201CIn this world, wherever there is light \\u2013 there are also shadows. As long as the concept of winners exists, there must also be losers.\\u201D \\u2013 Madara"
                    }
                ]
            },
            {
                "id": 1952238,
                "content": [
                    {
                        "username": "Neroli08",
                        "content": "Curious.. Which number I should pass to the get() as the snap_id If I never call the snap()? -1 or 0? The snap_id is 0, does that mean I have called the snap()  once since snap_id: the total number of times we called snap() minus 1."
                    },
                    {
                        "username": "who_rules",
                        "content": "Leetcode: Use a list of lists, adding both the element and the snap_id to each index.\\nMe: Following suggestion\\nLeetcode: Memory Limit Exceeded"
                    },
                    {
                        "username": "MaAsh99",
                        "content": "it is not clear to me what to do when a constraint broken. Do I just create nothing when given length is > 50000 or do I make one with the length = 50000? and what do I return when an invalid index or snap_id are given? do I just return NULL or -1 or do I throw an error? how did you guys know what to do? "
                    },
                    {
                        "username": "weselyong",
                        "content": "Before I started, I'd like to know which one is more important `space` or `time` from the description.\nOr by user cases : would it be write a lot or snap very often?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "*The interviewer is clearly confused, not expecting such a question.\\n\\u2013 Ummm, let\\'s consider all the possibilities?.."
                    },
                    {
                        "username": "piskaryovnikita",
                        "content": "This logic of getting value with snap_id is kind of similar to what snapshot isolation in DBs does[more info: Data Intensive Applications, Snapshot Isolation and Repeatable Read, p237].\\nSo the problem useful anyway :)"
                    },
                    {
                        "username": "drgIv",
                        "content": "for js\\nbro,remember that you can uses object like  pointer"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "I dont think the treemap is expected to be used in an interview as its inbuilt floorEntry function is used"
                    },
                    {
                        "username": "shux0223",
                        "content": "class SnapshotArray {\\npublic:\\n    unordered_map<int, int> changes;\\n    vector<unordered_map<int, int>>snapshots;\\n    SnapshotArray(int length) {\\n    }\\n    void set(int index, int val) {\\n        changes.insert({index,val});\\n    }\\n    \\n    int snap() {\\n        snapshots.push_back(changes);\\n        changes.clear();\\n        return snapshots.size()-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        for(int i = snap_id; i>=0; i--) {\\n            auto snap = snapshots[i];\\n            if(snap.find(index) != snap.end()) return snap[index];\\n        }\\n        return 0;\\n    }\\n};\\nwhy am i getting a mle when i m using o(set operations) of memory\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline!\\n\\nThe size of the data made this an interesting problem. There was no way that you would be able to save a copy of the array at each snapshot and you couldn\\'t hash the snapshots because a linear search of the snapshots will take too long."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\\u201CIn this world, wherever there is light \\u2013 there are also shadows. As long as the concept of winners exists, there must also be losers.\\u201D \\u2013 Madara"
                    }
                ]
            },
            {
                "id": 1944072,
                "content": [
                    {
                        "username": "Neroli08",
                        "content": "Curious.. Which number I should pass to the get() as the snap_id If I never call the snap()? -1 or 0? The snap_id is 0, does that mean I have called the snap()  once since snap_id: the total number of times we called snap() minus 1."
                    },
                    {
                        "username": "who_rules",
                        "content": "Leetcode: Use a list of lists, adding both the element and the snap_id to each index.\\nMe: Following suggestion\\nLeetcode: Memory Limit Exceeded"
                    },
                    {
                        "username": "MaAsh99",
                        "content": "it is not clear to me what to do when a constraint broken. Do I just create nothing when given length is > 50000 or do I make one with the length = 50000? and what do I return when an invalid index or snap_id are given? do I just return NULL or -1 or do I throw an error? how did you guys know what to do? "
                    },
                    {
                        "username": "weselyong",
                        "content": "Before I started, I'd like to know which one is more important `space` or `time` from the description.\nOr by user cases : would it be write a lot or snap very often?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "*The interviewer is clearly confused, not expecting such a question.\\n\\u2013 Ummm, let\\'s consider all the possibilities?.."
                    },
                    {
                        "username": "piskaryovnikita",
                        "content": "This logic of getting value with snap_id is kind of similar to what snapshot isolation in DBs does[more info: Data Intensive Applications, Snapshot Isolation and Repeatable Read, p237].\\nSo the problem useful anyway :)"
                    },
                    {
                        "username": "drgIv",
                        "content": "for js\\nbro,remember that you can uses object like  pointer"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "I dont think the treemap is expected to be used in an interview as its inbuilt floorEntry function is used"
                    },
                    {
                        "username": "shux0223",
                        "content": "class SnapshotArray {\\npublic:\\n    unordered_map<int, int> changes;\\n    vector<unordered_map<int, int>>snapshots;\\n    SnapshotArray(int length) {\\n    }\\n    void set(int index, int val) {\\n        changes.insert({index,val});\\n    }\\n    \\n    int snap() {\\n        snapshots.push_back(changes);\\n        changes.clear();\\n        return snapshots.size()-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        for(int i = snap_id; i>=0; i--) {\\n            auto snap = snapshots[i];\\n            if(snap.find(index) != snap.end()) return snap[index];\\n        }\\n        return 0;\\n    }\\n};\\nwhy am i getting a mle when i m using o(set operations) of memory\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline!\\n\\nThe size of the data made this an interesting problem. There was no way that you would be able to save a copy of the array at each snapshot and you couldn\\'t hash the snapshots because a linear search of the snapshots will take too long."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\\u201CIn this world, wherever there is light \\u2013 there are also shadows. As long as the concept of winners exists, there must also be losers.\\u201D \\u2013 Madara"
                    }
                ]
            },
            {
                "id": 1937861,
                "content": [
                    {
                        "username": "Neroli08",
                        "content": "Curious.. Which number I should pass to the get() as the snap_id If I never call the snap()? -1 or 0? The snap_id is 0, does that mean I have called the snap()  once since snap_id: the total number of times we called snap() minus 1."
                    },
                    {
                        "username": "who_rules",
                        "content": "Leetcode: Use a list of lists, adding both the element and the snap_id to each index.\\nMe: Following suggestion\\nLeetcode: Memory Limit Exceeded"
                    },
                    {
                        "username": "MaAsh99",
                        "content": "it is not clear to me what to do when a constraint broken. Do I just create nothing when given length is > 50000 or do I make one with the length = 50000? and what do I return when an invalid index or snap_id are given? do I just return NULL or -1 or do I throw an error? how did you guys know what to do? "
                    },
                    {
                        "username": "weselyong",
                        "content": "Before I started, I'd like to know which one is more important `space` or `time` from the description.\nOr by user cases : would it be write a lot or snap very often?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "*The interviewer is clearly confused, not expecting such a question.\\n\\u2013 Ummm, let\\'s consider all the possibilities?.."
                    },
                    {
                        "username": "piskaryovnikita",
                        "content": "This logic of getting value with snap_id is kind of similar to what snapshot isolation in DBs does[more info: Data Intensive Applications, Snapshot Isolation and Repeatable Read, p237].\\nSo the problem useful anyway :)"
                    },
                    {
                        "username": "drgIv",
                        "content": "for js\\nbro,remember that you can uses object like  pointer"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "I dont think the treemap is expected to be used in an interview as its inbuilt floorEntry function is used"
                    },
                    {
                        "username": "shux0223",
                        "content": "class SnapshotArray {\\npublic:\\n    unordered_map<int, int> changes;\\n    vector<unordered_map<int, int>>snapshots;\\n    SnapshotArray(int length) {\\n    }\\n    void set(int index, int val) {\\n        changes.insert({index,val});\\n    }\\n    \\n    int snap() {\\n        snapshots.push_back(changes);\\n        changes.clear();\\n        return snapshots.size()-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        for(int i = snap_id; i>=0; i--) {\\n            auto snap = snapshots[i];\\n            if(snap.find(index) != snap.end()) return snap[index];\\n        }\\n        return 0;\\n    }\\n};\\nwhy am i getting a mle when i m using o(set operations) of memory\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline!\\n\\nThe size of the data made this an interesting problem. There was no way that you would be able to save a copy of the array at each snapshot and you couldn\\'t hash the snapshots because a linear search of the snapshots will take too long."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\\u201CIn this world, wherever there is light \\u2013 there are also shadows. As long as the concept of winners exists, there must also be losers.\\u201D \\u2013 Madara"
                    }
                ]
            },
            {
                "id": 1928367,
                "content": [
                    {
                        "username": "Neroli08",
                        "content": "Curious.. Which number I should pass to the get() as the snap_id If I never call the snap()? -1 or 0? The snap_id is 0, does that mean I have called the snap()  once since snap_id: the total number of times we called snap() minus 1."
                    },
                    {
                        "username": "who_rules",
                        "content": "Leetcode: Use a list of lists, adding both the element and the snap_id to each index.\\nMe: Following suggestion\\nLeetcode: Memory Limit Exceeded"
                    },
                    {
                        "username": "MaAsh99",
                        "content": "it is not clear to me what to do when a constraint broken. Do I just create nothing when given length is > 50000 or do I make one with the length = 50000? and what do I return when an invalid index or snap_id are given? do I just return NULL or -1 or do I throw an error? how did you guys know what to do? "
                    },
                    {
                        "username": "weselyong",
                        "content": "Before I started, I'd like to know which one is more important `space` or `time` from the description.\nOr by user cases : would it be write a lot or snap very often?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "*The interviewer is clearly confused, not expecting such a question.\\n\\u2013 Ummm, let\\'s consider all the possibilities?.."
                    },
                    {
                        "username": "piskaryovnikita",
                        "content": "This logic of getting value with snap_id is kind of similar to what snapshot isolation in DBs does[more info: Data Intensive Applications, Snapshot Isolation and Repeatable Read, p237].\\nSo the problem useful anyway :)"
                    },
                    {
                        "username": "drgIv",
                        "content": "for js\\nbro,remember that you can uses object like  pointer"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "I dont think the treemap is expected to be used in an interview as its inbuilt floorEntry function is used"
                    },
                    {
                        "username": "shux0223",
                        "content": "class SnapshotArray {\\npublic:\\n    unordered_map<int, int> changes;\\n    vector<unordered_map<int, int>>snapshots;\\n    SnapshotArray(int length) {\\n    }\\n    void set(int index, int val) {\\n        changes.insert({index,val});\\n    }\\n    \\n    int snap() {\\n        snapshots.push_back(changes);\\n        changes.clear();\\n        return snapshots.size()-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        for(int i = snap_id; i>=0; i--) {\\n            auto snap = snapshots[i];\\n            if(snap.find(index) != snap.end()) return snap[index];\\n        }\\n        return 0;\\n    }\\n};\\nwhy am i getting a mle when i m using o(set operations) of memory\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline!\\n\\nThe size of the data made this an interesting problem. There was no way that you would be able to save a copy of the array at each snapshot and you couldn\\'t hash the snapshots because a linear search of the snapshots will take too long."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\\u201CIn this world, wherever there is light \\u2013 there are also shadows. As long as the concept of winners exists, there must also be losers.\\u201D \\u2013 Madara"
                    }
                ]
            },
            {
                "id": 1928090,
                "content": [
                    {
                        "username": "Neroli08",
                        "content": "Curious.. Which number I should pass to the get() as the snap_id If I never call the snap()? -1 or 0? The snap_id is 0, does that mean I have called the snap()  once since snap_id: the total number of times we called snap() minus 1."
                    },
                    {
                        "username": "who_rules",
                        "content": "Leetcode: Use a list of lists, adding both the element and the snap_id to each index.\\nMe: Following suggestion\\nLeetcode: Memory Limit Exceeded"
                    },
                    {
                        "username": "MaAsh99",
                        "content": "it is not clear to me what to do when a constraint broken. Do I just create nothing when given length is > 50000 or do I make one with the length = 50000? and what do I return when an invalid index or snap_id are given? do I just return NULL or -1 or do I throw an error? how did you guys know what to do? "
                    },
                    {
                        "username": "weselyong",
                        "content": "Before I started, I'd like to know which one is more important `space` or `time` from the description.\nOr by user cases : would it be write a lot or snap very often?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "*The interviewer is clearly confused, not expecting such a question.\\n\\u2013 Ummm, let\\'s consider all the possibilities?.."
                    },
                    {
                        "username": "piskaryovnikita",
                        "content": "This logic of getting value with snap_id is kind of similar to what snapshot isolation in DBs does[more info: Data Intensive Applications, Snapshot Isolation and Repeatable Read, p237].\\nSo the problem useful anyway :)"
                    },
                    {
                        "username": "drgIv",
                        "content": "for js\\nbro,remember that you can uses object like  pointer"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "I dont think the treemap is expected to be used in an interview as its inbuilt floorEntry function is used"
                    },
                    {
                        "username": "shux0223",
                        "content": "class SnapshotArray {\\npublic:\\n    unordered_map<int, int> changes;\\n    vector<unordered_map<int, int>>snapshots;\\n    SnapshotArray(int length) {\\n    }\\n    void set(int index, int val) {\\n        changes.insert({index,val});\\n    }\\n    \\n    int snap() {\\n        snapshots.push_back(changes);\\n        changes.clear();\\n        return snapshots.size()-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        for(int i = snap_id; i>=0; i--) {\\n            auto snap = snapshots[i];\\n            if(snap.find(index) != snap.end()) return snap[index];\\n        }\\n        return 0;\\n    }\\n};\\nwhy am i getting a mle when i m using o(set operations) of memory\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline!\\n\\nThe size of the data made this an interesting problem. There was no way that you would be able to save a copy of the array at each snapshot and you couldn\\'t hash the snapshots because a linear search of the snapshots will take too long."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\\u201CIn this world, wherever there is light \\u2013 there are also shadows. As long as the concept of winners exists, there must also be losers.\\u201D \\u2013 Madara"
                    }
                ]
            },
            {
                "id": 1927480,
                "content": [
                    {
                        "username": "Neroli08",
                        "content": "Curious.. Which number I should pass to the get() as the snap_id If I never call the snap()? -1 or 0? The snap_id is 0, does that mean I have called the snap()  once since snap_id: the total number of times we called snap() minus 1."
                    },
                    {
                        "username": "who_rules",
                        "content": "Leetcode: Use a list of lists, adding both the element and the snap_id to each index.\\nMe: Following suggestion\\nLeetcode: Memory Limit Exceeded"
                    },
                    {
                        "username": "MaAsh99",
                        "content": "it is not clear to me what to do when a constraint broken. Do I just create nothing when given length is > 50000 or do I make one with the length = 50000? and what do I return when an invalid index or snap_id are given? do I just return NULL or -1 or do I throw an error? how did you guys know what to do? "
                    },
                    {
                        "username": "weselyong",
                        "content": "Before I started, I'd like to know which one is more important `space` or `time` from the description.\nOr by user cases : would it be write a lot or snap very often?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "*The interviewer is clearly confused, not expecting such a question.\\n\\u2013 Ummm, let\\'s consider all the possibilities?.."
                    },
                    {
                        "username": "piskaryovnikita",
                        "content": "This logic of getting value with snap_id is kind of similar to what snapshot isolation in DBs does[more info: Data Intensive Applications, Snapshot Isolation and Repeatable Read, p237].\\nSo the problem useful anyway :)"
                    },
                    {
                        "username": "drgIv",
                        "content": "for js\\nbro,remember that you can uses object like  pointer"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "I dont think the treemap is expected to be used in an interview as its inbuilt floorEntry function is used"
                    },
                    {
                        "username": "shux0223",
                        "content": "class SnapshotArray {\\npublic:\\n    unordered_map<int, int> changes;\\n    vector<unordered_map<int, int>>snapshots;\\n    SnapshotArray(int length) {\\n    }\\n    void set(int index, int val) {\\n        changes.insert({index,val});\\n    }\\n    \\n    int snap() {\\n        snapshots.push_back(changes);\\n        changes.clear();\\n        return snapshots.size()-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        for(int i = snap_id; i>=0; i--) {\\n            auto snap = snapshots[i];\\n            if(snap.find(index) != snap.end()) return snap[index];\\n        }\\n        return 0;\\n    }\\n};\\nwhy am i getting a mle when i m using o(set operations) of memory\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline!\\n\\nThe size of the data made this an interesting problem. There was no way that you would be able to save a copy of the array at each snapshot and you couldn\\'t hash the snapshots because a linear search of the snapshots will take too long."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\\u201CIn this world, wherever there is light \\u2013 there are also shadows. As long as the concept of winners exists, there must also be losers.\\u201D \\u2013 Madara"
                    }
                ]
            },
            {
                "id": 1926959,
                "content": [
                    {
                        "username": "Neroli08",
                        "content": "Curious.. Which number I should pass to the get() as the snap_id If I never call the snap()? -1 or 0? The snap_id is 0, does that mean I have called the snap()  once since snap_id: the total number of times we called snap() minus 1."
                    },
                    {
                        "username": "who_rules",
                        "content": "Leetcode: Use a list of lists, adding both the element and the snap_id to each index.\\nMe: Following suggestion\\nLeetcode: Memory Limit Exceeded"
                    },
                    {
                        "username": "MaAsh99",
                        "content": "it is not clear to me what to do when a constraint broken. Do I just create nothing when given length is > 50000 or do I make one with the length = 50000? and what do I return when an invalid index or snap_id are given? do I just return NULL or -1 or do I throw an error? how did you guys know what to do? "
                    },
                    {
                        "username": "weselyong",
                        "content": "Before I started, I'd like to know which one is more important `space` or `time` from the description.\nOr by user cases : would it be write a lot or snap very often?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "*The interviewer is clearly confused, not expecting such a question.\\n\\u2013 Ummm, let\\'s consider all the possibilities?.."
                    },
                    {
                        "username": "piskaryovnikita",
                        "content": "This logic of getting value with snap_id is kind of similar to what snapshot isolation in DBs does[more info: Data Intensive Applications, Snapshot Isolation and Repeatable Read, p237].\\nSo the problem useful anyway :)"
                    },
                    {
                        "username": "drgIv",
                        "content": "for js\\nbro,remember that you can uses object like  pointer"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "I dont think the treemap is expected to be used in an interview as its inbuilt floorEntry function is used"
                    },
                    {
                        "username": "shux0223",
                        "content": "class SnapshotArray {\\npublic:\\n    unordered_map<int, int> changes;\\n    vector<unordered_map<int, int>>snapshots;\\n    SnapshotArray(int length) {\\n    }\\n    void set(int index, int val) {\\n        changes.insert({index,val});\\n    }\\n    \\n    int snap() {\\n        snapshots.push_back(changes);\\n        changes.clear();\\n        return snapshots.size()-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        for(int i = snap_id; i>=0; i--) {\\n            auto snap = snapshots[i];\\n            if(snap.find(index) != snap.end()) return snap[index];\\n        }\\n        return 0;\\n    }\\n};\\nwhy am i getting a mle when i m using o(set operations) of memory\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline!\\n\\nThe size of the data made this an interesting problem. There was no way that you would be able to save a copy of the array at each snapshot and you couldn\\'t hash the snapshots because a linear search of the snapshots will take too long."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\\u201CIn this world, wherever there is light \\u2013 there are also shadows. As long as the concept of winners exists, there must also be losers.\\u201D \\u2013 Madara"
                    }
                ]
            },
            {
                "id": 1926033,
                "content": [
                    {
                        "username": "Neroli08",
                        "content": "Curious.. Which number I should pass to the get() as the snap_id If I never call the snap()? -1 or 0? The snap_id is 0, does that mean I have called the snap()  once since snap_id: the total number of times we called snap() minus 1."
                    },
                    {
                        "username": "who_rules",
                        "content": "Leetcode: Use a list of lists, adding both the element and the snap_id to each index.\\nMe: Following suggestion\\nLeetcode: Memory Limit Exceeded"
                    },
                    {
                        "username": "MaAsh99",
                        "content": "it is not clear to me what to do when a constraint broken. Do I just create nothing when given length is > 50000 or do I make one with the length = 50000? and what do I return when an invalid index or snap_id are given? do I just return NULL or -1 or do I throw an error? how did you guys know what to do? "
                    },
                    {
                        "username": "weselyong",
                        "content": "Before I started, I'd like to know which one is more important `space` or `time` from the description.\nOr by user cases : would it be write a lot or snap very often?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "*The interviewer is clearly confused, not expecting such a question.\\n\\u2013 Ummm, let\\'s consider all the possibilities?.."
                    },
                    {
                        "username": "piskaryovnikita",
                        "content": "This logic of getting value with snap_id is kind of similar to what snapshot isolation in DBs does[more info: Data Intensive Applications, Snapshot Isolation and Repeatable Read, p237].\\nSo the problem useful anyway :)"
                    },
                    {
                        "username": "drgIv",
                        "content": "for js\\nbro,remember that you can uses object like  pointer"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "I dont think the treemap is expected to be used in an interview as its inbuilt floorEntry function is used"
                    },
                    {
                        "username": "shux0223",
                        "content": "class SnapshotArray {\\npublic:\\n    unordered_map<int, int> changes;\\n    vector<unordered_map<int, int>>snapshots;\\n    SnapshotArray(int length) {\\n    }\\n    void set(int index, int val) {\\n        changes.insert({index,val});\\n    }\\n    \\n    int snap() {\\n        snapshots.push_back(changes);\\n        changes.clear();\\n        return snapshots.size()-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        for(int i = snap_id; i>=0; i--) {\\n            auto snap = snapshots[i];\\n            if(snap.find(index) != snap.end()) return snap[index];\\n        }\\n        return 0;\\n    }\\n};\\nwhy am i getting a mle when i m using o(set operations) of memory\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline!\\n\\nThe size of the data made this an interesting problem. There was no way that you would be able to save a copy of the array at each snapshot and you couldn\\'t hash the snapshots because a linear search of the snapshots will take too long."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\\u201CIn this world, wherever there is light \\u2013 there are also shadows. As long as the concept of winners exists, there must also be losers.\\u201D \\u2013 Madara"
                    }
                ]
            },
            {
                "id": 1925999,
                "content": [
                    {
                        "username": "Neroli08",
                        "content": "Curious.. Which number I should pass to the get() as the snap_id If I never call the snap()? -1 or 0? The snap_id is 0, does that mean I have called the snap()  once since snap_id: the total number of times we called snap() minus 1."
                    },
                    {
                        "username": "who_rules",
                        "content": "Leetcode: Use a list of lists, adding both the element and the snap_id to each index.\\nMe: Following suggestion\\nLeetcode: Memory Limit Exceeded"
                    },
                    {
                        "username": "MaAsh99",
                        "content": "it is not clear to me what to do when a constraint broken. Do I just create nothing when given length is > 50000 or do I make one with the length = 50000? and what do I return when an invalid index or snap_id are given? do I just return NULL or -1 or do I throw an error? how did you guys know what to do? "
                    },
                    {
                        "username": "weselyong",
                        "content": "Before I started, I'd like to know which one is more important `space` or `time` from the description.\nOr by user cases : would it be write a lot or snap very often?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "*The interviewer is clearly confused, not expecting such a question.\\n\\u2013 Ummm, let\\'s consider all the possibilities?.."
                    },
                    {
                        "username": "piskaryovnikita",
                        "content": "This logic of getting value with snap_id is kind of similar to what snapshot isolation in DBs does[more info: Data Intensive Applications, Snapshot Isolation and Repeatable Read, p237].\\nSo the problem useful anyway :)"
                    },
                    {
                        "username": "drgIv",
                        "content": "for js\\nbro,remember that you can uses object like  pointer"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "I dont think the treemap is expected to be used in an interview as its inbuilt floorEntry function is used"
                    },
                    {
                        "username": "shux0223",
                        "content": "class SnapshotArray {\\npublic:\\n    unordered_map<int, int> changes;\\n    vector<unordered_map<int, int>>snapshots;\\n    SnapshotArray(int length) {\\n    }\\n    void set(int index, int val) {\\n        changes.insert({index,val});\\n    }\\n    \\n    int snap() {\\n        snapshots.push_back(changes);\\n        changes.clear();\\n        return snapshots.size()-1;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        for(int i = snap_id; i>=0; i--) {\\n            auto snap = snapshots[i];\\n            if(snap.find(index) != snap.end()) return snap[index];\\n        }\\n        return 0;\\n    }\\n};\\nwhy am i getting a mle when i m using o(set operations) of memory\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline!\\n\\nThe size of the data made this an interesting problem. There was no way that you would be able to save a copy of the array at each snapshot and you couldn\\'t hash the snapshots because a linear search of the snapshots will take too long."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\\u201CIn this world, wherever there is light \\u2013 there are also shadows. As long as the concept of winners exists, there must also be losers.\\u201D \\u2013 Madara"
                    }
                ]
            },
            {
                "id": 1925988,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "idk if it\\'s just me ? but I just can\\'t seem to solve these type of questions at all......like i become totally blank and don\\'t know what to do ? where to start\\nAll these design implementing problems :) (even though I know oops concept)\\nplease someone help me out, how to approach these questions or what to prepare and from where"
                    },
                    {
                        "username": "psionl0",
                        "content": "Get some practice with different data structures and algorithms. The more of these that you become familiar with, the more options will suggest themselves to you when you encounter a problem like this. (It is also not a sin to see how somebody else tackled the problem as long as you don\\'t just copy their answer)."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I don\\'t know why I at least don\\'t understand this type of questions."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Can someone help me out? \\n\\nI worked on this problem and found a solution that I found elegant: I create an array size \"length\", and in each array I store a dictionary which keeps track of the history of that value {snap_id: val}. This however fails the submission acceptance, because of Time Limit. \\n\\nWhen I look at the solution in the Editorial however, the solution they present is extremely similar, with the exception of storing the pairs as array, instead of dict. Can someone explain to me why that is more efficient, and therefore an accepted solution and storing/retrieving from a hash isn\\'t? "
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are doing a linear search of the {snap_id:val} pairs then you will get TLE on the larger test cases. You need to do a Binary Search."
                    },
                    {
                        "username": "feng3245",
                        "content": "Well I didn\\'t check editorial but this question is mostly for memory optimization. When you store snap_id -> val I am assuming you went and store all the vals that have changed once at least... but you don\\'t need to store all the values... because snap shot can refer to prior snap shot especially as the question never ask you for the entire snap shot but an index only. There for you can look to simply store only the changes and somehow only access those changes. Am keeping it vague to not give too much spoilers."
                    },
                    {
                        "username": "dranZerKai",
                        "content": "Why INT_MAX is used in target pair of upper_bound function ?\\n\\nHow upper bound will compare and return?\\n\\n `auto it = upper_bound(historyRecords[index].begin(), historyRecords[index].end(), make_pair(snap_id, INT_MAX));`"
                    },
                    {
                        "username": "vivekpande0512",
                        "content": "upper_bound() for pair(x, y) will return an iterator pointing to the position of pair\n (i) whose first value is equal to x and second value is greater than y.\nor\n(ii) whose first value is greater than x.\n\nINT_MAX ensures that second condition become true always\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "INT_MAX is guaranteed not to appear in the input (the max value goes only to 10^9). The search will obviously fail but upper_bound will give the proper location for the largest snapshot id that\\'s less than snap_id"
                    },
                    {
                        "username": "tiagofabre",
                        "content": "In Clojure this is the default implementation of vectors as it uses immutable data structures under the hood\n\n```Clojure\n(let [arr   [0, 0, 0]  ;; initialize the vector\n      snap1 (assoc arr 0 1)        ;; updates the vector to [1, 0, 0]\n      snap2 (-> arr assoc 0 2 1 3) ;; updates the vector to [2, 3, 0]\narr ;; returned value\n;; any of these vectors can be returned (arr, snap1, snap2)\n])\n```"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Testcase 71/74: TLE \\uD83D\\uDE11"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Even after a week of LC trying to engrain binary search into my brain, I still was doing a linear search to find the `get` result \\uD83D\\uDE11"
                    },
                    {
                        "username": "Prajju22",
                        "content": "still it will give mle\\n\\n"
                    },
                    {
                        "username": "sooryamarri",
                        "content": "Lets see..."
                    },
                    {
                        "username": "amancha9161",
                        "content": "Can someone help me with my approach? PLEASE...\\nI am trying to use a variant of binary search to get the highest possible snap_id in the given question.\\n\\nclass SnapshotArray {\\npublic:\\n    int id = 0;\\n    unordered_map<int, unordered_map<int,int>> theMap;\\n    SnapshotArray(int length) {\\n    }\\n    \\n    void set(int index, int val) {\\n        theMap[index][id] = val;\\n    }\\n    \\n    int snap() {\\n        return id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(theMap[index].find(snap_id) != theMap[index].end())\\n            return theMap[index][snap_id];\\n        // use a variant of binary search to the max snap_id less than\\n        // equal to the given id\\n        int lo = 0, hi = snap_id, mid, idx=0;\\n        while(lo <= hi){\\n            mid = (lo+hi)/2;\\n            auto it = theMap[index].find(mid);\\n            if(it != theMap[index].end()){\\n                idx = mid;\\n                lo = mid + 1;\\n            }\\n            else\\n                hi = mid - 1;\\n        }\\n        return theMap[index][idx];\\n    }\\n};"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Binary search works on **ordered** collections. And guess what, **unordered_map** is not one of them.\nEither do simple linear search, or change map to vector."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Iam not getting intuition of how to binary search here?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "If the requested snapshot ID for a given index doesn't exist, then you'll need to use the largest snapshot ID less than the requested snapshot ID. Basically a floor function. You can use binary search to speed this lookup"
                    }
                ]
            },
            {
                "id": 1925912,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "idk if it\\'s just me ? but I just can\\'t seem to solve these type of questions at all......like i become totally blank and don\\'t know what to do ? where to start\\nAll these design implementing problems :) (even though I know oops concept)\\nplease someone help me out, how to approach these questions or what to prepare and from where"
                    },
                    {
                        "username": "psionl0",
                        "content": "Get some practice with different data structures and algorithms. The more of these that you become familiar with, the more options will suggest themselves to you when you encounter a problem like this. (It is also not a sin to see how somebody else tackled the problem as long as you don\\'t just copy their answer)."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I don\\'t know why I at least don\\'t understand this type of questions."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Can someone help me out? \\n\\nI worked on this problem and found a solution that I found elegant: I create an array size \"length\", and in each array I store a dictionary which keeps track of the history of that value {snap_id: val}. This however fails the submission acceptance, because of Time Limit. \\n\\nWhen I look at the solution in the Editorial however, the solution they present is extremely similar, with the exception of storing the pairs as array, instead of dict. Can someone explain to me why that is more efficient, and therefore an accepted solution and storing/retrieving from a hash isn\\'t? "
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are doing a linear search of the {snap_id:val} pairs then you will get TLE on the larger test cases. You need to do a Binary Search."
                    },
                    {
                        "username": "feng3245",
                        "content": "Well I didn\\'t check editorial but this question is mostly for memory optimization. When you store snap_id -> val I am assuming you went and store all the vals that have changed once at least... but you don\\'t need to store all the values... because snap shot can refer to prior snap shot especially as the question never ask you for the entire snap shot but an index only. There for you can look to simply store only the changes and somehow only access those changes. Am keeping it vague to not give too much spoilers."
                    },
                    {
                        "username": "dranZerKai",
                        "content": "Why INT_MAX is used in target pair of upper_bound function ?\\n\\nHow upper bound will compare and return?\\n\\n `auto it = upper_bound(historyRecords[index].begin(), historyRecords[index].end(), make_pair(snap_id, INT_MAX));`"
                    },
                    {
                        "username": "vivekpande0512",
                        "content": "upper_bound() for pair(x, y) will return an iterator pointing to the position of pair\n (i) whose first value is equal to x and second value is greater than y.\nor\n(ii) whose first value is greater than x.\n\nINT_MAX ensures that second condition become true always\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "INT_MAX is guaranteed not to appear in the input (the max value goes only to 10^9). The search will obviously fail but upper_bound will give the proper location for the largest snapshot id that\\'s less than snap_id"
                    },
                    {
                        "username": "tiagofabre",
                        "content": "In Clojure this is the default implementation of vectors as it uses immutable data structures under the hood\n\n```Clojure\n(let [arr   [0, 0, 0]  ;; initialize the vector\n      snap1 (assoc arr 0 1)        ;; updates the vector to [1, 0, 0]\n      snap2 (-> arr assoc 0 2 1 3) ;; updates the vector to [2, 3, 0]\narr ;; returned value\n;; any of these vectors can be returned (arr, snap1, snap2)\n])\n```"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Testcase 71/74: TLE \\uD83D\\uDE11"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Even after a week of LC trying to engrain binary search into my brain, I still was doing a linear search to find the `get` result \\uD83D\\uDE11"
                    },
                    {
                        "username": "Prajju22",
                        "content": "still it will give mle\\n\\n"
                    },
                    {
                        "username": "sooryamarri",
                        "content": "Lets see..."
                    },
                    {
                        "username": "amancha9161",
                        "content": "Can someone help me with my approach? PLEASE...\\nI am trying to use a variant of binary search to get the highest possible snap_id in the given question.\\n\\nclass SnapshotArray {\\npublic:\\n    int id = 0;\\n    unordered_map<int, unordered_map<int,int>> theMap;\\n    SnapshotArray(int length) {\\n    }\\n    \\n    void set(int index, int val) {\\n        theMap[index][id] = val;\\n    }\\n    \\n    int snap() {\\n        return id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(theMap[index].find(snap_id) != theMap[index].end())\\n            return theMap[index][snap_id];\\n        // use a variant of binary search to the max snap_id less than\\n        // equal to the given id\\n        int lo = 0, hi = snap_id, mid, idx=0;\\n        while(lo <= hi){\\n            mid = (lo+hi)/2;\\n            auto it = theMap[index].find(mid);\\n            if(it != theMap[index].end()){\\n                idx = mid;\\n                lo = mid + 1;\\n            }\\n            else\\n                hi = mid - 1;\\n        }\\n        return theMap[index][idx];\\n    }\\n};"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Binary search works on **ordered** collections. And guess what, **unordered_map** is not one of them.\nEither do simple linear search, or change map to vector."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Iam not getting intuition of how to binary search here?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "If the requested snapshot ID for a given index doesn't exist, then you'll need to use the largest snapshot ID less than the requested snapshot ID. Basically a floor function. You can use binary search to speed this lookup"
                    }
                ]
            },
            {
                "id": 1925890,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "idk if it\\'s just me ? but I just can\\'t seem to solve these type of questions at all......like i become totally blank and don\\'t know what to do ? where to start\\nAll these design implementing problems :) (even though I know oops concept)\\nplease someone help me out, how to approach these questions or what to prepare and from where"
                    },
                    {
                        "username": "psionl0",
                        "content": "Get some practice with different data structures and algorithms. The more of these that you become familiar with, the more options will suggest themselves to you when you encounter a problem like this. (It is also not a sin to see how somebody else tackled the problem as long as you don\\'t just copy their answer)."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I don\\'t know why I at least don\\'t understand this type of questions."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Can someone help me out? \\n\\nI worked on this problem and found a solution that I found elegant: I create an array size \"length\", and in each array I store a dictionary which keeps track of the history of that value {snap_id: val}. This however fails the submission acceptance, because of Time Limit. \\n\\nWhen I look at the solution in the Editorial however, the solution they present is extremely similar, with the exception of storing the pairs as array, instead of dict. Can someone explain to me why that is more efficient, and therefore an accepted solution and storing/retrieving from a hash isn\\'t? "
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are doing a linear search of the {snap_id:val} pairs then you will get TLE on the larger test cases. You need to do a Binary Search."
                    },
                    {
                        "username": "feng3245",
                        "content": "Well I didn\\'t check editorial but this question is mostly for memory optimization. When you store snap_id -> val I am assuming you went and store all the vals that have changed once at least... but you don\\'t need to store all the values... because snap shot can refer to prior snap shot especially as the question never ask you for the entire snap shot but an index only. There for you can look to simply store only the changes and somehow only access those changes. Am keeping it vague to not give too much spoilers."
                    },
                    {
                        "username": "dranZerKai",
                        "content": "Why INT_MAX is used in target pair of upper_bound function ?\\n\\nHow upper bound will compare and return?\\n\\n `auto it = upper_bound(historyRecords[index].begin(), historyRecords[index].end(), make_pair(snap_id, INT_MAX));`"
                    },
                    {
                        "username": "vivekpande0512",
                        "content": "upper_bound() for pair(x, y) will return an iterator pointing to the position of pair\n (i) whose first value is equal to x and second value is greater than y.\nor\n(ii) whose first value is greater than x.\n\nINT_MAX ensures that second condition become true always\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "INT_MAX is guaranteed not to appear in the input (the max value goes only to 10^9). The search will obviously fail but upper_bound will give the proper location for the largest snapshot id that\\'s less than snap_id"
                    },
                    {
                        "username": "tiagofabre",
                        "content": "In Clojure this is the default implementation of vectors as it uses immutable data structures under the hood\n\n```Clojure\n(let [arr   [0, 0, 0]  ;; initialize the vector\n      snap1 (assoc arr 0 1)        ;; updates the vector to [1, 0, 0]\n      snap2 (-> arr assoc 0 2 1 3) ;; updates the vector to [2, 3, 0]\narr ;; returned value\n;; any of these vectors can be returned (arr, snap1, snap2)\n])\n```"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Testcase 71/74: TLE \\uD83D\\uDE11"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Even after a week of LC trying to engrain binary search into my brain, I still was doing a linear search to find the `get` result \\uD83D\\uDE11"
                    },
                    {
                        "username": "Prajju22",
                        "content": "still it will give mle\\n\\n"
                    },
                    {
                        "username": "sooryamarri",
                        "content": "Lets see..."
                    },
                    {
                        "username": "amancha9161",
                        "content": "Can someone help me with my approach? PLEASE...\\nI am trying to use a variant of binary search to get the highest possible snap_id in the given question.\\n\\nclass SnapshotArray {\\npublic:\\n    int id = 0;\\n    unordered_map<int, unordered_map<int,int>> theMap;\\n    SnapshotArray(int length) {\\n    }\\n    \\n    void set(int index, int val) {\\n        theMap[index][id] = val;\\n    }\\n    \\n    int snap() {\\n        return id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(theMap[index].find(snap_id) != theMap[index].end())\\n            return theMap[index][snap_id];\\n        // use a variant of binary search to the max snap_id less than\\n        // equal to the given id\\n        int lo = 0, hi = snap_id, mid, idx=0;\\n        while(lo <= hi){\\n            mid = (lo+hi)/2;\\n            auto it = theMap[index].find(mid);\\n            if(it != theMap[index].end()){\\n                idx = mid;\\n                lo = mid + 1;\\n            }\\n            else\\n                hi = mid - 1;\\n        }\\n        return theMap[index][idx];\\n    }\\n};"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Binary search works on **ordered** collections. And guess what, **unordered_map** is not one of them.\nEither do simple linear search, or change map to vector."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Iam not getting intuition of how to binary search here?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "If the requested snapshot ID for a given index doesn't exist, then you'll need to use the largest snapshot ID less than the requested snapshot ID. Basically a floor function. You can use binary search to speed this lookup"
                    }
                ]
            },
            {
                "id": 1925740,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "idk if it\\'s just me ? but I just can\\'t seem to solve these type of questions at all......like i become totally blank and don\\'t know what to do ? where to start\\nAll these design implementing problems :) (even though I know oops concept)\\nplease someone help me out, how to approach these questions or what to prepare and from where"
                    },
                    {
                        "username": "psionl0",
                        "content": "Get some practice with different data structures and algorithms. The more of these that you become familiar with, the more options will suggest themselves to you when you encounter a problem like this. (It is also not a sin to see how somebody else tackled the problem as long as you don\\'t just copy their answer)."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I don\\'t know why I at least don\\'t understand this type of questions."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Can someone help me out? \\n\\nI worked on this problem and found a solution that I found elegant: I create an array size \"length\", and in each array I store a dictionary which keeps track of the history of that value {snap_id: val}. This however fails the submission acceptance, because of Time Limit. \\n\\nWhen I look at the solution in the Editorial however, the solution they present is extremely similar, with the exception of storing the pairs as array, instead of dict. Can someone explain to me why that is more efficient, and therefore an accepted solution and storing/retrieving from a hash isn\\'t? "
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are doing a linear search of the {snap_id:val} pairs then you will get TLE on the larger test cases. You need to do a Binary Search."
                    },
                    {
                        "username": "feng3245",
                        "content": "Well I didn\\'t check editorial but this question is mostly for memory optimization. When you store snap_id -> val I am assuming you went and store all the vals that have changed once at least... but you don\\'t need to store all the values... because snap shot can refer to prior snap shot especially as the question never ask you for the entire snap shot but an index only. There for you can look to simply store only the changes and somehow only access those changes. Am keeping it vague to not give too much spoilers."
                    },
                    {
                        "username": "dranZerKai",
                        "content": "Why INT_MAX is used in target pair of upper_bound function ?\\n\\nHow upper bound will compare and return?\\n\\n `auto it = upper_bound(historyRecords[index].begin(), historyRecords[index].end(), make_pair(snap_id, INT_MAX));`"
                    },
                    {
                        "username": "vivekpande0512",
                        "content": "upper_bound() for pair(x, y) will return an iterator pointing to the position of pair\n (i) whose first value is equal to x and second value is greater than y.\nor\n(ii) whose first value is greater than x.\n\nINT_MAX ensures that second condition become true always\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "INT_MAX is guaranteed not to appear in the input (the max value goes only to 10^9). The search will obviously fail but upper_bound will give the proper location for the largest snapshot id that\\'s less than snap_id"
                    },
                    {
                        "username": "tiagofabre",
                        "content": "In Clojure this is the default implementation of vectors as it uses immutable data structures under the hood\n\n```Clojure\n(let [arr   [0, 0, 0]  ;; initialize the vector\n      snap1 (assoc arr 0 1)        ;; updates the vector to [1, 0, 0]\n      snap2 (-> arr assoc 0 2 1 3) ;; updates the vector to [2, 3, 0]\narr ;; returned value\n;; any of these vectors can be returned (arr, snap1, snap2)\n])\n```"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Testcase 71/74: TLE \\uD83D\\uDE11"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Even after a week of LC trying to engrain binary search into my brain, I still was doing a linear search to find the `get` result \\uD83D\\uDE11"
                    },
                    {
                        "username": "Prajju22",
                        "content": "still it will give mle\\n\\n"
                    },
                    {
                        "username": "sooryamarri",
                        "content": "Lets see..."
                    },
                    {
                        "username": "amancha9161",
                        "content": "Can someone help me with my approach? PLEASE...\\nI am trying to use a variant of binary search to get the highest possible snap_id in the given question.\\n\\nclass SnapshotArray {\\npublic:\\n    int id = 0;\\n    unordered_map<int, unordered_map<int,int>> theMap;\\n    SnapshotArray(int length) {\\n    }\\n    \\n    void set(int index, int val) {\\n        theMap[index][id] = val;\\n    }\\n    \\n    int snap() {\\n        return id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(theMap[index].find(snap_id) != theMap[index].end())\\n            return theMap[index][snap_id];\\n        // use a variant of binary search to the max snap_id less than\\n        // equal to the given id\\n        int lo = 0, hi = snap_id, mid, idx=0;\\n        while(lo <= hi){\\n            mid = (lo+hi)/2;\\n            auto it = theMap[index].find(mid);\\n            if(it != theMap[index].end()){\\n                idx = mid;\\n                lo = mid + 1;\\n            }\\n            else\\n                hi = mid - 1;\\n        }\\n        return theMap[index][idx];\\n    }\\n};"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Binary search works on **ordered** collections. And guess what, **unordered_map** is not one of them.\nEither do simple linear search, or change map to vector."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Iam not getting intuition of how to binary search here?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "If the requested snapshot ID for a given index doesn't exist, then you'll need to use the largest snapshot ID less than the requested snapshot ID. Basically a floor function. You can use binary search to speed this lookup"
                    }
                ]
            },
            {
                "id": 1925697,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "idk if it\\'s just me ? but I just can\\'t seem to solve these type of questions at all......like i become totally blank and don\\'t know what to do ? where to start\\nAll these design implementing problems :) (even though I know oops concept)\\nplease someone help me out, how to approach these questions or what to prepare and from where"
                    },
                    {
                        "username": "psionl0",
                        "content": "Get some practice with different data structures and algorithms. The more of these that you become familiar with, the more options will suggest themselves to you when you encounter a problem like this. (It is also not a sin to see how somebody else tackled the problem as long as you don\\'t just copy their answer)."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I don\\'t know why I at least don\\'t understand this type of questions."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Can someone help me out? \\n\\nI worked on this problem and found a solution that I found elegant: I create an array size \"length\", and in each array I store a dictionary which keeps track of the history of that value {snap_id: val}. This however fails the submission acceptance, because of Time Limit. \\n\\nWhen I look at the solution in the Editorial however, the solution they present is extremely similar, with the exception of storing the pairs as array, instead of dict. Can someone explain to me why that is more efficient, and therefore an accepted solution and storing/retrieving from a hash isn\\'t? "
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are doing a linear search of the {snap_id:val} pairs then you will get TLE on the larger test cases. You need to do a Binary Search."
                    },
                    {
                        "username": "feng3245",
                        "content": "Well I didn\\'t check editorial but this question is mostly for memory optimization. When you store snap_id -> val I am assuming you went and store all the vals that have changed once at least... but you don\\'t need to store all the values... because snap shot can refer to prior snap shot especially as the question never ask you for the entire snap shot but an index only. There for you can look to simply store only the changes and somehow only access those changes. Am keeping it vague to not give too much spoilers."
                    },
                    {
                        "username": "dranZerKai",
                        "content": "Why INT_MAX is used in target pair of upper_bound function ?\\n\\nHow upper bound will compare and return?\\n\\n `auto it = upper_bound(historyRecords[index].begin(), historyRecords[index].end(), make_pair(snap_id, INT_MAX));`"
                    },
                    {
                        "username": "vivekpande0512",
                        "content": "upper_bound() for pair(x, y) will return an iterator pointing to the position of pair\n (i) whose first value is equal to x and second value is greater than y.\nor\n(ii) whose first value is greater than x.\n\nINT_MAX ensures that second condition become true always\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "INT_MAX is guaranteed not to appear in the input (the max value goes only to 10^9). The search will obviously fail but upper_bound will give the proper location for the largest snapshot id that\\'s less than snap_id"
                    },
                    {
                        "username": "tiagofabre",
                        "content": "In Clojure this is the default implementation of vectors as it uses immutable data structures under the hood\n\n```Clojure\n(let [arr   [0, 0, 0]  ;; initialize the vector\n      snap1 (assoc arr 0 1)        ;; updates the vector to [1, 0, 0]\n      snap2 (-> arr assoc 0 2 1 3) ;; updates the vector to [2, 3, 0]\narr ;; returned value\n;; any of these vectors can be returned (arr, snap1, snap2)\n])\n```"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Testcase 71/74: TLE \\uD83D\\uDE11"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Even after a week of LC trying to engrain binary search into my brain, I still was doing a linear search to find the `get` result \\uD83D\\uDE11"
                    },
                    {
                        "username": "Prajju22",
                        "content": "still it will give mle\\n\\n"
                    },
                    {
                        "username": "sooryamarri",
                        "content": "Lets see..."
                    },
                    {
                        "username": "amancha9161",
                        "content": "Can someone help me with my approach? PLEASE...\\nI am trying to use a variant of binary search to get the highest possible snap_id in the given question.\\n\\nclass SnapshotArray {\\npublic:\\n    int id = 0;\\n    unordered_map<int, unordered_map<int,int>> theMap;\\n    SnapshotArray(int length) {\\n    }\\n    \\n    void set(int index, int val) {\\n        theMap[index][id] = val;\\n    }\\n    \\n    int snap() {\\n        return id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(theMap[index].find(snap_id) != theMap[index].end())\\n            return theMap[index][snap_id];\\n        // use a variant of binary search to the max snap_id less than\\n        // equal to the given id\\n        int lo = 0, hi = snap_id, mid, idx=0;\\n        while(lo <= hi){\\n            mid = (lo+hi)/2;\\n            auto it = theMap[index].find(mid);\\n            if(it != theMap[index].end()){\\n                idx = mid;\\n                lo = mid + 1;\\n            }\\n            else\\n                hi = mid - 1;\\n        }\\n        return theMap[index][idx];\\n    }\\n};"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Binary search works on **ordered** collections. And guess what, **unordered_map** is not one of them.\nEither do simple linear search, or change map to vector."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Iam not getting intuition of how to binary search here?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "If the requested snapshot ID for a given index doesn't exist, then you'll need to use the largest snapshot ID less than the requested snapshot ID. Basically a floor function. You can use binary search to speed this lookup"
                    }
                ]
            },
            {
                "id": 1925567,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "idk if it\\'s just me ? but I just can\\'t seem to solve these type of questions at all......like i become totally blank and don\\'t know what to do ? where to start\\nAll these design implementing problems :) (even though I know oops concept)\\nplease someone help me out, how to approach these questions or what to prepare and from where"
                    },
                    {
                        "username": "psionl0",
                        "content": "Get some practice with different data structures and algorithms. The more of these that you become familiar with, the more options will suggest themselves to you when you encounter a problem like this. (It is also not a sin to see how somebody else tackled the problem as long as you don\\'t just copy their answer)."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I don\\'t know why I at least don\\'t understand this type of questions."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Can someone help me out? \\n\\nI worked on this problem and found a solution that I found elegant: I create an array size \"length\", and in each array I store a dictionary which keeps track of the history of that value {snap_id: val}. This however fails the submission acceptance, because of Time Limit. \\n\\nWhen I look at the solution in the Editorial however, the solution they present is extremely similar, with the exception of storing the pairs as array, instead of dict. Can someone explain to me why that is more efficient, and therefore an accepted solution and storing/retrieving from a hash isn\\'t? "
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are doing a linear search of the {snap_id:val} pairs then you will get TLE on the larger test cases. You need to do a Binary Search."
                    },
                    {
                        "username": "feng3245",
                        "content": "Well I didn\\'t check editorial but this question is mostly for memory optimization. When you store snap_id -> val I am assuming you went and store all the vals that have changed once at least... but you don\\'t need to store all the values... because snap shot can refer to prior snap shot especially as the question never ask you for the entire snap shot but an index only. There for you can look to simply store only the changes and somehow only access those changes. Am keeping it vague to not give too much spoilers."
                    },
                    {
                        "username": "dranZerKai",
                        "content": "Why INT_MAX is used in target pair of upper_bound function ?\\n\\nHow upper bound will compare and return?\\n\\n `auto it = upper_bound(historyRecords[index].begin(), historyRecords[index].end(), make_pair(snap_id, INT_MAX));`"
                    },
                    {
                        "username": "vivekpande0512",
                        "content": "upper_bound() for pair(x, y) will return an iterator pointing to the position of pair\n (i) whose first value is equal to x and second value is greater than y.\nor\n(ii) whose first value is greater than x.\n\nINT_MAX ensures that second condition become true always\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "INT_MAX is guaranteed not to appear in the input (the max value goes only to 10^9). The search will obviously fail but upper_bound will give the proper location for the largest snapshot id that\\'s less than snap_id"
                    },
                    {
                        "username": "tiagofabre",
                        "content": "In Clojure this is the default implementation of vectors as it uses immutable data structures under the hood\n\n```Clojure\n(let [arr   [0, 0, 0]  ;; initialize the vector\n      snap1 (assoc arr 0 1)        ;; updates the vector to [1, 0, 0]\n      snap2 (-> arr assoc 0 2 1 3) ;; updates the vector to [2, 3, 0]\narr ;; returned value\n;; any of these vectors can be returned (arr, snap1, snap2)\n])\n```"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Testcase 71/74: TLE \\uD83D\\uDE11"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Even after a week of LC trying to engrain binary search into my brain, I still was doing a linear search to find the `get` result \\uD83D\\uDE11"
                    },
                    {
                        "username": "Prajju22",
                        "content": "still it will give mle\\n\\n"
                    },
                    {
                        "username": "sooryamarri",
                        "content": "Lets see..."
                    },
                    {
                        "username": "amancha9161",
                        "content": "Can someone help me with my approach? PLEASE...\\nI am trying to use a variant of binary search to get the highest possible snap_id in the given question.\\n\\nclass SnapshotArray {\\npublic:\\n    int id = 0;\\n    unordered_map<int, unordered_map<int,int>> theMap;\\n    SnapshotArray(int length) {\\n    }\\n    \\n    void set(int index, int val) {\\n        theMap[index][id] = val;\\n    }\\n    \\n    int snap() {\\n        return id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(theMap[index].find(snap_id) != theMap[index].end())\\n            return theMap[index][snap_id];\\n        // use a variant of binary search to the max snap_id less than\\n        // equal to the given id\\n        int lo = 0, hi = snap_id, mid, idx=0;\\n        while(lo <= hi){\\n            mid = (lo+hi)/2;\\n            auto it = theMap[index].find(mid);\\n            if(it != theMap[index].end()){\\n                idx = mid;\\n                lo = mid + 1;\\n            }\\n            else\\n                hi = mid - 1;\\n        }\\n        return theMap[index][idx];\\n    }\\n};"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Binary search works on **ordered** collections. And guess what, **unordered_map** is not one of them.\nEither do simple linear search, or change map to vector."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Iam not getting intuition of how to binary search here?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "If the requested snapshot ID for a given index doesn't exist, then you'll need to use the largest snapshot ID less than the requested snapshot ID. Basically a floor function. You can use binary search to speed this lookup"
                    }
                ]
            },
            {
                "id": 1925459,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "idk if it\\'s just me ? but I just can\\'t seem to solve these type of questions at all......like i become totally blank and don\\'t know what to do ? where to start\\nAll these design implementing problems :) (even though I know oops concept)\\nplease someone help me out, how to approach these questions or what to prepare and from where"
                    },
                    {
                        "username": "psionl0",
                        "content": "Get some practice with different data structures and algorithms. The more of these that you become familiar with, the more options will suggest themselves to you when you encounter a problem like this. (It is also not a sin to see how somebody else tackled the problem as long as you don\\'t just copy their answer)."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I don\\'t know why I at least don\\'t understand this type of questions."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Can someone help me out? \\n\\nI worked on this problem and found a solution that I found elegant: I create an array size \"length\", and in each array I store a dictionary which keeps track of the history of that value {snap_id: val}. This however fails the submission acceptance, because of Time Limit. \\n\\nWhen I look at the solution in the Editorial however, the solution they present is extremely similar, with the exception of storing the pairs as array, instead of dict. Can someone explain to me why that is more efficient, and therefore an accepted solution and storing/retrieving from a hash isn\\'t? "
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are doing a linear search of the {snap_id:val} pairs then you will get TLE on the larger test cases. You need to do a Binary Search."
                    },
                    {
                        "username": "feng3245",
                        "content": "Well I didn\\'t check editorial but this question is mostly for memory optimization. When you store snap_id -> val I am assuming you went and store all the vals that have changed once at least... but you don\\'t need to store all the values... because snap shot can refer to prior snap shot especially as the question never ask you for the entire snap shot but an index only. There for you can look to simply store only the changes and somehow only access those changes. Am keeping it vague to not give too much spoilers."
                    },
                    {
                        "username": "dranZerKai",
                        "content": "Why INT_MAX is used in target pair of upper_bound function ?\\n\\nHow upper bound will compare and return?\\n\\n `auto it = upper_bound(historyRecords[index].begin(), historyRecords[index].end(), make_pair(snap_id, INT_MAX));`"
                    },
                    {
                        "username": "vivekpande0512",
                        "content": "upper_bound() for pair(x, y) will return an iterator pointing to the position of pair\n (i) whose first value is equal to x and second value is greater than y.\nor\n(ii) whose first value is greater than x.\n\nINT_MAX ensures that second condition become true always\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "INT_MAX is guaranteed not to appear in the input (the max value goes only to 10^9). The search will obviously fail but upper_bound will give the proper location for the largest snapshot id that\\'s less than snap_id"
                    },
                    {
                        "username": "tiagofabre",
                        "content": "In Clojure this is the default implementation of vectors as it uses immutable data structures under the hood\n\n```Clojure\n(let [arr   [0, 0, 0]  ;; initialize the vector\n      snap1 (assoc arr 0 1)        ;; updates the vector to [1, 0, 0]\n      snap2 (-> arr assoc 0 2 1 3) ;; updates the vector to [2, 3, 0]\narr ;; returned value\n;; any of these vectors can be returned (arr, snap1, snap2)\n])\n```"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Testcase 71/74: TLE \\uD83D\\uDE11"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Even after a week of LC trying to engrain binary search into my brain, I still was doing a linear search to find the `get` result \\uD83D\\uDE11"
                    },
                    {
                        "username": "Prajju22",
                        "content": "still it will give mle\\n\\n"
                    },
                    {
                        "username": "sooryamarri",
                        "content": "Lets see..."
                    },
                    {
                        "username": "amancha9161",
                        "content": "Can someone help me with my approach? PLEASE...\\nI am trying to use a variant of binary search to get the highest possible snap_id in the given question.\\n\\nclass SnapshotArray {\\npublic:\\n    int id = 0;\\n    unordered_map<int, unordered_map<int,int>> theMap;\\n    SnapshotArray(int length) {\\n    }\\n    \\n    void set(int index, int val) {\\n        theMap[index][id] = val;\\n    }\\n    \\n    int snap() {\\n        return id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(theMap[index].find(snap_id) != theMap[index].end())\\n            return theMap[index][snap_id];\\n        // use a variant of binary search to the max snap_id less than\\n        // equal to the given id\\n        int lo = 0, hi = snap_id, mid, idx=0;\\n        while(lo <= hi){\\n            mid = (lo+hi)/2;\\n            auto it = theMap[index].find(mid);\\n            if(it != theMap[index].end()){\\n                idx = mid;\\n                lo = mid + 1;\\n            }\\n            else\\n                hi = mid - 1;\\n        }\\n        return theMap[index][idx];\\n    }\\n};"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Binary search works on **ordered** collections. And guess what, **unordered_map** is not one of them.\nEither do simple linear search, or change map to vector."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Iam not getting intuition of how to binary search here?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "If the requested snapshot ID for a given index doesn't exist, then you'll need to use the largest snapshot ID less than the requested snapshot ID. Basically a floor function. You can use binary search to speed this lookup"
                    }
                ]
            },
            {
                "id": 1925457,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "idk if it\\'s just me ? but I just can\\'t seem to solve these type of questions at all......like i become totally blank and don\\'t know what to do ? where to start\\nAll these design implementing problems :) (even though I know oops concept)\\nplease someone help me out, how to approach these questions or what to prepare and from where"
                    },
                    {
                        "username": "psionl0",
                        "content": "Get some practice with different data structures and algorithms. The more of these that you become familiar with, the more options will suggest themselves to you when you encounter a problem like this. (It is also not a sin to see how somebody else tackled the problem as long as you don\\'t just copy their answer)."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I don\\'t know why I at least don\\'t understand this type of questions."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Can someone help me out? \\n\\nI worked on this problem and found a solution that I found elegant: I create an array size \"length\", and in each array I store a dictionary which keeps track of the history of that value {snap_id: val}. This however fails the submission acceptance, because of Time Limit. \\n\\nWhen I look at the solution in the Editorial however, the solution they present is extremely similar, with the exception of storing the pairs as array, instead of dict. Can someone explain to me why that is more efficient, and therefore an accepted solution and storing/retrieving from a hash isn\\'t? "
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are doing a linear search of the {snap_id:val} pairs then you will get TLE on the larger test cases. You need to do a Binary Search."
                    },
                    {
                        "username": "feng3245",
                        "content": "Well I didn\\'t check editorial but this question is mostly for memory optimization. When you store snap_id -> val I am assuming you went and store all the vals that have changed once at least... but you don\\'t need to store all the values... because snap shot can refer to prior snap shot especially as the question never ask you for the entire snap shot but an index only. There for you can look to simply store only the changes and somehow only access those changes. Am keeping it vague to not give too much spoilers."
                    },
                    {
                        "username": "dranZerKai",
                        "content": "Why INT_MAX is used in target pair of upper_bound function ?\\n\\nHow upper bound will compare and return?\\n\\n `auto it = upper_bound(historyRecords[index].begin(), historyRecords[index].end(), make_pair(snap_id, INT_MAX));`"
                    },
                    {
                        "username": "vivekpande0512",
                        "content": "upper_bound() for pair(x, y) will return an iterator pointing to the position of pair\n (i) whose first value is equal to x and second value is greater than y.\nor\n(ii) whose first value is greater than x.\n\nINT_MAX ensures that second condition become true always\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "INT_MAX is guaranteed not to appear in the input (the max value goes only to 10^9). The search will obviously fail but upper_bound will give the proper location for the largest snapshot id that\\'s less than snap_id"
                    },
                    {
                        "username": "tiagofabre",
                        "content": "In Clojure this is the default implementation of vectors as it uses immutable data structures under the hood\n\n```Clojure\n(let [arr   [0, 0, 0]  ;; initialize the vector\n      snap1 (assoc arr 0 1)        ;; updates the vector to [1, 0, 0]\n      snap2 (-> arr assoc 0 2 1 3) ;; updates the vector to [2, 3, 0]\narr ;; returned value\n;; any of these vectors can be returned (arr, snap1, snap2)\n])\n```"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Testcase 71/74: TLE \\uD83D\\uDE11"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Even after a week of LC trying to engrain binary search into my brain, I still was doing a linear search to find the `get` result \\uD83D\\uDE11"
                    },
                    {
                        "username": "Prajju22",
                        "content": "still it will give mle\\n\\n"
                    },
                    {
                        "username": "sooryamarri",
                        "content": "Lets see..."
                    },
                    {
                        "username": "amancha9161",
                        "content": "Can someone help me with my approach? PLEASE...\\nI am trying to use a variant of binary search to get the highest possible snap_id in the given question.\\n\\nclass SnapshotArray {\\npublic:\\n    int id = 0;\\n    unordered_map<int, unordered_map<int,int>> theMap;\\n    SnapshotArray(int length) {\\n    }\\n    \\n    void set(int index, int val) {\\n        theMap[index][id] = val;\\n    }\\n    \\n    int snap() {\\n        return id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(theMap[index].find(snap_id) != theMap[index].end())\\n            return theMap[index][snap_id];\\n        // use a variant of binary search to the max snap_id less than\\n        // equal to the given id\\n        int lo = 0, hi = snap_id, mid, idx=0;\\n        while(lo <= hi){\\n            mid = (lo+hi)/2;\\n            auto it = theMap[index].find(mid);\\n            if(it != theMap[index].end()){\\n                idx = mid;\\n                lo = mid + 1;\\n            }\\n            else\\n                hi = mid - 1;\\n        }\\n        return theMap[index][idx];\\n    }\\n};"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Binary search works on **ordered** collections. And guess what, **unordered_map** is not one of them.\nEither do simple linear search, or change map to vector."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Iam not getting intuition of how to binary search here?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "If the requested snapshot ID for a given index doesn't exist, then you'll need to use the largest snapshot ID less than the requested snapshot ID. Basically a floor function. You can use binary search to speed this lookup"
                    }
                ]
            },
            {
                "id": 1925433,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "idk if it\\'s just me ? but I just can\\'t seem to solve these type of questions at all......like i become totally blank and don\\'t know what to do ? where to start\\nAll these design implementing problems :) (even though I know oops concept)\\nplease someone help me out, how to approach these questions or what to prepare and from where"
                    },
                    {
                        "username": "psionl0",
                        "content": "Get some practice with different data structures and algorithms. The more of these that you become familiar with, the more options will suggest themselves to you when you encounter a problem like this. (It is also not a sin to see how somebody else tackled the problem as long as you don\\'t just copy their answer)."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I don\\'t know why I at least don\\'t understand this type of questions."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Can someone help me out? \\n\\nI worked on this problem and found a solution that I found elegant: I create an array size \"length\", and in each array I store a dictionary which keeps track of the history of that value {snap_id: val}. This however fails the submission acceptance, because of Time Limit. \\n\\nWhen I look at the solution in the Editorial however, the solution they present is extremely similar, with the exception of storing the pairs as array, instead of dict. Can someone explain to me why that is more efficient, and therefore an accepted solution and storing/retrieving from a hash isn\\'t? "
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are doing a linear search of the {snap_id:val} pairs then you will get TLE on the larger test cases. You need to do a Binary Search."
                    },
                    {
                        "username": "feng3245",
                        "content": "Well I didn\\'t check editorial but this question is mostly for memory optimization. When you store snap_id -> val I am assuming you went and store all the vals that have changed once at least... but you don\\'t need to store all the values... because snap shot can refer to prior snap shot especially as the question never ask you for the entire snap shot but an index only. There for you can look to simply store only the changes and somehow only access those changes. Am keeping it vague to not give too much spoilers."
                    },
                    {
                        "username": "dranZerKai",
                        "content": "Why INT_MAX is used in target pair of upper_bound function ?\\n\\nHow upper bound will compare and return?\\n\\n `auto it = upper_bound(historyRecords[index].begin(), historyRecords[index].end(), make_pair(snap_id, INT_MAX));`"
                    },
                    {
                        "username": "vivekpande0512",
                        "content": "upper_bound() for pair(x, y) will return an iterator pointing to the position of pair\n (i) whose first value is equal to x and second value is greater than y.\nor\n(ii) whose first value is greater than x.\n\nINT_MAX ensures that second condition become true always\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "INT_MAX is guaranteed not to appear in the input (the max value goes only to 10^9). The search will obviously fail but upper_bound will give the proper location for the largest snapshot id that\\'s less than snap_id"
                    },
                    {
                        "username": "tiagofabre",
                        "content": "In Clojure this is the default implementation of vectors as it uses immutable data structures under the hood\n\n```Clojure\n(let [arr   [0, 0, 0]  ;; initialize the vector\n      snap1 (assoc arr 0 1)        ;; updates the vector to [1, 0, 0]\n      snap2 (-> arr assoc 0 2 1 3) ;; updates the vector to [2, 3, 0]\narr ;; returned value\n;; any of these vectors can be returned (arr, snap1, snap2)\n])\n```"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Testcase 71/74: TLE \\uD83D\\uDE11"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Even after a week of LC trying to engrain binary search into my brain, I still was doing a linear search to find the `get` result \\uD83D\\uDE11"
                    },
                    {
                        "username": "Prajju22",
                        "content": "still it will give mle\\n\\n"
                    },
                    {
                        "username": "sooryamarri",
                        "content": "Lets see..."
                    },
                    {
                        "username": "amancha9161",
                        "content": "Can someone help me with my approach? PLEASE...\\nI am trying to use a variant of binary search to get the highest possible snap_id in the given question.\\n\\nclass SnapshotArray {\\npublic:\\n    int id = 0;\\n    unordered_map<int, unordered_map<int,int>> theMap;\\n    SnapshotArray(int length) {\\n    }\\n    \\n    void set(int index, int val) {\\n        theMap[index][id] = val;\\n    }\\n    \\n    int snap() {\\n        return id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(theMap[index].find(snap_id) != theMap[index].end())\\n            return theMap[index][snap_id];\\n        // use a variant of binary search to the max snap_id less than\\n        // equal to the given id\\n        int lo = 0, hi = snap_id, mid, idx=0;\\n        while(lo <= hi){\\n            mid = (lo+hi)/2;\\n            auto it = theMap[index].find(mid);\\n            if(it != theMap[index].end()){\\n                idx = mid;\\n                lo = mid + 1;\\n            }\\n            else\\n                hi = mid - 1;\\n        }\\n        return theMap[index][idx];\\n    }\\n};"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Binary search works on **ordered** collections. And guess what, **unordered_map** is not one of them.\nEither do simple linear search, or change map to vector."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Iam not getting intuition of how to binary search here?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "If the requested snapshot ID for a given index doesn't exist, then you'll need to use the largest snapshot ID less than the requested snapshot ID. Basically a floor function. You can use binary search to speed this lookup"
                    }
                ]
            },
            {
                "id": 1925407,
                "content": [
                    {
                        "username": "ujjawal_OP",
                        "content": "idk if it\\'s just me ? but I just can\\'t seem to solve these type of questions at all......like i become totally blank and don\\'t know what to do ? where to start\\nAll these design implementing problems :) (even though I know oops concept)\\nplease someone help me out, how to approach these questions or what to prepare and from where"
                    },
                    {
                        "username": "psionl0",
                        "content": "Get some practice with different data structures and algorithms. The more of these that you become familiar with, the more options will suggest themselves to you when you encounter a problem like this. (It is also not a sin to see how somebody else tackled the problem as long as you don\\'t just copy their answer)."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I don\\'t know why I at least don\\'t understand this type of questions."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Can someone help me out? \\n\\nI worked on this problem and found a solution that I found elegant: I create an array size \"length\", and in each array I store a dictionary which keeps track of the history of that value {snap_id: val}. This however fails the submission acceptance, because of Time Limit. \\n\\nWhen I look at the solution in the Editorial however, the solution they present is extremely similar, with the exception of storing the pairs as array, instead of dict. Can someone explain to me why that is more efficient, and therefore an accepted solution and storing/retrieving from a hash isn\\'t? "
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are doing a linear search of the {snap_id:val} pairs then you will get TLE on the larger test cases. You need to do a Binary Search."
                    },
                    {
                        "username": "feng3245",
                        "content": "Well I didn\\'t check editorial but this question is mostly for memory optimization. When you store snap_id -> val I am assuming you went and store all the vals that have changed once at least... but you don\\'t need to store all the values... because snap shot can refer to prior snap shot especially as the question never ask you for the entire snap shot but an index only. There for you can look to simply store only the changes and somehow only access those changes. Am keeping it vague to not give too much spoilers."
                    },
                    {
                        "username": "dranZerKai",
                        "content": "Why INT_MAX is used in target pair of upper_bound function ?\\n\\nHow upper bound will compare and return?\\n\\n `auto it = upper_bound(historyRecords[index].begin(), historyRecords[index].end(), make_pair(snap_id, INT_MAX));`"
                    },
                    {
                        "username": "vivekpande0512",
                        "content": "upper_bound() for pair(x, y) will return an iterator pointing to the position of pair\n (i) whose first value is equal to x and second value is greater than y.\nor\n(ii) whose first value is greater than x.\n\nINT_MAX ensures that second condition become true always\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "INT_MAX is guaranteed not to appear in the input (the max value goes only to 10^9). The search will obviously fail but upper_bound will give the proper location for the largest snapshot id that\\'s less than snap_id"
                    },
                    {
                        "username": "tiagofabre",
                        "content": "In Clojure this is the default implementation of vectors as it uses immutable data structures under the hood\n\n```Clojure\n(let [arr   [0, 0, 0]  ;; initialize the vector\n      snap1 (assoc arr 0 1)        ;; updates the vector to [1, 0, 0]\n      snap2 (-> arr assoc 0 2 1 3) ;; updates the vector to [2, 3, 0]\narr ;; returned value\n;; any of these vectors can be returned (arr, snap1, snap2)\n])\n```"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Testcase 71/74: TLE \\uD83D\\uDE11"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Even after a week of LC trying to engrain binary search into my brain, I still was doing a linear search to find the `get` result \\uD83D\\uDE11"
                    },
                    {
                        "username": "Prajju22",
                        "content": "still it will give mle\\n\\n"
                    },
                    {
                        "username": "sooryamarri",
                        "content": "Lets see..."
                    },
                    {
                        "username": "amancha9161",
                        "content": "Can someone help me with my approach? PLEASE...\\nI am trying to use a variant of binary search to get the highest possible snap_id in the given question.\\n\\nclass SnapshotArray {\\npublic:\\n    int id = 0;\\n    unordered_map<int, unordered_map<int,int>> theMap;\\n    SnapshotArray(int length) {\\n    }\\n    \\n    void set(int index, int val) {\\n        theMap[index][id] = val;\\n    }\\n    \\n    int snap() {\\n        return id++;\\n    }\\n    \\n    int get(int index, int snap_id) {\\n        if(theMap[index].find(snap_id) != theMap[index].end())\\n            return theMap[index][snap_id];\\n        // use a variant of binary search to the max snap_id less than\\n        // equal to the given id\\n        int lo = 0, hi = snap_id, mid, idx=0;\\n        while(lo <= hi){\\n            mid = (lo+hi)/2;\\n            auto it = theMap[index].find(mid);\\n            if(it != theMap[index].end()){\\n                idx = mid;\\n                lo = mid + 1;\\n            }\\n            else\\n                hi = mid - 1;\\n        }\\n        return theMap[index][idx];\\n    }\\n};"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Binary search works on **ordered** collections. And guess what, **unordered_map** is not one of them.\nEither do simple linear search, or change map to vector."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Iam not getting intuition of how to binary search here?\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "If the requested snapshot ID for a given index doesn't exist, then you'll need to use the largest snapshot ID less than the requested snapshot ID. Basically a floor function. You can use binary search to speed this lookup"
                    }
                ]
            },
            {
                "id": 1925356,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "Lots of questions in my mind:\\n1. Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between?\\n2. Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\\n3. will there be snap() calls or get() calls before any set() calls? \\n\\nExamples are not clear."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between? \n>Will there be snap() calls or get() calls before any set() calls?\n\nOf course it can be, why not?\n\n---\n>Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\n\nThat's assumed to be so. If you encounter invalid call, this would be a bug that needs to be reported. Just note the phrase \"**Initially, each element equals 0.**\""
                    },
                    {
                        "username": "breathermachine",
                        "content": "1. Yes\\n2. get() calls will have valid indexes and snap_ids (cannot call get if no snapshot has been made yet)\\n3. Yes, the array is initially set to all zeroes.\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Make sure to remember if any set operation come after a snap it goes to same snap id untill next snap not taken."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Why can\\'t we use Nested Map? It gives TLE on testcase 69/74.\\n\\nApproach for using Nested Map:\\nThe bigger map will store the `snap_id` as the key and the value will another map storing all the changes made in the array (not the whole array, just the changes on that `snap_id`). The map would look like `map<int, map<int, int>>  // snap_id, index, value`. This would result in time complexity of `log (n)`  for `set` function. While running the `get` function, I can just loop through the beginning and find if the given `index` is present in that `snap_id` or not, breaking the loop when `snap_id` is smaller than the key of map, hence resulting in a time complexity of `n log (n)` which is similar with the Editorial.\\n\\nThanks."
                    },
                    {
                        "username": "najwer23",
                        "content": "FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory\\n\\nyhmmm :D\\n\\n"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "so for each index do we have separate snap ids or snap id is independent of the position in array like arr[0] can have snap id 1 and 2 similarly for arr[2] also we can have snap id 1 and 2. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "I think this is a very interesting binary search problem."
                    },
                    {
                        "username": "gabgilp",
                        "content": "I stg this comment is in every single problem."
                    },
                    {
                        "username": "KyrK",
                        "content": "If you struggle, check the hint. It\\'s helpful."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "what is snap() doing?"
                    },
                    {
                        "username": "iamac3",
                        "content": "snap means You have to print values as recorded in the time of last snap. Any modification after that will not be reflected yet in your get function."
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "taking the snapshot of the array at that time\\n"
                    },
                    {
                        "username": "dineshthanneeru",
                        "content": "public int get(int index, int snap_id) {\\n        return Tm[index].floorEntry(snap_id).getValue();\\n        \\n    }\\n\\nIn the get method why floorEntry is using ? please explain\\n"
                    },
                    {
                        "username": "sud140598",
                        "content": "`class SnapshotArray {\npublic:\n    vector<vector<pair<int, int> > > record;\n    int id = 0;\n    SnapshotArray(int length) {\n        for (int i = 0; i < length; i++)\n        {\n            vector<pair<int, int> > v;\n            record.push_back(v);\n        }\n    }\n    \n    void set(int index, int val) {\n        pair<int, int> myPair = {id, val};\n        int currRecordSize = record[index].size();\n\n        // maintain only one record for a snapshot id\n        if (currRecordSize > 0 && record[index][currRecordSize - 1].first == id)\n        {\n            record[index][currRecordSize - 1] = myPair;\n        }\n        else\n        {\n            record[index].push_back(myPair);\n        }\n    }\n    \n    int snap() {\n        return id++;\n    }\n    \n    int get(int index, int snap_id) {\n        auto currRecord = record[index];\n        int beg = 0, end = currRecord.size() - 1;\n        int ans = 0;\n        while (beg <= end)\n        {\n            int mid = beg + (end - beg) / 2;\n            int thisSnapId = currRecord[mid].first;\n            int thisSnapValue = currRecord[mid].second;\n            if (thisSnapId == snap_id)\n            {\n                return thisSnapValue;\n            }\n            if (thisSnapId > snap_id)\n            {\n                end = mid - 1;\n            }\n            else\n            {\n                ans = thisSnapValue;\n                beg = mid + 1;\n            }\n        }\n        return ans;\n    }\n};`\n\nCan someone explain why this solution gives MLE?\nPassing only 69 of 74 testcases"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Did something similar with map<int,vector<pair<int,int>>>..received MLE"
                    }
                ]
            },
            {
                "id": 1925340,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "Lots of questions in my mind:\\n1. Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between?\\n2. Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\\n3. will there be snap() calls or get() calls before any set() calls? \\n\\nExamples are not clear."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between? \n>Will there be snap() calls or get() calls before any set() calls?\n\nOf course it can be, why not?\n\n---\n>Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\n\nThat's assumed to be so. If you encounter invalid call, this would be a bug that needs to be reported. Just note the phrase \"**Initially, each element equals 0.**\""
                    },
                    {
                        "username": "breathermachine",
                        "content": "1. Yes\\n2. get() calls will have valid indexes and snap_ids (cannot call get if no snapshot has been made yet)\\n3. Yes, the array is initially set to all zeroes.\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Make sure to remember if any set operation come after a snap it goes to same snap id untill next snap not taken."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Why can\\'t we use Nested Map? It gives TLE on testcase 69/74.\\n\\nApproach for using Nested Map:\\nThe bigger map will store the `snap_id` as the key and the value will another map storing all the changes made in the array (not the whole array, just the changes on that `snap_id`). The map would look like `map<int, map<int, int>>  // snap_id, index, value`. This would result in time complexity of `log (n)`  for `set` function. While running the `get` function, I can just loop through the beginning and find if the given `index` is present in that `snap_id` or not, breaking the loop when `snap_id` is smaller than the key of map, hence resulting in a time complexity of `n log (n)` which is similar with the Editorial.\\n\\nThanks."
                    },
                    {
                        "username": "najwer23",
                        "content": "FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory\\n\\nyhmmm :D\\n\\n"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "so for each index do we have separate snap ids or snap id is independent of the position in array like arr[0] can have snap id 1 and 2 similarly for arr[2] also we can have snap id 1 and 2. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "I think this is a very interesting binary search problem."
                    },
                    {
                        "username": "gabgilp",
                        "content": "I stg this comment is in every single problem."
                    },
                    {
                        "username": "KyrK",
                        "content": "If you struggle, check the hint. It\\'s helpful."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "what is snap() doing?"
                    },
                    {
                        "username": "iamac3",
                        "content": "snap means You have to print values as recorded in the time of last snap. Any modification after that will not be reflected yet in your get function."
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "taking the snapshot of the array at that time\\n"
                    },
                    {
                        "username": "dineshthanneeru",
                        "content": "public int get(int index, int snap_id) {\\n        return Tm[index].floorEntry(snap_id).getValue();\\n        \\n    }\\n\\nIn the get method why floorEntry is using ? please explain\\n"
                    },
                    {
                        "username": "sud140598",
                        "content": "`class SnapshotArray {\npublic:\n    vector<vector<pair<int, int> > > record;\n    int id = 0;\n    SnapshotArray(int length) {\n        for (int i = 0; i < length; i++)\n        {\n            vector<pair<int, int> > v;\n            record.push_back(v);\n        }\n    }\n    \n    void set(int index, int val) {\n        pair<int, int> myPair = {id, val};\n        int currRecordSize = record[index].size();\n\n        // maintain only one record for a snapshot id\n        if (currRecordSize > 0 && record[index][currRecordSize - 1].first == id)\n        {\n            record[index][currRecordSize - 1] = myPair;\n        }\n        else\n        {\n            record[index].push_back(myPair);\n        }\n    }\n    \n    int snap() {\n        return id++;\n    }\n    \n    int get(int index, int snap_id) {\n        auto currRecord = record[index];\n        int beg = 0, end = currRecord.size() - 1;\n        int ans = 0;\n        while (beg <= end)\n        {\n            int mid = beg + (end - beg) / 2;\n            int thisSnapId = currRecord[mid].first;\n            int thisSnapValue = currRecord[mid].second;\n            if (thisSnapId == snap_id)\n            {\n                return thisSnapValue;\n            }\n            if (thisSnapId > snap_id)\n            {\n                end = mid - 1;\n            }\n            else\n            {\n                ans = thisSnapValue;\n                beg = mid + 1;\n            }\n        }\n        return ans;\n    }\n};`\n\nCan someone explain why this solution gives MLE?\nPassing only 69 of 74 testcases"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Did something similar with map<int,vector<pair<int,int>>>..received MLE"
                    }
                ]
            },
            {
                "id": 1925297,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "Lots of questions in my mind:\\n1. Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between?\\n2. Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\\n3. will there be snap() calls or get() calls before any set() calls? \\n\\nExamples are not clear."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between? \n>Will there be snap() calls or get() calls before any set() calls?\n\nOf course it can be, why not?\n\n---\n>Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\n\nThat's assumed to be so. If you encounter invalid call, this would be a bug that needs to be reported. Just note the phrase \"**Initially, each element equals 0.**\""
                    },
                    {
                        "username": "breathermachine",
                        "content": "1. Yes\\n2. get() calls will have valid indexes and snap_ids (cannot call get if no snapshot has been made yet)\\n3. Yes, the array is initially set to all zeroes.\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Make sure to remember if any set operation come after a snap it goes to same snap id untill next snap not taken."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Why can\\'t we use Nested Map? It gives TLE on testcase 69/74.\\n\\nApproach for using Nested Map:\\nThe bigger map will store the `snap_id` as the key and the value will another map storing all the changes made in the array (not the whole array, just the changes on that `snap_id`). The map would look like `map<int, map<int, int>>  // snap_id, index, value`. This would result in time complexity of `log (n)`  for `set` function. While running the `get` function, I can just loop through the beginning and find if the given `index` is present in that `snap_id` or not, breaking the loop when `snap_id` is smaller than the key of map, hence resulting in a time complexity of `n log (n)` which is similar with the Editorial.\\n\\nThanks."
                    },
                    {
                        "username": "najwer23",
                        "content": "FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory\\n\\nyhmmm :D\\n\\n"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "so for each index do we have separate snap ids or snap id is independent of the position in array like arr[0] can have snap id 1 and 2 similarly for arr[2] also we can have snap id 1 and 2. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "I think this is a very interesting binary search problem."
                    },
                    {
                        "username": "gabgilp",
                        "content": "I stg this comment is in every single problem."
                    },
                    {
                        "username": "KyrK",
                        "content": "If you struggle, check the hint. It\\'s helpful."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "what is snap() doing?"
                    },
                    {
                        "username": "iamac3",
                        "content": "snap means You have to print values as recorded in the time of last snap. Any modification after that will not be reflected yet in your get function."
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "taking the snapshot of the array at that time\\n"
                    },
                    {
                        "username": "dineshthanneeru",
                        "content": "public int get(int index, int snap_id) {\\n        return Tm[index].floorEntry(snap_id).getValue();\\n        \\n    }\\n\\nIn the get method why floorEntry is using ? please explain\\n"
                    },
                    {
                        "username": "sud140598",
                        "content": "`class SnapshotArray {\npublic:\n    vector<vector<pair<int, int> > > record;\n    int id = 0;\n    SnapshotArray(int length) {\n        for (int i = 0; i < length; i++)\n        {\n            vector<pair<int, int> > v;\n            record.push_back(v);\n        }\n    }\n    \n    void set(int index, int val) {\n        pair<int, int> myPair = {id, val};\n        int currRecordSize = record[index].size();\n\n        // maintain only one record for a snapshot id\n        if (currRecordSize > 0 && record[index][currRecordSize - 1].first == id)\n        {\n            record[index][currRecordSize - 1] = myPair;\n        }\n        else\n        {\n            record[index].push_back(myPair);\n        }\n    }\n    \n    int snap() {\n        return id++;\n    }\n    \n    int get(int index, int snap_id) {\n        auto currRecord = record[index];\n        int beg = 0, end = currRecord.size() - 1;\n        int ans = 0;\n        while (beg <= end)\n        {\n            int mid = beg + (end - beg) / 2;\n            int thisSnapId = currRecord[mid].first;\n            int thisSnapValue = currRecord[mid].second;\n            if (thisSnapId == snap_id)\n            {\n                return thisSnapValue;\n            }\n            if (thisSnapId > snap_id)\n            {\n                end = mid - 1;\n            }\n            else\n            {\n                ans = thisSnapValue;\n                beg = mid + 1;\n            }\n        }\n        return ans;\n    }\n};`\n\nCan someone explain why this solution gives MLE?\nPassing only 69 of 74 testcases"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Did something similar with map<int,vector<pair<int,int>>>..received MLE"
                    }
                ]
            },
            {
                "id": 1925296,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "Lots of questions in my mind:\\n1. Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between?\\n2. Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\\n3. will there be snap() calls or get() calls before any set() calls? \\n\\nExamples are not clear."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between? \n>Will there be snap() calls or get() calls before any set() calls?\n\nOf course it can be, why not?\n\n---\n>Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\n\nThat's assumed to be so. If you encounter invalid call, this would be a bug that needs to be reported. Just note the phrase \"**Initially, each element equals 0.**\""
                    },
                    {
                        "username": "breathermachine",
                        "content": "1. Yes\\n2. get() calls will have valid indexes and snap_ids (cannot call get if no snapshot has been made yet)\\n3. Yes, the array is initially set to all zeroes.\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Make sure to remember if any set operation come after a snap it goes to same snap id untill next snap not taken."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Why can\\'t we use Nested Map? It gives TLE on testcase 69/74.\\n\\nApproach for using Nested Map:\\nThe bigger map will store the `snap_id` as the key and the value will another map storing all the changes made in the array (not the whole array, just the changes on that `snap_id`). The map would look like `map<int, map<int, int>>  // snap_id, index, value`. This would result in time complexity of `log (n)`  for `set` function. While running the `get` function, I can just loop through the beginning and find if the given `index` is present in that `snap_id` or not, breaking the loop when `snap_id` is smaller than the key of map, hence resulting in a time complexity of `n log (n)` which is similar with the Editorial.\\n\\nThanks."
                    },
                    {
                        "username": "najwer23",
                        "content": "FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory\\n\\nyhmmm :D\\n\\n"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "so for each index do we have separate snap ids or snap id is independent of the position in array like arr[0] can have snap id 1 and 2 similarly for arr[2] also we can have snap id 1 and 2. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "I think this is a very interesting binary search problem."
                    },
                    {
                        "username": "gabgilp",
                        "content": "I stg this comment is in every single problem."
                    },
                    {
                        "username": "KyrK",
                        "content": "If you struggle, check the hint. It\\'s helpful."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "what is snap() doing?"
                    },
                    {
                        "username": "iamac3",
                        "content": "snap means You have to print values as recorded in the time of last snap. Any modification after that will not be reflected yet in your get function."
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "taking the snapshot of the array at that time\\n"
                    },
                    {
                        "username": "dineshthanneeru",
                        "content": "public int get(int index, int snap_id) {\\n        return Tm[index].floorEntry(snap_id).getValue();\\n        \\n    }\\n\\nIn the get method why floorEntry is using ? please explain\\n"
                    },
                    {
                        "username": "sud140598",
                        "content": "`class SnapshotArray {\npublic:\n    vector<vector<pair<int, int> > > record;\n    int id = 0;\n    SnapshotArray(int length) {\n        for (int i = 0; i < length; i++)\n        {\n            vector<pair<int, int> > v;\n            record.push_back(v);\n        }\n    }\n    \n    void set(int index, int val) {\n        pair<int, int> myPair = {id, val};\n        int currRecordSize = record[index].size();\n\n        // maintain only one record for a snapshot id\n        if (currRecordSize > 0 && record[index][currRecordSize - 1].first == id)\n        {\n            record[index][currRecordSize - 1] = myPair;\n        }\n        else\n        {\n            record[index].push_back(myPair);\n        }\n    }\n    \n    int snap() {\n        return id++;\n    }\n    \n    int get(int index, int snap_id) {\n        auto currRecord = record[index];\n        int beg = 0, end = currRecord.size() - 1;\n        int ans = 0;\n        while (beg <= end)\n        {\n            int mid = beg + (end - beg) / 2;\n            int thisSnapId = currRecord[mid].first;\n            int thisSnapValue = currRecord[mid].second;\n            if (thisSnapId == snap_id)\n            {\n                return thisSnapValue;\n            }\n            if (thisSnapId > snap_id)\n            {\n                end = mid - 1;\n            }\n            else\n            {\n                ans = thisSnapValue;\n                beg = mid + 1;\n            }\n        }\n        return ans;\n    }\n};`\n\nCan someone explain why this solution gives MLE?\nPassing only 69 of 74 testcases"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Did something similar with map<int,vector<pair<int,int>>>..received MLE"
                    }
                ]
            },
            {
                "id": 1925159,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "Lots of questions in my mind:\\n1. Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between?\\n2. Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\\n3. will there be snap() calls or get() calls before any set() calls? \\n\\nExamples are not clear."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between? \n>Will there be snap() calls or get() calls before any set() calls?\n\nOf course it can be, why not?\n\n---\n>Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\n\nThat's assumed to be so. If you encounter invalid call, this would be a bug that needs to be reported. Just note the phrase \"**Initially, each element equals 0.**\""
                    },
                    {
                        "username": "breathermachine",
                        "content": "1. Yes\\n2. get() calls will have valid indexes and snap_ids (cannot call get if no snapshot has been made yet)\\n3. Yes, the array is initially set to all zeroes.\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Make sure to remember if any set operation come after a snap it goes to same snap id untill next snap not taken."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Why can\\'t we use Nested Map? It gives TLE on testcase 69/74.\\n\\nApproach for using Nested Map:\\nThe bigger map will store the `snap_id` as the key and the value will another map storing all the changes made in the array (not the whole array, just the changes on that `snap_id`). The map would look like `map<int, map<int, int>>  // snap_id, index, value`. This would result in time complexity of `log (n)`  for `set` function. While running the `get` function, I can just loop through the beginning and find if the given `index` is present in that `snap_id` or not, breaking the loop when `snap_id` is smaller than the key of map, hence resulting in a time complexity of `n log (n)` which is similar with the Editorial.\\n\\nThanks."
                    },
                    {
                        "username": "najwer23",
                        "content": "FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory\\n\\nyhmmm :D\\n\\n"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "so for each index do we have separate snap ids or snap id is independent of the position in array like arr[0] can have snap id 1 and 2 similarly for arr[2] also we can have snap id 1 and 2. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "I think this is a very interesting binary search problem."
                    },
                    {
                        "username": "gabgilp",
                        "content": "I stg this comment is in every single problem."
                    },
                    {
                        "username": "KyrK",
                        "content": "If you struggle, check the hint. It\\'s helpful."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "what is snap() doing?"
                    },
                    {
                        "username": "iamac3",
                        "content": "snap means You have to print values as recorded in the time of last snap. Any modification after that will not be reflected yet in your get function."
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "taking the snapshot of the array at that time\\n"
                    },
                    {
                        "username": "dineshthanneeru",
                        "content": "public int get(int index, int snap_id) {\\n        return Tm[index].floorEntry(snap_id).getValue();\\n        \\n    }\\n\\nIn the get method why floorEntry is using ? please explain\\n"
                    },
                    {
                        "username": "sud140598",
                        "content": "`class SnapshotArray {\npublic:\n    vector<vector<pair<int, int> > > record;\n    int id = 0;\n    SnapshotArray(int length) {\n        for (int i = 0; i < length; i++)\n        {\n            vector<pair<int, int> > v;\n            record.push_back(v);\n        }\n    }\n    \n    void set(int index, int val) {\n        pair<int, int> myPair = {id, val};\n        int currRecordSize = record[index].size();\n\n        // maintain only one record for a snapshot id\n        if (currRecordSize > 0 && record[index][currRecordSize - 1].first == id)\n        {\n            record[index][currRecordSize - 1] = myPair;\n        }\n        else\n        {\n            record[index].push_back(myPair);\n        }\n    }\n    \n    int snap() {\n        return id++;\n    }\n    \n    int get(int index, int snap_id) {\n        auto currRecord = record[index];\n        int beg = 0, end = currRecord.size() - 1;\n        int ans = 0;\n        while (beg <= end)\n        {\n            int mid = beg + (end - beg) / 2;\n            int thisSnapId = currRecord[mid].first;\n            int thisSnapValue = currRecord[mid].second;\n            if (thisSnapId == snap_id)\n            {\n                return thisSnapValue;\n            }\n            if (thisSnapId > snap_id)\n            {\n                end = mid - 1;\n            }\n            else\n            {\n                ans = thisSnapValue;\n                beg = mid + 1;\n            }\n        }\n        return ans;\n    }\n};`\n\nCan someone explain why this solution gives MLE?\nPassing only 69 of 74 testcases"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Did something similar with map<int,vector<pair<int,int>>>..received MLE"
                    }
                ]
            },
            {
                "id": 1925146,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "Lots of questions in my mind:\\n1. Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between?\\n2. Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\\n3. will there be snap() calls or get() calls before any set() calls? \\n\\nExamples are not clear."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between? \n>Will there be snap() calls or get() calls before any set() calls?\n\nOf course it can be, why not?\n\n---\n>Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\n\nThat's assumed to be so. If you encounter invalid call, this would be a bug that needs to be reported. Just note the phrase \"**Initially, each element equals 0.**\""
                    },
                    {
                        "username": "breathermachine",
                        "content": "1. Yes\\n2. get() calls will have valid indexes and snap_ids (cannot call get if no snapshot has been made yet)\\n3. Yes, the array is initially set to all zeroes.\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Make sure to remember if any set operation come after a snap it goes to same snap id untill next snap not taken."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Why can\\'t we use Nested Map? It gives TLE on testcase 69/74.\\n\\nApproach for using Nested Map:\\nThe bigger map will store the `snap_id` as the key and the value will another map storing all the changes made in the array (not the whole array, just the changes on that `snap_id`). The map would look like `map<int, map<int, int>>  // snap_id, index, value`. This would result in time complexity of `log (n)`  for `set` function. While running the `get` function, I can just loop through the beginning and find if the given `index` is present in that `snap_id` or not, breaking the loop when `snap_id` is smaller than the key of map, hence resulting in a time complexity of `n log (n)` which is similar with the Editorial.\\n\\nThanks."
                    },
                    {
                        "username": "najwer23",
                        "content": "FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory\\n\\nyhmmm :D\\n\\n"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "so for each index do we have separate snap ids or snap id is independent of the position in array like arr[0] can have snap id 1 and 2 similarly for arr[2] also we can have snap id 1 and 2. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "I think this is a very interesting binary search problem."
                    },
                    {
                        "username": "gabgilp",
                        "content": "I stg this comment is in every single problem."
                    },
                    {
                        "username": "KyrK",
                        "content": "If you struggle, check the hint. It\\'s helpful."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "what is snap() doing?"
                    },
                    {
                        "username": "iamac3",
                        "content": "snap means You have to print values as recorded in the time of last snap. Any modification after that will not be reflected yet in your get function."
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "taking the snapshot of the array at that time\\n"
                    },
                    {
                        "username": "dineshthanneeru",
                        "content": "public int get(int index, int snap_id) {\\n        return Tm[index].floorEntry(snap_id).getValue();\\n        \\n    }\\n\\nIn the get method why floorEntry is using ? please explain\\n"
                    },
                    {
                        "username": "sud140598",
                        "content": "`class SnapshotArray {\npublic:\n    vector<vector<pair<int, int> > > record;\n    int id = 0;\n    SnapshotArray(int length) {\n        for (int i = 0; i < length; i++)\n        {\n            vector<pair<int, int> > v;\n            record.push_back(v);\n        }\n    }\n    \n    void set(int index, int val) {\n        pair<int, int> myPair = {id, val};\n        int currRecordSize = record[index].size();\n\n        // maintain only one record for a snapshot id\n        if (currRecordSize > 0 && record[index][currRecordSize - 1].first == id)\n        {\n            record[index][currRecordSize - 1] = myPair;\n        }\n        else\n        {\n            record[index].push_back(myPair);\n        }\n    }\n    \n    int snap() {\n        return id++;\n    }\n    \n    int get(int index, int snap_id) {\n        auto currRecord = record[index];\n        int beg = 0, end = currRecord.size() - 1;\n        int ans = 0;\n        while (beg <= end)\n        {\n            int mid = beg + (end - beg) / 2;\n            int thisSnapId = currRecord[mid].first;\n            int thisSnapValue = currRecord[mid].second;\n            if (thisSnapId == snap_id)\n            {\n                return thisSnapValue;\n            }\n            if (thisSnapId > snap_id)\n            {\n                end = mid - 1;\n            }\n            else\n            {\n                ans = thisSnapValue;\n                beg = mid + 1;\n            }\n        }\n        return ans;\n    }\n};`\n\nCan someone explain why this solution gives MLE?\nPassing only 69 of 74 testcases"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Did something similar with map<int,vector<pair<int,int>>>..received MLE"
                    }
                ]
            },
            {
                "id": 1925123,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "Lots of questions in my mind:\\n1. Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between?\\n2. Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\\n3. will there be snap() calls or get() calls before any set() calls? \\n\\nExamples are not clear."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between? \n>Will there be snap() calls or get() calls before any set() calls?\n\nOf course it can be, why not?\n\n---\n>Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\n\nThat's assumed to be so. If you encounter invalid call, this would be a bug that needs to be reported. Just note the phrase \"**Initially, each element equals 0.**\""
                    },
                    {
                        "username": "breathermachine",
                        "content": "1. Yes\\n2. get() calls will have valid indexes and snap_ids (cannot call get if no snapshot has been made yet)\\n3. Yes, the array is initially set to all zeroes.\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Make sure to remember if any set operation come after a snap it goes to same snap id untill next snap not taken."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Why can\\'t we use Nested Map? It gives TLE on testcase 69/74.\\n\\nApproach for using Nested Map:\\nThe bigger map will store the `snap_id` as the key and the value will another map storing all the changes made in the array (not the whole array, just the changes on that `snap_id`). The map would look like `map<int, map<int, int>>  // snap_id, index, value`. This would result in time complexity of `log (n)`  for `set` function. While running the `get` function, I can just loop through the beginning and find if the given `index` is present in that `snap_id` or not, breaking the loop when `snap_id` is smaller than the key of map, hence resulting in a time complexity of `n log (n)` which is similar with the Editorial.\\n\\nThanks."
                    },
                    {
                        "username": "najwer23",
                        "content": "FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory\\n\\nyhmmm :D\\n\\n"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "so for each index do we have separate snap ids or snap id is independent of the position in array like arr[0] can have snap id 1 and 2 similarly for arr[2] also we can have snap id 1 and 2. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "I think this is a very interesting binary search problem."
                    },
                    {
                        "username": "gabgilp",
                        "content": "I stg this comment is in every single problem."
                    },
                    {
                        "username": "KyrK",
                        "content": "If you struggle, check the hint. It\\'s helpful."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "what is snap() doing?"
                    },
                    {
                        "username": "iamac3",
                        "content": "snap means You have to print values as recorded in the time of last snap. Any modification after that will not be reflected yet in your get function."
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "taking the snapshot of the array at that time\\n"
                    },
                    {
                        "username": "dineshthanneeru",
                        "content": "public int get(int index, int snap_id) {\\n        return Tm[index].floorEntry(snap_id).getValue();\\n        \\n    }\\n\\nIn the get method why floorEntry is using ? please explain\\n"
                    },
                    {
                        "username": "sud140598",
                        "content": "`class SnapshotArray {\npublic:\n    vector<vector<pair<int, int> > > record;\n    int id = 0;\n    SnapshotArray(int length) {\n        for (int i = 0; i < length; i++)\n        {\n            vector<pair<int, int> > v;\n            record.push_back(v);\n        }\n    }\n    \n    void set(int index, int val) {\n        pair<int, int> myPair = {id, val};\n        int currRecordSize = record[index].size();\n\n        // maintain only one record for a snapshot id\n        if (currRecordSize > 0 && record[index][currRecordSize - 1].first == id)\n        {\n            record[index][currRecordSize - 1] = myPair;\n        }\n        else\n        {\n            record[index].push_back(myPair);\n        }\n    }\n    \n    int snap() {\n        return id++;\n    }\n    \n    int get(int index, int snap_id) {\n        auto currRecord = record[index];\n        int beg = 0, end = currRecord.size() - 1;\n        int ans = 0;\n        while (beg <= end)\n        {\n            int mid = beg + (end - beg) / 2;\n            int thisSnapId = currRecord[mid].first;\n            int thisSnapValue = currRecord[mid].second;\n            if (thisSnapId == snap_id)\n            {\n                return thisSnapValue;\n            }\n            if (thisSnapId > snap_id)\n            {\n                end = mid - 1;\n            }\n            else\n            {\n                ans = thisSnapValue;\n                beg = mid + 1;\n            }\n        }\n        return ans;\n    }\n};`\n\nCan someone explain why this solution gives MLE?\nPassing only 69 of 74 testcases"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Did something similar with map<int,vector<pair<int,int>>>..received MLE"
                    }
                ]
            },
            {
                "id": 1925025,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "Lots of questions in my mind:\\n1. Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between?\\n2. Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\\n3. will there be snap() calls or get() calls before any set() calls? \\n\\nExamples are not clear."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between? \n>Will there be snap() calls or get() calls before any set() calls?\n\nOf course it can be, why not?\n\n---\n>Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\n\nThat's assumed to be so. If you encounter invalid call, this would be a bug that needs to be reported. Just note the phrase \"**Initially, each element equals 0.**\""
                    },
                    {
                        "username": "breathermachine",
                        "content": "1. Yes\\n2. get() calls will have valid indexes and snap_ids (cannot call get if no snapshot has been made yet)\\n3. Yes, the array is initially set to all zeroes.\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Make sure to remember if any set operation come after a snap it goes to same snap id untill next snap not taken."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Why can\\'t we use Nested Map? It gives TLE on testcase 69/74.\\n\\nApproach for using Nested Map:\\nThe bigger map will store the `snap_id` as the key and the value will another map storing all the changes made in the array (not the whole array, just the changes on that `snap_id`). The map would look like `map<int, map<int, int>>  // snap_id, index, value`. This would result in time complexity of `log (n)`  for `set` function. While running the `get` function, I can just loop through the beginning and find if the given `index` is present in that `snap_id` or not, breaking the loop when `snap_id` is smaller than the key of map, hence resulting in a time complexity of `n log (n)` which is similar with the Editorial.\\n\\nThanks."
                    },
                    {
                        "username": "najwer23",
                        "content": "FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory\\n\\nyhmmm :D\\n\\n"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "so for each index do we have separate snap ids or snap id is independent of the position in array like arr[0] can have snap id 1 and 2 similarly for arr[2] also we can have snap id 1 and 2. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "I think this is a very interesting binary search problem."
                    },
                    {
                        "username": "gabgilp",
                        "content": "I stg this comment is in every single problem."
                    },
                    {
                        "username": "KyrK",
                        "content": "If you struggle, check the hint. It\\'s helpful."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "what is snap() doing?"
                    },
                    {
                        "username": "iamac3",
                        "content": "snap means You have to print values as recorded in the time of last snap. Any modification after that will not be reflected yet in your get function."
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "taking the snapshot of the array at that time\\n"
                    },
                    {
                        "username": "dineshthanneeru",
                        "content": "public int get(int index, int snap_id) {\\n        return Tm[index].floorEntry(snap_id).getValue();\\n        \\n    }\\n\\nIn the get method why floorEntry is using ? please explain\\n"
                    },
                    {
                        "username": "sud140598",
                        "content": "`class SnapshotArray {\npublic:\n    vector<vector<pair<int, int> > > record;\n    int id = 0;\n    SnapshotArray(int length) {\n        for (int i = 0; i < length; i++)\n        {\n            vector<pair<int, int> > v;\n            record.push_back(v);\n        }\n    }\n    \n    void set(int index, int val) {\n        pair<int, int> myPair = {id, val};\n        int currRecordSize = record[index].size();\n\n        // maintain only one record for a snapshot id\n        if (currRecordSize > 0 && record[index][currRecordSize - 1].first == id)\n        {\n            record[index][currRecordSize - 1] = myPair;\n        }\n        else\n        {\n            record[index].push_back(myPair);\n        }\n    }\n    \n    int snap() {\n        return id++;\n    }\n    \n    int get(int index, int snap_id) {\n        auto currRecord = record[index];\n        int beg = 0, end = currRecord.size() - 1;\n        int ans = 0;\n        while (beg <= end)\n        {\n            int mid = beg + (end - beg) / 2;\n            int thisSnapId = currRecord[mid].first;\n            int thisSnapValue = currRecord[mid].second;\n            if (thisSnapId == snap_id)\n            {\n                return thisSnapValue;\n            }\n            if (thisSnapId > snap_id)\n            {\n                end = mid - 1;\n            }\n            else\n            {\n                ans = thisSnapValue;\n                beg = mid + 1;\n            }\n        }\n        return ans;\n    }\n};`\n\nCan someone explain why this solution gives MLE?\nPassing only 69 of 74 testcases"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Did something similar with map<int,vector<pair<int,int>>>..received MLE"
                    }
                ]
            },
            {
                "id": 1925016,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "Lots of questions in my mind:\\n1. Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between?\\n2. Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\\n3. will there be snap() calls or get() calls before any set() calls? \\n\\nExamples are not clear."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between? \n>Will there be snap() calls or get() calls before any set() calls?\n\nOf course it can be, why not?\n\n---\n>Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\n\nThat's assumed to be so. If you encounter invalid call, this would be a bug that needs to be reported. Just note the phrase \"**Initially, each element equals 0.**\""
                    },
                    {
                        "username": "breathermachine",
                        "content": "1. Yes\\n2. get() calls will have valid indexes and snap_ids (cannot call get if no snapshot has been made yet)\\n3. Yes, the array is initially set to all zeroes.\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Make sure to remember if any set operation come after a snap it goes to same snap id untill next snap not taken."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Why can\\'t we use Nested Map? It gives TLE on testcase 69/74.\\n\\nApproach for using Nested Map:\\nThe bigger map will store the `snap_id` as the key and the value will another map storing all the changes made in the array (not the whole array, just the changes on that `snap_id`). The map would look like `map<int, map<int, int>>  // snap_id, index, value`. This would result in time complexity of `log (n)`  for `set` function. While running the `get` function, I can just loop through the beginning and find if the given `index` is present in that `snap_id` or not, breaking the loop when `snap_id` is smaller than the key of map, hence resulting in a time complexity of `n log (n)` which is similar with the Editorial.\\n\\nThanks."
                    },
                    {
                        "username": "najwer23",
                        "content": "FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory\\n\\nyhmmm :D\\n\\n"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "so for each index do we have separate snap ids or snap id is independent of the position in array like arr[0] can have snap id 1 and 2 similarly for arr[2] also we can have snap id 1 and 2. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "I think this is a very interesting binary search problem."
                    },
                    {
                        "username": "gabgilp",
                        "content": "I stg this comment is in every single problem."
                    },
                    {
                        "username": "KyrK",
                        "content": "If you struggle, check the hint. It\\'s helpful."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "what is snap() doing?"
                    },
                    {
                        "username": "iamac3",
                        "content": "snap means You have to print values as recorded in the time of last snap. Any modification after that will not be reflected yet in your get function."
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "taking the snapshot of the array at that time\\n"
                    },
                    {
                        "username": "dineshthanneeru",
                        "content": "public int get(int index, int snap_id) {\\n        return Tm[index].floorEntry(snap_id).getValue();\\n        \\n    }\\n\\nIn the get method why floorEntry is using ? please explain\\n"
                    },
                    {
                        "username": "sud140598",
                        "content": "`class SnapshotArray {\npublic:\n    vector<vector<pair<int, int> > > record;\n    int id = 0;\n    SnapshotArray(int length) {\n        for (int i = 0; i < length; i++)\n        {\n            vector<pair<int, int> > v;\n            record.push_back(v);\n        }\n    }\n    \n    void set(int index, int val) {\n        pair<int, int> myPair = {id, val};\n        int currRecordSize = record[index].size();\n\n        // maintain only one record for a snapshot id\n        if (currRecordSize > 0 && record[index][currRecordSize - 1].first == id)\n        {\n            record[index][currRecordSize - 1] = myPair;\n        }\n        else\n        {\n            record[index].push_back(myPair);\n        }\n    }\n    \n    int snap() {\n        return id++;\n    }\n    \n    int get(int index, int snap_id) {\n        auto currRecord = record[index];\n        int beg = 0, end = currRecord.size() - 1;\n        int ans = 0;\n        while (beg <= end)\n        {\n            int mid = beg + (end - beg) / 2;\n            int thisSnapId = currRecord[mid].first;\n            int thisSnapValue = currRecord[mid].second;\n            if (thisSnapId == snap_id)\n            {\n                return thisSnapValue;\n            }\n            if (thisSnapId > snap_id)\n            {\n                end = mid - 1;\n            }\n            else\n            {\n                ans = thisSnapValue;\n                beg = mid + 1;\n            }\n        }\n        return ans;\n    }\n};`\n\nCan someone explain why this solution gives MLE?\nPassing only 69 of 74 testcases"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Did something similar with map<int,vector<pair<int,int>>>..received MLE"
                    }
                ]
            },
            {
                "id": 1924926,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "Lots of questions in my mind:\\n1. Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between?\\n2. Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\\n3. will there be snap() calls or get() calls before any set() calls? \\n\\nExamples are not clear."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">Will there be multiple snap() call made consecutively i.e., there wont be any set() calls in between? \n>Will there be snap() calls or get() calls before any set() calls?\n\nOf course it can be, why not?\n\n---\n>Is every get() call valid i.e., is it certain that there is any value mapped to the index and snapId ?\n\nThat's assumed to be so. If you encounter invalid call, this would be a bug that needs to be reported. Just note the phrase \"**Initially, each element equals 0.**\""
                    },
                    {
                        "username": "breathermachine",
                        "content": "1. Yes\\n2. get() calls will have valid indexes and snap_ids (cannot call get if no snapshot has been made yet)\\n3. Yes, the array is initially set to all zeroes.\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "Make sure to remember if any set operation come after a snap it goes to same snap id untill next snap not taken."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Why can\\'t we use Nested Map? It gives TLE on testcase 69/74.\\n\\nApproach for using Nested Map:\\nThe bigger map will store the `snap_id` as the key and the value will another map storing all the changes made in the array (not the whole array, just the changes on that `snap_id`). The map would look like `map<int, map<int, int>>  // snap_id, index, value`. This would result in time complexity of `log (n)`  for `set` function. While running the `get` function, I can just loop through the beginning and find if the given `index` is present in that `snap_id` or not, breaking the loop when `snap_id` is smaller than the key of map, hence resulting in a time complexity of `n log (n)` which is similar with the Editorial.\\n\\nThanks."
                    },
                    {
                        "username": "najwer23",
                        "content": "FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory\\n\\nyhmmm :D\\n\\n"
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "so for each index do we have separate snap ids or snap id is independent of the position in array like arr[0] can have snap id 1 and 2 similarly for arr[2] also we can have snap id 1 and 2. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "I think this is a very interesting binary search problem."
                    },
                    {
                        "username": "gabgilp",
                        "content": "I stg this comment is in every single problem."
                    },
                    {
                        "username": "KyrK",
                        "content": "If you struggle, check the hint. It\\'s helpful."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "what is snap() doing?"
                    },
                    {
                        "username": "iamac3",
                        "content": "snap means You have to print values as recorded in the time of last snap. Any modification after that will not be reflected yet in your get function."
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "taking the snapshot of the array at that time\\n"
                    },
                    {
                        "username": "dineshthanneeru",
                        "content": "public int get(int index, int snap_id) {\\n        return Tm[index].floorEntry(snap_id).getValue();\\n        \\n    }\\n\\nIn the get method why floorEntry is using ? please explain\\n"
                    },
                    {
                        "username": "sud140598",
                        "content": "`class SnapshotArray {\npublic:\n    vector<vector<pair<int, int> > > record;\n    int id = 0;\n    SnapshotArray(int length) {\n        for (int i = 0; i < length; i++)\n        {\n            vector<pair<int, int> > v;\n            record.push_back(v);\n        }\n    }\n    \n    void set(int index, int val) {\n        pair<int, int> myPair = {id, val};\n        int currRecordSize = record[index].size();\n\n        // maintain only one record for a snapshot id\n        if (currRecordSize > 0 && record[index][currRecordSize - 1].first == id)\n        {\n            record[index][currRecordSize - 1] = myPair;\n        }\n        else\n        {\n            record[index].push_back(myPair);\n        }\n    }\n    \n    int snap() {\n        return id++;\n    }\n    \n    int get(int index, int snap_id) {\n        auto currRecord = record[index];\n        int beg = 0, end = currRecord.size() - 1;\n        int ans = 0;\n        while (beg <= end)\n        {\n            int mid = beg + (end - beg) / 2;\n            int thisSnapId = currRecord[mid].first;\n            int thisSnapValue = currRecord[mid].second;\n            if (thisSnapId == snap_id)\n            {\n                return thisSnapValue;\n            }\n            if (thisSnapId > snap_id)\n            {\n                end = mid - 1;\n            }\n            else\n            {\n                ans = thisSnapValue;\n                beg = mid + 1;\n            }\n        }\n        return ans;\n    }\n};`\n\nCan someone explain why this solution gives MLE?\nPassing only 69 of 74 testcases"
                    },
                    {
                        "username": "poiuyt123",
                        "content": "Did something similar with map<int,vector<pair<int,int>>>..received MLE"
                    }
                ]
            },
            {
                "id": 1924910,
                "content": [
                    {
                        "username": "jeetu_23",
                        "content": " ```\nclass SnapshotArray {\npublic:\n        unordered_map<int,unordered_map<int,int>>mp;\n        unordered_map<int,int>cnt;\n        int snaps;\n    SnapshotArray(int length) {\n        mp.clear();\n        cnt.clear();\n        snaps=0;\n    }\n    \n    void set(int index, int val) {\n        cnt[index]=val;\n        return;\n    }\n    \n    int snap() {\n        ++snaps;\n        unordered_map<int,int>&temp=mp[snaps];\n        temp=cnt;\n        return snaps-1;\n    }\n    \n    int get(int index, int snap_id) {\n        unordered_map<int,int>&v=mp[snap_id+1];\n        if(v.find(index)==v.end())return 0;\n        return v[index];\n    }\n};\n```\nWill someone help me why is these giving TLE ,every operation is O(1) then also it gives TLE why???"
                    },
                    {
                        "username": "breathermachine",
                        "content": "`temp=cnt;` is not O(1)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "When I submit my code, I am getting TLE for one testcase, when I use that test case and run the code , no TLE. why is this happening?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@seoli1225](/seoli1225) this is correct. TLE is for cumulative time usage"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "try not using any static  global vairables"
                    },
                    {
                        "username": "seoli1225",
                        "content": "Perheps during the \"submit\" process, the sum of all long testcases exceed the time limit. When you run only one testcase, the time is fine (I guess?)"
                    },
                    {
                        "username": "seoli1225",
                        "content": "If you receive \"Memory Limit Exceeded\", know that the number of snap is almost equal to the number of set and get: the sequence goes like \"set\", \"snap\", \"get\",\"set\", \"snap\", \"get\", instead of a lot of \"set\"s"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Not helpful"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Are this type of questions really asked in interviews!\\nIf yes than how is someone supposed to solve it if the person has not seen the question previously."
                    },
                    {
                        "username": "akshraj_05",
                        "content": "Can you please help me \\nmyOutput == desired Output\\nbut Output that leecode saw != my Output i didi not understand what this is\\n\\n![image](https://i.ibb.co/VDTqLJG/Screenshot-99.png)"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "One of the zero is replaced by 15"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Pass all the testcase and get a TLE... nice :)"
                    },
                    {
                        "username": "TJessop",
                        "content": "This needs more testcases. The hint is also misleading if you weren\\'t expecting binary search based on the other daily problems this week."
                    },
                    {
                        "username": "user7478F",
                        "content": "This is a hard to understand question, I\\'m not able to grasp what is snap function doing?"
                    },
                    {
                        "username": "powerup7",
                        "content": "It\\'s taking a \"snapshot\" or picture of the arr you have in memory. Now be warned, pass by reference or value is important here."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can anyone tell what\\'s wrong with last test case. It gives me tle and the input is blank??"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "New learning: searching in O(1) TC."
                    }
                ]
            },
            {
                "id": 1924726,
                "content": [
                    {
                        "username": "jeetu_23",
                        "content": " ```\nclass SnapshotArray {\npublic:\n        unordered_map<int,unordered_map<int,int>>mp;\n        unordered_map<int,int>cnt;\n        int snaps;\n    SnapshotArray(int length) {\n        mp.clear();\n        cnt.clear();\n        snaps=0;\n    }\n    \n    void set(int index, int val) {\n        cnt[index]=val;\n        return;\n    }\n    \n    int snap() {\n        ++snaps;\n        unordered_map<int,int>&temp=mp[snaps];\n        temp=cnt;\n        return snaps-1;\n    }\n    \n    int get(int index, int snap_id) {\n        unordered_map<int,int>&v=mp[snap_id+1];\n        if(v.find(index)==v.end())return 0;\n        return v[index];\n    }\n};\n```\nWill someone help me why is these giving TLE ,every operation is O(1) then also it gives TLE why???"
                    },
                    {
                        "username": "breathermachine",
                        "content": "`temp=cnt;` is not O(1)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "When I submit my code, I am getting TLE for one testcase, when I use that test case and run the code , no TLE. why is this happening?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@seoli1225](/seoli1225) this is correct. TLE is for cumulative time usage"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "try not using any static  global vairables"
                    },
                    {
                        "username": "seoli1225",
                        "content": "Perheps during the \"submit\" process, the sum of all long testcases exceed the time limit. When you run only one testcase, the time is fine (I guess?)"
                    },
                    {
                        "username": "seoli1225",
                        "content": "If you receive \"Memory Limit Exceeded\", know that the number of snap is almost equal to the number of set and get: the sequence goes like \"set\", \"snap\", \"get\",\"set\", \"snap\", \"get\", instead of a lot of \"set\"s"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Not helpful"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Are this type of questions really asked in interviews!\\nIf yes than how is someone supposed to solve it if the person has not seen the question previously."
                    },
                    {
                        "username": "akshraj_05",
                        "content": "Can you please help me \\nmyOutput == desired Output\\nbut Output that leecode saw != my Output i didi not understand what this is\\n\\n![image](https://i.ibb.co/VDTqLJG/Screenshot-99.png)"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "One of the zero is replaced by 15"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Pass all the testcase and get a TLE... nice :)"
                    },
                    {
                        "username": "TJessop",
                        "content": "This needs more testcases. The hint is also misleading if you weren\\'t expecting binary search based on the other daily problems this week."
                    },
                    {
                        "username": "user7478F",
                        "content": "This is a hard to understand question, I\\'m not able to grasp what is snap function doing?"
                    },
                    {
                        "username": "powerup7",
                        "content": "It\\'s taking a \"snapshot\" or picture of the arr you have in memory. Now be warned, pass by reference or value is important here."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can anyone tell what\\'s wrong with last test case. It gives me tle and the input is blank??"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "New learning: searching in O(1) TC."
                    }
                ]
            },
            {
                "id": 1924725,
                "content": [
                    {
                        "username": "jeetu_23",
                        "content": " ```\nclass SnapshotArray {\npublic:\n        unordered_map<int,unordered_map<int,int>>mp;\n        unordered_map<int,int>cnt;\n        int snaps;\n    SnapshotArray(int length) {\n        mp.clear();\n        cnt.clear();\n        snaps=0;\n    }\n    \n    void set(int index, int val) {\n        cnt[index]=val;\n        return;\n    }\n    \n    int snap() {\n        ++snaps;\n        unordered_map<int,int>&temp=mp[snaps];\n        temp=cnt;\n        return snaps-1;\n    }\n    \n    int get(int index, int snap_id) {\n        unordered_map<int,int>&v=mp[snap_id+1];\n        if(v.find(index)==v.end())return 0;\n        return v[index];\n    }\n};\n```\nWill someone help me why is these giving TLE ,every operation is O(1) then also it gives TLE why???"
                    },
                    {
                        "username": "breathermachine",
                        "content": "`temp=cnt;` is not O(1)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "When I submit my code, I am getting TLE for one testcase, when I use that test case and run the code , no TLE. why is this happening?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@seoli1225](/seoli1225) this is correct. TLE is for cumulative time usage"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "try not using any static  global vairables"
                    },
                    {
                        "username": "seoli1225",
                        "content": "Perheps during the \"submit\" process, the sum of all long testcases exceed the time limit. When you run only one testcase, the time is fine (I guess?)"
                    },
                    {
                        "username": "seoli1225",
                        "content": "If you receive \"Memory Limit Exceeded\", know that the number of snap is almost equal to the number of set and get: the sequence goes like \"set\", \"snap\", \"get\",\"set\", \"snap\", \"get\", instead of a lot of \"set\"s"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Not helpful"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Are this type of questions really asked in interviews!\\nIf yes than how is someone supposed to solve it if the person has not seen the question previously."
                    },
                    {
                        "username": "akshraj_05",
                        "content": "Can you please help me \\nmyOutput == desired Output\\nbut Output that leecode saw != my Output i didi not understand what this is\\n\\n![image](https://i.ibb.co/VDTqLJG/Screenshot-99.png)"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "One of the zero is replaced by 15"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Pass all the testcase and get a TLE... nice :)"
                    },
                    {
                        "username": "TJessop",
                        "content": "This needs more testcases. The hint is also misleading if you weren\\'t expecting binary search based on the other daily problems this week."
                    },
                    {
                        "username": "user7478F",
                        "content": "This is a hard to understand question, I\\'m not able to grasp what is snap function doing?"
                    },
                    {
                        "username": "powerup7",
                        "content": "It\\'s taking a \"snapshot\" or picture of the arr you have in memory. Now be warned, pass by reference or value is important here."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can anyone tell what\\'s wrong with last test case. It gives me tle and the input is blank??"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "New learning: searching in O(1) TC."
                    }
                ]
            },
            {
                "id": 1924503,
                "content": [
                    {
                        "username": "jeetu_23",
                        "content": " ```\nclass SnapshotArray {\npublic:\n        unordered_map<int,unordered_map<int,int>>mp;\n        unordered_map<int,int>cnt;\n        int snaps;\n    SnapshotArray(int length) {\n        mp.clear();\n        cnt.clear();\n        snaps=0;\n    }\n    \n    void set(int index, int val) {\n        cnt[index]=val;\n        return;\n    }\n    \n    int snap() {\n        ++snaps;\n        unordered_map<int,int>&temp=mp[snaps];\n        temp=cnt;\n        return snaps-1;\n    }\n    \n    int get(int index, int snap_id) {\n        unordered_map<int,int>&v=mp[snap_id+1];\n        if(v.find(index)==v.end())return 0;\n        return v[index];\n    }\n};\n```\nWill someone help me why is these giving TLE ,every operation is O(1) then also it gives TLE why???"
                    },
                    {
                        "username": "breathermachine",
                        "content": "`temp=cnt;` is not O(1)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "When I submit my code, I am getting TLE for one testcase, when I use that test case and run the code , no TLE. why is this happening?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@seoli1225](/seoli1225) this is correct. TLE is for cumulative time usage"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "try not using any static  global vairables"
                    },
                    {
                        "username": "seoli1225",
                        "content": "Perheps during the \"submit\" process, the sum of all long testcases exceed the time limit. When you run only one testcase, the time is fine (I guess?)"
                    },
                    {
                        "username": "seoli1225",
                        "content": "If you receive \"Memory Limit Exceeded\", know that the number of snap is almost equal to the number of set and get: the sequence goes like \"set\", \"snap\", \"get\",\"set\", \"snap\", \"get\", instead of a lot of \"set\"s"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Not helpful"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Are this type of questions really asked in interviews!\\nIf yes than how is someone supposed to solve it if the person has not seen the question previously."
                    },
                    {
                        "username": "akshraj_05",
                        "content": "Can you please help me \\nmyOutput == desired Output\\nbut Output that leecode saw != my Output i didi not understand what this is\\n\\n![image](https://i.ibb.co/VDTqLJG/Screenshot-99.png)"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "One of the zero is replaced by 15"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Pass all the testcase and get a TLE... nice :)"
                    },
                    {
                        "username": "TJessop",
                        "content": "This needs more testcases. The hint is also misleading if you weren\\'t expecting binary search based on the other daily problems this week."
                    },
                    {
                        "username": "user7478F",
                        "content": "This is a hard to understand question, I\\'m not able to grasp what is snap function doing?"
                    },
                    {
                        "username": "powerup7",
                        "content": "It\\'s taking a \"snapshot\" or picture of the arr you have in memory. Now be warned, pass by reference or value is important here."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can anyone tell what\\'s wrong with last test case. It gives me tle and the input is blank??"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "New learning: searching in O(1) TC."
                    }
                ]
            },
            {
                "id": 1924493,
                "content": [
                    {
                        "username": "jeetu_23",
                        "content": " ```\nclass SnapshotArray {\npublic:\n        unordered_map<int,unordered_map<int,int>>mp;\n        unordered_map<int,int>cnt;\n        int snaps;\n    SnapshotArray(int length) {\n        mp.clear();\n        cnt.clear();\n        snaps=0;\n    }\n    \n    void set(int index, int val) {\n        cnt[index]=val;\n        return;\n    }\n    \n    int snap() {\n        ++snaps;\n        unordered_map<int,int>&temp=mp[snaps];\n        temp=cnt;\n        return snaps-1;\n    }\n    \n    int get(int index, int snap_id) {\n        unordered_map<int,int>&v=mp[snap_id+1];\n        if(v.find(index)==v.end())return 0;\n        return v[index];\n    }\n};\n```\nWill someone help me why is these giving TLE ,every operation is O(1) then also it gives TLE why???"
                    },
                    {
                        "username": "breathermachine",
                        "content": "`temp=cnt;` is not O(1)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "When I submit my code, I am getting TLE for one testcase, when I use that test case and run the code , no TLE. why is this happening?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@seoli1225](/seoli1225) this is correct. TLE is for cumulative time usage"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "try not using any static  global vairables"
                    },
                    {
                        "username": "seoli1225",
                        "content": "Perheps during the \"submit\" process, the sum of all long testcases exceed the time limit. When you run only one testcase, the time is fine (I guess?)"
                    },
                    {
                        "username": "seoli1225",
                        "content": "If you receive \"Memory Limit Exceeded\", know that the number of snap is almost equal to the number of set and get: the sequence goes like \"set\", \"snap\", \"get\",\"set\", \"snap\", \"get\", instead of a lot of \"set\"s"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Not helpful"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Are this type of questions really asked in interviews!\\nIf yes than how is someone supposed to solve it if the person has not seen the question previously."
                    },
                    {
                        "username": "akshraj_05",
                        "content": "Can you please help me \\nmyOutput == desired Output\\nbut Output that leecode saw != my Output i didi not understand what this is\\n\\n![image](https://i.ibb.co/VDTqLJG/Screenshot-99.png)"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "One of the zero is replaced by 15"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Pass all the testcase and get a TLE... nice :)"
                    },
                    {
                        "username": "TJessop",
                        "content": "This needs more testcases. The hint is also misleading if you weren\\'t expecting binary search based on the other daily problems this week."
                    },
                    {
                        "username": "user7478F",
                        "content": "This is a hard to understand question, I\\'m not able to grasp what is snap function doing?"
                    },
                    {
                        "username": "powerup7",
                        "content": "It\\'s taking a \"snapshot\" or picture of the arr you have in memory. Now be warned, pass by reference or value is important here."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can anyone tell what\\'s wrong with last test case. It gives me tle and the input is blank??"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "New learning: searching in O(1) TC."
                    }
                ]
            },
            {
                "id": 1924477,
                "content": [
                    {
                        "username": "jeetu_23",
                        "content": " ```\nclass SnapshotArray {\npublic:\n        unordered_map<int,unordered_map<int,int>>mp;\n        unordered_map<int,int>cnt;\n        int snaps;\n    SnapshotArray(int length) {\n        mp.clear();\n        cnt.clear();\n        snaps=0;\n    }\n    \n    void set(int index, int val) {\n        cnt[index]=val;\n        return;\n    }\n    \n    int snap() {\n        ++snaps;\n        unordered_map<int,int>&temp=mp[snaps];\n        temp=cnt;\n        return snaps-1;\n    }\n    \n    int get(int index, int snap_id) {\n        unordered_map<int,int>&v=mp[snap_id+1];\n        if(v.find(index)==v.end())return 0;\n        return v[index];\n    }\n};\n```\nWill someone help me why is these giving TLE ,every operation is O(1) then also it gives TLE why???"
                    },
                    {
                        "username": "breathermachine",
                        "content": "`temp=cnt;` is not O(1)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "When I submit my code, I am getting TLE for one testcase, when I use that test case and run the code , no TLE. why is this happening?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@seoli1225](/seoli1225) this is correct. TLE is for cumulative time usage"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "try not using any static  global vairables"
                    },
                    {
                        "username": "seoli1225",
                        "content": "Perheps during the \"submit\" process, the sum of all long testcases exceed the time limit. When you run only one testcase, the time is fine (I guess?)"
                    },
                    {
                        "username": "seoli1225",
                        "content": "If you receive \"Memory Limit Exceeded\", know that the number of snap is almost equal to the number of set and get: the sequence goes like \"set\", \"snap\", \"get\",\"set\", \"snap\", \"get\", instead of a lot of \"set\"s"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Not helpful"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Are this type of questions really asked in interviews!\\nIf yes than how is someone supposed to solve it if the person has not seen the question previously."
                    },
                    {
                        "username": "akshraj_05",
                        "content": "Can you please help me \\nmyOutput == desired Output\\nbut Output that leecode saw != my Output i didi not understand what this is\\n\\n![image](https://i.ibb.co/VDTqLJG/Screenshot-99.png)"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "One of the zero is replaced by 15"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Pass all the testcase and get a TLE... nice :)"
                    },
                    {
                        "username": "TJessop",
                        "content": "This needs more testcases. The hint is also misleading if you weren\\'t expecting binary search based on the other daily problems this week."
                    },
                    {
                        "username": "user7478F",
                        "content": "This is a hard to understand question, I\\'m not able to grasp what is snap function doing?"
                    },
                    {
                        "username": "powerup7",
                        "content": "It\\'s taking a \"snapshot\" or picture of the arr you have in memory. Now be warned, pass by reference or value is important here."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can anyone tell what\\'s wrong with last test case. It gives me tle and the input is blank??"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "New learning: searching in O(1) TC."
                    }
                ]
            },
            {
                "id": 1924461,
                "content": [
                    {
                        "username": "jeetu_23",
                        "content": " ```\nclass SnapshotArray {\npublic:\n        unordered_map<int,unordered_map<int,int>>mp;\n        unordered_map<int,int>cnt;\n        int snaps;\n    SnapshotArray(int length) {\n        mp.clear();\n        cnt.clear();\n        snaps=0;\n    }\n    \n    void set(int index, int val) {\n        cnt[index]=val;\n        return;\n    }\n    \n    int snap() {\n        ++snaps;\n        unordered_map<int,int>&temp=mp[snaps];\n        temp=cnt;\n        return snaps-1;\n    }\n    \n    int get(int index, int snap_id) {\n        unordered_map<int,int>&v=mp[snap_id+1];\n        if(v.find(index)==v.end())return 0;\n        return v[index];\n    }\n};\n```\nWill someone help me why is these giving TLE ,every operation is O(1) then also it gives TLE why???"
                    },
                    {
                        "username": "breathermachine",
                        "content": "`temp=cnt;` is not O(1)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "When I submit my code, I am getting TLE for one testcase, when I use that test case and run the code , no TLE. why is this happening?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@seoli1225](/seoli1225) this is correct. TLE is for cumulative time usage"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "try not using any static  global vairables"
                    },
                    {
                        "username": "seoli1225",
                        "content": "Perheps during the \"submit\" process, the sum of all long testcases exceed the time limit. When you run only one testcase, the time is fine (I guess?)"
                    },
                    {
                        "username": "seoli1225",
                        "content": "If you receive \"Memory Limit Exceeded\", know that the number of snap is almost equal to the number of set and get: the sequence goes like \"set\", \"snap\", \"get\",\"set\", \"snap\", \"get\", instead of a lot of \"set\"s"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Not helpful"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Are this type of questions really asked in interviews!\\nIf yes than how is someone supposed to solve it if the person has not seen the question previously."
                    },
                    {
                        "username": "akshraj_05",
                        "content": "Can you please help me \\nmyOutput == desired Output\\nbut Output that leecode saw != my Output i didi not understand what this is\\n\\n![image](https://i.ibb.co/VDTqLJG/Screenshot-99.png)"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "One of the zero is replaced by 15"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Pass all the testcase and get a TLE... nice :)"
                    },
                    {
                        "username": "TJessop",
                        "content": "This needs more testcases. The hint is also misleading if you weren\\'t expecting binary search based on the other daily problems this week."
                    },
                    {
                        "username": "user7478F",
                        "content": "This is a hard to understand question, I\\'m not able to grasp what is snap function doing?"
                    },
                    {
                        "username": "powerup7",
                        "content": "It\\'s taking a \"snapshot\" or picture of the arr you have in memory. Now be warned, pass by reference or value is important here."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can anyone tell what\\'s wrong with last test case. It gives me tle and the input is blank??"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "New learning: searching in O(1) TC."
                    }
                ]
            },
            {
                "id": 1924441,
                "content": [
                    {
                        "username": "jeetu_23",
                        "content": " ```\nclass SnapshotArray {\npublic:\n        unordered_map<int,unordered_map<int,int>>mp;\n        unordered_map<int,int>cnt;\n        int snaps;\n    SnapshotArray(int length) {\n        mp.clear();\n        cnt.clear();\n        snaps=0;\n    }\n    \n    void set(int index, int val) {\n        cnt[index]=val;\n        return;\n    }\n    \n    int snap() {\n        ++snaps;\n        unordered_map<int,int>&temp=mp[snaps];\n        temp=cnt;\n        return snaps-1;\n    }\n    \n    int get(int index, int snap_id) {\n        unordered_map<int,int>&v=mp[snap_id+1];\n        if(v.find(index)==v.end())return 0;\n        return v[index];\n    }\n};\n```\nWill someone help me why is these giving TLE ,every operation is O(1) then also it gives TLE why???"
                    },
                    {
                        "username": "breathermachine",
                        "content": "`temp=cnt;` is not O(1)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "When I submit my code, I am getting TLE for one testcase, when I use that test case and run the code , no TLE. why is this happening?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@seoli1225](/seoli1225) this is correct. TLE is for cumulative time usage"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "try not using any static  global vairables"
                    },
                    {
                        "username": "seoli1225",
                        "content": "Perheps during the \"submit\" process, the sum of all long testcases exceed the time limit. When you run only one testcase, the time is fine (I guess?)"
                    },
                    {
                        "username": "seoli1225",
                        "content": "If you receive \"Memory Limit Exceeded\", know that the number of snap is almost equal to the number of set and get: the sequence goes like \"set\", \"snap\", \"get\",\"set\", \"snap\", \"get\", instead of a lot of \"set\"s"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Not helpful"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Are this type of questions really asked in interviews!\\nIf yes than how is someone supposed to solve it if the person has not seen the question previously."
                    },
                    {
                        "username": "akshraj_05",
                        "content": "Can you please help me \\nmyOutput == desired Output\\nbut Output that leecode saw != my Output i didi not understand what this is\\n\\n![image](https://i.ibb.co/VDTqLJG/Screenshot-99.png)"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "One of the zero is replaced by 15"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Pass all the testcase and get a TLE... nice :)"
                    },
                    {
                        "username": "TJessop",
                        "content": "This needs more testcases. The hint is also misleading if you weren\\'t expecting binary search based on the other daily problems this week."
                    },
                    {
                        "username": "user7478F",
                        "content": "This is a hard to understand question, I\\'m not able to grasp what is snap function doing?"
                    },
                    {
                        "username": "powerup7",
                        "content": "It\\'s taking a \"snapshot\" or picture of the arr you have in memory. Now be warned, pass by reference or value is important here."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can anyone tell what\\'s wrong with last test case. It gives me tle and the input is blank??"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "New learning: searching in O(1) TC."
                    }
                ]
            },
            {
                "id": 1924437,
                "content": [
                    {
                        "username": "jeetu_23",
                        "content": " ```\nclass SnapshotArray {\npublic:\n        unordered_map<int,unordered_map<int,int>>mp;\n        unordered_map<int,int>cnt;\n        int snaps;\n    SnapshotArray(int length) {\n        mp.clear();\n        cnt.clear();\n        snaps=0;\n    }\n    \n    void set(int index, int val) {\n        cnt[index]=val;\n        return;\n    }\n    \n    int snap() {\n        ++snaps;\n        unordered_map<int,int>&temp=mp[snaps];\n        temp=cnt;\n        return snaps-1;\n    }\n    \n    int get(int index, int snap_id) {\n        unordered_map<int,int>&v=mp[snap_id+1];\n        if(v.find(index)==v.end())return 0;\n        return v[index];\n    }\n};\n```\nWill someone help me why is these giving TLE ,every operation is O(1) then also it gives TLE why???"
                    },
                    {
                        "username": "breathermachine",
                        "content": "`temp=cnt;` is not O(1)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "When I submit my code, I am getting TLE for one testcase, when I use that test case and run the code , no TLE. why is this happening?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@seoli1225](/seoli1225) this is correct. TLE is for cumulative time usage"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "try not using any static  global vairables"
                    },
                    {
                        "username": "seoli1225",
                        "content": "Perheps during the \"submit\" process, the sum of all long testcases exceed the time limit. When you run only one testcase, the time is fine (I guess?)"
                    },
                    {
                        "username": "seoli1225",
                        "content": "If you receive \"Memory Limit Exceeded\", know that the number of snap is almost equal to the number of set and get: the sequence goes like \"set\", \"snap\", \"get\",\"set\", \"snap\", \"get\", instead of a lot of \"set\"s"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Not helpful"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Are this type of questions really asked in interviews!\\nIf yes than how is someone supposed to solve it if the person has not seen the question previously."
                    },
                    {
                        "username": "akshraj_05",
                        "content": "Can you please help me \\nmyOutput == desired Output\\nbut Output that leecode saw != my Output i didi not understand what this is\\n\\n![image](https://i.ibb.co/VDTqLJG/Screenshot-99.png)"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "One of the zero is replaced by 15"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Pass all the testcase and get a TLE... nice :)"
                    },
                    {
                        "username": "TJessop",
                        "content": "This needs more testcases. The hint is also misleading if you weren\\'t expecting binary search based on the other daily problems this week."
                    },
                    {
                        "username": "user7478F",
                        "content": "This is a hard to understand question, I\\'m not able to grasp what is snap function doing?"
                    },
                    {
                        "username": "powerup7",
                        "content": "It\\'s taking a \"snapshot\" or picture of the arr you have in memory. Now be warned, pass by reference or value is important here."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can anyone tell what\\'s wrong with last test case. It gives me tle and the input is blank??"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "New learning: searching in O(1) TC."
                    }
                ]
            },
            {
                "id": 1924431,
                "content": [
                    {
                        "username": "jeetu_23",
                        "content": " ```\nclass SnapshotArray {\npublic:\n        unordered_map<int,unordered_map<int,int>>mp;\n        unordered_map<int,int>cnt;\n        int snaps;\n    SnapshotArray(int length) {\n        mp.clear();\n        cnt.clear();\n        snaps=0;\n    }\n    \n    void set(int index, int val) {\n        cnt[index]=val;\n        return;\n    }\n    \n    int snap() {\n        ++snaps;\n        unordered_map<int,int>&temp=mp[snaps];\n        temp=cnt;\n        return snaps-1;\n    }\n    \n    int get(int index, int snap_id) {\n        unordered_map<int,int>&v=mp[snap_id+1];\n        if(v.find(index)==v.end())return 0;\n        return v[index];\n    }\n};\n```\nWill someone help me why is these giving TLE ,every operation is O(1) then also it gives TLE why???"
                    },
                    {
                        "username": "breathermachine",
                        "content": "`temp=cnt;` is not O(1)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "When I submit my code, I am getting TLE for one testcase, when I use that test case and run the code , no TLE. why is this happening?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@seoli1225](/seoli1225) this is correct. TLE is for cumulative time usage"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "try not using any static  global vairables"
                    },
                    {
                        "username": "seoli1225",
                        "content": "Perheps during the \"submit\" process, the sum of all long testcases exceed the time limit. When you run only one testcase, the time is fine (I guess?)"
                    },
                    {
                        "username": "seoli1225",
                        "content": "If you receive \"Memory Limit Exceeded\", know that the number of snap is almost equal to the number of set and get: the sequence goes like \"set\", \"snap\", \"get\",\"set\", \"snap\", \"get\", instead of a lot of \"set\"s"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Not helpful"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Are this type of questions really asked in interviews!\\nIf yes than how is someone supposed to solve it if the person has not seen the question previously."
                    },
                    {
                        "username": "akshraj_05",
                        "content": "Can you please help me \\nmyOutput == desired Output\\nbut Output that leecode saw != my Output i didi not understand what this is\\n\\n![image](https://i.ibb.co/VDTqLJG/Screenshot-99.png)"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "One of the zero is replaced by 15"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Pass all the testcase and get a TLE... nice :)"
                    },
                    {
                        "username": "TJessop",
                        "content": "This needs more testcases. The hint is also misleading if you weren\\'t expecting binary search based on the other daily problems this week."
                    },
                    {
                        "username": "user7478F",
                        "content": "This is a hard to understand question, I\\'m not able to grasp what is snap function doing?"
                    },
                    {
                        "username": "powerup7",
                        "content": "It\\'s taking a \"snapshot\" or picture of the arr you have in memory. Now be warned, pass by reference or value is important here."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can anyone tell what\\'s wrong with last test case. It gives me tle and the input is blank??"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "New learning: searching in O(1) TC."
                    }
                ]
            }
        ]
    },
    {
        "title": "Slowest Key",
        "question_content": "<p>A newly designed keypad was tested, where a tester pressed a sequence of <code>n</code> keys, one at a time.</p>\n\n<p>You are given a string <code>keysPressed</code> of length <code>n</code>, where <code>keysPressed[i]</code> was the <code>i<sup>th</sup></code> key pressed in the testing sequence, and a sorted list <code>releaseTimes</code>, where <code>releaseTimes[i]</code> was the time the <code>i<sup>th</sup></code> key was released. Both arrays are <strong>0-indexed</strong>. The <code>0<sup>th</sup></code> key was pressed at the time <code>0</code>,&nbsp;and every subsequent key was pressed at the <strong>exact</strong> time the previous key was released.</p>\n\n<p>The tester wants to know the key of the keypress that had the <strong>longest duration</strong>. The <code>i<sup>th</sup></code><sup> </sup>keypress had a <strong>duration</strong> of <code>releaseTimes[i] - releaseTimes[i - 1]</code>, and the <code>0<sup>th</sup></code> keypress had a duration of <code>releaseTimes[0]</code>.</p>\n\n<p>Note that the same key could have been pressed multiple times during the test, and these multiple presses of the same key <strong>may not</strong> have had the same <strong>duration</strong>.</p>\n\n<p><em>Return the key of the keypress that had the <strong>longest duration</strong>. If there are multiple such keypresses, return the lexicographically largest key of the keypresses.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> releaseTimes = [9,29,49,50], keysPressed = &quot;cbcd&quot;\n<strong>Output:</strong> &quot;c&quot;\n<strong>Explanation:</strong> The keypresses were as follows:\nKeypress for &#39;c&#39; had a duration of 9 (pressed at time 0 and released at time 9).\nKeypress for &#39;b&#39; had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29).\nKeypress for &#39;c&#39; had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49).\nKeypress for &#39;d&#39; had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50).\nThe longest of these was the keypress for &#39;b&#39; and the second keypress for &#39;c&#39;, both with duration 20.\n&#39;c&#39; is lexicographically larger than &#39;b&#39;, so the answer is &#39;c&#39;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> releaseTimes = [12,23,36,46,62], keysPressed = &quot;spuda&quot;\n<strong>Output:</strong> &quot;a&quot;\n<strong>Explanation:</strong> The keypresses were as follows:\nKeypress for &#39;s&#39; had a duration of 12.\nKeypress for &#39;p&#39; had a duration of 23 - 12 = 11.\nKeypress for &#39;u&#39; had a duration of 36 - 23 = 13.\nKeypress for &#39;d&#39; had a duration of 46 - 36 = 10.\nKeypress for &#39;a&#39; had a duration of 62 - 46 = 16.\nThe longest of these was the keypress for &#39;a&#39; with duration 16.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>releaseTimes.length == n</code></li>\n\t<li><code>keysPressed.length == n</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= releaseTimes[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>releaseTimes[i] &lt; releaseTimes[i+1]</code></li>\n\t<li><code>keysPressed</code> contains only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 909070,
                "title": "java-solution-o-n-explained",
                "content": "- Initialize the maxDifference and bestChar with the first character.\\n- Start iterating from 2nd character to nth character.\\n- Find the difference between every adjacent character (i and i-1th character)\\n- If the current difference is greater than maxDifference calculated so far. Or the difference is same but the current character is greater than bestChar, update the difference and bestChar.\\n- Return the bestChar.\\n```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int n = releaseTimes.length;\\n        int maxDifference = releaseTimes[0];\\n        char bestChar = keysPressed.charAt(0);\\n        for (int i = 1; i < n; i++) {\\n            int difference = releaseTimes[i] - releaseTimes[i-1];\\n\\n            if (difference > maxDifference || \\n                (difference == maxDifference && keysPressed.charAt(i) > bestChar)) {\\n                maxDifference = difference;\\n                bestChar = keysPressed.charAt(i);\\n            }\\n        }\\n        return bestChar;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int n = releaseTimes.length;\\n        int maxDifference = releaseTimes[0];\\n        char bestChar = keysPressed.charAt(0);\\n        for (int i = 1; i < n; i++) {\\n            int difference = releaseTimes[i] - releaseTimes[i-1];\\n\\n            if (difference > maxDifference || \\n                (difference == maxDifference && keysPressed.charAt(i) > bestChar)) {\\n                maxDifference = difference;\\n                bestChar = keysPressed.charAt(i);\\n            }\\n        }\\n        return bestChar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909825,
                "title": "python-one-pass-solution-without-using-an-extra-space",
                "content": "Time Complexity: O(n)\\nSpace Complexity: O(1)\\n```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        k, t = keysPressed[0], releaseTimes[0]\\n        \\n        for i in range(1, len(keysPressed)):\\n            time = releaseTimes[i] - releaseTimes[i-1] \\n            if time > t or (time == t and keysPressed[i] > k):\\n                t = time\\n                k = keysPressed[i]\\n        \\n        return k\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        k, t = keysPressed[0], releaseTimes[0]\\n        \\n        for i in range(1, len(keysPressed)):\\n            time = releaseTimes[i] - releaseTimes[i-1] \\n            if time > t or (time == t and keysPressed[i] > k):\\n                t = time\\n                k = keysPressed[i]\\n        \\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 985258,
                "title": "1-line-python",
                "content": "```\\ndef slowestKey(self, r, k):\\n    return max(zip(map(sub, r, [0, *r]), k))[1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef slowestKey(self, r, k):\\n    return max(zip(map(sub, r, [0, *r]), k))[1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1447810,
                "title": "python-one-pass-solution-clean-concise",
                "content": "```python\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        ansKey = keysPressed[0]\\n        ansDuration = releaseTimes[0]\\n        for i in range(1, len(keysPressed)):\\n            key = keysPressed[i]\\n            duration = releaseTimes[i] - releaseTimes[i-1]\\n            if duration > ansDuration or duration == ansDuration and key > ansKey:\\n                ansKey = key\\n                ansDuration = duration\\n        return ansKey\\n```\\n**Complexity**\\n- Time: `O(N)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        ansKey = keysPressed[0]\\n        ansDuration = releaseTimes[0]\\n        for i in range(1, len(keysPressed)):\\n            key = keysPressed[i]\\n            duration = releaseTimes[i] - releaseTimes[i-1]\\n            if duration > ansDuration or duration == ansDuration and key > ansKey:\\n                ansKey = key\\n                ansDuration = duration\\n        return ansKey\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447673,
                "title": "python-oneliner-explained",
                "content": "This is a kind of problems, where you probably spend more time reading problem statement, than solving it. What we need to do is just check all keys and how much time we press then and then choose the biggest one. We can do it with oneliner, using functionality of **zip** function.\\n\\n#### Complexity\\nIt is `O(n)` for time and `O(1)` for space, because `zip` is iterator and do not use additional memory.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def slowestKey(self, T, K):\\n        return max((t2 - t1, k) for t1, t2, k in zip(chain([0], T), T, K))[1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def slowestKey(self, T, K):\\n        return max((t2 - t1, k) for t1, t2, k in zip(chain([0], T), T, K))[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447818,
                "title": "c-simple-and-easy-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int time = releaseTimes[0], new_time = 0;\\n        char key = keysPressed[0];\\n        \\n        for (int i = 1; i < releaseTimes.size(); i++) {\\n            new_time = releaseTimes[i] - releaseTimes[i-1];\\n            \\n            if (new_time == time) \\n                key = keysPressed[i] > key ? keysPressed[i] : key;\\n            \\n            else if (new_time > time) {\\n                time = new_time;\\n                key = keysPressed[i];\\n            }\\n        }\\n        return key;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int time = releaseTimes[0], new_time = 0;\\n        char key = keysPressed[0];\\n        \\n        for (int i = 1; i < releaseTimes.size(); i++) {\\n            new_time = releaseTimes[i] - releaseTimes[i-1];\\n            \\n            if (new_time == time) \\n                key = keysPressed[i] > key ? keysPressed[i] : key;\\n            \\n            else if (new_time > time) {\\n                time = new_time;\\n                key = keysPressed[i];\\n            }\\n        }\\n        return key;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910457,
                "title": "c-one-pass",
                "content": "Just track the maximum time and the corresponding character.\\n\\nOne thing to watch here is when maximum times are the same. In that case, we would take the greater character.\\n\\n```cpp\\nchar slowestKey(vector<int>& times, string keys) {\\n    int max_p = times[0], res = keys[0];\\n    for (auto i = 1; i < times.size(); ++i)\\n        if (max_p <= times[i] - times[i - 1]) {\\n            if (max_p == times[i] - times[i - 1])\\n                res = max((char)res, keys[i]);\\n            else\\n                res = keys[i];\\n            max_p = times[i] - times[i - 1];\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nchar slowestKey(vector<int>& times, string keys) {\\n    int max_p = times[0], res = keys[0];\\n    for (auto i = 1; i < times.size(); ++i)\\n        if (max_p <= times[i] - times[i - 1]) {\\n            if (max_p == times[i] - times[i - 1])\\n                res = max((char)res, keys[i]);\\n            else\\n                res = keys[i];\\n            max_p = times[i] - times[i - 1];\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 909123,
                "title": "c-one-pass-linear-time-solution",
                "content": "## Idea \nUse an array to keep track of the **longest duration** on each key. Update this array when iterating over the string `keysPressed`\n\n## Complexity \n- Time `O(n)`\n- Space `O(1)`\n\n## C++ code\n\n```cpp\nclass Solution {\npublic:\n  char slowestKey(vector<int> &releaseTimes, string keysPressed) {\n    int n = releaseTimes.size();\n    int cnt[26] = {0};\n    cnt[keysPressed[0] - 'a'] = releaseTimes[0];\n\n    for (int i = 1; i < n; i++) {\n      cnt[keysPressed[i] - 'a'] = max(cnt[keysPressed[i] - 'a'], releaseTimes[i] - releaseTimes[i - 1]);\n    }\n\n    int idx = 25;\n    for (int i = 25; i >= 0; i--) {\n      if (cnt[i] > cnt[idx]) idx = i;\n    }\n    return idx + 'a';\n  }\n};\n```",
                "solutionTags": [],
                "code": "```cpp\nclass Solution {\npublic:\n  char slowestKey(vector<int> &releaseTimes, string keysPressed) {\n    int n = releaseTimes.size();\n    int cnt[26] = {0};\n    cnt[keysPressed[0] - 'a'] = releaseTimes[0];\n\n    for (int i = 1; i < n; i++) {\n      cnt[keysPressed[i] - 'a'] = max(cnt[keysPressed[i] - 'a'], releaseTimes[i] - releaseTimes[i - 1]);\n    }\n\n    int idx = 25;\n    for (int i = 25; i >= 0; i--) {\n      if (cnt[i] > cnt[idx]) idx = i;\n    }\n    return idx + 'a';\n  }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514113,
                "title": "python-one-pass-solution-clean-simple",
                "content": "**Python :**\\n\\n```\\ndef slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n\\tkey = [keysPressed[0]]\\n\\tmax_dur = releaseTimes[0]\\n\\n\\tfor i in range(1, len(releaseTimes)):\\n\\t\\tif releaseTimes[i] - releaseTimes[i - 1] == max_dur:\\n\\t\\t\\tkey.append(keysPressed[i])\\n\\n\\t\\tif releaseTimes[i] - releaseTimes[i - 1] > max_dur:\\n\\t\\t\\tmax_dur = releaseTimes[i] - releaseTimes[i - 1]\\n\\t\\t\\tkey = [keysPressed[i]]\\n\\n\\n\\treturn max(key)\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n\\tkey = [keysPressed[0]]\\n\\tmax_dur = releaseTimes[0]\\n\\n\\tfor i in range(1, len(releaseTimes)):\\n\\t\\tif releaseTimes[i] - releaseTimes[i - 1] == max_dur:\\n\\t\\t\\tkey.append(keysPressed[i])\\n\\n\\t\\tif releaseTimes[i] - releaseTimes[i - 1] > max_dur:\\n\\t\\t\\tmax_dur = releaseTimes[i] - releaseTimes[i - 1]\\n\\t\\t\\tkey = [keysPressed[i]]\\n\\n\\n\\treturn max(key)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 932384,
                "title": "python-one-pass-no-additional-memory",
                "content": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        max_dur = releaseTimes[0]\\n        max_key = keysPressed[0]\\n        \\n        for i in range(1, len(releaseTimes)):\\n            if releaseTimes[i] - releaseTimes[i-1] > max_dur:\\n                max_dur = releaseTimes[i] - releaseTimes[i-1]\\n                max_key = keysPressed[i]\\n            elif releaseTimes[i] - releaseTimes[i-1] == max_dur and max_key < keysPressed[i]:\\n                 max_key = keysPressed[i]\\n                    \\n        return max_key \\n```\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        max_dur = releaseTimes[0]\\n        max_key = keysPressed[0]\\n        \\n        for i in range(1, len(releaseTimes)):\\n            if releaseTimes[i] - releaseTimes[i-1] > max_dur:\\n                max_dur = releaseTimes[i] - releaseTimes[i-1]\\n                max_key = keysPressed[i]\\n            elif releaseTimes[i] - releaseTimes[i-1] == max_dur and max_key < keysPressed[i]:\\n                 max_key = keysPressed[i]\\n                    \\n        return max_key \\n```",
                "codeTag": "Java"
            },
            {
                "id": 997343,
                "title": "o-n-javascript-solution",
                "content": "```\\nvar slowestKey = function(releaseTimes, keysPressed) {\\nlet maxDuration = releaseTimes[0], char=keysPressed[0];\\nfor (let i = 1; i < releaseTimes.length; i++) {\\n    if (releaseTimes[i]-releaseTimes[i-1]==maxDuration && keysPressed[i]>char) char=keysPressed[i]\\n    else if (releaseTimes[i]-releaseTimes[i-1]>maxDuration) {\\n        char=keysPressed[i];\\n        maxDuration=releaseTimes[i]-releaseTimes[i-1];\\n    }\\n}\\nreturn char;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar slowestKey = function(releaseTimes, keysPressed) {\\nlet maxDuration = releaseTimes[0], char=keysPressed[0];\\nfor (let i = 1; i < releaseTimes.length; i++) {\\n    if (releaseTimes[i]-releaseTimes[i-1]==maxDuration && keysPressed[i]>char) char=keysPressed[i]\\n    else if (releaseTimes[i]-releaseTimes[i-1]>maxDuration) {\\n        char=keysPressed[i];\\n        maxDuration=releaseTimes[i]-releaseTimes[i-1];\\n    }\\n}\\nreturn char;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1448846,
                "title": "slowest-key-o-n-w-approach-c-python3-java",
                "content": "**GIVEN HINTS**\\n* Get for each press its key and amount of time taken.\\n* Iterate on the presses, maintaining the answer so far.\\n* The current press will change the answer if and only if its amount of time taken is longer than that of the previous answer, or they are equal but the key is larger than that of the previous answer.\\n\\n\\n**IDEA**\\n* Initialize the `maxtime` (int) and `ans` (char) with the first character.\\n* Start iterating from `2`nd character to `n`th character.\\n* Find the `difference` between `every adjacent character` (`i` and `i-1`th character)\\n\\t* If the `current difference` is greater than `maxtime` calculated so far. \\n\\t* Or the `difference is same` but the `current character` is *greater* than initialised `ans`, \\n\\t\\t* Update the difference and bestChar.\\n* Return the char `ans`.\\n\\n**SOLUTION**\\n`IN C++`\\n```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int maxTime = releaseTimes[0];\\n        char key = keysPressed[0];\\n        for (int i = 1; i < releaseTimes.size(); i++) {\\n            int duration = releaseTimes[i] - releaseTimes[i - 1];\\n            char curKey = keysPressed[i];\\n            if (duration > maxTime || (duration == maxTime && curKey > key)) {\\n                maxTime = duration;\\n                key = curKey;\\n            }\\n        }        \\n        return key;\\n    }\\n};\\n```\\n`IN Python3`\\n```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        maximum, ans = releaseTimes[0], keysPressed[0]\\n        for i in range(1, len(releaseTimes)):\\n            duration = releaseTimes[i] - releaseTimes[i-1]\\n            curr = keysPressed[i]\\n            if duration > maximum:\\n                maximum, ans = duration, curr\\n            elif duration == maximum and curr > ans:\\n                ans = curr\\n        return ans\\n```\\n`IN JAVA`\\n```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int duration = releaseTimes[0];\\n        char ans = keysPressed.charAt(0);\\n        for(int i=1; i<keysPressed.length(); i++)\\n        {\\n            int currDuration = releaseTimes[i] - releaseTimes[i-1];\\n            if(currDuration > duration)\\n            {\\n                duration = currDuration;\\n                ans = keysPressed.charAt(i);\\n            }\\n            else if(currDuration == duration)\\n            {\\n                ans  = ans < keysPressed.charAt(i) ? keysPressed.charAt(i) : ans;\\n            }\\n        }\\n        return ans ;\\n    }\\n}\\n```\\n\\n**TIME COMPLEXITY - O(N)**\\n**SPACE COMPLEXITY - O(1)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int maxTime = releaseTimes[0];\\n        char key = keysPressed[0];\\n        for (int i = 1; i < releaseTimes.size(); i++) {\\n            int duration = releaseTimes[i] - releaseTimes[i - 1];\\n            char curKey = keysPressed[i];\\n            if (duration > maxTime || (duration == maxTime && curKey > key)) {\\n                maxTime = duration;\\n                key = curKey;\\n            }\\n        }        \\n        return key;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        maximum, ans = releaseTimes[0], keysPressed[0]\\n        for i in range(1, len(releaseTimes)):\\n            duration = releaseTimes[i] - releaseTimes[i-1]\\n            curr = keysPressed[i]\\n            if duration > maximum:\\n                maximum, ans = duration, curr\\n            elif duration == maximum and curr > ans:\\n                ans = curr\\n        return ans\\n```\n```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int duration = releaseTimes[0];\\n        char ans = keysPressed.charAt(0);\\n        for(int i=1; i<keysPressed.length(); i++)\\n        {\\n            int currDuration = releaseTimes[i] - releaseTimes[i-1];\\n            if(currDuration > duration)\\n            {\\n                duration = currDuration;\\n                ans = keysPressed.charAt(i);\\n            }\\n            else if(currDuration == duration)\\n            {\\n                ans  = ans < keysPressed.charAt(i) ? keysPressed.charAt(i) : ans;\\n            }\\n        }\\n        return ans ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172372,
                "title": "python3-simple-and-readable-solution",
                "content": "```\\nclass Solution:\\n    def slowestKey(self, r: List[int], k: str) -> str:\\n        times = {r[0]: [k[0]]}\\n        \\n        for i in range(1 , len(r)):\\n            t = r[i] - r[i - 1]\\n            if(t in times):\\n                times[t].append(k[i])\\n            else:\\n                times[t] = [k[i]]\\n        \\n        keys = times[max(times.keys())]\\n        \\n        return max(keys)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, r: List[int], k: str) -> str:\\n        times = {r[0]: [k[0]]}\\n        \\n        for i in range(1 , len(r)):\\n            t = r[i] - r[i - 1]\\n            if(t in times):\\n                times[t].append(k[i])\\n            else:\\n                times[t] = [k[i]]\\n        \\n        keys = times[max(times.keys())]\\n        \\n        return max(keys)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 908998,
                "title": "java-python-3-1-pass-codes-w-brief-explanation-and-analysis-update-each-key-s-longest-time",
                "content": "Traverse the input array and string, compute the press time for each character and update the longest time.\\n\\n**Two Passes:**\\n```java\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int[] time = new int[26];\\n        for (int i = 0; i < releaseTimes.length; ++i) {\\n            char c = keysPressed.charAt(i);\\n            time[c - \\'a\\'] = Math.max(time[c - \\'a\\'], releaseTimes[i] - (i == 0 ? 0 : releaseTimes[i - 1]));\\n        }\\n        char ans = \\'z\\';\\n        for (char c = \\'y\\'; c >= \\'a\\'; --c) {\\n            if (time[ans - \\'a\\'] < time[c - \\'a\\']) {\\n                ans = c;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n**One Pass:**\\nIn case some prefer 1 pass codes, here are them:\\n```java\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        char slowestKey = \\'A\\';\\n        for (int i = 0, prev = 0, longestDuration = 0; i < releaseTimes.length; ++i) {\\n            int cur = releaseTimes[i], duration = cur - prev;\\n            char c = keysPressed.charAt(i);\\n            if (duration > longestDuration || duration == longestDuration && c > slowestKey) {\\n                longestDuration = duration;\\n                slowestKey = c;\\n            }\\n            prev = cur;\\n        }\\n        return slowestKey;        \\n    }\\n```\\n```python\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        slowest_key, longest_duration, prev = \\'A\\', 0, 0\\n        for i, cur in enumerate(releaseTimes):\\n            duration, key = cur - prev, keysPressed[i]\\n            if duration > longest_duration or duration == longest_duration and key > slowest_key:\\n                longest_duration, slowest_key = duration, key\\n            prev = cur\\n        return slowest_key\\n```\\n\\n**Analysis:**\\n\\nTime: O(n), space: O(1), where n = releaseTimes.length.",
                "solutionTags": [],
                "code": "```java\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int[] time = new int[26];\\n        for (int i = 0; i < releaseTimes.length; ++i) {\\n            char c = keysPressed.charAt(i);\\n            time[c - \\'a\\'] = Math.max(time[c - \\'a\\'], releaseTimes[i] - (i == 0 ? 0 : releaseTimes[i - 1]));\\n        }\\n        char ans = \\'z\\';\\n        for (char c = \\'y\\'; c >= \\'a\\'; --c) {\\n            if (time[ans - \\'a\\'] < time[c - \\'a\\']) {\\n                ans = c;\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```java\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        char slowestKey = \\'A\\';\\n        for (int i = 0, prev = 0, longestDuration = 0; i < releaseTimes.length; ++i) {\\n            int cur = releaseTimes[i], duration = cur - prev;\\n            char c = keysPressed.charAt(i);\\n            if (duration > longestDuration || duration == longestDuration && c > slowestKey) {\\n                longestDuration = duration;\\n                slowestKey = c;\\n            }\\n            prev = cur;\\n        }\\n        return slowestKey;        \\n    }\\n```\n```python\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        slowest_key, longest_duration, prev = \\'A\\', 0, 0\\n        for i, cur in enumerate(releaseTimes):\\n            duration, key = cur - prev, keysPressed[i]\\n            if duration > longest_duration or duration == longest_duration and key > slowest_key:\\n                longest_duration, slowest_key = duration, key\\n            prev = cur\\n        return slowest_key\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1448731,
                "title": "c-3-line-solution-o-n-time-o-1-space",
                "content": "`std::pair` has built-in operators for comparison.\\n```\\nclass Solution {\\npublic:\\n    char slowestKey(const vector<int>& releaseTimes, const string& keysPressed) {\\n        pair<int, char> key = {releaseTimes[0], keysPressed[0]};\\n        for(int i = 1; i < keysPressed.size(); ++i) key = max(key, {releaseTimes[i] - releaseTimes[i - 1], keysPressed[i]});\\n        return key.second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(const vector<int>& releaseTimes, const string& keysPressed) {\\n        pair<int, char> key = {releaseTimes[0], keysPressed[0]};\\n        for(int i = 1; i < keysPressed.size(); ++i) key = max(key, {releaseTimes[i] - releaseTimes[i - 1], keysPressed[i]});\\n        return key.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447800,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& a, string s) {\\n        int n = a.size();\\n        char ans = s[0];\\n        int maxi = a[0];\\n        for(int i = 1;i < n; i++){\\n            int curr = a[i]-a[i-1];\\n            if(curr > maxi){\\n                maxi = curr;\\n                ans = s[i];\\n            }else if(curr == maxi && ans < s[i]){\\n\\t\\t\\t\\tans=s[i];\\n\\t\\t\\t}\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTime Complexity : O(N)\\nSpace Complexity : O(1)\\n\\nQuestions/ Discussions are welcome.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& a, string s) {\\n        int n = a.size();\\n        char ans = s[0];\\n        int maxi = a[0];\\n        for(int i = 1;i < n; i++){\\n            int curr = a[i]-a[i-1];\\n            if(curr > maxi){\\n                maxi = curr;\\n                ans = s[i];\\n            }else if(curr == maxi && ans < s[i]){\\n\\t\\t\\t\\tans=s[i];\\n\\t\\t\\t}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 912177,
                "title": "java-easiest-solution-o-n-1ms-runtime",
                "content": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n         char item = keysPressed.charAt(0) ;\\n        int value = releaseTimes[0]; // 12\\n        for(int i = 1;i<releaseTimes.length;i++){//12,23,36,46,62    s p u d a\\n            if(releaseTimes[i] - releaseTimes[i-1] > value){ //62 - 46 = 16\\n                value = releaseTimes[i] - releaseTimes[i-1];//16\\n                item = keysPressed.charAt(i);//a\\n            }\\n            else if(releaseTimes[i] - releaseTimes[i-1] == value){\\n                if(keysPressed.charAt(i) > keysPressed.charAt(i-1))\\n                    item = keysPressed.charAt(i);\\n                else\\n                    item = keysPressed.charAt(i-1);\\n            }\\n            else\\n                continue;\\n        }\\n        return item;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n         char item = keysPressed.charAt(0) ;\\n        int value = releaseTimes[0]; // 12\\n        for(int i = 1;i<releaseTimes.length;i++){//12,23,36,46,62    s p u d a\\n            if(releaseTimes[i] - releaseTimes[i-1] > value){ //62 - 46 = 16\\n                value = releaseTimes[i] - releaseTimes[i-1];//16\\n                item = keysPressed.charAt(i);//a\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 910193,
                "title": "python-one-pass-solution",
                "content": "- **Using Sort**\\n\\n```python\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        res, prev = (0, []), 0\\n        \\n        for time, letter in zip(releaseTimes, keysPressed):\\n            if time - prev > res[0]:\\n                res = (time - prev, [letter])\\n            elif time - prev == res[0]:\\n                res[1].append(letter)\\n            prev = time\\n        \\n        return sorted(res[1])[-1]\\n```\\n\\n\\n- **Using Heap**\\n\\n```python\\nfrom heapq import heappush\\n\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        res, prev = (0, []), 0\\n        \\n        for time, letter in zip(releaseTimes, keysPressed):\\n            if time - prev > res[0]:\\n                res = (time - prev, [-ord(letter)])\\n            elif time - prev == res[0]:\\n                heappush(res[1], -ord(letter))\\n            prev = time\\n        \\n        return chr(-res[1][0])\\n```\\n\\n- **Using Max**\\n\\n```python\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        res, prev = (0, \\'\\'), 0\\n        \\n        for time, letter in zip(releaseTimes, keysPressed):\\n            if time - prev >= res[0]:\\n                res = max(res, (time - prev, letter))\\n            prev = time\\n        \\n        return res[1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        res, prev = (0, []), 0\\n        \\n        for time, letter in zip(releaseTimes, keysPressed):\\n            if time - prev > res[0]:\\n                res = (time - prev, [letter])\\n            elif time - prev == res[0]:\\n                res[1].append(letter)\\n            prev = time\\n        \\n        return sorted(res[1])[-1]\\n```\n```python\\nfrom heapq import heappush\\n\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        res, prev = (0, []), 0\\n        \\n        for time, letter in zip(releaseTimes, keysPressed):\\n            if time - prev > res[0]:\\n                res = (time - prev, [-ord(letter)])\\n            elif time - prev == res[0]:\\n                heappush(res[1], -ord(letter))\\n            prev = time\\n        \\n        return chr(-res[1][0])\\n```\n```python\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        res, prev = (0, \\'\\'), 0\\n        \\n        for time, letter in zip(releaseTimes, keysPressed):\\n            if time - prev >= res[0]:\\n                res = max(res, (time - prev, letter))\\n            prev = time\\n        \\n        return res[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146618,
                "title": "c-map-and-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,char> &a, pair<int,char>&b ) {\\n        return (a.first==b.first) ? a.second> b.second : a.first > b.first;\\n    }\\n    \\n    \\n    char slowestKey(vector<int>& releaseTimes, string keys) {\\n        unordered_multimap<int,char> mp;\\n        mp.insert({releaseTimes[0],keys[0]});\\n        for(int i=1;i<releaseTimes.size();i++) {\\n            mp.insert({releaseTimes[i]-releaseTimes[i-1] , keys[i]});\\n        }\\n        vector<pair<int,char>> p(mp.begin(),mp.end());\\n        sort(p.begin(),p.end(),cmp);\\n        return p[0].second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,char> &a, pair<int,char>&b ) {\\n        return (a.first==b.first) ? a.second> b.second : a.first > b.first;\\n    }\\n    \\n    \\n    char slowestKey(vector<int>& releaseTimes, string keys) {\\n        unordered_multimap<int,char> mp;\\n        mp.insert({releaseTimes[0],keys[0]});\\n        for(int i=1;i<releaseTimes.size();i++) {\\n            mp.insert({releaseTimes[i]-releaseTimes[i-1] , keys[i]});\\n        }\\n        vector<pair<int,char>> p(mp.begin(),mp.end());\\n        sort(p.begin(),p.end(),cmp);\\n        return p[0].second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064146,
                "title": "simple-java-solution-100-faster",
                "content": "\\n\\n```\\npublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int slowestKeyTime = releaseTimes[0];\\n        char slowestKeychar = keysPressed.charAt(0);\\n        int diff=0;\\n\\t\\tfor (int i = 1; i < releaseTimes.length; i++) {\\t\\n\\t\\t\\tdiff = releaseTimes[i] - releaseTimes[i-1];\\n\\t\\t\\tif ((slowestKeyTime < diff) || \\n\\t\\t\\t\\t\\t(slowestKeyTime == diff && slowestKeychar < keysPressed.charAt(i))) {\\n\\t\\t\\t\\tslowestKeychar = keysPressed.charAt(i);\\n\\t\\t\\t\\tslowestKeyTime =  diff;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn slowestKeychar;   \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int slowestKeyTime = releaseTimes[0];\\n        char slowestKeychar = keysPressed.charAt(0);\\n        int diff=0;\\n\\t\\tfor (int i = 1; i < releaseTimes.length; i++) {\\t\\n\\t\\t\\tdiff = releaseTimes[i] - releaseTimes[i-1];\\n\\t\\t\\tif ((slowestKeyTime < diff) || \\n\\t\\t\\t\\t\\t(slowestKeyTime == diff && slowestKeychar < keysPressed.charAt(i))) {\\n\\t\\t\\t\\tslowestKeychar = keysPressed.charAt(i);\\n\\t\\t\\t\\tslowestKeyTime =  diff;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn slowestKeychar;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1034496,
                "title": "java-100-faster-no-extra-space-o-n-easy-to-understand-with-explanation",
                "content": "Clean Code\\n```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int max = releaseTimes[0];\\n        char ch = keysPressed.charAt(0);\\n        for(int i=1;i<releaseTimes.length;i++){\\n            int diff = releaseTimes[i]-releaseTimes[i-1];\\n            if( diff >= max){\\n                if(diff>max)\\n                    ch = keysPressed.charAt(i);\\n                else if(diff== max)\\n                    ch = (char)Math.max((int) ch, (int) keysPressed.charAt(i));\\n                max = diff;\\n            }   \\n        }\\n        return ch;      \\n    }    \\n}\\n```\\n\\nCode with explanation\\n```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int max = releaseTimes[0]; // to store the max duration any key is pressed\\n        char ch = keysPressed.charAt(0); // to store the key that is pressed for the longest time \\n\\t\\t//i.e key corresponding to the max time\\n        for(int i=1;i<releaseTimes.length;i++){ //looping through 1 because we have already assmed that\\n\\t\\t//0 is the longest key while initializing ch and max variable\\n            int diff = releaseTimes[i]-releaseTimes[i-1]; // to store the duration of key at i index\\n            if( diff >= max){ // checking if the key is pressed longer than the last max duration already stored\\n                if(diff>max) // if the key is pressed longer than the last max\\n                    ch = keysPressed.charAt(i); // ch would become that character\\n                else if(diff== max) // if key is equally pressed than max was\\n                    ch = (char)Math.max((int) ch, (int) keysPressed.charAt(i)); // stroing ch as the laxicographically largest character\\n                max = diff; // in equal and greater, both cases the max will set to the diff\\n            }   \\n        }\\n        return ch;      // returning the longest pressed key\\n    }    \\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int max = releaseTimes[0];\\n        char ch = keysPressed.charAt(0);\\n        for(int i=1;i<releaseTimes.length;i++){\\n            int diff = releaseTimes[i]-releaseTimes[i-1];\\n            if( diff >= max){\\n                if(diff>max)\\n                    ch = keysPressed.charAt(i);\\n                else if(diff== max)\\n                    ch = (char)Math.max((int) ch, (int) keysPressed.charAt(i));\\n                max = diff;\\n            }   \\n        }\\n        return ch;      \\n    }    \\n}\\n```\n```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int max = releaseTimes[0]; // to store the max duration any key is pressed\\n        char ch = keysPressed.charAt(0); // to store the key that is pressed for the longest time \\n\\t\\t//i.e key corresponding to the max time\\n        for(int i=1;i<releaseTimes.length;i++){ //looping through 1 because we have already assmed that\\n\\t\\t//0 is the longest key while initializing ch and max variable\\n            int diff = releaseTimes[i]-releaseTimes[i-1]; // to store the duration of key at i index\\n            if( diff >= max){ // checking if the key is pressed longer than the last max duration already stored\\n                if(diff>max) // if the key is pressed longer than the last max\\n                    ch = keysPressed.charAt(i); // ch would become that character\\n                else if(diff== max) // if key is equally pressed than max was\\n                    ch = (char)Math.max((int) ch, (int) keysPressed.charAt(i)); // stroing ch as the laxicographically largest character\\n                max = diff; // in equal and greater, both cases the max will set to the diff\\n            }   \\n        }\\n        return ch;      // returning the longest pressed key\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909013,
                "title": "python-fast-easy",
                "content": "```\\nclass Solution(object):\\n    def slowestKey(self, releaseTimes, keyPressed):\\n        maxDiff = -1\\n        \\n        maxDuration = releaseTimes[0]\\n        ans = keyPressed[0]\\n        \\n        for i in range(1, len(releaseTimes)):\\n            diff = releaseTimes[i] - releaseTimes[i-1]\\n            \\n            if diff >= maxDuration:\\n                if diff > maxDuration:\\n                    ans = keyPressed[i]\\n                    maxDuration = diff\\n                else:\\n                    if keyPressed[i] > ans:\\n                        ans = keyPressed[i]\\n                    maxDuration = diff\\n                        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def slowestKey(self, releaseTimes, keyPressed):\\n        maxDiff = -1\\n        \\n        maxDuration = releaseTimes[0]\\n        ans = keyPressed[0]\\n        \\n        for i in range(1, len(releaseTimes)):\\n            diff = releaseTimes[i] - releaseTimes[i-1]\\n            \\n            if diff >= maxDuration:\\n                if diff > maxDuration:\\n                    ans = keyPressed[i]\\n                    maxDuration = diff\\n                else:\\n                    if keyPressed[i] > ans:\\n                        ans = keyPressed[i]\\n                    maxDuration = diff\\n                        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152688,
                "title": "python-99-fast-o-nlogn-o-n-vs-60-fast-o-n-o-1",
                "content": "1. 99% faster\\n**Time**: O(n *  log(n)) since we sort our list\\n**Memory**: O(n) since it grows linerarly\\n```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        \\n        dics = collections.defaultdict(list)\\n        max_length = releaseTimes[0]\\n        \\n        dics[max_length].append(keysPressed[0])\\n        \\n        for i in range(1, len(releaseTimes)):\\n            length = releaseTimes[i] - releaseTimes[i - 1]\\n            \\n            if length >= max_length:\\n                dics[length].append(keysPressed[i])\\n                max_length = length\\n                \\n        \\n        dics[max_length].sort()\\n        \\n        return dics[max_length][len(dics[max_length]) - 1]\\n```\\n\\n2. 60% faster\\n**Time**: O(n)\\n**Memory**: O(1)\\n```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        \\n        max_length = releaseTimes[0]\\n        max_value = keysPressed[0]\\n        \\n        for i in range(1, len(releaseTimes)):\\n            length = releaseTimes[i] - releaseTimes[i - 1]\\n            \\n            if length > max_length:\\n                max_length = length\\n                max_value = keysPressed[i]\\n            elif length == max_length:\\n                max_value = max(max_value, keysPressed[i])\\n                \\n        \\n        return max_value\\n        \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        \\n        dics = collections.defaultdict(list)\\n        max_length = releaseTimes[0]\\n        \\n        dics[max_length].append(keysPressed[0])\\n        \\n        for i in range(1, len(releaseTimes)):\\n            length = releaseTimes[i] - releaseTimes[i - 1]\\n            \\n            if length >= max_length:\\n                dics[length].append(keysPressed[i])\\n                max_length = length\\n                \\n        \\n        dics[max_length].sort()\\n        \\n        return dics[max_length][len(dics[max_length]) - 1]\\n```\n```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        \\n        max_length = releaseTimes[0]\\n        max_value = keysPressed[0]\\n        \\n        for i in range(1, len(releaseTimes)):\\n            length = releaseTimes[i] - releaseTimes[i - 1]\\n            \\n            if length > max_length:\\n                max_length = length\\n                max_value = keysPressed[i]\\n            elif length == max_length:\\n                max_value = max(max_value, keysPressed[i])\\n                \\n        \\n        return max_value\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 932229,
                "title": "fast-intuitive-python",
                "content": "```\\ndef slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        key = keysPressed[0]\\n        maxTime = releaseTimes[0]\\n\\n        for i in range(1, len(releaseTimes)):\\n            diff = releaseTimes[i] - releaseTimes[i-1]\\n            if diff > maxTime:\\n                maxTime = diff\\n                key = keysPressed[i]\\n            elif diff == maxTime:\\n                maxtime = diff\\n                key = max(key, keysPressed[i])\\n        return key\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        key = keysPressed[0]\\n        maxTime = releaseTimes[0]\\n\\n        for i in range(1, len(releaseTimes)):\\n            diff = releaseTimes[i] - releaseTimes[i-1]\\n            if diff > maxTime:\\n                maxTime = diff\\n                key = keysPressed[i]\\n            elif diff == maxTime:\\n                maxtime = diff\\n                key = max(key, keysPressed[i])\\n        return key\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 923883,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int start = 0;\\n        int maxval = 0;\\n        char res;\\n        for(int i=0; i<releaseTimes.size(); ++i){\\n            if(releaseTimes[i]-start>maxval){\\n                maxval = releaseTimes[i]-start;\\n                res = keysPressed[i];\\n            }\\n            else if(releaseTimes[i]-start==maxval){\\n                char temp = keysPressed[i];\\n                res = max(res, temp);\\n            }\\n            start = releaseTimes[i];\\n        }\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int start = 0;\\n        int maxval = 0;\\n        char res;\\n        for(int i=0; i<releaseTimes.size(); ++i){\\n            if(releaseTimes[i]-start>maxval){\\n                maxval = releaseTimes[i]-start;\\n                res = keysPressed[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 909278,
                "title": "java-0ms-100-ac-solution-o-n-cracked",
                "content": "***Note.: We are not checking the cases where releaseTimes length is zero since it is mentioned in problem it will be greater than 0.***\\n\\nSteps:\\n- Initialize the slowestKeyCount and slowestKey with the first character.\\n- Start iterating from 1st index of releaseTimes till length-1\\n- Find the difference between every adjacent character (i and i-1th character)\\n- If the current diff is greater than slowestKeyCount calculated so far then slowestKeyCount will be equal to new diff and slowestKey will be keysPressed char at that index.\\n- Also if current diff is equal to slowestKeyCount so far then check if it is lexicographically greater than update the slowestKey with the keysPressed char at that index.\\n\\n```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        \\n        int slowestKeyCount = releaseTimes[0];\\n        char slowestKey = keysPressed.charAt(0);\\n        \\n        for(int i=1; i<releaseTimes.length; i++) {\\n            \\n            int diff = releaseTimes[i] - releaseTimes[i-1];\\n            if(diff > slowestKeyCount) {\\n                slowestKeyCount = diff;\\n                slowestKey = keysPressed.charAt(i);\\n            }\\n            else if(diff == slowestKeyCount) {\\n                slowestKey = keysPressed.charAt(i) > slowestKey ? keysPressed.charAt(i) : slowestKey;\\n            }\\n        }\\n        \\n        return slowestKey;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        \\n        int slowestKeyCount = releaseTimes[0];\\n        char slowestKey = keysPressed.charAt(0);\\n        \\n        for(int i=1; i<releaseTimes.length; i++) {\\n            \\n            int diff = releaseTimes[i] - releaseTimes[i-1];\\n            if(diff > slowestKeyCount) {\\n                slowestKeyCount = diff;\\n                slowestKey = keysPressed.charAt(i);\\n            }\\n            else if(diff == slowestKeyCount) {\\n                slowestKey = keysPressed.charAt(i) > slowestKey ? keysPressed.charAt(i) : slowestKey;\\n            }\\n        }\\n        \\n        return slowestKey;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909106,
                "title": "java-easy-to-understand-o-n-solution",
                "content": "\\nWe can process each key to find the maximum time. Once we know the maximam time, we can search which key reach that maximum time and return it as the answer.\\n```\\n    public char slowestKey(int[] r, String k) {\\n        int[] time = new int[26];\\n        int max = 0;\\n        for (int i=0; i<k.length(); i++) {\\n            int temp = 0;\\n            if (i == 0) {\\n                temp = r[0];\\n            } else {\\n                temp = r[i] - r[i - 1];\\n            }\\n            time[k.charAt(i) - \\'a\\'] = time[k.charAt(i) - \\'a\\'] > temp ? time[k.charAt(i) - \\'a\\'] : temp ;\\n            max = Math.max(max, temp);\\n        }\\n        int res = 0;\\n        for (int i=25; i>=0; i--) {\\n            if (time[i] == max) {\\n                res = i;\\n                break;\\n            }\\n        }\\n        return (char)(res + \\'a\\');\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public char slowestKey(int[] r, String k) {\\n        int[] time = new int[26];\\n        int max = 0;\\n        for (int i=0; i<k.length(); i++) {\\n            int temp = 0;\\n            if (i == 0) {\\n                temp = r[0];\\n            } else {\\n                temp = r[i] - r[i - 1];\\n            }\\n            time[k.charAt(i) - \\'a\\'] = time[k.charAt(i) - \\'a\\'] > temp ? time[k.charAt(i) - \\'a\\'] : temp ;\\n            max = Math.max(max, temp);\\n        }\\n        int res = 0;\\n        for (int i=25; i>=0; i--) {\\n            if (time[i] == max) {\\n                res = i;\\n                break;\\n            }\\n        }\\n        return (char)(res + \\'a\\');\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 909047,
                "title": "c-o-n-save-max-time-key-press-for-each-char",
                "content": "```csharp\\npublic char SlowestKey(int[] releaseTimes, string keysPressed) \\n{\\n\\tint last = 0;\\n\\tint[] times = new int[26];\\n\\n\\tfor(int i = 0; i < releaseTimes.Length; i++)\\n\\t{\\n\\t\\tint duration = releaseTimes[i] - last;\\n\\t\\ttimes[keysPressed[i] - \\'a\\'] = Math.Max(times[keysPressed[i] - \\'a\\'], duration);            \\n\\t\\tlast = releaseTimes[i];\\n\\t}\\n\\n\\tint max = 0;\\n\\tchar result = \\'a\\';\\n\\tfor(int i = 0; i < 26; i++)\\n\\t{\\n\\t\\tif(times[i] >= max)\\n\\t\\t{\\n\\t\\t\\tmax = times[i];\\n\\t\\t\\tresult = (char)(i + \\'a\\');\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic char SlowestKey(int[] releaseTimes, string keysPressed) \\n{\\n\\tint last = 0;\\n\\tint[] times = new int[26];\\n\\n\\tfor(int i = 0; i < releaseTimes.Length; i++)\\n\\t{\\n\\t\\tint duration = releaseTimes[i] - last;\\n\\t\\ttimes[keysPressed[i] - \\'a\\'] = Math.Max(times[keysPressed[i] - \\'a\\'], duration);            \\n\\t\\tlast = releaseTimes[i];\\n\\t}\\n\\n\\tint max = 0;\\n\\tchar result = \\'a\\';\\n\\tfor(int i = 0; i < 26; i++)\\n\\t{\\n\\t\\tif(times[i] >= max)\\n\\t\\t{\\n\\t\\t\\tmax = times[i];\\n\\t\\t\\tresult = (char)(i + \\'a\\');\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2675041,
                "title": "java-o-n-69-faster-beginner-friendly",
                "content": "```\\nchar ans=keysPressed.charAt(0);\\n        int max=releaseTimes[0];\\n        \\n        for(int i=1;i<keysPressed.length();i++){\\n            int temp = Math.abs(releaseTimes[i]-releaseTimes[i-1]);\\n            \\n            if(temp>max){\\n                max = temp;\\n                ans = keysPressed.charAt(i);\\n            }else if(temp==max){\\n                if(ans<keysPressed.charAt(i)){\\n                    ans = keysPressed.charAt(i);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nchar ans=keysPressed.charAt(0);\\n        int max=releaseTimes[0];\\n        \\n        for(int i=1;i<keysPressed.length();i++){\\n            int temp = Math.abs(releaseTimes[i]-releaseTimes[i-1]);\\n            \\n            if(temp>max){\\n                max = temp;\\n                ans = keysPressed.charAt(i);\\n            }else if(temp==max){\\n                if(ans<keysPressed.charAt(i)){\\n                    ans = keysPressed.charAt(i);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2176879,
                "title": "javascript-simple-and-fast-solution",
                "content": "```\\nvar slowestKey = function (releaseTimes, keysPressed) {\\n    let max = 0, key;\\n    for (let i = 0; i < releaseTimes.length; i++) {\\n        const diff = releaseTimes[i] - (releaseTimes[i - 1] || 0);\\n        if (diff > max || (diff === max && keysPressed[i] > key)) {\\n            max = diff;\\n            key = keysPressed[i];\\n        }\\n    }\\n    return key;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar slowestKey = function (releaseTimes, keysPressed) {\\n    let max = 0, key;\\n    for (let i = 0; i < releaseTimes.length; i++) {\\n        const diff = releaseTimes[i] - (releaseTimes[i - 1] || 0);\\n        if (diff > max || (diff === max && keysPressed[i] > key)) {\\n            max = diff;\\n            key = keysPressed[i];\\n        }\\n    }\\n    return key;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1828754,
                "title": "python-easy-solution-o-n",
                "content": "```\\n    def slowestKey(self, rt: List[int], kp: str) -> str:\\n        \\n        \\n        l = []\\n        l.append([rt[0] , kp[0]])\\n        for i in range(1 ,len(rt)):\\n            \\n            l.append([rt[i] - rt[i-1] , kp[i]])\\n        \\n        \\n        maxs = max(l)\\n        \\n        \\n        return maxs[1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def slowestKey(self, rt: List[int], kp: str) -> str:\\n        \\n        \\n        l = []\\n        l.append([rt[0] , kp[0]])\\n        for i in range(1 ,len(rt)):\\n            \\n            l.append([rt[i] - rt[i-1] , kp[i]])\\n        \\n        \\n        maxs = max(l)\\n        \\n        \\n        return maxs[1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1449641,
                "title": "c-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    char slowestKey(vector<int> &releaseTimes, string keysPressed)\\n    {\\n        int maxTime = releaseTimes[0], n = releaseTimes.size(), currTime;\\n        char ans = keysPressed[0];\\n        for (int i = 1; i < n; ++i)\\n        {\\n            currTime = releaseTimes[i] - releaseTimes[i - 1];\\n            if (currTime > maxTime)\\n            {\\n                maxTime = currTime;\\n                ans = keysPressed[i];\\n            }\\n            else if (currTime == maxTime)\\n            {\\n                ans = std::max(ans, keysPressed[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    char slowestKey(vector<int> &releaseTimes, string keysPressed)\\n    {\\n        int maxTime = releaseTimes[0], n = releaseTimes.size(), currTime;\\n        char ans = keysPressed[0];\\n        for (int i = 1; i < n; ++i)\\n        {\\n            currTime = releaseTimes[i] - releaseTimes[i - 1];\\n            if (currTime > maxTime)\\n            {\\n                maxTime = currTime;\\n                ans = keysPressed[i];\\n            }\\n            else if (currTime == maxTime)\\n            {\\n                ans = std::max(ans, keysPressed[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447811,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn slowest_key(release_times: Vec<i32>, keys_pressed: String) -> char {\\n        std::iter::once(release_times[0])\\n            .chain(release_times.windows(2).map(|x| x[1] - x[0]))\\n            .zip(keys_pressed.chars())\\n            .max()\\n            .unwrap()\\n            .1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn slowest_key(release_times: Vec<i32>, keys_pressed: String) -> char {\\n        std::iter::once(release_times[0])\\n            .chain(release_times.windows(2).map(|x| x[1] - x[0]))\\n            .zip(keys_pressed.chars())\\n            .max()\\n            .unwrap()\\n            .1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1347833,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public char slowestKey(int[] r, String k) {\\n        int s=r[0],i;\\n        char c=k.charAt(0);\\n        for(i=1;i<r.length;i++)\\n        {\\n            if(r[i]-r[i-1]>s)\\n            {\\n                s=r[i]-r[i-1];\\n                c=k.charAt(i);\\n            }\\n            else if(r[i]-r[i-1]==s)\\n            {\\n                if(c<k.charAt(i))\\n                    c=k.charAt(i);\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public char slowestKey(int[] r, String k) {\\n        int s=r[0],i;\\n        char c=k.charAt(0);\\n        for(i=1;i<r.length;i++)\\n        {\\n            if(r[i]-r[i-1]>s)\\n            {\\n                s=r[i]-r[i-1];\\n                c=k.charAt(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1346547,
                "title": "java-0ms-100-fast-and-easy-to-understand-solution",
                "content": "```\\npublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int maxTime = -1;\\n        int lastReleaseTime = 0;\\n        char slowestKey = keysPressed.charAt(0);\\n        for (int i = 0; i < releaseTimes.length; i++) {\\n            int duration = releaseTimes[i] - lastReleaseTime;\\n            if (duration > maxTime) {\\n                slowestKey = keysPressed.charAt(i);\\n                maxTime = duration;\\n            } else if (duration == maxTime) {\\n                slowestKey = keysPressed.charAt(i) - slowestKey > 0 \\n                    ? keysPressed.charAt(i) : slowestKey;\\n            }\\n            lastReleaseTime = releaseTimes[i];\\n        }\\n        return slowestKey;\\n    }\\n```\\nPlease do upvote if you liked the solution or comment incase any doubt :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int maxTime = -1;\\n        int lastReleaseTime = 0;\\n        char slowestKey = keysPressed.charAt(0);\\n        for (int i = 0; i < releaseTimes.length; i++) {\\n            int duration = releaseTimes[i] - lastReleaseTime;\\n            if (duration > maxTime) {\\n                slowestKey = keysPressed.charAt(i);\\n                maxTime = duration;\\n            } else if (duration == maxTime) {\\n                slowestKey = keysPressed.charAt(i) - slowestKey > 0 \\n                    ? keysPressed.charAt(i) : slowestKey;\\n            }\\n            lastReleaseTime = releaseTimes[i];\\n        }\\n        return slowestKey;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1279934,
                "title": "java-0-ms-100-faster-easy-simple-concise",
                "content": "\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int maxTime = releaseTimes[0], difference;\\n        char[] keysPressedchars = keysPressed.toCharArray();\\n        char tempSlowestKey = keysPressedchars[0];\\n\\n        for (int i = 1; i < releaseTimes.length; i++) {\\n            difference = releaseTimes[i] - releaseTimes[i - 1];\\n\\n            if (difference > maxTime) {\\n                maxTime = difference;\\n                tempSlowestKey = keysPressedchars[i];\\n            } else if (difference == maxTime) {\\n                if (keysPressedchars[i] > tempSlowestKey) {\\n                    tempSlowestKey = keysPressedchars[i];\\n                }\\n            }\\n        }\\n\\n        return tempSlowestKey;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int maxTime = releaseTimes[0], difference;\\n        char[] keysPressedchars = keysPressed.toCharArray();\\n        char tempSlowestKey = keysPressedchars[0];\\n\\n        for (int i = 1; i < releaseTimes.length; i++) {\\n            difference = releaseTimes[i] - releaseTimes[i - 1];\\n\\n            if (difference > maxTime) {\\n                maxTime = difference;\\n                tempSlowestKey = keysPressedchars[i];\\n            } else if (difference == maxTime) {\\n                if (keysPressedchars[i] > tempSlowestKey) {\\n                    tempSlowestKey = keysPressedchars[i];\\n                }\\n            }\\n        }\\n\\n        return tempSlowestKey;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1236566,
                "title": "golang-solution",
                "content": "The idea of this solution is pretty simple, so I will let the code explain:\\n\\n**The Code:**\\n\\n```\\nfunc slowestKey(releaseTimes []int, keysPressed string) byte {\\n\\tmax := releaseTimes[0]\\n\\tletter := keysPressed[0]\\n\\n\\tfor i := 1; i < len(releaseTimes); i++ {\\n\\t\\tdifference := releaseTimes[i] - releaseTimes[i-1]\\n\\t\\tif difference > max {\\n\\t\\t\\tmax = difference\\n\\t\\t\\tletter = keysPressed[i]\\n\\t\\t} else if difference == max && keysPressed[i] > letter {\\n\\t\\t\\tmax = difference\\n\\t\\t\\tletter = keysPressed[i]\\n\\t\\t}\\n\\t}\\n\\n\\treturn letter\\n}\\n```\\n\\n**And the Same Thing Except Using A Struct:**\\n\\n```\\ntype slowest struct {\\n\\tmaximum int\\n\\tletter  byte\\n}\\n\\nfunc slowestKey(releaseTimes []int, keysPressed string) byte {\\n\\tmaxAndLetter := slowest{maximum: releaseTimes[0], letter: keysPressed[0]}\\n\\n\\tfor i := 1; i < len(releaseTimes); i++ {\\n\\t\\tdifference := releaseTimes[i] - releaseTimes[i-1]\\n\\t\\tif difference > maxAndLetter.maximum {\\n\\t\\t\\tmaxAndLetter.maximum = difference\\n\\t\\t\\tmaxAndLetter.letter = keysPressed[i]\\n\\t\\t} else if difference == maxAndLetter.maximum && keysPressed[i] > maxAndLetter.letter {\\n\\t\\t\\tmaxAndLetter.maximum = difference\\n\\t\\t\\tmaxAndLetter.letter = keysPressed[i]\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxAndLetter.letter\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc slowestKey(releaseTimes []int, keysPressed string) byte {\\n\\tmax := releaseTimes[0]\\n\\tletter := keysPressed[0]\\n\\n\\tfor i := 1; i < len(releaseTimes); i++ {\\n\\t\\tdifference := releaseTimes[i] - releaseTimes[i-1]\\n\\t\\tif difference > max {\\n\\t\\t\\tmax = difference\\n\\t\\t\\tletter = keysPressed[i]\\n\\t\\t} else if difference == max && keysPressed[i] > letter {\\n\\t\\t\\tmax = difference\\n\\t\\t\\tletter = keysPressed[i]\\n\\t\\t}\\n\\t}\\n\\n\\treturn letter\\n}\\n```\n```\\ntype slowest struct {\\n\\tmaximum int\\n\\tletter  byte\\n}\\n\\nfunc slowestKey(releaseTimes []int, keysPressed string) byte {\\n\\tmaxAndLetter := slowest{maximum: releaseTimes[0], letter: keysPressed[0]}\\n\\n\\tfor i := 1; i < len(releaseTimes); i++ {\\n\\t\\tdifference := releaseTimes[i] - releaseTimes[i-1]\\n\\t\\tif difference > maxAndLetter.maximum {\\n\\t\\t\\tmaxAndLetter.maximum = difference\\n\\t\\t\\tmaxAndLetter.letter = keysPressed[i]\\n\\t\\t} else if difference == maxAndLetter.maximum && keysPressed[i] > maxAndLetter.letter {\\n\\t\\t\\tmaxAndLetter.maximum = difference\\n\\t\\t\\tmaxAndLetter.letter = keysPressed[i]\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxAndLetter.letter\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1182742,
                "title": "rust-zip-fold-solution",
                "content": "```\\nimpl Solution {\\n    pub fn slowest_key(release_times: Vec<i32>, keys_pressed: String) -> char {\\n        let (mut max_time, mut max_key) = (0, \\' \\');\\n        release_times\\n            .iter()\\n            .zip(keys_pressed.chars())\\n            .fold(0, |t_prev, (&t_cur, c)| {\\n                let delay = t_cur - t_prev;\\n                if delay > max_time || delay == max_time && c > max_key {\\n                    max_key = c;\\n                    max_time = delay;\\n                }\\n                t_cur\\n            });\\n        max_key\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn slowest_key(release_times: Vec<i32>, keys_pressed: String) -> char {\\n        let (mut max_time, mut max_key) = (0, \\' \\');\\n        release_times\\n            .iter()\\n            .zip(keys_pressed.chars())\\n            .fold(0, |t_prev, (&t_cur, c)| {\\n                let delay = t_cur - t_prev;\\n                if delay > max_time || delay == max_time && c > max_key {\\n                    max_key = c;\\n                    max_time = delay;\\n                }\\n                t_cur\\n            });\\n        max_key\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113010,
                "title": "javascript-faster-than-99-o-n-single-iteration-solution",
                "content": "```\\nvar slowestKey = function(releaseTimes, keysPressed) {\\n  let maxLength = 0, longestIndex = -1;\\n  \\n  for (let i in releaseTimes) {\\n    let timePressed = releaseTimes[i] - (releaseTimes[i-1] || 0);\\n    \\n    // if longer press found than current max, update maxLength and index of longest pressed key\\n    if (timePressed > maxLength) {\\n      maxLength = timePressed;\\n      longestIndex = i;\\n    } \\n    // if current timePressed is same as max, update longestIndex if current is lexicographically larger\\n    else if (timePressed === maxLength) {\\n      longestIndex = keysPressed[i] > keysPressed[longestIndex] ? i : longestIndex;\\n    }\\n  }\\n  \\n  return keysPressed[longestIndex];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar slowestKey = function(releaseTimes, keysPressed) {\\n  let maxLength = 0, longestIndex = -1;\\n  \\n  for (let i in releaseTimes) {\\n    let timePressed = releaseTimes[i] - (releaseTimes[i-1] || 0);\\n    \\n    // if longer press found than current max, update maxLength and index of longest pressed key\\n    if (timePressed > maxLength) {\\n      maxLength = timePressed;\\n      longestIndex = i;\\n    } \\n    // if current timePressed is same as max, update longestIndex if current is lexicographically larger\\n    else if (timePressed === maxLength) {\\n      longestIndex = keysPressed[i] > keysPressed[longestIndex] ? i : longestIndex;\\n    }\\n  }\\n  \\n  return keysPressed[longestIndex];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1019637,
                "title": "simple-python-solution-faster-than-97-89-o-n-time-and-o-1-space-detailed-comments",
                "content": "```\\n# Solution 1 : O(n) time and O(1) space complexity\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        largest_duration = 0 # track of largest duration\\n        start_time = 0 # handy for first key press duration\\n        result = \\'\\' # will contain the result key\\n        for i,release_time in enumerate(releaseTimes):\\n            duration = release_time - start_time # get the duration for each key\\n            # if duration is greater than current \\n            # largest duration\\n            # we update the largest duration and result key\\n            if duration > largest_duration:\\n                largest_duration = duration\\n                result = keysPressed[i]\\n            # if duration equal to largest duration\\n            # then we will check the keys\\' ascii value.\\n            # which one is larger, is the result key\\n            if duration == largest_duration:\\n                current_char = keysPressed[i]\\n                if ord(current_char) > ord(result):\\n                    result = current_char\\n            # current relase time will be next key\\'s start time\\n            start_time = release_time \\n        return result\\n            \\n        \\n```\\nRuntime: 48 ms, faster than 97.89% of Python3 online submissions for Slowest Key.\\nMemory Usage: 14.3 MB, less than 94.39% of Python3 online submissions for Slowest Key.",
                "solutionTags": [],
                "code": "```\\n# Solution 1 : O(n) time and O(1) space complexity\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        largest_duration = 0 # track of largest duration\\n        start_time = 0 # handy for first key press duration\\n        result = \\'\\' # will contain the result key\\n        for i,release_time in enumerate(releaseTimes):\\n            duration = release_time - start_time # get the duration for each key\\n            # if duration is greater than current \\n            # largest duration\\n            # we update the largest duration and result key\\n            if duration > largest_duration:\\n                largest_duration = duration\\n                result = keysPressed[i]\\n            # if duration equal to largest duration\\n            # then we will check the keys\\' ascii value.\\n            # which one is larger, is the result key\\n            if duration == largest_duration:\\n                current_char = keysPressed[i]\\n                if ord(current_char) > ord(result):\\n                    result = current_char\\n            # current relase time will be next key\\'s start time\\n            start_time = release_time \\n        return result\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 994372,
                "title": "python-3-straightforward",
                "content": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        #\\n        n = len(releaseTimes)\\n        time = releaseTimes[0]\\n        letter = keysPressed[0]\\n        for i in range(1,n):\\n            if releaseTimes[i]-releaseTimes[i-1] > time:\\n                time = releaseTimes[i]-releaseTimes[i-1]\\n                letter = keysPressed[i]\\n            elif releaseTimes[i]-releaseTimes[i-1] == time and keysPressed[i] > letter:\\n                letter = keysPressed[i]\\n        return letter\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        #\\n        n = len(releaseTimes)\\n        time = releaseTimes[0]\\n        letter = keysPressed[0]\\n        for i in range(1,n):\\n            if releaseTimes[i]-releaseTimes[i-1] > time:\\n                time = releaseTimes[i]-releaseTimes[i-1]\\n                letter = keysPressed[i]\\n            elif releaseTimes[i]-releaseTimes[i-1] == time and keysPressed[i] > letter:\\n                letter = keysPressed[i]\\n        return letter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987098,
                "title": "java",
                "content": "class Solution {\\n\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        char[] charArray = keysPressed.toCharArray();\\n        int diff=Integer.MIN_VALUE,index=0;\\n        for(int i=0;i< releaseTimes.length;i++){\\n            int timeTaken;\\n            if(i==0){\\n                timeTaken=releaseTimes[i];\\n            }else{\\n                timeTaken=releaseTimes[i]-releaseTimes[i-1];\\n            }\\n            if(timeTaken>diff){\\n                index=i;\\n                diff=timeTaken;\\n            }else if(timeTaken==diff && charArray[i]-\\'a\\'>charArray[index]-\\'a\\'){\\n                index=i;\\n            }\\n        }\\n        return charArray[index];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        char[] charArray = keysPressed.toCharArray();\\n        int diff=Integer.MIN_VALUE,index=0;\\n        for(int i=0;i< releaseTimes.length;i++){\\n            int timeTaken;\\n            if(i==0){\\n                timeTaken=releaseTimes[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 963231,
                "title": "c-solution",
                "content": "```\\nchar slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n\\tchar resKey = keysPressed[0];\\n\\tint resTime = releaseTimes[0];\\n\\tfor (int i = 1; i < releaseTimes.size(); i++) {\\n\\t\\tint curTime = releaseTimes[i] - releaseTimes[i - 1];\\n\\t\\tif (curTime >= resTime) {\\n\\t\\t\\tif (curTime == resTime)\\n\\t\\t\\t\\tresKey = max(resKey, keysPressed[i]);\\n\\t\\t\\telse {\\n\\t\\t\\t\\tresKey = keysPressed[i];\\n\\t\\t\\t\\tresTime = curTime;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn resKey;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nchar slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n\\tchar resKey = keysPressed[0];\\n\\tint resTime = releaseTimes[0];\\n\\tfor (int i = 1; i < releaseTimes.size(); i++) {\\n\\t\\tint curTime = releaseTimes[i] - releaseTimes[i - 1];\\n\\t\\tif (curTime >= resTime) {\\n\\t\\t\\tif (curTime == resTime)\\n\\t\\t\\t\\tresKey = max(resKey, keysPressed[i]);\\n\\t\\t\\telse {\\n\\t\\t\\t\\tresKey = keysPressed[i];\\n\\t\\t\\t\\tresTime = curTime;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn resKey;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 909794,
                "title": "no-loops-ruby-swift-c-haskell-apl-solutions",
                "content": "https://github.com/codereport/LeetCode\\n\\n**Ruby:**\\n```\\ndef slowest_key(t, k)\\n    return t.unshift(0)\\n            .each_cons(2)\\n            .map{|a, b| b - a}\\n            .zip(k.chars)\\n            .max[1]\\nend\\n```\\n\\n**Swift:**\\n```\\nfunc slowestKey(_ t: [Int], _ k: String) -> Character {\\n    let d = zip(t, [0] + t).map(-)\\n    let e = zip(Array(k), d.map{ $0 == d.max() })\\n    return e.filter{ $1 }.map { $0.0 }.max()!\\n}\\n```\\n\\n**C++:**\\n```\\nchar slowestKey(vector<int>& t, string k) {\\n    auto d = std::vector(t.size(), 0);\\n    std::adjacent_difference(t.cbegin(), t.cend(), d.begin());\\n    return std::inner_product(d.cbegin(), d.cend(), k.begin(),\\n        std::pair{-1, \\'a\\'}, \\n        [](auto a, auto b) { return std::max(a, b); },\\n        [](auto a, auto b) { return std::pair{a, b}; }).second;\\n}\\n```\\n\\n**Haskell:**\\n```\\nslowestKey :: String -> [Int] -> Char\\nslowestKey k = snd \\n             . maximum \\n             . (flip zip) k \\n             . mapAdjacent (flip (-)) \\n             . (0:)\\n```\\n\\n**APL:**\\n![image](https://assets.leetcode.com/users/images/ec766ec2-5682-4448-b225-f32e40db8611_1603638178.6379042.png)\\n",
                "solutionTags": [
                    "C",
                    "Ruby",
                    "Swift"
                ],
                "code": "```\\ndef slowest_key(t, k)\\n    return t.unshift(0)\\n            .each_cons(2)\\n            .map{|a, b| b - a}\\n            .zip(k.chars)\\n            .max[1]\\nend\\n```\n```\\nfunc slowestKey(_ t: [Int], _ k: String) -> Character {\\n    let d = zip(t, [0] + t).map(-)\\n    let e = zip(Array(k), d.map{ $0 == d.max() })\\n    return e.filter{ $1 }.map { $0.0 }.max()!\\n}\\n```\n```\\nchar slowestKey(vector<int>& t, string k) {\\n    auto d = std::vector(t.size(), 0);\\n    std::adjacent_difference(t.cbegin(), t.cend(), d.begin());\\n    return std::inner_product(d.cbegin(), d.cend(), k.begin(),\\n        std::pair{-1, \\'a\\'}, \\n        [](auto a, auto b) { return std::max(a, b); },\\n        [](auto a, auto b) { return std::pair{a, b}; }).second;\\n}\\n```\n```\\nslowestKey :: String -> [Int] -> Char\\nslowestKey k = snd \\n             . maximum \\n             . (flip zip) k \\n             . mapAdjacent (flip (-)) \\n             . (0:)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 909523,
                "title": "java-easy-and-clear-code-one-pass",
                "content": "if you like it pls upvote\\n\\nJava\\n```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int[] arr = new int[releaseTimes.length];\\n        arr[0] = releaseTimes[0];\\n        int max =arr[0];\\n        int res =keysPressed.charAt(0)-\\'a\\';\\n        for(int i =1;i<releaseTimes.length;i++){\\n            arr[i] = releaseTimes[i] -releaseTimes[i-1];\\n            if(arr[i] == max){\\n                res = Math.max(res,keysPressed.charAt(i)-\\'a\\');\\n            }\\n            else if(arr[i] > max){\\n                max = arr[i];\\n                res = keysPressed.charAt(i)-\\'a\\';\\n            }\\n        }\\n        \\n        \\n        \\n        return (char)(res+\\'a\\');\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int[] arr = new int[releaseTimes.length];\\n        arr[0] = releaseTimes[0];\\n        int max =arr[0];\\n        int res =keysPressed.charAt(0)-\\'a\\';\\n        for(int i =1;i<releaseTimes.length;i++){\\n            arr[i] = releaseTimes[i] -releaseTimes[i-1];\\n            if(arr[i] == max){\\n                res = Math.max(res,keysPressed.charAt(i)-\\'a\\');\\n            }\\n            else if(arr[i] > max){\\n                max = arr[i];\\n                res = keysPressed.charAt(i)-\\'a\\';\\n            }\\n        }\\n        \\n        \\n        \\n        return (char)(res+\\'a\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909096,
                "title": "my-java-solution-easy-understanding",
                "content": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int longPress = releaseTimes[0];\\n        int index = 0;\\n        for (int i=1; i<releaseTimes.length; i++) {\\n            int currentPress = releaseTimes[i] - releaseTimes[i-1];\\n            if (currentPress > longPress) {\\n                index = i;\\n                longPress = currentPress;\\n            }\\n            else if (currentPress == longPress && keysPressed.charAt(i) > keysPressed.charAt(index)) {\\n                index = i;\\n                longPress = currentPress;\\n            }\\n        }\\n        return keysPressed.charAt(index);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int longPress = releaseTimes[0];\\n        int index = 0;\\n        for (int i=1; i<releaseTimes.length; i++) {\\n            int currentPress = releaseTimes[i] - releaseTimes[i-1];\\n            if (currentPress > longPress) {\\n                index = i;\\n                longPress = currentPress;\\n            }\\n            else if (currentPress == longPress && keysPressed.charAt(i) > keysPressed.charAt(index)) {\\n                index = i;\\n                longPress = currentPress;\\n            }\\n        }\\n        return keysPressed.charAt(index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909080,
                "title": "java-optimal-solution-o-n-one-pass-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int longestDuration = releaseTimes[0];\\n        char slowestKey = keysPressed.charAt(0);\\n        for (int i = 1; i < releaseTimes.length; i++) {\\n            int duration = releaseTimes[i] - releaseTimes[i - 1];\\n            if (duration > longestDuration || (duration == longestDuration && keysPressed.charAt(i) > slowestKey)) {\\n                slowestKey = keysPressed.charAt(i);\\n                longestDuration = duration;\\n            }\\n        }\\n        return slowestKey;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int longestDuration = releaseTimes[0];\\n        char slowestKey = keysPressed.charAt(0);\\n        for (int i = 1; i < releaseTimes.length; i++) {\\n            int duration = releaseTimes[i] - releaseTimes[i - 1];\\n            if (duration > longestDuration || (duration == longestDuration && keysPressed.charAt(i) > slowestKey)) {\\n                slowestKey = keysPressed.charAt(i);\\n                longestDuration = duration;\\n            }\\n        }\\n        return slowestKey;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909026,
                "title": "o-n-store-max",
                "content": "**Idea:** Save max duration for the key and the key itself. Traverse over the releaseTimes and find the time. If `time difference == max`, key character should be max lexicographically. For instance if `a` and `b` have 10 unit time, we can use something like: `maxOf(\\'a\\', \\'b\\')`\\n\\n```\\n    fun slowestKey(releaseTimes: IntArray, keysPressed: String): Char {\\n        var max = releaseTimes[0]\\n        var key = keysPressed[0]\\n        \\n        for (i in 1 until releaseTimes.size) {\\n            val diff = releaseTimes[i] - releaseTimes[i-1]\\n            \\n            if (diff >= max) {\\n                key = if (max != diff) keysPressed[i] else maxOf(key, keysPressed[i])\\n                max = diff\\n            }\\n        }\\n        \\n        return key\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun slowestKey(releaseTimes: IntArray, keysPressed: String): Char {\\n        var max = releaseTimes[0]\\n        var key = keysPressed[0]\\n        \\n        for (i in 1 until releaseTimes.size) {\\n            val diff = releaseTimes[i] - releaseTimes[i-1]\\n            \\n            if (diff >= max) {\\n                key = if (max != diff) keysPressed[i] else maxOf(key, keysPressed[i])\\n                max = diff\\n            }\\n        }\\n        \\n        return key\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 908993,
                "title": "easy-c-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string str) {\\n        vector<char>vect;\\n        unordered_map<char,int>mp;\\n        mp[str[0]] = releaseTimes[0];\\n        int currmax = releaseTimes[0];\\n        for(int i=1;i<str.size();i++)\\n        {\\n            mp[str[i]] =max(mp[str[i]],releaseTimes[i]-releaseTimes[i-1]);\\n            currmax = max(currmax,releaseTimes[i]-releaseTimes[i-1]);\\n        }\\n        for(auto c : mp)\\n        {\\n            if(c.second == currmax)\\n            {\\n                vect.push_back(c.first);\\n            }\\n        }\\n    sort(vect.begin(),vect.end());\\n        return vect[vect.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string str) {\\n        vector<char>vect;\\n        unordered_map<char,int>mp;\\n        mp[str[0]] = releaseTimes[0];\\n        int currmax = releaseTimes[0];\\n        for(int i=1;i<str.size();i++)\\n        {\\n            mp[str[i]] =max(mp[str[i]],releaseTimes[i]-releaseTimes[i-1]);\\n            currmax = max(currmax,releaseTimes[i]-releaseTimes[i-1]);\\n        }\\n        for(auto c : mp)\\n        {\\n            if(c.second == currmax)\\n            {\\n                vect.push_back(c.first);\\n            }\\n        }\\n    sort(vect.begin(),vect.end());\\n        return vect[vect.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053738,
                "title": "easy-to-read-solution-in-ruby",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Maintain and initialize 2 counters with index 0 respective variables: 1 for max duration and another for key pressed for that max duration.\\n- Iterate through release times starting from index 1\\n- Calculate current duration and compare it with max duration\\n- If current duration is greater than max duration, update max duration with current duration and key pressed var with the respectice value\\n- If current duration is equal to max duration, comapre current key pressed and max key pressed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n# @param {Integer[]} release_times\\n# @param {String} keys_pressed\\n# @return {Character}\\ndef slowest_key(release_times, keys_pressed)\\n    max_duration = release_times[0]\\n    max_key_pressed = keys_pressed[0]\\n\\n    for i in 1...release_times.length do\\n        curr_duration = release_times[i] - release_times[i - 1]\\n        if curr_duration > max_duration\\n            max_duration = curr_duration\\n            max_key_pressed = keys_pressed[i]\\n        elsif curr_duration == max_duration\\n            curr_key_pressed = keys_pressed[i]\\n            if curr_key_pressed > max_key_pressed\\n                max_key_pressed = curr_key_pressed\\n            end\\n        end\\n    end\\n    max_key_pressed\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} release_times\\n# @param {String} keys_pressed\\n# @return {Character}\\ndef slowest_key(release_times, keys_pressed)\\n    max_duration = release_times[0]\\n    max_key_pressed = keys_pressed[0]\\n\\n    for i in 1...release_times.length do\\n        curr_duration = release_times[i] - release_times[i - 1]\\n        if curr_duration > max_duration\\n            max_duration = curr_duration\\n            max_key_pressed = keys_pressed[i]\\n        elsif curr_duration == max_duration\\n            curr_key_pressed = keys_pressed[i]\\n            if curr_key_pressed > max_key_pressed\\n                max_key_pressed = curr_key_pressed\\n            end\\n        end\\n    end\\n    max_key_pressed\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3676056,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& rt, string kp) {\\n        int time=rt[0];\\n        char mx=kp[0];\\n        for(int i=1; i<rt.size(); i++)\\n        {\\n            int val=rt[i]-rt[i-1];\\n            if(val>time){\\n                mx = kp[i];\\n                time=val;\\n            }\\n            else if(val==time)\\n                mx = max(mx, kp[i]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& rt, string kp) {\\n        int time=rt[0];\\n        char mx=kp[0];\\n        for(int i=1; i<rt.size(); i++)\\n        {\\n            int val=rt[i]-rt[i-1];\\n            if(val>time){\\n                mx = kp[i];\\n                time=val;\\n            }\\n            else if(val==time)\\n                mx = max(mx, kp[i]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591299,
                "title": "easy-to-understand-c-single-loop-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse the given vector \"**releaseTimes**\", obtain the pressing duration for each key, compare them to get the maximum value and find corresponding keys  in the string \"**keysPressed**\". For more than one such keys obtained, simply compare the characters.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Declare 3 variables \\'**n**\\',\\'**max**\\' and \\'**maxc**\\' assigning them the value of upperbound index of the given vector(or string), first element of the array \"**releaseTimes**\" and the first element of the given string \"**keysPressed**\" respectively.\\n- Here, we are going to compare all the elements of the given vector with its first element because the first element of the vector needs no manipulation and directly provides the pressing duration of the first key. \\n- Now, using a for loop, we traverse the vector, backwards, from the upperbound \\'**n**\\' upto the second element. Each traversed element is manipulated as the difference of itself and its previous term. This process, for each iteration, gives us the pressing duration of each corresponding key in the given string \"**keysPressed**\".\\n- Then, within the same iteration of the loop, we compare \\'**max**\\' with the obtained duration value and if \\'**max**\\' is smaller, \\'**max**\\'is assigned the new duration value and \\'**maxc**\\' is assigned the corresponding key from the string \"**keysPressed**\". This process, on successive iterations, simultaneously provides us the maximum pressing duration of a key \\'**max**\\' and the corresponding key \\'**maxc**\\'.  \\n- Coming to the part of multiple keys for the same \\'**max**\\' pressing duration, we simply compare the characters using the relational operator and assign the greater character to \\'**maxc**\\'.\\n\\nAfter the loop is run completely, we obtain the required key as \\'**maxc**\\'.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int n=releaseTimes.size()-1,max=releaseTimes[0];char maxc=keysPressed[0];\\n        for(int i=n;i!=0;i--){\\n            releaseTimes[i]-=releaseTimes[i-1];\\n            if(max<releaseTimes[i]){\\n                max=releaseTimes[i];maxc=keysPressed[i];\\n            }\\n            if(max==releaseTimes[i])if(keysPressed[i]>maxc)maxc=keysPressed[i];\\n        }\\n        return maxc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int n=releaseTimes.size()-1,max=releaseTimes[0];char maxc=keysPressed[0];\\n        for(int i=n;i!=0;i--){\\n            releaseTimes[i]-=releaseTimes[i-1];\\n            if(max<releaseTimes[i]){\\n                max=releaseTimes[i];maxc=keysPressed[i];\\n            }\\n            if(max==releaseTimes[i])if(keysPressed[i]>maxc)maxc=keysPressed[i];\\n        }\\n        return maxc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399585,
                "title": "slowest-key-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int i, max=0;\\n        char ans=\\'a\\';\\n        releaseTimes.insert(releaseTimes.begin()+0, 0);\\n        for(i=1 ; i<releaseTimes.size() ; i++)\\n        {\\n            if(releaseTimes[i]-releaseTimes[i-1]>max)\\n            {\\n                max = releaseTimes[i]-releaseTimes[i-1];\\n                ans = keysPressed[i-1];\\n            }\\n            else if(releaseTimes[i]-releaseTimes[i-1]==max && keysPressed[i-1]>ans)\\n            {\\n                ans = keysPressed[i-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int i, max=0;\\n        char ans=\\'a\\';\\n        releaseTimes.insert(releaseTimes.begin()+0, 0);\\n        for(i=1 ; i<releaseTimes.size() ; i++)\\n        {\\n            if(releaseTimes[i]-releaseTimes[i-1]>max)\\n            {\\n                max = releaseTimes[i]-releaseTimes[i-1];\\n                ans = keysPressed[i-1];\\n            }\\n            else if(releaseTimes[i]-releaseTimes[i-1]==max && keysPressed[i-1]>ans)\\n            {\\n                ans = keysPressed[i-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363734,
                "title": "using-dictionary",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        time = {}\\n        prev = 0\\n        m = 0\\n        for i in range(0, len(releaseTimes)):\\n            a = releaseTimes[i]-prev\\n            prev = releaseTimes[i]\\n            m = max(m,a)\\n            if keysPressed[i] not in time:\\n                time[keysPressed[i]] = a\\n            else:\\n                time[keysPressed[i]]=max(time[keysPressed[i]], a)\\n\\n        return sorted([k for k, v in sorted(time.items(), reverse=True, key=lambda item:item[1]) if v==m], reverse=True)[0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        time = {}\\n        prev = 0\\n        m = 0\\n        for i in range(0, len(releaseTimes)):\\n            a = releaseTimes[i]-prev\\n            prev = releaseTimes[i]\\n            m = max(m,a)\\n            if keysPressed[i] not in time:\\n                time[keysPressed[i]] = a\\n            else:\\n                time[keysPressed[i]]=max(time[keysPressed[i]], a)\\n\\n        return sorted([k for k, v in sorted(time.items(), reverse=True, key=lambda item:item[1]) if v==m], reverse=True)[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222319,
                "title": "c-simple",
                "content": "```\\nchar slowestKey(vector<int>& rel, string keys) {\\n        \\n        int n = keys.size();\\n        vector<pair<int,char>> v;\\n\\n        v.push_back({rel[0], keys[0]});\\n\\n        for(int i=1;i<n;i++){\\n            v.push_back({rel[i]- rel[i-1], keys[i]});\\n        }\\n\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n\\n        return v[0].second;\\n        \\n\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar slowestKey(vector<int>& rel, string keys) {\\n        \\n        int n = keys.size();\\n        vector<pair<int,char>> v;\\n\\n        v.push_back({rel[0], keys[0]});\\n\\n        for(int i=1;i<n;i++){\\n            v.push_back({rel[i]- rel[i-1], keys[i]});\\n        }\\n\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n\\n        return v[0].second;\\n        \\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3033542,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        char answer=keysPressed[0];\\n        int time=releaseTimes[0];\\n        for(int i=1;i<releaseTimes.size();i++){\\n            int duration=releaseTimes[i]-releaseTimes[i-1];\\n            if(duration==time){\\n                answer=max(answer,keysPressed[i]);\\n            }\\n            if(duration>time){\\n                answer=keysPressed[i];\\n                time=duration;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        char answer=keysPressed[0];\\n        int time=releaseTimes[0];\\n        for(int i=1;i<releaseTimes.size();i++){\\n            int duration=releaseTimes[i]-releaseTimes[i-1];\\n            if(duration==time){\\n                answer=max(answer,keysPressed[i]);\\n            }\\n            if(duration>time){\\n                answer=keysPressed[i];\\n                time=duration;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819337,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int time = releaseTimes[0], new_time = 0;\\n        char key = keysPressed[0];\\n        \\n        for (int i = 1; i < releaseTimes.size(); i++) {\\n            new_time = releaseTimes[i] - releaseTimes[i-1];\\n            \\n            if (new_time == time) \\n                key = keysPressed[i] > key ? keysPressed[i] : key;\\n            \\n            else if (new_time > time) {\\n                time = new_time;\\n                key = keysPressed[i];\\n            }\\n        }\\n        return key;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int time = releaseTimes[0], new_time = 0;\\n        char key = keysPressed[0];\\n        \\n        for (int i = 1; i < releaseTimes.size(); i++) {\\n            new_time = releaseTimes[i] - releaseTimes[i-1];\\n            \\n            if (new_time == time) \\n                key = keysPressed[i] > key ? keysPressed[i] : key;\\n            \\n            else if (new_time > time) {\\n                time = new_time;\\n                key = keysPressed[i];\\n            }\\n        }\\n        return key;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733598,
                "title": "typescript-javascript-92-memory-less",
                "content": "```\\nfunction slowestKey(releaseTimes: number[], keysPressed: string): string {\\n    let maxKey = keysPressed[0];\\n    let maxDuration = releaseTimes[0];\\n    \\n    for (let i = 1; i < keysPressed.length; i++) {\\n        const key = keysPressed[i];\\n        const duration = releaseTimes[i] - releaseTimes[i - 1];\\n        \\n        if (maxDuration < duration || maxDuration === duration && maxKey < key) {\\n            maxDuration = duration;\\n            maxKey = key;\\n        }\\n    }\\n    \\n    return maxKey;\\n}\\n```\\n\\n<img alt=\"submission\" src=\"https://assets.leetcode.com/users/images/100e33b9-4d3b-4c8a-b104-56932b94ddec_1666474131.2110178.png\" width=\"600px\"/>\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction slowestKey(releaseTimes: number[], keysPressed: string): string {\\n    let maxKey = keysPressed[0];\\n    let maxDuration = releaseTimes[0];\\n    \\n    for (let i = 1; i < keysPressed.length; i++) {\\n        const key = keysPressed[i];\\n        const duration = releaseTimes[i] - releaseTimes[i - 1];\\n        \\n        if (maxDuration < duration || maxDuration === duration && maxKey < key) {\\n            maxDuration = duration;\\n            maxKey = key;\\n        }\\n    }\\n    \\n    return maxKey;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2363201,
                "title": "java-o-n-solution-using-prefix-sum",
                "content": "Using prefix sum to calculate pressing time for each key and then comparing them\\n```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) \\n    {\\n        int n=releaseTimes.length;\\n        int[] prefix = new int[n];\\n        \\n        prefix[0] = releaseTimes[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i] = releaseTimes[i] - releaseTimes[i-1];\\n        }\\n        \\n        int ans = prefix[0];\\n        char bestchar = keysPressed.charAt(0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ans<prefix[i])\\n            {\\n                ans = prefix[i];\\n                bestchar = keysPressed.charAt(i);\\n            }\\n            else if((ans==prefix[i]) && (keysPressed.charAt(i) > bestchar))\\n            {\\n                bestchar = keysPressed.charAt(i);\\n            }\\n        }\\n                    \\n    return bestchar;\\n        \\n    }\\n}\\n```\\n\\n**Happy Coding**",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) \\n    {\\n        int n=releaseTimes.length;\\n        int[] prefix = new int[n];\\n        \\n        prefix[0] = releaseTimes[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i] = releaseTimes[i] - releaseTimes[i-1];\\n        }\\n        \\n        int ans = prefix[0];\\n        char bestchar = keysPressed.charAt(0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ans<prefix[i])\\n            {\\n                ans = prefix[i];\\n                bestchar = keysPressed.charAt(i);\\n            }\\n            else if((ans==prefix[i]) && (keysPressed.charAt(i) > bestchar))\\n            {\\n                bestchar = keysPressed.charAt(i);\\n            }\\n        }\\n                    \\n    return bestchar;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075895,
                "title": "scala-one-line-solution",
                "content": "```\\n def slowestKey(releaseTimes: Array[Int], keysPressed: String): Char = {\\n    (((List(0) :::releaseTimes.toList) zip releaseTimes.toList).map(n => n._2 - n._1) zip keysPressed).maxBy(n => (n._1, n._2))._2\\n  }\\n\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n def slowestKey(releaseTimes: Array[Int], keysPressed: String): Char = {\\n    (((List(0) :::releaseTimes.toList) zip releaseTimes.toList).map(n => n._2 - n._1) zip keysPressed).maxBy(n => (n._1, n._2))._2\\n  }\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2015163,
                "title": "java-fast-solution",
                "content": "```\\n\\tpublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int max = releaseTimes[0];\\n        char maxKey = keysPressed.charAt(0);\\n        for(int i = 1; i < releaseTimes.length; i++) {\\n            int diff = releaseTimes[i] - releaseTimes[i-1];\\n            if(diff > max) {\\n                max = diff;\\n                maxKey = keysPressed.charAt(i);\\n            } else if(diff == max) {\\n                maxKey = (char)Math.max(maxKey, keysPressed.charAt(i));\\n            }\\n        }\\n        return maxKey;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int max = releaseTimes[0];\\n        char maxKey = keysPressed.charAt(0);\\n        for(int i = 1; i < releaseTimes.length; i++) {\\n            int diff = releaseTimes[i] - releaseTimes[i-1];\\n            if(diff > max) {\\n                max = diff;\\n                maxKey = keysPressed.charAt(i);\\n            } else if(diff == max) {\\n                maxKey = (char)Math.max(maxKey, keysPressed.charAt(i));\\n            }\\n        }\\n        return maxKey;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995310,
                "title": "javascript-solution",
                "content": "I think the code is self-explanatory.\\n\\n```\\nvar slowestKey = function(releaseTimes, keysPressed) {\\n    let [key, duration] = [null, 0];\\n    for (let i = 0; i < releaseTimes.length; i++) {\\n        const currentKey = keysPressed[i];\\n        const currentDuration = releaseTimes[i] - (releaseTimes[i - 1] || 0);\\n        if (currentDuration > duration) {\\n            key = currentKey;\\n            duration = currentDuration; \\n        } else if (currentDuration === duration && currentKey.localeCompare(key) !== -1) { // compares keys, for \\'a\\'.localeCompare(\\'b\\') it will be -1 meaning that \\'a\\' is less than \\'b\\' so for \\'ba\\' case with the same durations the answer will be \\'b\\'\\n            key = currentKey;\\n            duration = currentDuration;        \\n        }\\n    }\\n    \\n    return key;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar slowestKey = function(releaseTimes, keysPressed) {\\n    let [key, duration] = [null, 0];\\n    for (let i = 0; i < releaseTimes.length; i++) {\\n        const currentKey = keysPressed[i];\\n        const currentDuration = releaseTimes[i] - (releaseTimes[i - 1] || 0);\\n        if (currentDuration > duration) {\\n            key = currentKey;\\n            duration = currentDuration; \\n        } else if (currentDuration === duration && currentKey.localeCompare(key) !== -1) { // compares keys, for \\'a\\'.localeCompare(\\'b\\') it will be -1 meaning that \\'a\\' is less than \\'b\\' so for \\'ba\\' case with the same durations the answer will be \\'b\\'\\n            key = currentKey;\\n            duration = currentDuration;        \\n        }\\n    }\\n    \\n    return key;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1951178,
                "title": "simple-c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& rt, string kp) {\\n        int ans = rt[0];\\n        char key = kp[0];\\n        for(int i=1;i<rt.size();i++){\\n            int temp = rt[i]-rt[i-1];\\n            if(temp>ans){\\n                ans = temp;\\n                key = kp[i];\\n            }\\n            else if(temp==ans){\\n                key = key-kp[i]>0?key:kp[i];\\n            }\\n        }\\n        return key;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& rt, string kp) {\\n        int ans = rt[0];\\n        char key = kp[0];\\n        for(int i=1;i<rt.size();i++){\\n            int temp = rt[i]-rt[i-1];\\n            if(temp>ans){\\n                ans = temp;\\n                key = kp[i];\\n            }\\n            else if(temp==ans){\\n                key = key-kp[i]>0?key:kp[i];\\n            }\\n        }\\n        return key;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857991,
                "title": "python-o-n-easy-for-newbies",
                "content": "```\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        ld,lex = releaseTimes[0],keysPressed[0]\\n        for i in range(1,len(releaseTimes)):\\n            t = releaseTimes[i]- releaseTimes[i-1] \\n            if ld <t:\\n                ld = t\\n                lex = keysPressed[i]\\n            elif ld == t:\\n                lex = max(lex,keysPressed[i])\\n        return lex\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        ld,lex = releaseTimes[0],keysPressed[0]\\n        for i in range(1,len(releaseTimes)):\\n            t = releaseTimes[i]- releaseTimes[i-1] \\n            if ld <t:\\n                ld = t\\n                lex = keysPressed[i]\\n            elif ld == t:\\n                lex = max(lex,keysPressed[i])\\n        return lex\\n                \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1828777,
                "title": "java-o-n-solution-faster-than-98",
                "content": "```\\npublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int longestduration = releaseTimes[0];\\n        char ldkeypreseed = keysPressed.charAt(0);\\n        for (int i = 1; i < releaseTimes.length; i++){\\n            if (longestduration < (releaseTimes[i] - releaseTimes[i - 1])){\\n                longestduration = (releaseTimes[i] - releaseTimes[i - 1]);\\n                ldkeypreseed = keysPressed.charAt(i);\\n            } else if (longestduration == (releaseTimes[i] - releaseTimes[i - 1]))  {\\n                if ((int)(keysPressed.charAt(i)) > (int)(ldkeypreseed)){\\n                    longestduration = (releaseTimes[i] - releaseTimes[i - 1]);\\n                    ldkeypreseed = keysPressed.charAt(i);\\n                }\\n            }\\n        }\\n        return ldkeypreseed;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int longestduration = releaseTimes[0];\\n        char ldkeypreseed = keysPressed.charAt(0);\\n        for (int i = 1; i < releaseTimes.length; i++){\\n            if (longestduration < (releaseTimes[i] - releaseTimes[i - 1])){\\n                longestduration = (releaseTimes[i] - releaseTimes[i - 1]);\\n                ldkeypreseed = keysPressed.charAt(i);\\n            } else if (longestduration == (releaseTimes[i] - releaseTimes[i - 1]))  {\\n                if ((int)(keysPressed.charAt(i)) > (int)(ldkeypreseed)){\\n                    longestduration = (releaseTimes[i] - releaseTimes[i - 1]);\\n                    ldkeypreseed = keysPressed.charAt(i);\\n                }\\n            }\\n        }\\n        return ldkeypreseed;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1780642,
                "title": "2-lines-python-solution-faster-than-60-memory-less-than-60",
                "content": "def slowestKey(self, R: List[int], S: str) -> str:\\n        R = [R[0]] + [R[i+1]-R[i] for i in range(len(R)-1)]\\n        return max([(b,a) for (a,b) in zip(S,R)])[1]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "def slowestKey(self, R: List[int], S: str) -> str:\\n        R = [R[0]] + [R[i+1]-R[i] for i in range(len(R)-1)]\\n        return max([(b,a) for (a,b) in zip(S,R)])[1]",
                "codeTag": "Python3"
            },
            {
                "id": 1748201,
                "title": "easy-python-three-rows-solution",
                "content": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        for i in range(len(releaseTimes)-1, 0, -1):\\n            releaseTimes[i] = releaseTimes[i] - releaseTimes[i-1]\\n        return max(zip(releaseTimes,list(keysPressed)))[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        for i in range(len(releaseTimes)-1, 0, -1):\\n            releaseTimes[i] = releaseTimes[i] - releaseTimes[i-1]\\n        return max(zip(releaseTimes,list(keysPressed)))[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723345,
                "title": "c-time-complexity-o-n-aux-space-o-1",
                "content": "```\\n/*\\n * author: deytulsi18\\n * problem: https://leetcode.com/problems/slowest-key/\\n * time complexity: O(n)\\n * auxiliary space: O(1)\\n * language: cpp\\n */\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        \\n        char res = keysPressed[0];\\n        int duration = releaseTimes[0];\\n        \\n        for (int i = 1; i < releaseTimes.size(); i++)\\n        {\\n            int currentDuration = releaseTimes[i] - releaseTimes[i - 1];\\n            if (duration < currentDuration)\\n            {\\n                res = keysPressed[i];\\n                duration = currentDuration;\\n            }\\n            else if (duration == currentDuration)\\n            {\\n                res = max(res, keysPressed[i]);\\n                duration = currentDuration;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n * author: deytulsi18\\n * problem: https://leetcode.com/problems/slowest-key/\\n * time complexity: O(n)\\n * auxiliary space: O(1)\\n * language: cpp\\n */\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        \\n        char res = keysPressed[0];\\n        int duration = releaseTimes[0];\\n        \\n        for (int i = 1; i < releaseTimes.size(); i++)\\n        {\\n            int currentDuration = releaseTimes[i] - releaseTimes[i - 1];\\n            if (duration < currentDuration)\\n            {\\n                res = keysPressed[i];\\n                duration = currentDuration;\\n            }\\n            else if (duration == currentDuration)\\n            {\\n                res = max(res, keysPressed[i]);\\n                duration = currentDuration;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632454,
                "title": "java-readable-solution",
                "content": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        char longestKey = keysPressed.charAt(0);\\n        int longestTime = releaseTimes[0];\\n        for(int i = 1; i < keysPressed.length(); i++) {\\n            char key = keysPressed.charAt(i);\\n            int time = releaseTimes[i] - releaseTimes[i-1];\\n            if(time > longestTime) {\\n                longestKey = key;\\n                longestTime = time;\\n            }\\n            else if((time == longestTime) && (key > longestKey)) {\\n                longestKey = key;\\n            }\\n        }\\n        \\n        return longestKey;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        char longestKey = keysPressed.charAt(0);\\n        int longestTime = releaseTimes[0];\\n        for(int i = 1; i < keysPressed.length(); i++) {\\n            char key = keysPressed.charAt(i);\\n            int time = releaseTimes[i] - releaseTimes[i-1];\\n            if(time > longestTime) {\\n                longestKey = key;\\n                longestTime = time;\\n            }\\n            else if((time == longestTime) && (key > longestKey)) {\\n                longestKey = key;\\n            }\\n        }\\n        \\n        return longestKey;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617953,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        max_duration, key = releaseTimes[0], keysPressed[0]\\n        for i in range(1, len(releaseTimes)):\\n            duration = releaseTimes[i] - releaseTimes[i - 1]\\n            if duration > max_duration:\\n                max_duration = duration\\n                key = keysPressed[i]\\n            elif duration == max_duration:\\n                key = max(keysPressed[i], key)\\n\\n        return key\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        max_duration, key = releaseTimes[0], keysPressed[0]\\n        for i in range(1, len(releaseTimes)):\\n            duration = releaseTimes[i] - releaseTimes[i - 1]\\n            if duration > max_duration:\\n                max_duration = duration\\n                key = keysPressed[i]\\n            elif duration == max_duration:\\n                key = max(keysPressed[i], key)\\n\\n        return key\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473117,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int ans=releaseTimes[0];\\n        char key=keysPressed[0];\\n        for(int i=1;i<releaseTimes.size();i++){\\n            int duration=releaseTimes[i]-releaseTimes[i-1];\\n            if(duration>ans){\\n                ans=duration;\\n                key=keysPressed[i];\\n            }else if(duration==ans){\\n                ans=duration;\\n                key=key-keysPressed[i]>0?key:keysPressed[i];\\n            }\\n        }\\n        return key;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int ans=releaseTimes[0];\\n        char key=keysPressed[0];\\n        for(int i=1;i<releaseTimes.size();i++){\\n            int duration=releaseTimes[i]-releaseTimes[i-1];\\n            if(duration>ans){\\n                ans=duration;\\n                key=keysPressed[i];\\n            }else if(duration==ans){\\n                ans=duration;\\n                key=key-keysPressed[i]>0?key:keysPressed[i];\\n            }\\n        }\\n        return key;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459068,
                "title": "java-straightforward-solution",
                "content": "```\\n// Just find maximum difference of two consecutive values in releaseTime\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        char[] arr = keysPressed.toCharArray();\\n        \\n        int slowest = 0;\\n        int duration = releaseTimes[0];\\n        \\n        for(int i = 1; i < arr.length; i++) {\\n            if(duration < releaseTimes[i] - releaseTimes[i-1] || (arr[i] > arr[slowest] && duration == releaseTimes[i] - releaseTimes[i-1])) {\\n                slowest = i;\\n                duration = releaseTimes[i] - releaseTimes[i-1];\\n            }\\n        }\\n        \\n        return arr[slowest];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Just find maximum difference of two consecutive values in releaseTime\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        char[] arr = keysPressed.toCharArray();\\n        \\n        int slowest = 0;\\n        int duration = releaseTimes[0];\\n        \\n        for(int i = 1; i < arr.length; i++) {\\n            if(duration < releaseTimes[i] - releaseTimes[i-1] || (arr[i] > arr[slowest] && duration == releaseTimes[i] - releaseTimes[i-1])) {\\n                slowest = i;\\n                duration = releaseTimes[i] - releaseTimes[i-1];\\n            }\\n        }\\n        \\n        return arr[slowest];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451634,
                "title": "java-easy-100-faster",
                "content": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n    \\n        int  index=0;\\n\\n        int  duration = 0;\\n        int  maxDuration = releaseTimes[0];\\n        \\n        for(int i = 1 ; i <releaseTimes.length ; i++){\\n            duration = releaseTimes[i]-releaseTimes[i-1];\\n         \\n            if(duration >  maxDuration || (maxDuration == duration && keysPressed.charAt(index) < keysPressed.charAt(i))){\\n                     \\n               maxDuration = duration;\\n                index = i;\\n            \\n            }\\n            \\n        }\\n        \\n        return keysPressed.charAt(index);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n    \\n        int  index=0;\\n\\n        int  duration = 0;\\n        int  maxDuration = releaseTimes[0];\\n        \\n        for(int i = 1 ; i <releaseTimes.length ; i++){\\n            duration = releaseTimes[i]-releaseTimes[i-1];\\n         \\n            if(duration >  maxDuration || (maxDuration == duration && keysPressed.charAt(index) < keysPressed.charAt(i))){\\n                     \\n               maxDuration = duration;\\n                index = i;\\n            \\n            }\\n            \\n        }\\n        \\n        return keysPressed.charAt(index);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449273,
                "title": "kotlin-time-n-space-1",
                "content": "```\\nfun slowestKey(releaseTimes: IntArray, keysPressed: String): Char {\\n\\tvar maxTime = releaseTimes[0]\\n\\tvar maxChar = keysPressed[0]\\n\\n\\tfor (i in 1 until releaseTimes.size) {\\n\\t\\tval time = releaseTimes[i] - releaseTimes[i - 1]\\n\\t\\tif (time == maxTime) {\\n\\t\\t\\tif (maxChar - keysPressed[i] < 0) {\\n\\t\\t\\t\\tmaxChar = keysPressed[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (time > maxTime) {\\n\\t\\t\\tmaxTime = time\\n\\t\\t\\tmaxChar = keysPressed[i]\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxChar\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun slowestKey(releaseTimes: IntArray, keysPressed: String): Char {\\n\\tvar maxTime = releaseTimes[0]\\n\\tvar maxChar = keysPressed[0]\\n\\n\\tfor (i in 1 until releaseTimes.size) {\\n\\t\\tval time = releaseTimes[i] - releaseTimes[i - 1]\\n\\t\\tif (time == maxTime) {\\n\\t\\t\\tif (maxChar - keysPressed[i] < 0) {\\n\\t\\t\\t\\tmaxChar = keysPressed[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (time > maxTime) {\\n\\t\\t\\tmaxTime = time\\n\\t\\t\\tmaxChar = keysPressed[i]\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxChar\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1448895,
                "title": "c-o-n-iteration",
                "content": "```\\npublic class Solution {\\n    public char SlowestKey(int[] releaseTimes, string keysPressed) {\\n        if(keysPressed.Length==1)\\n            return keysPressed[0];\\n        \\n        char res = \\'a\\';\\n        int max = int.MinValue;\\n        \\n        int startTime = 0;\\n        for(int i =0; i < keysPressed.Length; i++)\\n        {\\n            int pressTime = releaseTimes[i] - startTime;\\n            if(pressTime==max)\\n            {\\n                if(keysPressed[i] > res)\\n                    res = keysPressed[i];\\n            }\\n            else if(pressTime >max)\\n            {\\n                res = keysPressed[i];\\n                max = pressTime;\\n            }\\n            startTime = releaseTimes[i];\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "class Solution {\\n    public char SlowestKey(int[] releaseTimes, string keysPressed) {\\n        if(keysPressed.Length==1)\\n            return keysPressed[0];\\n        \\n        char res = \\'a\\';\\n        int max = int.MinValue;\\n        \\n        int startTime = 0;\\n        for(int i =0; i < keysPressed.Length; i++)\\n        {\\n            int pressTime = releaseTimes[i] - startTime;\\n            if(pressTime==max)\\n            {\\n                if(keysPressed[i] > res)\\n                    res = keysPressed[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1448810,
                "title": "clear-go-solution",
                "content": "```\\nfunc slowestKey(releaseTimes []int, keysPressed string) byte {\\n\\tmax, result := releaseTimes[0], keysPressed[0]\\n\\tfor i := 1; i < len(releaseTimes); i++ {\\n\\t\\tif r, k := releaseTimes[i]-releaseTimes[i-1], keysPressed[i]; r > max || r == max && k > result {\\n\\t\\t\\tmax, result = r, k\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc slowestKey(releaseTimes []int, keysPressed string) byte {\\n\\tmax, result := releaseTimes[0], keysPressed[0]\\n\\tfor i := 1; i < len(releaseTimes); i++ {\\n\\t\\tif r, k := releaseTimes[i]-releaseTimes[i-1], keysPressed[i]; r > max || r == max && k > result {\\n\\t\\t\\tmax, result = r, k\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1448552,
                "title": "simple-problem-simple-solution-o-n-time-o-1-space",
                "content": "The official solution may look haunting but the problem is not that tough.\\nYou just have to find the maximum time difference from releaseTime array and update the answer accordingly.\\n\\n1> If the current difference > previous difference then current char is answer for now\\n2> If the current difference == previous difference then max of previous answer and current char is answer for now\\n<br>\\n```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& rt, string kp) {\\n        \\n        int diff = rt[0], temp;\\n        char ans = kp[0];\\n        \\n        for(int i = 1; i < rt.size(); i++) {\\n            temp = rt[i] - rt[i-1];\\n            if(temp > diff) {\\n                diff = temp;\\n                ans = kp[i];\\n            }\\n            else if(temp == diff) {\\n                ans = max(ans, kp[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& rt, string kp) {\\n        \\n        int diff = rt[0], temp;\\n        char ans = kp[0];\\n        \\n        for(int i = 1; i < rt.size(); i++) {\\n            temp = rt[i] - rt[i-1];\\n            if(temp > diff) {\\n                diff = temp;\\n                ans = kp[i];\\n            }\\n            else if(temp == diff) {\\n                ans = max(ans, kp[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448391,
                "title": "javascript-solution",
                "content": "Step 1. Create keyTimeMap\\nStep 2. Find the maximum releaseTime value\\n\\nLet\\'s take the given input\\n`releaseTimes = [9,29,49,50], keysPressed = \"cbcd\"`\\n\\nIn this case,\\n```\\nkeyTimeMap = { c: 20, b: 20, d: 1 }\\n```\\n\\nHere the step 2 can be done separately, but in that case we will have to go through the keyTimeMap separately. That solves the problem but it will take more time; worst case O(26) more since the problem said \"_keysPressed contains only lowercase English letters._\"\\nThis can be avoided by keeping track of this maximum value and as mentioned in the problem \"_If there are multiple such keypresses, return the lexicographically largest key of the keypresses._\"\\n\\nAny suggestions for improvement are welcome.\\n\\n```\\n/**\\n * @param {number[]} releaseTimes\\n * @param {string} keysPressed\\n * @return {character}\\n */\\nvar slowestKey = function(releaseTimes, keysPressed) {\\n    let keyTimeMap = {};\\n    let prevTime = 0;\\n    let maxVal = releaseTimes[0];\\n    let resultChar = keysPressed[0];\\n    \\n    for (let i = 0; i < releaseTimes.length; i++) {\\n        let currentTime = releaseTimes[i] - prevTime;\\n\\t\\t// Step 1\\n        if (keyTimeMap[keysPressed[i]] === undefined) {\\n            keyTimeMap[keysPressed[i]] = currentTime;\\n        } else {\\n            keyTimeMap[keysPressed[i]] = Math.max(currentTime, keyTimeMap[keysPressed[i]]);\\n        }\\n        \\n\\t\\t// Step 2\\n        maxVal = Math.max(maxVal, currentTime);\\n        if (keyTimeMap[keysPressed[i]] === maxVal) {\\n            if (keyTimeMap[resultChar] === keyTimeMap[keysPressed[i]]) {\\n                resultChar = (resultChar > keysPressed[i]) ? resultChar : keysPressed[i];\\n            } else {\\n                resultChar = keysPressed[i];\\n            }\\n        }\\n        \\n        prevTime = releaseTimes[i];\\n    }    \\n    \\n    return resultChar;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nkeyTimeMap = { c: 20, b: 20, d: 1 }\\n```\n```\\n/**\\n * @param {number[]} releaseTimes\\n * @param {string} keysPressed\\n * @return {character}\\n */\\nvar slowestKey = function(releaseTimes, keysPressed) {\\n    let keyTimeMap = {};\\n    let prevTime = 0;\\n    let maxVal = releaseTimes[0];\\n    let resultChar = keysPressed[0];\\n    \\n    for (let i = 0; i < releaseTimes.length; i++) {\\n        let currentTime = releaseTimes[i] - prevTime;\\n\\t\\t// Step 1\\n        if (keyTimeMap[keysPressed[i]] === undefined) {\\n            keyTimeMap[keysPressed[i]] = currentTime;\\n        } else {\\n            keyTimeMap[keysPressed[i]] = Math.max(currentTime, keyTimeMap[keysPressed[i]]);\\n        }\\n        \\n\\t\\t// Step 2\\n        maxVal = Math.max(maxVal, currentTime);\\n        if (keyTimeMap[keysPressed[i]] === maxVal) {\\n            if (keyTimeMap[resultChar] === keyTimeMap[keysPressed[i]]) {\\n                resultChar = (resultChar > keysPressed[i]) ? resultChar : keysPressed[i];\\n            } else {\\n                resultChar = keysPressed[i];\\n            }\\n        }\\n        \\n        prevTime = releaseTimes[i];\\n    }    \\n    \\n    return resultChar;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1448090,
                "title": "c-solution",
                "content": "```\\n    /* Loop each key that is pressed. For each key pressed, calculate the releasetime\\n     * compare with the previous key release time. Adjust the answer only when the\\n     * release time is greater than or equal to  previous release time and current key\\n     * is greater than the previous key.\\n     */\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        // Check if there are keys or not\\n        if (keysPressed.empty()) {\\n            // There are no keys that are pressed\\n            return 96;\\n        }\\n        \\n        // variables to store the longest releasetime and longest key that is pressed\\n        // As the keys are all lower case letters whose ascii values starts from 97,\\n        // assinging the longest key to starting key.\\n        // Default longest key release time to starting releasing key time.\\n        int time = releaseTimes[0];\\n        char key = keysPressed[0];\\n        \\n        // Holds the current release time\\n        int currTime = 0;\\n        \\n        // Loop all the keys that are pressed\\n        for (int i = 1; i < keysPressed. length(); i++) {\\n            // Evaluate the current time to release the key\\n            currTime = releaseTimes[i] - releaseTimes[i-1];\\n            \\n            // Check whether this is longest duration key that is pressed or not\\n            if ((keysPressed[i] > key && currTime == time) || currTime > time) {\\n                time = currTime;\\n                key = keysPressed[i];\\n            }\\n            currTime = releaseTimes[i];\\n        }\\n        \\n        return key;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /* Loop each key that is pressed. For each key pressed, calculate the releasetime\\n     * compare with the previous key release time. Adjust the answer only when the\\n     * release time is greater than or equal to  previous release time and current key\\n     * is greater than the previous key.\\n     */\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        // Check if there are keys or not\\n        if (keysPressed.empty()) {\\n            // There are no keys that are pressed\\n            return 96;\\n        }\\n        \\n        // variables to store the longest releasetime and longest key that is pressed\\n        // As the keys are all lower case letters whose ascii values starts from 97,\\n        // assinging the longest key to starting key.\\n        // Default longest key release time to starting releasing key time.\\n        int time = releaseTimes[0];\\n        char key = keysPressed[0];\\n        \\n        // Holds the current release time\\n        int currTime = 0;\\n        \\n        // Loop all the keys that are pressed\\n        for (int i = 1; i < keysPressed. length(); i++) {\\n            // Evaluate the current time to release the key\\n            currTime = releaseTimes[i] - releaseTimes[i-1];\\n            \\n            // Check whether this is longest duration key that is pressed or not\\n            if ((keysPressed[i] > key && currTime == time) || currTime > time) {\\n                time = currTime;\\n                key = keysPressed[i];\\n            }\\n            currTime = releaseTimes[i];\\n        }\\n        \\n        return key;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1447964,
                "title": "c-easy-af-well-explained-one-pass",
                "content": "**Please upvote if you like the solution**\\uD83D\\uDE43. Comment for doubts.\\n\\n**Idea**\\n*  The idea is very simple, we just need to return the character at i where the difference **time[i]-time[i-1]** is maximum. \\n*  If there are two characters where the ***mxtime** is same*, we maintain a **mxch** counter that will always be compared every such iteration and at last have the lexicographically greatest character.\\n \\n*  We use the **max()** function in c++ to contain the max character. For those who didn\\'t know it can work as well with characters as we use it in integers. This is because it compares according to the ASCII value of each character, i.e.  **max(\\'c\\',\\'d\\')** will give us \\'d\\' as answer.\\n\\n*Time Complexity : O(N)*\\n*Space Complexity : O(1)*\\n\\n```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& nums, string s) {\\n        char mxch=s[0];\\n        int mxtime=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]==mxtime){\\n                mxch=max(mxch,s[i]);\\n            }\\n            else if(nums[i]-nums[i-1]>mxtime){\\n                mxtime=nums[i]-nums[i-1];\\n                mxch=s[i];\\n            }\\n        }\\n        return mxch;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& nums, string s) {\\n        char mxch=s[0];\\n        int mxtime=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]==mxtime){\\n                mxch=max(mxch,s[i]);\\n            }\\n            else if(nums[i]-nums[i-1]>mxtime){\\n                mxtime=nums[i]-nums[i-1];\\n                mxch=s[i];\\n            }\\n        }\\n        return mxch;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447923,
                "title": "c-simple-solution-explained-100-time-30-space",
                "content": "Nice warmup problem to start the week \\uD83D\\uDC4D \\n\\nThis problem is pretty straightforward - to return the element of an input matching the position of the other one with the largest difference between its current value and the previous, with a similarly straightfoward criterium to resolve draws.\\n\\nTo solve it, we will first of all declare the support variable `res` and set it to `0`.\\n\\nIn our main loop, we will iterate with `i` across the whole length of the input provided (stored in `lmt`) and also get a few other scoped variables while at it:\\n* `prev` and `curr` will store the previous and current value respectively, with the former initialised to `0` as per specs;\\n* `diff` will store the difference of the above;\\n* `maxGap` will store the maximum interval found so far, initialised to be `INT_MIN`.\\n\\nIn the loop we will then:\\n* assign the current values to `curr` and consequently `diff`;\\n* if either `diff` is greater than any other gap we found before or if it is equal the maximum, but matches a character with higher lexicographic value, then:\\n\\t* we updated `res` to be the current character;\\n\\t* update `maxGap` to be `diff`;\\n* update `prev` to be `curr` for the next loop.\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& times, string keys) {\\n        // support variables\\n        char res = 0;\\n        for (int i = 0, lmt = keys.size(), prev = 0, curr, diff, maxGap = INT_MIN; i < lmt; i++) {\\n            curr = times[i], diff = curr - prev;\\n            if (diff > maxGap || diff == maxGap && keys[i] > res) {\\n                res = keys[i];\\n                maxGap = diff;\\n            }\\n            prev = curr;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& times, string keys) {\\n        // support variables\\n        char res = 0;\\n        for (int i = 0, lmt = keys.size(), prev = 0, curr, diff, maxGap = INT_MIN; i < lmt; i++) {\\n            curr = times[i], diff = curr - prev;\\n            if (diff > maxGap || diff == maxGap && keys[i] > res) {\\n                res = keys[i];\\n                maxGap = diff;\\n            }\\n            prev = curr;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447915,
                "title": "python3-memory-less-than-94-faster-than-77-simple-and-straightforward",
                "content": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        max_duration = releaseTimes[0]\\n        max_key = keysPressed[0]\\n        for i in range(1, len(releaseTimes)):\\n            if (releaseTimes[i]-releaseTimes[i-1] > max_duration) or ( releaseTimes[i]-releaseTimes[i-1] == max_duration and keysPressed[i] >= max_key):\\n                max_key = keysPressed[i]\\n                max_duration = releaseTimes[i]-releaseTimes[i-1]\\n        return max_key\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        max_duration = releaseTimes[0]\\n        max_key = keysPressed[0]\\n        for i in range(1, len(releaseTimes)):\\n            if (releaseTimes[i]-releaseTimes[i-1] > max_duration) or ( releaseTimes[i]-releaseTimes[i-1] == max_duration and keysPressed[i] >= max_key):\\n                max_key = keysPressed[i]\\n                max_duration = releaseTimes[i]-releaseTimes[i-1]\\n        return max_key\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447779,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public char slowestKey(int[] r, String k) {\\n        int s=r[0],n=r.length;\\n        char c=k.charAt(0);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(r[i]-r[i-1]>s)\\n            {\\n                s=r[i]-r[i-1];\\n                c=k.charAt(i);\\n            }\\n            else if(r[i]-r[i-1]==s)\\n            {\\n                if(c<k.charAt(i))\\n                    c=k.charAt(i);\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public char slowestKey(int[] r, String k) {\\n        int s=r[0],n=r.length;\\n        char c=k.charAt(0);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(r[i]-r[i-1]>s)\\n            {\\n                s=r[i]-r[i-1];\\n                c=k.charAt(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1447733,
                "title": "c-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int comp = releaseTimes[0]; // first key time\\n        char res = keysPressed[0]; // let first key be the result\\n        for(int i=1; keysPressed[i]; i++) { // iterate from second key to last key\\n            int temp = releaseTimes[i] - releaseTimes[i-1]; // get the time of ith key in temp\\n            if(temp > comp) { // if temp beat the answer so far\\n                comp = temp; // update the answer so far\\n                res = keysPressed[i]; // update res with temp\\'s key\\n            }\\n            if(temp == comp) // if time so far and time of ith key are same than\\n               res = keysPressed[i] > res ? keysPressed[i] : res; // update res lexicographically\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int comp = releaseTimes[0]; // first key time\\n        char res = keysPressed[0]; // let first key be the result\\n        for(int i=1; keysPressed[i]; i++) { // iterate from second key to last key\\n            int temp = releaseTimes[i] - releaseTimes[i-1]; // get the time of ith key in temp\\n            if(temp > comp) { // if temp beat the answer so far\\n                comp = temp; // update the answer so far\\n                res = keysPressed[i]; // update res with temp\\'s key\\n            }\\n            if(temp == comp) // if time so far and time of ith key are same than\\n               res = keysPressed[i] > res ? keysPressed[i] : res; // update res lexicographically\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447725,
                "title": "python-one-line-no-zip-briefly-explained",
                "content": "I use a list interpretation (the \"```[[releaseTimes[0],keysPressed[0]]] + [[releaseTimes[i]-releaseTimes[i-1],keysPressed[i]] for i in range(1, len(releaseTimes))]```\" bit) to measure the duration of each key press.\\n\\nThen I take the \"maximum\", using a customized key that gives most of the weight to the duration of the press, but some to the lexicgraphical ordering of the key, like so:\\n```max( ... ,key=lambda i:100*i[0]+ord(i[1]))```\\n\\nTogether, these give us the list entry that contains the required character. That character is at position [1] within the list entry. Hence, the ```[1]``` at the end.\\n\\nEasy, eh?\\n\\n```\\n#Runtime: 56 ms, faster than 70.22% of Python3 online submissions for Slowest Key.\\n#Memory Usage: 14.4 MB, less than 56.84% of Python3 online submissions for Slowest Key.\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        return max([[releaseTimes[0],keysPressed[0]]] + [[releaseTimes[i]-releaseTimes[i-1],keysPressed[i]] for i in range(1, len(releaseTimes))],key=lambda i:100*i[0]+ord(i[1]))[1];\\n```",
                "solutionTags": [],
                "code": "```[[releaseTimes[0],keysPressed[0]]] + [[releaseTimes[i]-releaseTimes[i-1],keysPressed[i]] for i in range(1, len(releaseTimes))]```\n```max( ... ,key=lambda i:100*i[0]+ord(i[1]))```\n```[1]```\n```\\n#Runtime: 56 ms, faster than 70.22% of Python3 online submissions for Slowest Key.\\n#Memory Usage: 14.4 MB, less than 56.84% of Python3 online submissions for Slowest Key.\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        return max([[releaseTimes[0],keysPressed[0]]] + [[releaseTimes[i]-releaseTimes[i-1],keysPressed[i]] for i in range(1, len(releaseTimes))],key=lambda i:100*i[0]+ord(i[1]))[1];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391400,
                "title": "o-n-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        vector<int> v(26,INT_MIN);\\n        int old = 0,n = releaseTimes.size();\\n        for(int  i = 0 ;i < n;i++)\\n        {\\n            v[keysPressed[i] - \\'a\\'] = max(v[keysPressed[i] - \\'a\\'],abs(old-releaseTimes[i]));\\n            old = releaseTimes[i];\\n        }\\n        int mx = 0,in = 0;\\n        for(int i = v.size()-1 ;i >= 0;i--)\\n        {\\n            if(mx < v[i])\\n            {\\n                mx = v[i];\\n                in = i;\\n            }\\n        }\\n        return in + \\'a\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        vector<int> v(26,INT_MIN);\\n        int old = 0,n = releaseTimes.size();\\n        for(int  i = 0 ;i < n;i++)\\n        {\\n            v[keysPressed[i] - \\'a\\'] = max(v[keysPressed[i] - \\'a\\'],abs(old-releaseTimes[i]));\\n            old = releaseTimes[i];\\n        }\\n        int mx = 0,in = 0;\\n        for(int i = v.size()-1 ;i >= 0;i--)\\n        {\\n            if(mx < v[i])\\n            {\\n                mx = v[i];\\n                in = i;\\n            }\\n        }\\n        return in + \\'a\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276938,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public char SlowestKey(int[] releaseTimes, string keysPressed) {\\n        \\n        int max = releaseTimes[0];\\n        char c = keysPressed[0];\\n        \\n        for(int i=1;i<releaseTimes.Length;i++){\\n            int a = releaseTimes[i] - releaseTimes[i-1];\\n            if(max < a ){\\n                max = a;\\n                c = keysPressed[i];\\n            }\\n            else if (max == a){\\n                if(c - \\'a\\' < keysPressed[i] - \\'a\\'){\\n                    c = keysPressed[i];\\n                }\\n            }\\n        }        \\n        return c; \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public char SlowestKey(int[] releaseTimes, string keysPressed) {\\n        \\n        int max = releaseTimes[0];\\n        char c = keysPressed[0];\\n        \\n        for(int i=1;i<releaseTimes.Length;i++){\\n            int a = releaseTimes[i] - releaseTimes[i-1];\\n            if(max < a ){\\n                max = a;\\n                c = keysPressed[i];\\n            }\\n            else if (max == a){\\n                if(c - \\'a\\' < keysPressed[i] - \\'a\\'){\\n                    c = keysPressed[i];\\n                }\\n            }\\n        }        \\n        return c; \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264094,
                "title": "easy-c-solution-o-n-easy-to-understand-using-map",
                "content": "```\\nchar slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        map<char,int> mp;\\n        for(int i=0;i<keysPressed.size();i++){\\n            if(i==0){\\n                mp[keysPressed[i]] = max(mp[keysPressed[i]],releaseTimes[i]-0);            \\n            }\\n            else{\\n                mp[keysPressed[i]] = max(mp[keysPressed[i]],releaseTimes[i]-releaseTimes[i-1]);\\n            }\\n        }\\n        \\n        char ans;\\n        int maxi = 0;\\n        for(auto i : mp){\\n            if(i.second>=maxi){\\n                maxi = i.second;\\n                ans = i.first;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nchar slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        map<char,int> mp;\\n        for(int i=0;i<keysPressed.size();i++){\\n            if(i==0){\\n                mp[keysPressed[i]] = max(mp[keysPressed[i]],releaseTimes[i]-0);            \\n            }\\n            else{\\n                mp[keysPressed[i]] = max(mp[keysPressed[i]],releaseTimes[i]-releaseTimes[i-1]);\\n            }\\n        }\\n        \\n        char ans;\\n        int maxi = 0;\\n        for(auto i : mp){\\n            if(i.second>=maxi){\\n                maxi = i.second;\\n                ans = i.first;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1256087,
                "title": "python3-simple-solution-beats-99-95-as-of-6th-june-2021",
                "content": "```\\ndef slowestKey(self, times: List[int], keys: str) -> str:\\n        prev=0\\n        result=0\\n        resultKey=\\'\\'\\n        for i in range(len(times)):\\n            diff=times[i]-prev\\n            \\n            if diff>result:\\n                result=diff\\n                resultKey=keys[i]\\n                \\n            elif diff==result:\\n                if resultKey< keys[i]:\\n                    resultKey=keys[i]\\n                    \\n            prev=times[i]\\n            \\n        return resultKey\\n```",
                "solutionTags": [],
                "code": "```\\ndef slowestKey(self, times: List[int], keys: str) -> str:\\n        prev=0\\n        result=0\\n        resultKey=\\'\\'\\n        for i in range(len(times)):\\n            diff=times[i]-prev\\n            \\n            if diff>result:\\n                result=diff\\n                resultKey=keys[i]\\n                \\n            elif diff==result:\\n                if resultKey< keys[i]:\\n                    resultKey=keys[i]\\n                    \\n            prev=times[i]\\n            \\n        return resultKey\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1240974,
                "title": "python-3-o-n-solution",
                "content": "```\\ndef slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n\\tmax_duration = releaseTimes[0]\\n\\tres = keysPressed[0]\\n\\n\\tl = len(keysPressed)\\n\\n\\tfor i in range(1, l):\\n\\t\\td = releaseTimes[i]-releaseTimes[i-1]\\n\\n\\t\\tif d>max_duration:\\n\\t\\t\\tmax_duration = d\\n\\t\\t\\tres = keysPressed[i]\\n\\t\\telif d==max_duration:\\n\\t\\t\\tres = max(res, keysPressed[i])\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n\\tmax_duration = releaseTimes[0]\\n\\tres = keysPressed[0]\\n\\n\\tl = len(keysPressed)\\n\\n\\tfor i in range(1, l):\\n\\t\\td = releaseTimes[i]-releaseTimes[i-1]\\n\\n\\t\\tif d>max_duration:\\n\\t\\t\\tmax_duration = d\\n\\t\\t\\tres = keysPressed[i]\\n\\t\\telif d==max_duration:\\n\\t\\t\\tres = max(res, keysPressed[i])\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1199313,
                "title": "ultra-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& t, string k) {\\n\\n        int time, mx = t[0];\\n        char ans = k[0];\\n        for (int i = 1; i < t.size(); i++)\\n        {\\n            time = t[i] - t[i - 1];\\n            if (time > mx)\\n            {\\n                ans = k[i];\\n                mx = time;\\n            }\\n            else if (time == mx) // If the current time is equal to the maximum, put the greater alphabet in the answer.\\n            {\\n                int n = max(ans - \\'a\\', k[i] - \\'a\\');\\n                ans = n + \\'a\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& t, string k) {\\n\\n        int time, mx = t[0];\\n        char ans = k[0];\\n        for (int i = 1; i < t.size(); i++)\\n        {\\n            time = t[i] - t[i - 1];\\n            if (time > mx)\\n            {\\n                ans = k[i];\\n                mx = time;\\n            }\\n            else if (time == mx) // If the current time is equal to the maximum, put the greater alphabet in the answer.\\n            {\\n                int n = max(ans - \\'a\\', k[i] - \\'a\\');\\n                ans = n + \\'a\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145493,
                "title": "c-easy-with-unordered-multimap",
                "content": "char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        \\n        \\n         unordered_multimap<int,char>m;\\n        \\n        m.insert(make_pair(releaseTimes[0],keysPressed[0]));\\n        for(int i=1;i<releaseTimes.size();i++)\\n        {\\n            int z=releaseTimes[i]-releaseTimes[i-1];\\n         \\n            m.insert(make_pair(z,keysPressed[i]));\\n        }\\n         vector<pair<int,char>> v(m.begin(),m.end());\\n        sort(v.begin(),v.end());\\n        int l=INT_MIN;\\n        char a;\\n        for(auto i:v)\\n        {\\n            if(i.first>=l)\\n            {\\n                l=i.first;\\n                a=i.second;\\n            }\\n            \\n        }\\n        return a;\\n        \\n    }",
                "solutionTags": [],
                "code": "char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        \\n        \\n         unordered_multimap<int,char>m;\\n        \\n        m.insert(make_pair(releaseTimes[0],keysPressed[0]));\\n        for(int i=1;i<releaseTimes.size();i++)\\n        {\\n            int z=releaseTimes[i]-releaseTimes[i-1];\\n         \\n            m.insert(make_pair(z,keysPressed[i]));\\n        }\\n         vector<pair<int,char>> v(m.begin(),m.end());\\n        sort(v.begin(),v.end());\\n        int l=INT_MIN;\\n        char a;\\n        for(auto i:v)\\n        {\\n            if(i.first>=l)\\n            {\\n                l=i.first;\\n                a=i.second;\\n            }\\n            \\n        }\\n        return a;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1139515,
                "title": "python-o-n-solution-with-o-1-space",
                "content": "```\\n    def slowestKey(self, releaseTimes, keysPressed):\\n\\n        prev, max_hold = 0, 0\\n        output = \"\"\\n        for ind, i in enumerate(releaseTimes):\\n            hold = i - prev\\n            if hold >= max_hold:\\n\\t\\t\\t    # lexical precendences incase of a tie\\n                if hold == max_hold:\\n                    output = max(output, keysPressed[ind])\\n                else:    \\n                    max_hold = hold\\n                    output = keysPressed[ind]   \\n            prev = i\\n        return output",
                "solutionTags": [],
                "code": "```\\n    def slowestKey(self, releaseTimes, keysPressed):\\n\\n        prev, max_hold = 0, 0\\n        output = \"\"\\n        for ind, i in enumerate(releaseTimes):\\n            hold = i - prev\\n            if hold >= max_hold:\\n\\t\\t\\t    # lexical precendences incase of a tie\\n                if hold == max_hold:\\n                    output = max(output, keysPressed[ind])\\n                else:    \\n                    max_hold = hold\\n                    output = keysPressed[ind]   \\n            prev = i\\n        return output",
                "codeTag": "Python3"
            },
            {
                "id": 1138056,
                "title": "go-golang-solution",
                "content": "```\\nfunc slowestKey(releaseTimes []int, keysPressed string) byte {\\n    \\n    prev := 0\\n    max := 0\\n    var ans byte\\n    \\n    for i := 0; i < len(keysPressed); i++ {\\n        if releaseTimes[i] - prev > max {\\n            max = releaseTimes[i] - prev\\n            ans = keysPressed[i]\\n        } else if releaseTimes[i] - prev == max {\\n            if ans < keysPressed[i] {\\n                ans = keysPressed[i]\\n            }\\n        }\\n        \\n        prev = releaseTimes[i]\\n    }\\n    \\n    return ans\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc slowestKey(releaseTimes []int, keysPressed string) byte {\\n    \\n    prev := 0\\n    max := 0\\n    var ans byte\\n    \\n    for i := 0; i < len(keysPressed); i++ {\\n        if releaseTimes[i] - prev > max {\\n            max = releaseTimes[i] - prev\\n            ans = keysPressed[i]\\n        } else if releaseTimes[i] - prev == max {\\n            if ans < keysPressed[i] {\\n                ans = keysPressed[i]\\n            }\\n        }\\n        \\n        prev = releaseTimes[i]\\n    }\\n    \\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1136209,
                "title": "2-java-solutions-array-and-map",
                "content": "```\\npublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n\\t\\tint[] count = new int[26];\\n\\t\\tchar[] cc = keysPressed.toCharArray();\\n\\t\\tcount[cc[0] - \\'a\\'] = releaseTimes[0];\\n\\t\\tchar result = 0;\\n\\t\\tint max = releaseTimes[0];\\n\\t\\tfor(int i=1; i<releaseTimes.length; i++) {\\n\\t\\t\\tcount[cc[i] - \\'a\\'] = Math.max(count[cc[i] - \\'a\\'], releaseTimes[i] - releaseTimes[i-1]);\\n\\t\\t\\tmax = Math.max(max, count[cc[i] - \\'a\\']);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(int i=25; i>=0; i--) {\\n\\t\\t\\tif(max == count[i]) {\\n\\t\\t\\t\\tresult = (char) (i + \\'a\\');\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\t\\n```\\t\\n\\tpublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n\\t\\tchar result = 0;\\n        int max = Integer.MIN_VALUE;\\n        Map<Character, Integer> map = new HashMap<>();\\n        char[] cc = keysPressed.toCharArray();\\n        \\n        for(int i=0; i<releaseTimes.length; i++) {\\n            if(i == 0)\\n                map.put(cc[i], releaseTimes[i]);\\n            else {\\n            \\tif(map.containsKey(cc[i])) {\\n            \\t\\tint count = map.get(cc[i]);\\n            \\t\\tif(count > releaseTimes[i] - releaseTimes[i-1])\\n            \\t\\t\\tcontinue;\\n            \\t\\telse\\n            \\t\\t\\tmap.put(cc[i], releaseTimes[i] - releaseTimes[i-1]);\\n            \\t} else {\\n            \\t\\tmap.put(cc[i], releaseTimes[i] - releaseTimes[i-1]);\\n            \\t}\\n            }\\n            \\n            if(map.get(cc[i]) > max) {\\n            \\tresult = cc[i];\\n            \\tmax = map.get(cc[i]);\\n            } else if(map.get(cc[i]) == max) {\\n            \\tif((int) cc[i] < (int) result)\\n                    continue;\\n                else\\n                    result = cc[i];\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n\\t\\tint[] count = new int[26];\\n\\t\\tchar[] cc = keysPressed.toCharArray();\\n\\t\\tcount[cc[0] - \\'a\\'] = releaseTimes[0];\\n\\t\\tchar result = 0;\\n\\t\\tint max = releaseTimes[0];\\n\\t\\tfor(int i=1; i<releaseTimes.length; i++) {\\n\\t\\t\\tcount[cc[i] - \\'a\\'] = Math.max(count[cc[i] - \\'a\\'], releaseTimes[i] - releaseTimes[i-1]);\\n\\t\\t\\tmax = Math.max(max, count[cc[i] - \\'a\\']);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(int i=25; i>=0; i--) {\\n\\t\\t\\tif(max == count[i]) {\\n\\t\\t\\t\\tresult = (char) (i + \\'a\\');\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1135355,
                "title": "c-o-nlogn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        if(releaseTimes.empty()) return \\'.\\';\\n        if(keysPressed.empty()) return \\'.\\';\\n        if(releaseTimes.size() != keysPressed.size()) return \\'.\\';\\n        \\n        // vector of pair to keep track of char and time\\n        int last = 0;\\n        vector<pair<char, int>> data; // key to time\\n        for(int i=0; i<releaseTimes.size(); i++){\\n            int time = releaseTimes[i];\\n            int c = keysPressed[i];\\n            data.push_back(make_pair(c, time - last));\\n            last = time;\\n        }\\n        \\n        // sort data to move max / lex order to front\\n        sort(data.begin(), data.end(), [](pair<char, int>& a, pair<char, int>& b){\\n            if(a.second == b.second) return a.first > b.first;\\n            return a.second > b.second;\\n            ;});\\n        if(!data.empty()) return data.front().first;\\n        return \\'.\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        if(releaseTimes.empty()) return \\'.\\';\\n        if(keysPressed.empty()) return \\'.\\';\\n        if(releaseTimes.size() != keysPressed.size()) return \\'.\\';\\n        \\n        // vector of pair to keep track of char and time\\n        int last = 0;\\n        vector<pair<char, int>> data; // key to time\\n        for(int i=0; i<releaseTimes.size(); i++){\\n            int time = releaseTimes[i];\\n            int c = keysPressed[i];\\n            data.push_back(make_pair(c, time - last));\\n            last = time;\\n        }\\n        \\n        // sort data to move max / lex order to front\\n        sort(data.begin(), data.end(), [](pair<char, int>& a, pair<char, int>& b){\\n            if(a.second == b.second) return a.first > b.first;\\n            return a.second > b.second;\\n            ;});\\n        if(!data.empty()) return data.front().first;\\n        return \\'.\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118618,
                "title": "clean-java-solution",
                "content": "```Java\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        \\n        if(releaseTimes == null || keysPressed == null) throw new NullPointerException();;\\n        \\n        int longestTime = releaseTimes[0];\\n        char ansChar = keysPressed.charAt(0);\\n        \\n        for(int i = 1; i < releaseTimes.length; i++){\\n            \\n            if(releaseTimes[i] - releaseTimes[i-1] > longestTime || \\n              ( releaseTimes[i] - releaseTimes[i-1] == longestTime \\n               && ansChar < keysPressed.charAt(i))){\\n                \\n                ansChar = keysPressed.charAt(i);\\n                longestTime = releaseTimes[i] - releaseTimes[i-1];\\n                \\n            }\\n        }\\n        \\n        return ansChar;\\n    }\\n```",
                "solutionTags": [],
                "code": "```Java\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        \\n        if(releaseTimes == null || keysPressed == null) throw new NullPointerException();;\\n        \\n        int longestTime = releaseTimes[0];\\n        char ansChar = keysPressed.charAt(0);\\n        \\n        for(int i = 1; i < releaseTimes.length; i++){\\n            \\n            if(releaseTimes[i] - releaseTimes[i-1] > longestTime || \\n              ( releaseTimes[i] - releaseTimes[i-1] == longestTime \\n               && ansChar < keysPressed.charAt(i))){\\n                \\n                ansChar = keysPressed.charAt(i);\\n                longestTime = releaseTimes[i] - releaseTimes[i-1];\\n                \\n            }\\n        }\\n        \\n        return ansChar;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1117753,
                "title": "java-faster-then-100",
                "content": "\\tclass Solution {\\n\\t\\tpublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n\\t\\t\\tint max = releaseTimes[0];\\n\\t\\t\\tchar key = keysPressed.charAt(0);\\n\\n\\t\\t\\tfor(int i = 1; i < releaseTimes.length; i++){\\n\\t\\t\\t\\tint current = releaseTimes[i] - releaseTimes[i-1];\\n\\t\\t\\t\\tif(max < current){\\n\\t\\t\\t\\t\\tmax = current;\\n\\t\\t\\t\\t\\tkey = keysPressed.charAt(i);  \\n\\t\\t\\t\\t}else if(max == current){\\n\\t\\t\\t\\t\\tkey = key > keysPressed.charAt(i) ? key : keysPressed.charAt(i);\\n\\t\\t\\t\\t}  \\n\\t\\t\\t}\\n\\t\\t\\treturn key;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n\\t\\t\\tint max = releaseTimes[0];\\n\\t\\t\\tchar key = keysPressed.charAt(0);\\n\\n\\t\\t\\tfor(int i = 1; i < releaseTimes.length; i++){\\n\\t\\t\\t\\tint current = releaseTimes[i] - releaseTimes[i-1];\\n\\t\\t\\t\\tif(max < current){\\n\\t\\t\\t\\t\\tmax = current;\\n\\t\\t\\t\\t\\tkey = keysPressed.charAt(i);  \\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1102146,
                "title": "javascript-python",
                "content": "```\\nconst slowestKey = (releaseTimes, keysPressed) => {\\n    let maxDiff = releaseTimes[0]\\n    let idx = 0\\n    for(let i = 1; i < keysPressed.length; i++) {\\n        const current = releaseTimes[i] - releaseTimes[i - 1]\\n        if (current > maxDiff) {\\n            maxDiff = current\\n            idx = i\\n        } else if (maxDiff === current) {\\n            idx = keysPressed.charCodeAt(idx) < keysPressed.charCodeAt(i) ? i : idx\\n        }\\n    }\\n    return keysPressed[idx]  \\n};\\n```\\n\\n```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        max_diff = releaseTimes[0]\\n        char = keysPressed[0]\\n        \\n        for i in range(1, len(keysPressed)):\\n            current = releaseTimes[i] - releaseTimes[i - 1]\\n            c = keysPressed[i]\\n            if current > max_diff:\\n                max_diff = current\\n                char = c\\n            elif current == max_diff:\\n                char = c if ord(c) > ord(char) else char\\n        return char\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nconst slowestKey = (releaseTimes, keysPressed) => {\\n    let maxDiff = releaseTimes[0]\\n    let idx = 0\\n    for(let i = 1; i < keysPressed.length; i++) {\\n        const current = releaseTimes[i] - releaseTimes[i - 1]\\n        if (current > maxDiff) {\\n            maxDiff = current\\n            idx = i\\n        } else if (maxDiff === current) {\\n            idx = keysPressed.charCodeAt(idx) < keysPressed.charCodeAt(i) ? i : idx\\n        }\\n    }\\n    return keysPressed[idx]  \\n};\\n```\n```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        max_diff = releaseTimes[0]\\n        char = keysPressed[0]\\n        \\n        for i in range(1, len(keysPressed)):\\n            current = releaseTimes[i] - releaseTimes[i - 1]\\n            c = keysPressed[i]\\n            if current > max_diff:\\n                max_diff = current\\n                char = c\\n            elif current == max_diff:\\n                char = c if ord(c) > ord(char) else char\\n        return char\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099764,
                "title": "python3-simple-solution-beats-90-users",
                "content": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        x = {releaseTimes[0] : keysPressed[0]}\\n        for i in range(1,len(releaseTimes)):\\n            a = releaseTimes[i] - releaseTimes[i-1]\\n            if a in x:\\n                if x[a] < keysPressed[i]:\\n                    x[a] = keysPressed[i]\\n            else:\\n                x[a] = keysPressed[i]\\n        return x[max(x.keys())]\\n```\\n**If you like the solution, please vote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        x = {releaseTimes[0] : keysPressed[0]}\\n        for i in range(1,len(releaseTimes)):\\n            a = releaseTimes[i] - releaseTimes[i-1]\\n            if a in x:\\n                if x[a] < keysPressed[i]:\\n                    x[a] = keysPressed[i]\\n            else:\\n                x[a] = keysPressed[i]\\n        return x[max(x.keys())]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1094191,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        char ans = keysPressed.charAt(0);\\n        int max = releaseTimes[0];\\n        for(int i = 1; i < releaseTimes.length; i++){\\n            char c = keysPressed.charAt(i);\\n            int currtime = releaseTimes[i] - releaseTimes[i-1];\\n            if(currtime > max){\\n                    max = currtime;\\n                    ans = c;\\n                }\\n            else if(currtime == max){\\n                ans = ans > c ? ans : c;\\n            }\\n        }\\n        return ans;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        char ans = keysPressed.charAt(0);\\n        int max = releaseTimes[0];\\n        for(int i = 1; i < releaseTimes.length; i++){\\n            char c = keysPressed.charAt(i);\\n            int currtime = releaseTimes[i] - releaseTimes[i-1];\\n            if(currtime > max){\\n                    max = currtime;\\n                    ans = c;\\n                }\\n            else if(currtime == max){\\n                ans = ans > c ? ans : c;\\n            }\\n        }\\n        return ans;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064433,
                "title": "solution-in-java",
                "content": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int maxDiff=releaseTimes[0];\\n        char c=keysPressed.charAt(0);\\n        \\n        for(int i=1;i<releaseTimes.length;i++){\\n            if(releaseTimes[i]-releaseTimes[i-1]>maxDiff){\\n                maxDiff=releaseTimes[i]-releaseTimes[i-1];\\n                c=keysPressed.charAt(i);\\n            }\\n            else{\\n                if(releaseTimes[i]-releaseTimes[i-1]==maxDiff)\\n                    c=(c>keysPressed.charAt(i))?c:keysPressed.charAt(i);\\n            }\\n        }\\n        \\n        return c;\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int maxDiff=releaseTimes[0];\\n        char c=keysPressed.charAt(0);\\n        \\n        for(int i=1;i<releaseTimes.length;i++){\\n            if(releaseTimes[i]-releaseTimes[i-1]>maxDiff){\\n                maxDiff=releaseTimes[i]-releaseTimes[i-1];\\n                c=keysPressed.charAt(i);\\n            }\\n            else{\\n                if(releaseTimes[i]-releaseTimes[i-1]==maxDiff)\\n                    c=(c>keysPressed.charAt(i))?c:keysPressed.charAt(i);\\n            }\\n        }\\n        \\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061316,
                "title": "java-o-n-solution",
                "content": "```\\npublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n\\t\\tint[] count = new int[26];\\n        int max = releaseTimes[0];\\n        count[keysPressed.charAt(0) - \\'a\\'] = releaseTimes[0];\\n\\t\\t\\n\\t\\t//for every character get the max time and record the max time\\n        for(int i = 1; i < keysPressed.length(); i++){\\n            char c = keysPressed.charAt(i);\\n            count[c - \\'a\\'] = Math.max(count[c - \\'a\\'], releaseTimes[i] - releaseTimes[i-1]);\\n            max = Math.max(max,count[c - \\'a\\']);\\n        }\\n        \\n\\t\\t//traverse in reverse to get the lexicographically bigger character with max time\\n\\t\\tchar res = keysPressed.charAt(0) ;\\n        for(int j = 25; j>=0; j--)\\n            if(count[j] == max){\\n \\t\\t\\t\\tres = (char)(j +\\'a\\');\\n                break;\\n            } \\n\\t\\t\\t\\t\\n        return res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n\\t\\tint[] count = new int[26];\\n        int max = releaseTimes[0];\\n        count[keysPressed.charAt(0) - \\'a\\'] = releaseTimes[0];\\n\\t\\t\\n\\t\\t//for every character get the max time and record the max time\\n        for(int i = 1; i < keysPressed.length(); i++){\\n            char c = keysPressed.charAt(i);\\n            count[c - \\'a\\'] = Math.max(count[c - \\'a\\'], releaseTimes[i] - releaseTimes[i-1]);\\n            max = Math.max(max,count[c - \\'a\\']);\\n        }\\n        \\n\\t\\t//traverse in reverse to get the lexicographically bigger character with max time\\n\\t\\tchar res = keysPressed.charAt(0) ;\\n        for(int j = 25; j>=0; j--)\\n            if(count[j] == max){\\n \\t\\t\\t\\tres = (char)(j +\\'a\\');\\n                break;\\n            } \\n\\t\\t\\t\\t\\n        return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1041563,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        duration  = []\\n        maxes = []\\n        for i in range(len(releaseTimes)):\\n            if i == 0:\\n                duration.append(releaseTimes[0])\\n            else:\\n                duration.append(releaseTimes[i] - releaseTimes[i-1])\\n                \\n        m = max(duration)\\n        \\n        for i in range(len(duration)):\\n            if duration[i] == m:\\n                maxes.append(keysPressed[i])\\n                \\n        return max(maxes)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        duration  = []\\n        maxes = []\\n        for i in range(len(releaseTimes)):\\n            if i == 0:\\n                duration.append(releaseTimes[0])\\n            else:\\n                duration.append(releaseTimes[i] - releaseTimes[i-1])\\n                \\n        m = max(duration)\\n        \\n        for i in range(len(duration)):\\n            if duration[i] == m:\\n                maxes.append(keysPressed[i])\\n                \\n        return max(maxes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037200,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def slowestKey(self, releaseTimes, keysPressed):\\n        arr=releaseTimes\\n        s=keysPressed\\n        d={}\\n        intl=0\\n        for i in range(len(arr)):\\n            diff=abs(arr[i]-intl)\\n            if s[i] not in d:\\n                d[s[i]]=diff\\n            else:\\n                d[s[i]]=max(diff, d[s[i]])\\n            intl=arr[i]\\n        m=max(d.values())\\n        l=[]\\n        for i in d:\\n            if d[i]==m:\\n                l.append(i)\\n        l.sort()\\n        return l[-1]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def slowestKey(self, releaseTimes, keysPressed):\\n        arr=releaseTimes\\n        s=keysPressed\\n        d={}\\n        intl=0\\n        for i in range(len(arr)):\\n            diff=abs(arr[i]-intl)\\n            if s[i] not in d:\\n                d[s[i]]=diff\\n            else:\\n                d[s[i]]=max(diff, d[s[i]])\\n            intl=arr[i]\\n        m=max(d.values())\\n        l=[]\\n        for i in d:\\n            if d[i]==m:\\n                l.append(i)\\n        l.sort()\\n        return l[-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 981554,
                "title": "java-solution-with-priorityqueue-o-n-log-n",
                "content": "**TimeComplexity : O(n log n)\\nSpaceCompexity : O(n)**\\n\\nThis is O(n log n), not fast. I just wanted to share this solution with priorityQueue.\\n```\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> (a[1] == b[1]) ? b[0] - a[0] : b[1] - a[1]); // because of \\'lexicographically sorting\\'\\n        for (int i = 0; i < releaseTimes.length; i++) { // just one pass -> O(n)\\n            int releaseTime = (i == 0) ? releaseTimes[0] : releaseTimes[i] - releaseTimes[i - 1];\\n            maxHeap.add(new int[] {keysPressed.charAt(i) - \\'a\\', releaseTime}); // insertion in priorityQueue complexity -> O(log n)\\n        }\\n        \\n        return (char) (maxHeap.peek()[0] + \\'a\\');\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> (a[1] == b[1]) ? b[0] - a[0] : b[1] - a[1]); // because of \\'lexicographically sorting\\'\\n        for (int i = 0; i < releaseTimes.length; i++) { // just one pass -> O(n)\\n            int releaseTime = (i == 0) ? releaseTimes[0] : releaseTimes[i] - releaseTimes[i - 1];\\n            maxHeap.add(new int[] {keysPressed.charAt(i) - \\'a\\', releaseTime}); // insertion in priorityQueue complexity -> O(log n)\\n        }\\n        \\n        return (char) (maxHeap.peek()[0] + \\'a\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 937120,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        char slowestKey = keysPressed.charAt(0);\\n        int slowestKeyDuration = releaseTimes[0];        \\n        \\n        for(int i = 1 ; i < keysPressed.length() ; i++) {\\n            char c = keysPressed.charAt(i);\\n            int duration = releaseTimes[i] - releaseTimes[i - 1];\\n            if (duration > slowestKeyDuration \\n                || (duration == slowestKeyDuration && c > slowestKey)) {\\n                slowestKey = c;\\n                slowestKeyDuration = duration;\\n            }\\n        }\\n        return slowestKey;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        char slowestKey = keysPressed.charAt(0);\\n        int slowestKeyDuration = releaseTimes[0];        \\n        \\n        for(int i = 1 ; i < keysPressed.length() ; i++) {\\n            char c = keysPressed.charAt(i);\\n            int duration = releaseTimes[i] - releaseTimes[i - 1];\\n            if (duration > slowestKeyDuration \\n                || (duration == slowestKeyDuration && c > slowestKey)) {\\n                slowestKey = c;\\n                slowestKeyDuration = duration;\\n            }\\n        }\\n        return slowestKey;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931008,
                "title": "faster-than-92-57-javascript-easy",
                "content": "```\\nvar slowestKey = function(releaseTimes, keysPressed) {\\n    var letters = \"abcdefghijklmnopqrstuvwxyz\";\\n    var max = releaseTimes[0];\\n    var ind = 0;\\n    for(let i = 1; i < keysPressed.length; i++) {\\n        if(releaseTimes[i] - releaseTimes[i-1] > max) {\\n            max = releaseTimes[i] - releaseTimes[i-1];\\n            ind = i;\\n        }\\n        if(releaseTimes[i] - releaseTimes[i-1] == max) {\\n            var k1 = letters.indexOf(keysPressed[i]);\\n            var k2 = letters.indexOf(keysPressed[ind]);\\n            if(k1 > k2) {\\n                ind = i;\\n            }\\n        }\\n    }\\n    return keysPressed[ind];\\n};",
                "solutionTags": [],
                "code": "```\\nvar slowestKey = function(releaseTimes, keysPressed) {\\n    var letters = \"abcdefghijklmnopqrstuvwxyz\";\\n    var max = releaseTimes[0];\\n    var ind = 0;\\n    for(let i = 1; i < keysPressed.length; i++) {\\n        if(releaseTimes[i] - releaseTimes[i-1] > max) {\\n            max = releaseTimes[i] - releaseTimes[i-1];\\n            ind = i;\\n        }\\n        if(releaseTimes[i] - releaseTimes[i-1] == max) {\\n            var k1 = letters.indexOf(keysPressed[i]);\\n            var k2 = letters.indexOf(keysPressed[ind]);\\n            if(k1 > k2) {\\n                ind = i;\\n            }\\n        }\\n    }\\n    return keysPressed[ind];\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 928460,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int maxIndex = 0;\\n        int max = releaseTimes[0];        \\n        for (int i = 1; i < releaseTimes.length; ++i) {\\n            int duration = releaseTimes[i] - releaseTimes[i - 1];            \\n            if (duration > max || duration == max && keysPressed.charAt(i) > keysPressed.charAt(maxIndex)) { \\n                max = duration;\\n                maxIndex = i;\\n            }\\n        }\\n        return keysPressed.charAt(maxIndex);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int maxIndex = 0;\\n        int max = releaseTimes[0];        \\n        for (int i = 1; i < releaseTimes.length; ++i) {\\n            int duration = releaseTimes[i] - releaseTimes[i - 1];            \\n            if (duration > max || duration == max && keysPressed.charAt(i) > keysPressed.charAt(maxIndex)) { \\n                max = duration;\\n                maxIndex = i;\\n            }\\n        }\\n        return keysPressed.charAt(maxIndex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924637,
                "title": "readable-python-o-n-no-zip-counter",
                "content": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        maxTime = float(\"-inf\")\\n        maxChar = \"\"\\n        for i in range(len(keysPressed)):\\n\\t\\t\\t# the first one is alwasys the specified release time\\n            if i==0:\\n                time = releaseTimes[i]\\n\\t\\t\\t# everything after requires a difference in times\\n\\t\\t\\t# releasedTimes[i+1] >= releasedTimes[i]\\n            else:\\n                time = releaseTimes[i] - releaseTimes[i-1]\\n\\t\\t\\t\\n            if time > maxTime:\\n                maxTime = time\\n                maxChar = keysPressed[i]\\n\\t\\t\\t# comparing chars, operators allow for lexicographical comparison\\n            elif time == maxTime and maxChar < keysPressed[i]:\\n                maxChar = keysPressed[i]\\n\\t\\t\\t\\t\\n\\t\\t# time complexity : O(N) where N=len(keys)=len(releasedTimes)\\n\\t\\t# space complexity: O(1)\\n        return maxChar\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        maxTime = float(\"-inf\")\\n        maxChar = \"\"\\n        for i in range(len(keysPressed)):\\n\\t\\t\\t# the first one is alwasys the specified release time\\n            if i==0:\\n                time = releaseTimes[i]\\n\\t\\t\\t# everything after requires a difference in times\\n\\t\\t\\t# releasedTimes[i+1] >= releasedTimes[i]\\n            else:\\n                time = releaseTimes[i] - releaseTimes[i-1]\\n\\t\\t\\t\\n            if time > maxTime:\\n                maxTime = time\\n                maxChar = keysPressed[i]\\n\\t\\t\\t# comparing chars, operators allow for lexicographical comparison\\n            elif time == maxTime and maxChar < keysPressed[i]:\\n                maxChar = keysPressed[i]\\n\\t\\t\\t\\t\\n\\t\\t# time complexity : O(N) where N=len(keys)=len(releasedTimes)\\n\\t\\t# space complexity: O(1)\\n        return maxChar\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922635,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def slowestKey(self, releaseTimes, keysPressed):\\n        \"\"\"\\n        :type releaseTimes: List[int]\\n        :type keysPressed: str\\n        :rtype: str\\n        \"\"\"\\n        # p_time = previous time num in the list\\n        # h_difference = highest difference -> (difference, letter)\\n        p_time, h_difference = 0, [0,0]\\n        \\n        for idx in range(len(releaseTimes)):\\n            \\n            #c_time = current time\\n            c_time = releaseTimes[idx]\\n            # diff = difference\\n            diff = c_time - p_time\\n            \\n            if diff == h_difference[0]:\\n                if keysPressed[idx] > h_difference[1]:\\n                    h_difference = [diff, keysPressed[idx]]\\n            \\n            elif diff > h_difference[0]:\\n                h_difference[0] = diff\\n                h_difference[1] = keysPressed[idx]\\n                \\n            p_time = c_time\\n            \\n        return h_difference[1]\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def slowestKey(self, releaseTimes, keysPressed):\\n        \"\"\"\\n        :type releaseTimes: List[int]\\n        :type keysPressed: str\\n        :rtype: str\\n        \"\"\"\\n        # p_time = previous time num in the list\\n        # h_difference = highest difference -> (difference, letter)\\n        p_time, h_difference = 0, [0,0]\\n        \\n        for idx in range(len(releaseTimes)):\\n            \\n            #c_time = current time\\n            c_time = releaseTimes[idx]\\n            # diff = difference\\n            diff = c_time - p_time\\n            \\n            if diff == h_difference[0]:\\n                if keysPressed[idx] > h_difference[1]:\\n                    h_difference = [diff, keysPressed[idx]]\\n            \\n            elif diff > h_difference[0]:\\n                h_difference[0] = diff\\n                h_difference[1] = keysPressed[idx]\\n                \\n            p_time = c_time\\n            \\n        return h_difference[1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 916220,
                "title": "python-one-line-one-pass",
                "content": "```python\\ndef slowestKey(self, t: List[int], k: str) -> str:\\n    return max((t[i] - (t[i-1] if i else 0), k[i]) for i in range(len(k)))[1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef slowestKey(self, t: List[int], k: str) -> str:\\n    return max((t[i] - (t[i-1] if i else 0), k[i]) for i in range(len(k)))[1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 914608,
                "title": "java-100-o-n-time",
                "content": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int maxDiff = releaseTimes[0];\\n        char result = keysPressed.charAt(0);\\n        for (int i = 1; i < releaseTimes.length; i++) {\\n            int diff = releaseTimes[i] - releaseTimes[i-1];\\n            if (diff >= maxDiff) {\\n                char currChar = keysPressed.charAt(i);\\n                if (diff > maxDiff || currChar > result) {\\n                    result = currChar;\\n                }\\n                maxDiff = diff;\\n            }\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int maxDiff = releaseTimes[0];\\n        char result = keysPressed.charAt(0);\\n        for (int i = 1; i < releaseTimes.length; i++) {\\n            int diff = releaseTimes[i] - releaseTimes[i-1];\\n            if (diff >= maxDiff) {\\n                char currChar = keysPressed.charAt(i);\\n                if (diff > maxDiff || currChar > result) {\\n                    result = currChar;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 911360,
                "title": "python-3-solution",
                "content": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes, keysPressed: str) -> str:\\n        \"\"\"\\n        Given an array of key release times (releaseTimes) and\\n        a sequence of keys pressed, this program returns the\\n        key with the longest duration. If multiple keys have\\n        the same longest duration, the program returns the highest\\n        key lexigraphically.\\n\\n        :param releaseTimes: array of key release times\\n        :type releaseTimes: list[int]\\n        :param keysPressed: sequence of keys pressed\\n        :type keysPressed: str\\n        :return: highest lexigraphically slowest key\\n        :rtype: str\\n        \"\"\"\\n        length = len(keysPressed)\\n        slowest_key = [releaseTimes[0], keysPressed[0]]\\n        for k in range(1, length):\\n            duration = releaseTimes[k] - releaseTimes[k - 1]\\n            if duration >= slowest_key[0]:\\n                slowest_key = max(slowest_key, [duration, keysPressed[k]])\\n        return slowest_key[1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes, keysPressed: str) -> str:\\n        \"\"\"\\n        Given an array of key release times (releaseTimes) and\\n        a sequence of keys pressed, this program returns the\\n        key with the longest duration. If multiple keys have\\n        the same longest duration, the program returns the highest\\n        key lexigraphically.\\n\\n        :param releaseTimes: array of key release times\\n        :type releaseTimes: list[int]\\n        :param keysPressed: sequence of keys pressed\\n        :type keysPressed: str\\n        :return: highest lexigraphically slowest key\\n        :rtype: str\\n        \"\"\"\\n        length = len(keysPressed)\\n        slowest_key = [releaseTimes[0], keysPressed[0]]\\n        for k in range(1, length):\\n            duration = releaseTimes[k] - releaseTimes[k - 1]\\n            if duration >= slowest_key[0]:\\n                slowest_key = max(slowest_key, [duration, keysPressed[k]])\\n        return slowest_key[1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910183,
                "title": "c-o-n-for-loop-solution",
                "content": "Check two condition in the for loop:\\n1. If duration is the same as max duration, we check lexicographically largest key.\\n2. if duration is larger, we update the max duration and the character.\\n\\nComplexity:\\nRuntime: O(n), Space O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int maxDur = releaseTimes[0];\\n        char res = keysPressed[0];\\n        \\n        for (int i = 1; i < releaseTimes.size(); ++i) {\\n            int diff =  releaseTimes[i] - releaseTimes[i-1];\\n            if (diff == maxDur && keysPressed[i] > res)  {\\n                res = keysPressed[i];\\n            } else if (diff > maxDur) {\\n                res = keysPressed[i];\\n                maxDur = diff;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int maxDur = releaseTimes[0];\\n        char res = keysPressed[0];\\n        \\n        for (int i = 1; i < releaseTimes.size(); ++i) {\\n            int diff =  releaseTimes[i] - releaseTimes[i-1];\\n            if (diff == maxDur && keysPressed[i] > res)  {\\n                res = keysPressed[i];\\n            } else if (diff > maxDur) {\\n                res = keysPressed[i];\\n                maxDur = diff;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909815,
                "title": "kt-js-py3-cpp-best-time",
                "content": "**Synopsis:**\\n\\nPerform a linear scan of the input times `A` and `keys` to return the `key` of the `best` `time`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun slowestKey(A: IntArray, keys: String): Char {\\n        var best = 0\\n        var ans = \\'0\\'\\n        keys.forEachIndexed { i, key ->\\n            var time = if (0 < i) A[i] - A[i - 1] else A[i]\\n            if (best < time || (best == time && ans < key)) {\\n                best = time\\n                ans = key\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet slowestKey = (A, keys, best = 0, ans = \\'0\\') => {\\n    keys.split(\\'\\').forEach((key, i) => {\\n        let time = 0 < i ? A[i] - A[i - 1] : A[i];\\n        if (best < time || (best == time && ans.localeCompare(key) < 0))\\n            best = time,\\n            ans = key;\\n    });\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def slowestKey(self, A: List[int], keys: str, best = 0, ans = \\'0\\') -> str:\\n        for i, key in enumerate(keys):\\n            time = A[i] - A[i - 1] if 0 < i else A[i]\\n            if best < time or (best == time and ans < key):\\n                best = time\\n                ans = key\\n        return ans\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    char slowestKey(VI& A, string keys, int best = 0, char ans = \\'0\\') {\\n        for (auto i{ 0 }; i < A.size(); ++i) {\\n            auto time = 0 < i ? A[i] - A[i - 1] : A[i];\\n            auto key = keys[i];\\n            if (best < time || (best == time && ans < key))\\n                best = time,\\n                ans = key;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun slowestKey(A: IntArray, keys: String): Char {\\n        var best = 0\\n        var ans = \\'0\\'\\n        keys.forEachIndexed { i, key ->\\n            var time = if (0 < i) A[i] - A[i - 1] else A[i]\\n            if (best < time || (best == time && ans < key)) {\\n                best = time\\n                ans = key\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```\n```\\nlet slowestKey = (A, keys, best = 0, ans = \\'0\\') => {\\n    keys.split(\\'\\').forEach((key, i) => {\\n        let time = 0 < i ? A[i] - A[i - 1] : A[i];\\n        if (best < time || (best == time && ans.localeCompare(key) < 0))\\n            best = time,\\n            ans = key;\\n    });\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def slowestKey(self, A: List[int], keys: str, best = 0, ans = \\'0\\') -> str:\\n        for i, key in enumerate(keys):\\n            time = A[i] - A[i - 1] if 0 < i else A[i]\\n            if best < time or (best == time and ans < key):\\n                best = time\\n                ans = key\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    char slowestKey(VI& A, string keys, int best = 0, char ans = \\'0\\') {\\n        for (auto i{ 0 }; i < A.size(); ++i) {\\n            auto time = 0 < i ? A[i] - A[i - 1] : A[i];\\n            auto key = keys[i];\\n            if (best < time || (best == time && ans < key))\\n                best = time,\\n                ans = key;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909751,
                "title": "c-solution",
                "content": "```\\nchar slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n\\tpair<int, int> maxKeyTime;\\n\\tmaxKeyTime.first=keysPressed[0];\\n\\tmaxKeyTime.second=releaseTimes[0];\\n\\tfor(int i=1; i<releaseTimes.size(); ++i){\\n\\t\\tint curr_key = keysPressed[i];\\n\\t\\tint curr_time = releaseTimes[i]-releaseTimes[i-1];\\n\\t\\tif(curr_time==maxKeyTime.second){\\n\\t\\t\\tif(curr_key>maxKeyTime.first)\\n\\t\\t\\t\\tmaxKeyTime.first = curr_key;\\n\\t\\t}\\n\\t\\tif(curr_time>maxKeyTime.second){\\n\\t\\t\\tmaxKeyTime.first=curr_key;\\n\\t\\t\\tmaxKeyTime.second=curr_time;\\n\\t\\t}\\n\\t}\\n\\treturn maxKeyTime.first;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n\\tpair<int, int> maxKeyTime;\\n\\tmaxKeyTime.first=keysPressed[0];\\n\\tmaxKeyTime.second=releaseTimes[0];\\n\\tfor(int i=1; i<releaseTimes.size(); ++i){\\n\\t\\tint curr_key = keysPressed[i];\\n\\t\\tint curr_time = releaseTimes[i]-releaseTimes[i-1];\\n\\t\\tif(curr_time==maxKeyTime.second){\\n\\t\\t\\tif(curr_key>maxKeyTime.first)\\n\\t\\t\\t\\tmaxKeyTime.first = curr_key;\\n\\t\\t}\\n\\t\\tif(curr_time>maxKeyTime.second){\\n\\t\\t\\tmaxKeyTime.first=curr_key;\\n\\t\\t\\tmaxKeyTime.second=curr_time;\\n\\t\\t}\\n\\t}\\n\\treturn maxKeyTime.first;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 909724,
                "title": "simple-python-solution-easy-to-understand",
                "content": "```python\\n        max_t = releaseTimes[0]\\n        key = keysPressed[0]\\n        for i in range(1, len(keysPressed)):\\n            time = releaseTimes[i] - releaseTimes[i-1]\\n            if time > max_t:\\n                max_t = time\\n                key = keysPressed[i]\\n            elif time == max_t and keysPressed[i] > key:\\n                max_t = time\\n                key = keysPressed[i]\\n        \\n        return key\\n```",
                "solutionTags": [],
                "code": "```python\\n        max_t = releaseTimes[0]\\n        key = keysPressed[0]\\n        for i in range(1, len(keysPressed)):\\n            time = releaseTimes[i] - releaseTimes[i-1]\\n            if time > max_t:\\n                max_t = time\\n                key = keysPressed[i]\\n            elif time == max_t and keysPressed[i] > key:\\n                max_t = time\\n                key = keysPressed[i]\\n        \\n        return key\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 909715,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int n = releaseTimes.length;\\n        int max = releaseTimes[0], index = 0;\\n        for (int i = 1; i < n; ++i) {\\n            int d = releaseTimes[i] - releaseTimes[i - 1];\\n            if (max < d) {\\n                max = d;\\n                index = i;\\n            }\\n            else if (max == d) {\\n                if (keysPressed.charAt(i) > keysPressed.charAt(index)) {\\n                    index = i;\\n                }\\n            }\\n        }\\n        \\n        return keysPressed.charAt(index);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int n = releaseTimes.length;\\n        int max = releaseTimes[0], index = 0;\\n        for (int i = 1; i < n; ++i) {\\n            int d = releaseTimes[i] - releaseTimes[i - 1];\\n            if (max < d) {\\n                max = d;\\n                index = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 909683,
                "title": "python3-self-explanatory-solution",
                "content": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        prev = max_dur = 0\\n        result= \\'a\\'\\n        for dur, key in zip(releaseTimes, keysPressed):\\n            curr_dur = dur - prev\\n            if curr_dur > max_dur:\\n                result = key\\n                max_dur = curr_dur\\n            elif curr_dur == max_dur:\\n                result = max(result, key)\\n            prev = dur\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        prev = max_dur = 0\\n        result= \\'a\\'\\n        for dur, key in zip(releaseTimes, keysPressed):\\n            curr_dur = dur - prev\\n            if curr_dur > max_dur:\\n                result = key\\n                max_dur = curr_dur\\n            elif curr_dur == max_dur:\\n                result = max(result, key)\\n            prev = dur\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909659,
                "title": "c-o-n-simple-solution",
                "content": "C++ \\nTime complexity: O(n)\\nSpace complexity: O(1)\\nRunTime: 8ms(100% faster)\\n```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        char res=keysPressed[0];\\n        int maxval=releaseTimes[0], tmp;\\n        \\n        for(int i=1; i<releaseTimes.size(); ++i)\\n        {\\n            tmp=releaseTimes[i]-releaseTimes[i-1];\\n            if(tmp>maxval)\\n            {\\n                maxval=tmp;\\n                res=keysPressed[i];\\n            }\\n            else if(tmp == maxval)\\n                res=max(res, keysPressed[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        char res=keysPressed[0];\\n        int maxval=releaseTimes[0], tmp;\\n        \\n        for(int i=1; i<releaseTimes.size(); ++i)\\n        {\\n            tmp=releaseTimes[i]-releaseTimes[i-1];\\n            if(tmp>maxval)\\n            {\\n                maxval=tmp;\\n                res=keysPressed[i];\\n            }\\n            else if(tmp == maxval)\\n                res=max(res, keysPressed[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909639,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func slowestKey(_ releaseTimes: [Int], _ keysPressed: String) -> Character {\\n        let keysPressed = Array(keysPressed), c = keysPressed.count\\n        var slowKey = Character(\"?\"), slowTime = Int.min, lastTime = 0\\n        for i in 0..<c {\\n            let time = releaseTimes[i] - lastTime\\n            lastTime = releaseTimes[i]\\n            if time > slowTime || time == slowTime && keysPressed[i] > slowKey {\\n                slowTime = time\\n                slowKey = keysPressed[i]\\n            }\\n        }\\n        return slowKey\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func slowestKey(_ releaseTimes: [Int], _ keysPressed: String) -> Character {\\n        let keysPressed = Array(keysPressed), c = keysPressed.count\\n        var slowKey = Character(\"?\"), slowTime = Int.min, lastTime = 0\\n        for i in 0..<c {\\n            let time = releaseTimes[i] - lastTime\\n            lastTime = releaseTimes[i]\\n            if time > slowTime || time == slowTime && keysPressed[i] > slowKey {\\n                slowTime = time\\n                slowKey = keysPressed[i]\\n            }\\n        }\\n        return slowKey\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909535,
                "title": "rust-0ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn slowest_key(release_times: Vec<i32>, keys_pressed: String) -> char {\\n        let mut pre = 0;\\n        let mut ans = \\' \\';\\n        let mut sub = -1;\\n        for (idx, ch) in keys_pressed.chars().into_iter().enumerate() {\\n            let x = release_times[idx] - pre;\\n            pre = release_times[idx];\\n            if x > sub {\\n                sub = x;\\n                ans = ch;\\n            } else if x == sub && ch > ans {\\n                ans = ch;\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_slowest_key() {\\n        assert_eq!(\\n            Solution::slowest_key(vec![9, 29, 49, 50], \"cbcd\".to_owned()),\\n            \\'c\\'\\n        );\\n    }\\n\\n    #[test]\\n    fn test_slowest_key_02() {\\n        assert_eq!(\\n            Solution::slowest_key(vec![12, 23, 36, 46, 62], \"spuda\".to_owned()),\\n            \\'a\\'\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn slowest_key(release_times: Vec<i32>, keys_pressed: String) -> char {\\n        let mut pre = 0;\\n        let mut ans = \\' \\';\\n        let mut sub = -1;\\n        for (idx, ch) in keys_pressed.chars().into_iter().enumerate() {\\n            let x = release_times[idx] - pre;\\n            pre = release_times[idx];\\n            if x > sub {\\n                sub = x;\\n                ans = ch;\\n            } else if x == sub && ch > ans {\\n                ans = ch;\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_slowest_key() {\\n        assert_eq!(\\n            Solution::slowest_key(vec![9, 29, 49, 50], \"cbcd\".to_owned()),\\n            \\'c\\'\\n        );\\n    }\\n\\n    #[test]\\n    fn test_slowest_key_02() {\\n        assert_eq!(\\n            Solution::slowest_key(vec![12, 23, 36, 46, 62], \"spuda\".to_owned()),\\n            \\'a\\'\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 909343,
                "title": "my-javascript-solution-92-ms",
                "content": "```\\nvar slowestKey = function(releaseTimes, keysPressed) {\\n    let result = keysPressed[0];\\n    let slowestTime = releaseTimes[0];\\n    const n = releaseTimes.length;\\n    let prevTime = releaseTimes[0];\\n    let diff;\\n    \\n    for (let i = 1; i < n; ++i) {\\n        diff = releaseTimes[i] - prevTime;\\n        if (diff > slowestTime) {\\n            slowestTime = diff;\\n            result = keysPressed[i];\\n        } else if (diff === slowestTime && result.localeCompare(keysPressed[i]) === -1) {\\n            result = keysPressed[i];\\n        }\\n        prevTime = releaseTimes[i];\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar slowestKey = function(releaseTimes, keysPressed) {\\n    let result = keysPressed[0];\\n    let slowestTime = releaseTimes[0];\\n    const n = releaseTimes.length;\\n    let prevTime = releaseTimes[0];\\n    let diff;\\n    \\n    for (let i = 1; i < n; ++i) {\\n        diff = releaseTimes[i] - prevTime;\\n        if (diff > slowestTime) {\\n            slowestTime = diff;\\n            result = keysPressed[i];\\n        } else if (diff === slowestTime && result.localeCompare(keysPressed[i]) === -1) {\\n            result = keysPressed[i];\\n        }\\n        prevTime = releaseTimes[i];\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 909327,
                "title": "java-100-faster-o-n-solution",
                "content": "```\\nclass Solution {\\n    public char slowestKey(int[] a, String s) {\\n        \\n        int[] temp = new int[26];\\n        temp[s.charAt(0) -\\'a\\'] = a[0];\\n        int max = Integer.MIN_VALUE;\\n        int l = s.length();\\n        int maxIndex = 0;\\n        for (int i=1;i<l;i++)\\n        {\\n            char c = s.charAt(i);\\n            if (temp[c-\\'a\\'] < a[i] - a[i-1])\\n            {\\n                temp[c-\\'a\\'] = a[i] - a[i-1];\\n            }\\n        }\\n        \\n        for (int i=25;i>=0;i--)\\n        {\\n            if (temp[i] > max) \\n            {\\n                max = temp[i];\\n                maxIndex = i;\\n            }\\n        }\\n        \\n        return (char) (maxIndex + \\'a\\');\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public char slowestKey(int[] a, String s) {\\n        \\n        int[] temp = new int[26];\\n        temp[s.charAt(0) -\\'a\\'] = a[0];\\n        int max = Integer.MIN_VALUE;\\n        int l = s.length();\\n        int maxIndex = 0;\\n        for (int i=1;i<l;i++)\\n        {\\n            char c = s.charAt(i);\\n            if (temp[c-\\'a\\'] < a[i] - a[i-1])\\n            {\\n                temp[c-\\'a\\'] = a[i] - a[i-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 909301,
                "title": "c-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int n = keysPressed.size();\\n        vector<int> duration(26, 0);\\n        duration[keysPressed[0]-\\'a\\'] = releaseTimes[0];\\n        for (int i=1; i<n; ++i) {\\n            duration[keysPressed[i]-\\'a\\'] = max(duration[keysPressed[i]-\\'a\\'], releaseTimes[i] - releaseTimes[i-1]);\\n        }\\n        int mxm = 0;\\n        char slowestKey;\\n        for (int i=0; i<26; ++i) {\\n            if (duration[i] >= mxm) {\\n                mxm = duration[i];\\n                slowestKey = i + \\'a\\';\\n            }\\n        }\\n        return slowestKey;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int n = keysPressed.size();\\n        vector<int> duration(26, 0);\\n        duration[keysPressed[0]-\\'a\\'] = releaseTimes[0];\\n        for (int i=1; i<n; ++i) {\\n            duration[keysPressed[i]-\\'a\\'] = max(duration[keysPressed[i]-\\'a\\'], releaseTimes[i] - releaseTimes[i-1]);\\n        }\\n        int mxm = 0;\\n        char slowestKey;\\n        for (int i=0; i<26; ++i) {\\n            if (duration[i] >= mxm) {\\n                mxm = duration[i];\\n                slowestKey = i + \\'a\\';\\n            }\\n        }\\n        return slowestKey;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909241,
                "title": "easy-java-solution-o-n",
                "content": "**Simple Logic : We just need to take the difference b/w current and previous index. If the difference is same we need to store the character which is lexicographically larger.**\\n\\n\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int max=releaseTimes[0];\\n        int temp;\\n        char res = keysPressed.charAt(0);\\n        for(int i=1;i<releaseTimes.length;i++){\\n            temp = releaseTimes[i] - releaseTimes[i-1];\\n            if(max == temp){\\n                if(res < keysPressed.charAt(i))\\n                    res = keysPressed.charAt(i);\\n            }\\n            else if(temp > max){\\n                max = temp;\\n                res = keysPressed.charAt(i);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int max=releaseTimes[0];\\n        int temp;\\n        char res = keysPressed.charAt(0);\\n        for(int i=1;i<releaseTimes.length;i++){\\n            temp = releaseTimes[i] - releaseTimes[i-1];\\n            if(max == temp){\\n                if(res < keysPressed.charAt(i))\\n                    res = keysPressed.charAt(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 909196,
                "title": "python3-o-n-solution",
                "content": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        maxReleaseTime = releaseTimes[0]\\n        maxChar = keysPressed[0]\\n        \\n        for i in range(1, len(releaseTimes)):\\n            diff = releaseTimes[i] - releaseTimes[i-1]\\n            \\n            if diff > maxReleaseTime:\\n                maxReleaseTime = diff\\n                maxChar = keysPressed[i]\\n            elif diff == maxReleaseTime:\\n                if keysPressed[i] > maxChar:\\n                    maxChar = keysPressed[i]\\n                    \\n        \\n        return maxChar\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        maxReleaseTime = releaseTimes[0]\\n        maxChar = keysPressed[0]\\n        \\n        for i in range(1, len(releaseTimes)):\\n            diff = releaseTimes[i] - releaseTimes[i-1]\\n            \\n            if diff > maxReleaseTime:\\n                maxReleaseTime = diff\\n                maxChar = keysPressed[i]\\n            elif diff == maxReleaseTime:\\n                if keysPressed[i] > maxChar:\\n                    maxChar = keysPressed[i]\\n                    \\n        \\n        return maxChar\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 909180,
                "title": "javascript-sortedmap-100ms",
                "content": "```\\nconst slowestKey = (releaseTimes, keysPressed) => {\\n    let n = releaseTimes.length;\\n    let map = new Map();\\n    for (let i = 0; i < n; i++) {\\n        let tmp = 0;\\n        if (i == 0) {\\n            tmp = releaseTimes[0];\\n        } else {\\n            tmp = releaseTimes[i] - releaseTimes[i - 1];\\n        }\\n        if (map.has(keysPressed[i])) {\\n            let max = Math.max(tmp, map.get(keysPressed[i]));\\n            map.set(keysPressed[i], max);\\n        } else {\\n            map.set(keysPressed[i], tmp);\\n        }\\n    }\\n    let resMap = sortMap(map);\\n    return resMap.entries().next().value[0];\\n};\\n\\n\\nconst sortMap = (map) => {\\n    return new Map([...map].sort((a, b) => {\\n        if (a[1] == b[1]) return b[0].localeCompare(a[0]);\\n        return b[1] - a[1];\\n    }));\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst slowestKey = (releaseTimes, keysPressed) => {\\n    let n = releaseTimes.length;\\n    let map = new Map();\\n    for (let i = 0; i < n; i++) {\\n        let tmp = 0;\\n        if (i == 0) {\\n            tmp = releaseTimes[0];\\n        } else {\\n            tmp = releaseTimes[i] - releaseTimes[i - 1];\\n        }\\n        if (map.has(keysPressed[i])) {\\n            let max = Math.max(tmp, map.get(keysPressed[i]));\\n            map.set(keysPressed[i], max);\\n        } else {\\n            map.set(keysPressed[i], tmp);\\n        }\\n    }\\n    let resMap = sortMap(map);\\n    return resMap.entries().next().value[0];\\n};\\n\\n\\nconst sortMap = (map) => {\\n    return new Map([...map].sort((a, b) => {\\n        if (a[1] == b[1]) return b[0].localeCompare(a[0]);\\n        return b[1] - a[1];\\n    }));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 909158,
                "title": "java-sort-based-clean-and-concise",
                "content": "JAVA - easy to understand - clean. Just one sort.\\n\\n```\\nclass Solution {\\n    static class Node implements Comparable<Node> {\\n        char chq;\\n        int  dur;\\n        public Node(char chq, int dur){\\n            this.chq = chq;\\n            this.dur = dur;\\n        }\\n        public int compareTo(Node other){\\n            if (other.dur != this.dur)\\n                return other.dur - this.dur;\\n            else\\n                return (int) (other.chq - this.chq);\\n        }\\n    }\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        List<Node> klist = new ArrayList<>();\\n        \\n        for(int i = 0; i < releaseTimes.length; i++){\\n            int elapsed = (i == 0) ? releaseTimes[0] : (releaseTimes[i] - releaseTimes[i-1]);\\n            Node curr = new Node(keysPressed.charAt(i), elapsed);\\n            klist.add(curr);\\n        }\\n        Collections.sort( klist );\\n        \\n        return klist.get(0).chq;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static class Node implements Comparable<Node> {\\n        char chq;\\n        int  dur;\\n        public Node(char chq, int dur){\\n            this.chq = chq;\\n            this.dur = dur;\\n        }\\n        public int compareTo(Node other){\\n            if (other.dur != this.dur)\\n                return other.dur - this.dur;\\n            else\\n                return (int) (other.chq - this.chq);\\n        }\\n    }\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        List<Node> klist = new ArrayList<>();\\n        \\n        for(int i = 0; i < releaseTimes.length; i++){\\n            int elapsed = (i == 0) ? releaseTimes[0] : (releaseTimes[i] - releaseTimes[i-1]);\\n            Node curr = new Node(keysPressed.charAt(i), elapsed);\\n            klist.add(curr);\\n        }\\n        Collections.sort( klist );\\n        \\n        return klist.get(0).chq;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909122,
                "title": "java-1-ms-faster-than-100-00-41-7-mb-less-than-25-00",
                "content": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int idx = 0;\\n        int maxLen = releaseTimes[0];\\n        for (int i = 1; i < releaseTimes.length; ++i) {\\n            int len = releaseTimes[i] - releaseTimes[i - 1];\\n            if (len > maxLen || len == maxLen && keysPressed.charAt(i) > keysPressed.charAt(idx)) {\\n                maxLen = len;\\n                idx = i;\\n            }\\n        }\\n        return keysPressed.charAt(idx);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int idx = 0;\\n        int maxLen = releaseTimes[0];\\n        for (int i = 1; i < releaseTimes.length; ++i) {\\n            int len = releaseTimes[i] - releaseTimes[i - 1];\\n            if (len > maxLen || len == maxLen && keysPressed.charAt(i) > keysPressed.charAt(idx)) {\\n                maxLen = len;\\n                idx = i;\\n            }\\n        }\\n        return keysPressed.charAt(idx);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909121,
                "title": "c-simple-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int maxd = 0;\\n        char c;\\n        \\n        for(int i = 0; i < releaseTimes.size(); i++)\\n        {\\n            //Check the duration\\n            int d = (i == 0? releaseTimes[i]-0 : releaseTimes[i] - releaseTimes[i-1]);\\n            \\n            //duration is greater? for same duration char is larger?\\n            if(d > maxd || ( d == maxd && keysPressed[i] > c))\\n            {\\n                maxd = d;\\n                c = keysPressed[i];\\n            }            \\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\\n        int maxd = 0;\\n        char c;\\n        \\n        for(int i = 0; i < releaseTimes.size(); i++)\\n        {\\n            //Check the duration\\n            int d = (i == 0? releaseTimes[i]-0 : releaseTimes[i] - releaseTimes[i-1]);\\n            \\n            //duration is greater? for same duration char is larger?\\n            if(d > maxd || ( d == maxd && keysPressed[i] > c))\\n            {\\n                maxd = d;\\n                c = keysPressed[i];\\n            }            \\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909098,
                "title": "java-using-ascii-value-with-constant-space-and-o-n-runtime",
                "content": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int[] durations = new int[26];\\n        char c = keysPressed.charAt(0);\\n        durations[c-\\'a\\'] = releaseTimes[0];\\n        int max = releaseTimes[0];\\n        for(int i=1; i<releaseTimes.length; i++){\\n            int duration = releaseTimes[i] - releaseTimes[i-1];\\n            if(max<duration) max = duration;\\n            if(durations[keysPressed.charAt(i) - \\'a\\'] < duration) {\\n                durations[keysPressed.charAt(i) - \\'a\\'] = duration;\\n            }\\n        }\\n        \\n        for(int i=25; i>-1; i--){\\n            if(durations[i]==max) {\\n                c = (char)(i+\\'a\\');\\n                break;\\n            }\\n        }\\n        \\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int[] durations = new int[26];\\n        char c = keysPressed.charAt(0);\\n        durations[c-\\'a\\'] = releaseTimes[0];\\n        int max = releaseTimes[0];\\n        for(int i=1; i<releaseTimes.length; i++){\\n            int duration = releaseTimes[i] - releaseTimes[i-1];\\n            if(max<duration) max = duration;\\n            if(durations[keysPressed.charAt(i) - \\'a\\'] < duration) {\\n                durations[keysPressed.charAt(i) - \\'a\\'] = duration;\\n            }\\n        }\\n        \\n        for(int i=25; i>-1; i--){\\n            if(durations[i]==max) {\\n                c = (char)(i+\\'a\\');\\n                break;\\n            }\\n        }\\n        \\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909088,
                "title": "java-easy-solution",
                "content": "```\\npublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n        \\n        int arr[]=new int[26];\\n        int ans=releaseTimes[0];\\n        for(int i=0;i<releaseTimes.length;i++){\\n            char c=keysPressed.charAt(i);\\n            if(i==0){\\n                arr[c-97]=releaseTimes[i];\\n            }\\n            else{\\n                arr[c-97]=Math.max(arr[c-97],releaseTimes[i]-releaseTimes[i-1]);\\n                ans=Math.max(ans,releaseTimes[i]-releaseTimes[i-1]);\\n            }  \\n        }\\n         \\n        for(int i=25;i>=0;i--){\\n            if(ans==arr[i])\\n                return (char)(i+97);\\n        }\\n        return \\'0\\';\\n    }\\n",
                "solutionTags": [],
                "code": "```\\npublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n        \\n        int arr[]=new int[26];\\n        int ans=releaseTimes[0];\\n        for(int i=0;i<releaseTimes.length;i++){\\n            char c=keysPressed.charAt(i);\\n            if(i==0){\\n                arr[c-97]=releaseTimes[i];\\n            }\\n            else{\\n                arr[c-97]=Math.max(arr[c-97],releaseTimes[i]-releaseTimes[i-1]);\\n                ans=Math.max(ans,releaseTimes[i]-releaseTimes[i-1]);\\n            }  \\n        }\\n         \\n        for(int i=25;i>=0;i--){\\n            if(ans==arr[i])\\n                return (char)(i+97);\\n        }\\n        return \\'0\\';\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 909087,
                "title": "python-simple-solution-5-lines",
                "content": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        d = {}\\n        d[releaseTimes[0]]  =  [keysPressed[0]]\\n        for i in range(1,len(releaseTimes)):\\n            d[releaseTimes[i]-releaseTimes[i-1]]  =  d.get(releaseTimes[i]-releaseTimes[i-1],[])+[keysPressed[i]]\\n        return max(d[max(d)])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        d = {}\\n        d[releaseTimes[0]]  =  [keysPressed[0]]\\n        for i in range(1,len(releaseTimes)):\\n            d[releaseTimes[i]-releaseTimes[i-1]]  =  d.get(releaseTimes[i]-releaseTimes[i-1],[])+[keysPressed[i]]\\n        return max(d[max(d)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909085,
                "title": "java-one-pass-89",
                "content": "```\\nclass Solution {\\n    public char slowestKey(int[] r, String keysPressed) {\\n        char answer = keysPressed.charAt(0);\\n        int time = r[0];\\n        for (int i = 1; i < r.length; i++) {\\n            if (r[i] - r[i - 1] > time) {\\n                answer = keysPressed.charAt(i);\\n                time = r[i] - r[i - 1];\\n            } else if (r[i] - r[i - 1] == time) {\\n                if (keysPressed.charAt(i) > answer) {\\n                    answer = keysPressed.charAt(i);\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public char slowestKey(int[] r, String keysPressed) {\\n        char answer = keysPressed.charAt(0);\\n        int time = r[0];\\n        for (int i = 1; i < r.length; i++) {\\n            if (r[i] - r[i - 1] > time) {\\n                answer = keysPressed.charAt(i);\\n                time = r[i] - r[i - 1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 909078,
                "title": "python3-5-line-linear-scan",
                "content": "Condition to update `ans`: \\n1) if release time is longer than current max;\\n2) if release time is the same as current max and the new key is larger in lexicographical order. \\n```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        ans, mx = \"\", 0\\n        for i, (t, k) in enumerate(zip(releaseTimes, keysPressed)):\\n            if i: t -= releaseTimes[i-1]\\n            if t > mx or t == mx and k > ans: ans, mx = k, t # update \\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        ans = \"\"\\n        mx = prev = 0\\n        for t, k in zip(releaseTimes, keysPressed):\\n            mx, ans = max((mx, ans), (t-prev, k))\\n            prev = t\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        ans, mx = \"\", 0\\n        for i, (t, k) in enumerate(zip(releaseTimes, keysPressed)):\\n            if i: t -= releaseTimes[i-1]\\n            if t > mx or t == mx and k > ans: ans, mx = k, t # update \\n        return ans \\n```\n```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        ans = \"\"\\n        mx = prev = 0\\n        for t, k in zip(releaseTimes, keysPressed):\\n            mx, ans = max((mx, ans), (t-prev, k))\\n            prev = t\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909072,
                "title": "java-solution-using-pair-easy-to-understand",
                "content": "```\\nclass Pair {\\n    char A;\\n    int B;\\n    \\n    Pair(char ch, int diff) {\\n        this.A = ch;\\n        this.B = diff;\\n    }\\n}\\n\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        Pair[] arr = new Pair[releaseTimes.length];\\n        arr[0] = new Pair(keysPressed.charAt(0), releaseTimes[0]);\\n        \\n        for(int i = 1; i < keysPressed.length(); i++) {\\n            arr[i] = new Pair(keysPressed.charAt(i), releaseTimes[i] - releaseTimes[i - 1]);\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        char res = \\' \\';\\n        \\n        for(Pair i : arr) {\\n            if(i.B > max) {\\n                max = i.B;\\n                res = i.A;\\n            }\\n            else if(i.B == max) {\\n                int key = (int)(i.A);\\n                int resKey = (int)(res);\\n                \\n                if(key > resKey) {\\n                    res = i.A;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Pair {\\n    char A;\\n    int B;\\n    \\n    Pair(char ch, int diff) {\\n        this.A = ch;\\n        this.B = diff;\\n    }\\n}\\n\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        Pair[] arr = new Pair[releaseTimes.length];\\n        arr[0] = new Pair(keysPressed.charAt(0), releaseTimes[0]);\\n        \\n        for(int i = 1; i < keysPressed.length(); i++) {\\n            arr[i] = new Pair(keysPressed.charAt(i), releaseTimes[i] - releaseTimes[i - 1]);\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        char res = \\' \\';\\n        \\n        for(Pair i : arr) {\\n            if(i.B > max) {\\n                max = i.B;\\n                res = i.A;\\n            }\\n            else if(i.B == max) {\\n                int key = (int)(i.A);\\n                int resKey = (int)(res);\\n                \\n                if(key > resKey) {\\n                    res = i.A;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909065,
                "title": "python-linear-time-o-n-solution",
                "content": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        \\n        maxTime = releaseTimes[0]\\n        maxChar = keysPressed[0]\\n        \\n        for i in range(1, len(releaseTimes)):\\n            diff = releaseTimes[i] - releaseTimes[i-1]\\n            \\n            if diff > maxTime:\\n                maxTime = diff\\n                maxChar = keysPressed[i]\\n                \\n            elif diff == maxTime:\\n                if maxChar < keysPressed[i]:\\n                    maxChar = keysPressed[i]\\n                    \\n        return maxChar\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        \\n        maxTime = releaseTimes[0]\\n        maxChar = keysPressed[0]\\n        \\n        for i in range(1, len(releaseTimes)):\\n            diff = releaseTimes[i] - releaseTimes[i-1]\\n            \\n            if diff > maxTime:\\n                maxTime = diff\\n                maxChar = keysPressed[i]\\n                \\n            elif diff == maxTime:\\n                if maxChar < keysPressed[i]:\\n                    maxChar = keysPressed[i]\\n                    \\n        return maxChar\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909057,
                "title": "python-super-easy-to-understand",
                "content": "```\\ndef slowestKey(self, releaseTimes, keysPressed):\\n\\tdiffs = []\\n\\tdiffs.append(releaseTimes[0])\\n\\tfor i in range(1, len(releaseTimes)):\\n\\t\\tdiffs.append(releaseTimes[i] - releaseTimes[i - 1])\\n\\tlongest = max(diffs)\\n\\toptions = []\\n\\tfor i, c in enumerate(keysPressed):\\n\\t\\tif diffs[i] == longest:\\n\\t\\t\\toptions.append(c)\\n\\toptions.sort()\\n\\treturn options[-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef slowestKey(self, releaseTimes, keysPressed):\\n\\tdiffs = []\\n\\tdiffs.append(releaseTimes[0])\\n\\tfor i in range(1, len(releaseTimes)):\\n\\t\\tdiffs.append(releaseTimes[i] - releaseTimes[i - 1])\\n\\tlongest = max(diffs)\\n\\toptions = []\\n\\tfor i, c in enumerate(keysPressed):\\n\\t\\tif diffs[i] == longest:\\n\\t\\t\\toptions.append(c)\\n\\toptions.sort()\\n\\treturn options[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 909046,
                "title": "java-short-and-easy-solution",
                "content": "```\\n public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        char ch=keysPressed.charAt(0);\\n        int mmax=releaseTimes[0];\\n        \\n        for(int i=1;i<releaseTimes.length;i++){\\n            if((releaseTimes[i]-releaseTimes[i-1])>=mmax){\\n                if((releaseTimes[i]-releaseTimes[i-1])>mmax){\\n                     mmax=releaseTimes[i]-releaseTimes[i-1];\\n                ch=keysPressed.charAt(i);\\n                }else if((releaseTimes[i]-releaseTimes[i-1])==mmax && ch<keysPressed.charAt(i)){\\n                    mmax=releaseTimes[i]-releaseTimes[i-1];\\n                   ch=keysPressed.charAt(i);\\n                }\\n            }\\n        }\\n        \\n        return ch;\\n    }",
                "solutionTags": [],
                "code": "```\\n public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        char ch=keysPressed.charAt(0);\\n        int mmax=releaseTimes[0];\\n        \\n        for(int i=1;i<releaseTimes.length;i++){\\n            if((releaseTimes[i]-releaseTimes[i-1])>=mmax){\\n                if((releaseTimes[i]-releaseTimes[i-1])>mmax){\\n                     mmax=releaseTimes[i]-releaseTimes[i-1];\\n                ch=keysPressed.charAt(i);\\n                }else if((releaseTimes[i]-releaseTimes[i-1])==mmax && ch<keysPressed.charAt(i)){\\n                    mmax=releaseTimes[i]-releaseTimes[i-1];\\n                   ch=keysPressed.charAt(i);\\n                }\\n            }\\n        }\\n        \\n        return ch;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 909033,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        times = [0 for _ in range(26)]\\n        releaseTimes = [releaseTimes[0]] + [releaseTimes[i] - releaseTimes[i-1] for i in range(1, len(releaseTimes))]\\n        for r in range(len(releaseTimes)):\\n            c = ord(keysPressed[r]) - ord(\\'a\\')\\n            times[c] = max(times[c], releaseTimes[r])\\n        \\n        m = max(times)\\n        can = [t for t in range(len(times)) if times[t] == m]\\n        return chr(ord(\\'a\\') + can[-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        times = [0 for _ in range(26)]\\n        releaseTimes = [releaseTimes[0]] + [releaseTimes[i] - releaseTimes[i-1] for i in range(1, len(releaseTimes))]\\n        for r in range(len(releaseTimes)):\\n            c = ord(keysPressed[r]) - ord(\\'a\\')\\n            times[c] = max(times[c], releaseTimes[r])\\n        \\n        m = max(times)\\n        can = [t for t in range(len(times)) if times[t] == m]\\n        return chr(ord(\\'a\\') + can[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909030,
                "title": "python-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n\\t\\t\\tif not releaseTimes:\\n\\t\\t\\t\\treturn \"\"\\n\\t\\t\\tres = keysPressed[0]\\n\\t\\t\\tcur = releaseTimes[0]\\n\\t\\t\\tfor i in range(1, len(releaseTimes)):\\n\\t\\t\\t\\tif releaseTimes[i] - releaseTimes[i - 1] > cur:\\n\\t\\t\\t\\t\\tcur = releaseTimes[i] - releaseTimes[i - 1]\\n\\t\\t\\t\\t\\tres = keysPressed[i]\\n\\t\\t\\t\\telif releaseTimes[i] - releaseTimes[i - 1] == cur:\\n\\t\\t\\t\\t\\tres = max(res, keysPressed[i])\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n\\t\\t\\tif not releaseTimes:\\n\\t\\t\\t\\treturn \"\"\\n\\t\\t\\tres = keysPressed[0]\\n\\t\\t\\tcur = releaseTimes[0]\\n\\t\\t\\tfor i in range(1, len(releaseTimes)):\\n\\t\\t\\t\\tif releaseTimes[i] - releaseTimes[i - 1] > cur:\\n\\t\\t\\t\\t\\tcur = releaseTimes[i] - releaseTimes[i - 1]\\n\\t\\t\\t\\t\\tres = keysPressed[i]\\n\\t\\t\\t\\telif releaseTimes[i] - releaseTimes[i - 1] == cur:\\n\\t\\t\\t\\t\\tres = max(res, keysPressed[i])\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 909028,
                "title": "python-3-solution",
                "content": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        pos=0\\n        outputtime=releaseTimes[0]\\n        lk=list(keysPressed)\\n        for ind, val in enumerate(releaseTimes):\\n            dtime = val - releaseTimes[ind-1]\\n            if dtime > outputtime:\\n                pos=ind\\n                outputtime = dtime\\n            elif dtime == outputtime:\\n                if ord(lk[ind]) > ord(lk[pos]):\\n                    pos=ind\\n        return(lk[pos])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\\n        pos=0\\n        outputtime=releaseTimes[0]\\n        lk=list(keysPressed)\\n        for ind, val in enumerate(releaseTimes):\\n            dtime = val - releaseTimes[ind-1]\\n            if dtime > outputtime:\\n                pos=ind\\n                outputtime = dtime\\n            elif dtime == outputtime:\\n                if ord(lk[ind]) > ord(lk[pos]):\\n                    pos=ind\\n        return(lk[pos])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909011,
                "title": "java-calculate-for-each-key-easy-to-understand",
                "content": "```\\npublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n        char maxChar = keysPressed.charAt(0);\\n        int maxTime = releaseTimes[0];\\n        for(int i = 1; i < keysPressed.length(); i++){\\n            int duration = releaseTimes[i] - releaseTimes[i-1];\\n            char charPressed = keysPressed.charAt(i);\\n            if (duration > maxTime){\\n                maxTime = duration;\\n                maxChar = charPressed;\\n            }else if (duration == maxTime){\\n                if (maxChar - \\'a\\' < keysPressed.charAt(i) - \\'a\\'){\\n                    maxChar = charPressed;\\n                }\\n            } \\n        }\\n        return maxChar;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic char slowestKey(int[] releaseTimes, String keysPressed) {\\n        char maxChar = keysPressed.charAt(0);\\n        int maxTime = releaseTimes[0];\\n        for(int i = 1; i < keysPressed.length(); i++){\\n            int duration = releaseTimes[i] - releaseTimes[i-1];\\n            char charPressed = keysPressed.charAt(i);\\n            if (duration > maxTime){\\n                maxTime = duration;\\n                maxChar = charPressed;\\n            }else if (duration == maxTime){\\n                if (maxChar - \\'a\\' < keysPressed.charAt(i) - \\'a\\'){\\n                    maxChar = charPressed;\\n                }\\n            } \\n        }\\n        return maxChar;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 908997,
                "title": "easy-java-o-n",
                "content": "```\\n\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        \\n        char longest = keysPressed.charAt(0);\\n        int longestTime = releaseTimes[0];\\n        \\n        for(int i = 1; i < releaseTimes.length; i++)\\n        {\\n            int duration = releaseTimes[i] - releaseTimes[i-1];\\n            \\n            if(duration >= longestTime)\\n            {\\n                longestTime = duration;\\n                \\n                if(duration == longestTime && keysPressed.charAt(i) > longest)\\n                {\\n                    longest = keysPressed.charAt(i);\\n                }\\n                else\\n                {\\n                    longest = keysPressed.charAt(i);\\n                }\\n            }\\n        }\\n        \\n        return longest;\\n    }\\n\\t\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        \\n        char longest = keysPressed.charAt(0);\\n        int longestTime = releaseTimes[0];\\n        \\n        for(int i = 1; i < releaseTimes.length; i++)\\n        {\\n            int duration = releaseTimes[i] - releaseTimes[i-1];\\n            \\n            if(duration >= longestTime)\\n            {\\n                longestTime = duration;\\n                \\n                if(duration == longestTime && keysPressed.charAt(i) > longest)\\n                {\\n                    longest = keysPressed.charAt(i);\\n                }\\n                else\\n                {\\n                    longest = keysPressed.charAt(i);\\n                }\\n            }\\n        }\\n        \\n        return longest;\\n    }\\n\\t\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 4102271,
                "title": "simpleand-easy-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int ans = releaseTimes[0], j=0;\\n        for(int i=1;i<releaseTimes.length;i++){\\n            if(releaseTimes[i]-releaseTimes[i-1] > ans){\\n                ans = releaseTimes[i]-releaseTimes[i-1];\\n                j = i;\\n            }\\n            else if(releaseTimes[i]-releaseTimes[i-1] == ans){\\n                if(keysPressed.charAt(i)-\\'a\\' > keysPressed.charAt(j)-\\'a\\'){\\n                    ans = releaseTimes[i]-releaseTimes[i-1];\\n                    j = i;\\n                }\\n            }\\n        }\\n        return keysPressed.charAt(j);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int ans = releaseTimes[0], j=0;\\n        for(int i=1;i<releaseTimes.length;i++){\\n            if(releaseTimes[i]-releaseTimes[i-1] > ans){\\n                ans = releaseTimes[i]-releaseTimes[i-1];\\n                j = i;\\n            }\\n            else if(releaseTimes[i]-releaseTimes[i-1] == ans){\\n                if(keysPressed.charAt(i)-\\'a\\' > keysPressed.charAt(j)-\\'a\\'){\\n                    ans = releaseTimes[i]-releaseTimes[i-1];\\n                    j = i;\\n                }\\n            }\\n        }\\n        return keysPressed.charAt(j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097191,
                "title": "java-o-n-beats-100-1-ms-beginner-friendly",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n\\n         int maxTime = releaseTimes[0];\\n         char slowKey = keysPressed.charAt(0);\\n\\n        for(int i=1;i<releaseTimes.length;i++)\\n        {\\n            int duration = releaseTimes[i]-releaseTimes[i-1];\\n\\n           if(duration>maxTime || \\n                 (duration == maxTime && keysPressed.charAt(i)>slowKey))\\n           {\\n               maxTime = duration;\\n               slowKey = keysPressed.charAt(i);\\n           }\\n        }\\n          \\n\\n\\n        return slowKey;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n\\n         int maxTime = releaseTimes[0];\\n         char slowKey = keysPressed.charAt(0);\\n\\n        for(int i=1;i<releaseTimes.length;i++)\\n        {\\n            int duration = releaseTimes[i]-releaseTimes[i-1];\\n\\n           if(duration>maxTime || \\n                 (duration == maxTime && keysPressed.charAt(i)>slowKey))\\n           {\\n               maxTime = duration;\\n               slowKey = keysPressed.charAt(i);\\n           }\\n        }\\n          \\n\\n\\n        return slowKey;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094982,
                "title": "beats-100-of-users",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int max = releaseTimes[0];\\n        int idx = 0;\\n        for (int i = 1; i < releaseTimes.length; i++){\\n            if (releaseTimes[i] - releaseTimes[i-1] > max){\\n                max = releaseTimes[i] - releaseTimes[i-1];\\n                idx = i;\\n            }\\n            else if (releaseTimes[i] - releaseTimes[i-1] == max && keysPressed.charAt(i) > keysPressed.charAt(idx)){\\n                idx = i;\\n            }\\n        }\\n        return keysPressed.charAt(idx);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\\n        int max = releaseTimes[0];\\n        int idx = 0;\\n        for (int i = 1; i < releaseTimes.length; i++){\\n            if (releaseTimes[i] - releaseTimes[i-1] > max){\\n                max = releaseTimes[i] - releaseTimes[i-1];\\n                idx = i;\\n            }\\n            else if (releaseTimes[i] - releaseTimes[i-1] == max && keysPressed.charAt(i) > keysPressed.charAt(idx)){\\n                idx = i;\\n            }\\n        }\\n        return keysPressed.charAt(idx);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085106,
                "title": "simple-js-solution-with-58ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} releaseTimes\\n * @param {string} keysPressed\\n * @return {character}\\n */\\nvar slowestKey = function(releaseTimes, keysPressed) {\\n    for(let i=releaseTimes.length-1;i>=0;i--){\\n        releaseTimes[i]-=releaseTimes[i-1] || 0\\n    }\\n    let max=Math.max(...releaseTimes)\\n    releaseTimes=releaseTimes.map((e,i)=>e==max?keysPressed[i]:e)\\n    releaseTimes=releaseTimes.filter((e)=>e%e!=0).sort()\\n    return releaseTimes[releaseTimes.length-1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} releaseTimes\\n * @param {string} keysPressed\\n * @return {character}\\n */\\nvar slowestKey = function(releaseTimes, keysPressed) {\\n    for(let i=releaseTimes.length-1;i>=0;i--){\\n        releaseTimes[i]-=releaseTimes[i-1] || 0\\n    }\\n    let max=Math.max(...releaseTimes)\\n    releaseTimes=releaseTimes.map((e,i)=>e==max?keysPressed[i]:e)\\n    releaseTimes=releaseTimes.filter((e)=>e%e!=0).sort()\\n    return releaseTimes[releaseTimes.length-1]\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1860504,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Pretty tricky uhh"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "lol fax how is this easy im never gonna learn how to code i should just become a plumber"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "Good question to practice hash maps, though it can be solved using normal if else, but imo using maps will be better!"
                    }
                ]
            },
            {
                "id": 2043726,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Pretty tricky uhh"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "lol fax how is this easy im never gonna learn how to code i should just become a plumber"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "Good question to practice hash maps, though it can be solved using normal if else, but imo using maps will be better!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Employees With Missing Information",
        "question_content": "<p>Table: <code>Employees</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| employee_id | int     |\n| name        | varchar |\n+-------------+---------+\nemployee_id is the column with unique values for this table.\nEach row of this table indicates the name of the employee whose ID is employee_id.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Salaries</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| employee_id | int     |\n| salary      | int     |\n+-------------+---------+\nemployee_id is the column with unique values for this table.\nEach row of this table indicates the salary of the employee whose ID is employee_id.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the IDs of all the employees with <strong>missing information</strong>. The information of an employee is missing if:</p>\n\n<ul>\n\t<li>The employee&#39;s <strong>name</strong> is missing, or</li>\n\t<li>The employee&#39;s <strong>salary</strong> is missing.</li>\n</ul>\n\n<p>Return the result table ordered by <code>employee_id</code> <strong>in ascending order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployees table:\n+-------------+----------+\n| employee_id | name     |\n+-------------+----------+\n| 2           | Crew     |\n| 4           | Haven    |\n| 5           | Kristian |\n+-------------+----------+\nSalaries table:\n+-------------+--------+\n| employee_id | salary |\n+-------------+--------+\n| 5           | 76071  |\n| 1           | 22517  |\n| 4           | 63539  |\n+-------------+--------+\n<strong>Output:</strong> \n+-------------+\n| employee_id |\n+-------------+\n| 1           |\n| 2           |\n+-------------+\n<strong>Explanation:</strong> \nEmployees 1, 2, 4, and 5 are working at this company.\nThe name of employee 1 is missing.\nThe salary of employee 2 is missing.\n</pre>\n",
        "solutions": [
            {
                "id": 1946042,
                "title": "implementing-full-join-in-mysql",
                "content": "* There is no natively implemented Outer Join in MySQL.\\n* But we can implement **OUTER JOIN** in MySQL by taking a LEFT JOIN and RIGHT JOIN union.\\n* If column names of two tables are identical, we can use the USING clause instead of the ON clause.\\n```\\nSELECT T.employee_id\\nFROM  \\n  (SELECT * FROM Employees LEFT JOIN Salaries USING(employee_id)\\n   UNION \\n   SELECT * FROM Employees RIGHT JOIN Salaries USING(employee_id))\\nAS T\\nWHERE T.salary IS NULL OR T.name IS NULL\\nORDER BY employee_id;",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "* There is no natively implemented Outer Join in MySQL.\\n* But we can implement **OUTER JOIN** in MySQL by taking a LEFT JOIN and RIGHT JOIN union.\\n* If column names of two tables are identical, we can use the USING clause instead of the ON clause.\\n```\\nSELECT T.employee_id\\nFROM  \\n  (SELECT * FROM Employees LEFT JOIN Salaries USING(employee_id)\\n   UNION \\n   SELECT * FROM Employees RIGHT JOIN Salaries USING(employee_id))\\nAS T\\nWHERE T.salary IS NULL OR T.name IS NULL\\nORDER BY employee_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 1391540,
                "title": "union-where-not-in",
                "content": "```\\nSELECT employee_id FROM Employees WHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION \\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\n\\nORDER BY 1 ASC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT employee_id FROM Employees WHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION \\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\n\\nORDER BY 1 ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2496406,
                "title": "two-methods-by-using-joins-and-union-full-outer-join-mysql",
                "content": "**\\uD83D\\uDE0APLEASE UPVOTE IF YOU FIND USEFUL \\uD83D\\uDE0A**\\n*Full outer join is not supported in mySQL , instead we use UNION*\\n**Method1**\\n```\\nSELECT employee_id from Employees e WHERE employee_id not in (Select employee_id from Salaries)\\nUNION \\nSELECT employee_id from Salaries s WHERE employee_id not in (Select employee_id from Employees)\\nORDER BY employee_id;\\n```\\n**Method2**\\n```\\nSelect e.employee_id from Employees e \\nLEFT JOIN Salaries s \\nON e.employee_id = s.employee_id\\nWHERE s.salary  is NULL\\n\\nUNION\\n\\nSelect s.employee_id from Salaries s\\nLEFT JOIN Employees e \\nON e.employee_id = s.employee_id\\nWHERE e.name is NULL\\n\\nORDER BY employee_id;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nSELECT employee_id from Employees e WHERE employee_id not in (Select employee_id from Salaries)\\nUNION \\nSELECT employee_id from Salaries s WHERE employee_id not in (Select employee_id from Employees)\\nORDER BY employee_id;\\n```\n```\\nSelect e.employee_id from Employees e \\nLEFT JOIN Salaries s \\nON e.employee_id = s.employee_id\\nWHERE s.salary  is NULL\\n\\nUNION\\n\\nSelect s.employee_id from Salaries s\\nLEFT JOIN Employees e \\nON e.employee_id = s.employee_id\\nWHERE e.name is NULL\\n\\nORDER BY employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3012530,
                "title": "mysql-union-easy-to-understand",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect e.employee_id from employees e  left join salaries s on e.employee_id=s.employee_id where s.salary is null\\nunion \\nselect s.employee_id from salaries s  left join employees e on e.employee_id=s.employee_id where e.name is null\\norder by employee_id;\\n\\n```\\n\\n```please upvote, if you find it useful```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect e.employee_id from employees e  left join salaries s on e.employee_id=s.employee_id where s.salary is null\\nunion \\nselect s.employee_id from salaries s  left join employees e on e.employee_id=s.employee_id where e.name is null\\norder by employee_id;\\n\\n```\n```please upvote, if you find it useful```",
                "codeTag": "Unknown"
            },
            {
                "id": 1939570,
                "title": "mysql-nice-and-crisp-solution",
                "content": "```\\nSELECT employee_id \\nFROM employees\\nWHERE employee_id NOT IN (SELECT employee_id FROM salaries)\\nUNION\\nSELECT employee_id \\nFROM salaries\\nWHERE employee_id NOT IN (SELECT employee_id FROM employees)\\nORDER BY employee_id;\\n```\\nUpvote if you like.",
                "solutionTags": [],
                "code": "```\\nSELECT employee_id \\nFROM employees\\nWHERE employee_id NOT IN (SELECT employee_id FROM salaries)\\nUNION\\nSELECT employee_id \\nFROM salaries\\nWHERE employee_id NOT IN (SELECT employee_id FROM employees)\\nORDER BY employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1408900,
                "title": "mysql-implementing-full-join-by-using-union-for-beginners-like-me",
                "content": "MySQL does not support FULL JOIN, so you have to combine JOIN, UNION and LEFT JOIN to get an equivalent. Here is an another way:\\n\\n```\\nSELECT sub.employee_id\\nFROM (\\n\\tSELECT e.employee_id, name, salary\\n\\tFROM employees AS e\\n\\tLEFT JOIN salaries AS s\\n\\tON e.employee_id = s.employee_id\\n\\t\\n\\tUNION\\n\\t\\n\\tSELECT s.employee_id, name, salary\\n\\tFROM employees AS e\\n\\tRIGHT JOIN salaries AS s\\n\\tON e.employee_id = s.employee_id) AS sub\\nWHERE sub.name IS NULL OR sub.salary IS NULL\\nORDER BY sub.employee_id\\n```\\n\\nContributions are appreciated...\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT sub.employee_id\\nFROM (\\n\\tSELECT e.employee_id, name, salary\\n\\tFROM employees AS e\\n\\tLEFT JOIN salaries AS s\\n\\tON e.employee_id = s.employee_id\\n\\t\\n\\tUNION\\n\\t\\n\\tSELECT s.employee_id, name, salary\\n\\tFROM employees AS e\\n\\tRIGHT JOIN salaries AS s\\n\\tON e.employee_id = s.employee_id) AS sub\\nWHERE sub.name IS NULL OR sub.salary IS NULL\\nORDER BY sub.employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2364758,
                "title": "mysql-union-two-approaches-left-join-sub-query",
                "content": "### *Please Upvote if you found this helpful.*\\n**SUBQUERY:**\\n```\\nselect employee_id from Employees where employee_id not in  (select  employee_id from Salaries)\\nunion \\nselect employee_id from Salaries where employee_id not in  (select  employee_id from Employees)\\norder by employee_id;\\n```\\n\\n**JOINS:**\\n```\\nselect e.employee_id from Employees e  \\nleft join Salaries s on e.employee_id=s.employee_id\\nwhere salary is null \\nunion \\nselect s.employee_id from Salaries s\\nleft join Employees e  on e.employee_id=s.employee_id\\nwhere name is null \\norder by employee_id;\\n```",
                "solutionTags": [],
                "code": "```\\nselect employee_id from Employees where employee_id not in  (select  employee_id from Salaries)\\nunion \\nselect employee_id from Salaries where employee_id not in  (select  employee_id from Employees)\\norder by employee_id;\\n```\n```\\nselect e.employee_id from Employees e  \\nleft join Salaries s on e.employee_id=s.employee_id\\nwhere salary is null \\nunion \\nselect s.employee_id from Salaries s\\nleft join Employees e  on e.employee_id=s.employee_id\\nwhere name is null \\norder by employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3434909,
                "title": "union-and-not-in-concept",
                "content": "# MYSQL\\n``` \\nselect employee_id from employees where employee_id not in (select employee_id from Salaries)\\nunion \\nselect employee_id from salaries where employee_id not in (select employee_id from employees)\\norder by employee_id\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "``` \\nselect employee_id from employees where employee_id not in (select employee_id from Salaries)\\nunion \\nselect employee_id from salaries where employee_id not in (select employee_id from employees)\\norder by employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2245773,
                "title": "simple-and-easy-mysql-solutions-2-approaches",
                "content": "Approach 1\\n```\\n#Using Join\\nselect e.employee_id from Employees e\\n    left join Salaries s on e.employee_id = s.employee_id\\n    where s.salary is NULL    \\nunion\\nselect s.employee_id from Salaries s\\n    left join Employees e on s.employee_id=e.employee_id\\n    where e.name is NULL\\norder by employee_id;\\n \\n```\\n\\nApproach 2\\n```\\nselect employee_id from Employees where employee_id not in(select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;\\n```\\n\\n**Please UpVote if it was Helpful :)**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n#Using Join\\nselect e.employee_id from Employees e\\n    left join Salaries s on e.employee_id = s.employee_id\\n    where s.salary is NULL    \\nunion\\nselect s.employee_id from Salaries s\\n    left join Employees e on s.employee_id=e.employee_id\\n    where e.name is NULL\\norder by employee_id;\\n \\n```\n```\\nselect employee_id from Employees where employee_id not in(select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1882490,
                "title": "oracle-mysql-2ways-clean",
                "content": "### Oracle\\n```\\nSELECT e.employee_id \\n  FROM Employees e \\n  LEFT JOIN Salaries s ON e.employee_id = s.employee_id\\n  WHERE s.salary IS NULL\\n  UNION\\n SELECT s1.employee_id\\n   FROM Salaries s1\\n   LEFT JOIN Employees e1 ON e1.employee_id = s1.employee_id\\n  WHERE e1.name IS NULL\\n```\\n\\n### MySQL\\n\\n```\\nSELECT employee_id \\n  FROM Salaries \\n WHERE employee_id NOT IN (SELECT employee_id \\n                             FROM Employees\\n                           )\\nUNION\\nSELECT employee_id \\n  FROM Employees \\n WHERE employee_id NOT IN (SELECT employee_id \\n                             FROM Salaries\\n                           )\\nORDER BY 1\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nSELECT e.employee_id \\n  FROM Employees e \\n  LEFT JOIN Salaries s ON e.employee_id = s.employee_id\\n  WHERE s.salary IS NULL\\n  UNION\\n SELECT s1.employee_id\\n   FROM Salaries s1\\n   LEFT JOIN Employees e1 ON e1.employee_id = s1.employee_id\\n  WHERE e1.name IS NULL\\n```\n```\\nSELECT employee_id \\n  FROM Salaries \\n WHERE employee_id NOT IN (SELECT employee_id \\n                             FROM Employees\\n                           )\\nUNION\\nSELECT employee_id \\n  FROM Employees \\n WHERE employee_id NOT IN (SELECT employee_id \\n                             FROM Salaries\\n                           )\\nORDER BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1930265,
                "title": "simple-solution-mssql",
                "content": "1.\\n```\\nselect employee_id from employees\\nunion\\nselect employee_id from salaries\\nexcept\\nselect employee_id from employees\\nintersect \\nselect employee_id from salaries\\n```\\nunion of two tables minus intersection\\n\\nunion 1 2 4 5\\nintersection 4 5 \\nunion - intersection =1 2\\n\\n2.\\n```\\nselect employee_id from employees\\nwhere employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in (select employee_id from Employees)\\n```\\nplease upvote if you find it useful",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect employee_id from employees\\nunion\\nselect employee_id from salaries\\nexcept\\nselect employee_id from employees\\nintersect \\nselect employee_id from salaries\\n```\n```\\nselect employee_id from employees\\nwhere employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in (select employee_id from Employees)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1454647,
                "title": "union",
                "content": "select T.employee_id \\n from\\n (select * from Employees\\n union \\n select * from Salaries) as T\\n group by T.employee_id \\n having count(employee_id)<2\\n order by employee_id asc\\n",
                "solutionTags": [],
                "code": "select T.employee_id \\n from\\n (select * from Employees\\n union \\n select * from Salaries) as T\\n group by T.employee_id \\n having count(employee_id)<2\\n order by employee_id asc\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1919867,
                "title": "simple-mysql-solution-2-approaches-easy-to-understand-faster-than-99",
                "content": "```\\n# Note: Full Outer Join is not supported by MySQL so we have to use left and right join with union in the below solution.\\nselect employee_id from\\n(select emp.employee_id\\nfrom employees emp left join salaries sal \\non emp.employee_id = sal.employee_id\\nwhere salary is null\\nUNION\\nselect sal.employee_id\\nfrom employees emp right join salaries sal \\non emp.employee_id = sal.employee_id\\nwhere emp.name is null) temp\\norder by employee_id\\n\\n# Faster Solution\\nselect employee_id from\\n(select employee_id from employees\\nwhere employee_id NOT IN (select employee_id from salaries)\\nUNION\\nselect employee_id from salaries\\nwhere employee_id NOT IN (select employee_id from employees)) temp\\norder by employee_id\\n\\n# Do upvote if you like both the approaches\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Note: Full Outer Join is not supported by MySQL so we have to use left and right join with union in the below solution.\\nselect employee_id from\\n(select emp.employee_id\\nfrom employees emp left join salaries sal \\non emp.employee_id = sal.employee_id\\nwhere salary is null\\nUNION\\nselect sal.employee_id\\nfrom employees emp right join salaries sal \\non emp.employee_id = sal.employee_id\\nwhere emp.name is null) temp\\norder by employee_id\\n\\n# Faster Solution\\nselect employee_id from\\n(select employee_id from employees\\nwhere employee_id NOT IN (select employee_id from salaries)\\nUNION\\nselect employee_id from salaries\\nwhere employee_id NOT IN (select employee_id from employees)) temp\\norder by employee_id\\n\\n# Do upvote if you like both the approaches\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2136594,
                "title": "mysql-3-different-approaches",
                "content": "\\n# Solution 1\\n```\\nSELECT employee_id \\nFROM Salaries \\nWHERE employee_id NOT IN (SELECT employee_id \\n                             FROM Employees\\n                           )\\nUNION\\n\\nSELECT employee_id \\nFROM Employees \\nWHERE employee_id NOT IN (SELECT employee_id \\n                             FROM Salaries\\n                           )\\nORDER BY employee_id\\n```\\n\\n# Solution 2\\n```\\nSELECT T.employee_id from\\n(\\n    SELECT * FROM Employees \\n    UNION ALL\\n    SELECT * FROM Salaries\\n) T\\n\\nGROUP BY T.EMPLOYEE_ID\\nHAVING COUNT(T.EMPLOYEE_ID) = 1   /*can also use count(*) */\\nORDER BY T.EMPLOYEE_ID ASC\\n```\\n\\n# Solution 3\\nNote - Doesn\\'t work here in LEETCODE but this is also a potenstial solutin to solve this problem during interviews.\\n\\n```\\nSELECT ISNULL(A.employee_id,B.employee_id) AS employee_id\\nFROM Employees A\\nFULL OUTER JOIN Salaries B\\nON A.employee_id = B.employee_id\\nWHERE A.name IS NULL OR B.salary IS NULL\\nORDER BY employee_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nSELECT employee_id \\nFROM Salaries \\nWHERE employee_id NOT IN (SELECT employee_id \\n                             FROM Employees\\n                           )\\nUNION\\n\\nSELECT employee_id \\nFROM Employees \\nWHERE employee_id NOT IN (SELECT employee_id \\n                             FROM Salaries\\n                           )\\nORDER BY employee_id\\n```\n```\\nSELECT T.employee_id from\\n(\\n    SELECT * FROM Employees \\n    UNION ALL\\n    SELECT * FROM Salaries\\n) T\\n\\nGROUP BY T.EMPLOYEE_ID\\nHAVING COUNT(T.EMPLOYEE_ID) = 1   /*can also use count(*) */\\nORDER BY T.EMPLOYEE_ID ASC\\n```\n```\\nSELECT ISNULL(A.employee_id,B.employee_id) AS employee_id\\nFROM Employees A\\nFULL OUTER JOIN Salaries B\\nON A.employee_id = B.employee_id\\nWHERE A.name IS NULL OR B.salary IS NULL\\nORDER BY employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3114650,
                "title": "by-using-union-operation-in-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT employee_id from Employees e WHERE employee_id not in (Select employee_id from Salaries)\\nUNION \\nSELECT employee_id from Salaries s WHERE employee_id not in (Select employee_id from Employees)\\nORDER BY employee_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT employee_id from Employees e WHERE employee_id not in (Select employee_id from Salaries)\\nUNION \\nSELECT employee_id from Salaries s WHERE employee_id not in (Select employee_id from Employees)\\nORDER BY employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3057231,
                "title": "sql-sloution",
                "content": "# Code\\n```\\nSELECT employee_id FROM Employees WHERE employee_id not in (SELECT employee_id FROM Salaries)\\n  UNION\\nSELECT employee_id FROM Salaries\\n   WHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT employee_id FROM Employees WHERE employee_id not in (SELECT employee_id FROM Salaries)\\n  UNION\\nSELECT employee_id FROM Salaries\\n   WHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2621640,
                "title": "easy-by-union-order-by-not-in",
                "content": "```\\n(\\n    SELECT e2.employee_id FROM salaries AS e2 \\nWHERE e2.employee_id NOT IN (SELECT Employees.employee_id FROM Employees)\\nUNION\\nSELECT e1.employee_id FROM Employees e1 WHERE\\ne1.employee_id NOT IN (SELECT Salaries.employee_id FROM Salaries)\\n) ORDER BY employee_id\\n# atlast order by employee_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle",
                    "Union Find"
                ],
                "code": "```\\n(\\n    SELECT e2.employee_id FROM salaries AS e2 \\nWHERE e2.employee_id NOT IN (SELECT Employees.employee_id FROM Employees)\\nUNION\\nSELECT e1.employee_id FROM Employees e1 WHERE\\ne1.employee_id NOT IN (SELECT Salaries.employee_id FROM Salaries)\\n) ORDER BY employee_id\\n# atlast order by employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2480351,
                "title": "easy-full-outer-join-ms-sql-without-union",
                "content": "It will work on ms sql.\\n```\\nSELECT (CASE \\n            WHEN e.employee_id IS null \\n            THEN s.employee_id \\n            ELSE e.employee_id \\n        END) AS employee_id \\nFROM employees e \\nFULL OUTER JOIN salaries s \\n    ON s.employee_id=e.employee_id\\nWHERE e.name IS null \\n      OR s.salary IS null\\nORDER BY employee_id;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT (CASE \\n            WHEN e.employee_id IS null \\n            THEN s.employee_id \\n            ELSE e.employee_id \\n        END) AS employee_id \\nFROM employees e \\nFULL OUTER JOIN salaries s \\n    ON s.employee_id=e.employee_id\\nWHERE e.name IS null \\n      OR s.salary IS null\\nORDER BY employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2022975,
                "title": "mssql-simple-solution-via-full-outer-join",
                "content": "Hi, there! \\nTo solve this problem, you need to take the following steps:\\n1.  Simply join the two tables (sets) with a [*full outer join*](https://www.w3schools.com/sql/sql_join_full.asp);\\n2.  Add tuple filtering condition to where:\\n```1 = 1``` used to make it easier to remove conditions through a \"--\" comment\\n```and E.[name] is null``` because we need employees without names\\n```or S.[salary] is null``` ...or without salaries;\\n3. Now we need to display the ID of the employee who has *null* in one of the tables (*Employees* OR *Salaries*). To do this, we use *[coalesce](https://docs.microsoft.com/en-us/sql/t-sql/language-elements/coalesce-transact-sql?view=sql-server-ver15)*. In short, function ```coalesce(E.[employee_id], S.[employee_id])``` in this case substitutes the value of the second argument if the first argument is NULL.\\n4. Finally, we just sort the *coalesce* function result, because by description, we must return the result in ascending order.\\n\\n```\\nselect\\n    coalesce(E.[employee_id], S.[employee_id]) as \\'employee_id\\'\\nfrom [dbo].[Employees] E\\n    full outer join [dbo].[Salaries] S\\n        on E.[employee_id] = S.[employee_id]\\nwhere 1 = 1\\n    and E.[name] is null\\n    or S.[salary] is null\\norder by \\'employee_id\\';\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```1 = 1```\n```and E.[name] is null```\n```or S.[salary] is null```\n```coalesce(E.[employee_id], S.[employee_id])```\n```\\nselect\\n    coalesce(E.[employee_id], S.[employee_id]) as \\'employee_id\\'\\nfrom [dbo].[Employees] E\\n    full outer join [dbo].[Salaries] S\\n        on E.[employee_id] = S.[employee_id]\\nwhere 1 = 1\\n    and E.[name] is null\\n    or S.[salary] is null\\norder by \\'employee_id\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390961,
                "title": "fast-mysql-solution-using-union-and-group-by-with-brief-explanation",
                "content": "Steps:\\n1. select all the employee_ids from 2 tables\\n2. find out the employee_id which appears only once\\n\\nfor example:\\ntable 1=[1,2,5], table 2=[1,4,5]\\nStep 1. select all the employee_ids with UNION ALL\\n-> 1, 1, 2, 4, 5, 5\\nStep 2. find those employee_ids which appear only once\\n-> 2, 4\\n```\\n# Write your MySQL query statement below\\nSELECT employee_id FROM\\n(\\n\\t# select all the employee_ids from 2 tables (eg. [1, 1, 2, 4, 5, 5])\\n    SELECT employee_id FROM Employees\\n    UNION ALL SELECT employee_id FROM Salaries\\n) t\\nGROUP BY employee_id\\nHAVING COUNT(*)=1\\nORDER BY employee_id;\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT employee_id FROM\\n(\\n\\t# select all the employee_ids from 2 tables (eg. [1, 1, 2, 4, 5, 5])\\n    SELECT employee_id FROM Employees\\n    UNION ALL SELECT employee_id FROM Salaries\\n) t\\nGROUP BY employee_id\\nHAVING COUNT(*)=1\\nORDER BY employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2107784,
                "title": "beginner-friendly-solution",
                "content": "```\\n# Write your MySQL query statement below\\nselect employee_id from Employees where employee_id not in(select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in(select employee_id from Employees)\\norder by employee_id asc\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect employee_id from Employees where employee_id not in(select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in(select employee_id from Employees)\\norder by employee_id asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390976,
                "title": "simple-mysql-solution-using-not-in",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT employee_id FROM Employees\\nWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION SELECT employee_id FROM Salaries\\nWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id;\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT employee_id FROM Employees\\nWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION SELECT employee_id FROM Salaries\\nWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3303902,
                "title": "sql-server-clean-easy",
                "content": "```\\nSELECT e.employee_id\\nFROM Employees e\\nLEFT JOIN Salaries s ON e.employee_id = s.employee_id\\nWHERE e.name IS NULL OR s.salary IS NULL\\nUNION\\nSELECT s.employee_id\\nFROM Employees e\\nRIGHT JOIN Salaries s ON e.employee_id = s.employee_id\\nWHERE e.employee_id IS NULL OR e.name IS NULL\\nORDER BY employee_id ASC;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT e.employee_id\\nFROM Employees e\\nLEFT JOIN Salaries s ON e.employee_id = s.employee_id\\nWHERE e.name IS NULL OR s.salary IS NULL\\nUNION\\nSELECT s.employee_id\\nFROM Employees e\\nRIGHT JOIN Salaries s ON e.employee_id = s.employee_id\\nWHERE e.employee_id IS NULL OR e.name IS NULL\\nORDER BY employee_id ASC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2792940,
                "title": "easy-union-operation",
                "content": "**please upvote if you liked**\\n```\\n# Write your MySQL query statement below\\nselect employee_id from Employees where\\nemployee_id not in (select employee_id from Salaries)\\nunion \\nselect employee_id from Salaries where\\nemployee_id not in (select employee_id from Employees) \\norder by employee_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect employee_id from Employees where\\nemployee_id not in (select employee_id from Salaries)\\nunion \\nselect employee_id from Salaries where\\nemployee_id not in (select employee_id from Employees) \\norder by employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2629093,
                "title": "sql-easy-inner-join-union",
                "content": "```\\nSELECT employee_id FROM employees\\nWHERE employee_id NOT IN (SELECT employee_id FROM salaries)\\nUNION\\nSELECT employee_id FROM salaries\\nWHERE employee_id NOT IN (SELECT employee_id FROM employees)\\nORDER BY employee_id;\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nSELECT employee_id FROM employees\\nWHERE employee_id NOT IN (SELECT employee_id FROM salaries)\\nUNION\\nSELECT employee_id FROM salaries\\nWHERE employee_id NOT IN (SELECT employee_id FROM employees)\\nORDER BY employee_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2607366,
                "title": "1965-employees-with-missing-information",
                "content": "```\\nSELECT employee_id FROM Employees\\nWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\n\\nUNION\\n\\nSELECT employee_id FROM Salaries\\nWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\n\\nORDER BY employee_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT employee_id FROM Employees\\nWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\n\\nUNION\\n\\nSELECT employee_id FROM Salaries\\nWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\n\\nORDER BY employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2520717,
                "title": "mysql-beginner-level-easy-to-understand-simple-short-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome.***\\n*====================================================================*\\n\\u2705 **MySQL Code :**\\n```\\nSELECT employee_id FROM Employees WHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION \\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY 1 ASC;\\n```\\n**Runtime:** 882 ms\\n**Memory Usage:**  0B\\n________________________________\\n__________________________________\\n\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nSELECT employee_id FROM Employees WHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION \\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY 1 ASC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2465177,
                "title": "mysql-easy-solution",
                "content": "```\\nselect employee_id from employees \\nwhere employee_id not in (select employee_id from salaries)\\nunion\\nselect employee_id from salaries\\nwhere employee_id not in (select employee_id from employees)\\norder by 1\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nselect employee_id from employees \\nwhere employee_id not in (select employee_id from salaries)\\nunion\\nselect employee_id from salaries\\nwhere employee_id not in (select employee_id from employees)\\norder by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2310373,
                "title": "best-solution-and-best-explanation-please-once-try-it",
                "content": "### Please Upvote if You Love it \\u2705\\n\\n```\\n# Write your MySQL query statement below\\n\\n# Query  1: => For finding ids of all the employees with missing salary, we need to query for employees whose records are present in employees table but not in  salaries tables. So Query 1 will be following\\n\\n\\tSelect employee_id from Employees where employee_id not in (Select employee_id from Salaries )\\n\\n# Query 2 : => For finding ids of all the employees with missing name, we need to query for employees whose records are present in Salaries table but not in Employees tables. So Query 2 Will be following \\n\\n\\tSelect employee_id from Salaries where employee_id not in (Select employee_id from Employees)\\n\\n# For finding employee_id of all the employees with missing information we need to take Union (OR condition ) of Query 1 and Query 2 and then order it in ascending order\\n\\n# Final Solution is\\nSelect employee_id from Employees where employee_id not in (Select employee_id from Salaries )\\nUnion\\nSelect employee_id from Salaries where employee_id not in (Select employee_id from Employees)\\norder by employee_id asc\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n# Query  1: => For finding ids of all the employees with missing salary, we need to query for employees whose records are present in employees table but not in  salaries tables. So Query 1 will be following\\n\\n\\tSelect employee_id from Employees where employee_id not in (Select employee_id from Salaries )\\n\\n# Query 2 : => For finding ids of all the employees with missing name, we need to query for employees whose records are present in Salaries table but not in Employees tables. So Query 2 Will be following \\n\\n\\tSelect employee_id from Salaries where employee_id not in (Select employee_id from Employees)\\n\\n# For finding employee_id of all the employees with missing information we need to take Union (OR condition ) of Query 1 and Query 2 and then order it in ascending order\\n\\n# Final Solution is\\nSelect employee_id from Employees where employee_id not in (Select employee_id from Salaries )\\nUnion\\nSelect employee_id from Salaries where employee_id not in (Select employee_id from Employees)\\norder by employee_id asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1949142,
                "title": "oracle-820-ms-two-solution-explanation",
                "content": "**Solution 1:**\\n1. Union IDs from both table (with saving duplicates)\\n2. Select IDs from step 1 that occur once (IDs with name and salary will have duplicates)\\n3. Sort IDs from step 2\\n```\\nselect employee_id from (\\n    select employee_id from employees\\n    union all\\n    select employee_id from salaries\\n) tmp\\ngroup by employee_id\\nhaving count(employee_id) = 1\\norder by employee_id\\n```\\n\\n**Solution 2:**\\n1. Find IDs from first table, thats not occur in second table\\n2. Find IDs from second table, thats not occur in first table\\n3. Union results from previous steps\\n4. Sort IDs from step 3\\n```\\nselect employee_id from (\\n    select e.employee_id from employees e\\n    left join salaries s on e.employee_id = s.employee_id\\n    where s.employee_id is NULL\\n    union all\\n    select s.employee_id from employees e\\n    right join salaries s on e.employee_id = s.employee_id\\n    where e.employee_id is NULL\\n) tmp\\norder by employee_id\\n```",
                "solutionTags": [
                    "Oracle",
                    "Union Find"
                ],
                "code": "```\\nselect employee_id from (\\n    select employee_id from employees\\n    union all\\n    select employee_id from salaries\\n) tmp\\ngroup by employee_id\\nhaving count(employee_id) = 1\\norder by employee_id\\n```\n```\\nselect employee_id from (\\n    select e.employee_id from employees e\\n    left join salaries s on e.employee_id = s.employee_id\\n    where s.employee_id is NULL\\n    union all\\n    select s.employee_id from employees e\\n    right join salaries s on e.employee_id = s.employee_id\\n    where e.employee_id is NULL\\n) tmp\\norder by employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524371,
                "title": "ms-sql",
                "content": "#### Question\\n```\\n1965. Employees With Missing Information\\nEasy\\n\\nSQL Schema\\nTable: Employees\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| employee_id | int     |\\n| name        | varchar |\\n+-------------+---------+\\nemployee_id is the primary key for this table.\\nEach row of this table indicates the name of the employee whose ID is employee_id.\\n \\n\\nTable: Salaries\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| employee_id | int     |\\n| salary      | int     |\\n+-------------+---------+\\nemployee_id is the primary key for this table.\\nEach row of this table indicates the salary of the employee whose ID is employee_id.\\n \\n\\nWrite an SQL query to report the IDs of all the employees with missing information. The information of an employee is missing if:\\n\\nThe employee\\'s name is missing, or\\nThe employee\\'s salary is missing.\\nReturn the result table ordered by employee_id in ascending order.\\n\\nThe query result format is in the following example:\\n\\n \\n\\nEmployees table:\\n+-------------+----------+\\n| employee_id | name     |\\n+-------------+----------+\\n| 2           | Crew     |\\n| 4           | Haven    |\\n| 5           | Kristian |\\n+-------------+----------+\\nSalaries table:\\n+-------------+--------+\\n| employee_id | salary |\\n+-------------+--------+\\n| 5           | 76071  |\\n| 1           | 22517  |\\n| 4           | 63539  |\\n+-------------+--------+\\n\\nResult table:\\n+-------------+\\n| employee_id |\\n+-------------+\\n| 1           |\\n| 2           |\\n+-------------+\\n\\nEmployees 1, 2, 4, and 5 are working at this company.\\nThe name of employee 1 is missing.\\nThe salary of employee 2 is missing.\\n```\\n#### Answer1\\n```SQL\\nselect case when e.employee_id is NULL then s.employee_id\\nelse e.employee_id  end as employee_id FROM Employees e\\nFULL OUTER JOIN Salaries s\\nON e.employee_id = s.employee_id\\nWHERE e.employee_id IS NULL or s.employee_id IS NULL   \\norder by employee_id\\n```\\n#### Answer2\\n```SQL\\nselect coalesce(e.employee_id,s.employee_id) as employee_id \\nFROM Employees e\\nFULL OUTER JOIN Salaries s\\nON e.employee_id = s.employee_id\\nWHERE e.employee_id IS NULL or s.employee_id IS NULL   \\norder by employee_id\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n1965. Employees With Missing Information\\nEasy\\n\\nSQL Schema\\nTable: Employees\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| employee_id | int     |\\n| name        | varchar |\\n+-------------+---------+\\nemployee_id is the primary key for this table.\\nEach row of this table indicates the name of the employee whose ID is employee_id.\\n \\n\\nTable: Salaries\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| employee_id | int     |\\n| salary      | int     |\\n+-------------+---------+\\nemployee_id is the primary key for this table.\\nEach row of this table indicates the salary of the employee whose ID is employee_id.\\n \\n\\nWrite an SQL query to report the IDs of all the employees with missing information. The information of an employee is missing if:\\n\\nThe employee\\'s name is missing, or\\nThe employee\\'s salary is missing.\\nReturn the result table ordered by employee_id in ascending order.\\n\\nThe query result format is in the following example:\\n\\n \\n\\nEmployees table:\\n+-------------+----------+\\n| employee_id | name     |\\n+-------------+----------+\\n| 2           | Crew     |\\n| 4           | Haven    |\\n| 5           | Kristian |\\n+-------------+----------+\\nSalaries table:\\n+-------------+--------+\\n| employee_id | salary |\\n+-------------+--------+\\n| 5           | 76071  |\\n| 1           | 22517  |\\n| 4           | 63539  |\\n+-------------+--------+\\n\\nResult table:\\n+-------------+\\n| employee_id |\\n+-------------+\\n| 1           |\\n| 2           |\\n+-------------+\\n\\nEmployees 1, 2, 4, and 5 are working at this company.\\nThe name of employee 1 is missing.\\nThe salary of employee 2 is missing.\\n```\n```SQL\\nselect case when e.employee_id is NULL then s.employee_id\\nelse e.employee_id  end as employee_id FROM Employees e\\nFULL OUTER JOIN Salaries s\\nON e.employee_id = s.employee_id\\nWHERE e.employee_id IS NULL or s.employee_id IS NULL   \\norder by employee_id\\n```\n```SQL\\nselect coalesce(e.employee_id,s.employee_id) as employee_id \\nFROM Employees e\\nFULL OUTER JOIN Salaries s\\nON e.employee_id = s.employee_id\\nWHERE e.employee_id IS NULL or s.employee_id IS NULL   \\norder by employee_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3264758,
                "title": "solution-with-simple-query-full-join-sql-server",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT\\n    ISNULL(E.employee_id,s.employee_id) employee_id\\nFROM\\n    Employees E\\nFULL JOIN \\n    Salaries S ON E.employee_id = S.employee_id\\nWHERE\\n    E.name IS NULL\\nOR\\n    S.salary IS NULL\\nORDER BY\\n     ISNULL(E.employee_id,s.employee_id)\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT\\n    ISNULL(E.employee_id,s.employee_id) employee_id\\nFROM\\n    Employees E\\nFULL JOIN \\n    Salaries S ON E.employee_id = S.employee_id\\nWHERE\\n    E.name IS NULL\\nOR\\n    S.salary IS NULL\\nORDER BY\\n     ISNULL(E.employee_id,s.employee_id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2791834,
                "title": "mysql-union-not-in-order-by",
                "content": "```\\n# Write your MySQL query statement below\\nselect employee_id from \\nEmployees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from\\nSalaries where employee_id not in (select employee_id from Employees)\\norder by employee_id asc;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect employee_id from \\nEmployees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from\\nSalaries where employee_id not in (select employee_id from Employees)\\norder by employee_id asc;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2558275,
                "title": "mysql-shortest-solution",
                "content": "This is the shortest solution ever \\n```\\nSELECT employee_id FROM Employees\\nWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id FROM Salaries \\nWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id\\n```\\n\\n***Please UPVOTE***",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nSELECT employee_id FROM Employees\\nWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id FROM Salaries \\nWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2286315,
                "title": "oracle-simple-and-best-solution",
                "content": "# Please upvote if you find it helpful.\\n```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT employee_id FROM employees e\\nFULL OUTER JOIN\\nsalaries s\\nUSING (employee_id)\\nWHERE e.name IS NULL OR s.salary IS NULL\\nORDER BY employee_id;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT employee_id FROM employees e\\nFULL OUTER JOIN\\nsalaries s\\nUSING (employee_id)\\nWHERE e.name IS NULL OR s.salary IS NULL\\nORDER BY employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2283850,
                "title": "using-union-and-left-join-easy",
                "content": "\\n\\'\\'\\'\\n\\n# Write your MySQL query statement below\\nSELECT Salaries.employee_id\\nFROM Salaries \\nLEFT JOIN Employees \\n     on Employees.employee_id=Salaries.employee_id\\nWHERE Employees.name is null\\n\\nunion\\n\\nSELECT Employees.employee_id\\nFROM  Employees\\nLEFT JOIN Salaries\\n     on Salaries.employee_id=Employees.employee_id\\nWHERE Salaries.salary is null\\n\\norder by employee_id\\n\\n    \\n    \\n\\t\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'\\n\\n# Write your MySQL query statement below\\nSELECT Salaries.employee_id\\nFROM Salaries \\nLEFT JOIN Employees \\n     on Employees.employee_id=Salaries.employee_id\\nWHERE Employees.name is null\\n\\nunion\\n\\nSELECT Employees.employee_id\\nFROM  Employees\\nLEFT JOIN Salaries\\n     on Salaries.employee_id=Employees.employee_id\\nWHERE Salaries.salary is null\\n\\norder by employee_id\\n\\n    \\n    \\n\\t\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2035758,
                "title": "easiest-mysql-solution",
                "content": "```\\nselect employees.employee_id from employees left join salaries on\\nemployees.employee_id=salaries.employee_id\\nwhere salaries.employee_id is null \\n\\nunion\\n\\nselect salaries.employee_id from salaries left join employees on\\nemployees.employee_id=salaries.employee_id\\nwhere employees.employee_id is null \\n\\norder by employee_id asc\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nselect employees.employee_id from employees left join salaries on\\nemployees.employee_id=salaries.employee_id\\nwhere salaries.employee_id is null \\n\\nunion\\n\\nselect salaries.employee_id from salaries left join employees on\\nemployees.employee_id=salaries.employee_id\\nwhere employees.employee_id is null \\n\\norder by employee_id asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1966868,
                "title": "union-vs-union-all-discussion-two-approaches-to-solve-the-problem-description",
                "content": "Before moving on to SQL queries let\\'s dicuss what union and union all does\\n* `UNION` does a union without duplicates\\n* `UNION ALL` takes into account duplicates as well.\\n\\n**Approach1**: So basically if you do a union all of employeeid on two tables the count will be 1 for employee id which are only present in one table.\\nOnce we do a union all we can do a count(empid) using groupby (empid) and then check if count of(empid) = 1 /*note that we need to use having with aggregate function here*/\\n\\n\\n**Approach2** : Basically we firstly check from table 1 which entries are not present in table2 using not in clause and similarly we check from table 1 which entries are not present in table2 and then do a union of these two.\\n\\nPersonally I feel approach one is better because if you were to do it for 3 tables then you can  simply change your having condition.\\n\\n```\\n\\n/*SOLUTION 1*/\\n\\nSELECT T.employee_id from\\n(\\n    SELECT * FROM Employees \\n    UNION ALL\\n    SELECT * FROM Salaries\\n) T\\n\\nGROUP BY T.EMPLOYEE_ID\\nHAVING COUNT(T.EMPLOYEE_ID) = 1   /*can also use count(*) */\\nORDER BY T.EMPLOYEE_ID ASC\\n\\n\\n/*\\nSOLUTION 2\\n*/\\n\\nSELECT E.employee_id as employee_id from Employees E\\nWHERE E.employee_id NOT IN \\n(\\n    SELECT employee_id from Salaries\\n)\\n\\nUNION\\n\\nSELECT S.employee_id as employee_id from Salaries S\\nWHERE S.employee_id NOT IN\\n(\\n    SELECT employee_id from Employees\\n)\\n\\nORDER BY employee_id ASC\\n\\n```\\n\\nPS: Please upvote if you find this useful. It would motivate me to write more detailed solutions.",
                "solutionTags": [],
                "code": "```\\n\\n/*SOLUTION 1*/\\n\\nSELECT T.employee_id from\\n(\\n    SELECT * FROM Employees \\n    UNION ALL\\n    SELECT * FROM Salaries\\n) T\\n\\nGROUP BY T.EMPLOYEE_ID\\nHAVING COUNT(T.EMPLOYEE_ID) = 1   /*can also use count(*) */\\nORDER BY T.EMPLOYEE_ID ASC\\n\\n\\n/*\\nSOLUTION 2\\n*/\\n\\nSELECT E.employee_id as employee_id from Employees E\\nWHERE E.employee_id NOT IN \\n(\\n    SELECT employee_id from Salaries\\n)\\n\\nUNION\\n\\nSELECT S.employee_id as employee_id from Salaries S\\nWHERE S.employee_id NOT IN\\n(\\n    SELECT employee_id from Employees\\n)\\n\\nORDER BY employee_id ASC\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1391719,
                "title": "sql-server-case-when-full-outer-join",
                "content": "```\\nSELECT CASE WHEN name IS NULL THEN s.employee_id\\n            WHEN salary IS NULL THEN e.employee_id\\n            END as employee_id\\nFROM Employees e\\nFULL OUTER JOIN Salaries s\\nON e.employee_id = s.employee_id\\nWHERE name IS NULL or salary IS NULL          -- get the ones without proper information\\nORDER BY employee_id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT CASE WHEN name IS NULL THEN s.employee_id\\n            WHEN salary IS NULL THEN e.employee_id\\n            END as employee_id\\nFROM Employees e\\nFULL OUTER JOIN Salaries s\\nON e.employee_id = s.employee_id\\nWHERE name IS NULL or salary IS NULL          -- get the ones without proper information\\nORDER BY employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3790245,
                "title": "mysql-solution-for-employees-with-missing-information-problem",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nThe goal is to find the employee IDs for which either the name or the salary information is missing. We can achieve this by performing a combination of LEFT JOIN and RIGHT JOIN between the Employees and Salaries tables and then filtering the rows where the name or salary is NULL.\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n1. Perform a LEFT JOIN between the Employees and Salaries tables to get all rows from the Employees table and matching rows from the Salaries table based on the employee_id.\\r\\n1. In the WHERE clause, filter the rows where the name from the Employees table is NULL or the salary from the Salaries table is NULL. This will give us the employee IDs for which either the name or salary information is missing.\\r\\n1. Perform a RIGHT JOIN between the Employees and Salaries tables to get all rows from the Salaries table and matching rows from the Employees table based on the employee_id.\\r\\n1. In the WHERE clause, filter the rows where the name from the Employees table is NULL or the salary from the Salaries table is NULL. This will give us additional employee IDs for which either the name or salary information is missing.\\r\\n1. Use the UNION operator to combine the results of both joins to get the final set of employee IDs with missing information.\\r\\n1. Sort the employee IDs in ascending order using ORDER BY.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\nThe time complexity of the SQL query is O(n + m), where n is the number of rows in the Employees table and m is the number of rows in the Salaries table. This is because we need to perform two joins, one for each table, and then filter the rows based on the WHERE clause.\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\nThe space complexity is O(max(n, m)), where n is the number of rows in the Employees table and m is the number of rows in the Salaries table. This is because the space required to store the results of the two joins and the UNION operation depends on the maximum number of rows between the two tables.\\r\\n\\r\\n# Code\\r\\n```\\r\\n# Write your MySQL query statement below\\r\\nSELECT COALESCE(e.employee_id, s.employee_id) AS employee_id\\r\\nFROM Employees e\\r\\nLEFT JOIN Salaries s ON e.employee_id = s.employee_id\\r\\nWHERE e.name IS NULL OR s.salary IS NULL\\r\\n\\r\\nUNION\\r\\n\\r\\nSELECT COALESCE(e.employee_id, s.employee_id) AS employee_id\\r\\nFROM Employees e\\r\\nRIGHT JOIN Salaries s ON e.employee_id = s.employee_id\\r\\nWHERE e.name IS NULL OR s.salary IS NULL\\r\\n\\r\\nORDER BY employee_id;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\n# Write your MySQL query statement below\\r\\nSELECT COALESCE(e.employee_id, s.employee_id) AS employee_id\\r\\nFROM Employees e\\r\\nLEFT JOIN Salaries s ON e.employee_id = s.employee_id\\r\\nWHERE e.name IS NULL OR s.salary IS NULL\\r\\n\\r\\nUNION\\r\\n\\r\\nSELECT COALESCE(e.employee_id, s.employee_id) AS employee_id\\r\\nFROM Employees e\\r\\nRIGHT JOIN Salaries s ON e.employee_id = s.employee_id\\r\\nWHERE e.name IS NULL OR s.salary IS NULL\\r\\n\\r\\nORDER BY employee_id;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3339678,
                "title": "using-union",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect employee_id \\nfrom Employees\\nwhere employee_id\\nnot in(select employee_id from salaries)\\nunion\\nselect employee_id \\nfrom salaries\\nwhere employee_id\\nnot in(select employee_id from Employees)\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect employee_id \\nfrom Employees\\nwhere employee_id\\nnot in(select employee_id from salaries)\\nunion\\nselect employee_id \\nfrom salaries\\nwhere employee_id\\nnot in(select employee_id from Employees)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3272177,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect Employees.employee_id from Employees natural left join Salaries \\nwhere Salaries.salary is null\\nunion \\nselect Salaries.employee_id from salaries natural left join Employees \\nwhere Employees.name is null\\norder by employee_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Employees.employee_id from Employees natural left join Salaries \\nwhere Salaries.salary is null\\nunion \\nselect Salaries.employee_id from salaries natural left join Employees \\nwhere Employees.name is null\\norder by employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2827709,
                "title": "mysql-oracle-sql-solution-union-not-in",
                "content": "MySQL/Oracle sql solution\\n```\\nSELECT employee_id\\nFROM Employees\\nWHERE employee_id NOT IN (SELECT employee_id\\n                          FROM Salaries)\\nUNION\\nSELECT employee_id\\nFROM Salaries\\nWHERE employee_id NOT IN (SELECT employee_id\\n                          FROM Employees)\\nORDER BY employee_id;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nSELECT employee_id\\nFROM Employees\\nWHERE employee_id NOT IN (SELECT employee_id\\n                          FROM Salaries)\\nUNION\\nSELECT employee_id\\nFROM Salaries\\nWHERE employee_id NOT IN (SELECT employee_id\\n                          FROM Employees)\\nORDER BY employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2777413,
                "title": "clever-oracle-solution-with-nvl-function",
                "content": "There is a NVL(param1, param2) function in oracle which comes in handy when we want to replace the NULL value with another value. Here if the value of param1 is null, then it is replaced with the value of param2. \\n\\n\\n```\\nSELECT NVL(E.EMPLOYEE_ID, S.EMPLOYEE_ID) AS EMPLOYEE_ID \\nFROM EMPLOYEES E\\nFULL JOIN SALARIES S ON E.EMPLOYEE_ID = S.EMPLOYEE_ID\\nWHERE E.NAME IS NULL\\nOR S.SALARY IS NULL \\nORDER BY EMPLOYEE_ID;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT NVL(E.EMPLOYEE_ID, S.EMPLOYEE_ID) AS EMPLOYEE_ID \\nFROM EMPLOYEES E\\nFULL JOIN SALARIES S ON E.EMPLOYEE_ID = S.EMPLOYEE_ID\\nWHERE E.NAME IS NULL\\nOR S.SALARY IS NULL \\nORDER BY EMPLOYEE_ID;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2592480,
                "title": "easy-and-simple",
                "content": "```\\n# Write your MySQL query statement below\\nselect employee_id from Employees where employee_id not in (select employee_id from salaries)\\nunion \\nselect employee_id from salaries where employee_id not in(select employee_id from employees)\\norder by employee_id",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect employee_id from Employees where employee_id not in (select employee_id from salaries)\\nunion \\nselect employee_id from salaries where employee_id not in(select employee_id from employees)\\norder by employee_id",
                "codeTag": "Unknown"
            },
            {
                "id": 2548577,
                "title": "1965-employees-with-missing-information",
                "content": "```\\nSELECT employee_id FROM Employees\\nWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\n\\nUNION\\n\\nSELECT employee_id FROM Salaries\\nWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\n\\nORDER BY employee_id;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT employee_id FROM Employees\\nWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\n\\nUNION\\n\\nSELECT employee_id FROM Salaries\\nWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\n\\nORDER BY employee_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 2529447,
                "title": "solution-here-mysql-will-not-support-full-join",
                "content": "```\\nSELECT employee_id \\nFROM Employees \\nWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id\\nFROM Salaries \\nWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\n\\nORDER BY employee_id\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT employee_id \\nFROM Employees \\nWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id\\nFROM Salaries \\nWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\n\\nORDER BY employee_id\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2452307,
                "title": "beginner-level-solution-with-sub-query-and-union",
                "content": "Please **upvote** if you find it helpful. Thank you :)\\n\\n**Solution:**\\n```\\nSELECT employee_id\\nFROM Employees\\nWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id\\nFROM Salaries\\nWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nSELECT employee_id\\nFROM Employees\\nWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id\\nFROM Salaries\\nWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2291365,
                "title": "ms-sql-simple-2-approach",
                "content": "1. Using **UNION ALL**\\n```\\nSELECT employee_id\\nFROM (\\n        SELECT E.employee_id\\n        FROM Employees E\\n        LEFT JOIN Salaries S ON S.employee_id = E.employee_id\\n        WHERE name IS NULL OR salary IS NULL\\n\\n        UNION ALL\\n\\n        SELECT S.employee_id\\n        FROM Employees E\\n        RIGHT JOIN Salaries S ON S.employee_id = E.employee_id\\n        WHERE name IS NULL OR salary IS NULL\\n)A\\nORDER BY 1 \\n```\\n\\n2. Using **FULL OUTER JOIN** \\n```\\nSELECT ISNULL(E.employee_id, S.employee_id) employee_id\\nFROM Employees E\\nFULL OUTER JOIN Salaries S ON S.employee_id = E.employee_id\\nWHERE E.employee_id IS NULL OR S.employee_id IS NULL\\nORDER BY 1 ASC\\n```",
                "solutionTags": [
                    "MS SQL Server",
                    "Union Find"
                ],
                "code": "```\\nSELECT employee_id\\nFROM (\\n        SELECT E.employee_id\\n        FROM Employees E\\n        LEFT JOIN Salaries S ON S.employee_id = E.employee_id\\n        WHERE name IS NULL OR salary IS NULL\\n\\n        UNION ALL\\n\\n        SELECT S.employee_id\\n        FROM Employees E\\n        RIGHT JOIN Salaries S ON S.employee_id = E.employee_id\\n        WHERE name IS NULL OR salary IS NULL\\n)A\\nORDER BY 1 \\n```\n```\\nSELECT ISNULL(E.employee_id, S.employee_id) employee_id\\nFROM Employees E\\nFULL OUTER JOIN Salaries S ON S.employee_id = E.employee_id\\nWHERE E.employee_id IS NULL OR S.employee_id IS NULL\\nORDER BY 1 ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2263669,
                "title": "mysql",
                "content": "Using **UNION**\\n```\\nSELECT employee_id\\nFROM\\n( SELECT employee_id FROM Employees\\nUNION ALL \\nSELECT employee_id FROM Salaries\\n)emp\\nGROUP BY employee_id\\nHAVING COUNT(employee_id)=1\\nORDER BY 1;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nSELECT employee_id\\nFROM\\n( SELECT employee_id FROM Employees\\nUNION ALL \\nSELECT employee_id FROM Salaries\\n)emp\\nGROUP BY employee_id\\nHAVING COUNT(employee_id)=1\\nORDER BY 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2242207,
                "title": "a-simple-solution-in-postgresql",
                "content": "```\\nSELECT e.employee_id FROM Employees e \\n\\tLEFT JOIN salaries s ON e.employee_id = s.employee_id\\n\\t\\tWHERE s.salary IS NULL\\nUNION\\nSELECT s.employee_id FROM Salaries s \\n\\tLEFT JOIN employees e ON e.employee_id = s.employee_id\\n\\t\\tWHERE e.name IS NULL;\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nSELECT e.employee_id FROM Employees e \\n\\tLEFT JOIN salaries s ON e.employee_id = s.employee_id\\n\\t\\tWHERE s.salary IS NULL\\nUNION\\nSELECT s.employee_id FROM Salaries s \\n\\tLEFT JOIN employees e ON e.employee_id = s.employee_id\\n\\t\\tWHERE e.name IS NULL;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2232392,
                "title": "mysql-union-table-solution-easy-solution",
                "content": "```\\nSELECT emp.employee_id\\nFROM\\n    (SELECT \\n        salaries.employee_id\\n     FROM\\n        employees RIGHT JOIN salaries\\n        ON employees.employee_id = salaries.employee_id\\n     WHERE\\n        employees.name IS NULL\\n\\n    UNION\\n\\n     SELECT \\n        employees.employee_id\\n     FROM\\n        employees LEFT JOIN salaries\\n        ON employees.employee_id = salaries.employee_id\\n     WHERE\\n        salaries.salary IS NULL\\n    ) AS emp\\nORDER BY emp.employee_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nSELECT emp.employee_id\\nFROM\\n    (SELECT \\n        salaries.employee_id\\n     FROM\\n        employees RIGHT JOIN salaries\\n        ON employees.employee_id = salaries.employee_id\\n     WHERE\\n        employees.name IS NULL\\n\\n    UNION\\n\\n     SELECT \\n        employees.employee_id\\n     FROM\\n        employees LEFT JOIN salaries\\n        ON employees.employee_id = salaries.employee_id\\n     WHERE\\n        salaries.salary IS NULL\\n    ) AS emp\\nORDER BY emp.employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2222422,
                "title": "easy-approach-mysql",
                "content": "SELECT employee_id FROM Employees \\nWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id FROM Salaries \\nWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT employee_id FROM Employees \\nWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id FROM Salaries \\nWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 2211980,
                "title": "sql-easy-using-select-union",
                "content": "```\\nSELECT employee_id FROM Employees \\n\\tWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id FROM Salaries \\n\\tWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id;\\n```\\nPlease upvote if you found this useful :)",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nSELECT employee_id FROM Employees \\n\\tWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id FROM Salaries \\n\\tWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2164513,
                "title": "mysql-easy-using-union",
                "content": "```\\nselect employee_id \\nfrom Salaries\\nwhere employee_id not in (select employee_id from Employees)\\nunion\\nselect employee_id \\nfrom Employees\\nwhere employee_id not in (select employee_id from Salaries)\\norder by employee_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nselect employee_id \\nfrom Salaries\\nwhere employee_id not in (select employee_id from Employees)\\nunion\\nselect employee_id \\nfrom Employees\\nwhere employee_id not in (select employee_id from Salaries)\\norder by employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2149127,
                "title": "full-outer-join-easy",
                "content": "```\\nselect\\nisnull(e.employee_id, s.employee_id) as employee_id\\nfrom\\nemployees e full outer join salaries s on e.employee_id=s.employee_id\\nwhere e.name IS NULL or s.salary is null\\norder by isnull(e.employee_id, s.employee_id) asc",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect\\nisnull(e.employee_id, s.employee_id) as employee_id\\nfrom\\nemployees e full outer join salaries s on e.employee_id=s.employee_id\\nwhere e.name IS NULL or s.salary is null\\norder by isnull(e.employee_id, s.employee_id) asc",
                "codeTag": "Unknown"
            },
            {
                "id": 2034235,
                "title": "tsql-full-outer-join-statement",
                "content": "```\\nSELECT ISNULL(A.employee_id,B.employee_id) AS employee_id\\nFROM Employees A\\nFULL OUTER JOIN Salaries B\\nON A.employee_id = B.employee_id\\nWHERE A.name IS NULL OR B.salary IS NULL\\nORDER BY employee_id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT ISNULL(A.employee_id,B.employee_id) AS employee_id\\nFROM Employees A\\nFULL OUTER JOIN Salaries B\\nON A.employee_id = B.employee_id\\nWHERE A.name IS NULL OR B.salary IS NULL\\nORDER BY employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1958208,
                "title": "mysql-solution",
                "content": "SELECT e.employee_id\\nFROM Employees e\\nWHERE e.employee_id NOT IN (SELECT s.employee_id FROM Salaries s)\\n\\nUNION\\n\\nSELECT s.employee_id\\nFROM Salaries s\\nWHERE s.employee_id NOT IN (SELECT e.employee_id FROM Employees e)\\n\\nORDER BY employee_id;",
                "solutionTags": [],
                "code": "SELECT e.employee_id\\nFROM Employees e\\nWHERE e.employee_id NOT IN (SELECT s.employee_id FROM Salaries s)\\n\\nUNION\\n\\nSELECT s.employee_id\\nFROM Salaries s\\nWHERE s.employee_id NOT IN (SELECT e.employee_id FROM Employees e)\\n\\nORDER BY employee_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 1933430,
                "title": "mysql-full-join-using-union",
                "content": "The simple solution here would be to do full outer join and find the id\\'s without salary or name\\nUnfortunately, We don\\'t have FULL OUTER JOIN in MySQL, to achieve that we can create it using UNION of left outer and right outer\\n\\n```\\n# Write your MySQL query statement below\\n\\nSELECT res.employee_id FROM\\n(\\n    SELECT *\\n    FROM employees\\n    LEFT OUTER JOIN salaries\\n    USING (employee_id)\\n    \\n    UNION\\n    \\n    SELECT *\\n    FROM employees\\n    RIGHT OUTER JOIN salaries\\n    USING (employee_id)\\n) res\\nWHERE name IS NULL \\nOR salary IS NULL\\nORDER BY employee_id;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT res.employee_id FROM\\n(\\n    SELECT *\\n    FROM employees\\n    LEFT OUTER JOIN salaries\\n    USING (employee_id)\\n    \\n    UNION\\n    \\n    SELECT *\\n    FROM employees\\n    RIGHT OUTER JOIN salaries\\n    USING (employee_id)\\n) res\\nWHERE name IS NULL \\nOR salary IS NULL\\nORDER BY employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1398255,
                "title": "mysql-union",
                "content": "\\n```\\nSELECT employee_id FROM Employees WHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION \\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT employee_id FROM Employees WHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION \\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3910216,
                "title": "super-easy-solution",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/c61476a1-59e3-45e2-8cea-8b468e937cbb_1692039020.491576.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT COALESCE(E.employee_id, S.employee_id) AS employee_id\\nFROM Employees E\\nFULL JOIN Salaries S ON E.employee_id = S.employee_id\\nWHERE E.employee_id IS NULL OR S.employee_id IS NULL\\nORDER BY employee_id;\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT COALESCE(E.employee_id, S.employee_id) AS employee_id\\nFROM Employees E\\nFULL JOIN Salaries S ON E.employee_id = S.employee_id\\nWHERE E.employee_id IS NULL OR S.employee_id IS NULL\\nORDER BY employee_id;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3896379,
                "title": "pandas-outer-join",
                "content": "# Intuition\\n1. Merge two tables\\n2. Select rows with at least one null\\n\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_employees(employees: pd.DataFrame, salaries: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(employees, salaries, on=\\'employee_id\\', how=\\'outer\\')\\n    return df[df.isna().any(axis=1)][[\\'employee_id\\']].sort_values(by=\\'employee_id\\')\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_employees(employees: pd.DataFrame, salaries: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(employees, salaries, on=\\'employee_id\\', how=\\'outer\\')\\n    return df[df.isna().any(axis=1)][[\\'employee_id\\']].sort_values(by=\\'employee_id\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3086842,
                "title": "full-outer-join-emulation-in-mysql-alternate-quick-and-intuitive-approach",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n# Emulating full outer join in SQL\\nSELECT EMPLOYEE_ID FROM\\n(SELECT E.EMPLOYEE_ID, NAME, SALARY FROM EMPLOYEES E\\nLEFT OUTER JOIN SALARIES S ON E.EMPLOYEE_ID = S.EMPLOYEE_ID\\nUNION \\nSELECT S.EMPLOYEE_ID, NAME, SALARY FROM EMPLOYEES E\\nRIGHT OUTER JOIN SALARIES S ON E.EMPLOYEE_ID = S.EMPLOYEE_ID) T\\nWHERE NAME IS NULL OR SALARY IS NULL\\nORDER BY employee_id\\n\\n# Alternate: Intuitive \\nSELECT EMPLOYEE_ID FROM EMPLOYEES WHERE EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID FROM SALARIES)\\nUNION\\nSELECT EMPLOYEE_ID FROM SALARIES WHERE EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID FROM EMPLOYEES)\\nORDER BY 1 ASC \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n# Emulating full outer join in SQL\\nSELECT EMPLOYEE_ID FROM\\n(SELECT E.EMPLOYEE_ID, NAME, SALARY FROM EMPLOYEES E\\nLEFT OUTER JOIN SALARIES S ON E.EMPLOYEE_ID = S.EMPLOYEE_ID\\nUNION \\nSELECT S.EMPLOYEE_ID, NAME, SALARY FROM EMPLOYEES E\\nRIGHT OUTER JOIN SALARIES S ON E.EMPLOYEE_ID = S.EMPLOYEE_ID) T\\nWHERE NAME IS NULL OR SALARY IS NULL\\nORDER BY employee_id\\n\\n# Alternate: Intuitive \\nSELECT EMPLOYEE_ID FROM EMPLOYEES WHERE EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID FROM SALARIES)\\nUNION\\nSELECT EMPLOYEE_ID FROM SALARIES WHERE EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID FROM EMPLOYEES)\\nORDER BY 1 ASC \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3042478,
                "title": "cte-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nWITH helper AS (\\n    SELECT * FROM Employees\\n    UNION SELECT * FROM Salaries\\n)\\nSELECT employee_id FROM helper\\nGROUP BY  employee_id \\nHAVING COUNT(employee_id) < 2\\nORDER BY employee_id ASC",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nWITH helper AS (\\n    SELECT * FROM Employees\\n    UNION SELECT * FROM Salaries\\n)\\nSELECT employee_id FROM helper\\nGROUP BY  employee_id \\nHAVING COUNT(employee_id) < 2\\nORDER BY employee_id ASC",
                "codeTag": "Unknown"
            },
            {
                "id": 3015069,
                "title": "oracle-simple-solution-beats-86",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\nselect coalesce(e.employee_id,s.employee_id) as employee_id \\nfrom Employees e FULL OUTER JOIN Salaries s\\nON e.employee_id = s.employee_id\\nwhere name is null or salary is null\\norder by employee_id;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nselect coalesce(e.employee_id,s.employee_id) as employee_id \\nfrom Employees e FULL OUTER JOIN Salaries s\\nON e.employee_id = s.employee_id\\nwhere name is null or salary is null\\norder by employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2979391,
                "title": "employees-with-missing-information-solution-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect e.employee_id\\n    from Employees e\\n    left join Salaries s\\n    using(employee_id)\\n    where salary is null\\nunion all\\nselect s.employee_id\\n    from Employees e\\n    right join Salaries s\\n    using(employee_id)\\n    where name is null\\norder by employee_id;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect e.employee_id\\n    from Employees e\\n    left join Salaries s\\n    using(employee_id)\\n    where salary is null\\nunion all\\nselect s.employee_id\\n    from Employees e\\n    right join Salaries s\\n    using(employee_id)\\n    where name is null\\norder by employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2926479,
                "title": "fast-solution-using-not-in-and-union-and-order-by-employee-id",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect employee_id from salaries where employee_id not in \\n(select employee_id from employees)\\nunion\\nselect employee_id from employees where employee_id not in \\n(select employee_id from salaries)\\norder by employee_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect employee_id from salaries where employee_id not in \\n(select employee_id from employees)\\nunion\\nselect employee_id from employees where employee_id not in \\n(select employee_id from salaries)\\norder by employee_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2909168,
                "title": "union-on-left-joins",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect distinct c.employee_id from \\n(\\nselect e.employee_id, e.name, s2.salary from Employees e\\nleft join Salaries s2 on s2.employee_id = e.employee_id\\n\\nunion\\n\\nselect s.employee_id, e2.name, s.salary from Salaries s\\nleft join Employees e2 on e2.employee_id = s.employee_id\\n) as c\\nwhere c.name is null or c.salary is null\\norder by c.employee_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect distinct c.employee_id from \\n(\\nselect e.employee_id, e.name, s2.salary from Employees e\\nleft join Salaries s2 on s2.employee_id = e.employee_id\\n\\nunion\\n\\nselect s.employee_id, e2.name, s.salary from Salaries s\\nleft join Employees e2 on e2.employee_id = s.employee_id\\n) as c\\nwhere c.name is null or c.salary is null\\norder by c.employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2899180,
                "title": "mysql-left-join-right-join-union",
                "content": "There is no `outer join` in MySQL.\\nhttps://leetcode.com/submissions/detail/857838266/\\n```\\n# Write your MySQL query statement below\\n(\\n    select e.employee_id \\n    from Employees as e\\n    left join Salaries as s\\n    on e.employee_id = s.employee_id\\n    where s.employee_id is null\\n)\\nunion\\n(\\n    select s.employee_id\\n    from Employees as e\\n    right join Salaries as s\\n    on e.employee_id = s.employee_id\\n    where e.employee_id is null\\n)\\norder by employee_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n(\\n    select e.employee_id \\n    from Employees as e\\n    left join Salaries as s\\n    on e.employee_id = s.employee_id\\n    where s.employee_id is null\\n)\\nunion\\n(\\n    select s.employee_id\\n    from Employees as e\\n    right join Salaries as s\\n    on e.employee_id = s.employee_id\\n    where e.employee_id is null\\n)\\norder by employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2872477,
                "title": "come-watch-easiest-mysql-beginners-method-mysql",
                "content": "UNION IS THE KEY!!!\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect employee_id from salaries where employee_id not in (Select employee_id from employees)\\nunion \\nSelect employee_id from employees where employee_id not in (Select employee_id from salaries) order by employee_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect employee_id from salaries where employee_id not in (Select employee_id from employees)\\nunion \\nSelect employee_id from employees where employee_id not in (Select employee_id from salaries) order by employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2868579,
                "title": "3-mysql-solutions",
                "content": "#FASTEST : Using Group BY\\nSELECT T.employee_id FROM\\n(\\n    SELECT * FROM Employees \\n    UNION ALL\\n    SELECT * FROM Salaries\\n) T\\nGROUP BY T.employee_id\\nHAVING COUNT(T.employee_id) = 1 \\nORDER BY T.employee_id ASC;\\n\\n#Using UNION and WHERE NOT IN\\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN (SELECT employee_id FROM Employees WHERE name IS NOT NULL)\\nUNION\\nSELECT employee_id FROM Employees WHERE employee_id NOT IN (SELECT employee_id FROM Salaries WHERE salary IS NOT NULL)\\nORDER BY employee_id ASC;\\n\\n#Using JOIN\\nSELECT JOINEDTABLE.employee_id\\nFROM\\n    (   \\n        SELECT *\\n        FROM Employees\\n        LEFT JOIN Salaries\\n        USING(employee_id)\\n    UNION\\n        SELECT * \\n        FROM Salaries\\n        LEFT JOIN Employees\\n        USING(employee_id)\\n    )\\n    AS JOINEDTABLE\\nWHERE JOINEDTABLE.salary IS NULL OR JOINEDTABLE.name IS NULL\\nORDER BY JOINEDTABLE.employee_id ASC;",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "#FASTEST : Using Group BY\\nSELECT T.employee_id FROM\\n(\\n    SELECT * FROM Employees \\n    UNION ALL\\n    SELECT * FROM Salaries\\n) T\\nGROUP BY T.employee_id\\nHAVING COUNT(T.employee_id) = 1 \\nORDER BY T.employee_id ASC;\\n\\n#Using UNION and WHERE NOT IN\\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN (SELECT employee_id FROM Employees WHERE name IS NOT NULL)\\nUNION\\nSELECT employee_id FROM Employees WHERE employee_id NOT IN (SELECT employee_id FROM Salaries WHERE salary IS NOT NULL)\\nORDER BY employee_id ASC;\\n\\n#Using JOIN\\nSELECT JOINEDTABLE.employee_id\\nFROM\\n    (   \\n        SELECT *\\n        FROM Employees\\n        LEFT JOIN Salaries\\n        USING(employee_id)\\n    UNION\\n        SELECT * \\n        FROM Salaries\\n        LEFT JOIN Employees\\n        USING(employee_id)\\n    )\\n    AS JOINEDTABLE\\nWHERE JOINEDTABLE.salary IS NULL OR JOINEDTABLE.name IS NULL\\nORDER BY JOINEDTABLE.employee_id ASC;",
                "codeTag": "Unknown"
            },
            {
                "id": 2612878,
                "title": "all-three-solutions-last-one-is-epic",
                "content": "Solution 1\\n```\\nSELECT employee_id from Employees e WHERE employee_id not in (Select employee_id from Salaries)\\nUNION \\nSELECT employee_id from Salaries s WHERE employee_id not in (Select employee_id from Employees)\\nORDER BY employee_id;\\n```\\n\\n\\nSolution 2\\n```\\nSelect e.employee_id from Employees e \\nLEFT JOIN Salaries s \\nON e.employee_id = s.employee_id\\nWHERE s.salary  is NULL\\n\\nUNION\\n\\nSelect s.employee_id from Salaries s\\nLEFT JOIN Employees e \\nON e.employee_id = s.employee_id\\nWHERE e.name is NULL\\n\\nORDER BY employee_id;\\n```\\n\\nSolution 3 (epic)\\n```\\nselect T.employee_id from\\n\\n(select * from Employees\\nunion\\nselect * from Salaries\\n) as T\\n\\ngroup by T.employee_id\\n\\nhaving count(T.employee_id) < 2\\n\\norder by T.employee_id asc\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT employee_id from Employees e WHERE employee_id not in (Select employee_id from Salaries)\\nUNION \\nSELECT employee_id from Salaries s WHERE employee_id not in (Select employee_id from Employees)\\nORDER BY employee_id;\\n```\n```\\nSelect e.employee_id from Employees e \\nLEFT JOIN Salaries s \\nON e.employee_id = s.employee_id\\nWHERE s.salary  is NULL\\n\\nUNION\\n\\nSelect s.employee_id from Salaries s\\nLEFT JOIN Employees e \\nON e.employee_id = s.employee_id\\nWHERE e.name is NULL\\n\\nORDER BY employee_id;\\n```\n```\\nselect T.employee_id from\\n\\n(select * from Employees\\nunion\\nselect * from Salaries\\n) as T\\n\\ngroup by T.employee_id\\n\\nhaving count(T.employee_id) < 2\\n\\norder by T.employee_id asc\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2533658,
                "title": "here-is-solution-with-left-join-and-union",
                "content": "```sql\\nSELECT e.employee_id \\nFROM Employees e\\nLEFT JOIN Salaries s ON e.employee_id = s.employee_id\\nWHERE s.employee_id IS NULL\\nUNION \\nSELECT s.employee_id \\nFROM Salaries s\\nLEFT JOIN Employees e ON e.employee_id = s.employee_id\\nWHERE e.employee_id IS NULL\\nORDER BY employee_id\\n```",
                "solutionTags": [],
                "code": "```sql\\nSELECT e.employee_id \\nFROM Employees e\\nLEFT JOIN Salaries s ON e.employee_id = s.employee_id\\nWHERE s.employee_id IS NULL\\nUNION \\nSELECT s.employee_id \\nFROM Salaries s\\nLEFT JOIN Employees e ON e.employee_id = s.employee_id\\nWHERE e.employee_id IS NULL\\nORDER BY employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527856,
                "title": "neat-and-easy-solution",
                "content": "**#Solution**\\n\\n\\nSELECT employee_id FROM Employees WHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION \\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\n\\nORDER BY 1 ASC;",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "**#Solution**\\n\\n\\nSELECT employee_id FROM Employees WHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION \\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\n\\nORDER BY 1 ASC;",
                "codeTag": "Unknown"
            },
            {
                "id": 2518524,
                "title": "fast-not-exists-union-solution",
                "content": "```\\nSELECT employee_id FROM Employees e\\nWHERE NOT EXISTS (SELECT employee_id FROM Salaries s WHERE e.employee_id = s.employee_id)\\n\\nUNION \\n\\nSELECT employee_id FROM Salaries s\\nWHERE NOT EXISTS (SELECT employee_id FROM Employees e WHERE e.employee_id = s.employee_id)\\n\\nORDER BY employee_id\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nSELECT employee_id FROM Employees e\\nWHERE NOT EXISTS (SELECT employee_id FROM Salaries s WHERE e.employee_id = s.employee_id)\\n\\nUNION \\n\\nSELECT employee_id FROM Salaries s\\nWHERE NOT EXISTS (SELECT employee_id FROM Employees e WHERE e.employee_id = s.employee_id)\\n\\nORDER BY employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484642,
                "title": "simple-mysql-solution-union",
                "content": "In this problem we are required to write **an SQL query to report the IDs of all the employees with missing information. The information of an employee is missing if:**\\n\\n**The employee\\'s name is missing, or\\nThe employee\\'s salary is missing.**\\n\\nAnd we also are supposed to return the result table **return the result table ordered by employee_id in ascending order.**\\n\\nUsing the **NOT IN query before UNION** I have checked if the **name is misssing**\\n\\n```\\nSELECT employee_id \\nFROM Employees\\nWHERE employee_id \\nNOT IN (SELECT employee_id FROM Salaries)\\n```\\n\\nUsing the **NOT IN query after UNION** I have checked if the **name is misssing**\\n\\n```\\nSELECT employee_id \\nFROM Salaries\\nWHERE employee_id \\nNOT IN (SELECT employee_id FROM Employees)\\n```\\n\\nNow using **UNION** to merge both queries.\\n```\\nSELECT employee_id \\nFROM Employees\\nWHERE employee_id \\nNOT IN (SELECT employee_id FROM Salaries)\\n\\nUNION\\n\\nSELECT employee_id \\nFROM Salaries\\nWHERE employee_id \\nNOT IN (SELECT employee_id FROM Employees)\\n```\\n\\nAt last ordering them by id.\\n**COMPLETE CODE:**\\n```\\n# Write your MySQL query statement below\\nSELECT employee_id \\nFROM Employees\\nWHERE employee_id \\nNOT IN (SELECT employee_id FROM Salaries)\\n\\nUNION\\n\\nSELECT employee_id \\nFROM Salaries\\nWHERE employee_id \\nNOT IN (SELECT employee_id FROM Employees)\\n\\nORDER BY employee_id;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nSELECT employee_id \\nFROM Employees\\nWHERE employee_id \\nNOT IN (SELECT employee_id FROM Salaries)\\n```\n```\\nSELECT employee_id \\nFROM Salaries\\nWHERE employee_id \\nNOT IN (SELECT employee_id FROM Employees)\\n```\n```\\nSELECT employee_id \\nFROM Employees\\nWHERE employee_id \\nNOT IN (SELECT employee_id FROM Salaries)\\n\\nUNION\\n\\nSELECT employee_id \\nFROM Salaries\\nWHERE employee_id \\nNOT IN (SELECT employee_id FROM Employees)\\n```\n```\\n# Write your MySQL query statement below\\nSELECT employee_id \\nFROM Employees\\nWHERE employee_id \\nNOT IN (SELECT employee_id FROM Salaries)\\n\\nUNION\\n\\nSELECT employee_id \\nFROM Salaries\\nWHERE employee_id \\nNOT IN (SELECT employee_id FROM Employees)\\n\\nORDER BY employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2477129,
                "title": "faster-than-96-64",
                "content": "# MYSQL\\n```\\nselect employee_id from employees\\n    where employee_id not in(\\n        select e.employee_id from employees as e, salaries as s\\n        where e.employee_id = s.employee_id\\n    )\\nunion\\nselect employee_id from salaries\\n    where employee_id not in(\\n        select e.employee_id from employees as e, salaries as s\\n        where e.employee_id = s.employee_id\\n    )\\norder by employee_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nselect employee_id from employees\\n    where employee_id not in(\\n        select e.employee_id from employees as e, salaries as s\\n        where e.employee_id = s.employee_id\\n    )\\nunion\\nselect employee_id from salaries\\n    where employee_id not in(\\n        select e.employee_id from employees as e, salaries as s\\n        where e.employee_id = s.employee_id\\n    )\\norder by employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2429999,
                "title": "mysql-simple-and-easy-implementation",
                "content": "```\\nselect  employee_id\\nfrom Employees\\nwhere employee_id not in(select employee_id\\n                        from Salaries)\\n             union\\nselect  employee_id\\nfrom  Salaries\\nwhere employee_id not in(select employee_id\\n                        from Employees)\\norder by employee_id;",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nselect  employee_id\\nfrom Employees\\nwhere employee_id not in(select employee_id\\n                        from Salaries)\\n             union\\nselect  employee_id\\nfrom  Salaries\\nwhere employee_id not in(select employee_id\\n                        from Employees)\\norder by employee_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 2400584,
                "title": "mysql-very-easy-solution-100-working",
                "content": "select employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "select employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 2337111,
                "title": "mysql-solution-using-union-and-not-in-nested-query",
                "content": "#### STEPS\\n- Select those id\\'s from first table which are not in second table then select those id\\'s from second table which are not in first table,\\n- Take union of both result sets\\n- Sort the result set by `employee_id`\\n\\n```\\n\\nSELECT\\n    e.employee_id \\n    FROM Employees as e \\n        WHERE e.employee_id \\n            NOT IN (SELECT employee_id FROM Salaries) \\n    UNION\\nSELECT s.employee_id\\n    FROM Salaries as s\\n        WHERE s.employee_id\\n            NOT IN (SELECT employee_id FROM Employees)\\n    \\n    ORDER BY employee_id;\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSELECT\\n    e.employee_id \\n    FROM Employees as e \\n        WHERE e.employee_id \\n            NOT IN (SELECT employee_id FROM Salaries) \\n    UNION\\nSELECT s.employee_id\\n    FROM Salaries as s\\n        WHERE s.employee_id\\n            NOT IN (SELECT employee_id FROM Employees)\\n    \\n    ORDER BY employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2332725,
                "title": "mysql-left-join-union",
                "content": "```\\nselect      e.employee_id\\nfrom        employees e\\nleft join   salaries s\\non          e.employee_id = s.employee_id\\nwhere       s.salary is null\\n\\nUNION\\n\\nselect      s.employee_id\\nfrom        salaries s\\nleft join   employees e\\non          s.employee_id = e.employee_id\\nwhere       e.name is null\\n\\norder by    1\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nselect      e.employee_id\\nfrom        employees e\\nleft join   salaries s\\non          e.employee_id = s.employee_id\\nwhere       s.salary is null\\n\\nUNION\\n\\nselect      s.employee_id\\nfrom        salaries s\\nleft join   employees e\\non          s.employee_id = e.employee_id\\nwhere       e.name is null\\n\\norder by    1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2298241,
                "title": "two-ms-sql-solution",
                "content": "Two solutions for MS SQL Server.\\n\\nThe first one seems quite long but it\\'s more like a step-by-step approach, easy to follow and understand.\\n\\nWe create a table based on Employees, join it with Salaries on \\'employee_id\\' from both. The question here is: what ids do we have in the first table that are not present in the second table? We do the same in reverse for Salaries and finally Union the two tables.\\n\\n```\\nSELECT \\n    e.employee_id\\nFROM \\n    Employees AS e\\nLEFT JOIN\\n    Salaries AS s\\n        ON e.employee_id = s.employee_id\\nWHERE s.employee_id IS NULL\\n\\nUNION\\n\\nSELECT \\n    s.employee_id\\nFROM \\n    Salaries AS s\\nLEFT JOIN\\n    Employees AS e\\n        ON s.employee_id = e.employee_id\\nWHERE e.employee_id IS NULL\\nORDER BY e.employee_id\\n```\\n\\nOr we can achieve the same with COALESCE in more elegant way. COALESCE returns the first NOT NULL value.\\n\\n```\\nSELECT\\n    COALESCE(e.employee_id, s.employee_id) AS employee_id\\nFROM \\n    Employees AS e\\nFULL JOIN\\n    Salaries AS s\\n        ON e.employee_id = s.employee_id\\nWHERE\\n    e.name IS NULL OR s.salary IS NULL\\nORDER BY employee_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT \\n    e.employee_id\\nFROM \\n    Employees AS e\\nLEFT JOIN\\n    Salaries AS s\\n        ON e.employee_id = s.employee_id\\nWHERE s.employee_id IS NULL\\n\\nUNION\\n\\nSELECT \\n    s.employee_id\\nFROM \\n    Salaries AS s\\nLEFT JOIN\\n    Employees AS e\\n        ON s.employee_id = e.employee_id\\nWHERE e.employee_id IS NULL\\nORDER BY e.employee_id\\n```\n```\\nSELECT\\n    COALESCE(e.employee_id, s.employee_id) AS employee_id\\nFROM \\n    Employees AS e\\nFULL JOIN\\n    Salaries AS s\\n        ON e.employee_id = s.employee_id\\nWHERE\\n    e.name IS NULL OR s.salary IS NULL\\nORDER BY employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2271349,
                "title": "simple-solution-using-union",
                "content": "# Write your MySQL query statement below\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) union\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees) order by employee_id",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "# Write your MySQL query statement below\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) union\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees) order by employee_id",
                "codeTag": "Unknown"
            },
            {
                "id": 2252856,
                "title": "mysql-simple-query-using-union",
                "content": "```\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees) order by employee_id;\\n```",
                "solutionTags": [],
                "code": "```\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees) order by employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2214339,
                "title": "easy-solution-with-explanation",
                "content": "```\\n# Find all the employee_ids that have salaries but without names\\nSELECT s.employee_id FROM Salaries s LEFT JOIN Employees e \\nON e.employee_id = s.employee_id \\nWHERE e.name IS NULL\\n\\n# Combine\\nUNION\\n\\n# Find all the employee_ids that have names but without salaries\\nSELECT e.employee_id FROM Employees e LEFT JOIN Salaries s\\nON e.employee_id = s.employee_id \\nWHERE s.salary IS NULL\\n\\n# Reorder the result by employee_id in the ascending order\\nORDER BY employee_id;\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\n# Find all the employee_ids that have salaries but without names\\nSELECT s.employee_id FROM Salaries s LEFT JOIN Employees e \\nON e.employee_id = s.employee_id \\nWHERE e.name IS NULL\\n\\n# Combine\\nUNION\\n\\n# Find all the employee_ids that have names but without salaries\\nSELECT e.employee_id FROM Employees e LEFT JOIN Salaries s\\nON e.employee_id = s.employee_id \\nWHERE s.salary IS NULL\\n\\n# Reorder the result by employee_id in the ascending order\\nORDER BY employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2212020,
                "title": "easy-solution-using-case",
                "content": "```\\nSELECT case\\n        WHEN e.employee_id is null THEN s.employee_id\\n        WHEN s.salary is NULL THEN e.employee_id\\n        END AS employee_id\\nFROM employees e FULL JOIN salaries s ON e.employee_id = s.employee_id\\n\\nWHERE e.employee_id is null or s.salary is NULL\\n\\nORDER BY employee_id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT case\\n        WHEN e.employee_id is null THEN s.employee_id\\n        WHEN s.salary is NULL THEN e.employee_id\\n        END AS employee_id\\nFROM employees e FULL JOIN salaries s ON e.employee_id = s.employee_id\\n\\nWHERE e.employee_id is null or s.salary is NULL\\n\\nORDER BY employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2190068,
                "title": "simple-approach-w-o-using-union",
                "content": "```\\nSELECT COALESCE(E.EMPLOYEE_ID,S.EMPLOYEE_ID) AS EMPLOYEE_ID\\nFROM EMPLOYEES E\\nFULL OUTER JOIN SALARIES S ON E.EMPLOYEE_ID=S.EMPLOYEE_ID\\nWHERE E.NAME IS NULL OR S.SALARY IS NULL\\nORDER BY COALESCE(E.EMPLOYEE_ID,S.EMPLOYEE_ID)\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT COALESCE(E.EMPLOYEE_ID,S.EMPLOYEE_ID) AS EMPLOYEE_ID\\nFROM EMPLOYEES E\\nFULL OUTER JOIN SALARIES S ON E.EMPLOYEE_ID=S.EMPLOYEE_ID\\nWHERE E.NAME IS NULL OR S.SALARY IS NULL\\nORDER BY COALESCE(E.EMPLOYEE_ID,S.EMPLOYEE_ID)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2119002,
                "title": "mysql-solution-2-approaches",
                "content": "**Approach 1:**\\n```\\nSELECT employee_id FROM Employees \\nWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id FROM Salaries \\nWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id;\\n```\\n\\n\\n**Approach 2:**\\n```\\nSELECT Sub.employee_id FROM\\n(SELECT e.employee_id, name, salary\\nFROM Employees AS e \\nLEFT JOIN \\nSalaries AS s\\nON e.employee_id = s.employee_id\\nUNION\\nSELECT s.employee_id, name, salary\\nFROM Employees AS e \\nRIGHT JOIN \\nSalaries AS s\\nON e.employee_id = s.employee_id) AS Sub\\nWHERE Sub.name IS NULL OR Sub.salary IS NULL\\nORDER BY Sub.Employee_id;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nSELECT employee_id FROM Employees \\nWHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id FROM Salaries \\nWHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id;\\n```\n```\\nSELECT Sub.employee_id FROM\\n(SELECT e.employee_id, name, salary\\nFROM Employees AS e \\nLEFT JOIN \\nSalaries AS s\\nON e.employee_id = s.employee_id\\nUNION\\nSELECT s.employee_id, name, salary\\nFROM Employees AS e \\nRIGHT JOIN \\nSalaries AS s\\nON e.employee_id = s.employee_id) AS Sub\\nWHERE Sub.name IS NULL OR Sub.salary IS NULL\\nORDER BY Sub.Employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2106131,
                "title": "sql-with-join-and-union",
                "content": "``` select employee_id from employees\\nwhere employee_id not in\\n(select employees.employee_id from \\nemployees \\njoin \\nsalaries \\nwhere employees.employee_id = salaries.employee_id)\\nunion \\nselect employee_id from salaries\\nwhere employee_id not in\\n(select employees.employee_id from \\nemployees \\njoin \\nsalaries \\nwhere employees.employee_id = salaries.employee_id)\\norder by employee_id\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "``` select employee_id from employees\\nwhere employee_id not in\\n(select employees.employee_id from \\nemployees \\njoin \\nsalaries \\nwhere employees.employee_id = salaries.employee_id)\\nunion \\nselect employee_id from salaries\\nwhere employee_id not in\\n(select employees.employee_id from \\nemployees \\njoin \\nsalaries \\nwhere employees.employee_id = salaries.employee_id)\\norder by employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2088932,
                "title": "the-easiest-solution-using-union",
                "content": "Runtime: 564 ms, faster than 46.37% of MySQL online submissions for Employees With Missing Information.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Employees With Missing Information.\\n\\n```\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by(employee_id);\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by(employee_id);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2088607,
                "title": "mssql-solution-with-iif",
                "content": "```\\nSELECT\\n    IIF(e.employee_id IS NULL, s.employee_id, e.employee_id) AS employee_id\\nFROM\\n    Employees e\\n    FULL OUTER JOIN Salaries s ON e.employee_id = s.employee_id\\nWHERE\\n    e.name IS NULL \\n    OR s.salary IS NULL\\nORDER BY\\n    IIF(e.employee_id IS NULL, s.employee_id, e.employee_id)\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT\\n    IIF(e.employee_id IS NULL, s.employee_id, e.employee_id) AS employee_id\\nFROM\\n    Employees e\\n    FULL OUTER JOIN Salaries s ON e.employee_id = s.employee_id\\nWHERE\\n    e.name IS NULL \\n    OR s.salary IS NULL\\nORDER BY\\n    IIF(e.employee_id IS NULL, s.employee_id, e.employee_id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2063146,
                "title": "mysql-2-simple-solutions-using-union-full-outer-join",
                "content": "***Using UNION + Where_Not_In***\\n```\\nSELECT EMPLOYEE_ID FROM EMPLOYEES WHERE EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID FROM SALARIES)\\nUNION\\nSELECT EMPLOYEE_ID FROM SALARIES WHERE EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID FROM EMPLOYEES)\\nORDER BY EMPLOYEE_ID;\\n```\\n***Using Full Outer Join***\\n```\\nSELECT T.EMPLOYEE_ID\\nFROM(\\n    SELECT * FROM EMPLOYEES LEFT JOIN SALARIES USING(EMPLOYEE_ID)\\n    UNION\\n    SELECT * FROM EMPLOYEES RIGHT JOIN SALARIES USING(EMPLOYEE_ID)\\n)\\nAS T\\nWHERE T.SALARY IS NULL OR T.NAME IS NULL\\nORDER BY T.EMPLOYEE_ID;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT EMPLOYEE_ID FROM EMPLOYEES WHERE EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID FROM SALARIES)\\nUNION\\nSELECT EMPLOYEE_ID FROM SALARIES WHERE EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID FROM EMPLOYEES)\\nORDER BY EMPLOYEE_ID;\\n```\n```\\nSELECT T.EMPLOYEE_ID\\nFROM(\\n    SELECT * FROM EMPLOYEES LEFT JOIN SALARIES USING(EMPLOYEE_ID)\\n    UNION\\n    SELECT * FROM EMPLOYEES RIGHT JOIN SALARIES USING(EMPLOYEE_ID)\\n)\\nAS T\\nWHERE T.SALARY IS NULL OR T.NAME IS NULL\\nORDER BY T.EMPLOYEE_ID;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2059321,
                "title": "1965-employees-with-missing-information-why-full-outer-join-is-not-possible",
                "content": "select *\\nfrom employees\\nfull outer join salaries\\non employees.employee_id=salaries.employee_id;\\n\\nwhy full outer join is not possible here?",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select *\\nfrom employees\\nfull outer join salaries\\non employees.employee_id=salaries.employee_id;\\n\\nwhy full outer join is not possible here?",
                "codeTag": "Unknown"
            },
            {
                "id": 2043075,
                "title": "simple-mysql-union-and-not-in",
                "content": "```\\nselect employee_id from Employees where employee_id not in (select employee_id from salaries)\\nUNION \\nselect employee_id from salaries where employee_id not in (select employee_id from employees)\\norder by employee_id asc\\n```",
                "solutionTags": [],
                "code": "```\\nselect employee_id from Employees where employee_id not in (select employee_id from salaries)\\nUNION \\nselect employee_id from salaries where employee_id not in (select employee_id from employees)\\norder by employee_id asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2031700,
                "title": "mysql-solution-with-union-faster-than-98-31",
                "content": "```\\nselect e.employee_id from Employees as e where employee_id not in (select employee_id from Salaries) \\nunion\\nselect s.employee_id from Salaries as s where employee_id not in (select employee_id from Employees) order by employee_id asc;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect e.employee_id from Employees as e where employee_id not in (select employee_id from Salaries) \\nunion\\nselect s.employee_id from Salaries as s where employee_id not in (select employee_id from Employees) order by employee_id asc;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1938288,
                "title": "mysql-full-outer-join-solution",
                "content": "```\\nwith temp as\\n(select e.employee_id, e.name,s.salary from Employees e left join Salaries s on e.employee_id = s.employee_id\\nunion\\nselect s.employee_id, e.name,s.salary from Salaries s left join Employees e on e.employee_id = s.employee_id)\\n\\nselect employee_id from temp where name is null or salary is null order by employee_id;\\n```",
                "solutionTags": [],
                "code": "```\\nwith temp as\\n(select e.employee_id, e.name,s.salary from Employees e left join Salaries s on e.employee_id = s.employee_id\\nunion\\nselect s.employee_id, e.name,s.salary from Salaries s left join Employees e on e.employee_id = s.employee_id)\\n\\nselect employee_id from temp where name is null or salary is null order by employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1894892,
                "title": "union-all-faster-than-70",
                "content": "select a.employee_id\\nfrom \\n\\t(select employee_id from Employees e\\n\\tunion all\\n\\tselect s.employee_idfrom Salaries s) a\\ngroup by a.employee_id\\nhaving count(a.employee_id) = 1\\norder by a.employee_id",
                "solutionTags": [],
                "code": "select a.employee_id\\nfrom \\n\\t(select employee_id from Employees e\\n\\tunion all\\n\\tselect s.employee_idfrom Salaries s) a\\ngroup by a.employee_id\\nhaving count(a.employee_id) = 1\\norder by a.employee_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1596516,
                "title": "simple-and-easy-solution",
                "content": "select coalesce(e.employee_id,s.employee_id) employee_id\\nfrom employees e full outer join salaries s \\non e.employee_id = s.employee_id\\nwhere name is null or salary is null\\norder by 1",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "select coalesce(e.employee_id,s.employee_id) employee_id\\nfrom employees e full outer join salaries s \\non e.employee_id = s.employee_id\\nwhere name is null or salary is null\\norder by 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1469936,
                "title": "mysql-left-and-right-join-with-union",
                "content": "SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere s.salary is null\\n\\nUNION\\nSELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.name is null\\norder by employee_id",
                "solutionTags": [],
                "code": "SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere s.salary is null\\n\\nUNION\\nSELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.name is null\\norder by employee_id",
                "codeTag": "Unknown"
            },
            {
                "id": 4077308,
                "title": "pandas-sql-easy-employees-with-missing-information",
                "content": "[see the Successfully Accepted Submission](https://leetcode.com/submissions/detail/1056242323/)\\n\\n```\\nimport pandas as pd\\n\\ndef find_employees(employees: pd.DataFrame, salaries: pd.DataFrame) -> pd.DataFrame:\\n    # First, we must get unique employee IDs from both DataFrames, so first we concatenate two Series, one containing employee IDs from the `employees` DataFrame and the other containing employee IDs from the `salaries` DataFrame. After that, we can obtain the unique values from the combined Series.\\n    all_employee_ids = pd.concat([employees[\\'employee_id\\'], salaries[\\'employee_id\\']]).unique()\\n\\n    # Then, we must find employee IDs that are in one DataFrame but not in the other\\n    missing_employee_ids = [emp_id for emp_id in all_employee_ids if emp_id not in employees[\\'employee_id\\'].values or emp_id not in salaries[\\'employee_id\\'].values]\\n\\n    # After that, we create a DataFrame with the missing employee IDs\\n    employee_df = pd.DataFrame({\\'employee_id\\': missing_employee_ids})\\n\\n    # In the next step, we sort the result by \\'employee_id\\'\\n    sorted_employee = employee_df.sort_values(by=\\'employee_id\\')\\n\\n    # Finally, we reset the index\\n    structured_employee = sorted_employee.reset_index(drop=True)\\n\\n    return structured_employee\\n```\\n\\n**SQL**\\n\\n[see the Successfully Accepted Submission](https://leetcode.com/submissions/detail/1061744922/)\\n\\n```\\nSELECT employee_id \\nFROM Employees \\nWHERE employee_id not in (SELECT employee_id FROM Salaries)\\n\\nUNION\\n\\nSELECT employee_id \\nFROM Salaries \\nWHERE employee_id not in (SELECT employee_id FROM Employees) \\n\\nORDER BY employee_id;\\n```\\n\\n```\\n-- Select \\'employee_id\\' values that are not present in the \\'Salaries\\' table\\n-- by using a subquery with a NOT IN clause\\nSELECT employee_id \\nFROM Employees \\nWHERE employee_id not in (SELECT employee_id FROM Salaries)\\n\\n-- Combine the results with the following query using UNION\\nUNION\\n\\n-- Select \\'employee_id\\' values that are not present in the \\'Employees\\' table\\n-- by using a subquery with a NOT IN clause\\nSELECT employee_id \\nFROM Salaries \\nWHERE employee_id not in (SELECT employee_id FROM Employees)\\n\\n-- Order the combined results by \\'employee_id\\' in ascending order\\nORDER BY employee_id;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/f7c12c6a-8d13-4dab-a774-ef51d4e1d511_1695382421.2508502.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_employees(employees: pd.DataFrame, salaries: pd.DataFrame) -> pd.DataFrame:\\n    # First, we must get unique employee IDs from both DataFrames, so first we concatenate two Series, one containing employee IDs from the `employees` DataFrame and the other containing employee IDs from the `salaries` DataFrame. After that, we can obtain the unique values from the combined Series.\\n    all_employee_ids = pd.concat([employees[\\'employee_id\\'], salaries[\\'employee_id\\']]).unique()\\n\\n    # Then, we must find employee IDs that are in one DataFrame but not in the other\\n    missing_employee_ids = [emp_id for emp_id in all_employee_ids if emp_id not in employees[\\'employee_id\\'].values or emp_id not in salaries[\\'employee_id\\'].values]\\n\\n    # After that, we create a DataFrame with the missing employee IDs\\n    employee_df = pd.DataFrame({\\'employee_id\\': missing_employee_ids})\\n\\n    # In the next step, we sort the result by \\'employee_id\\'\\n    sorted_employee = employee_df.sort_values(by=\\'employee_id\\')\\n\\n    # Finally, we reset the index\\n    structured_employee = sorted_employee.reset_index(drop=True)\\n\\n    return structured_employee\\n```\n```\\nSELECT employee_id \\nFROM Employees \\nWHERE employee_id not in (SELECT employee_id FROM Salaries)\\n\\nUNION\\n\\nSELECT employee_id \\nFROM Salaries \\nWHERE employee_id not in (SELECT employee_id FROM Employees) \\n\\nORDER BY employee_id;\\n```\n```\\n-- Select \\'employee_id\\' values that are not present in the \\'Salaries\\' table\\n-- by using a subquery with a NOT IN clause\\nSELECT employee_id \\nFROM Employees \\nWHERE employee_id not in (SELECT employee_id FROM Salaries)\\n\\n-- Combine the results with the following query using UNION\\nUNION\\n\\n-- Select \\'employee_id\\' values that are not present in the \\'Employees\\' table\\n-- by using a subquery with a NOT IN clause\\nSELECT employee_id \\nFROM Salaries \\nWHERE employee_id not in (SELECT employee_id FROM Employees)\\n\\n-- Order the combined results by \\'employee_id\\' in ascending order\\nORDER BY employee_id;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3379952,
                "title": "employees-with-missing-information-union",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nselect e.employee_id from Employees e left join salaries s\\non e.employee_id=s.employee_id where s.salary is null\\nunion\\nselect s.employee_id from Salaries s left join employees e\\non e.employee_id=s.employee_id where e.name is null\\norder by employee_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nselect e.employee_id from Employees e left join salaries s\\non e.employee_id=s.employee_id where s.salary is null\\nunion\\nselect s.employee_id from Salaries s left join employees e\\non e.employee_id=s.employee_id where e.name is null\\norder by employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3080970,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT employee_id\\nFROM `Employees`\\nWHERE employee_id NOT IN (\\n    SELECT employee_id\\n    FROM `Salaries`\\n)\\nUNION\\nSELECT employee_id\\nFROM `Salaries`\\nWHERE employee_id NOT IN (\\n    SELECT employee_id\\n    FROM `Employees`\\n)\\nORDER BY employee_id ASC;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT employee_id\\nFROM `Employees`\\nWHERE employee_id NOT IN (\\n    SELECT employee_id\\n    FROM `Salaries`\\n)\\nUNION\\nSELECT employee_id\\nFROM `Salaries`\\nWHERE employee_id NOT IN (\\n    SELECT employee_id\\n    FROM `Employees`\\n)\\nORDER BY employee_id ASC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3052381,
                "title": "simple-way",
                "content": "# Intuition\\nThis what I think.\\n\\n# Approach\\nlogical thinking\\n\\n# Complexity\\n- Time complexity: none\\n---\\n\\n- Space complexity: none\\n---\\n\\n# Code\\n```\\nselect employee_id\\nfrom employees\\nwhere employee_id not in (\\n    select employee_id\\n    from salaries\\n)\\nunion\\nselect employee_id\\nfrom salaries\\nwhere employee_id not in (\\n    select employee_id\\n    from employees\\n)\\norder by employee_id\\n;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect employee_id\\nfrom employees\\nwhere employee_id not in (\\n    select employee_id\\n    from salaries\\n)\\nunion\\nselect employee_id\\nfrom salaries\\nwhere employee_id not in (\\n    select employee_id\\n    from employees\\n)\\norder by employee_id\\n;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2837516,
                "title": "can-anyone-explain",
                "content": "what am I doing wrong?\\n\\nSELECT t.employee_id\\nFROM\\n(SELECT *\\nFROM Employees EM\\nLEFT JOIN Salaries SA ON EM.employee_id = SA.employee_id\\nUNION\\nSELECT *\\nFROM Employees EM\\nRIGHT JOIN Salaries SA ON EM.employee_id = SA.employee_id) AS t\\nWHERE t.salary is null or t.name is null\\nORDER BY t.employee_id;",
                "solutionTags": [],
                "code": "what am I doing wrong?\\n\\nSELECT t.employee_id\\nFROM\\n(SELECT *\\nFROM Employees EM\\nLEFT JOIN Salaries SA ON EM.employee_id = SA.employee_id\\nUNION\\nSELECT *\\nFROM Employees EM\\nRIGHT JOIN Salaries SA ON EM.employee_id = SA.employee_id) AS t\\nWHERE t.salary is null or t.name is null\\nORDER BY t.employee_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 2738580,
                "title": "why-is-solution-is-incorrect",
                "content": "SELECT *\\nFROM employees e\\nJOIN salaries s\\nUSING (employee_id)\\nWHERE e.name IS NULL OR s.salary IS NULL\\nORDER BY e.employee_id",
                "solutionTags": [],
                "code": "SELECT *\\nFROM employees e\\nJOIN salaries s\\nUSING (employee_id)\\nWHERE e.name IS NULL OR s.salary IS NULL\\nORDER BY e.employee_id",
                "codeTag": "Unknown"
            },
            {
                "id": 2679360,
                "title": "mysql-union-solution",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT employee_id FROM Employees WHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION \\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT employee_id FROM Employees WHERE employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION \\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2636551,
                "title": "employess-with-missing-information-sql",
                "content": "SELECT employee_id FROM employees\\nWHERE employee_id NOT IN (SELECT employee_id FROM salaries)\\nUNION\\nSELECT employee_id FROM salaries\\nWHERE employee_id NOT IN (SELECT employee_id FROM employees)\\nORDER BY employee_id;",
                "solutionTags": [],
                "code": "SELECT employee_id FROM employees\\nWHERE employee_id NOT IN (SELECT employee_id FROM salaries)\\nUNION\\nSELECT employee_id FROM salaries\\nWHERE employee_id NOT IN (SELECT employee_id FROM employees)\\nORDER BY employee_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 2620898,
                "title": "using-union-left-and-right-join",
                "content": "```\\n# Write your MySQL query statement below\\n(select employee_id\\nfrom Employees\\nwhere employee_id not in(select employee_id from Salaries))\\nunion\\n(select employee_id\\nfrom Salaries\\nwhere  employee_id not in(select employee_id from Employees)) order by employee_id;\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\n(select employee_id\\nfrom Employees\\nwhere employee_id not in(select employee_id from Salaries))\\nunion\\n(select employee_id\\nfrom Salaries\\nwhere  employee_id not in(select employee_id from Employees)) order by employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2572506,
                "title": "1965-employees-with-missing-information",
                "content": "MySQL Solution\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;",
                "solutionTags": [],
                "code": "MySQL Solution\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 2563665,
                "title": "simple-solution-with-explanation",
                "content": "```\\n# Write your MySQL query statement below\\n# By Using Full order join,we join all left join and right join.\\n# As FULL OUTER JOIN is not available in leetcode --> so we join it using left join and right join\\n\\nSELECT Employees.employee_id FROM Employees\\nLEFT JOIN Salaries ON Employees.employee_id = Salaries.employee_id where Salaries.employee_id IS NULL\\n# As Left join --> show all left column + Inner Join that\\'s why if Salaries.employee.id is NULL then it is not present in Salaries.\\nUNION\\nSELECT Salaries.employee_id FROM Employees\\nRIGHT JOIN Salaries ON Employees.employee_id = Salaries.employee_id where Employees.employee_id IS NULL\\n# As Right join --> show all Right column + Inner Join that\\'s why if Employees.employee.id is NULL then it is not present in Employees.\\norder by employee_id;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n# By Using Full order join,we join all left join and right join.\\n# As FULL OUTER JOIN is not available in leetcode --> so we join it using left join and right join\\n\\nSELECT Employees.employee_id FROM Employees\\nLEFT JOIN Salaries ON Employees.employee_id = Salaries.employee_id where Salaries.employee_id IS NULL\\n# As Left join --> show all left column + Inner Join that\\'s why if Salaries.employee.id is NULL then it is not present in Salaries.\\nUNION\\nSELECT Salaries.employee_id FROM Employees\\nRIGHT JOIN Salaries ON Employees.employee_id = Salaries.employee_id where Employees.employee_id IS NULL\\n# As Right join --> show all Right column + Inner Join that\\'s why if Employees.employee.id is NULL then it is not present in Employees.\\norder by employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2554660,
                "title": "sql-easiest-solution",
                "content": "```\\nselect employee_id from employees where employee_id not in (\\n\\nselect employee_id from salaries \\n)\\nunion \\nselect employee_id from salaries where employee_id not in(\\nselect employee_id from employees\\n)\\norder by employee_id\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect employee_id from employees where employee_id not in (\\n\\nselect employee_id from salaries \\n)\\nunion \\nselect employee_id from salaries where employee_id not in(\\nselect employee_id from employees\\n)\\norder by employee_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2539633,
                "title": "full-join-in-mysql",
                "content": "I didn\\'t knew that mysql doesn\\'t have full join but after googling came to know that union comes to rescue so heres the solution,\\n\\n***Approach : Do the full join which will give the data along with null values so use where filter get empid\\'s where the name or salary is null and at last order by***\\n\\n```\\nselect sub.employee_id from \\n(select  from \\nemployees e left join salaries s\\nusing (employee_id)\\nunion \\nselect  from \\nemployees e right join salaries s\\nusing (employee_id) ) as sub \\nwhere sub.name is null or \\nsub.salary is null\\norder by sub.employee_id ;\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect sub.employee_id from \\n(select  from \\nemployees e left join salaries s\\nusing (employee_id)\\nunion \\nselect  from \\nemployees e right join salaries s\\nusing (employee_id) ) as sub \\nwhere sub.name is null or \\nsub.salary is null\\norder by sub.employee_id ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2528184,
                "title": "clean-easy-solution-with-statement-union",
                "content": "```\\nWITH \\n\\t-- What employee_ids do we have in employees table that is not currently in salaries table?\\n    e AS (\\n        SELECT employee_id\\n        FROM employees\\n        WHERE employee_id NOT IN (\\n            SELECT employee_id FROM salaries\\n        )\\n    ), \\n\\t-- What employee_ids do we have in salaries table that is not currently in employees table?\\n    s AS (\\n        SELECT employee_id\\n        FROM salaries\\n        WHERE employee_id NOT IN (\\n            SELECT employee_id FROM employees\\n        )\\n    )\\n\\n-- Main query combining what we got from querying previous 2 tables\\nSELECT * FROM e \\nUNION \\nSELECT * FROM s\\nORDER BY employee_id ASC\\n```",
                "solutionTags": [],
                "code": "```\\nWITH \\n\\t-- What employee_ids do we have in employees table that is not currently in salaries table?\\n    e AS (\\n        SELECT employee_id\\n        FROM employees\\n        WHERE employee_id NOT IN (\\n            SELECT employee_id FROM salaries\\n        )\\n    ), \\n\\t-- What employee_ids do we have in salaries table that is not currently in employees table?\\n    s AS (\\n        SELECT employee_id\\n        FROM salaries\\n        WHERE employee_id NOT IN (\\n            SELECT employee_id FROM employees\\n        )\\n    )\\n\\n-- Main query combining what we got from querying previous 2 tables\\nSELECT * FROM e \\nUNION \\nSELECT * FROM s\\nORDER BY employee_id ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2507054,
                "title": "2-solutions-where-not-in-left-join",
                "content": "faster: \\n```\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees) \\norder by employee_id\\n```\\n```\\nselect e.employee_id from Employees e\\nleft join Salaries s on e.employee_id = s.employee_id\\nwhere salary is NULL \\nunion \\nselect s.employee_id from Salaries s\\nleft join Employees e on e.employee_id = s.employee_id\\nwhere name is NULL \\norder by employee_id\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees) \\norder by employee_id\\n```\n```\\nselect e.employee_id from Employees e\\nleft join Salaries s on e.employee_id = s.employee_id\\nwhere salary is NULL \\nunion \\nselect s.employee_id from Salaries s\\nleft join Employees e on e.employee_id = s.employee_id\\nwhere name is NULL \\norder by employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2502252,
                "title": "mysql-solution-faster-than-93-clean-easy",
                "content": "Please UPVOTE \\uD83D\\uDD25\\n```\\nSELECT Salaries.employee_id FROM Salaries\\nWHERE \\n\\tNOT EXISTS  \\n\\t\\t\\t(SELECT 1 FROM  Employees WHERE  Salaries.employee_id = Employees.employee_id  )\\nUNION ALL    # union all tables \\nSELECT Employees.Employee_id FROM Employees\\nWHERE \\n\\tNOT EXISTS\\n\\t\\t\\t(SELECT 1 FROM Salaries WHERE Salaries.employee_id = Employees.employee_id )\\nORDER BY Employee_id\\n```\\nPlease UPVOTE \\uD83D\\uDD25",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nSELECT Salaries.employee_id FROM Salaries\\nWHERE \\n\\tNOT EXISTS  \\n\\t\\t\\t(SELECT 1 FROM  Employees WHERE  Salaries.employee_id = Employees.employee_id  )\\nUNION ALL    # union all tables \\nSELECT Employees.Employee_id FROM Employees\\nWHERE \\n\\tNOT EXISTS\\n\\t\\t\\t(SELECT 1 FROM Salaries WHERE Salaries.employee_id = Employees.employee_id )\\nORDER BY Employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2474131,
                "title": "simple-mysql-solution-easy-understanding",
                "content": "```\\nSelect employee_id from employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from salaries where employee_id not in (select employee_id from employees)\\norder by employee_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect employee_id from employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from salaries where employee_id not in (select employee_id from employees)\\norder by employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456535,
                "title": "easy-solution-mysql-faster-than-99-99",
                "content": "```\\nSELECT\\n    employee_id\\n\\nFROM (\\nSELECT\\n    e.employee_id\\nFROM Employees e\\nLEFT JOIN Salaries s\\nON e.employee_id = s.employee_id\\nWHERE s.salary IS NULL\\n\\nUNION \\n\\nSELECT\\n    s.employee_id\\nFROM Salaries s\\nLEFT JOIN Employees e\\nON s.employee_id = e.employee_id\\nWHERE e.name IS NULL\\n) der\\nORDER BY\\n    employee_id;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e4e5d150-99c2-4ab4-ad08-cdd36fe59470_1661052867.029396.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    employee_id\\n\\nFROM (\\nSELECT\\n    e.employee_id\\nFROM Employees e\\nLEFT JOIN Salaries s\\nON e.employee_id = s.employee_id\\nWHERE s.salary IS NULL\\n\\nUNION \\n\\nSELECT\\n    s.employee_id\\nFROM Salaries s\\nLEFT JOIN Employees e\\nON s.employee_id = e.employee_id\\nWHERE e.name IS NULL\\n) der\\nORDER BY\\n    employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2427611,
                "title": "easy-mysql-solution",
                "content": "```\\nSELECT employee_id FROM Employees\\nWHERE employee_id NOT IN (SELECT DISTINCT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id FROM Salaries\\nWHERE employee_id NOT IN (SELECT DISTINCT employee_id FROM Employees)\\nORDER BY employee_id ASC;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT employee_id FROM Employees\\nWHERE employee_id NOT IN (SELECT DISTINCT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id FROM Salaries\\nWHERE employee_id NOT IN (SELECT DISTINCT employee_id FROM Employees)\\nORDER BY employee_id ASC;",
                "codeTag": "Unknown"
            },
            {
                "id": 2413520,
                "title": "straightforward-sql-solution-memory-beats-100",
                "content": "```\\n(select e.employee_id from employees e left join salaries s on e.employee_id = s.employee_id where s.salary is null)\\nunion\\n(select s.employee_id from employees e right join salaries s on e.employee_id = s.employee_id where e.name is null)\\norder by employee_id\\n```",
                "solutionTags": [],
                "code": "```\\n(select e.employee_id from employees e left join salaries s on e.employee_id = s.employee_id where s.salary is null)\\nunion\\n(select s.employee_id from employees e right join salaries s on e.employee_id = s.employee_id where e.name is null)\\norder by employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2380059,
                "title": "mysql-solution-using-union",
                "content": "```\\n(select employee_id from Employees where employee_id not in (select employee_id from Salaries))\\nunion\\n(select employee_id from Salaries where employee_id not in  (select employee_id from Employees))\\norder by employee_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\n(select employee_id from Employees where employee_id not in (select employee_id from Salaries))\\nunion\\n(select employee_id from Salaries where employee_id not in  (select employee_id from Employees))\\norder by employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2369453,
                "title": "easy-to-understand-solution",
                "content": "\\'\\'\\'\\n\\n\\tselect e.employee_id from Employees e\\n\\t\\tleft join Salaries s on e.employee_id = s.employee_id\\n\\t\\twhere s.salary is NULL    \\n\\tunion\\n\\tselect s.employee_id from Salaries s\\n\\t\\tleft join Employees e on s.employee_id=e.employee_id\\n\\t\\twhere e.name is NULL\\n\\torder by employee_id;\\n\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\'\\'\\'\\n\\n\\tselect e.employee_id from Employees e\\n\\t\\tleft join Salaries s on e.employee_id = s.employee_id\\n\\t\\twhere s.salary is NULL    \\n\\tunion\\n\\tselect s.employee_id from Salaries s\\n\\t\\tleft join Employees e on s.employee_id=e.employee_id\\n\\t\\twhere e.name is NULL\\n\\torder by employee_id;\\n\\n\\'\\'\\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2359134,
                "title": "c-step-by-step-explanation-union-join-not-in",
                "content": "```\\n/*\\n1) this will select the employees who are in the salary table :\\n\\nSELECT e.employee_id as employee_id\\nFROM Employees AS e INNER JOIN Salaries AS s\\nWHERE e.employee_id=s.employee_id;\\n\\n\\n2) now we want the column showing if The employee\\'s name is missing or\\nThe employee\\'s salary is missing from the table above :\\n\\nthis will select if the employee\\'s name is missing:\\nSELECT e.employee_id FROM Employees as e WHERE e.employee_id NOT IN\\n(SELECT e.employee_id as employee_id\\nFROM Employees AS e INNER JOIN Salaries AS s\\nWHERE e.employee_id=s.employee_id) \\n\\n\\nthis will select if the employee\\'s name is missing:\\n\\nSELECT s.employee_id FROM Salaries as s WHERE s.employee_id NOT IN\\n(SELECT e.employee_id as employee_id\\nFROM Employees AS e INNER JOIN Salaries AS s\\nWHERE e.employee_id=s.employee_id) ORDER BY employee_id\\n\\n3) as we want both the values in one column , we \\nwill take union of the above 2 queries:\\n*/\\n\\nSELECT e.employee_id FROM Employees as e WHERE e.employee_id NOT IN\\n(SELECT e.employee_id as employee_id\\nFROM Employees AS e INNER JOIN Salaries AS s\\nWHERE e.employee_id=s.employee_id) \\nUNION\\nSELECT s.employee_id FROM Salaries as s WHERE s.employee_id NOT IN\\n(SELECT e.employee_id as employee_id\\nFROM Employees AS e INNER JOIN Salaries AS s\\nWHERE e.employee_id=s.employee_id) ORDER BY employee_id\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n1) this will select the employees who are in the salary table :\\n\\nSELECT e.employee_id as employee_id\\nFROM Employees AS e INNER JOIN Salaries AS s\\nWHERE e.employee_id=s.employee_id;\\n\\n\\n2) now we want the column showing if The employee\\'s name is missing or\\nThe employee\\'s salary is missing from the table above :\\n\\nthis will select if the employee\\'s name is missing:\\nSELECT e.employee_id FROM Employees as e WHERE e.employee_id NOT IN\\n(SELECT e.employee_id as employee_id\\nFROM Employees AS e INNER JOIN Salaries AS s\\nWHERE e.employee_id=s.employee_id) \\n\\n\\nthis will select if the employee\\'s name is missing:\\n\\nSELECT s.employee_id FROM Salaries as s WHERE s.employee_id NOT IN\\n(SELECT e.employee_id as employee_id\\nFROM Employees AS e INNER JOIN Salaries AS s\\nWHERE e.employee_id=s.employee_id) ORDER BY employee_id\\n\\n3) as we want both the values in one column , we \\nwill take union of the above 2 queries:\\n*/\\n\\nSELECT e.employee_id FROM Employees as e WHERE e.employee_id NOT IN\\n(SELECT e.employee_id as employee_id\\nFROM Employees AS e INNER JOIN Salaries AS s\\nWHERE e.employee_id=s.employee_id) \\nUNION\\nSELECT s.employee_id FROM Salaries as s WHERE s.employee_id NOT IN\\n(SELECT e.employee_id as employee_id\\nFROM Employees AS e INNER JOIN Salaries AS s\\nWHERE e.employee_id=s.employee_id) ORDER BY employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2356506,
                "title": "union-not-in",
                "content": "```\\nSELECT EMPLOYEE_ID \\n\\tFROM Employees \\nWHERE EMPLOYEE_ID NOT IN (\\n    SELECT employee_id FROM SALARIES\\n) \\nUNION \\nSELECT EMPLOYEE_ID \\n\\tFROM SALARIES \\nWHERE EMPLOYEE_ID NOT IN (\\n    SELECT employee_id FROM EMPLOYEES\\n) \\nORDER BY employee_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nSELECT EMPLOYEE_ID \\n\\tFROM Employees \\nWHERE EMPLOYEE_ID NOT IN (\\n    SELECT employee_id FROM SALARIES\\n) \\nUNION \\nSELECT EMPLOYEE_ID \\n\\tFROM SALARIES \\nWHERE EMPLOYEE_ID NOT IN (\\n    SELECT employee_id FROM EMPLOYEES\\n) \\nORDER BY employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2355563,
                "title": "ms-sql-with-no-union-cte-and-subqueries",
                "content": "select coalesce(e.employee_id, s.employee_id) as employee_id from Employees e \\n\\tfull outer join salaries s on e.employee_id = s.employee_id \\n\\twhere salary is null or e.employee_id is null \\n\\torder by coalesce(e.employee_id, s.employee_id) asc",
                "solutionTags": [],
                "code": "select coalesce(e.employee_id, s.employee_id) as employee_id from Employees e \\n\\tfull outer join salaries s on e.employee_id = s.employee_id \\n\\twhere salary is null or e.employee_id is null \\n\\torder by coalesce(e.employee_id, s.employee_id) asc",
                "codeTag": "Unknown"
            },
            {
                "id": 2332397,
                "title": "another-solution-using-count",
                "content": "SELECT employee_id \\n    FROM (\\n        SELECT employee_id \\n        FROM employees \\n        UNION ALL SELECT employee_id \\n        FROM salaries\\n    )\\n GROUP BY employee_id \\n HAVING count(*) < 2\\n ORDER BY employee_id",
                "solutionTags": [],
                "code": "SELECT employee_id \\n    FROM (\\n        SELECT employee_id \\n        FROM employees \\n        UNION ALL SELECT employee_id \\n        FROM salaries\\n    )\\n GROUP BY employee_id \\n HAVING count(*) < 2\\n ORDER BY employee_id",
                "codeTag": "Unknown"
            },
            {
                "id": 2318901,
                "title": "union-query",
                "content": "SELECT employee_id FROM Employees \\nWHERE employee_id \\nNOT IN (SELECT employee_id FROM Salaries )\\nUNION\\nSELECT employee_id FROM Salaries \\nWHERE employee_id \\nNOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id ASC",
                "solutionTags": [],
                "code": "SELECT employee_id FROM Employees \\nWHERE employee_id \\nNOT IN (SELECT employee_id FROM Salaries )\\nUNION\\nSELECT employee_id FROM Salaries \\nWHERE employee_id \\nNOT IN (SELECT employee_id FROM Employees)\\nORDER BY employee_id ASC",
                "codeTag": "Unknown"
            },
            {
                "id": 2313651,
                "title": "easy-mysql-solution-using-union",
                "content": "```\\n select employee_id from Salaries where employee_id not in (select employee_id from Employees) union select employee_id from Employees where employee_id not in (select employee_id from Salaries) order by employee_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\n select employee_id from Salaries where employee_id not in (select employee_id from Employees) union select employee_id from Employees where employee_id not in (select employee_id from Salaries) order by employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2309676,
                "title": "easy-solution-using-union",
                "content": "SELECT employee_id FROM Employees WHERE employee_id not in(SELECT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id not in(SELECT employee_id FROM Employees)\\nORDER BY employee_id",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "SELECT employee_id FROM Employees WHERE employee_id not in(SELECT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id not in(SELECT employee_id FROM Employees)\\nORDER BY employee_id",
                "codeTag": "Unknown"
            },
            {
                "id": 2295006,
                "title": "mysql-simple-approach-easy",
                "content": "```\\nSELECT employee_id\\nFROM Employees\\nWHERE\\nemployee_id NOT IN (\\nSELECT employee_id\\nFROM Salaries\\n)\\n\\nUNION\\n\\nSELECT employee_id\\nFROM Salaries\\nWHERE\\nemployee_id NOT IN (\\nSELECT employee_id\\nFROM Employees\\n)\\n\\nORDER BY employee_id;\\n```\\n### **Don\\'t forget to UPVOTE bro...**",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nSELECT employee_id\\nFROM Employees\\nWHERE\\nemployee_id NOT IN (\\nSELECT employee_id\\nFROM Salaries\\n)\\n\\nUNION\\n\\nSELECT employee_id\\nFROM Salaries\\nWHERE\\nemployee_id NOT IN (\\nSELECT employee_id\\nFROM Employees\\n)\\n\\nORDER BY employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2284624,
                "title": "mysql-simple-solution-without-join",
                "content": "```\\nSELECT employee_id FROM Employees where employee_id \\n    NOT IN(select employee_id from Salaries)\\nUNION\\nSELECT employee_id FROM Salaries where employee_id \\n    NOT IN(select employee_id from Employees)\\nORDER BY employee_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT employee_id FROM Employees where employee_id \\n    NOT IN(select employee_id from Salaries)\\nUNION\\nSELECT employee_id FROM Salaries where employee_id \\n    NOT IN(select employee_id from Employees)\\nORDER BY employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2281484,
                "title": "simple-solution-using-union-and-subquery",
                "content": "select employee_id from employees where employee_id\\n       not in (select employee_id from salaries)\\nunion \\nselect employee_id from salaries where employee_id \\n       not in (select employee_id from employees)\\norder by employee_id",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "select employee_id from employees where employee_id\\n       not in (select employee_id from salaries)\\nunion \\nselect employee_id from salaries where employee_id \\n       not in (select employee_id from employees)\\norder by employee_id",
                "codeTag": "Unknown"
            },
            {
                "id": 2264385,
                "title": "mysql-solution-without-join",
                "content": "```\\nSELECT employee_id\\nFROM (\\n\\n    SELECT\\n        employee_id\\n    FROM\\n        Employees\\n    WHERE\\n        employee_id NOT IN (SELECT employee_id FROM Salaries)\\n\\n    UNION\\n\\n    SELECT\\n        employee_id\\n    FROM\\n        Salaries\\n    WHERE\\n        employee_id NOT IN (SELECT employee_id FROM Employees)\\n    \\n) as temp\\nORDER BY employee_id ASC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT employee_id\\nFROM (\\n\\n    SELECT\\n        employee_id\\n    FROM\\n        Employees\\n    WHERE\\n        employee_id NOT IN (SELECT employee_id FROM Salaries)\\n\\n    UNION\\n\\n    SELECT\\n        employee_id\\n    FROM\\n        Salaries\\n    WHERE\\n        employee_id NOT IN (SELECT employee_id FROM Employees)\\n    \\n) as temp\\nORDER BY employee_id ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2244245,
                "title": "sql-server-simple-solution",
                "content": "Select case \\n\\t\\t\\twhen E.employee_id is null then S.employee_id \\n\\t\\t\\telse E.employee_id \\n\\t\\t\\tend as employee_id\\nfrom Employees E full outer join Salaries S on E.employee_id = S.employee_id \\nwhere E.name is null or S.salary is null\\norder by employee_id",
                "solutionTags": [],
                "code": "Select case \\n\\t\\t\\twhen E.employee_id is null then S.employee_id \\n\\t\\t\\telse E.employee_id \\n\\t\\t\\tend as employee_id\\nfrom Employees E full outer join Salaries S on E.employee_id = S.employee_id \\nwhere E.name is null or S.salary is null\\norder by employee_id",
                "codeTag": "Unknown"
            },
            {
                "id": 2244157,
                "title": "logic-solution",
                "content": "select employee_id from employees  where employee_id not in(select employee_id from salaries)\\nunion\\nselect employee_id from salaries where employee_id not in (select employee_id from employees)",
                "solutionTags": [
                    "Oracle",
                    "Union Find"
                ],
                "code": "select employee_id from employees  where employee_id not in(select employee_id from salaries)\\nunion\\nselect employee_id from salaries where employee_id not in (select employee_id from employees)",
                "codeTag": "Unknown"
            },
            {
                "id": 2241658,
                "title": "oracle-with-left-join-right-join-union",
                "content": "```\\nSELECT e.employee_id FROM employees e LEFT JOIN salaries s ON e.employee_id = s.employee_id\\nWHERE s.salary IS NULL\\nUNION\\nSELECT s.employee_id FROM employees e RIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nWHERE e.name IS NULL;",
                "solutionTags": [],
                "code": "```\\nSELECT e.employee_id FROM employees e LEFT JOIN salaries s ON e.employee_id = s.employee_id\\nWHERE s.salary IS NULL\\nUNION\\nSELECT s.employee_id FROM employees e RIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nWHERE e.name IS NULL;",
                "codeTag": "Unknown"
            },
            {
                "id": 2217577,
                "title": "mysql-using-union",
                "content": "select employee_id from Employees\\nwhere employee_id not in(\\nselect employee_id from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in(\\nselect employee_id from Employees)\\norder by employee_id ;\\n",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "select employee_id from Employees\\nwhere employee_id not in(\\nselect employee_id from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in(\\nselect employee_id from Employees)\\norder by employee_id ;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2214629,
                "title": "shortest-answer-cast-concat",
                "content": "```\\nSELECT CAST(CONCAT(s.employee_id, e.employee_id) AS numeric) AS employee_id \\nFROM salaries s\\nFULL JOIN employees e \\nON e.employee_id = s.employee_id \\nWHERE e.name IS NULL or s.salary IS NULL\\nORDER BY 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT CAST(CONCAT(s.employee_id, e.employee_id) AS numeric) AS employee_id \\nFROM salaries s\\nFULL JOIN employees e \\nON e.employee_id = s.employee_id \\nWHERE e.name IS NULL or s.salary IS NULL\\nORDER BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2201958,
                "title": "two-mysql-solutions",
                "content": "**NOTE:** The first solution is faster than the second one.\\n\\n```\\nSELECT\\n    employee_id\\nFROM\\n    Employees\\nWHERE\\n    employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION\\n    SELECT\\n        employee_id\\n    FROM\\n        Salaries\\n    WHERE\\n        employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY\\n    employee_id;\\n```\\n\\n```\\nSELECT\\n    employee_id\\nFROM\\n    Employees e\\nWHERE\\n    NOT EXISTS (SELECT 1 FROM Salaries s WHERE e.employee_id = s.employee_id)\\nUNION\\n    SELECT\\n        employee_id\\n    FROM\\n        Salaries s\\n    WHERE\\n        NOT EXISTS (SELECT 1 FROM Employees e WHERE s.employee_id = e.employee_id)\\nORDER BY\\n    employee_id;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nSELECT\\n    employee_id\\nFROM\\n    Employees\\nWHERE\\n    employee_id NOT IN (SELECT employee_id FROM Salaries)\\nUNION\\n    SELECT\\n        employee_id\\n    FROM\\n        Salaries\\n    WHERE\\n        employee_id NOT IN (SELECT employee_id FROM Employees)\\nORDER BY\\n    employee_id;\\n```\n```\\nSELECT\\n    employee_id\\nFROM\\n    Employees e\\nWHERE\\n    NOT EXISTS (SELECT 1 FROM Salaries s WHERE e.employee_id = s.employee_id)\\nUNION\\n    SELECT\\n        employee_id\\n    FROM\\n        Salaries s\\n    WHERE\\n        NOT EXISTS (SELECT 1 FROM Employees e WHERE s.employee_id = e.employee_id)\\nORDER BY\\n    employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2179697,
                "title": "simplest-solution",
                "content": "```\\n/* Write your T-SQL query statement below */\\nSELECT employee_id \\nFROM Employees \\n    WHERE employee_id NOT IN\\n    (SELECT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id FROM Salaries\\n    WHERE employee_id NOT IN\\n    (SELECT employee_id FROM Employees )\\nORDER BY employee_id",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT employee_id \\nFROM Employees \\n    WHERE employee_id NOT IN\\n    (SELECT employee_id FROM Salaries)\\nUNION\\nSELECT employee_id FROM Salaries\\n    WHERE employee_id NOT IN\\n    (SELECT employee_id FROM Employees )\\nORDER BY employee_id",
                "codeTag": "Unknown"
            },
            {
                "id": 2150494,
                "title": "coder-of-the-day",
                "content": "## ***UNION***\\n***Easy to Understand :-***\\n\\n1. If you have basic understanding of Union , it\\'s just that.\\n2. Want to brush your concepts again , refer it here:-\\n#### [https://www.w3schools.com/sql/sql_union.asp]\\n\\n![image](https://assets.leetcode.com/users/images/5d2c0b71-337a-4d82-89fe-c4408e8e4ebb_1655196260.0138757.gif)\\n\\n```\\nselect employee_id from employees where employee_id not in\\n(select employee_id from salaries)\\nUnion\\nselect employee_id from salaries where employee_id not in\\n(select employee_id from employees)\\norder by employee_id;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle",
                    "Union Find"
                ],
                "code": "```\\nselect employee_id from employees where employee_id not in\\n(select employee_id from salaries)\\nUnion\\nselect employee_id from salaries where employee_id not in\\n(select employee_id from employees)\\norder by employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2131016,
                "title": "full-outer-join-and-coalesce",
                "content": "```\\nSELECT coalesce(e.employee_id,s.employee_id) as employee_id\\nFROM Employees e\\nFULL OUTER JOIN Salaries s\\nON e.employee_id = s.employee_id \\nWHERE name IS NULL OR salary IS NULL\\nORDER BY coalesce(e.employee_id,s.employee_id)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT coalesce(e.employee_id,s.employee_id) as employee_id\\nFROM Employees e\\nFULL OUTER JOIN Salaries s\\nON e.employee_id = s.employee_id \\nWHERE name IS NULL OR salary IS NULL\\nORDER BY coalesce(e.employee_id,s.employee_id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2103657,
                "title": "2-solutions-for-sqlserver-full-outer-join-and-except",
                "content": "Full outer join:\\n\\n```\\nSELECT ISNULL(e.employee_id, s.employee_id) AS employee_id\\nFROM Employees e FULL OUTER JOIN Salaries s\\nON e.employee_id = s.employee_id\\nWHERE e.name IS NULL OR s.salary IS NULL\\nORDER BY employee_id\\n```\\n\\n\\nExcept (set difference):\\n\\n```\\n(SELECT employee_id FROM Employees EXCEPT SELECT employee_id FROM Salaries)\\nUNION\\n(SELECT employee_id FROM Salaries EXCEPT SELECT employee_id FROM Employees)\\nORDER BY employee_id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT ISNULL(e.employee_id, s.employee_id) AS employee_id\\nFROM Employees e FULL OUTER JOIN Salaries s\\nON e.employee_id = s.employee_id\\nWHERE e.name IS NULL OR s.salary IS NULL\\nORDER BY employee_id\\n```\n```\\n(SELECT employee_id FROM Employees EXCEPT SELECT employee_id FROM Salaries)\\nUNION\\n(SELECT employee_id FROM Salaries EXCEPT SELECT employee_id FROM Employees)\\nORDER BY employee_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2095859,
                "title": "ms-sql-server-accepts-full-outer-join",
                "content": "SELECT COALESCE(e.employee_id, s.employee_id) as employee_id\\nFROM Employees e\\nFULL OUTER JOIN Salaries s\\nON e.employee_id = s.employee_id\\nWHERE e.name IS NULL or s.salary IS NULL\\nORDER BY employee_id",
                "solutionTags": [],
                "code": "SELECT COALESCE(e.employee_id, s.employee_id) as employee_id\\nFROM Employees e\\nFULL OUTER JOIN Salaries s\\nON e.employee_id = s.employee_id\\nWHERE e.name IS NULL or s.salary IS NULL\\nORDER BY employee_id",
                "codeTag": "Unknown"
            },
            {
                "id": 2086752,
                "title": "very-easy-sql-query-hint-use-union-and-not-in",
                "content": "```\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;```",
                "codeTag": "Unknown"
            },
            {
                "id": 2078909,
                "title": "mysql-simple-solution-union",
                "content": "```\\nSELECT EMPLOYEE_ID FROM EMPLOYEES WHERE EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID FROM SALARIES)\\nUNION\\nSELECT EMPLOYEE_ID FROM SALARIES WHERE EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID FROM EMPLOYEES)\\nORDER BY EMPLOYEE_ID;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT EMPLOYEE_ID FROM EMPLOYEES WHERE EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID FROM SALARIES)\\nUNION\\nSELECT EMPLOYEE_ID FROM SALARIES WHERE EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID FROM EMPLOYEES)\\nORDER BY EMPLOYEE_ID;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2058126,
                "title": "easy-and-simple-solution-using-union-not-in-clause",
                "content": "**Employees With Missing Information Solution**\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT employee_id \\n    FROM Employees \\n        WHERE employee_id \\n            NOT IN (SELECT employee_id FROM Salaries)\\n\\nUNION \\n\\nSELECT employee_id \\n    FROM Salaries \\n        WHERE employee_id \\n            NOT IN (SELECT employee_id FROM Employees)\\n\\nORDER BY employee_id \\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT employee_id \\n    FROM Employees \\n        WHERE employee_id \\n            NOT IN (SELECT employee_id FROM Salaries)\\n\\nUNION \\n\\nSELECT employee_id \\n    FROM Salaries \\n        WHERE employee_id \\n            NOT IN (SELECT employee_id FROM Employees)\\n\\nORDER BY employee_id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038497,
                "title": "mysql-solution-2-solutions-using-left-join-using-subquery",
                "content": "```\\n# Using Left Join\\nselect e.employee_id\\nfrom Employees e left join Salaries s on e.employee_id = s.employee_id\\nwhere s.salary is null\\nunion\\nselect s.employee_id\\nfrom Salaries s left join Employees e on s.employee_id = e.employee_id\\nwhere e.name is null\\norder by employee_id;\\n\\n# OR\\n# Using Sub-query\\nselect employee_id\\nfrom Employees\\nwhere employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id\\nfrom Salaries\\nwhere employee_id not in (select employee_id from Employees)\\norder by employee_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Using Left Join\\nselect e.employee_id\\nfrom Employees e left join Salaries s on e.employee_id = s.employee_id\\nwhere s.salary is null\\nunion\\nselect s.employee_id\\nfrom Salaries s left join Employees e on s.employee_id = e.employee_id\\nwhere e.name is null\\norder by employee_id;\\n\\n# OR\\n# Using Sub-query\\nselect employee_id\\nfrom Employees\\nwhere employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id\\nfrom Salaries\\nwhere employee_id not in (select employee_id from Employees)\\norder by employee_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2029061,
                "title": "oracle-solution-using-union",
                "content": "Select employee_id From Employees Where employee_id NOT IN (select employee_id  From Salaries) UNION \\nSelect employee_id From Salaries Where employee_id NOT IN  (select employee_id  From Employees) \\nORDER BY employee_id asc;",
                "solutionTags": [
                    "Oracle",
                    "Union Find"
                ],
                "code": "Select employee_id From Employees Where employee_id NOT IN (select employee_id  From Salaries) UNION \\nSelect employee_id From Salaries Where employee_id NOT IN  (select employee_id  From Employees) \\nORDER BY employee_id asc;",
                "codeTag": "Unknown"
            },
            {
                "id": 2027550,
                "title": "mysql-solution-using-union",
                "content": "SELECT employees.employee_id FROM employees \\nWHERE employees.employee_id NOT IN (SELECT salaries.employee_id FROM salaries)\\nUNION\\nSELECT salaries.employee_id FROM salaries\\nWHERE salaries.employee_id NOT IN (SELECT employees.employee_id FROM employees)\\nORDER BY employee_id;",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "SELECT employees.employee_id FROM employees \\nWHERE employees.employee_id NOT IN (SELECT salaries.employee_id FROM salaries)\\nUNION\\nSELECT salaries.employee_id FROM salaries\\nWHERE salaries.employee_id NOT IN (SELECT employees.employee_id FROM employees)\\nORDER BY employee_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 2024973,
                "title": "simple-full-outer-join-solution",
                "content": "```\\nSELECT\\n\\t(CASE \\n        WHEN b_employee_id IS NULL THEN a_employee_id\\n        WHEN a_employee_id IS NULL THEN b_employee_id\\n   END) as employee_id\\nFROM\\n    (SELECT\\n        a.employee_id AS a_employee_id,\\n        b.employee_id AS b_employee_id\\n    FROM \\n        Employees a\\n        FULL OUTER JOIN\\n        Salaries b\\n        ON a.employee_id = b.employee_id\\n    WHERE a.employee_id IS NULL OR b.employee_id IS NULL) c\\nORDER BY\\n    employee_id",
                "solutionTags": [],
                "code": "```\\nSELECT\\n\\t(CASE \\n        WHEN b_employee_id IS NULL THEN a_employee_id\\n        WHEN a_employee_id IS NULL THEN b_employee_id\\n   END) as employee_id\\nFROM\\n    (SELECT\\n        a.employee_id AS a_employee_id,\\n        b.employee_id AS b_employee_id\\n    FROM \\n        Employees a\\n        FULL OUTER JOIN\\n        Salaries b\\n        ON a.employee_id = b.employee_id\\n    WHERE a.employee_id IS NULL OR b.employee_id IS NULL) c\\nORDER BY\\n    employee_id",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1576870,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1570564,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1570858,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1576685,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1780259,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1811740,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1674650,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1575976,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1798544,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1894054,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1576870,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1570564,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1570858,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1576685,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1780259,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1811740,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1674650,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1575976,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1798544,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1894054,
                "content": [
                    {
                        "username": "htiwari313",
                        "content": "\\n\\tselect employee_id from employees where employee_id not in (select employee_id from salaries )\\n\\tunion\\n\\tselect employee_id from salaries where employee_id not in (select employee_id from employees)\\n\\torder by employee_id;"
                    },
                    {
                        "username": "mahesh0511",
                        "content": "hii please share your number"
                    },
                    {
                        "username": "AndreKim",
                        "content": "MySQL:\\n\\n\\t(SELECT E.employee_id\\n\\tFROM Employees E\\n\\tLEFT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE S.salary IS NULL\\n\\tUNION\\n\\n\\tSELECT S.employee_id\\n\\tFROM Employees E\\n\\tRIGHT JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL)\\n\\tORDER BY employee_id\\n\\t\\nMS SQL Server:\\n\\n\\tSELECT (\\n\\t\\tCASE WHEN E.name IS NULL THEN S.employee_id\\n\\t\\t\\t WHEN S.salary IS NULL THEN E.employee_id\\n\\t\\tEND\\n\\t) employee_id\\n\\tFROM Employees E\\n\\tFULL JOIN Salaries S on E.employee_id = S.employee_id\\n\\tWHERE E.name IS NULL OR S.salary IS NULL\\n\\tORDER BY employee_id;\\n\\t\\n\\nNote:\\nAlthough MSSQL solution is done using FULL JOIN to show different approach, solution using UNION will probably show better performance than using FULL JOIN.\\n\\nRemember that MySQL does not have FULL JOIN function!"
                    },
                    {
                        "username": "Code_Ranjit",
                        "content": "#** Write your MySQL query statement below**\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)\\norder by employee_id;"
                    },
                    {
                        "username": "digantpatel404",
                        "content": "What if there is missing values in the Employees table or Salaries table ?"
                    },
                    {
                        "username": "jackmtlee",
                        "content": "# the result is (A U B) - (A \\u2229 B)\\nselect employee_id   from Employees  \\nwhere employee_id  not in \\n(select employee_id  from Salaries)\\nunion\\nselect employee_id from Salaries\\nwhere employee_id not in \\n(select employee_id  from Employees )\\norder by employee_id asc"
                    },
                    {
                        "username": "ivchun07",
                        "content": "I\\'ve been stuck on this problem for about two days...trying REALLY HARD not to skip or give up lol...but the union of sets notation you typed out really helped out in finally getting the light bulb in my head to turn on! Thank you! ---I realize I need to brush up on my math now ha"
                    },
                    {
                        "username": "tcsanitesh",
                        "content": "what is wrong with my query \\nSELECT Employees.Employee_id\\nFROM Employees \\nFull OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employees.name is null or Salaries.salary is null\\nORDER BY Employees.Employee_id;\\n\\nwhen I run the query it says \"Runtime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'OUTER JOIN Salaries ON Employees.Employee_id=Salaries.Employee_id\\nwhere Employee\\' at line 4\"\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@ayush8621](/ayush8621) is  this working?\\n"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "[@dostonbek_tilavov](/dostonbek_tilavov)  ohh shit is it...?"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "MySQL does not support full outer join\\n"
                    },
                    {
                        "username": "ayush8621",
                        "content": "select case when e.employee_id is null then s.employee_id else e.employee_id end  as employee_id from employees e full outer join salaries s on e.employee_id=s.employee_id where e.name is null or salary is null order by e.employee_id,s.employee_id;"
                    },
                    {
                        "username": "ShubhamShuklaManipal",
                        "content": "/* Write your PL/SQL query statement below */\\n/*SQL Query by Shubham Shukla*/\\n\\nselect employee_id from Employees where employee_id not in (select employee_id from Salaries) UNION \\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees)"
                    },
                    {
                        "username": "user9157Sk",
                        "content": "Here is better way to implement the solution.\n\nselect case when e.employee_id is null then s.employee_id else e.employee_id end employee_id\nfrom Employees as e full outer join Salaries as s\non e.employee_id = s.employee_id\nwhere e.employee_id is null or s.employee_id is null\norder by employee_id asc"
                    },
                    {
                        "username": "Kool_Panda",
                        "content": "(SELECT e.employee_id FROM employees e\\nLEFT JOIN salaries s ON e.employee_id = s.employee_id \\n where s.employee_id is null)\\n \\nUNION all\\n\\n(SELECT s.employee_id FROM employees e\\nRIGHT JOIN salaries s ON e.employee_id = s.employee_id\\nwhere e.employee_id is null)\\n\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "with ids_not_missing_info as (select E.employee_id\\n                            from Employees E, Salaries S\\n                            where E.employee_id = S.employee_id\\n                            and E.name is not null \\n                            and S.salary is not null\\n                            ),\\n    total_ids as (\\n        select employee_id\\n        from Employees \\n        UNION\\n        select employee_id\\n        from Salaries\\n    )\\n\\nselect employee_id\\nfrom total_ids\\nwhere employee_id not in (select * from ids_not_missing_info)\\norder by employee_id\\n"
                    },
                    {
                        "username": "phani2023",
                        "content": "seeking comments on pros and cons of this approach from the community"
                    },
                    {
                        "username": "kondrashov87",
                        "content": "select e.employee_id\\n  from Employees e\\nleft join Salaries s\\n    on e.employee_id = s.employee_id\\n where s.employee_id is null\\nunion all\\nselect k.employee_id\\n  from Salaries k\\nleft join Employees d\\n    on k.employee_id = d.employee_id\\n where d.employee_id is null\\norder by employee_id"
                    }
                ]
            },
            {
                "id": 1876415,
                "content": [
                    {
                        "username": "challaarun",
                        "content": "SELECT e.employee_id FROM Employees e WHERE e.employee_id not in (SELECT s.employee_id FROM Salaries s)\\n    -> UNION\\n    -> SELECT s.employee_id FROM Salaries s WHERE s.employee_id not in (SELECT e.employee_id FROM Employees e)\\n    -> ORDER BY employee_id;"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Since mySql don\\'t support FULL OUTER JOIN so need to implement left join and right join and then combine then with union, basically this is what full outer join is.\\nAt the end we need to order by employee_id so be careful there since in global order by we can\\'t use table name."
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below script worked for me,\\nselect em.employee_id from Employees as em \\nwhere em.employee_id not in (select sa.employee_id from Salaries as sa) \\nUNION \\nselect sa.employee_id from Salaries as sa \\nwhere sa.employee_id not in (select em.employee_id from Employees as em) order by employee_id asc"
                    },
                    {
                        "username": "HasanMahmudDev",
                        "content": "Please brief this problem."
                    },
                    {
                        "username": "mohamed1237",
                        "content": "with c as (select  e.employee_id\\nfrom Employees as e\\nunion\\nselect s.employee_id\\nfrom Salaries as s )\\nselect employee_id\\nfrom c\\nwhere employee_id not in (select z.employee_id\\n                           from Employees as z\\n                           join Salaries as a\\n                           using(employee_id))\\norder by employee_id asc;"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select employee_id \\nfrom \\n(select employee_id from Employees \\nunion all \\nselect employee_id from salaries\\n) employee_id\\nwhere employee_id  not in\\n(\\n    select e.employee_id   \\n    from\\n    Employees e join Salaries s\\n    ON \\n    e.employee_id = s.employee_id \\n)\\norder by employee_id asc"
                    },
                    {
                        "username": "inframundo",
                        "content": "Can someone explain to me why this code is not a solution to this problem?\\n\\n\\n# Write your MySQL query statement below\\nSELECT *\\nFROM(\\nSELECT CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nLEFT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n\\n\\n\\nUNION\\n\\nSELECT  CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nRIGHT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n) AS u\\nWHERE u.employee_id%11<>0\\nORDER BY employee_id"
                    },
                    {
                        "username": "Tina_Bao",
                        "content": "select employee_id\\nfrom \\n(select e.employee_id \\nfrom Employees e\\nunion all\\nselect s.employee_id\\nfrom Salaries s) as A\\ngroup by employee_id\\nhaving count(employee_id)=\"1\"\\norder by employee_id"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL Server via FULL JOIN\\n\\n```\\nSELECT COALESCE(E.[employee_id], S.[employee_id]) AS [employee_id] FROM [Employees] AS E\\nFULL OUTER JOIN [Salaries] AS S\\nON E.[employee_id] = S.[employee_id]\\nWHERE E.[employee_id] IS NULL OR S.[employee_id] IS NULL\\nORDER BY [employee_id]"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can anyone tell what is wrong with my query \"(select employee_id from Employees except select employee_id from Salaries) union (select employee_id from Salaries except select employee_id from Employees);\""
                    }
                ]
            },
            {
                "id": 1862983,
                "content": [
                    {
                        "username": "challaarun",
                        "content": "SELECT e.employee_id FROM Employees e WHERE e.employee_id not in (SELECT s.employee_id FROM Salaries s)\\n    -> UNION\\n    -> SELECT s.employee_id FROM Salaries s WHERE s.employee_id not in (SELECT e.employee_id FROM Employees e)\\n    -> ORDER BY employee_id;"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Since mySql don\\'t support FULL OUTER JOIN so need to implement left join and right join and then combine then with union, basically this is what full outer join is.\\nAt the end we need to order by employee_id so be careful there since in global order by we can\\'t use table name."
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below script worked for me,\\nselect em.employee_id from Employees as em \\nwhere em.employee_id not in (select sa.employee_id from Salaries as sa) \\nUNION \\nselect sa.employee_id from Salaries as sa \\nwhere sa.employee_id not in (select em.employee_id from Employees as em) order by employee_id asc"
                    },
                    {
                        "username": "HasanMahmudDev",
                        "content": "Please brief this problem."
                    },
                    {
                        "username": "mohamed1237",
                        "content": "with c as (select  e.employee_id\\nfrom Employees as e\\nunion\\nselect s.employee_id\\nfrom Salaries as s )\\nselect employee_id\\nfrom c\\nwhere employee_id not in (select z.employee_id\\n                           from Employees as z\\n                           join Salaries as a\\n                           using(employee_id))\\norder by employee_id asc;"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select employee_id \\nfrom \\n(select employee_id from Employees \\nunion all \\nselect employee_id from salaries\\n) employee_id\\nwhere employee_id  not in\\n(\\n    select e.employee_id   \\n    from\\n    Employees e join Salaries s\\n    ON \\n    e.employee_id = s.employee_id \\n)\\norder by employee_id asc"
                    },
                    {
                        "username": "inframundo",
                        "content": "Can someone explain to me why this code is not a solution to this problem?\\n\\n\\n# Write your MySQL query statement below\\nSELECT *\\nFROM(\\nSELECT CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nLEFT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n\\n\\n\\nUNION\\n\\nSELECT  CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nRIGHT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n) AS u\\nWHERE u.employee_id%11<>0\\nORDER BY employee_id"
                    },
                    {
                        "username": "Tina_Bao",
                        "content": "select employee_id\\nfrom \\n(select e.employee_id \\nfrom Employees e\\nunion all\\nselect s.employee_id\\nfrom Salaries s) as A\\ngroup by employee_id\\nhaving count(employee_id)=\"1\"\\norder by employee_id"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL Server via FULL JOIN\\n\\n```\\nSELECT COALESCE(E.[employee_id], S.[employee_id]) AS [employee_id] FROM [Employees] AS E\\nFULL OUTER JOIN [Salaries] AS S\\nON E.[employee_id] = S.[employee_id]\\nWHERE E.[employee_id] IS NULL OR S.[employee_id] IS NULL\\nORDER BY [employee_id]"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can anyone tell what is wrong with my query \"(select employee_id from Employees except select employee_id from Salaries) union (select employee_id from Salaries except select employee_id from Employees);\""
                    }
                ]
            },
            {
                "id": 1860207,
                "content": [
                    {
                        "username": "challaarun",
                        "content": "SELECT e.employee_id FROM Employees e WHERE e.employee_id not in (SELECT s.employee_id FROM Salaries s)\\n    -> UNION\\n    -> SELECT s.employee_id FROM Salaries s WHERE s.employee_id not in (SELECT e.employee_id FROM Employees e)\\n    -> ORDER BY employee_id;"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Since mySql don\\'t support FULL OUTER JOIN so need to implement left join and right join and then combine then with union, basically this is what full outer join is.\\nAt the end we need to order by employee_id so be careful there since in global order by we can\\'t use table name."
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below script worked for me,\\nselect em.employee_id from Employees as em \\nwhere em.employee_id not in (select sa.employee_id from Salaries as sa) \\nUNION \\nselect sa.employee_id from Salaries as sa \\nwhere sa.employee_id not in (select em.employee_id from Employees as em) order by employee_id asc"
                    },
                    {
                        "username": "HasanMahmudDev",
                        "content": "Please brief this problem."
                    },
                    {
                        "username": "mohamed1237",
                        "content": "with c as (select  e.employee_id\\nfrom Employees as e\\nunion\\nselect s.employee_id\\nfrom Salaries as s )\\nselect employee_id\\nfrom c\\nwhere employee_id not in (select z.employee_id\\n                           from Employees as z\\n                           join Salaries as a\\n                           using(employee_id))\\norder by employee_id asc;"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select employee_id \\nfrom \\n(select employee_id from Employees \\nunion all \\nselect employee_id from salaries\\n) employee_id\\nwhere employee_id  not in\\n(\\n    select e.employee_id   \\n    from\\n    Employees e join Salaries s\\n    ON \\n    e.employee_id = s.employee_id \\n)\\norder by employee_id asc"
                    },
                    {
                        "username": "inframundo",
                        "content": "Can someone explain to me why this code is not a solution to this problem?\\n\\n\\n# Write your MySQL query statement below\\nSELECT *\\nFROM(\\nSELECT CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nLEFT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n\\n\\n\\nUNION\\n\\nSELECT  CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nRIGHT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n) AS u\\nWHERE u.employee_id%11<>0\\nORDER BY employee_id"
                    },
                    {
                        "username": "Tina_Bao",
                        "content": "select employee_id\\nfrom \\n(select e.employee_id \\nfrom Employees e\\nunion all\\nselect s.employee_id\\nfrom Salaries s) as A\\ngroup by employee_id\\nhaving count(employee_id)=\"1\"\\norder by employee_id"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL Server via FULL JOIN\\n\\n```\\nSELECT COALESCE(E.[employee_id], S.[employee_id]) AS [employee_id] FROM [Employees] AS E\\nFULL OUTER JOIN [Salaries] AS S\\nON E.[employee_id] = S.[employee_id]\\nWHERE E.[employee_id] IS NULL OR S.[employee_id] IS NULL\\nORDER BY [employee_id]"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can anyone tell what is wrong with my query \"(select employee_id from Employees except select employee_id from Salaries) union (select employee_id from Salaries except select employee_id from Employees);\""
                    }
                ]
            },
            {
                "id": 1848850,
                "content": [
                    {
                        "username": "challaarun",
                        "content": "SELECT e.employee_id FROM Employees e WHERE e.employee_id not in (SELECT s.employee_id FROM Salaries s)\\n    -> UNION\\n    -> SELECT s.employee_id FROM Salaries s WHERE s.employee_id not in (SELECT e.employee_id FROM Employees e)\\n    -> ORDER BY employee_id;"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Since mySql don\\'t support FULL OUTER JOIN so need to implement left join and right join and then combine then with union, basically this is what full outer join is.\\nAt the end we need to order by employee_id so be careful there since in global order by we can\\'t use table name."
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below script worked for me,\\nselect em.employee_id from Employees as em \\nwhere em.employee_id not in (select sa.employee_id from Salaries as sa) \\nUNION \\nselect sa.employee_id from Salaries as sa \\nwhere sa.employee_id not in (select em.employee_id from Employees as em) order by employee_id asc"
                    },
                    {
                        "username": "HasanMahmudDev",
                        "content": "Please brief this problem."
                    },
                    {
                        "username": "mohamed1237",
                        "content": "with c as (select  e.employee_id\\nfrom Employees as e\\nunion\\nselect s.employee_id\\nfrom Salaries as s )\\nselect employee_id\\nfrom c\\nwhere employee_id not in (select z.employee_id\\n                           from Employees as z\\n                           join Salaries as a\\n                           using(employee_id))\\norder by employee_id asc;"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select employee_id \\nfrom \\n(select employee_id from Employees \\nunion all \\nselect employee_id from salaries\\n) employee_id\\nwhere employee_id  not in\\n(\\n    select e.employee_id   \\n    from\\n    Employees e join Salaries s\\n    ON \\n    e.employee_id = s.employee_id \\n)\\norder by employee_id asc"
                    },
                    {
                        "username": "inframundo",
                        "content": "Can someone explain to me why this code is not a solution to this problem?\\n\\n\\n# Write your MySQL query statement below\\nSELECT *\\nFROM(\\nSELECT CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nLEFT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n\\n\\n\\nUNION\\n\\nSELECT  CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nRIGHT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n) AS u\\nWHERE u.employee_id%11<>0\\nORDER BY employee_id"
                    },
                    {
                        "username": "Tina_Bao",
                        "content": "select employee_id\\nfrom \\n(select e.employee_id \\nfrom Employees e\\nunion all\\nselect s.employee_id\\nfrom Salaries s) as A\\ngroup by employee_id\\nhaving count(employee_id)=\"1\"\\norder by employee_id"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL Server via FULL JOIN\\n\\n```\\nSELECT COALESCE(E.[employee_id], S.[employee_id]) AS [employee_id] FROM [Employees] AS E\\nFULL OUTER JOIN [Salaries] AS S\\nON E.[employee_id] = S.[employee_id]\\nWHERE E.[employee_id] IS NULL OR S.[employee_id] IS NULL\\nORDER BY [employee_id]"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can anyone tell what is wrong with my query \"(select employee_id from Employees except select employee_id from Salaries) union (select employee_id from Salaries except select employee_id from Employees);\""
                    }
                ]
            },
            {
                "id": 1846617,
                "content": [
                    {
                        "username": "challaarun",
                        "content": "SELECT e.employee_id FROM Employees e WHERE e.employee_id not in (SELECT s.employee_id FROM Salaries s)\\n    -> UNION\\n    -> SELECT s.employee_id FROM Salaries s WHERE s.employee_id not in (SELECT e.employee_id FROM Employees e)\\n    -> ORDER BY employee_id;"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Since mySql don\\'t support FULL OUTER JOIN so need to implement left join and right join and then combine then with union, basically this is what full outer join is.\\nAt the end we need to order by employee_id so be careful there since in global order by we can\\'t use table name."
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below script worked for me,\\nselect em.employee_id from Employees as em \\nwhere em.employee_id not in (select sa.employee_id from Salaries as sa) \\nUNION \\nselect sa.employee_id from Salaries as sa \\nwhere sa.employee_id not in (select em.employee_id from Employees as em) order by employee_id asc"
                    },
                    {
                        "username": "HasanMahmudDev",
                        "content": "Please brief this problem."
                    },
                    {
                        "username": "mohamed1237",
                        "content": "with c as (select  e.employee_id\\nfrom Employees as e\\nunion\\nselect s.employee_id\\nfrom Salaries as s )\\nselect employee_id\\nfrom c\\nwhere employee_id not in (select z.employee_id\\n                           from Employees as z\\n                           join Salaries as a\\n                           using(employee_id))\\norder by employee_id asc;"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select employee_id \\nfrom \\n(select employee_id from Employees \\nunion all \\nselect employee_id from salaries\\n) employee_id\\nwhere employee_id  not in\\n(\\n    select e.employee_id   \\n    from\\n    Employees e join Salaries s\\n    ON \\n    e.employee_id = s.employee_id \\n)\\norder by employee_id asc"
                    },
                    {
                        "username": "inframundo",
                        "content": "Can someone explain to me why this code is not a solution to this problem?\\n\\n\\n# Write your MySQL query statement below\\nSELECT *\\nFROM(\\nSELECT CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nLEFT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n\\n\\n\\nUNION\\n\\nSELECT  CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nRIGHT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n) AS u\\nWHERE u.employee_id%11<>0\\nORDER BY employee_id"
                    },
                    {
                        "username": "Tina_Bao",
                        "content": "select employee_id\\nfrom \\n(select e.employee_id \\nfrom Employees e\\nunion all\\nselect s.employee_id\\nfrom Salaries s) as A\\ngroup by employee_id\\nhaving count(employee_id)=\"1\"\\norder by employee_id"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL Server via FULL JOIN\\n\\n```\\nSELECT COALESCE(E.[employee_id], S.[employee_id]) AS [employee_id] FROM [Employees] AS E\\nFULL OUTER JOIN [Salaries] AS S\\nON E.[employee_id] = S.[employee_id]\\nWHERE E.[employee_id] IS NULL OR S.[employee_id] IS NULL\\nORDER BY [employee_id]"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can anyone tell what is wrong with my query \"(select employee_id from Employees except select employee_id from Salaries) union (select employee_id from Salaries except select employee_id from Employees);\""
                    }
                ]
            },
            {
                "id": 1764595,
                "content": [
                    {
                        "username": "challaarun",
                        "content": "SELECT e.employee_id FROM Employees e WHERE e.employee_id not in (SELECT s.employee_id FROM Salaries s)\\n    -> UNION\\n    -> SELECT s.employee_id FROM Salaries s WHERE s.employee_id not in (SELECT e.employee_id FROM Employees e)\\n    -> ORDER BY employee_id;"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Since mySql don\\'t support FULL OUTER JOIN so need to implement left join and right join and then combine then with union, basically this is what full outer join is.\\nAt the end we need to order by employee_id so be careful there since in global order by we can\\'t use table name."
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below script worked for me,\\nselect em.employee_id from Employees as em \\nwhere em.employee_id not in (select sa.employee_id from Salaries as sa) \\nUNION \\nselect sa.employee_id from Salaries as sa \\nwhere sa.employee_id not in (select em.employee_id from Employees as em) order by employee_id asc"
                    },
                    {
                        "username": "HasanMahmudDev",
                        "content": "Please brief this problem."
                    },
                    {
                        "username": "mohamed1237",
                        "content": "with c as (select  e.employee_id\\nfrom Employees as e\\nunion\\nselect s.employee_id\\nfrom Salaries as s )\\nselect employee_id\\nfrom c\\nwhere employee_id not in (select z.employee_id\\n                           from Employees as z\\n                           join Salaries as a\\n                           using(employee_id))\\norder by employee_id asc;"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select employee_id \\nfrom \\n(select employee_id from Employees \\nunion all \\nselect employee_id from salaries\\n) employee_id\\nwhere employee_id  not in\\n(\\n    select e.employee_id   \\n    from\\n    Employees e join Salaries s\\n    ON \\n    e.employee_id = s.employee_id \\n)\\norder by employee_id asc"
                    },
                    {
                        "username": "inframundo",
                        "content": "Can someone explain to me why this code is not a solution to this problem?\\n\\n\\n# Write your MySQL query statement below\\nSELECT *\\nFROM(\\nSELECT CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nLEFT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n\\n\\n\\nUNION\\n\\nSELECT  CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nRIGHT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n) AS u\\nWHERE u.employee_id%11<>0\\nORDER BY employee_id"
                    },
                    {
                        "username": "Tina_Bao",
                        "content": "select employee_id\\nfrom \\n(select e.employee_id \\nfrom Employees e\\nunion all\\nselect s.employee_id\\nfrom Salaries s) as A\\ngroup by employee_id\\nhaving count(employee_id)=\"1\"\\norder by employee_id"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL Server via FULL JOIN\\n\\n```\\nSELECT COALESCE(E.[employee_id], S.[employee_id]) AS [employee_id] FROM [Employees] AS E\\nFULL OUTER JOIN [Salaries] AS S\\nON E.[employee_id] = S.[employee_id]\\nWHERE E.[employee_id] IS NULL OR S.[employee_id] IS NULL\\nORDER BY [employee_id]"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can anyone tell what is wrong with my query \"(select employee_id from Employees except select employee_id from Salaries) union (select employee_id from Salaries except select employee_id from Employees);\""
                    }
                ]
            },
            {
                "id": 1762392,
                "content": [
                    {
                        "username": "challaarun",
                        "content": "SELECT e.employee_id FROM Employees e WHERE e.employee_id not in (SELECT s.employee_id FROM Salaries s)\\n    -> UNION\\n    -> SELECT s.employee_id FROM Salaries s WHERE s.employee_id not in (SELECT e.employee_id FROM Employees e)\\n    -> ORDER BY employee_id;"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Since mySql don\\'t support FULL OUTER JOIN so need to implement left join and right join and then combine then with union, basically this is what full outer join is.\\nAt the end we need to order by employee_id so be careful there since in global order by we can\\'t use table name."
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below script worked for me,\\nselect em.employee_id from Employees as em \\nwhere em.employee_id not in (select sa.employee_id from Salaries as sa) \\nUNION \\nselect sa.employee_id from Salaries as sa \\nwhere sa.employee_id not in (select em.employee_id from Employees as em) order by employee_id asc"
                    },
                    {
                        "username": "HasanMahmudDev",
                        "content": "Please brief this problem."
                    },
                    {
                        "username": "mohamed1237",
                        "content": "with c as (select  e.employee_id\\nfrom Employees as e\\nunion\\nselect s.employee_id\\nfrom Salaries as s )\\nselect employee_id\\nfrom c\\nwhere employee_id not in (select z.employee_id\\n                           from Employees as z\\n                           join Salaries as a\\n                           using(employee_id))\\norder by employee_id asc;"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select employee_id \\nfrom \\n(select employee_id from Employees \\nunion all \\nselect employee_id from salaries\\n) employee_id\\nwhere employee_id  not in\\n(\\n    select e.employee_id   \\n    from\\n    Employees e join Salaries s\\n    ON \\n    e.employee_id = s.employee_id \\n)\\norder by employee_id asc"
                    },
                    {
                        "username": "inframundo",
                        "content": "Can someone explain to me why this code is not a solution to this problem?\\n\\n\\n# Write your MySQL query statement below\\nSELECT *\\nFROM(\\nSELECT CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nLEFT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n\\n\\n\\nUNION\\n\\nSELECT  CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nRIGHT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n) AS u\\nWHERE u.employee_id%11<>0\\nORDER BY employee_id"
                    },
                    {
                        "username": "Tina_Bao",
                        "content": "select employee_id\\nfrom \\n(select e.employee_id \\nfrom Employees e\\nunion all\\nselect s.employee_id\\nfrom Salaries s) as A\\ngroup by employee_id\\nhaving count(employee_id)=\"1\"\\norder by employee_id"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL Server via FULL JOIN\\n\\n```\\nSELECT COALESCE(E.[employee_id], S.[employee_id]) AS [employee_id] FROM [Employees] AS E\\nFULL OUTER JOIN [Salaries] AS S\\nON E.[employee_id] = S.[employee_id]\\nWHERE E.[employee_id] IS NULL OR S.[employee_id] IS NULL\\nORDER BY [employee_id]"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can anyone tell what is wrong with my query \"(select employee_id from Employees except select employee_id from Salaries) union (select employee_id from Salaries except select employee_id from Employees);\""
                    }
                ]
            },
            {
                "id": 1762321,
                "content": [
                    {
                        "username": "challaarun",
                        "content": "SELECT e.employee_id FROM Employees e WHERE e.employee_id not in (SELECT s.employee_id FROM Salaries s)\\n    -> UNION\\n    -> SELECT s.employee_id FROM Salaries s WHERE s.employee_id not in (SELECT e.employee_id FROM Employees e)\\n    -> ORDER BY employee_id;"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Since mySql don\\'t support FULL OUTER JOIN so need to implement left join and right join and then combine then with union, basically this is what full outer join is.\\nAt the end we need to order by employee_id so be careful there since in global order by we can\\'t use table name."
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below script worked for me,\\nselect em.employee_id from Employees as em \\nwhere em.employee_id not in (select sa.employee_id from Salaries as sa) \\nUNION \\nselect sa.employee_id from Salaries as sa \\nwhere sa.employee_id not in (select em.employee_id from Employees as em) order by employee_id asc"
                    },
                    {
                        "username": "HasanMahmudDev",
                        "content": "Please brief this problem."
                    },
                    {
                        "username": "mohamed1237",
                        "content": "with c as (select  e.employee_id\\nfrom Employees as e\\nunion\\nselect s.employee_id\\nfrom Salaries as s )\\nselect employee_id\\nfrom c\\nwhere employee_id not in (select z.employee_id\\n                           from Employees as z\\n                           join Salaries as a\\n                           using(employee_id))\\norder by employee_id asc;"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select employee_id \\nfrom \\n(select employee_id from Employees \\nunion all \\nselect employee_id from salaries\\n) employee_id\\nwhere employee_id  not in\\n(\\n    select e.employee_id   \\n    from\\n    Employees e join Salaries s\\n    ON \\n    e.employee_id = s.employee_id \\n)\\norder by employee_id asc"
                    },
                    {
                        "username": "inframundo",
                        "content": "Can someone explain to me why this code is not a solution to this problem?\\n\\n\\n# Write your MySQL query statement below\\nSELECT *\\nFROM(\\nSELECT CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nLEFT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n\\n\\n\\nUNION\\n\\nSELECT  CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nRIGHT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n) AS u\\nWHERE u.employee_id%11<>0\\nORDER BY employee_id"
                    },
                    {
                        "username": "Tina_Bao",
                        "content": "select employee_id\\nfrom \\n(select e.employee_id \\nfrom Employees e\\nunion all\\nselect s.employee_id\\nfrom Salaries s) as A\\ngroup by employee_id\\nhaving count(employee_id)=\"1\"\\norder by employee_id"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL Server via FULL JOIN\\n\\n```\\nSELECT COALESCE(E.[employee_id], S.[employee_id]) AS [employee_id] FROM [Employees] AS E\\nFULL OUTER JOIN [Salaries] AS S\\nON E.[employee_id] = S.[employee_id]\\nWHERE E.[employee_id] IS NULL OR S.[employee_id] IS NULL\\nORDER BY [employee_id]"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can anyone tell what is wrong with my query \"(select employee_id from Employees except select employee_id from Salaries) union (select employee_id from Salaries except select employee_id from Employees);\""
                    }
                ]
            },
            {
                "id": 1762097,
                "content": [
                    {
                        "username": "challaarun",
                        "content": "SELECT e.employee_id FROM Employees e WHERE e.employee_id not in (SELECT s.employee_id FROM Salaries s)\\n    -> UNION\\n    -> SELECT s.employee_id FROM Salaries s WHERE s.employee_id not in (SELECT e.employee_id FROM Employees e)\\n    -> ORDER BY employee_id;"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Since mySql don\\'t support FULL OUTER JOIN so need to implement left join and right join and then combine then with union, basically this is what full outer join is.\\nAt the end we need to order by employee_id so be careful there since in global order by we can\\'t use table name."
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below script worked for me,\\nselect em.employee_id from Employees as em \\nwhere em.employee_id not in (select sa.employee_id from Salaries as sa) \\nUNION \\nselect sa.employee_id from Salaries as sa \\nwhere sa.employee_id not in (select em.employee_id from Employees as em) order by employee_id asc"
                    },
                    {
                        "username": "HasanMahmudDev",
                        "content": "Please brief this problem."
                    },
                    {
                        "username": "mohamed1237",
                        "content": "with c as (select  e.employee_id\\nfrom Employees as e\\nunion\\nselect s.employee_id\\nfrom Salaries as s )\\nselect employee_id\\nfrom c\\nwhere employee_id not in (select z.employee_id\\n                           from Employees as z\\n                           join Salaries as a\\n                           using(employee_id))\\norder by employee_id asc;"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select employee_id \\nfrom \\n(select employee_id from Employees \\nunion all \\nselect employee_id from salaries\\n) employee_id\\nwhere employee_id  not in\\n(\\n    select e.employee_id   \\n    from\\n    Employees e join Salaries s\\n    ON \\n    e.employee_id = s.employee_id \\n)\\norder by employee_id asc"
                    },
                    {
                        "username": "inframundo",
                        "content": "Can someone explain to me why this code is not a solution to this problem?\\n\\n\\n# Write your MySQL query statement below\\nSELECT *\\nFROM(\\nSELECT CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nLEFT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n\\n\\n\\nUNION\\n\\nSELECT  CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nRIGHT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n) AS u\\nWHERE u.employee_id%11<>0\\nORDER BY employee_id"
                    },
                    {
                        "username": "Tina_Bao",
                        "content": "select employee_id\\nfrom \\n(select e.employee_id \\nfrom Employees e\\nunion all\\nselect s.employee_id\\nfrom Salaries s) as A\\ngroup by employee_id\\nhaving count(employee_id)=\"1\"\\norder by employee_id"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL Server via FULL JOIN\\n\\n```\\nSELECT COALESCE(E.[employee_id], S.[employee_id]) AS [employee_id] FROM [Employees] AS E\\nFULL OUTER JOIN [Salaries] AS S\\nON E.[employee_id] = S.[employee_id]\\nWHERE E.[employee_id] IS NULL OR S.[employee_id] IS NULL\\nORDER BY [employee_id]"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can anyone tell what is wrong with my query \"(select employee_id from Employees except select employee_id from Salaries) union (select employee_id from Salaries except select employee_id from Employees);\""
                    }
                ]
            },
            {
                "id": 1756469,
                "content": [
                    {
                        "username": "challaarun",
                        "content": "SELECT e.employee_id FROM Employees e WHERE e.employee_id not in (SELECT s.employee_id FROM Salaries s)\\n    -> UNION\\n    -> SELECT s.employee_id FROM Salaries s WHERE s.employee_id not in (SELECT e.employee_id FROM Employees e)\\n    -> ORDER BY employee_id;"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Since mySql don\\'t support FULL OUTER JOIN so need to implement left join and right join and then combine then with union, basically this is what full outer join is.\\nAt the end we need to order by employee_id so be careful there since in global order by we can\\'t use table name."
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below script worked for me,\\nselect em.employee_id from Employees as em \\nwhere em.employee_id not in (select sa.employee_id from Salaries as sa) \\nUNION \\nselect sa.employee_id from Salaries as sa \\nwhere sa.employee_id not in (select em.employee_id from Employees as em) order by employee_id asc"
                    },
                    {
                        "username": "HasanMahmudDev",
                        "content": "Please brief this problem."
                    },
                    {
                        "username": "mohamed1237",
                        "content": "with c as (select  e.employee_id\\nfrom Employees as e\\nunion\\nselect s.employee_id\\nfrom Salaries as s )\\nselect employee_id\\nfrom c\\nwhere employee_id not in (select z.employee_id\\n                           from Employees as z\\n                           join Salaries as a\\n                           using(employee_id))\\norder by employee_id asc;"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select employee_id \\nfrom \\n(select employee_id from Employees \\nunion all \\nselect employee_id from salaries\\n) employee_id\\nwhere employee_id  not in\\n(\\n    select e.employee_id   \\n    from\\n    Employees e join Salaries s\\n    ON \\n    e.employee_id = s.employee_id \\n)\\norder by employee_id asc"
                    },
                    {
                        "username": "inframundo",
                        "content": "Can someone explain to me why this code is not a solution to this problem?\\n\\n\\n# Write your MySQL query statement below\\nSELECT *\\nFROM(\\nSELECT CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nLEFT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n\\n\\n\\nUNION\\n\\nSELECT  CONCAT_WS(\\'\\',emp.employee_id, sal.employee_id) AS employee_id\\nFROM employees emp\\nRIGHT JOIN salaries sal\\nON sal.employee_id=emp.employee_id\\n\\n) AS u\\nWHERE u.employee_id%11<>0\\nORDER BY employee_id"
                    },
                    {
                        "username": "Tina_Bao",
                        "content": "select employee_id\\nfrom \\n(select e.employee_id \\nfrom Employees e\\nunion all\\nselect s.employee_id\\nfrom Salaries s) as A\\ngroup by employee_id\\nhaving count(employee_id)=\"1\"\\norder by employee_id"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL Server via FULL JOIN\\n\\n```\\nSELECT COALESCE(E.[employee_id], S.[employee_id]) AS [employee_id] FROM [Employees] AS E\\nFULL OUTER JOIN [Salaries] AS S\\nON E.[employee_id] = S.[employee_id]\\nWHERE E.[employee_id] IS NULL OR S.[employee_id] IS NULL\\nORDER BY [employee_id]"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can anyone tell what is wrong with my query \"(select employee_id from Employees except select employee_id from Salaries) union (select employee_id from Salaries except select employee_id from Employees);\""
                    }
                ]
            },
            {
                "id": 1750507,
                "content": [
                    {
                        "username": "rong6",
                        "content": "# Write your MySQL query statement below\\n\\nselect employee_id  from Employees \\n where employee_id not in (select employee_id from Salaries )\\n union\\n select employee_id  from Salaries \\n where employee_id not in (select employee_id from Employees ) \\n order by 1"
                    },
                    {
                        "username": "Utkarsh2ml",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id)\\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id) ORDER BY employee_id"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT employee_id FROM Salaries) \\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id not in(SELECT employee_id FROM Employees) \\nOrder by employee_id"
                    },
                    {
                        "username": "Cynotryl",
                        "content": "I just proposed this oracle solution myself and I don\\'t know despite of resulting in the same answer, the test case is still getting failed.\\n```\\nselect e.employee_id || s.employee_id as \"employee_id\"  from employees e full outer join salaries s on s.employee_id=e.employee_id where s.employee_id is null or e.employee_id is null;\\n```"
                    },
                    {
                        "username": "b0968760387",
                        "content": "because employee_id is int but it\\'s char at your answer. "
                    },
                    {
                        "username": "vikashkumarbth381",
                        "content": "select e.employee_id From Employees e left join salaries s\\non e.employee_id=s.employee_id\\nwhere s.salary is NULL\\nunion\\n\\nselect s.employee_id from salaries s left join employees e on s.employee_id=e.employee_id where e.name is null order by employee_id;"
                    },
                    {
                        "username": "user5418EK",
                        "content": "what is error in sql query below?\n\nselect Salaries.employee_id   from Employees full  outer join Salaries on Employees.employee_id =Salaries.employee_id where Salaries.employee_id NOT IN (select employee_id   from Employees inner  join Salaries on  Employees.employee_id =Salaries.employee_id )  order by employee_id  asc ;\n\n"
                    },
                    {
                        "username": "ruqinch",
                        "content": "MySQL does not support full outer join out of the box, so you will need to do a full outer join using a combination of other join types such as LEFT JOIN ad RIGHT JOIN that are supported in MySQL."
                    },
                    {
                        "username": "NikitaJain165",
                        "content": "Error : Unknown column \\'Employees.employee_id\\' in \\'on clause\\'\\n\\nAny idea what is wrong here?"
                    },
                    {
                        "username": "adnanghafoor2933",
                        "content": "My solution is ( employees  -  salaries ) U ( salaries - employees )\\n\\n` select employee_id from employees\\n    minus\\n select employee_id from salaries)\\nunion\\n\\n select employee_id from salaries\\n minus\\n select employee_id from employees`"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "it is showing error"
                    },
                    {
                        "username": "ishhanayy",
                        "content": " `# Write your MySQL query statement below\\nselect employee_id from Employees where employee_id not in (select employee_id from Employees natural join Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees natural join Salaries) order by employee_id;`"
                    },
                    {
                        "username": "husein14",
                        "content": "select employee_id from \\nEmployees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from\\nSalaries where employee_id not in (select employee_id from Employees)\\norder by employee_id asc;\\n"
                    }
                ]
            },
            {
                "id": 1750258,
                "content": [
                    {
                        "username": "rong6",
                        "content": "# Write your MySQL query statement below\\n\\nselect employee_id  from Employees \\n where employee_id not in (select employee_id from Salaries )\\n union\\n select employee_id  from Salaries \\n where employee_id not in (select employee_id from Employees ) \\n order by 1"
                    },
                    {
                        "username": "Utkarsh2ml",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id)\\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id) ORDER BY employee_id"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT employee_id FROM Salaries) \\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id not in(SELECT employee_id FROM Employees) \\nOrder by employee_id"
                    },
                    {
                        "username": "Cynotryl",
                        "content": "I just proposed this oracle solution myself and I don\\'t know despite of resulting in the same answer, the test case is still getting failed.\\n```\\nselect e.employee_id || s.employee_id as \"employee_id\"  from employees e full outer join salaries s on s.employee_id=e.employee_id where s.employee_id is null or e.employee_id is null;\\n```"
                    },
                    {
                        "username": "b0968760387",
                        "content": "because employee_id is int but it\\'s char at your answer. "
                    },
                    {
                        "username": "vikashkumarbth381",
                        "content": "select e.employee_id From Employees e left join salaries s\\non e.employee_id=s.employee_id\\nwhere s.salary is NULL\\nunion\\n\\nselect s.employee_id from salaries s left join employees e on s.employee_id=e.employee_id where e.name is null order by employee_id;"
                    },
                    {
                        "username": "user5418EK",
                        "content": "what is error in sql query below?\n\nselect Salaries.employee_id   from Employees full  outer join Salaries on Employees.employee_id =Salaries.employee_id where Salaries.employee_id NOT IN (select employee_id   from Employees inner  join Salaries on  Employees.employee_id =Salaries.employee_id )  order by employee_id  asc ;\n\n"
                    },
                    {
                        "username": "ruqinch",
                        "content": "MySQL does not support full outer join out of the box, so you will need to do a full outer join using a combination of other join types such as LEFT JOIN ad RIGHT JOIN that are supported in MySQL."
                    },
                    {
                        "username": "NikitaJain165",
                        "content": "Error : Unknown column \\'Employees.employee_id\\' in \\'on clause\\'\\n\\nAny idea what is wrong here?"
                    },
                    {
                        "username": "adnanghafoor2933",
                        "content": "My solution is ( employees  -  salaries ) U ( salaries - employees )\\n\\n` select employee_id from employees\\n    minus\\n select employee_id from salaries)\\nunion\\n\\n select employee_id from salaries\\n minus\\n select employee_id from employees`"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "it is showing error"
                    },
                    {
                        "username": "ishhanayy",
                        "content": " `# Write your MySQL query statement below\\nselect employee_id from Employees where employee_id not in (select employee_id from Employees natural join Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees natural join Salaries) order by employee_id;`"
                    },
                    {
                        "username": "husein14",
                        "content": "select employee_id from \\nEmployees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from\\nSalaries where employee_id not in (select employee_id from Employees)\\norder by employee_id asc;\\n"
                    }
                ]
            },
            {
                "id": 1740698,
                "content": [
                    {
                        "username": "rong6",
                        "content": "# Write your MySQL query statement below\\n\\nselect employee_id  from Employees \\n where employee_id not in (select employee_id from Salaries )\\n union\\n select employee_id  from Salaries \\n where employee_id not in (select employee_id from Employees ) \\n order by 1"
                    },
                    {
                        "username": "Utkarsh2ml",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id)\\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id) ORDER BY employee_id"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT employee_id FROM Salaries) \\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id not in(SELECT employee_id FROM Employees) \\nOrder by employee_id"
                    },
                    {
                        "username": "Cynotryl",
                        "content": "I just proposed this oracle solution myself and I don\\'t know despite of resulting in the same answer, the test case is still getting failed.\\n```\\nselect e.employee_id || s.employee_id as \"employee_id\"  from employees e full outer join salaries s on s.employee_id=e.employee_id where s.employee_id is null or e.employee_id is null;\\n```"
                    },
                    {
                        "username": "b0968760387",
                        "content": "because employee_id is int but it\\'s char at your answer. "
                    },
                    {
                        "username": "vikashkumarbth381",
                        "content": "select e.employee_id From Employees e left join salaries s\\non e.employee_id=s.employee_id\\nwhere s.salary is NULL\\nunion\\n\\nselect s.employee_id from salaries s left join employees e on s.employee_id=e.employee_id where e.name is null order by employee_id;"
                    },
                    {
                        "username": "user5418EK",
                        "content": "what is error in sql query below?\n\nselect Salaries.employee_id   from Employees full  outer join Salaries on Employees.employee_id =Salaries.employee_id where Salaries.employee_id NOT IN (select employee_id   from Employees inner  join Salaries on  Employees.employee_id =Salaries.employee_id )  order by employee_id  asc ;\n\n"
                    },
                    {
                        "username": "ruqinch",
                        "content": "MySQL does not support full outer join out of the box, so you will need to do a full outer join using a combination of other join types such as LEFT JOIN ad RIGHT JOIN that are supported in MySQL."
                    },
                    {
                        "username": "NikitaJain165",
                        "content": "Error : Unknown column \\'Employees.employee_id\\' in \\'on clause\\'\\n\\nAny idea what is wrong here?"
                    },
                    {
                        "username": "adnanghafoor2933",
                        "content": "My solution is ( employees  -  salaries ) U ( salaries - employees )\\n\\n` select employee_id from employees\\n    minus\\n select employee_id from salaries)\\nunion\\n\\n select employee_id from salaries\\n minus\\n select employee_id from employees`"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "it is showing error"
                    },
                    {
                        "username": "ishhanayy",
                        "content": " `# Write your MySQL query statement below\\nselect employee_id from Employees where employee_id not in (select employee_id from Employees natural join Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees natural join Salaries) order by employee_id;`"
                    },
                    {
                        "username": "husein14",
                        "content": "select employee_id from \\nEmployees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from\\nSalaries where employee_id not in (select employee_id from Employees)\\norder by employee_id asc;\\n"
                    }
                ]
            },
            {
                "id": 1735243,
                "content": [
                    {
                        "username": "rong6",
                        "content": "# Write your MySQL query statement below\\n\\nselect employee_id  from Employees \\n where employee_id not in (select employee_id from Salaries )\\n union\\n select employee_id  from Salaries \\n where employee_id not in (select employee_id from Employees ) \\n order by 1"
                    },
                    {
                        "username": "Utkarsh2ml",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id)\\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id) ORDER BY employee_id"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT employee_id FROM Salaries) \\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id not in(SELECT employee_id FROM Employees) \\nOrder by employee_id"
                    },
                    {
                        "username": "Cynotryl",
                        "content": "I just proposed this oracle solution myself and I don\\'t know despite of resulting in the same answer, the test case is still getting failed.\\n```\\nselect e.employee_id || s.employee_id as \"employee_id\"  from employees e full outer join salaries s on s.employee_id=e.employee_id where s.employee_id is null or e.employee_id is null;\\n```"
                    },
                    {
                        "username": "b0968760387",
                        "content": "because employee_id is int but it\\'s char at your answer. "
                    },
                    {
                        "username": "vikashkumarbth381",
                        "content": "select e.employee_id From Employees e left join salaries s\\non e.employee_id=s.employee_id\\nwhere s.salary is NULL\\nunion\\n\\nselect s.employee_id from salaries s left join employees e on s.employee_id=e.employee_id where e.name is null order by employee_id;"
                    },
                    {
                        "username": "user5418EK",
                        "content": "what is error in sql query below?\n\nselect Salaries.employee_id   from Employees full  outer join Salaries on Employees.employee_id =Salaries.employee_id where Salaries.employee_id NOT IN (select employee_id   from Employees inner  join Salaries on  Employees.employee_id =Salaries.employee_id )  order by employee_id  asc ;\n\n"
                    },
                    {
                        "username": "ruqinch",
                        "content": "MySQL does not support full outer join out of the box, so you will need to do a full outer join using a combination of other join types such as LEFT JOIN ad RIGHT JOIN that are supported in MySQL."
                    },
                    {
                        "username": "NikitaJain165",
                        "content": "Error : Unknown column \\'Employees.employee_id\\' in \\'on clause\\'\\n\\nAny idea what is wrong here?"
                    },
                    {
                        "username": "adnanghafoor2933",
                        "content": "My solution is ( employees  -  salaries ) U ( salaries - employees )\\n\\n` select employee_id from employees\\n    minus\\n select employee_id from salaries)\\nunion\\n\\n select employee_id from salaries\\n minus\\n select employee_id from employees`"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "it is showing error"
                    },
                    {
                        "username": "ishhanayy",
                        "content": " `# Write your MySQL query statement below\\nselect employee_id from Employees where employee_id not in (select employee_id from Employees natural join Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees natural join Salaries) order by employee_id;`"
                    },
                    {
                        "username": "husein14",
                        "content": "select employee_id from \\nEmployees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from\\nSalaries where employee_id not in (select employee_id from Employees)\\norder by employee_id asc;\\n"
                    }
                ]
            },
            {
                "id": 1734946,
                "content": [
                    {
                        "username": "rong6",
                        "content": "# Write your MySQL query statement below\\n\\nselect employee_id  from Employees \\n where employee_id not in (select employee_id from Salaries )\\n union\\n select employee_id  from Salaries \\n where employee_id not in (select employee_id from Employees ) \\n order by 1"
                    },
                    {
                        "username": "Utkarsh2ml",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id)\\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id) ORDER BY employee_id"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT employee_id FROM Salaries) \\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id not in(SELECT employee_id FROM Employees) \\nOrder by employee_id"
                    },
                    {
                        "username": "Cynotryl",
                        "content": "I just proposed this oracle solution myself and I don\\'t know despite of resulting in the same answer, the test case is still getting failed.\\n```\\nselect e.employee_id || s.employee_id as \"employee_id\"  from employees e full outer join salaries s on s.employee_id=e.employee_id where s.employee_id is null or e.employee_id is null;\\n```"
                    },
                    {
                        "username": "b0968760387",
                        "content": "because employee_id is int but it\\'s char at your answer. "
                    },
                    {
                        "username": "vikashkumarbth381",
                        "content": "select e.employee_id From Employees e left join salaries s\\non e.employee_id=s.employee_id\\nwhere s.salary is NULL\\nunion\\n\\nselect s.employee_id from salaries s left join employees e on s.employee_id=e.employee_id where e.name is null order by employee_id;"
                    },
                    {
                        "username": "user5418EK",
                        "content": "what is error in sql query below?\n\nselect Salaries.employee_id   from Employees full  outer join Salaries on Employees.employee_id =Salaries.employee_id where Salaries.employee_id NOT IN (select employee_id   from Employees inner  join Salaries on  Employees.employee_id =Salaries.employee_id )  order by employee_id  asc ;\n\n"
                    },
                    {
                        "username": "ruqinch",
                        "content": "MySQL does not support full outer join out of the box, so you will need to do a full outer join using a combination of other join types such as LEFT JOIN ad RIGHT JOIN that are supported in MySQL."
                    },
                    {
                        "username": "NikitaJain165",
                        "content": "Error : Unknown column \\'Employees.employee_id\\' in \\'on clause\\'\\n\\nAny idea what is wrong here?"
                    },
                    {
                        "username": "adnanghafoor2933",
                        "content": "My solution is ( employees  -  salaries ) U ( salaries - employees )\\n\\n` select employee_id from employees\\n    minus\\n select employee_id from salaries)\\nunion\\n\\n select employee_id from salaries\\n minus\\n select employee_id from employees`"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "it is showing error"
                    },
                    {
                        "username": "ishhanayy",
                        "content": " `# Write your MySQL query statement below\\nselect employee_id from Employees where employee_id not in (select employee_id from Employees natural join Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees natural join Salaries) order by employee_id;`"
                    },
                    {
                        "username": "husein14",
                        "content": "select employee_id from \\nEmployees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from\\nSalaries where employee_id not in (select employee_id from Employees)\\norder by employee_id asc;\\n"
                    }
                ]
            },
            {
                "id": 1725787,
                "content": [
                    {
                        "username": "rong6",
                        "content": "# Write your MySQL query statement below\\n\\nselect employee_id  from Employees \\n where employee_id not in (select employee_id from Salaries )\\n union\\n select employee_id  from Salaries \\n where employee_id not in (select employee_id from Employees ) \\n order by 1"
                    },
                    {
                        "username": "Utkarsh2ml",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id)\\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id) ORDER BY employee_id"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT employee_id FROM Salaries) \\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id not in(SELECT employee_id FROM Employees) \\nOrder by employee_id"
                    },
                    {
                        "username": "Cynotryl",
                        "content": "I just proposed this oracle solution myself and I don\\'t know despite of resulting in the same answer, the test case is still getting failed.\\n```\\nselect e.employee_id || s.employee_id as \"employee_id\"  from employees e full outer join salaries s on s.employee_id=e.employee_id where s.employee_id is null or e.employee_id is null;\\n```"
                    },
                    {
                        "username": "b0968760387",
                        "content": "because employee_id is int but it\\'s char at your answer. "
                    },
                    {
                        "username": "vikashkumarbth381",
                        "content": "select e.employee_id From Employees e left join salaries s\\non e.employee_id=s.employee_id\\nwhere s.salary is NULL\\nunion\\n\\nselect s.employee_id from salaries s left join employees e on s.employee_id=e.employee_id where e.name is null order by employee_id;"
                    },
                    {
                        "username": "user5418EK",
                        "content": "what is error in sql query below?\n\nselect Salaries.employee_id   from Employees full  outer join Salaries on Employees.employee_id =Salaries.employee_id where Salaries.employee_id NOT IN (select employee_id   from Employees inner  join Salaries on  Employees.employee_id =Salaries.employee_id )  order by employee_id  asc ;\n\n"
                    },
                    {
                        "username": "ruqinch",
                        "content": "MySQL does not support full outer join out of the box, so you will need to do a full outer join using a combination of other join types such as LEFT JOIN ad RIGHT JOIN that are supported in MySQL."
                    },
                    {
                        "username": "NikitaJain165",
                        "content": "Error : Unknown column \\'Employees.employee_id\\' in \\'on clause\\'\\n\\nAny idea what is wrong here?"
                    },
                    {
                        "username": "adnanghafoor2933",
                        "content": "My solution is ( employees  -  salaries ) U ( salaries - employees )\\n\\n` select employee_id from employees\\n    minus\\n select employee_id from salaries)\\nunion\\n\\n select employee_id from salaries\\n minus\\n select employee_id from employees`"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "it is showing error"
                    },
                    {
                        "username": "ishhanayy",
                        "content": " `# Write your MySQL query statement below\\nselect employee_id from Employees where employee_id not in (select employee_id from Employees natural join Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees natural join Salaries) order by employee_id;`"
                    },
                    {
                        "username": "husein14",
                        "content": "select employee_id from \\nEmployees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from\\nSalaries where employee_id not in (select employee_id from Employees)\\norder by employee_id asc;\\n"
                    }
                ]
            },
            {
                "id": 1724626,
                "content": [
                    {
                        "username": "rong6",
                        "content": "# Write your MySQL query statement below\\n\\nselect employee_id  from Employees \\n where employee_id not in (select employee_id from Salaries )\\n union\\n select employee_id  from Salaries \\n where employee_id not in (select employee_id from Employees ) \\n order by 1"
                    },
                    {
                        "username": "Utkarsh2ml",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id)\\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id) ORDER BY employee_id"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT employee_id FROM Salaries) \\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id not in(SELECT employee_id FROM Employees) \\nOrder by employee_id"
                    },
                    {
                        "username": "Cynotryl",
                        "content": "I just proposed this oracle solution myself and I don\\'t know despite of resulting in the same answer, the test case is still getting failed.\\n```\\nselect e.employee_id || s.employee_id as \"employee_id\"  from employees e full outer join salaries s on s.employee_id=e.employee_id where s.employee_id is null or e.employee_id is null;\\n```"
                    },
                    {
                        "username": "b0968760387",
                        "content": "because employee_id is int but it\\'s char at your answer. "
                    },
                    {
                        "username": "vikashkumarbth381",
                        "content": "select e.employee_id From Employees e left join salaries s\\non e.employee_id=s.employee_id\\nwhere s.salary is NULL\\nunion\\n\\nselect s.employee_id from salaries s left join employees e on s.employee_id=e.employee_id where e.name is null order by employee_id;"
                    },
                    {
                        "username": "user5418EK",
                        "content": "what is error in sql query below?\n\nselect Salaries.employee_id   from Employees full  outer join Salaries on Employees.employee_id =Salaries.employee_id where Salaries.employee_id NOT IN (select employee_id   from Employees inner  join Salaries on  Employees.employee_id =Salaries.employee_id )  order by employee_id  asc ;\n\n"
                    },
                    {
                        "username": "ruqinch",
                        "content": "MySQL does not support full outer join out of the box, so you will need to do a full outer join using a combination of other join types such as LEFT JOIN ad RIGHT JOIN that are supported in MySQL."
                    },
                    {
                        "username": "NikitaJain165",
                        "content": "Error : Unknown column \\'Employees.employee_id\\' in \\'on clause\\'\\n\\nAny idea what is wrong here?"
                    },
                    {
                        "username": "adnanghafoor2933",
                        "content": "My solution is ( employees  -  salaries ) U ( salaries - employees )\\n\\n` select employee_id from employees\\n    minus\\n select employee_id from salaries)\\nunion\\n\\n select employee_id from salaries\\n minus\\n select employee_id from employees`"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "it is showing error"
                    },
                    {
                        "username": "ishhanayy",
                        "content": " `# Write your MySQL query statement below\\nselect employee_id from Employees where employee_id not in (select employee_id from Employees natural join Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees natural join Salaries) order by employee_id;`"
                    },
                    {
                        "username": "husein14",
                        "content": "select employee_id from \\nEmployees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from\\nSalaries where employee_id not in (select employee_id from Employees)\\norder by employee_id asc;\\n"
                    }
                ]
            },
            {
                "id": 1719222,
                "content": [
                    {
                        "username": "rong6",
                        "content": "# Write your MySQL query statement below\\n\\nselect employee_id  from Employees \\n where employee_id not in (select employee_id from Salaries )\\n union\\n select employee_id  from Salaries \\n where employee_id not in (select employee_id from Employees ) \\n order by 1"
                    },
                    {
                        "username": "Utkarsh2ml",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id)\\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id) ORDER BY employee_id"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT employee_id FROM Salaries) \\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id not in(SELECT employee_id FROM Employees) \\nOrder by employee_id"
                    },
                    {
                        "username": "Cynotryl",
                        "content": "I just proposed this oracle solution myself and I don\\'t know despite of resulting in the same answer, the test case is still getting failed.\\n```\\nselect e.employee_id || s.employee_id as \"employee_id\"  from employees e full outer join salaries s on s.employee_id=e.employee_id where s.employee_id is null or e.employee_id is null;\\n```"
                    },
                    {
                        "username": "b0968760387",
                        "content": "because employee_id is int but it\\'s char at your answer. "
                    },
                    {
                        "username": "vikashkumarbth381",
                        "content": "select e.employee_id From Employees e left join salaries s\\non e.employee_id=s.employee_id\\nwhere s.salary is NULL\\nunion\\n\\nselect s.employee_id from salaries s left join employees e on s.employee_id=e.employee_id where e.name is null order by employee_id;"
                    },
                    {
                        "username": "user5418EK",
                        "content": "what is error in sql query below?\n\nselect Salaries.employee_id   from Employees full  outer join Salaries on Employees.employee_id =Salaries.employee_id where Salaries.employee_id NOT IN (select employee_id   from Employees inner  join Salaries on  Employees.employee_id =Salaries.employee_id )  order by employee_id  asc ;\n\n"
                    },
                    {
                        "username": "ruqinch",
                        "content": "MySQL does not support full outer join out of the box, so you will need to do a full outer join using a combination of other join types such as LEFT JOIN ad RIGHT JOIN that are supported in MySQL."
                    },
                    {
                        "username": "NikitaJain165",
                        "content": "Error : Unknown column \\'Employees.employee_id\\' in \\'on clause\\'\\n\\nAny idea what is wrong here?"
                    },
                    {
                        "username": "adnanghafoor2933",
                        "content": "My solution is ( employees  -  salaries ) U ( salaries - employees )\\n\\n` select employee_id from employees\\n    minus\\n select employee_id from salaries)\\nunion\\n\\n select employee_id from salaries\\n minus\\n select employee_id from employees`"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "it is showing error"
                    },
                    {
                        "username": "ishhanayy",
                        "content": " `# Write your MySQL query statement below\\nselect employee_id from Employees where employee_id not in (select employee_id from Employees natural join Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees natural join Salaries) order by employee_id;`"
                    },
                    {
                        "username": "husein14",
                        "content": "select employee_id from \\nEmployees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from\\nSalaries where employee_id not in (select employee_id from Employees)\\norder by employee_id asc;\\n"
                    }
                ]
            },
            {
                "id": 1696467,
                "content": [
                    {
                        "username": "rong6",
                        "content": "# Write your MySQL query statement below\\n\\nselect employee_id  from Employees \\n where employee_id not in (select employee_id from Salaries )\\n union\\n select employee_id  from Salaries \\n where employee_id not in (select employee_id from Employees ) \\n order by 1"
                    },
                    {
                        "username": "Utkarsh2ml",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id)\\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id) ORDER BY employee_id"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT employee_id FROM Salaries) \\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id not in(SELECT employee_id FROM Employees) \\nOrder by employee_id"
                    },
                    {
                        "username": "Cynotryl",
                        "content": "I just proposed this oracle solution myself and I don\\'t know despite of resulting in the same answer, the test case is still getting failed.\\n```\\nselect e.employee_id || s.employee_id as \"employee_id\"  from employees e full outer join salaries s on s.employee_id=e.employee_id where s.employee_id is null or e.employee_id is null;\\n```"
                    },
                    {
                        "username": "b0968760387",
                        "content": "because employee_id is int but it\\'s char at your answer. "
                    },
                    {
                        "username": "vikashkumarbth381",
                        "content": "select e.employee_id From Employees e left join salaries s\\non e.employee_id=s.employee_id\\nwhere s.salary is NULL\\nunion\\n\\nselect s.employee_id from salaries s left join employees e on s.employee_id=e.employee_id where e.name is null order by employee_id;"
                    },
                    {
                        "username": "user5418EK",
                        "content": "what is error in sql query below?\n\nselect Salaries.employee_id   from Employees full  outer join Salaries on Employees.employee_id =Salaries.employee_id where Salaries.employee_id NOT IN (select employee_id   from Employees inner  join Salaries on  Employees.employee_id =Salaries.employee_id )  order by employee_id  asc ;\n\n"
                    },
                    {
                        "username": "ruqinch",
                        "content": "MySQL does not support full outer join out of the box, so you will need to do a full outer join using a combination of other join types such as LEFT JOIN ad RIGHT JOIN that are supported in MySQL."
                    },
                    {
                        "username": "NikitaJain165",
                        "content": "Error : Unknown column \\'Employees.employee_id\\' in \\'on clause\\'\\n\\nAny idea what is wrong here?"
                    },
                    {
                        "username": "adnanghafoor2933",
                        "content": "My solution is ( employees  -  salaries ) U ( salaries - employees )\\n\\n` select employee_id from employees\\n    minus\\n select employee_id from salaries)\\nunion\\n\\n select employee_id from salaries\\n minus\\n select employee_id from employees`"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "it is showing error"
                    },
                    {
                        "username": "ishhanayy",
                        "content": " `# Write your MySQL query statement below\\nselect employee_id from Employees where employee_id not in (select employee_id from Employees natural join Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees natural join Salaries) order by employee_id;`"
                    },
                    {
                        "username": "husein14",
                        "content": "select employee_id from \\nEmployees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from\\nSalaries where employee_id not in (select employee_id from Employees)\\norder by employee_id asc;\\n"
                    }
                ]
            },
            {
                "id": 1694942,
                "content": [
                    {
                        "username": "rong6",
                        "content": "# Write your MySQL query statement below\\n\\nselect employee_id  from Employees \\n where employee_id not in (select employee_id from Salaries )\\n union\\n select employee_id  from Salaries \\n where employee_id not in (select employee_id from Employees ) \\n order by 1"
                    },
                    {
                        "username": "Utkarsh2ml",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id)\\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id NOT IN(SELECT A.employee_id\\nFROM Employees A\\nJOIN Salaries B ON A.employee_id=B.employee_id) ORDER BY employee_id"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT employee_id FROM Employees WHERE employee_id NOT IN(SELECT employee_id FROM Salaries) \\nUNION\\nSELECT employee_id FROM Salaries WHERE employee_id not in(SELECT employee_id FROM Employees) \\nOrder by employee_id"
                    },
                    {
                        "username": "Cynotryl",
                        "content": "I just proposed this oracle solution myself and I don\\'t know despite of resulting in the same answer, the test case is still getting failed.\\n```\\nselect e.employee_id || s.employee_id as \"employee_id\"  from employees e full outer join salaries s on s.employee_id=e.employee_id where s.employee_id is null or e.employee_id is null;\\n```"
                    },
                    {
                        "username": "b0968760387",
                        "content": "because employee_id is int but it\\'s char at your answer. "
                    },
                    {
                        "username": "vikashkumarbth381",
                        "content": "select e.employee_id From Employees e left join salaries s\\non e.employee_id=s.employee_id\\nwhere s.salary is NULL\\nunion\\n\\nselect s.employee_id from salaries s left join employees e on s.employee_id=e.employee_id where e.name is null order by employee_id;"
                    },
                    {
                        "username": "user5418EK",
                        "content": "what is error in sql query below?\n\nselect Salaries.employee_id   from Employees full  outer join Salaries on Employees.employee_id =Salaries.employee_id where Salaries.employee_id NOT IN (select employee_id   from Employees inner  join Salaries on  Employees.employee_id =Salaries.employee_id )  order by employee_id  asc ;\n\n"
                    },
                    {
                        "username": "ruqinch",
                        "content": "MySQL does not support full outer join out of the box, so you will need to do a full outer join using a combination of other join types such as LEFT JOIN ad RIGHT JOIN that are supported in MySQL."
                    },
                    {
                        "username": "NikitaJain165",
                        "content": "Error : Unknown column \\'Employees.employee_id\\' in \\'on clause\\'\\n\\nAny idea what is wrong here?"
                    },
                    {
                        "username": "adnanghafoor2933",
                        "content": "My solution is ( employees  -  salaries ) U ( salaries - employees )\\n\\n` select employee_id from employees\\n    minus\\n select employee_id from salaries)\\nunion\\n\\n select employee_id from salaries\\n minus\\n select employee_id from employees`"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "it is showing error"
                    },
                    {
                        "username": "ishhanayy",
                        "content": " `# Write your MySQL query statement below\\nselect employee_id from Employees where employee_id not in (select employee_id from Employees natural join Salaries)\\nunion\\nselect employee_id from Salaries where employee_id not in (select employee_id from Employees natural join Salaries) order by employee_id;`"
                    },
                    {
                        "username": "husein14",
                        "content": "select employee_id from \\nEmployees where employee_id not in (select employee_id from Salaries)\\nunion\\nselect employee_id from\\nSalaries where employee_id not in (select employee_id from Employees)\\norder by employee_id asc;\\n"
                    }
                ]
            }
        ]
    }
]