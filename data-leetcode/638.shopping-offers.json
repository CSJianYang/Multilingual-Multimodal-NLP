[
    {
        "title": "Candy",
        "question_content": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\nYou are giving candies to these children subjected to the following requirements:\n\n\tEach child must have at least one candy.\n\tChildren with a higher rating get more candies than their neighbors.\n\nReturn the minimum number of candies you need to have to distribute the candies to the children.\n&nbsp;\nExample 1:\n\nInput: ratings = [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\nExample 2:\n\nInput: ratings = [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n\n&nbsp;\nConstraints:\n\n\tn == ratings.length\n\t1 <= n <= 2 * 104\n\t0 <= ratings[i] <= 2 * 104",
        "solutions": [
            {
                "id": 42769,
                "title": "a-simple-solution",
                "content": "  \\n\\n      int candy(vector<int> &ratings)\\n     {\\n    \\t int size=ratings.size();\\n    \\t if(size<=1)\\n    \\t\\t return size;\\n    \\t vector<int> num(size,1);\\n    \\t for (int i = 1; i < size; i++)\\n    \\t {\\n    \\t\\t if(ratings[i]>ratings[i-1])\\n    \\t\\t\\t num[i]=num[i-1]+1;\\n    \\t }\\n    \\t for (int i= size-1; i>0 ; i--)\\n    \\t {\\n    \\t\\t if(ratings[i-1]>ratings[i])\\n    \\t\\t\\t num[i-1]=max(num[i]+1,num[i-1]);\\n    \\t }\\n    \\t int result=0;\\n    \\t for (int i = 0; i < size; i++)\\n    \\t {\\n    \\t\\t result+=num[i];\\n    \\t\\t// cout<<num[i]<<\" \";\\n    \\t }\\n    \\t return result;\\n     }",
                "solutionTags": [],
                "code": "  \\n\\n      int candy(vector<int> &ratings)\\n     {\\n    \\t int size=ratings.size();\\n    \\t if(size<=1)\\n    \\t\\t return size;\\n    \\t vector<int> num(size,1);\\n    \\t for (int i = 1; i < size; i++)\\n    \\t {\\n    \\t\\t if(ratings[i]>ratings[i-1])\\n    \\t\\t\\t num[i]=num[i-1]+1;\\n    \\t }\\n    \\t for (int i= size-1; i>0 ; i--)\\n    \\t {\\n    \\t\\t if(ratings[i-1]>ratings[i])\\n    \\t\\t\\t num[i-1]=max(num[i]+1,num[i-1]);\\n    \\t }\\n    \\t int result=0;\\n    \\t for (int i = 0; i < size; i++)\\n    \\t {\\n    \\t\\t result+=num[i];\\n    \\t\\t// cout<<num[i]<<\" \";\\n    \\t }\\n    \\t return result;\\n     }",
                "codeTag": "C++"
            },
            {
                "id": 2234434,
                "title": "c-o-n-time-o-1-space-full-explanation",
                "content": "***Upvote if Found Helpful***\\n\\n**Alternate O(n) Space Approach :**\\n\\nWe can easily calculate the number of candy needed by using an array to store the candy of each child. And after that traverse the rating array twice. The first loop makes sure children with a higher rating get more candy than its left neighbor, the second loop makes sure children with a higher rating get more candy than its right neighbor. At last add the total number of candies. This approach is O(n) time and O(n) space. This type of solutions are available in other posts.\\n\\n# **O(1) Space Approach :**\\n\\nWe can consider this problem like valley and peak problem. In each valley there should be 1 candy and for each increasing solpe in either side we need to increse candy by 1. Peaks have highest candy. If any equal rating is found then candy resets to 1 as two equal neighbours may have any number of candies. The peak should contain the higher number of candy between which is calculated from the incresing slope and which is calculated from decreasing slope. Because this will satisfy the condition that peak element is having more candies than its neighbours. \\n\\n***Example :***\\n\\n```\\nLet take the Rating as : [1,3,6,8,9,5,3,6,8,5,4,2,2,3,7,7,9,8,6,6,6,4,2]\\n\\nEach child represented as rating(candy he is given)\\nPeak = max(peak, valley)\\n\\nSee when peak is encountered we take max of the peak calculated from left and valley calculated from right.\\nWhen we get any equal element it gets reset to 1 candy or if it is peak we take max(0, right valley)\\n\\n           (5)         (4)                         (3)\\n            9           8                           9\\n           /|\\\\         /|\\\\                         /|\\\\\\n          / | \\\\       / | \\\\                (3)    / | \\\\\\n      (4)8  |  5(2)  6  |  5(3)             7 __ 7  |  8(2)\\n        /   |   \\\\   (2) |   \\\\              /|   (1) |   \\\\\\n       /    |    \\\\ /    |    \\\\            / |    |  |    \\\\         (3)\\n   (3)6     |     3     |     4(2)       3(2)    |  |     6 __ 6 __ 6    -> Total candy = 50\\n     /      |    (1)    |      \\\\        /   | Reset |    (1)  (1)   |\\\\\\n    /       |           |       \\\\      /    |  to 1 |          |    | \\\\\\n(2)3        |           |        2 __ 2     |       |          |    |  4(2)\\n  /         |           |       (1)  (1)    |       |        Reset  |   \\\\\\n /          |           |                   |       |         to 1  |    \\\\\\n1(1)        |           |                   |       |               |     2(1)\\n   Peak= max(5,3)  Peak= max(3,4)    Peak= max(3,0) |         Peak= max(0,3)\\n                                               Peak= max(2,3)   \\n```\\n\\n**Implementation :**\\n\\n* So we take initially n candy for n children. Then we start traversing the rating array from the second element. If we find equal elements we continue to next element as they already have 1 candy.\\n\\n* If an increasing slop is found `(ratings[i] > ratings [i-1])` we increase value of peak and and add the peak value to candy. After each iteration new peak is found and the value is added to candy. In this way we also get the value of minimum height of the peak at the end.\\n\\n* If a decreasing slope is found `(ratings[i] < ratings [i-1])` we calculate the depth of the valley which is in turn the minimum height of the previous peak. In each iteration we increse the valley by 1 and add it to the candy. You can visualise it as 1 candy is added to each of the previous members untill peak or the new peak value is interted at the previous peak and other values are shifted to right by 1 place. We also need to check if it is going out of array if so then return the number of candy.\\n\\n* After this we can see we have added the peak value twice in candy once as peak and once as valley. But we need only the max value out of these two so we substract the `min(peak, valley)` from candy. \\n\\n* After that return the candy.\\n\\n**Note :** We have considered the sequence increasing -> decreasing as peak should have the max value between the height of left (increasing) side and height of right (decreasing) side. In case of decresing -> increasing we dont need to give special attention as the vallley will always have 1 candy and in our code in this case peak will have 0 value so nothing will be substracted from the candy in the end of iteration.\\n\\nSee the example for better understanding :\\n\\n```\\nIn our code we increase the peak and add peak value untill we get the minimum actual peak.\\nIn case of the decreasing part take this example.\\n\\n[7,5,3,2], initial candy = 4, In each iteration valley++ and candy += valley\\n\\n7 starting (valley = 0, candy = 4, candy configuaration  = [1,1,1,1])\\n \\\\\\n  5 (valley = 1, candy = 4+1 = 5, candy configuaration  = [2,1,1,1])\\n   \\\\\\n    3 (valley = 2, candy = 5+2 = 7, candy configuaration = [3,2,1,1])\\n     \\\\\\n      2 [valley = 3, candy = 7+3 = 10, candy configuartion = [4,3,2,1])\\n\\t  \\nHere see the valley is at last equal to the minimum previous peak value.\\n\\nAs we have given 1 candy to all before so the peak and valley values are actually 1 less than the actual candy they should get.\\n```\\n\\n**Code :**\\n\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candy = n, i=1;\\n        while(i<n){\\n            if(ratings[i] == ratings[i-1]){\\n                i++;\\n                continue;\\n            }\\n            \\n            //For increasing slope\\n            int peak = 0;\\n            while(ratings[i] > ratings [i-1]){\\n                peak++;\\n                candy += peak;\\n                i++;\\n                if(i == n) return candy;\\n            }\\n            \\n            //For decreasing slope\\n            int valley = 0;\\n            while(i<n && ratings[i] < ratings[i-1]){\\n                valley++;\\n                candy += valley;\\n                i++;\\n            }\\n            candy -= min(peak, valley); //Keep only the higher peak\\n        }\\n        return candy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nLet take the Rating as : [1,3,6,8,9,5,3,6,8,5,4,2,2,3,7,7,9,8,6,6,6,4,2]\\n\\nEach child represented as rating(candy he is given)\\nPeak = max(peak, valley)\\n\\nSee when peak is encountered we take max of the peak calculated from left and valley calculated from right.\\nWhen we get any equal element it gets reset to 1 candy or if it is peak we take max(0, right valley)\\n\\n           (5)         (4)                         (3)\\n            9           8                           9\\n           /|\\\\         /|\\\\                         /|\\\\\\n          / | \\\\       / | \\\\                (3)    / | \\\\\\n      (4)8  |  5(2)  6  |  5(3)             7 __ 7  |  8(2)\\n        /   |   \\\\   (2) |   \\\\              /|   (1) |   \\\\\\n       /    |    \\\\ /    |    \\\\            / |    |  |    \\\\         (3)\\n   (3)6     |     3     |     4(2)       3(2)    |  |     6 __ 6 __ 6    -> Total candy = 50\\n     /      |    (1)    |      \\\\        /   | Reset |    (1)  (1)   |\\\\\\n    /       |           |       \\\\      /    |  to 1 |          |    | \\\\\\n(2)3        |           |        2 __ 2     |       |          |    |  4(2)\\n  /         |           |       (1)  (1)    |       |        Reset  |   \\\\\\n /          |           |                   |       |         to 1  |    \\\\\\n1(1)        |           |                   |       |               |     2(1)\\n   Peak= max(5,3)  Peak= max(3,4)    Peak= max(3,0) |         Peak= max(0,3)\\n                                               Peak= max(2,3)   \\n```\n```\\nIn our code we increase the peak and add peak value untill we get the minimum actual peak.\\nIn case of the decreasing part take this example.\\n\\n[7,5,3,2], initial candy = 4, In each iteration valley++ and candy += valley\\n\\n7 starting (valley = 0, candy = 4, candy configuaration  = [1,1,1,1])\\n \\\\\\n  5 (valley = 1, candy = 4+1 = 5, candy configuaration  = [2,1,1,1])\\n   \\\\\\n    3 (valley = 2, candy = 5+2 = 7, candy configuaration = [3,2,1,1])\\n     \\\\\\n      2 [valley = 3, candy = 7+3 = 10, candy configuartion = [4,3,2,1])\\n\\t  \\nHere see the valley is at last equal to the minimum previous peak value.\\n\\nAs we have given 1 candy to all before so the peak and valley values are actually 1 less than the actual candy they should get.\\n```\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candy = n, i=1;\\n        while(i<n){\\n            if(ratings[i] == ratings[i-1]){\\n                i++;\\n                continue;\\n            }\\n            \\n            //For increasing slope\\n            int peak = 0;\\n            while(ratings[i] > ratings [i-1]){\\n                peak++;\\n                candy += peak;\\n                i++;\\n                if(i == n) return candy;\\n            }\\n            \\n            //For decreasing slope\\n            int valley = 0;\\n            while(i<n && ratings[i] < ratings[i-1]){\\n                valley++;\\n                candy += valley;\\n                i++;\\n            }\\n            candy -= min(peak, valley); //Keep only the higher peak\\n        }\\n        return candy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 135698,
                "title": "simple-solution-with-one-pass-using-o-1-space",
                "content": "To use two variables  \\'up\\' and \\'down\\' to count the steps of continuous up and down respectively, and a \\'peak\\' representing the peak before going down. In the below example:\\n```\\n[0, 1, 20, 9, 8, 7]\\n```\\nScan from left to right, first child is given 1 candy;\\nthe second child is given 2 candies,  and up=1;\\nthe third child is given 3 candies,  and up=2; peak=2;\\nthe fourth child is given 1 candy,  and down=1; and third child still has 3 candies since peak=2;\\nthe fifth child is given 1 candy,  and down=2; and the previous child needs 1 more candy now but the third child no need more;\\nthe sixth child is given 1 candy,  and down=3; and both the fifth and fourth child needs 1 more candy now, and the peak, the third child need 1 more as well.\\n```\\n        public int Candy(int[] ratings) {\\n            if (ratings.Length == 0) return 0;\\n            int ret = 1;\\n            int up = 0, down = 0, peak = 0;\\n            for (int i = 1; i < ratings.Length; i++) {\\n                if (ratings[i - 1] < ratings[i]) {\\n                    peak = ++up;\\n                    down = 0;\\n                    ret += 1 + up;\\n                } else if (ratings[i - 1] == ratings[i])  {\\n                    peak = up = down = 0;\\n                    ret += 1;\\n                } else {\\n                    up = 0;\\n                    down++;\\n                    ret += 1 + down + (peak >= down ? -1 : 0);\\n                }\\n            }\\n\\n            return ret;\\n        }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n[0, 1, 20, 9, 8, 7]\\n```\n```\\n        public int Candy(int[] ratings) {\\n            if (ratings.Length == 0) return 0;\\n            int ret = 1;\\n            int up = 0, down = 0, peak = 0;\\n            for (int i = 1; i < ratings.Length; i++) {\\n                if (ratings[i - 1] < ratings[i]) {\\n                    peak = ++up;\\n                    down = 0;\\n                    ret += 1 + up;\\n                } else if (ratings[i - 1] == ratings[i])  {\\n                    peak = up = down = 0;\\n                    ret += 1;\\n                } else {\\n                    up = 0;\\n                    down++;\\n                    ret += 1 + down + (peak >= down ? -1 : 0);\\n                }\\n            }\\n\\n            return ret;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 42794,
                "title": "simple-o-n-java-solution-with-comments",
                "content": "    public int candy(int[] ratings) {\\n        int candies[] = new int[ratings.length];        \\n        Arrays.fill(candies, 1);// Give each child 1 candy \\n        \\t\\n        for (int i = 1; i < candies.length; i++){// Scan from left to right, to make sure right higher rated child gets 1 more candy than left lower rated child\\n\\t        if (ratings[i] > ratings[i - 1]) candies[i] = (candies[i - 1] + 1);\\n\\t    }\\n\\t     \\n\\t    for (int i = candies.length - 2; i >= 0; i--) {// Scan from right to left, to make sure left higher rated child gets 1 more candy than right lower rated child\\n\\t\\t    if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], (candies[i + 1] + 1));\\n\\t    }\\n\\t    \\n        int sum = 0;        \\n        for (int candy : candies)  \\n        \\tsum += candy;        \\n        return sum;\\n\\t}",
                "solutionTags": [],
                "code": "    public int candy(int[] ratings) {\\n        int candies[] = new int[ratings.length];        \\n        Arrays.fill(candies, 1);// Give each child 1 candy \\n        \\t\\n        for (int i = 1; i < candies.length; i++){// Scan from left to right, to make sure right higher rated child gets 1 more candy than left lower rated child\\n\\t        if (ratings[i] > ratings[i - 1]) candies[i] = (candies[i - 1] + 1);\\n\\t    }\\n\\t     \\n\\t    for (int i = candies.length - 2; i >= 0; i--) {// Scan from right to left, to make sure left higher rated child gets 1 more candy than right lower rated child\\n\\t\\t    if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], (candies[i + 1] + 1));\\n\\t    }\\n\\t    \\n        int sum = 0;        \\n        for (int candy : candies)  \\n        \\tsum += candy;        \\n        return sum;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 4037646,
                "title": "99-20-greedy-two-one-pass",
                "content": "# Comprehensive Guide to Solving \"Candy\": Distributing Candies Like a Pro\\n\\n## Introduction & Problem Statement\\n\\nHey there, coding enthusiasts! Welcome back to another exciting coding session. Today\\'s problem is a treat\\u2014literally! We\\'re going to solve the \"Candy\" problem. Imagine you have a bunch of kids lined up, each with a rating assigned to them. Your task is to distribute candies to these kids following two simple rules:\\n\\n1. Every child must get at least one candy.\\n2. A child with a higher rating should get more candies than their immediate neighbors.\\n\\nSounds like a piece of cake, right? But here\\'s the twist: you need to accomplish this with the fewest candies possible. Let\\'s dig into the mechanics of this problem and how to approach it.\\n\\n## Key Concepts and Constraints\\n\\n### Why is This Problem Unique?\\n\\n1. **Child Ratings**: \\n   The ratings of each child are your only guide in how you distribute the candies. Following the rules while using these ratings makes this problem an intriguing puzzle.\\n  \\n2. **Minimum Candies**: \\n   You\\'re not just distributing candies willy-nilly; the goal is to meet the conditions using the least amount of candy.\\n\\n3. **Constraints**: \\n   - The length of the ratings array, `n` , is between  $$1$$  and $$ 2 \\\\times 10^4 $$.\\n   - Ratings are integers between $$0$$ and $$ 2 \\\\times 10^4 $$.\\n\\n### Strategies to Tackle the Problem\\n\\n1. **Greedy Algorithm: Two-Pass Method**  \\n   This method takes two passes through the ratings array to ensure that each child gets the appropriate amount of candy.\\n\\n2. **One-Pass Greedy Algorithm: Up-Down-Peak Method**  \\n   This more advanced method uses a single pass and employs three key variables\\u2014Up, Down, and Peak\\u2014to efficiently determine the minimum number of candies needed.\\n\\n---\\n\\n## Live Coding + Explenation of Greedy Two Pass\\nhttps://youtu.be/JqrZHuhljps?si=TxkUjNTZ1CxMviij\\n\\n## Greedy Algorithm: Two-Pass Method Explained\\n\\n### What is a Greedy Algorithm?\\n\\nA Greedy Algorithm makes choices that seem optimal at the moment. For this problem, we use a two-pass greedy approach to make sure each child gets the minimum number of candies that still satisfy the conditions.\\n\\n### The Nuts and Bolts of the Two-Pass Method\\n\\n1. **Initialize Candies Array**  \\n   - We start by creating a `candies` array of the same length as the `ratings` array and initialize all its values to 1. This is the base case and ensures that every child will receive at least one candy, satisfying the first condition.\\n  \\n2. **Forward Pass: Left to Right**\\n   - Now, we iterate through the `ratings` array from the beginning to the end. For each child (except the first), we compare their rating with the one to the left. If it\\'s higher, we update the `candies` array for that child to be one more than the child on the left. This takes care of the second condition but only accounts for the child\\'s left neighbor.\\n   \\n3. **Backward Pass: Right to Left**  \\n   - After the forward pass, we loop through the array again but in the reverse direction. This time, we compare each child\\'s rating with the child to their right. If the rating is higher, we need to make sure the child has more candies than the right neighbor. So, we update the `candies` array for that child to be the maximum between its current number of candies and one more than the right neighbor\\'s candies. This ensures that both neighboring conditions are checked and satisfied.\\n   \\n4. **Summing it All Up**\\n   - Finally, we sum up all the values in the `candies` array. This will give us the minimum total number of candies that need to be distributed to satisfy both conditions.\\n  \\n### Time and Space Complexity\\n\\n- **Time Complexity**: $$O(n)$$, because we make two passes through the array.\\n- **Space Complexity**: $$O(n)$$, for storing the `candies` array.\\n\\n## Code Greedy\\n``` Python []\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        candies = [1] * n \\n\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i-1]:\\n                candies[i] = candies[i-1] + 1\\n\\n        for i in range(n-2, -1, -1):\\n            if ratings[i] > ratings[i+1]:\\n                candies[i] = max(candies[i], candies[i+1] + 1)\\n        \\n        return sum(candies)\\n```\\n``` Go []\\nfunc candy(ratings []int) int {\\n    n := len(ratings)\\n    candies := make([]int, n)\\n    for i := range candies {\\n        candies[i] = 1\\n    }\\n\\n    for i := 1; i < n; i++ {\\n        if ratings[i] > ratings[i-1] {\\n            candies[i] = candies[i-1] + 1\\n        }\\n    }\\n\\n    for i := n - 2; i >= 0; i-- {\\n        if ratings[i] > ratings[i+1] {\\n            if candies[i] <= candies[i+1] {\\n                candies[i] = candies[i+1] + 1\\n            }\\n        }\\n    }\\n\\n    totalCandies := 0\\n    for _, candy := range candies {\\n        totalCandies += candy\\n    }\\n\\n    return totalCandies\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn candy(ratings: Vec<i32>) -> i32 {\\n        let n = ratings.len();\\n        let mut candies = vec![1; n];\\n\\n        for i in 1..n {\\n            if ratings[i] > ratings[i - 1] {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        for i in (0..n - 1).rev() {\\n            if ratings[i] > ratings[i + 1] {\\n                candies[i] = std::cmp::max(candies[i], candies[i + 1] + 1);\\n            }\\n        }\\n\\n        candies.iter().sum()\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int candy(std::vector<int>& ratings) {\\n        int n = ratings.size();\\n        std::vector<int> candies(n, 1);\\n\\n        for (int i = 1; i < n; ++i) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 2; i >= 0; --i) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                candies[i] = std::max(candies[i], candies[i + 1] + 1);\\n            }\\n        }\\n\\n        int totalCandies = 0;\\n        for (int candy : candies) {\\n            totalCandies += candy;\\n        }\\n\\n        return totalCandies;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] candies = new int[n];\\n        Arrays.fill(candies, 1);\\n\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                candies[i] = Math.max(candies[i], candies[i + 1] + 1);\\n            }\\n        }\\n\\n        int totalCandies = 0;\\n        for (int candy : candies) {\\n            totalCandies += candy;\\n        }\\n\\n        return totalCandies;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public int Candy(int[] ratings) {\\n        int n = ratings.Length;\\n        int[] candies = new int[n];\\n        Array.Fill(candies, 1);\\n\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                candies[i] = Math.Max(candies[i], candies[i + 1] + 1);\\n            }\\n        }\\n\\n        int totalCandies = 0;\\n        foreach (int candy in candies) {\\n            totalCandies += candy;\\n        }\\n\\n        return totalCandies;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} ratings\\n * @return {number}\\n */\\nvar candy = function(ratings) {\\n    const n = ratings.length;\\n    const candies = new Array(n).fill(1);\\n\\n    for (let i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (let i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1]) {\\n            candies[i] = Math.max(candies[i], candies[i + 1] + 1);\\n        }\\n    }\\n\\n    return candies.reduce((a, b) => a + b, 0);\\n};\\n```\\n``` PHP []\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $ratings\\n     * @return Integer\\n     */\\n    function candy($ratings) {\\n        $n = count($ratings);\\n        $candies = array_fill(0, $n, 1);\\n\\n        for ($i = 1; $i < $n; $i++) {\\n            if ($ratings[$i] > $ratings[$i - 1]) {\\n                $candies[$i] = $candies[$i - 1] + 1;\\n            }\\n        }\\n\\n        for ($i = $n - 2; $i >= 0; $i--) {\\n            if ($ratings[$i] > $ratings[$i + 1]) {\\n                $candies[$i] = max($candies[$i], $candies[$i + 1] + 1);\\n            }\\n        }\\n\\n        return array_sum($candies);\\n    }\\n}\\n```\\n## One-Pass Greedy Algorithm: Up-Down-Peak Method\\n\\n### Why `Up`, `Down`, and `Peak`?\\n\\nThe essence of the one-pass greedy algorithm lies in these three variables: `Up`, `Down`, and `Peak`. They serve as counters for the following:\\n\\n- **`Up`:** Counts how many children have **increasing ratings** from the last child. This helps us determine how many candies we need for a child with a higher rating than the previous child.\\n  \\n- **`Down`:** Counts how many children have **decreasing ratings** from the last child. This helps us determine how many candies we need for a child with a lower rating than the previous child.\\n\\n- **`Peak`:** Keeps track of the **last highest point** in an increasing sequence. When we have a decreasing sequence after the peak, we can refer back to the `Peak` to adjust the number of candies if needed.\\n\\n### How Does it Work?\\n\\n1. **Initialize Your Counters**\\n   - Start with `ret = 1` because each child must have at least one candy. Initialize `up`, `down`, and `peak` to 0.\\n   \\n2. **Loop Through Ratings**\\n   - For each pair of adjacent children, compare their ratings. Here are the scenarios:\\n   \\n     - **If the rating is increasing**: Update `up` and `peak` by incrementing them by 1. Set `down` to 0. Add `up + 1` to `ret` because the current child must have one more candy than the previous child.\\n     \\n     - **If the rating is the same**: Reset `up`, `down`, and `peak` to 0, because neither an increasing nor a decreasing trend is maintained. Add 1 to `ret` because the current child must have at least one candy.\\n     \\n     - **If the rating is decreasing**: Update `down` by incrementing it by 1. Reset `up` to 0. Add `down` to `ret`. Additionally, if `peak` is greater than or equal to `down`, decrement `ret` by 1. This is because the peak child can share the same number of candies as one of the children in the decreasing sequence, which allows us to reduce the total number of candies.\\n  \\n3. **Return the Total Candy Count**\\n   - At the end of the loop, `ret` will contain the minimum total number of candies needed for all the children, so return `ret`.\\n\\nBy using `up`, `down`, and `peak`, we can efficiently traverse the ratings list just once, updating our total candies count (`ret`) as we go. This method is efficient and helps us solve the problem in a single pass, with a time complexity of $$O(n)$$.\\n### Time and Space Complexity\\n\\n- **Time Complexity**: $$O(n)$$, for the single pass through the ratings array.\\n- **Space Complexity**: $$O(1)$$, as we only use a few extra variables.\\n\\n## Code One-Pass Greedy\\n``` Python []\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        if not ratings:\\n            return 0\\n        \\n        ret, up, down, peak = 1, 0, 0, 0\\n        \\n        for prev, curr in zip(ratings[:-1], ratings[1:]):\\n            if prev < curr:\\n                up, down, peak = up + 1, 0, up + 1\\n                ret += 1 + up\\n            elif prev == curr:\\n                up = down = peak = 0\\n                ret += 1\\n            else:\\n                up, down = 0, down + 1\\n                ret += 1 + down - int(peak >= down)\\n        \\n        return ret\\n\\n```\\n``` Go []\\nfunc candy(ratings []int) int {\\n    if len(ratings) == 0 {\\n        return 0\\n    }\\n\\n    ret, up, down, peak := 1, 0, 0, 0\\n\\n    for i := 0; i < len(ratings) - 1; i++ {\\n        prev, curr := ratings[i], ratings[i+1]\\n\\n        if prev < curr {\\n            up++\\n            down = 0\\n            peak = up\\n            ret += 1 + up\\n        } else if prev == curr {\\n            up, down, peak = 0, 0, 0\\n            ret += 1\\n        } else {\\n            up = 0\\n            down++\\n            ret += 1 + down\\n            if peak >= down {\\n                ret--\\n            }\\n        }\\n    }\\n\\n    return ret\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn candy(ratings: Vec<i32>) -> i32 {\\n        if ratings.is_empty() {\\n            return 0;\\n        }\\n\\n        let mut ret = 1;\\n        let mut up = 0;\\n        let mut down = 0;\\n        let mut peak = 0;\\n\\n        for i in 0..ratings.len() - 1 {\\n            let (prev, curr) = (ratings[i], ratings[i + 1]);\\n\\n            if prev < curr {\\n                up += 1;\\n                down = 0;\\n                peak = up;\\n                ret += 1 + up;\\n            } else if prev == curr {\\n                up = 0;\\n                down = 0;\\n                peak = 0;\\n                ret += 1;\\n            } else {\\n                up = 0;\\n                down += 1;\\n                ret += 1 + down;\\n                if peak >= down {\\n                    ret -= 1;\\n                }\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n```\\n\\n## Performance Comparison\\n\\n| Language  | Approach  | Time (ms)  | Memory (MB) |\\n|-----------|-----------|------------|-------------|\\n| Rust      | One Pass  | 1          | 2.1         |\\n| Rust      | Two Pass  | 2          | 2.3         |\\n| Java      | Two Pass  | 3          | 44.3        |\\n| Go        | One Pass  | 9          | 6.2         |\\n| C++       | Two Pass  | 11         | 17.8        |\\n| Go        | Two Pass  | 14         | 6.6         |\\n| PHP       | Two Pass  | 42         | 21.9        |\\n| JavaScript| Two Pass  | 59         | 45.1        |\\n| C#        | Two Pass  | 98         | 44.3        |\\n| Python3   | One Pass  | 126        | 19.5        |\\n| Python3   | Two Pass  | 139        | 19.2        |\\n\\n![h2.png](https://assets.leetcode.com/users/images/098d38e8-c14e-48b3-9c98-3394eb56d996_1694566150.8876379.png)\\n\\n## Live Coding & Explenation - One Pass\\nhttps://youtu.be/_MVFeqfiDK4?si=t8El9b9mlUQneXDk\\n\\n## Code Highlights and Best Practices\\n\\n- The Two-Pass Greedy Algorithm is straightforward and effective, making it a solid approach for this problem.\\n- The One-Pass Greedy Algorithm is even more efficient in terms of space complexity and is also a bit more challenging to understand.\\n  \\nBy mastering these approaches, you\\'ll be well-equipped to tackle other optimization problems, which are common in coding interviews and competitive programming. So, are you ready to distribute some candies? Let\\'s get coding!\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Array",
                    "Greedy"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        candies = [1] * n \\n\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i-1]:\\n                candies[i] = candies[i-1] + 1\\n\\n        for i in range(n-2, -1, -1):\\n            if ratings[i] > ratings[i+1]:\\n                candies[i] = max(candies[i], candies[i+1] + 1)\\n        \\n        return sum(candies)\\n```\n``` Go []\\nfunc candy(ratings []int) int {\\n    n := len(ratings)\\n    candies := make([]int, n)\\n    for i := range candies {\\n        candies[i] = 1\\n    }\\n\\n    for i := 1; i < n; i++ {\\n        if ratings[i] > ratings[i-1] {\\n            candies[i] = candies[i-1] + 1\\n        }\\n    }\\n\\n    for i := n - 2; i >= 0; i-- {\\n        if ratings[i] > ratings[i+1] {\\n            if candies[i] <= candies[i+1] {\\n                candies[i] = candies[i+1] + 1\\n            }\\n        }\\n    }\\n\\n    totalCandies := 0\\n    for _, candy := range candies {\\n        totalCandies += candy\\n    }\\n\\n    return totalCandies\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn candy(ratings: Vec<i32>) -> i32 {\\n        let n = ratings.len();\\n        let mut candies = vec![1; n];\\n\\n        for i in 1..n {\\n            if ratings[i] > ratings[i - 1] {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        for i in (0..n - 1).rev() {\\n            if ratings[i] > ratings[i + 1] {\\n                candies[i] = std::cmp::max(candies[i], candies[i + 1] + 1);\\n            }\\n        }\\n\\n        candies.iter().sum()\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int candy(std::vector<int>& ratings) {\\n        int n = ratings.size();\\n        std::vector<int> candies(n, 1);\\n\\n        for (int i = 1; i < n; ++i) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 2; i >= 0; --i) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                candies[i] = std::max(candies[i], candies[i + 1] + 1);\\n            }\\n        }\\n\\n        int totalCandies = 0;\\n        for (int candy : candies) {\\n            totalCandies += candy;\\n        }\\n\\n        return totalCandies;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] candies = new int[n];\\n        Arrays.fill(candies, 1);\\n\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                candies[i] = Math.max(candies[i], candies[i + 1] + 1);\\n            }\\n        }\\n\\n        int totalCandies = 0;\\n        for (int candy : candies) {\\n            totalCandies += candy;\\n        }\\n\\n        return totalCandies;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public int Candy(int[] ratings) {\\n        int n = ratings.Length;\\n        int[] candies = new int[n];\\n        Array.Fill(candies, 1);\\n\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                candies[i] = Math.Max(candies[i], candies[i + 1] + 1);\\n            }\\n        }\\n\\n        int totalCandies = 0;\\n        foreach (int candy in candies) {\\n            totalCandies += candy;\\n        }\\n\\n        return totalCandies;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} ratings\\n * @return {number}\\n */\\nvar candy = function(ratings) {\\n    const n = ratings.length;\\n    const candies = new Array(n).fill(1);\\n\\n    for (let i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (let i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1]) {\\n            candies[i] = Math.max(candies[i], candies[i + 1] + 1);\\n        }\\n    }\\n\\n    return candies.reduce((a, b) => a + b, 0);\\n};\\n```\n``` PHP []\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $ratings\\n     * @return Integer\\n     */\\n    function candy($ratings) {\\n        $n = count($ratings);\\n        $candies = array_fill(0, $n, 1);\\n\\n        for ($i = 1; $i < $n; $i++) {\\n            if ($ratings[$i] > $ratings[$i - 1]) {\\n                $candies[$i] = $candies[$i - 1] + 1;\\n            }\\n        }\\n\\n        for ($i = $n - 2; $i >= 0; $i--) {\\n            if ($ratings[$i] > $ratings[$i + 1]) {\\n                $candies[$i] = max($candies[$i], $candies[$i + 1] + 1);\\n            }\\n        }\\n\\n        return array_sum($candies);\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        if not ratings:\\n            return 0\\n        \\n        ret, up, down, peak = 1, 0, 0, 0\\n        \\n        for prev, curr in zip(ratings[:-1], ratings[1:]):\\n            if prev < curr:\\n                up, down, peak = up + 1, 0, up + 1\\n                ret += 1 + up\\n            elif prev == curr:\\n                up = down = peak = 0\\n                ret += 1\\n            else:\\n                up, down = 0, down + 1\\n                ret += 1 + down - int(peak >= down)\\n        \\n        return ret\\n\\n```\n``` Go []\\nfunc candy(ratings []int) int {\\n    if len(ratings) == 0 {\\n        return 0\\n    }\\n\\n    ret, up, down, peak := 1, 0, 0, 0\\n\\n    for i := 0; i < len(ratings) - 1; i++ {\\n        prev, curr := ratings[i], ratings[i+1]\\n\\n        if prev < curr {\\n            up++\\n            down = 0\\n            peak = up\\n            ret += 1 + up\\n        } else if prev == curr {\\n            up, down, peak = 0, 0, 0\\n            ret += 1\\n        } else {\\n            up = 0\\n            down++\\n            ret += 1 + down\\n            if peak >= down {\\n                ret--\\n            }\\n        }\\n    }\\n\\n    return ret\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn candy(ratings: Vec<i32>) -> i32 {\\n        if ratings.is_empty() {\\n            return 0;\\n        }\\n\\n        let mut ret = 1;\\n        let mut up = 0;\\n        let mut down = 0;\\n        let mut peak = 0;\\n\\n        for i in 0..ratings.len() - 1 {\\n            let (prev, curr) = (ratings[i], ratings[i + 1]);\\n\\n            if prev < curr {\\n                up += 1;\\n                down = 0;\\n                peak = up;\\n                ret += 1 + up;\\n            } else if prev == curr {\\n                up = 0;\\n                down = 0;\\n                peak = 0;\\n                ret += 1;\\n            } else {\\n                up = 0;\\n                down += 1;\\n                ret += 1 + down;\\n                if peak >= down {\\n                    ret -= 1;\\n                }\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42770,
                "title": "one-pass-constant-space-java-solution",
                "content": "Hi guys!\\n\\nThis solution picks each element from the input array only once. First, we give a candy to the first child. Then for each child we have three cases:\\n\\n 1. His/her rating is equal to the previous one -> give 1 candy.\\n 2. His/her rating is greater than the previous one -> give him (previous + 1) candies.\\n 3. His/her rating is less than the previous one -> don't know what to do yet, let's just count the number of such consequent cases.\\n \\nWhen we enter 1 or 2 condition we can check our count from 3. If it's not zero then we know that we were descending before and we have everything to update our total candies amount: number of children in descending sequence of raitings - coundDown, number of candies given at peak - prev (we don't update prev when descending). Total number of candies for \"descending\" children can be found through arithmetic progression formula (1+2+...+countDown). Plus we need to update our peak child if his number of candies is less then or equal to countDown. \\n\\nHere's a pretty concise code below.\\n\\n----------\\n\\n    public class Solution {\\n        public int candy(int[] ratings) {\\n            if (ratings == null || ratings.length == 0) return 0;\\n            int total = 1, prev = 1, countDown = 0;\\n            for (int i = 1; i < ratings.length; i++) {\\n                if (ratings[i] >= ratings[i-1]) {\\n                    if (countDown > 0) {\\n                        total += countDown*(countDown+1)/2; // arithmetic progression\\n                        if (countDown >= prev) total += countDown - prev + 1;\\n                        countDown = 0;\\n                        prev = 1;\\n                    }\\n                    prev = ratings[i] == ratings[i-1] ? 1 : prev+1;\\n                    total += prev;\\n                } else countDown++;\\n            }\\n            if (countDown > 0) { // if we were descending at the end\\n                total += countDown*(countDown+1)/2;\\n                if (countDown >= prev) total += countDown - prev + 1;\\n            }\\n            return total;\\n        }\\n    }\\n\\nHave a nice coding!",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int candy(int[] ratings) {\\n            if (ratings == null || ratings.length == 0) return 0;\\n            int total = 1, prev = 1, countDown = 0;\\n            for (int i = 1; i < ratings.length; i++) {\\n                if (ratings[i] >= ratings[i-1]) {\\n                    if (countDown > 0) {\\n                        total += countDown*(countDown+1)/2; // arithmetic progression\\n                        if (countDown >= prev) total += countDown - prev + 1;\\n                        countDown = 0;\\n                        prev = 1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1300194,
                "title": "python-o-n-time-solution-explained",
                "content": "Go from left to right and while increase, give the the next person +1 candy from previous, if not, leave number of candies as it was. In this way when we make this pass we make sure that condition that person with bigger value gets more candies fulfilled for pairs of adjusent persons where left person is smaller than right. Now, go from right to left and do the same: now we cover pairs of adjacent persons where right is smaller than left. After these two passes all persons are happy.\\n\\n#### Complexity\\nOverall time and space complexity is `O(n)`. Remark: there is also `O(1)` space complexity solution using the idea of peaks and valleys.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def candy(self, R):\\n        n, ans = len(R), [1]*len(R)\\n        \\n        for i in range(n-1):\\n            if R[i] < R[i+1]:\\n                ans[i+1] = max(1 + ans[i], ans[i+1])\\n                \\n        for i in range(n-2, -1, -1):\\n            if R[i+1] < R[i]:\\n                ans[i] = max(1 + ans[i+1], ans[i])\\n        \\n        return sum(ans)\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def candy(self, R):\\n        n, ans = len(R), [1]*len(R)\\n        \\n        for i in range(n-1):\\n            if R[i] < R[i+1]:\\n                ans[i+1] = max(1 + ans[i], ans[i+1])\\n                \\n        for i in range(n-2, -1, -1):\\n            if R[i+1] < R[i]:\\n                ans[i] = max(1 + ans[i+1], ans[i])\\n        \\n        return sum(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42774,
                "title": "very-simple-java-solution-with-detail-explanation",
                "content": "    We take ratings array as [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]\\n\\nIn the given problem each student will have at least 1 candy. So distribute 1 candy to each.\\n\\n    ratings:     [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]\\n    candies:     [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n\\nNow traverse the array from left to right. If the rating of (n+1) child is greater than (n) child then set the candy of (n+1) child as one candy more than the (n) child candies.\\n\\n    ratings:     [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]\\n    candies:     [1, 2, 1, 1, 2, 3, 4, 1, 1, 1, 2, 1]\\n\\nNow  traverse the array from right to left. If the (n) child rating is more than (n+1) child and (n) child candies is less than one more than (n+1) child candies then update the candies of (n) child as 1+ (n+1) candies.\\n\\n    ratings:     [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]\\n    candies:     [1, 2, 1, 1, 2, 3, 4, 3, 2, 1, 2, 1]\\n\\nTotal minimum candies: 23\\n\\n    public int candy(int[] ratings) {\\n            int sum=0;\\n            int[] a=new int[ratings.length];\\n            for(int i=0;i<a.length;i++)\\n            {\\n                a[i]=1;\\n            }\\n            for(int i=0;i<ratings.length-1;i++)\\n            {\\n                if(ratings[i+1]>ratings[i])\\n                {\\n                    a[i+1]=a[i]+1;\\n                }\\n            }\\n            for(int i=ratings.length-1;i>0;i--)\\n            {\\n                if(ratings[i-1]>ratings[i])\\n                {\\n                    if(a[i-1]<(a[i]+1))\\n                    {\\n                        a[i-1]=a[i]+1;\\n                    }\\n                }\\n            }\\n            for(int i=0;i<a.length;i++)\\n            {\\n                sum+=a[i];\\n            }\\n            return sum;\\n        }",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "    We take ratings array as [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]\\n\\nIn the given problem each student will have at least 1 candy. So distribute 1 candy to each.\\n\\n    ratings:     [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]\\n    candies:     [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n\\nNow traverse the array from left to right. If the rating of (n+1) child is greater than (n) child then set the candy of (n+1) child as one candy more than the (n) child candies.\\n\\n    ratings:     [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]\\n    candies:     [1, 2, 1, 1, 2, 3, 4, 1, 1, 1, 2, 1]\\n\\nNow  traverse the array from right to left. If the (n) child rating is more than (n+1) child and (n) child candies is less than one more than (n+1) child candies then update the candies of (n) child as 1+ (n+1) candies.\\n\\n    ratings:     [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]\\n    candies:     [1, 2, 1, 1, 2, 3, 4, 3, 2, 1, 2, 1]\\n\\nTotal minimum candies: 23\\n\\n    public int candy(int[] ratings) {\\n            int sum=0;\\n            int[] a=new int[ratings.length];\\n            for(int i=0;i<a.length;i++)\\n            {\\n                a[i]=1;\\n            }\\n            for(int i=0;i<ratings.length-1;i++)\\n            {\\n                if(ratings[i+1]>ratings[i])\\n                {\\n                    a[i+1]=a[i]+1;\\n                }\\n            }\\n            for(int i=ratings.length-1;i>0;i--)\\n            {\\n                if(ratings[i-1]>ratings[i])\\n                {\\n                    if(a[i-1]<(a[i]+1))\\n                    {\\n                        a[i-1]=a[i]+1;\\n                    }\\n                }\\n            }\\n            for(int i=0;i<a.length;i++)\\n            {\\n                sum+=a[i];\\n            }\\n            return sum;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1300022,
                "title": "candy-distribution-c-99-faster-explained",
                "content": "Used greedy aproach:\\n1. every student should get atleast one so initially give 1 candy to every student\\n2. Now traverse left to right, whenever we get a higher rating, it should get more candy from its neighbour( left neighbour in the curr case) so give just one more candy than its left neighbour\\n3. Now another case left when its right neighbour has higher rating, traverse from right, and if we get a higher rating, give it max(curr, 1+candy of its right). max ensures that for local maxima candies shuld be high than both neighbours;\\n\\n```\\nint candy(vector<int>& r) {\\n        int n = r.size();\\n        vector<int> c(n, 1);\\n        for (int i = 1; i < n; i++)\\n            if (r[i] > r[i - 1]) c[i] = c[i - 1] + 1;\\n        for (int i = n - 2; ~i; i--)\\n            if (r[i] > r[i + 1]) c[i] = max(c[i], c[i + 1] + 1);\\n        int res = 0;\\n        for (auto t: c) res += t;\\n        return res;\\n    }\\n```\\n**If you find it helpful, plz upvote**",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint candy(vector<int>& r) {\\n        int n = r.size();\\n        vector<int> c(n, 1);\\n        for (int i = 1; i < n; i++)\\n            if (r[i] > r[i - 1]) c[i] = c[i - 1] + 1;\\n        for (int i = n - 2; ~i; i--)\\n            if (r[i] > r[i + 1]) c[i] = max(c[i], c[i + 1] + 1);\\n        int res = 0;\\n        for (auto t: c) res += t;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037652,
                "title": "beats-99-93-greedy-two-solutions-c-java-python-commented-code",
                "content": "# Problem Description\\nThe task is distributing candies to a group of `n` children standing in a line. Each child is assigned a **rating value**, represented as an **integer** array called `ratings`.\\n\\nFollow **two specific requirements** while distributing the candies:\\n- Each child must have at least one candy.\\n- Children with a higher rating should receive more candies than their neighbors.\\n\\nThe **goal** is to determine the **minimum** number of candies needed to satisfy these requirements and distribute the candies to the children accordingly.\\n\\n- **Constraints:**\\n    - `n == ratings.length`\\n    - `1 <= n <= 2 * 104`\\n    - `0 <= ratings[i] <= 2 * 104`\\n    - at **least one candy** for each child\\n    - neighbours with **higher rating** have **more candies**\\n\\n\\n---\\n\\n\\n\\n# Intuition\\nHi there\\uD83D\\uDE00\\nLet\\'s take a look on this interesting problem.\\n\\nFor our candies task we have **two crucial requirements**: Each child must have **at least one** candy, and children with **higher ratings** than their **neighbors** have more candies than them... Interesting.\\n\\nLet\\'s explore some ratings\\' cases together:\\n\\n\\n```\\n2, 2, 2 \\n```\\nHere we can see that **each child** of them can have **one candy** since no one has higher rating than its neighbor.\\n\\n```\\n1, 2, 2, 2 \\n```\\nHere we can see that the array of candies will be `1, 2, 1, 1`.\\n\\n```\\n9, 8, 7\\n```\\nHere we can see that array of candies will be `3, 2, 1`.\\n\\n```\\n7, 8, 9\\n```\\nHere we can see that array of candies will be `1, 2, 3`.\\n\\n\\nI think now we have some **idea** about what is going on here\\uD83E\\uDD14\\n- Children with **equal ratings** can have different candies and that won\\'t violate our requirements since we are aiming for giving **minimum** candies.\\n- We must take care of **decreasing** subarrays and **increasing** ones.\\n\\nHow can we use an approach that take care of these **observations**?\\uD83D\\uDE80\\n\\n## Two Pass Approach \\nIn this approach we will:\\n- Iterate from `left to right` to take care of **increasing** subarrays \\n- Iterate from `right to left` to take care of **decreasing** subarrays\\n- We **won\\'t do anything** to **equal** neighbours since they won\\'t affect our requirements\\n\\nLet\\'s take an example:\\n```\\n9, 8, 8, 7, 7, 8, 9\\n```\\n**First** we have array of candes `1, 1, 1, 1, 1, 1, 1`\\n\\nAfter our **first pass** (from left to right) we will have array of candies `1, 1, 1, 1, 1, 2, 3`.\\nWe can see that it **handled** the **increasing** subarray perfectly.\\n\\nAfter our **second pass**(from right to left) we will have array of candies `2, 1, 2, 1, 1, 2, 3 `.\\nwe can see that it also **handled** the **decreasing** subarray perfectly.\\n\\nAlso, it handled the equal neighbours after the two passes. It finally minimized our candies. \\n\\n\\n## One Pass Approach \\nThis solution is more challenging since it requires us to handle the **three cases** in **one** pass. How can we start? \\uD83E\\uDD14\\nWe saw before that we have three cases **increasing** subarrays,  **decreasing** subarrays and **equal** subbarrays.\\nWe can start by intialize **three variables** to handle the three of them.\\n\\nFor **increasing** subarray we need one variable `up` to handle what candy we give to current child.\\nfor each child in the **increasing** subarray increase the `up` variable by one and give the current child `up + 1` candies indicating that it must have more that the child before him\\nwe will call `up + 1` as `peak` to mean the highest child in our subarray\\n\\nFor **equal** subarrays, only give them `one` candy and we will see that we only give one to the children in the middle of the subarray\\n\\nFor **decreasing** subarray here comes the challenge \\nWe will introduce variable like first case called `down` but the purpose of it **not** indicating that we give candies to current child but, giving **one** candy to current child and **one** candy for each child before him in the decreasing subarray to meet the requirements.\\n\\nExample : `1, 2, 3, 3, 2, 1`\\n![1.jpg](https://assets.leetcode.com/users/images/a99e9752-25cb-46f7-8d18-364b17088f96_1694573615.3577487.jpeg)\\n\\nBut what if we have **increasing** then **decreasing** subarrays?\\nWe will have the **last** child of the first subarray as first child on the second and then we give each child in the decreasing subarray one candy except that child who is our `peak` until the length of the subarray is larger than the `peak`.\\n\\nExample : `1, 2, 3, 2, 1`\\n![2.jpg](https://assets.leetcode.com/users/images/53bc278c-a910-47a6-846c-d8d85461c79c_1694573659.6552763.jpeg)\\n\\n\\n\\n---\\n\\n\\n\\n# Approach\\n\\n## Two Pass Approach\\n### Steps\\n- **Initialize** variables:\\n    - `n` is number of children.\\n    - `candies` to store candies for each child..\\n- **First Pass** (Left to Right):\\n    - For each child, **check** if the previous child has a **lower** rating and has **more** or **equal** candies.\\n    - If **true**, give the current child one more candy than the previous child.\\n- **Second Pass** (Right to Left):\\n    - For each child, **check** if the next child has a **lower** rating and has **more** or **equal** candies.\\n    - If **true**, give the current child one more candy than the next child.\\n    \\n- Calculate and return totalCandies.\\n\\n### Complexity\\n- **Time complexity:** $$O(N)$$\\nSince we are looping over the ratings array twice then the time complexity is `2*N` which is `O(N)`.\\n- **Space complexity:** $$O(N)$$\\nSince we are storing the number of candies for each child then the space complexity is `O(N)`.\\n\\n\\n---\\n\\n## One Pass Approach\\n### Steps\\n- **Initialize** variables:\\n    - `n` to store the number of children.\\n    - `upCount` to keep track of consecutive increasing ratings.\\n    - `downCount` to keep track of consecutive decreasing ratings.\\n    - `peakCount` to store the number of candies at the peak of increasing ratings.\\n    - `totalCandies` to count required candies.\\n- **Iterate** Through Ratings:\\n    - **compare** the child rating with the **previous** child\\n    - If current child has a **higher** rating than previous one then update the variables and add `peakCount` to `totalCandies`.\\n    - If current child has the **same** rating as previous one then update and add `1` to ``totalCandies``.\\n    - If current child has a **lower** rating than previous one update and update `totalCandies` by adding `downCount` + 1, subtracting `1` if `peakCount` is greater than `downCount`.\\n- **Return** `totalCandies`\\n\\n### Complexity\\n- **Time complexity:** $$O(N)$$\\nSince we are looping over the ratings array one time then the time complexity is `N` which is `O(N)`.\\n- **Space complexity:** $$O(1)$$\\nSince we are storing only couple of variables then the space complexity is `O(1)`.\\n\\n\\n---\\n\\n\\n\\n# Code\\n## Two Pass Approach\\n```C++ []\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size(); // Get the number of children\\n        \\n        vector<int> candies(n, 1); // Initialize a vector to store the number of candies for each child\\n        \\n        // First pass: Check ratings from left to right\\n        for(int i = 1; i < n; i++){\\n            if(ratings[i - 1] < ratings[i] && candies[i - 1] >= candies[i]){\\n                // If the current child has a higher rating and fewer or equal candies than the previous child,\\n                // give them one more candy than the previous child\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n        \\n        // Second pass: Check ratings from right to left\\n        for(int i = n - 2; i >= 0; i--){\\n            if(ratings[i + 1] < ratings[i] && candies[i + 1] >= candies[i]){\\n                // If the current child has a higher rating and fewer or equal candies than the next child,\\n                // give them one more candy than the next child\\n                candies[i] = candies[i + 1] + 1;\\n            }\\n        }\\n        \\n        int totalCandies = 0;\\n        \\n        // Calculate the total number of candies needed\\n        for(int i = 0; i < n; i++){\\n            totalCandies += candies[i];\\n        }\\n        \\n        return totalCandies;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length; // Get the number of children\\n        \\n        int[] candies = new int[n]; // Initialize an array to store the number of candies for each child\\n        \\n        // First pass: Check ratings from left to right\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i - 1] < ratings[i] && candies[i - 1] >= candies[i]) {\\n                // If the current child has a higher rating and fewer or equal candies than the previous child,\\n                // give them one more candy than the previous child\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n        \\n        // Second pass: Check ratings from right to left\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i + 1] < ratings[i] && candies[i + 1] >= candies[i]) {\\n                // If the current child has a higher rating and fewer or equal candies than the next child,\\n                // give them one more candy than the next child\\n                candies[i] = candies[i + 1] + 1;\\n            }\\n        }\\n        \\n        int totalCandies = 0;\\n        \\n        // Calculate the total number of candies needed\\n        for (int i = 0; i < n; i++) {\\n            totalCandies += candies[i] + 1;\\n        }\\n        \\n        return totalCandies;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def candy(self, ratings) -> int:\\n        n = len(ratings)  # Get the number of children\\n        \\n        candies = [1] * n  # Initialize a list to store the number of candies for each child\\n        \\n        # First pass: Check ratings from left to right\\n        for i in range(1, n):\\n            if ratings[i - 1] < ratings[i] and candies[i - 1] >= candies[i]:\\n                # If the current child has a higher rating and fewer or equal candies than the previous child,\\n                # give them one more candy than the previous child\\n                candies[i] = candies[i - 1] + 1\\n        \\n        # Second pass: Check ratings from right to left\\n        for i in range(n - 2, -1, -1):\\n            if ratings[i + 1] < ratings[i] and candies[i + 1] >= candies[i]:\\n                # If the current child has a higher rating and fewer or equal candies than the next child,\\n                # give them one more candy than the next child\\n                candies[i] = candies[i + 1] + 1\\n        \\n        total_candies = sum(candies)  # Calculate the total number of candies needed\\n        \\n        return total_candies\\n```\\n\\n## One Pass Approach\\n```C++ []\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size(); // Get the number of children\\n        int upCount = 0, downCount = 0, peakCount = 0, totalCandies = 1; // Initialize variables\\n        \\n        for(int i = 1; i < n ; i ++){\\n            if(ratings[i - 1] < ratings[i]){\\n                // If the current child has a higher rating than the previous one\\n                downCount = 0;\\n                upCount += 1;\\n                peakCount = upCount + 1;\\n                totalCandies += peakCount;\\n            } else if(ratings[i - 1] == ratings[i]){\\n                // If the current child has the same rating as the previous one\\n                downCount = 0;\\n                upCount = 0;\\n                peakCount = 0;\\n                totalCandies += 1;\\n            } else {\\n                // If the current child has a lower rating than the previous one\\n                downCount += 1;\\n                upCount = 0;\\n                totalCandies += downCount + 1 - (peakCount > downCount);\\n            }\\n        }\\n        \\n        return totalCandies;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length; // Get the number of children\\n        int upCount = 0, downCount = 0, peakCount = 0, totalCandies = 1; // Initialize variables\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i - 1] < ratings[i]) {\\n                // If the current child has a higher rating than the previous one\\n                downCount = 0;\\n                upCount += 1;\\n                peakCount = upCount + 1;\\n                totalCandies += peakCount;\\n            } else if (ratings[i - 1] == ratings[i]) {\\n                // If the current child has the same rating as the previous one\\n                downCount = 0;\\n                upCount = 0;\\n                peakCount = 0;\\n                totalCandies += 1;\\n            } else {\\n                // If the current child has a lower rating than the previous one\\n                downCount += 1;\\n                upCount = 0;\\n                totalCandies += downCount + 1 - (peakCount > downCount ? 1 : 0);\\n            }\\n        }\\n        \\n        return totalCandies;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def candy(self, ratings) -> int:\\n        n = len(ratings)  # Get the number of children\\n        upCount = downCount = peakCount = 0\\n        totalCandies = 1  # Initialize variables\\n        \\n        for i in range(1, n):\\n            if ratings[i - 1] < ratings[i]:\\n                # If the current child has a higher rating than the previous one\\n                downCount = 0\\n                upCount += 1\\n                peakCount = upCount + 1\\n                totalCandies += peakCount\\n            elif ratings[i - 1] == ratings[i]:\\n                # If the current child has the same rating as the previous one\\n                downCount = 0\\n                upCount = 0\\n                peakCount = 0\\n                totalCandies += 1\\n            else:\\n                # If the current child has a lower rating than the previous one\\n                downCount += 1\\n                upCount = 0\\n                totalCandies += downCount + 1 - (1 if peakCount > downCount else 0)\\n        \\n        return totalCandies\\n```\\n\\n\\n![leet_sol.jpg](https://assets.leetcode.com/users/images/fa9927ee-3d40-447d-ae31-148ce5f55633_1694564084.5767484.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\n2, 2, 2 \\n```\n```\\n1, 2, 2, 2 \\n```\n```\\n9, 8, 7\\n```\n```\\n7, 8, 9\\n```\n```\\n9, 8, 8, 7, 7, 8, 9\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size(); // Get the number of children\\n        \\n        vector<int> candies(n, 1); // Initialize a vector to store the number of candies for each child\\n        \\n        // First pass: Check ratings from left to right\\n        for(int i = 1; i < n; i++){\\n            if(ratings[i - 1] < ratings[i] && candies[i - 1] >= candies[i]){\\n                // If the current child has a higher rating and fewer or equal candies than the previous child,\\n                // give them one more candy than the previous child\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n        \\n        // Second pass: Check ratings from right to left\\n        for(int i = n - 2; i >= 0; i--){\\n            if(ratings[i + 1] < ratings[i] && candies[i + 1] >= candies[i]){\\n                // If the current child has a higher rating and fewer or equal candies than the next child,\\n                // give them one more candy than the next child\\n                candies[i] = candies[i + 1] + 1;\\n            }\\n        }\\n        \\n        int totalCandies = 0;\\n        \\n        // Calculate the total number of candies needed\\n        for(int i = 0; i < n; i++){\\n            totalCandies += candies[i];\\n        }\\n        \\n        return totalCandies;\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length; // Get the number of children\\n        \\n        int[] candies = new int[n]; // Initialize an array to store the number of candies for each child\\n        \\n        // First pass: Check ratings from left to right\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i - 1] < ratings[i] && candies[i - 1] >= candies[i]) {\\n                // If the current child has a higher rating and fewer or equal candies than the previous child,\\n                // give them one more candy than the previous child\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n        \\n        // Second pass: Check ratings from right to left\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i + 1] < ratings[i] && candies[i + 1] >= candies[i]) {\\n                // If the current child has a higher rating and fewer or equal candies than the next child,\\n                // give them one more candy than the next child\\n                candies[i] = candies[i + 1] + 1;\\n            }\\n        }\\n        \\n        int totalCandies = 0;\\n        \\n        // Calculate the total number of candies needed\\n        for (int i = 0; i < n; i++) {\\n            totalCandies += candies[i] + 1;\\n        }\\n        \\n        return totalCandies;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def candy(self, ratings) -> int:\\n        n = len(ratings)  # Get the number of children\\n        \\n        candies = [1] * n  # Initialize a list to store the number of candies for each child\\n        \\n        # First pass: Check ratings from left to right\\n        for i in range(1, n):\\n            if ratings[i - 1] < ratings[i] and candies[i - 1] >= candies[i]:\\n                # If the current child has a higher rating and fewer or equal candies than the previous child,\\n                # give them one more candy than the previous child\\n                candies[i] = candies[i - 1] + 1\\n        \\n        # Second pass: Check ratings from right to left\\n        for i in range(n - 2, -1, -1):\\n            if ratings[i + 1] < ratings[i] and candies[i + 1] >= candies[i]:\\n                # If the current child has a higher rating and fewer or equal candies than the next child,\\n                # give them one more candy than the next child\\n                candies[i] = candies[i + 1] + 1\\n        \\n        total_candies = sum(candies)  # Calculate the total number of candies needed\\n        \\n        return total_candies\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size(); // Get the number of children\\n        int upCount = 0, downCount = 0, peakCount = 0, totalCandies = 1; // Initialize variables\\n        \\n        for(int i = 1; i < n ; i ++){\\n            if(ratings[i - 1] < ratings[i]){\\n                // If the current child has a higher rating than the previous one\\n                downCount = 0;\\n                upCount += 1;\\n                peakCount = upCount + 1;\\n                totalCandies += peakCount;\\n            } else if(ratings[i - 1] == ratings[i]){\\n                // If the current child has the same rating as the previous one\\n                downCount = 0;\\n                upCount = 0;\\n                peakCount = 0;\\n                totalCandies += 1;\\n            } else {\\n                // If the current child has a lower rating than the previous one\\n                downCount += 1;\\n                upCount = 0;\\n                totalCandies += downCount + 1 - (peakCount > downCount);\\n            }\\n        }\\n        \\n        return totalCandies;\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length; // Get the number of children\\n        int upCount = 0, downCount = 0, peakCount = 0, totalCandies = 1; // Initialize variables\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i - 1] < ratings[i]) {\\n                // If the current child has a higher rating than the previous one\\n                downCount = 0;\\n                upCount += 1;\\n                peakCount = upCount + 1;\\n                totalCandies += peakCount;\\n            } else if (ratings[i - 1] == ratings[i]) {\\n                // If the current child has the same rating as the previous one\\n                downCount = 0;\\n                upCount = 0;\\n                peakCount = 0;\\n                totalCandies += 1;\\n            } else {\\n                // If the current child has a lower rating than the previous one\\n                downCount += 1;\\n                upCount = 0;\\n                totalCandies += downCount + 1 - (peakCount > downCount ? 1 : 0);\\n            }\\n        }\\n        \\n        return totalCandies;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def candy(self, ratings) -> int:\\n        n = len(ratings)  # Get the number of children\\n        upCount = downCount = peakCount = 0\\n        totalCandies = 1  # Initialize variables\\n        \\n        for i in range(1, n):\\n            if ratings[i - 1] < ratings[i]:\\n                # If the current child has a higher rating than the previous one\\n                downCount = 0\\n                upCount += 1\\n                peakCount = upCount + 1\\n                totalCandies += peakCount\\n            elif ratings[i - 1] == ratings[i]:\\n                # If the current child has the same rating as the previous one\\n                downCount = 0\\n                upCount = 0\\n                peakCount = 0\\n                totalCandies += 1\\n            else:\\n                # If the current child has a lower rating than the previous one\\n                downCount += 1\\n                upCount = 0\\n                totalCandies += downCount + 1 - (1 if peakCount > downCount else 0)\\n        \\n        return totalCandies\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301166,
                "title": "c-solution-o-n-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int>left(n, 1), right(n, 1);\\n        \\n        //traverse left to right and compare curr value with left side value\\n        for(int i = 1; i < n; i++)\\n            if(ratings[i] > ratings[i-1]) left[i] = left[i-1]+1;\\n              \\n         //traverse right to left and compare curr value with right side value\\n        for(int i = n-2; i >= 0; i--)\\n            if(ratings[i] > ratings[i+1]) right[i] = right[i+1]+1;\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            ans += max(left[i], right[i]);\\n        \\n        return ans;            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int>left(n, 1), right(n, 1);\\n        \\n        //traverse left to right and compare curr value with left side value\\n        for(int i = 1; i < n; i++)\\n            if(ratings[i] > ratings[i-1]) left[i] = left[i-1]+1;\\n              \\n         //traverse right to left and compare curr value with right side value\\n        for(int i = n-2; i >= 0; i--)\\n            if(ratings[i] > ratings[i+1]) right[i] = right[i+1]+1;\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            ans += max(left[i], right[i]);\\n        \\n        return ans;            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42795,
                "title": "two-c-solutions-given-with-explanation-both-with-o-n-time-one-with-o-1-space-the-other-with-o-n-space",
                "content": "The question requires us to make sure a child with a higher rate has more candies than its left and right neighbors. One simple solution is to do two scans: one foward scan (from 1 to N-1) to make sure child i has more candies than its left neighbor if its rate is higher than its left neighbor. After the forward scan, we can guarantee that the left neighbor relationship is correct but we have to do more to make the right neighbor relationship in order; so we do the backwarad scan (from N-2 to 0) to make child i has more candies than its right neighbor i+1 if its rate is higher than its right neighbor. In the following implementation, we need a O(N) array number to save the number of candies needed for children, so it has O(N) space complexity and we do two linear scans so the time complexity is O(N) \\n\\n    class Solution {\\n    public:\\n        int candy(vector<int>& ratings) {\\n            int len = ratings.size(), res = 0, i;\\n            if(len>0)\\n            {\\n                vector<int> number(len,0); // to save the number of candies for child[0:N-1]\\n                number[0] = 1; \\n    // forward scan to calculate how many candies needed for child i to make sure it has more candies than its left neighbor if it has a higher rate, otherwise, give one candy to it\\n                for(i=1; i<len;++i) number[i] = ratings[i]>ratings[i-1]?number[i-1]+1:1;\\n    \\n    // backward scan to calculate to make sure child i has more candies than its right neighbor if it has a higher rate, pick the bigger one from forward and backward scans as the final number for child i\\n                for(i=len-2, res = number[len-1]; i>=0;--i)\\n                {\\n                    if( (ratings[i]>ratings[i+1]) && number[i]<(number[i+1]+1) ) number[i] = number[i+1]+1;\\n                    res += number[i];\\n                }\\n            }\\n            return res;\\n        }\\n    };\\n\\nNow, the question is can we do better? Do we really need two scans? If we do only forward scan, then the problem is we can not guarantee the right neighbor relationship holds. i.e. we don't know if the following order is descending (i>i+1>i+2>...). and that may cause issues. To fix that, we will detect the dips (the points at which the order switchs from increasing to decreasng). We will make sure all the local dips (minimum points) has only one candy and update its previous neighbors (which has hgher rates than its rate) accordingly. To do such update, we need to know when the decrease starts, so we use pPos to save that starting points. \\nSo the solution becomes: do the forward scan, if it is in an increasing order (child i rate > child i-1 order), check if it is a local dip (neg_peak == true): if so, update the candy number to make sure child i-1 has one candy. if not, just give one more candy to child i. If it is in an decreasing order (child i rate < child i-1 order)\\n, just give one less candy to i. don't forget at last, we still need to make sure child N-1 has one or more candy. So O(1) space , O(N) time\\n\\n        class Solution {\\n        public:\\n            int candy(vector<int>& ratings) {\\n                const int len = ratings.size();\\n                if(len<=1) return len;\\n                \\n                int i, pPos, res=1, peak=1; // peak: # candies given to the i-1 child\\n                bool neg_peak = false; // flag to indicate if it is a local dip\\n                for(i=1; i<len;i++)\\n                {\\n                    if(ratings[i] >= ratings[i-1]) \\n                    {   // it is increasing\\n                        if(neg_peak) \\n                        {  // it is a local dip, we need to make sure i-1 has one candy\\n                            res -= (peak-1) * (i-pPos - (peak>0));\\n                            peak = 1;\\n                            neg_peak = false;\\n                        }\\n                       // update child i candy number, if equal, set to 1\\n                        peak = (ratings[i] == ratings[i-1])? 1:++peak;\\n                        res += peak;\\n                    }\\n                    else\\n                    { // decreasing, just give one less candy, if it is the starting point of a decrease, update pPos\\n                        if(!neg_peak) {pPos = i-1; neg_peak = true;}\\n                        res += --peak;\\n                    }\\n                }\\n    // don't forget to update res, if the last one is a local dip\\n                return !neg_peak? res : res - (peak-1) * (i-pPos - (peak>0));\\n        \\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int candy(vector<int>& ratings) {\\n            int len = ratings.size(), res = 0, i;\\n            if(len>0)\\n            {\\n                vector<int> number(len,0); // to save the number of candies for child[0:N-1]\\n                number[0] = 1; \\n    // forward scan to calculate how many candies needed for child i to make sure it has more candies than its left neighbor if it has a higher rate, otherwise, give one candy to it\\n                for(i=1; i<len;++i) number[i] = ratings[i]>ratings[i-1]?number[i-1]+1:1;\\n    \\n    // backward scan to calculate to make sure child i has more candies than its right neighbor if it has a higher rate, pick the bigger one from forward and backward scans as the final number for child i\\n                for(i=len-2, res = number[len-1]; i>=0;--i)\\n                {\\n                    if( (ratings[i]>ratings[i+1]) && number[i]<(number[i+1]+1) ) number[i] = number[i+1]+1;\\n                    res += number[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 42881,
                "title": "python-two-pass-solution-left-to-right-then-right-to-left",
                "content": "        \\n    def candy(self, ratings):\\n        res = len(ratings) * [1]\\n        for i in xrange(1, len(ratings)):  # from left to right\\n            if ratings[i] > ratings[i-1]:\\n                res[i] = res[i-1] + 1\\n        for i in xrange(len(ratings)-1, 0, -1):  # from right to left\\n            if ratings[i-1] > ratings[i]:\\n                res[i-1] = max(res[i-1], res[i]+1)\\n        return sum(res)",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def candy(self, ratings):\\n        res = len(ratings) * [1]\\n        for i in xrange(1, len(ratings)):  # from left to right\\n            if ratings[i] > ratings[i-1]:\\n                res[i] = res[i-1] + 1\\n        for i in xrange(len(ratings)-1, 0, -1):  # from right to left\\n            if ratings[i-1] > ratings[i]:\\n                res[i-1] = max(res[i-1], res[i]+1)\\n        return sum(res)",
                "codeTag": "Python3"
            },
            {
                "id": 42878,
                "title": "c-easy-to-understand-solution-with-lot-of-comments-o-n-constant-space-one-pass",
                "content": "Let me know if you find it easy please.\\n\\n    Ratings:\\n                        Peak\\n            Peak        |\\n            |           | |\\n          | |           | | |   \\n        | | | |       | | | | |       | | |\\n      | | | | | |   | | | | | | |     | | |\\n    | | | | | | | | | | | | | | | | | | | |\\n                    Candies:\\n    1 2 3 4 5 3 2 1 2 3 5 4 3 2 1 1 1 2 1 1\\n    x---a---x\\n            x--b--x    \\n\\n\\n\\n\\n\\n    \\n\\n\\n\\n It seems easy to track the length of the slopes of the mountains (sequence of all ascending or \\n all descending ratings)\\n and then sum the candies for the two slopes (an easy n*(n+1)/2), with land sequences adding +1 each \\n rating value. \\n\\n It almost works.\\n Big problem is we don't know who the peak belongs (left or right slope?)\\n\\n Example: the first sequence \"a\" is made of 5 ascending elements. \\n    The second sequence \"b\" is made of 4 descending elements.\\n    Which slope gets the peak? \\n\\n Answer: the longest. So for the first mountain \"a\" slope is\\n \\n    L(a)=4    ==>  4+3+2+1 candies \\n\\nand \"b\" is \\n\\n    L(b)=3 ==> 3+2+1 candies\\n\\nPeak is \\n\\n    max(L(a),L(b)) + 1 ==>5 candies.\\n         \\n\\n Unfortunately we can know the longer side of the mountain at the end of the mountain only.\\n\\n So we use \"up\" and \"down\" variable to track the length of the slopes. We sum the candies \\n at the end of each mountain and then we reset the slopes to zero.\\n\\n Special case: we have same rating twice (land). This ends a mountain even if it was ascending \\n (that means: descending slope of length = 0)\\n\\n And to make things more complicated, the last element of a sequence \\n is also the beginning of the next sequence (another mountain or land),\\n so we take that into account.\\n\\n\\n    class Solution {\\n    public:\\n        // Candies for a slope of n elements\\n        int slope(int n)\\n        {\\n            return (n*(n+1))/2;\\n        }\\n    \\n        int candy(vector<int> &ratings) {\\n            if (ratings.size() <= 1 )\\n            {\\n                return ratings.size();\\n            }\\n            int tot = 0;        // The final amount of candies\\n            int up = 0;         // Lenght of the last ascending slope\\n            int down = 0;       // Lenght of the last descending slope\\n            int oldsign = 0;    // Previous ratings trend (1 = ascending, -1 == descending, 0 = stable) \\n    \\n            for (int i = 1; i< ratings.size(); i++)\\n            {\\n                            // Current ratings trend, same meaning as oldsign\\n                int newsign = ratings[i] > ratings[i-1] ? 1 : \\n                              ratings[i] < ratings[i-1] ? -1 : 0;\\n                            // We can calculate the contribution of a slope \\n                            // when that slope ends and it's not the peak of a mountain,\\n                            // that's why we have \"newsign == 0\" and not \"newsign <= 0\"\\n                if ((oldsign > 0 && newsign == 0)  ||\\n                    (oldsign < 0  && newsign >= 0) )\\n                    {\\n                            // The peak of the mountain should have max(up,down)+1\\n                            // candies, but the end of the mountain is the beginning of\\n                            // the next sequence, so we don't the candy at the end of \\n                            // the mountain\\n                        tot += slope(up) + slope(down) + std::max(up, down);\\n                        up = 0;\\n                        down = 0;\\n                    }\\n    \\n                if(newsign > 0)\\n                    up++;\\n                if(newsign < 0)\\n                    down++;\\n                        // Same rating of the previous child?\\n                        // Take one candy.If you are better then the next child\\n                        // the descending slope will take that into account, don't worry\\n                if(newsign == 0)\\n                    tot++;\\n                    \\n                oldsign = newsign;\\n            }\\n            \\n                        // Final sequence has to be closed\\n                        // Why +1? Because we don't have a sequence next!\\n            tot += ramp(up) + ramp(down) + std::max(up, down) + 1;\\n            return tot;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        // Candies for a slope of n elements\\n        int slope(int n)\\n        {\\n            return (n*(n+1))/2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2234774,
                "title": "c-using-two-arrays-easy-to-understand-with-comments",
                "content": "**TIME COMPLEXITY = O(N)**\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int ans = 0, n= ratings.size();\\n        \\n        // it take care about student get more candies than its left neighbor\\n        vector<int>L_candy(n,1);\\n        for(int i=1; i<n; i++){\\n            if(ratings[i]>ratings[i-1] )\\n                L_candy[i]=L_candy[i-1]+1;\\n        }\\n        \\n        // it take care about student get more candies than its right neighbor\\n        vector<int> R_candy(n,1);\\n        for(int i=n-2; i>=0; i--){\\n            if(ratings[i]>ratings[i+1] )\\n                R_candy[i] = R_candy[i+1]+1;\\n        }\\n        \\n        // here we take the maximum value which satisfy both the left and the right neighbor condition \\n        for(int i=0; i<n; i++){\\n            ans += max(L_candy[i], R_candy[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf you like the post then **upVote!!!**",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int ans = 0, n= ratings.size();\\n        \\n        // it take care about student get more candies than its left neighbor\\n        vector<int>L_candy(n,1);\\n        for(int i=1; i<n; i++){\\n            if(ratings[i]>ratings[i-1] )\\n                L_candy[i]=L_candy[i-1]+1;\\n        }\\n        \\n        // it take care about student get more candies than its right neighbor\\n        vector<int> R_candy(n,1);\\n        for(int i=n-2; i>=0; i--){\\n            if(ratings[i]>ratings[i+1] )\\n                R_candy[i] = R_candy[i+1]+1;\\n        }\\n        \\n        // here we take the maximum value which satisfy both the left and the right neighbor condition \\n        for(int i=0; i<n; i++){\\n            ans += max(L_candy[i], R_candy[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038784,
                "title": "video-o-n-time-o-1-space-solution-python-javascript-java-c",
                "content": "# Intuition\\nKeep two peak values and subtract the lower peak from total.\\n\\n---\\n\\n# Solution Video\\n\\nhttps://youtu.be/f5oFx-X0eS4\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2310\\nThank you for your support!\\n\\n---\\n\\n# Approach\\n\\n## \\u25A0 Step 1\\nIntialize `total_candies` with `len(ratings)` because at least all children has one candy.\\n\\n## \\u25A0 Step 2\\nWe iterate through `ratings` one by one.\\n\\n### case1\\n```\\nif ratings[i] == ratings[i - 1]:\\n```\\nwe don\\'t have to give a candy to the current `i` child because current `i` child has the same rating with previous child. Just increment `i` and continue.\\n\\n### case2\\n```\\nwhile i < n and ratings[i] > ratings[i - 1]:\\n```\\nThis case indicates that the current `i` child has higher raiting than `i - 1` previous child. In this case, we need to give candies to the current `i` child.\\n\\nAdd `+1` to `current_peak` and add `current_peak` to `total_candies` and incremtnt `i`. this process continues until we don\\'t meet case2 `while condition` above.\\n\\nLet me explain `current_peak` in \"How it works\" section.\\n\\n### case3\\n```\\nwhile i < n and ratings[i] < ratings[i - 1]:\\n```\\nThis case indicates that the current `i` child has lower raiting than `i - 1` previous child. In this case, actually we do the same thing of `case2`. Because even if input is decreasing order `[9,5,3,1]`, we need to give candies to the current `i` child. In the end, total candies are 10 `[4,3,2,1]`. we need some extra candies.\\n\\nAdd `+1` to `current_valley` and add `current_valley` to `total_candies` and incremtnt `i`. this process continues until we don\\'t meet case 3 `while condition` above.\\n\\nLet me explain `current_valley` in \"How it works\" section.\\n\\nIn the last of Step 2, subtract minium of `current_peak` or `current_valley` from `total_candies`.\\n\\n# How it works\\nLet\\'s think with this input. \\n```\\nInput: ratings = [2,4,6,7,3,2,2]\\n```\\n```\\ntotal_candies(Let\\'s say \"total\") = 7 (length of input array)\\ncurrent_peak(Let\\'s say \"peak\") = 0\\ncurrent_valley(Let\\'s say \"valley\") = 0\\n\\n```\\nIn Step2, starting from `index 1`.\\n```\\n\\u25A0 Case2\\ncondtion: while i < n and ratings[i] > ratings[i - 1]:\\n\\nindex 1 > index 0, so peak = 1, valley = 0, total = 8 (7 + 1)\\nindex 2 > index 1, so peak = 2, valley = 0, total = 10 (8 + 2)\\nindex 3 > index 2, so peak = 3, valley = 0, total = 13 (10 + 3)\\nindex 4 < index 3, then stop Case2\\n\\nOur code distrubtes candies like this so far\\nfrom [1,1,1,1,1,1,1]\\nto   [1,2,3,4,1,1,1](total 13 candies)\\n```\\n```\\n\\u25A0 Case3\\ncondtion: while i < n and ratings[i] < ratings[i - 1]:\\n\\nindex 4 < index 3, so peak = 3, valley = 1, total = 14 (13 + 1)\\nindex 5 < index 4, so peak = 3, valley = 2, total = 16 (14 + 2)\\nindex 6 == index 5, then stop Case3\\n\\nOur code distrubtes candies like this so far\\nfrom [1,2,3,4,1,1,1](Case2)\\nto   [1,2,3,4,2,3,1](total 16 candies)\\n```\\n\\nLet me explain `total_candies -= min(current_peak, current_valley)`\\nBefore that, `the last rating(index 6)` is equal to `index 5`, so we don\\'t do anything(meet `Case1`). Let me skip it.\\n\\nNow Look at this. When ratings = `[2,4,6,7,3,2,2]`\\n```\\nThis is real distribution, In other words, the minimum number of\\ncandies you need to have to distribute\\n\\n[1,2,3,4,2,1,1] = 14 candies\\n[1,1,1,1,1,1,1]\\n[0,1,2,3,1,0,0](additional candies for each children)\\n```\\n```\\nHow our code distributes candies\\n\\n[1,2,3,4,2,3,1] = 16 candies\\n[1,1,1,1,1,1,1]\\n[0,1,2,3,1,2,0](additional candies for each children)\\n```\\n\\nCompare distribution of adittional candies.\\n```\\n[0,1,2,3,1,0,0](Real)\\n[0,1,2,3,1,2,0](Our code)\\n```\\nOur code distributes `extra 2 candies` at `index 5` which is equal to minimum of `current_peak` or `current_valley`. That\\'s because actually we add peaks twice as a `peak` and as a `valley` in Case2 and Case3. For this question, we need peak value only once. More precisely, we need only higher peak between range of one of `peak` and `valley` combinations(in this case between `index1` and `index5`), because of constraints from the description saying \"Children with a higher rating get more candies than their neighbors\".\\n\\nThat\\'s why we need to substract `minimum peak` from `total_candies`. In this case `16 - 2`. `peak = 3` vs `valley = 2`\\n\\n```\\nOutput: 14\\n```\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\'n\\' is the number of elements in the \\'ratings\\' list. This is because we are using a single loop to iterate through the ratings, and within the loop, we perform constant time operations.\\n\\n- Space complexity: O(1), which means it uses a constant amount of additional memory regardless of the size of the \\'ratings\\' list. The only variables that consume memory are \\'n\\', \\'total_candies\\', \\'i\\', \\'current_peak\\', and \\'current_valley\\', and these variables do not depend on the input size \\'n\\'.\\n\\n```python []\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        total_candies = n\\n        i = 1\\n\\n        while i < n:\\n            if ratings[i] == ratings[i - 1]:\\n                i += 1\\n                continue\\n\\n            current_peak = 0\\n            while i < n and ratings[i] > ratings[i - 1]:\\n                current_peak += 1\\n                total_candies += current_peak\\n                i += 1\\n            \\n            if i == n:\\n                return total_candies\\n\\n            current_valley = 0\\n            while i < n and ratings[i] < ratings[i - 1]:\\n                current_valley += 1\\n                total_candies += current_valley\\n                i += 1\\n\\n            total_candies -= min(current_peak, current_valley)\\n\\n        return total_candies\\n```\\n```javascript []\\n/**\\n * @param {number[]} ratings\\n * @return {number}\\n */\\nvar candy = function(ratings) {\\n    const n = ratings.length;\\n    let totalCandies = n;\\n    let i = 1;\\n\\n    while (i < n) {\\n        if (ratings[i] === ratings[i - 1]) {\\n            i++;\\n            continue;\\n        }\\n\\n        let currentPeak = 0;\\n        while (i < n && ratings[i] > ratings[i - 1]) {\\n            currentPeak++;\\n            totalCandies += currentPeak;\\n            i++;\\n        }\\n\\n        if (i === n) {\\n            return totalCandies;\\n        }\\n\\n        let currentValley = 0;\\n        while (i < n && ratings[i] < ratings[i - 1]) {\\n            currentValley++;\\n            totalCandies += currentValley;\\n            i++;\\n        }\\n\\n        totalCandies -= Math.min(currentPeak, currentValley);\\n    }\\n\\n    return totalCandies;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int totalCandies = n;\\n        int i = 1;\\n\\n        while (i < n) {\\n            if (ratings[i] == ratings[i - 1]) {\\n                i++;\\n                continue;\\n            }\\n\\n            int currentPeak = 0;\\n            while (i < n && ratings[i] > ratings[i - 1]) {\\n                currentPeak++;\\n                totalCandies += currentPeak;\\n                i++;\\n            }\\n\\n            if (i == n) {\\n                return totalCandies;\\n            }\\n\\n            int currentValley = 0;\\n            while (i < n && ratings[i] < ratings[i - 1]) {\\n                currentValley++;\\n                totalCandies += currentValley;\\n                i++;\\n            }\\n\\n            totalCandies -= Math.min(currentPeak, currentValley);\\n        }\\n\\n        return totalCandies;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n       int n = ratings.size();\\n        int totalCandies = n;\\n        int i = 1;\\n\\n        while (i < n) {\\n            if (ratings[i] == ratings[i - 1]) {\\n                i++;\\n                continue;\\n            }\\n\\n            int currentPeak = 0;\\n            while (i < n && ratings[i] > ratings[i - 1]) {\\n                currentPeak++;\\n                totalCandies += currentPeak;\\n                i++;\\n            }\\n\\n            if (i == n) {\\n                return totalCandies;\\n            }\\n\\n            int currentValley = 0;\\n            while (i < n && ratings[i] < ratings[i - 1]) {\\n                currentValley++;\\n                totalCandies += currentValley;\\n                i++;\\n            }\\n\\n            totalCandies -= min(currentPeak, currentValley);\\n        }\\n\\n        return totalCandies;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nif ratings[i] == ratings[i - 1]:\\n```\n```\\nwhile i < n and ratings[i] > ratings[i - 1]:\\n```\n```\\nwhile i < n and ratings[i] < ratings[i - 1]:\\n```\n```\\nInput: ratings = [2,4,6,7,3,2,2]\\n```\n```\\ntotal_candies(Let\\'s say \"total\") = 7 (length of input array)\\ncurrent_peak(Let\\'s say \"peak\") = 0\\ncurrent_valley(Let\\'s say \"valley\") = 0\\n\\n```\n```\\n\\u25A0 Case2\\ncondtion: while i < n and ratings[i] > ratings[i - 1]:\\n\\nindex 1 > index 0, so peak = 1, valley = 0, total = 8 (7 + 1)\\nindex 2 > index 1, so peak = 2, valley = 0, total = 10 (8 + 2)\\nindex 3 > index 2, so peak = 3, valley = 0, total = 13 (10 + 3)\\nindex 4 < index 3, then stop Case2\\n\\nOur code distrubtes candies like this so far\\nfrom [1,1,1,1,1,1,1]\\nto   [1,2,3,4,1,1,1](total 13 candies)\\n```\n```\\n\\u25A0 Case3\\ncondtion: while i < n and ratings[i] < ratings[i - 1]:\\n\\nindex 4 < index 3, so peak = 3, valley = 1, total = 14 (13 + 1)\\nindex 5 < index 4, so peak = 3, valley = 2, total = 16 (14 + 2)\\nindex 6 == index 5, then stop Case3\\n\\nOur code distrubtes candies like this so far\\nfrom [1,2,3,4,1,1,1](Case2)\\nto   [1,2,3,4,2,3,1](total 16 candies)\\n```\n```\\nThis is real distribution, In other words, the minimum number of\\ncandies you need to have to distribute\\n\\n[1,2,3,4,2,1,1] = 14 candies\\n[1,1,1,1,1,1,1]\\n[0,1,2,3,1,0,0](additional candies for each children)\\n```\n```\\nHow our code distributes candies\\n\\n[1,2,3,4,2,3,1] = 16 candies\\n[1,1,1,1,1,1,1]\\n[0,1,2,3,1,2,0](additional candies for each children)\\n```\n```\\n[0,1,2,3,1,0,0](Real)\\n[0,1,2,3,1,2,0](Our code)\\n```\n```\\nOutput: 14\\n```\n```python []\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        total_candies = n\\n        i = 1\\n\\n        while i < n:\\n            if ratings[i] == ratings[i - 1]:\\n                i += 1\\n                continue\\n\\n            current_peak = 0\\n            while i < n and ratings[i] > ratings[i - 1]:\\n                current_peak += 1\\n                total_candies += current_peak\\n                i += 1\\n            \\n            if i == n:\\n                return total_candies\\n\\n            current_valley = 0\\n            while i < n and ratings[i] < ratings[i - 1]:\\n                current_valley += 1\\n                total_candies += current_valley\\n                i += 1\\n\\n            total_candies -= min(current_peak, current_valley)\\n\\n        return total_candies\\n```\n```javascript []\\n/**\\n * @param {number[]} ratings\\n * @return {number}\\n */\\nvar candy = function(ratings) {\\n    const n = ratings.length;\\n    let totalCandies = n;\\n    let i = 1;\\n\\n    while (i < n) {\\n        if (ratings[i] === ratings[i - 1]) {\\n            i++;\\n            continue;\\n        }\\n\\n        let currentPeak = 0;\\n        while (i < n && ratings[i] > ratings[i - 1]) {\\n            currentPeak++;\\n            totalCandies += currentPeak;\\n            i++;\\n        }\\n\\n        if (i === n) {\\n            return totalCandies;\\n        }\\n\\n        let currentValley = 0;\\n        while (i < n && ratings[i] < ratings[i - 1]) {\\n            currentValley++;\\n            totalCandies += currentValley;\\n            i++;\\n        }\\n\\n        totalCandies -= Math.min(currentPeak, currentValley);\\n    }\\n\\n    return totalCandies;    \\n};\\n```\n```java []\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int totalCandies = n;\\n        int i = 1;\\n\\n        while (i < n) {\\n            if (ratings[i] == ratings[i - 1]) {\\n                i++;\\n                continue;\\n            }\\n\\n            int currentPeak = 0;\\n            while (i < n && ratings[i] > ratings[i - 1]) {\\n                currentPeak++;\\n                totalCandies += currentPeak;\\n                i++;\\n            }\\n\\n            if (i == n) {\\n                return totalCandies;\\n            }\\n\\n            int currentValley = 0;\\n            while (i < n && ratings[i] < ratings[i - 1]) {\\n                currentValley++;\\n                totalCandies += currentValley;\\n                i++;\\n            }\\n\\n            totalCandies -= Math.min(currentPeak, currentValley);\\n        }\\n\\n        return totalCandies;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n       int n = ratings.size();\\n        int totalCandies = n;\\n        int i = 1;\\n\\n        while (i < n) {\\n            if (ratings[i] == ratings[i - 1]) {\\n                i++;\\n                continue;\\n            }\\n\\n            int currentPeak = 0;\\n            while (i < n && ratings[i] > ratings[i - 1]) {\\n                currentPeak++;\\n                totalCandies += currentPeak;\\n                i++;\\n            }\\n\\n            if (i == n) {\\n                return totalCandies;\\n            }\\n\\n            int currentValley = 0;\\n            while (i < n && ratings[i] < ratings[i - 1]) {\\n                currentValley++;\\n                totalCandies += currentValley;\\n                i++;\\n            }\\n\\n            totalCandies -= min(currentPeak, currentValley);\\n        }\\n\\n        return totalCandies;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235599,
                "title": "candy-java-solution-simple-approach",
                "content": "**Approach: **\\n![image](https://assets.leetcode.com/users/images/8e625675-840e-438f-9733-90d8a5f60a05_1656919335.6807528.jpeg)\\n![image](https://assets.leetcode.com/users/images/ad4ee21e-ec47-434d-81d0-b534cf240158_1656919335.635522.jpeg)\\n\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n =  ratings.length;\\n        if(n==0)\\n            return 0;\\n        int left[] = new int[n];\\n        Arrays.fill(left,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(ratings[i] > ratings[i-1])\\n                left[i] = left[i-1]+1;\\n        }\\n        int right[] = new int[n];\\n        Arrays.fill(right,1);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(ratings[i] > ratings[i+1])\\n                right[i] = right[i+1]+1;\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n            ans += Math.max(left[i],right[i]);\\n        return ans;\\n    }\\n}\\n```\\n\\nTime Complexity : O(n)\\nSpace Complexity : O(n) coz we are taking two arrays here\\n\\n**Though this is the accepted solution here, this can be optimised more:\\nThe optimal solution is here:\\n[https://leetcode.com/problems/candy/discuss/2235735/Candy-or-Java-Solution-or-Optimized](http://)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n =  ratings.length;\\n        if(n==0)\\n            return 0;\\n        int left[] = new int[n];\\n        Arrays.fill(left,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(ratings[i] > ratings[i-1])\\n                left[i] = left[i-1]+1;\\n        }\\n        int right[] = new int[n];\\n        Arrays.fill(right,1);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(ratings[i] > ratings[i+1])\\n                right[i] = right[i+1]+1;\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n            ans += Math.max(left[i],right[i]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038277,
                "title": "beginner-friendly-line-by-line-explanation-easy-candy-solution-python-java-beats-95",
                "content": "# Beats \\n![image.png](https://assets.leetcode.com/users/images/b132f758-40f8-4e36-8898-57b76f9ae0d8_1694582712.425661.png)\\n\\n# JAVA CODE 1-2ms \\n# UPVOTE IF U LIKE !!!\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe main intuition behind this problem is to ensure that children with higher ratings receive more candies than their neighbors, while still giving each child at least one candy. One way to approach this is to scan the ratings array from left to right and then from right to left, adjusting the number of candies given based on the rating comparisons.\\n# Approach\\n1. Initialize variables:\\n\\n- 1. \"up_count\" to count increasing ratings sequences (starts at 1).\\n- 2. \"down_count\" to count decreasing ratings sequences (starts at 0).\\n- 3. \"candies_given\" to keep track of the total number of candies given (starts at 1).\\n- 4. \"peak\" to keep track of the peak of increasing ratings (starts at 0).\\n2. Iterate through the ratings list starting from the second element.\\n\\n- 1. If the current rating is greater than the previous one, it\\'s an increasing sequence:\\n- - - Increment up_count.\\n- - - Reset down_count to 0.\\n- - - Increment candies_given by up_count.\\n- - - Update peak to the value of up_count (as this is the peak of the current increasing sequence).\\n- 2. If the current rating is equal to the previous one, reset counts:\\n- - - Reset down_count and peak to 0.\\n- - - Reset up_count to 1.\\n- - - Increment candies_given by 1 (since they have the same rating, they should have the same number of candies).\\n- 3. If the current rating is less than the previous one, it\\'s a decreasing sequence:\\n- - - Increment down_count.\\n- - - Reset up_count to 1.\\n- - - Increment candies_given by down_count.\\n- - - If the current down_count is greater than or equal to peak, give an extra candy to the child at the peak of the decreasing sequence.\\n3. Return candies_given, which represents the minimum number of candies given to satisfy the conditions\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time Complexity: $$O(n)$$ - We iterate through the ratings array twice, once from left to right and once from right to left.\\n- Space Complexity: $$O(1)$$ - We use a constant amount of extra space for variables.\\n\\n\\n# Code\\n# Python\\n```\\n# Define a class named Solution.\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        up_count = 1  # Initialize a variable to count increasing ratings sequences.\\n        down_count = 0  # Initialize a variable to count decreasing ratings sequences.\\n        candies_given = 1  # Initialize the total count of candies given, starting with one.\\n        peak = 0  # Initialize a variable to keep track of the peak of increasing ratings.\\n\\n        # Iterate through the ratings list starting from the second element.\\n        for i in range(1, len(ratings)):\\n            if ratings[i] > ratings[i - 1]:\\n                # If the current rating is greater than the previous one, it\\'s an increasing sequence.\\n                up_count += 1\\n                down_count = 0\\n                candies_given += up_count  # Increment the candy count for the current child.\\n                peak = up_count  # Update the peak for the current increasing sequence.\\n            elif ratings[i] == ratings[i - 1]:\\n                # If the current rating is equal to the previous one, reset counts.\\n                down_count = 0\\n                peak = 0\\n                up_count = 1\\n                candies_given += 1  # Increment the candy count for the current child (since they have the same rating).\\n            else:\\n                # If the current rating is less than the previous one, it\\'s a decreasing sequence.\\n                down_count += 1\\n                up_count = 1\\n                candies_given += down_count  # Increment the candy count for the current child.\\n                if peak <= down_count:\\n                    candies_given += 1  # Give an extra candy to the child at the peak of the decreasing sequence.\\n\\n        return candies_given  # Return the total number of candies given to all children.\\n\\n          \\n```\\n# JAVA\\n```\\n// Define a class named Solution.\\nclass Solution {\\n    // Define a method named candy.\\n    public int candy(int[] ratings) {\\n        // Check if the ratings array is empty; if so, return 0 candies.\\n        if (ratings.length == 0)\\n            return 0;\\n        \\n        int n = ratings.length; // Get the number of children.\\n        int[] candies = new int[n]; // Create an array to store the number of candies for each child.\\n\\n        // Initialize each child with 1 candy (as a baseline).\\n        for (int i = 0; i < n; i++) {\\n            candies[i] = 1;\\n        }\\n\\n        // Pass through the ratings array from left to right and adjust candies as needed.\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = 1 + candies[i - 1];\\n            }\\n        }\\n\\n        // Pass through the ratings array from right to left to ensure the right neighbors also get appropriate candies.\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {\\n                candies[i] = 1 + candies[i + 1];\\n            }\\n        }\\n\\n        int totalCandies = 0; // Initialize a variable to store the total number of candies given.\\n\\n        // Sum up the candies for all children to get the total count.\\n        for (int candyCount : candies) {\\n            totalCandies += candyCount;\\n        }\\n\\n        return totalCandies; // Return the total number of candies given to all children.\\n    }\\n}\\n\\n```\\n# C++\\n```\\n// Define a class named Solution.\\nclass Solution {\\npublic:\\n    // Define a method named candy.\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size(); // Get the number of children.\\n        vector<int> left(n, 1), right(n, 1); // Create vectors to store left and right candy counts for each child.\\n\\n        // Calculate the left candies.\\n        for (int i = 1; i < n; ++i) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                left[i] = left[i - 1] + 1;\\n            }\\n        }\\n\\n        // Calculate the right candies.\\n        for (int i = n - 2; i >= 0; --i) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                right[i] = right[i + 1] + 1;\\n            }\\n        }\\n\\n        int totalCandies = 0; // Initialize a variable to store the total number of candies given.\\n\\n        // Calculate the maximum candies for each child from the left and right counts and sum them up.\\n        for (int i = 0; i < n; ++i) {\\n            totalCandies += max(left[i], right[i]);\\n        }\\n\\n        return totalCandies; // Return the total number of candies given to all children.\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n# Define a class named Solution.\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        up_count = 1  # Initialize a variable to count increasing ratings sequences.\\n        down_count = 0  # Initialize a variable to count decreasing ratings sequences.\\n        candies_given = 1  # Initialize the total count of candies given, starting with one.\\n        peak = 0  # Initialize a variable to keep track of the peak of increasing ratings.\\n\\n        # Iterate through the ratings list starting from the second element.\\n        for i in range(1, len(ratings)):\\n            if ratings[i] > ratings[i - 1]:\\n                # If the current rating is greater than the previous one, it\\'s an increasing sequence.\\n                up_count += 1\\n                down_count = 0\\n                candies_given += up_count  # Increment the candy count for the current child.\\n                peak = up_count  # Update the peak for the current increasing sequence.\\n            elif ratings[i] == ratings[i - 1]:\\n                # If the current rating is equal to the previous one, reset counts.\\n                down_count = 0\\n                peak = 0\\n                up_count = 1\\n                candies_given += 1  # Increment the candy count for the current child (since they have the same rating).\\n            else:\\n                # If the current rating is less than the previous one, it\\'s a decreasing sequence.\\n                down_count += 1\\n                up_count = 1\\n                candies_given += down_count  # Increment the candy count for the current child.\\n                if peak <= down_count:\\n                    candies_given += 1  # Give an extra candy to the child at the peak of the decreasing sequence.\\n\\n        return candies_given  # Return the total number of candies given to all children.\\n\\n          \\n```\n```\\n// Define a class named Solution.\\nclass Solution {\\n    // Define a method named candy.\\n    public int candy(int[] ratings) {\\n        // Check if the ratings array is empty; if so, return 0 candies.\\n        if (ratings.length == 0)\\n            return 0;\\n        \\n        int n = ratings.length; // Get the number of children.\\n        int[] candies = new int[n]; // Create an array to store the number of candies for each child.\\n\\n        // Initialize each child with 1 candy (as a baseline).\\n        for (int i = 0; i < n; i++) {\\n            candies[i] = 1;\\n        }\\n\\n        // Pass through the ratings array from left to right and adjust candies as needed.\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = 1 + candies[i - 1];\\n            }\\n        }\\n\\n        // Pass through the ratings array from right to left to ensure the right neighbors also get appropriate candies.\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {\\n                candies[i] = 1 + candies[i + 1];\\n            }\\n        }\\n\\n        int totalCandies = 0; // Initialize a variable to store the total number of candies given.\\n\\n        // Sum up the candies for all children to get the total count.\\n        for (int candyCount : candies) {\\n            totalCandies += candyCount;\\n        }\\n\\n        return totalCandies; // Return the total number of candies given to all children.\\n    }\\n}\\n\\n```\n```\\n// Define a class named Solution.\\nclass Solution {\\npublic:\\n    // Define a method named candy.\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size(); // Get the number of children.\\n        vector<int> left(n, 1), right(n, 1); // Create vectors to store left and right candy counts for each child.\\n\\n        // Calculate the left candies.\\n        for (int i = 1; i < n; ++i) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                left[i] = left[i - 1] + 1;\\n            }\\n        }\\n\\n        // Calculate the right candies.\\n        for (int i = n - 2; i >= 0; --i) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                right[i] = right[i + 1] + 1;\\n            }\\n        }\\n\\n        int totalCandies = 0; // Initialize a variable to store the total number of candies given.\\n\\n        // Calculate the maximum candies for each child from the left and right counts and sum them up.\\n        for (int i = 0; i < n; ++i) {\\n            totalCandies += max(left[i], right[i]);\\n        }\\n\\n        return totalCandies; // Return the total number of candies given to all children.\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433313,
                "title": "python-simple-two-pass-forth-and-back",
                "content": "# Intuition\\nSome other solutions are too much complicated, which shouldn\\'t be. Just play some cases to get this idea. Please up vote if you agree with this idea and let me see if you like it.\\n\\nOkay, just saw other friends already got this idea. I did work it out alone since it\\'s pretty straightforward. Anyways, I hope my comments here help understanding.\\n\\n# Approach\\nGoing foward to reward higher rating on the right. Going backward for higher rating on left. Generally, there is only one rule:\\n- If you see a higher rating on the next child, it deserves one more candies if it didn\\'t\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ since only two passes on the rating array.\\n\\n- Space complexity:\\n$$O(n)$$ due to the $$give$$ list.\\n\\n# Code\\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        give = [1] * n\\n\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i-1]:\\n                give[i] = give[i-1] + 1\\n\\n        for i in range(n-2, -1, -1):\\n            if ratings[i] > ratings[i+1] and give[i] <= give[i+1]:\\n                give[i] = give[i+1] + 1\\n\\n        return sum(give)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        give = [1] * n\\n\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i-1]:\\n                give[i] = give[i-1] + 1\\n\\n        for i in range(n-2, -1, -1):\\n            if ratings[i] > ratings[i+1] and give[i] <= give[i+1]:\\n                give[i] = give[i+1] + 1\\n\\n        return sum(give)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42889,
                "title": "simple-python-solution-with-two-passes",
                "content": "    class Solution:\\n        # @param {integer[]} ratings\\n        # @return {integer}\\n        def candy(self, ratings):\\n            # use two pass scan from left to right and vice versa to keep the candy level up to now\\n            # similar to like the Trapping Rain Water question\\n            res = [1]*len(ratings) # also compatable with [] input\\n            lbase = rbase = 1\\n            # left scan\\n            for i in xrange(1, len(ratings)):\\n                lbase = lbase + 1 if ratings[i] > ratings[i-1] else 1\\n                res[i] = lbase\\n            # right scan\\n            for i in xrange(len(ratings)-2, -1, -1):\\n                rbase = rbase + 1 if ratings[i] > ratings[i+1] else 1\\n                res[i] = max(rbase, res[i])\\n            return sum(res)",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 4037722,
                "title": "c-10ms-99-62-beginner-friendly-fast",
                "content": "# C++ | 10ms | 99.62% | Beginner Friendly | Fast\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int> &ratings)\\n {\\n\\t int size=ratings.size();\\n\\t if(size<=1)\\n\\t\\t return size;\\n\\t vector<int> num(size,1);\\n\\t for (int i = 1; i < size; i++)\\n\\t {\\n\\t\\t if(ratings[i]>ratings[i-1])\\n\\t\\t\\t num[i]=num[i-1]+1;\\n\\t }\\n\\t for (int i= size-1; i>0 ; i--)\\n\\t {\\n\\t\\t if(ratings[i-1]>ratings[i])\\n\\t\\t\\t num[i-1]=max(num[i]+1,num[i-1]);\\n\\t }\\n\\t int result=0;\\n\\t for (int i = 0; i < size; i++)\\n\\t {\\n\\t\\t result+=num[i];\\n\\t\\t// cout<<num[i]<<\" \";\\n\\t }\\n\\t return result;\\n }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int> &ratings)\\n {\\n\\t int size=ratings.size();\\n\\t if(size<=1)\\n\\t\\t return size;\\n\\t vector<int> num(size,1);\\n\\t for (int i = 1; i < size; i++)\\n\\t {\\n\\t\\t if(ratings[i]>ratings[i-1])\\n\\t\\t\\t num[i]=num[i-1]+1;\\n\\t }\\n\\t for (int i= size-1; i>0 ; i--)\\n\\t {\\n\\t\\t if(ratings[i-1]>ratings[i])\\n\\t\\t\\t num[i-1]=max(num[i]+1,num[i-1]);\\n\\t }\\n\\t int result=0;\\n\\t for (int i = 0; i < size; i++)\\n\\t {\\n\\t\\t result+=num[i];\\n\\t\\t// cout<<num[i]<<\" \";\\n\\t }\\n\\t return result;\\n }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4037727,
                "title": "python-99-82-beginner-friendly-optimal-solution",
                "content": "# Python | 99.82% | Beginner Friendly | Optimal Solution\\n```\\nclass Solution:\\n    def candy(self, R):\\n        n, ans = len(R), [1]*len(R)\\n        \\n        for i in range(n-1):\\n            if R[i] < R[i+1]:\\n                ans[i+1] = max(1 + ans[i], ans[i+1])\\n                \\n        for i in range(n-2, -1, -1):\\n            if R[i+1] < R[i]:\\n                ans[i] = max(1 + ans[i+1], ans[i])\\n        \\n        return sum(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, R):\\n        n, ans = len(R), [1]*len(R)\\n        \\n        for i in range(n-1):\\n            if R[i] < R[i+1]:\\n                ans[i+1] = max(1 + ans[i], ans[i+1])\\n                \\n        for i in range(n-2, -1, -1):\\n            if R[i+1] < R[i]:\\n                ans[i] = max(1 + ans[i+1], ans[i])\\n        \\n        return sum(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234990,
                "title": "c-easy-greedy-o-n-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& rat) {\\n        int n = rat.size(), sum = 0;\\n        vector<int> res(n, 1);  // initialize the resultant array with all elements 1 since each child will get minimum 1 candy\\n        \\n        if (n == 1) \\n        {\\n            return 1;\\n        }\\n        \\n        // traverse the given ratings array and if the value of rat[i + 1] is greater than rat[i],\\n        // then update the value of ans[i + 1] as ans[i] + 1\\n        // this is to make sure higher rating one gets more than right neighbour\\n        for(int i=0; i<n-1; i++)\\n        {\\n            if (rat[i+1] > rat[i]) \\n            {\\n                res[i+1] = res[i] + 1;\\n            }\\n        }\\n        \\n        // traverse the given array from the back and if the value of rat[i] > rat[i + 1] and the value of res[i] <= res[i + 1],\\n        // then update the value of res[i] as res[i + 1] + 1\\n        // this is to make sure higher rating one gets more than left neighbour\\n        for (int i=n-2; i>=0; i--) \\n        {\\n            if (rat[i] > rat[i+1] && res[i] <= res[i+1]) \\n            {\\n                res[i] = res[i+1]+1;\\n            }\\n        \\n            sum += res[i]; // increment the sum by res[i]\\n        }\\n        \\n        sum += res[n-1]; // increment with last element as it was left earlier\\n        \\n        return sum; // return the resultant sum\\n    }\\n};\\n```\\n\\n**Time Complexity: O(N)\\nSpace Complexity: O(N)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& rat) {\\n        int n = rat.size(), sum = 0;\\n        vector<int> res(n, 1);  // initialize the resultant array with all elements 1 since each child will get minimum 1 candy\\n        \\n        if (n == 1) \\n        {\\n            return 1;\\n        }\\n        \\n        // traverse the given ratings array and if the value of rat[i + 1] is greater than rat[i],\\n        // then update the value of ans[i + 1] as ans[i] + 1\\n        // this is to make sure higher rating one gets more than right neighbour\\n        for(int i=0; i<n-1; i++)\\n        {\\n            if (rat[i+1] > rat[i]) \\n            {\\n                res[i+1] = res[i] + 1;\\n            }\\n        }\\n        \\n        // traverse the given array from the back and if the value of rat[i] > rat[i + 1] and the value of res[i] <= res[i + 1],\\n        // then update the value of res[i] as res[i + 1] + 1\\n        // this is to make sure higher rating one gets more than left neighbour\\n        for (int i=n-2; i>=0; i--) \\n        {\\n            if (rat[i] > rat[i+1] && res[i] <= res[i+1]) \\n            {\\n                res[i] = res[i+1]+1;\\n            }\\n        \\n            sum += res[i]; // increment the sum by res[i]\\n        }\\n        \\n        sum += res[n-1]; // increment with last element as it was left earlier\\n        \\n        return sum; // return the resultant sum\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300170,
                "title": "c-python-java-simple-solution-with-explanation-and-sample-tc-o-n",
                "content": "*------Please **upvote!** if you like the solution and explanation.  Please put your questions/doubts in the comments section below.  I will try my best to answer them.------*\\n\\n**EXPLANATION:**\\n\\nCreate a result array (**`candies`**) to store the candies for each person.  First go from left to right and increment candies by 1 of people whose rating is more than the left neighbor.\\n\\nThen, go from right to left and if **`ratings [i] > ratings [i+1]`** update **`candies [i]`** to max of **`candies [i], candies [i+1] + 1`**\\n\\nFinally return sum of candies [].\\n\\nTake sample example:\\n`candies [] = [1, 1, 1, 1, 1, 1, 1]` : Initialize candies with 1 candy each \\n`ratings [] = [1, 6, 10, 8, 7, 3, 2]`\\n\\n**After 1st iteration:** update candies while going left to right: **`if ratings [i] > ratings [i-1] ---> candies [i] = candies [i-1] + 1`**\\n\\n`ratings [] = [1, 6, 10, 8, 7, 3, 2]`\\n`candies [] = [1, 2, 3, 1, 1, 1, 1]`\\n\\n**After 2nd iteration:** update candies while going right to left:**`if ratings [i] > ratings [i+1] ---> candies [i] = max (candies [i+1] + 1, candies [i])`**\\n\\n`ratings [] = [1, 6, 10, 8, 7, 3, 2]`\\n`candies [] = [1, 2, 5, 4, 3, 2, 1]`\\n\\n**Sum = 18** ---> Answer\\n\\n**C++ Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector <int> candies (n, 1);\\n        for (int i = 1; i < n; i++) {\\n            if (ratings [i] > ratings [i-1])\\n                candies [i] = candies [i-1] + 1;\\n        }\\n        int sum = candies [n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            if (ratings [i] > ratings [i+1])\\n                candies [i] = max (candies [i], candies [i+1] + 1);\\n            sum += candies [i];\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n**Python Code:**\\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len (ratings)\\n        candies = [1] * n\\n        for i in range (1, n):\\n            if ratings [i] > ratings [i-1]:\\n                candies [i] = candies [i-1] + 1\\n        for i in range (n-2, -1, -1):\\n            if ratings [i] > ratings [i+1]:\\n                candies [i] = max (candies [i], candies [i+1] + 1)\\n        return sum (candies)\\n```\\n\\n**Java Code:**\\n\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int candies [] = new int [n];\\n        Arrays.fill (candies, 1);\\n        for (int i = 1; i < n; i++) {\\n            if (ratings [i] > ratings [i-1])\\n                candies [i] = candies [i-1] + 1;\\n        }\\n        int sum = candies [n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            if (ratings [i] > ratings [i+1])\\n                candies [i] = Math.max (candies [i], candies [i+1] + 1);\\n            sum += candies [i];\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\nPlease **upvote!** if you like the solution and explanation.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector <int> candies (n, 1);\\n        for (int i = 1; i < n; i++) {\\n            if (ratings [i] > ratings [i-1])\\n                candies [i] = candies [i-1] + 1;\\n        }\\n        int sum = candies [n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            if (ratings [i] > ratings [i+1])\\n                candies [i] = max (candies [i], candies [i+1] + 1);\\n            sum += candies [i];\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len (ratings)\\n        candies = [1] * n\\n        for i in range (1, n):\\n            if ratings [i] > ratings [i-1]:\\n                candies [i] = candies [i-1] + 1\\n        for i in range (n-2, -1, -1):\\n            if ratings [i] > ratings [i+1]:\\n                candies [i] = max (candies [i], candies [i+1] + 1)\\n        return sum (candies)\\n```\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int candies [] = new int [n];\\n        Arrays.fill (candies, 1);\\n        for (int i = 1; i < n; i++) {\\n            if (ratings [i] > ratings [i-1])\\n                candies [i] = candies [i-1] + 1;\\n        }\\n        int sum = candies [n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            if (ratings [i] > ratings [i+1])\\n                candies [i] = Math.max (candies [i], candies [i+1] + 1);\\n            sum += candies [i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161652,
                "title": "one-pass-o-n-with-o-1-space-shortest-solution-easy-to-understand",
                "content": "* We use ```inc``` to record the length of the **current (or the last)** increasing sequence\\n* We use ```dec``` to record the length of the current decresing sequence\\n### Scan the ```ratings```, there are 3 cases:\\n1. Sequence is increasing:\\n\\t* If the sequence was previously decresing, reset ```inc``` to ```1```\\n\\t* Bump up ```inc``` and increase our final answer ```ans``` by ```inc``` (*give the last child ```inc``` candies*)\\n\\t* Since the sequence is currently increasing, reset ```dec``` to ```1```\\n2. Sequence is decreasing:\\n\\t* Bump up ```dec``` and increase ```ans``` by ```dec - 1```. *Meaining we give ```1``` candy to the last child, and bump up the candies for everyone before him, expect the first child in the decreasing sequence.*\\n\\t* Bump up ```ans``` if ```dec > inc```: *because the length of the current decreasing sequence exceeds the last increasing sequence, which implies we need to bump up the candies for the first child in the decreasing sequence. Consider the sample ```[1, 5, 3, 2, 1]```: initially we gave the second child only 2 candies, but when we reach ```ratings[3]=2```, 2 is not enough for him*\\n3. Otherwise (```ratings[i] == ratings[i - 1]```): simply increment ```ans``` (*1 candy for the child is enough*) and reset ```inc``` and ```dec``` to 1.\\n\\n```\\n    public int candy(int[] ratings) {\\n        int ans = 1, inc = 1, dec = 1;\\n        for (int i = 1; i < ratings.length; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                if (i > 1 && ratings[i - 1] < ratings[i - 2]) inc = 1;\\n                ans += ++inc;\\n                dec = 1;\\n            }\\n            else if (ratings[i] < ratings[i - 1]) {\\n                dec++;\\n                ans += dec - 1;\\n                if (dec > inc) ans++;\\n            }\\n            else {\\n                ans++;\\n                inc = 1;\\n                dec = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```inc```\n```dec```\n```ratings```\n```inc```\n```1```\n```inc```\n```ans```\n```inc```\n```inc```\n```dec```\n```1```\n```dec```\n```ans```\n```dec - 1```\n```1```\n```ans```\n```dec > inc```\n```[1, 5, 3, 2, 1]```\n```ratings[3]=2```\n```ratings[i] == ratings[i - 1]```\n```ans```\n```inc```\n```dec```\n```\\n    public int candy(int[] ratings) {\\n        int ans = 1, inc = 1, dec = 1;\\n        for (int i = 1; i < ratings.length; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                if (i > 1 && ratings[i - 1] < ratings[i - 2]) inc = 1;\\n                ans += ++inc;\\n                dec = 1;\\n            }\\n            else if (ratings[i] < ratings[i - 1]) {\\n                dec++;\\n                ans += dec - 1;\\n                if (dec > inc) ans++;\\n            }\\n            else {\\n                ans++;\\n                inc = 1;\\n                dec = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2234828,
                "title": "python-two-pass-explanation-intuition-greedy",
                "content": "**Upvote if u like**\\n1. Traverse once right to left and later left to right\\n2. temp contains candy counts , with initially all having one candy\\n3. In right to left traversal, if ratings[i]>ratings[i-1] , give one candy to i th child.\\n4. We traverse backward for testcases like [1,3,2,2,1] here before backward traversal temp is [1,2,1,1,1] , but real ans should be [1,2,1,2,1]. So for this we traverse backward.\\n\\n\\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n=len(ratings)\\n        temp = [1]*n\\n        \\n        for i in range(1,n):\\n            if(ratings[i]>ratings[i-1]):\\n                temp[i]=temp[i-1]+1\\n        if(n>1):\\n            if(ratings[0]>ratings[1]):\\n                temp[0]=2\\n                \\n            \\n        for i in range(n-2,-1,-1):\\n            if(ratings[i]>ratings[i+1] and temp[i]<=temp[i+1]):\\n                temp[i]=temp[i+1]+1\\n\\n                \\n        return sum(temp)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n=len(ratings)\\n        temp = [1]*n\\n        \\n        for i in range(1,n):\\n            if(ratings[i]>ratings[i-1]):\\n                temp[i]=temp[i-1]+1\\n        if(n>1):\\n            if(ratings[0]>ratings[1]):\\n                temp[0]=2\\n                \\n            \\n        for i in range(n-2,-1,-1):\\n            if(ratings[i]>ratings[i+1] and temp[i]<=temp[i+1]):\\n                temp[i]=temp[i+1]+1\\n\\n                \\n        return sum(temp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 912299,
                "title": "python3-100-time-efficient-soln-o-n-time-o-1-space",
                "content": "class Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        \\n        \\n        up = 1\\n        down = 0\\n        rat = 1\\n        peak = 0\\n        \\n        for i in range(1,len(ratings)):\\n            \\n            if ratings[i]>ratings[i-1]:\\n                up+=1\\n                down =  0\\n                rat+=up\\n                peak = up\\n                \\n            elif ratings[i]==ratings[i-1]:\\n                down = 0\\n                peak = 0\\n                up = 1\\n                rat+=1\\n                \\n            else:\\n                down+=1\\n                up = 1\\n                rat+=down\\n                if peak<=down:\\n                    rat+=1\\n                    \\n        return rat",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "class Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        \\n        \\n        up = 1\\n        down = 0\\n        rat = 1\\n        peak = 0\\n        \\n        for i in range(1,len(ratings)):\\n            \\n            if ratings[i]>ratings[i-1]:\\n                up+=1\\n                down =  0\\n                rat+=up\\n                peak = up\\n                \\n            elif ratings[i]==ratings[i-1]:\\n                down = 0\\n                peak = 0\\n                up = 1\\n                rat+=1\\n                \\n            else:\\n                down+=1\\n                up = 1\\n                rat+=down\\n                if peak<=down:\\n                    rat+=1\\n                    \\n        return rat",
                "codeTag": "Java"
            },
            {
                "id": 42849,
                "title": "the-simplest-and-well-explained-solution-accepted-as-best-submission-in-c",
                "content": "When we first encounter such problem, the *least* is the keyword here. There are two constraints: \\n\\n - each child will have candy which means at least one candy;\\n - children with higher ratings will have more candies, which means their amount of candies is larger than neighboring children - to the left and to the right;\\n\\nSince the problem is resolved into these two constraints, then it can be easy to be handled now. The basic idea is as follows: \\n\\n -  traverse from the left to the right to determine the minimal amount of candies for each child that is constrained by the left; \\n - traverse from the right to the left and  determine the minimal amount of candies for each child that is constrained by the right;\\n - finally we can get the minimal constrained by both the left and the right neighbors for each child by retrieving the them from the results of the above two. \\n\\nOkay, by now you might be wonder how to determine the minimal constrained by the left or the right; actually it's quite intuitive that suppose we are traversing from the left to the right and set the leftmost child to 1 candy and then \\n\\n - if the next child ratings is higher ratings[i+1]>ratings[i] then **limits[i+1]=limits[i]+1**; \\n - if the next child ratings is equal to the current one ratings[i+1]==ratings[i] then **limits[i+1]=limits[i]**;\\n - if the next child ratings is smaller (ratings[i+1] < ratings[i]) then the child is not constrained by the left now and can be any but we need to reach global minimal so **limits[i]=1**;\\n\\nEach child will be either constrained by the left or the right or both, but since it's constrained by *the higher ratings more candies rule* the minimal can only be achieved by following it; then it's the valid least amount of candies we can reach.\\n\\nMerging the two results into final limits traversing from the left to the right: \\n\\n - if the ratings[i+1] > ratings[i] then obviously limits[i+1] will be determined by the max(limits[i]+1, limits[i]) - the second parameter limits[i] here is the previous traversal (from right to left) result limits[i] constrained by the right. We have to meet the constraints of both side, so we select the higher limit here;\\n - if the ratings[i+] <= ratings[i] then limits[i+1] should be less than limits[i]  determined by the left but limits[i+1] which is determined by the right in the previous traversal (from right to left) is already less then limits[i]; so limits[i+1] in from-right-to-left is the valid minimal value we can get here; \\n\\nSince we have to store the limits for each child either from left to right or from right to left, so space cost will be O(n) but as an optimized option we can reuse it to reduce the space cost from 2*n to n. As for time cost, we are traversing, man! Obviously it will be O(n), to further reduce the time cost we can sum them up at the second traversal to reduce the time cost from 3 traversals to 2 traversals only.\\n\\n - Space cost O(n)\\n - Time cost O(n)\\n\\n\\n----------\\n\\n    #define MAX(a, b) ((a) > (b) ? (a) : (b))\\n    #define MIN(a, b) ((a) < (b) ? (a) : (b))\\n    //AC - 16ms;\\n    int candy(int* ratings, int size)\\n    {\\n        if(!size) return 0;\\n        int* limits = (int*)malloc(sizeof(int)*size);\\n        limits[size-1] = 1;\\n        for(int i = size-2; i >-1; i--) //from right to left;\\n            if(ratings[i] > ratings[i+1]) limits[i] = limits[i+1]+1;\\n            else limits[i] = 1;\\n        int sum = limits[0];\\n        for(int i = 1; i < size; i++) //from left to right and collect the results;\\n        {\\n            if(ratings[i] > ratings[i-1]) limits[i] = MAX(limits[i], limits[i-1]+1);\\n            else limits[i] = MIN(limits[i-1]-1, limits[i]);\\n            sum += limits[i];\\n        }\\n        return sum;\\n    }",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "When we first encounter such problem, the *least* is the keyword here. There are two constraints: \\n\\n - each child will have candy which means at least one candy;\\n - children with higher ratings will have more candies, which means their amount of candies is larger than neighboring children - to the left and to the right;\\n\\nSince the problem is resolved into these two constraints, then it can be easy to be handled now. The basic idea is as follows: \\n\\n -  traverse from the left to the right to determine the minimal amount of candies for each child that is constrained by the left; \\n - traverse from the right to the left and  determine the minimal amount of candies for each child that is constrained by the right;\\n - finally we can get the minimal constrained by both the left and the right neighbors for each child by retrieving the them from the results of the above two. \\n\\nOkay, by now you might be wonder how to determine the minimal constrained by the left or the right; actually it's quite intuitive that suppose we are traversing from the left to the right and set the leftmost child to 1 candy and then \\n\\n - if the next child ratings is higher ratings[i+1]>ratings[i] then **limits[i+1]=limits[i]+1**; \\n - if the next child ratings is equal to the current one ratings[i+1]==ratings[i] then **limits[i+1]=limits[i]**;\\n - if the next child ratings is smaller (ratings[i+1] < ratings[i]) then the child is not constrained by the left now and can be any but we need to reach global minimal so **limits[i]=1**;\\n\\nEach child will be either constrained by the left or the right or both, but since it's constrained by *the higher ratings more candies rule* the minimal can only be achieved by following it; then it's the valid least amount of candies we can reach.\\n\\nMerging the two results into final limits traversing from the left to the right: \\n\\n - if the ratings[i+1] > ratings[i] then obviously limits[i+1] will be determined by the max(limits[i]+1, limits[i]) - the second parameter limits[i] here is the previous traversal (from right to left) result limits[i] constrained by the right. We have to meet the constraints of both side, so we select the higher limit here;\\n - if the ratings[i+] <= ratings[i] then limits[i+1] should be less than limits[i]  determined by the left but limits[i+1] which is determined by the right in the previous traversal (from right to left) is already less then limits[i]; so limits[i+1] in from-right-to-left is the valid minimal value we can get here; \\n\\nSince we have to store the limits for each child either from left to right or from right to left, so space cost will be O(n) but as an optimized option we can reuse it to reduce the space cost from 2*n to n. As for time cost, we are traversing, man! Obviously it will be O(n), to further reduce the time cost we can sum them up at the second traversal to reduce the time cost from 3 traversals to 2 traversals only.\\n\\n - Space cost O(n)\\n - Time cost O(n)\\n\\n\\n----------\\n\\n    #define MAX(a, b) ((a) > (b) ? (a) : (b))\\n    #define MIN(a, b) ((a) < (b) ? (a) : (b))\\n    //AC - 16ms;\\n    int candy(int* ratings, int size)\\n    {\\n        if(!size) return 0;\\n        int* limits = (int*)malloc(sizeof(int)*size);\\n        limits[size-1] = 1;\\n        for(int i = size-2; i >-1; i--) //from right to left;\\n            if(ratings[i] > ratings[i+1]) limits[i] = limits[i+1]+1;\\n            else limits[i] = 1;\\n        int sum = limits[0];\\n        for(int i = 1; i < size; i++) //from left to right and collect the results;\\n        {\\n            if(ratings[i] > ratings[i-1]) limits[i] = MAX(limits[i], limits[i-1]+1);\\n            else limits[i] = MIN(limits[i-1]-1, limits[i]);\\n            sum += limits[i];\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2237688,
                "title": "c-o-n-time-o-1-space-intuitive-explanation",
                "content": "**Intuition**\\nWhen there\\'s a group of `n` ascending ratings, we can just assign `1,2,...,n` candies. For example, if `ratings=[3,6,7,10]`, then we can assign candies `[1,2,3,4]` to minimize the number of candies given. Similarly, for `n` descending ratings, we can assign `n,n-1,...,1` candies.\\n\\nThe only tricky case is when a rating is a \"peak\". In the case `ratings=[1,3,5,4]`, the `5` acts as a peak. Since there\\'s a group of `3` ascending candies before the peak (including the peak itself), we should assign the peak `3` candies, but there\\'s a group of `2` descending candies after the peak (including the peak itself). If this happens, we should assign the peak `max(3,2) = 3` candies to satisfy all conditions.\\n\\nIn the case there\\'s a group with all the same ratings, we can just assign them `1` candy, given that they aren\\'t part of a peak or valley.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int direction(int x, int y) {\\n        if (x == y) return 0;\\n        return (x > y ? -1 : 1);\\n    }\\n    \\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int i = 0, prev = 1;\\n        int ans = 1;\\n        while (i + 1 < n) {\\n            int run = 1, dir = direction(ratings[i], ratings[i + 1]);\\n            while (i + 1 < n && dir == direction(ratings[i], ratings[i + 1])) {\\n                run++;\\n                i++;\\n            }\\n            if (dir == 0) {\\n                ans += run;\\n                ans -= 1;\\n                prev = 1;\\n            } else {\\n                ans += run * (run + 1) / 2;\\n                if (dir == -1) {\\n                    ans -= min(prev, run);\\n                } else {\\n                    ans -= 1;\\n                }\\n                prev = run;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity:** O(n) - One pass through the array.\\n**Space Complexity:** O(1) - Only constant number of extra variables used.\\n\\n\\n**Upvote** if you like quick and simple explanations!\\n\\n**Join our discord** to meet other people prepping for interviews!\\n**https://discord.gg/7wpQQFYC**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int direction(int x, int y) {\\n        if (x == y) return 0;\\n        return (x > y ? -1 : 1);\\n    }\\n    \\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int i = 0, prev = 1;\\n        int ans = 1;\\n        while (i + 1 < n) {\\n            int run = 1, dir = direction(ratings[i], ratings[i + 1]);\\n            while (i + 1 < n && dir == direction(ratings[i], ratings[i + 1])) {\\n                run++;\\n                i++;\\n            }\\n            if (dir == 0) {\\n                ans += run;\\n                ans -= 1;\\n                prev = 1;\\n            } else {\\n                ans += run * (run + 1) / 2;\\n                if (dir == -1) {\\n                    ans -= min(prev, run);\\n                } else {\\n                    ans -= 1;\\n                }\\n                prev = run;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938475,
                "title": "100-fastest-swift-solution-0-n-o-n",
                "content": "```\\nclass Solution {\\n\\t// - Complexity:\\n    //   - time: 0(n) + O(n)\\n\\n    func candy(_ ratings: [Int]) -> Int {\\n\\t\\tvar indexs: [Int] = []\\n\\t\\tvar count = 0\\n        \\n        for i in 0..<ratings.count {\\n\\t\\t\\tlet left = i > 0 ? ratings[i - 1] : Int.max\\n\\t\\t\\tlet right = i < ratings.count - 1 ? ratings[i + 1] : Int.max\\n\\t\\t\\t\\n            if ratings[i] <= left && ratings[i] <= right {\\n\\t\\t\\t\\tindexs.append(i)\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        indexs.append(ratings.count)\\n\\t\\t\\n        var prev = -1\\n        for index in indexs {\\n\\t\\t\\tlet start = prev + 1\\n\\t\\t\\tlet end = index\\n\\t\\t\\t\\n            if end > start {\\n\\t\\t\\t\\tvar maxRating = Int.min\\n\\t\\t\\t\\tvar maxIndex = Int.min\\n\\t\\t\\t\\t\\n                for i in start..<end {\\n\\t\\t\\t\\t\\tif ratings[i] >= maxRating {\\n\\t\\t\\t\\t\\t\\tmaxRating = ratings[i]\\n\\t\\t\\t\\t\\t\\tmaxIndex = i\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n                var leftCount = maxIndex - start\\n\\t\\t\\t\\tvar rightCount = end - maxIndex - 1\\n\\t\\t\\t\\t\\n                if maxIndex - 1 >= start && ratings[maxIndex - 1] == maxRating {\\n\\t\\t\\t\\t\\trightCount += 1\\n\\t\\t\\t\\t\\n                } else {\\n\\t\\t\\t\\t\\tif leftCount > rightCount {\\n\\t\\t\\t\\t\\t\\tleftCount += 1\\n\\t\\t\\t\\t\\t\\n                    } else {\\n\\t\\t\\t\\t\\t\\trightCount += 1\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n                \\n\\t\\t\\t\\tcount += (2 + leftCount + 1) * leftCount / 2 + (2 + rightCount + 1) * rightCount / 2\\n\\t\\t\\t}\\n\\t\\t\\t\\n            prev = index\\n\\t\\t}\\n        \\n\\t\\treturn count\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\t// - Complexity:\\n    //   - time: 0(n) + O(n)\\n\\n    func candy(_ ratings: [Int]) -> Int {\\n\\t\\tvar indexs: [Int] = []\\n\\t\\tvar count = 0\\n        \\n        for i in 0..<ratings.count {\\n\\t\\t\\tlet left = i > 0 ? ratings[i - 1] : Int.max\\n\\t\\t\\tlet right = i < ratings.count - 1 ? ratings[i + 1] : Int.max\\n\\t\\t\\t\\n            if ratings[i] <= left && ratings[i] <= right {\\n\\t\\t\\t\\tindexs.append(i)\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        indexs.append(ratings.count)\\n\\t\\t\\n        var prev = -1\\n        for index in indexs {\\n\\t\\t\\tlet start = prev + 1\\n\\t\\t\\tlet end = index\\n\\t\\t\\t\\n            if end > start {\\n\\t\\t\\t\\tvar maxRating = Int.min\\n\\t\\t\\t\\tvar maxIndex = Int.min\\n\\t\\t\\t\\t\\n                for i in start..<end {\\n\\t\\t\\t\\t\\tif ratings[i] >= maxRating {\\n\\t\\t\\t\\t\\t\\tmaxRating = ratings[i]\\n\\t\\t\\t\\t\\t\\tmaxIndex = i\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n                var leftCount = maxIndex - start\\n\\t\\t\\t\\tvar rightCount = end - maxIndex - 1\\n\\t\\t\\t\\t\\n                if maxIndex - 1 >= start && ratings[maxIndex - 1] == maxRating {\\n\\t\\t\\t\\t\\trightCount += 1\\n\\t\\t\\t\\t\\n                } else {\\n\\t\\t\\t\\t\\tif leftCount > rightCount {\\n\\t\\t\\t\\t\\t\\tleftCount += 1\\n\\t\\t\\t\\t\\t\\n                    } else {\\n\\t\\t\\t\\t\\t\\trightCount += 1\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n                \\n\\t\\t\\t\\tcount += (2 + leftCount + 1) * leftCount / 2 + (2 + rightCount + 1) * rightCount / 2\\n\\t\\t\\t}\\n\\t\\t\\t\\n            prev = index\\n\\t\\t}\\n        \\n\\t\\treturn count\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679044,
                "title": "java-solution-simple-solution-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int[] arr = new int[ratings.length];\\n        Arrays.fill(arr, 1);\\n        int ans = ratings.length;\\n\\n        while(true){\\n            boolean bool = false;\\n            for(int i = 0; i < ratings.length-1; i++){\\n\\n                if(ratings[i] > ratings[i+1] && arr[i] <= arr[i+1]){\\n                    arr[i]++;\\n                    ans++;\\n                    bool = true;\\n                }\\n\\n                if(ratings[i] < ratings[i+1] && arr[i] >= arr[i+1]){\\n                    arr[i+1]++;\\n                    ans++;\\n                    bool = true;\\n                }\\n            }\\n\\n            if(!bool)\\n                break;\\n        }\\n\\n        return ans;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int[] arr = new int[ratings.length];\\n        Arrays.fill(arr, 1);\\n        int ans = ratings.length;\\n\\n        while(true){\\n            boolean bool = false;\\n            for(int i = 0; i < ratings.length-1; i++){\\n\\n                if(ratings[i] > ratings[i+1] && arr[i] <= arr[i+1]){\\n                    arr[i]++;\\n                    ans++;\\n                    bool = true;\\n                }\\n\\n                if(ratings[i] < ratings[i+1] && arr[i] >= arr[i+1]){\\n                    arr[i+1]++;\\n                    ans++;\\n                    bool = true;\\n                }\\n            }\\n\\n            if(!bool)\\n                break;\\n        }\\n\\n        return ans;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42831,
                "title": "simple-javascript-solution",
                "content": "    var candy = function(ratings) {\\n        var len = ratings.length;\\n        var forward = new Array(len);\\n        backward = new Array(len);\\n\\n        forward[0] = 1;\\n        backward[len-1] = 1;\\n        for (var i = 1; i < len; i++) {\\n            if (ratings[i] > ratings[i-1]) forward[i] = forward[i-1] + 1;\\n            else forward[i] = 1;\\n        }\\n\\n        for (var i = len - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i+1]) backward[i] = backward[i+1] + 1;\\n            else backward[i] = 1;\\n        }\\n        var sum = 0;\\n        for (var i = 0; i < len; i++) {\\n            sum += Math.max(forward[i], backward[i]);\\n        }\\n        return sum;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var candy = function(ratings) {\\n        var len = ratings.length;\\n        var forward = new Array(len);\\n        backward = new Array(len);\\n\\n        forward[0] = 1;\\n        backward[len-1] = 1;\\n        for (var i = 1; i < len; i++) {\\n            if (ratings[i] > ratings[i-1]) forward[i] = forward[i-1] + 1;\\n            else forward[i] = 1;\\n        }\\n\\n        for (var i = len - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i+1]) backward[i] = backward[i+1] + 1;\\n            else backward[i] = 1;\\n        }\\n        var sum = 0;\\n        for (var i = 0; i < len; i++) {\\n            sum += Math.max(forward[i], backward[i]);\\n        }\\n        return sum;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 42870,
                "title": "my-two-36ms-codes-one-pass-o-1-space-plus-another-easy-to-understand-code-c",
                "content": "    class Solution { // O(n) single pass\\n    public:\\n        int candy(vector<int>& ratings) {\\n            int ans = 0;\\n            int i = 1; int dip = 1;\\n            if(ratings.size() == 1) return 1;\\n            while(i < ratings.size())\\n            {  \\n                int len2 = 1;\\n                while( i < ratings.size() && ratings[i] == ratings[i-1]){\\n                    i++; ans += len2;\\n                }\\n                while(i < ratings.size() && ratings[i-1] < ratings[i]){\\n                    len2++; i++;\\n                } ans += len2*(len2+1)/2;\\n                while( i < ratings.size() && ratings[i] == ratings[i-1]){\\n                    i++; ans += 1;\\n                    len2 = 1;\\n                }\\n                len2--;\\n                int len = 0;\\n                while( i < ratings.size() && ratings[i-1] > ratings[i]){\\n                    len++;  i++;\\n                }\\n                if( i-1 != ratings.size()-1 ) { ans -= 1; }\\n                ans += len*(len+1)/2;\\n                if(len > len2) ans += len-len2;\\n            }\\n            return ans;\\n        }\\n    };\\n\\nEasy to understand 2 pass code:    \\nIdea: Forward pass is intuitively ok and gives min candies, the second reverse pass doesn't break any thing from the previous pass and completes the reverse direction requirements too.\\n\\n    class Solution {\\n    public:\\n        int candy(vector<int>& arr) {\\n            int cand[100001] = {0};\\n            int n = arr.size();\\n            for(int i = 1; i < n; i++) \\n                if(arr[i] > arr[i-1]) cand[i] = cand[i-1] + 1;\\n            for(int i = n-2; i>= 0; i--) \\n                if(arr[i] > arr[i+1]) cand[i] = max(cand[i], cand[i+1] + 1);\\n            int sum = n;\\n            for(int i = 0; i < n; i++) sum += cand[i];\\n            return sum;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution { // O(n) single pass\\n    public:\\n        int candy(vector<int>& ratings) {\\n            int ans = 0;\\n            int i = 1; int dip = 1;\\n            if(ratings.size() == 1) return 1;\\n            while(i < ratings.size())\\n            {  \\n                int len2 = 1;\\n                while( i < ratings.size() && ratings[i] == ratings[i-1]){\\n                    i++; ans += len2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2234710,
                "title": "cpp-java-code-2-approach-with-simple-explanation-o-n-time-o-1-space-optimized-sol",
                "content": "**Approach - 1 --> Time Complexity O(n) and Space Complexity O(n)**\\n\\n**Step-1** : Assign 1 candy to each children i.e in left and right array .\\n**Step-2** : Create a left array , that make sure to have a candy greater than left element only.\\n                  if(arr [ i  ] > arr [ i - 1  ]   )  then left [ i ] = left [ i - 1 ] + 1;\\n**Step-3** : Create a right array , that make sure to have a candy greater than right element only.\\n\\t\\t\\t\\t if( arr [ i ] > arr [ i + 1] ) then right [ i ] = right [ i +1 ] + 1;\\n**Step-4** : Calculate max of ( left[i] , right[i] )\\n\\nE.g :\\n3    8    4   5   7  9\\n1    1    1   1   1   1    --->  left array assigned with 1\\n1    2    1   2   3   4   ---->  step-2\\n1    1    1   1   1   1   ---> right array assigned with 1\\n1    2    1   1   1   1   ----> step-3\\ncalculate max of step 2 and step 3\\n1    2    1   2   3   4   ----------------------> ANSWER = 1 + 2+ 1+ 2+3 +4 = 13\\n\\n**Note : You can also do it in a two loop with single extra array. **\\n\\n\\n**Approach - 2 : We can apply the approach of valley and peak problem.**\\npeek will have maximum candy while valley have 1 candy.\\nInitialize candy_count = no. of childern ( bcz each children must have 1 candy )\\nStart the looping from 1 to arr.size() -1\\nstep -1 : if current value is equal to previous value then they have same number of Candy.\\nstep -2 : if we have increasing slope , we increase the peak value by one for each increasing element \\n``` while( arr [ i ] > arr [ i - 1 ] ) peak++;``` and add count_candy with peak value.\\nstep - 3 : if we have decreasing slope , we increase the value of valley by one for each decreasing element\\n```while ( arr [ i ] < arr [ i - 1 ] ) valley++``` and add count_candy with valley value.\\nstep -4 : count_candy = count_candy - min ( peak , valley )\\n\\n**J A V A     S O L U T I O N**\\n```\\nclass Solution {\\n    public int candy(int[] ratings) { \\n        int peak = 0 , valley = 0 , size = ratings.length,candy_count = size ;\\n        for(int i = 1 ; i< size ;){\\n            if(ratings[i] == ratings[i-1]){ i++ ; continue;}\\n            peak = 0 ;\\n            valley = 0;\\n            while( i< size && ratings[i] > ratings[i-1]){\\n                peak++;\\n                i++;\\n                candy_count += peak;\\n            }\\n               \\n            \\n            while(i<size && ratings[i] < ratings[i-1]){\\n                valley++;\\n                i++;\\n                candy_count += valley;\\n            }\\n               \\n            candy_count -= Math.min(peak,valley);\\n        }\\n        return candy_count;\\n    }\\n}\\n```\\n**C P P  S O L U T I O N**\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int peak = 0 , valley = 0 , size = ratings.size(),candy_count = size ;\\n        for(int i = 1 ; i< size ;){\\n            if(ratings[i] == ratings[i-1]){ i++ ; continue;}\\n            peak = 0 ;\\n            valley = 0;\\n            while( i< size && ratings[i] > ratings[i-1]){\\n                peak++;\\n                i++;\\n                candy_count += peak;\\n            }\\n               \\n            \\n            while(i<size && ratings[i] < ratings[i-1]){\\n                valley++;\\n                i++;\\n                candy_count += valley;\\n            }\\n               \\n            candy_count -= min(peak,valley);\\n        }\\n        return candy_count;\\n    }\\n};\\n```\\n\\n**Upvote if you found it helpful**\\n**",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "``` while( arr [ i ] > arr [ i - 1 ] ) peak++;```\n```while ( arr [ i ] < arr [ i - 1 ] ) valley++```\n```\\nclass Solution {\\n    public int candy(int[] ratings) { \\n        int peak = 0 , valley = 0 , size = ratings.length,candy_count = size ;\\n        for(int i = 1 ; i< size ;){\\n            if(ratings[i] == ratings[i-1]){ i++ ; continue;}\\n            peak = 0 ;\\n            valley = 0;\\n            while( i< size && ratings[i] > ratings[i-1]){\\n                peak++;\\n                i++;\\n                candy_count += peak;\\n            }\\n               \\n            \\n            while(i<size && ratings[i] < ratings[i-1]){\\n                valley++;\\n                i++;\\n                candy_count += valley;\\n            }\\n               \\n            candy_count -= Math.min(peak,valley);\\n        }\\n        return candy_count;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int peak = 0 , valley = 0 , size = ratings.size(),candy_count = size ;\\n        for(int i = 1 ; i< size ;){\\n            if(ratings[i] == ratings[i-1]){ i++ ; continue;}\\n            peak = 0 ;\\n            valley = 0;\\n            while( i< size && ratings[i] > ratings[i-1]){\\n                peak++;\\n                i++;\\n                candy_count += peak;\\n            }\\n               \\n            \\n            while(i<size && ratings[i] < ratings[i-1]){\\n                valley++;\\n                i++;\\n                candy_count += valley;\\n            }\\n               \\n            candy_count -= min(peak,valley);\\n        }\\n        return candy_count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42890,
                "title": "does-anyone-have-a-better-idea",
                "content": "My code is accepted with **a run-time complexity of O(n)** and **a space complexity of nearly O(1), less than O(n)**.\\n\\nI deal with it for two times:\\n\\n1st, from left to right, I add all the rising points, including the right edges without the left edges.\\n\\n2nd, from right to left, I add all the rising points, which are falling points at the 1st time, including the right and left edges.\\n\\nThere are 4 points should be noticed:\\n\\n1) The right edges must be dealt with for two times, so I only add the difference values or 0. I use a stack to mark every tops' candies except for the last child.\\n\\n2) The left edges are not dealt with for the 1st time, but they are dealt with for the 2nd time.\\n\\n3) For the flat parts, the left edges are dealt with as rising points, while the right edges are dealt with by adding 1 for the 1st time. So for the 2nd time, I add the values they should have then minus 1 when meeting the right edges. The rest are dealt with by adding 1 for the 1st time and not dealt with for the 2nd time.\\n\\n4) As to the point 0, I deal with it if it's less than or equal to point 1 by adding 1. If it's larger than point 1, I don't deal with it until the 2nd time is finished.\\n\\nHere is the code:\\n\\n    class Solution {\\n    public:\\n    \\tint candy(vector<int> &ratings) {\\n    \\t\\t// IMPORTANT: Please reset any member data you declared, as\\n    \\t\\t// the same Solution instance will be reused for each test case.\\n    \\t\\tif( ratings.size()<2 )\\n    \\t\\t\\treturn ratings.size();\\n    \\t\\tint len=1, sum=0, flat=1, tmp;\\n    \\t\\tvector<int> tops;\\n    \\t\\tsum += ratings[0]>ratings[1] ? 0 : len ;\\n    \\t\\tfor(int i=1; i<ratings.size(); ++i)\\n    \\t\\t{\\n    \\t\\t\\tif( ratings[i]>ratings[i-1] )\\n    \\t\\t\\t\\tsum += ++len;\\n    \\t\\t\\telse if( ratings[i]==ratings[i-1] )\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tlen = 1;\\n    \\t\\t\\t\\tsum += 1;\\n    \\t\\t\\t}\\n    \\t\\t\\telse if( ratings[i]<ratings[i-1] && len!=1 )\\n    \\t\\t\\t{\\n    \\t\\t\\t\\ttops.push_back(len);\\n    \\t\\t\\t\\tlen=1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tlen=1;\\n    \\t\\tfor(int i=ratings.size()-1; i>0; --i)\\n    \\t\\t{\\n    \\t\\t\\tif( ratings[i]<ratings[i-1] )\\n    \\t\\t\\t\\tsum += len++;\\n    \\t\\t\\tif( ratings[i]==ratings[i-1] )\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tsum += len-1;\\n    \\t\\t\\t\\tlen = 1;\\n    \\t\\t\\t}\\n    \\t\\t\\telse if( ratings[i]>ratings[i-1] && len!=1 )\\n    \\t\\t\\t{\\n    \\t\\t\\t\\ttmp = tops.back();\\n    \\t\\t\\t\\ttops.pop_back();\\n    \\t\\t\\t\\tsum += len>tmp?(len-tmp):0;\\n    \\t\\t\\t\\tlen = 1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tsum += ratings[0]>ratings[1] ? len : 0 ;\\n    \\t\\treturn sum;\\n    \\t}\\n    };\\n\\nDoes anyone have a better idea? My code has a complicated judgement and seems not elegant enough.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tint candy(vector<int> &ratings) {\\n    \\t\\t// IMPORTANT: Please reset any member data you declared, as\\n    \\t\\t// the same Solution instance will be reused for each test case.\\n    \\t\\tif( ratings.size()<2 )\\n    \\t\\t\\treturn ratings.size();\\n    \\t\\tint len=1, sum=0, flat=1, tmp;\\n    \\t\\tvector<int> tops;\\n    \\t\\tsum += ratings[0]>ratings[1] ? 0 : len ;\\n    \\t\\tfor(int i=1; i<ratings.size(); ++i)\\n    \\t\\t{\\n    \\t\\t\\tif( ratings[i]>ratings[i-1] )\\n    \\t\\t\\t\\tsum += ++len;\\n    \\t\\t\\telse if( ratings[i]==ratings[i-1] )\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tlen = 1;\\n    \\t\\t\\t\\tsum += 1;\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3994447,
                "title": "fully-explained-c-solution-clean-code-beats-95-of-solutions-easy-to-understand",
                "content": "# Intuition\\nTo maintain the given rule, the solution uses a two-pass approach:\\n\\n- **First Pass (Forward Traversal):**\\n\\nIn the first pass, the code iterates through the ratings from left to right. For each child, it checks if the child to the right has a higher rating. If so, it gives the current child one more candy than the child to the left. This step ensures that children with higher ratings receive more candies than their lower-rated neighbours.\\n\\n- **Second Pass (Backward Traversal):**\\n\\nIn the second pass, the code iterates through the ratings from right to left. For each child, it checks if the child to the left has a higher rating and ***hasn\\'t received more candies already*** (this is to prevent over-candying). If both conditions are met, it gives the left child more candy than the rigth child.\\n\\nBy performing these two passes, the solution guarantees that both conditions are met while minimizing the total number of candies distributed. The key insight is that you can start with an initial distribution of one candy per child and adjust it as needed based on the ratings and neighboring children. This approach ensures fairness and satisfies the problem constraints efficiently.\\n\\nIn summary, the intuition of this solution is to iteratively adjust the number of candies given to each child based on their ratings and the ratings of their neighbors, ensuring that the conditions of the problem are met while minimizing the total number of candies distributed. It\\'s a greedy approach that works by making local decisions to achieve a globally optimal solution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere\\'s how the code works:\\n\\nIt first initializes a vector called \\'candy\\' with the same length as the input \\'ratings\\' vector, with each element set to \"1\". Each child is initially given one candy.\\n\\nIn the first pass (forward traversal), it checks for increasing ratings. If the rating of the next child is higher than the current child, it gives the next child one more candy than the current child. This ensures that children with higher ratings receive more candies.\\n\\nIn the second pass (backward traversal), it checks for decreasing ratings. **If the rating of the previous child is higher, and the previous child hasn\\'t received more candies already**, it gives the previous child one more candy to satisfy the rule.\\n\\nFinally, it calculates the total number of candies distributed by summing up the elements in the candy vector and returns that value as the minimum total number of candies needed to satisfy the constraints.\\n\\nThis code guarantees that the constraints are met while minimizing the total number of candies distributed.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n10ms RUNTIME - Beats 95% solutions\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size() ;\\n        vector<int> candy(n, 1) ;\\n        \\n        //First Pass:Forward traversal to handle increasing ratings\\n        for(int i = 0; i<n-1; i++) {\\n            if(ratings[i+1] > ratings[i])\\n                candy[i+1] = candy[i] + 1 ; //If the next child has a higher rating, give them one more candy than previous child\\n        }\\n        \\n        //Second Pass:Backward traversal to handle decreasing ratings\\n        for(int i = n-1; i>0; i--) {\\n            if(ratings[i-1] > ratings[i] && candy[i-1] <= candy[i])\\n                candy[i-1] = candy[i] + 1 ; \\n                //If the previous child has a higher rating and hasn\\'t received more candy, give them more candy than current child\\n        }\\n\\n        int totalCandy = 0 ;\\n        for(int i = 0; i<n; i++)\\n            totalCandy = totalCandy + candy[i] ;\\n        \\n        return totalCandy ;\\n    }\\n};\\n```\\n# IF YOU UNDERSTOOD AND LIKED THE CODE, PLEASE UPVOTE",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size() ;\\n        vector<int> candy(n, 1) ;\\n        \\n        //First Pass:Forward traversal to handle increasing ratings\\n        for(int i = 0; i<n-1; i++) {\\n            if(ratings[i+1] > ratings[i])\\n                candy[i+1] = candy[i] + 1 ; //If the next child has a higher rating, give them one more candy than previous child\\n        }\\n        \\n        //Second Pass:Backward traversal to handle decreasing ratings\\n        for(int i = n-1; i>0; i--) {\\n            if(ratings[i-1] > ratings[i] && candy[i-1] <= candy[i])\\n                candy[i-1] = candy[i] + 1 ; \\n                //If the previous child has a higher rating and hasn\\'t received more candy, give them more candy than current child\\n        }\\n\\n        int totalCandy = 0 ;\\n        for(int i = 0; i<n; i++)\\n            totalCandy = totalCandy + candy[i] ;\\n        \\n        return totalCandy ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205689,
                "title": "135-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem can be solved using two passes of linear scans over the given ratings list. First, we can allocate 1 candy to each child. Then, we can do a forward scan and check if the current child\\'s rating is greater than the previous child\\'s rating. If it is, we can give one more candy to the current child than the previous child. Similarly, we can do a backward scan and check if the current child\\'s rating is greater than the next child\\'s rating. If it is, we can give one more candy to the current child than the next child. Finally, we can return the sum of the candies allocated to all the children.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def candy(self, ratings: List[int]) -> int:\\n    n = len(ratings)\\n    candies = [1] * n  # Allocate 1 candy to each child\\n    for i in range(1, n):\\n        if ratings[i] > ratings[i - 1]:\\n            candies[i] = candies[i - 1] + 1  # Give one more candy to current child than previous child\\n    for i in range(n - 2, -1, -1):\\n        if ratings[i] > ratings[i + 1]:\\n            candies[i] = max(candies[i], candies[i + 1] + 1)  # Give one more candy to current child than next child\\n    return sum(candies)  # Return the total number of candies allocated\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n  def candy(self, ratings: List[int]) -> int:\\n    n = len(ratings)\\n    candies = [1] * n  # Allocate 1 candy to each child\\n    for i in range(1, n):\\n        if ratings[i] > ratings[i - 1]:\\n            candies[i] = candies[i - 1] + 1  # Give one more candy to current child than previous child\\n    for i in range(n - 2, -1, -1):\\n        if ratings[i] > ratings[i + 1]:\\n            candies[i] = max(candies[i], candies[i + 1] + 1)  # Give one more candy to current child than next child\\n    return sum(candies)  # Return the total number of candies allocated\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235501,
                "title": "easy-python-solution-candy",
                "content": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        length = len(ratings)\\n        candies = [1] * length\\n        for i in range(1, length):\\n            if ratings[i] > ratings[i-1] and candies[i] <= candies[i-1]:\\n                candies[i] = candies[i-1] + 1\\n        for i in range(length - 2, -1, -1):\\n            if ratings[i] > ratings[i + 1] and candies[i] <= candies[i+1]:\\n                candies[i] = candies[i+1] + 1\\n        return sum(candies)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        length = len(ratings)\\n        candies = [1] * length\\n        for i in range(1, length):\\n            if ratings[i] > ratings[i-1] and candies[i] <= candies[i-1]:\\n                candies[i] = candies[i-1] + 1\\n        for i in range(length - 2, -1, -1):\\n            if ratings[i] > ratings[i + 1] and candies[i] <= candies[i+1]:\\n                candies[i] = candies[i+1] + 1\\n        return sum(candies)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235318,
                "title": "c-topological-sort-graph",
                "content": "Did not see any graph based approach in the discuss section, so adding it here ^^\\nNot the fastest approach but is intuitive.\\nVisualize array of ratings as graph. Edge(u --> v) is made when u < v.\\nThen assign candies in topology sort order starting from 1 and increment after every level of bfs.\\n```\\nint candy(vector<int> &a)\\n{\\n    int n = a.size();\\n    vector<int> adj[n];\\n    vector<int> inDegree(n, 0);\\n    for (int i = 0; i < n - 1; i++)\\n    {\\n        int u = a[i], v = a[i + 1];\\n        if (v > u)\\n            adj[i].push_back(i + 1), inDegree[i + 1]++;\\n        else if (u > v)\\n            adj[i + 1].push_back(i), inDegree[i]++;\\n    }\\n    queue<int> q;\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (inDegree[i] == 0)\\n            q.push(i);\\n    }\\n    int ans = 0, curr = 1;\\n    while (!q.empty())\\n    {\\n        int size = q.size();\\n        while (size--)\\n        {\\n            int node = q.front();\\n            q.pop();\\n            ans += curr;\\n            for (auto &x : adj[node])\\n            {\\n                inDegree[x]--;\\n                if (inDegree[x] == 0)\\n                    q.push(x);\\n            }\\n        }\\n        curr++;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nint candy(vector<int> &a)\\n{\\n    int n = a.size();\\n    vector<int> adj[n];\\n    vector<int> inDegree(n, 0);\\n    for (int i = 0; i < n - 1; i++)\\n    {\\n        int u = a[i], v = a[i + 1];\\n        if (v > u)\\n            adj[i].push_back(i + 1), inDegree[i + 1]++;\\n        else if (u > v)\\n            adj[i + 1].push_back(i), inDegree[i]++;\\n    }\\n    queue<int> q;\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (inDegree[i] == 0)\\n            q.push(i);\\n    }\\n    int ans = 0, curr = 1;\\n    while (!q.empty())\\n    {\\n        int size = q.size();\\n        while (size--)\\n        {\\n            int node = q.front();\\n            q.pop();\\n            ans += curr;\\n            for (auto &x : adj[node])\\n            {\\n                inDegree[x]--;\\n                if (inDegree[x] == 0)\\n                    q.push(x);\\n            }\\n        }\\n        curr++;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2234889,
                "title": "c-o-n-easy-solution-using-single-array",
                "content": "\\t// we can not check neighbour directly for any index because if we change that index i according \\n\\t// to the neighbour i+1 then may be error because index i+1 will further depend on index i+2\\n\\t// so two times traversal will be required \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint candy(vector<int>& ratings) {\\n\\t\\t\\tint n=ratings.size();\\n\\t\\t\\t  vector<int>ans(n,1);\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1])\\n\\t\\t\\t\\t\\tans[i]=ans[i-1]+1;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=n-2;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1])\\n\\t\\t\\t\\t\\tans[i]=ans[i+1]+1;\\n\\t\\t\\t}\\n\\t\\t\\treturn accumulate(ans.begin(),ans.end(),0);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint candy(vector<int>& ratings) {\\n\\t\\t\\tint n=ratings.size();\\n\\t\\t\\t  vector<int>ans(n,1);\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1])\\n\\t\\t\\t\\t\\tans[i]=ans[i-1]+1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 868478,
                "title": "a-solution-you-can-easily-figure-out-during-an-interview-topological-sort-solution",
                "content": "The actual rating of each child doesn\\'t really matter. \\nThe only thing matters is the relationship(larger/smaller) between two adjacent children, so we could convert it to a graph problem.\\nWe can do **topological sort** to this graph and give one more candy for each level of the graph.\\n\\nOne thing to note that we don\\'t need to build this graph actually. Instead simply use an array to track indegree. \\nThis could make the code concise and easier to implement during an interview.\\n\\n\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] ind = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            if(i!=0 && ratings[i-1] > ratings[i]) ind[i-1]++;\\n            if(i!=n-1 && ratings[i+1] > ratings[i]) ind[i+1]++;\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i = 0; i < n; i++)\\n            if(ind[i] == 0) q.offer(i);\\n        \\n        int ans = 0;\\n        int level = 1;\\n        while(!q.isEmpty()) {\\n            for(int k = q.size(); k > 0; k--) {\\n                int idx = q.poll();\\n                ans+=level;\\n                if(idx!=0 && ratings[idx-1] > ratings[idx] && --ind[idx-1] == 0) q.offer(idx-1);\\n                if(idx!=n-1 && ratings[idx+1] > ratings[idx] && --ind[idx+1] == 0) q.offer(idx+1);\\n            }\\n            level++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] ind = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            if(i!=0 && ratings[i-1] > ratings[i]) ind[i-1]++;\\n            if(i!=n-1 && ratings[i+1] > ratings[i]) ind[i+1]++;\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i = 0; i < n; i++)\\n            if(ind[i] == 0) q.offer(i);\\n        \\n        int ans = 0;\\n        int level = 1;\\n        while(!q.isEmpty()) {\\n            for(int k = q.size(); k > 0; k--) {\\n                int idx = q.poll();\\n                ans+=level;\\n                if(idx!=0 && ratings[idx-1] > ratings[idx] && --ind[idx-1] == 0) q.offer(idx-1);\\n                if(idx!=n-1 && ratings[idx+1] > ratings[idx] && --ind[idx+1] == 0) q.offer(idx+1);\\n            }\\n            level++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327158,
                "title": "intuitive-o-n-time-and-o-1-explained-like-a-5th-grader",
                "content": "When I read this question the thing that came into my mind was that which person will get 1 candy. So I imagined ratings as heights of towers and then realized that locally minimum tower will get 1 candy.\\n\\n- Consider ratings as heights of towers as shown in the figure below.\\n- First of all we build infinite size towers to left and right of the array.\\n- We define pits as the points, which have tower size as local minimum,\\n  i.e. height of tower just to the left >= height_pit <= height of tower just to the right\\n- In the below figure P1,P2...P5 are pits\\n\\n```\\nRatings:\\n\\nInf                                      Inf\\n|                   Peak                  |\\n|       Peak          |                   |\\n|         |           | |                 |\\n|       | |           | | |               |\\n|     | | | |       | | | | |     | | |   |\\n|   | | | | | |   | | | | | | |   | | |   |\\n| _ | | | | | | | | | | | | | | _ | | | | |\\n-------------------------------------------\\n* 0 2 3 4 5 3 2 1 2 3 6 5 4 3 2 0 3 3 3 1 *\\ni=0 1 2 3 4 5 6 7 8 9...             ...19\\n  ^\\t\\t        ^               ^   ^   ^\\n  P1\\t\\t    P2              P3  P4  P5\\n```\\n\\n- We assign candy=1 (minimum candy) to the pit tower and go left and right to the pit tower till we encounter peak. Assigning candy to the towers by increasing it by 1.\\n- For example if we start with pit P1, then we assign\\n\\t- candy=1 to tower at i=0\\n\\t- candy=2 to tower at i=1\\n\\t- candy=3 to tower at i=2\\n\\t- candy=4 to tower at i=3\\n\\t- candy=5 to tower at i=4\\n\\t- **we have now reached the peak so we store the peakIndex and peakVal**\\n\\t- we store peakIndex and peakVal only when we go to the right of pit\\n\\n- When we go to the left of the pit and if we reach the peak which already has candy assigned so we check if the new candy we are carrying is greater than the candy already assigned, if yes then we remove the original candy assigned and assign it the new candy.\\n- For example, when we start with pit=P2 and keep going left we see that when we reach peak at i=4\\n\\t- new candy = 4 \\n\\t- But old candy assigned = 5, so we don\\'t assign it new candy\\n\\t\\nHence we start with \\n```\\npeakIndex = None  #index of peak to the right of the pit\\npeakVal = None  # candy assigned to the peak\\ntotalSum = 0 # total candies assigned\\n```\\n\\n**Python code:**\\n\\n```\\ndef candy(self, L):\\n    #whenever you encounter a pit then assign values to towers by going left and right\\n    \\n    #creating infinte size towers to left and right borders\\n    L.insert(0,float(\\'inf\\'))\\n    L.append(float(\\'inf\\'))\\n    \\n    peakIndex = None\\n    peakVal = None\\n    totalCandy = 0\\n    \\n    for i in xrange(1,len(L)-1):\\n        if L[i-1]>=L[i]<=L[i+1]:\\n            #means this point is a pit so start filling left and right\\n            \\n            # +1 corresponds to assigning candy=1 to the pit\\n            totalCandy+=1\\n            \\n            #going left\\n            index = i-1\\n            curr_candy = 2\\n            \\n            #index>=1 so that we don\\'t reach the left infinite tower\\n            while index>=1 and L[index]>L[index+1]:\\n                #if we encounter peak\\n                if index==peakIndex:\\n                    totalCandy -= peakVal\\n                    totalCandy += max(peakVal,curr_candy)\\n                else:\\n                    totalCandy += curr_candy\\n                index-=1\\n                curr_candy+=1\\n                \\n            #going right\\n            index = i+1\\n            curr_candy = 2\\n            \\n            #index<len(L)-1 so that we don\\'t reach the right infinite tower\\n            while index<len(L)-1 and L[index]>L[index-1]:\\n                totalCandy += curr_candy\\n                index+=1\\n                curr_candy+=1\\n            \\n            #updating encountered peak\\n            peakIndex = index-1\\n            peakVal = curr_candy-1\\n    return totalCandy\\n```",
                "solutionTags": [],
                "code": "```\\nRatings:\\n\\nInf                                      Inf\\n|                   Peak                  |\\n|       Peak          |                   |\\n|         |           | |                 |\\n|       | |           | | |               |\\n|     | | | |       | | | | |     | | |   |\\n|   | | | | | |   | | | | | | |   | | |   |\\n| _ | | | | | | | | | | | | | | _ | | | | |\\n-------------------------------------------\\n* 0 2 3 4 5 3 2 1 2 3 6 5 4 3 2 0 3 3 3 1 *\\ni=0 1 2 3 4 5 6 7 8 9...             ...19\\n  ^\\t\\t        ^               ^   ^   ^\\n  P1\\t\\t    P2              P3  P4  P5\\n```\n```\\npeakIndex = None  #index of peak to the right of the pit\\npeakVal = None  # candy assigned to the peak\\ntotalSum = 0 # total candies assigned\\n```\n```\\ndef candy(self, L):\\n    #whenever you encounter a pit then assign values to towers by going left and right\\n    \\n    #creating infinte size towers to left and right borders\\n    L.insert(0,float(\\'inf\\'))\\n    L.append(float(\\'inf\\'))\\n    \\n    peakIndex = None\\n    peakVal = None\\n    totalCandy = 0\\n    \\n    for i in xrange(1,len(L)-1):\\n        if L[i-1]>=L[i]<=L[i+1]:\\n            #means this point is a pit so start filling left and right\\n            \\n            # +1 corresponds to assigning candy=1 to the pit\\n            totalCandy+=1\\n            \\n            #going left\\n            index = i-1\\n            curr_candy = 2\\n            \\n            #index>=1 so that we don\\'t reach the left infinite tower\\n            while index>=1 and L[index]>L[index+1]:\\n                #if we encounter peak\\n                if index==peakIndex:\\n                    totalCandy -= peakVal\\n                    totalCandy += max(peakVal,curr_candy)\\n                else:\\n                    totalCandy += curr_candy\\n                index-=1\\n                curr_candy+=1\\n                \\n            #going right\\n            index = i+1\\n            curr_candy = 2\\n            \\n            #index<len(L)-1 so that we don\\'t reach the right infinite tower\\n            while index<len(L)-1 and L[index]>L[index-1]:\\n                totalCandy += curr_candy\\n                index+=1\\n                curr_candy+=1\\n            \\n            #updating encountered peak\\n            peakIndex = index-1\\n            peakVal = curr_candy-1\\n    return totalCandy\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 42896,
                "title": "concise-java-solution",
                "content": "In the forward pass, if we meet r[i] < r[i+1] , assign candy[i+1] = candy[i]+1;\\n\\nIn the backward pass, the only difference is the case when r[i-1] < r[i] > r[i+1], need to compare candy[i+1]+1, and candy[i] (which is calculated in forward side).\\n\\n\\n    public class Solution {\\n        public int candy(int[] ratings) {\\n            // initialize\\n            int candy[] = new int[ratings.length];\\n            int sum = 0;\\n            Arrays.fill(candy,1); // crucial step!\\n            \\n            // forward pass, assign candy for increasing ones\\n            for(int i = 1;i < ratings.length;i++)\\n                if(ratings[i] > ratings[i-1])\\n                    candy[i] = candy[i-1]+1;\\n                    \\n            // backforward pass, assign candy for decreasing ones\\n            for(int i = ratings.length-2;i >= 0;i--)\\n                if(ratings[i] > ratings[i+1]){\\n                    if(i-1 >= 0 && ratings[i-1] <= ratings[i])\\n                        candy[i] = Math.max(candy[i+1]+1, candy[i]);\\n                    else\\n                        candy[i] = candy[i+1] + 1;\\n                }\\n            \\n            // sum up candy\\n            for(int i = 0;i < candy.length;i++)\\n                sum += candy[i];\\n            return sum;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int candy(int[] ratings) {\\n            // initialize\\n            int candy[] = new int[ratings.length];\\n            int sum = 0;\\n            Arrays.fill(candy,1); // crucial step!\\n            \\n            // forward pass, assign candy for increasing ones\\n            for(int i = 1;i < ratings.length;i++)\\n                if(ratings[i] > ratings[i-1])\\n                    candy[i] = candy[i-1]+1;\\n                    \\n            // backforward pass, assign candy for decreasing ones\\n            for(int i = ratings.length-2;i >= 0;i--)\\n                if(ratings[i] > ratings[i+1]){\\n                    if(i-1 >= 0 && ratings[i-1] <= ratings[i])\\n                        candy[i] = Math.max(candy[i+1]+1, candy[i]);\\n                    else\\n                        candy[i] = candy[i+1] + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4038177,
                "title": "100-easy-one-pass-solution-with-explanation-and-example-visualization",
                "content": "\\n# Approach\\nFirstly we\\'ll create an array ```left``` of ```size n+1```, this array will store the ```number of candies``` to be allotted to ith child considering his ```neighbours to left```.\\n\\nTraverse through the ratings array and if rating of current child is more than rating of previous child, increase the number of candies by 1, i.e ```left[i] = left[i-1] + 1```.\\n\\nWe\\'re accounting for the left neighbours, now we need to account for right neigbours, for this we can have another for loop which will run from ```right to left```, but this will just ```add on to space complexity```.\\n\\nOne thing that we notice in our left for loop is that we need to increment only when the current child\\'s rating is greater than previous child\\'r rating.\\n\\nSo in the for loop for ```right neighbour```, we will check if rating of current child is greater than one to its right, if it is we will increment the value of right and do ```left[i] = max(left[i], right)```.\\n\\nBy doing this we are incrementing the value of right ```only when the current rating is greater than next```, if its not our ```right``` stands at ```1```, this way we don\\'t need to store our candies for right neighbours in another array and then later take maximum, so we ```save ourselves a lot of time and space```.\\n\\nAt last find the ```sum``` of candies and ```return sum```.\\n\\n# I\\'ve explained an example below for better understanding-\\n![image.png](https://assets.leetcode.com/users/images/73408bf6-d2b5-4c93-ab81-a532d5210989_1694580577.7185543.png)\\n\\n\\n# Do upvote if you liked even a bit!\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n      vector<int> left(n+1,1);\\n      for(int i=1;i<n;i++){\\n          if(ratings[i]>ratings[i-1]) left[i]=left[i-1]+1;\\n      }  \\n\\n      int right=1;\\n      for(int i=n-2;i>=0;i--){\\n          if(ratings[i]>ratings[i+1]){\\n            right++;\\n            left[i]=max(left[i],right);\\n          }else right=1;\\n      }\\n\\n      int sum=0;\\n      for(int i=0;i<n;i++){\\n            sum+=left[i];\\n      }\\n      return sum;\\n    }\\n};\\n```\\n# JAVA Code\\n```\\npublic class Solution {\\n    public int candy(int[] ratings) {\\n        if (ratings == null || ratings.length == 0) return 0;\\n        int total = 1, prev = 1, countDown = 0;\\n        for (int i = 1; i < ratings.length; i++) {\\n            if (ratings[i] >= ratings[i-1]) {\\n                if (countDown > 0) {\\n                    total += countDown*(countDown+1)/2; // arithmetic progression\\n                    if (countDown >= prev) total += countDown - prev + 1;\\n                    countDown = 0;\\n                    prev = 1;\\n                }\\n                prev = ratings[i] == ratings[i-1] ? 1 : prev+1;\\n                total += prev;\\n            } else countDown++;\\n        }\\n        if (countDown > 0) { // if we were descending at the end\\n            total += countDown*(countDown+1)/2;\\n            if (countDown >= prev) total += countDown - prev + 1;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```left```\n```size n+1```\n```number of candies```\n```neighbours to left```\n```left[i] = left[i-1] + 1```\n```right to left```\n```add on to space complexity```\n```right neighbour```\n```left[i] = max(left[i], right)```\n```only when the current rating is greater than next```\n```right```\n```1```\n```save ourselves a lot of time and space```\n```sum```\n```return sum```\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n      vector<int> left(n+1,1);\\n      for(int i=1;i<n;i++){\\n          if(ratings[i]>ratings[i-1]) left[i]=left[i-1]+1;\\n      }  \\n\\n      int right=1;\\n      for(int i=n-2;i>=0;i--){\\n          if(ratings[i]>ratings[i+1]){\\n            right++;\\n            left[i]=max(left[i],right);\\n          }else right=1;\\n      }\\n\\n      int sum=0;\\n      for(int i=0;i<n;i++){\\n            sum+=left[i];\\n      }\\n      return sum;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public int candy(int[] ratings) {\\n        if (ratings == null || ratings.length == 0) return 0;\\n        int total = 1, prev = 1, countDown = 0;\\n        for (int i = 1; i < ratings.length; i++) {\\n            if (ratings[i] >= ratings[i-1]) {\\n                if (countDown > 0) {\\n                    total += countDown*(countDown+1)/2; // arithmetic progression\\n                    if (countDown >= prev) total += countDown - prev + 1;\\n                    countDown = 0;\\n                    prev = 1;\\n                }\\n                prev = ratings[i] == ratings[i-1] ? 1 : prev+1;\\n                total += prev;\\n            } else countDown++;\\n        }\\n        if (countDown > 0) { // if we were descending at the end\\n            total += countDown*(countDown+1)/2;\\n            if (countDown >= prev) total += countDown - prev + 1;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558829,
                "title": "c-easy-o-n-solution-using-2-only-for-loop",
                "content": "# Intuition  \\n   If neighbour rating is less we should give that child one more candy.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAt initials - give 1 candy to every child to meet the condition - every child must get a candy.\\n\\nTHEN \\n\\n    for loop ---------------->\\n      If ratings[i]>ratings[i-1]\\n            i+1 th child get one more candy than i th child,so increase it once\\n     for loop <-----------------\\n      If ratings[i]>ratings[i+1]\\n           i th child get one more candy than i+1 th child, so increase it once \\n\\n\\nOne more thing you have to keep in mind that, while reverse traversing in 2nd loop you should not give a increment to a child who already got in first loop and not required increment anymore\\n\\n         example :-\\n     ratings              1 3 2 2 1\\n     candy get:-\\n     intitials            1 1 1 1 1\\n     after 1st loop       1 2 1 1 1\\n     after 2nd loop       1 3 1 2 1\\n                            ^\\n                            |\\n                        got increment twice, but dont need in 2nd loop\\n    so while reverse traversing we also check\\n               candy[i]<=candy[i+1]\\n                              then only it get a increment.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        if(ratings.size()==1){\\n            return 1;\\n        }\\n        \\n        vector<int>ans(ratings.size(),1);  \\n        for(int i=1;i<ratings.size();i++){\\n            if(ratings[i]>ratings[i-1]){\\n                ans[i]=ans[i-1]+1;\\n            }\\n        }\\n        for(int i=ratings.size()-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                ans[i]=ans[i+1]+1;\\n            }\\n        }\\n      \\n     return accumulate(ans.begin(),ans.end(),0LL);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        if(ratings.size()==1){\\n            return 1;\\n        }\\n        \\n        vector<int>ans(ratings.size(),1);  \\n        for(int i=1;i<ratings.size();i++){\\n            if(ratings[i]>ratings[i-1]){\\n                ans[i]=ans[i-1]+1;\\n            }\\n        }\\n        for(int i=ratings.size()-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                ans[i]=ans[i+1]+1;\\n            }\\n        }\\n      \\n     return accumulate(ans.begin(),ans.end(),0LL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013668,
                "title": "java-1ms-simple-solution-with-detailed-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic Trapping Rainwater like solution. https://leetcode.com/problems/trapping-rain-water/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nObservations : \\n- init with all 1.\\n- we only give one more when we see adjacent increase (both from left to right).\\n- I want to use some case to illustrate this.\\n- notice we don\\'t care for the exact values of ratings, only their relation\\n\\nthe rating is similar to \\'wave\\', increase of decrease\\n\\nlet\\'s look at this case:\\n```\\nratings: [1,3,6,9,4,2]\\ncandies: [1,2,3,4,2,1]\\n```\\n\\nthe highest rating is 9, when scan from left to right, num of candies should be 4, scan right to left, it should be 3, then we choose the larger value.\\n\\nand let\\'s look at some case containing adjacent-equal\\n\\nwhen there are adjacent-equal, lets look at some cases:\\n\\n```\\nratings: [1,2,3,3,3,3,4,5]\\ncandies: [1,2,3,1,1,1,2,3]\\n```\\n\\n```\\nratings: [1,2,8,8,8,8,8,2]\\ncandies: [1,2,3,1,1,1,2,1]\\n```\\n\\nwith these cases it should be easier to understand\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int[] cendies = new int[ratings.length];\\n        \\n        for(int i=0; i<cendies.length; ++i){\\n            cendies[i]=1;\\n        }\\n\\n        for(int i=1; i<cendies.length; ++i){\\n            if(ratings[i]>ratings[i-1]){\\n                cendies[i]=cendies[i-1]+1;\\n            }\\n        }\\n\\n        for(int i=cendies.length-2; i>=0; --i){\\n            if(ratings[i]>ratings[i+1] && cendies[i]<cendies[i+1]+1){\\n                cendies[i]=cendies[i+1]+1;\\n            }\\n        }\\n\\n        int sum=0;\\n        for(int i=0; i<cendies.length; ++i){\\n            sum+=cendies[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nratings: [1,3,6,9,4,2]\\ncandies: [1,2,3,4,2,1]\\n```\n```\\nratings: [1,2,3,3,3,3,4,5]\\ncandies: [1,2,3,1,1,1,2,3]\\n```\n```\\nratings: [1,2,8,8,8,8,8,2]\\ncandies: [1,2,3,1,1,1,2,1]\\n```\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int[] cendies = new int[ratings.length];\\n        \\n        for(int i=0; i<cendies.length; ++i){\\n            cendies[i]=1;\\n        }\\n\\n        for(int i=1; i<cendies.length; ++i){\\n            if(ratings[i]>ratings[i-1]){\\n                cendies[i]=cendies[i-1]+1;\\n            }\\n        }\\n\\n        for(int i=cendies.length-2; i>=0; --i){\\n            if(ratings[i]>ratings[i+1] && cendies[i]<cendies[i+1]+1){\\n                cendies[i]=cendies[i+1]+1;\\n            }\\n        }\\n\\n        int sum=0;\\n        for(int i=0; i<cendies.length; ++i){\\n            sum+=cendies[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301339,
                "title": "candy-python-144ms-runtime-2-solutions",
                "content": "\\n\\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        lenratings = len(ratings)       # call len only once. It is used 3 times\\n        ans = [1] * lenratings\\n        for i in range(1, lenratings):\\n            if ratings[i] > ratings[i-1]:\\n                ans[i] = ans[i-1] + 1\\n        for i in range(lenratings-2, -1, -1):\\n            a = i+1                     # a is used 2 times in if\\n            # compare rantings and candys is faster than use \"max\" to calculate.\\n            if ratings[i] > ratings[a] and ans[i] <= ans[a]:\\n                ans[i] = ans[a] + 1\\n        return sum(ans)\\n```\\n\\nIn this second solution I try to save some time in the reverse loop saving only indexes that should be visited. But in the end of the tests the runtime is the same but usage memory is bigger.\\n\\n```\\nclass Solution:\\n    def candy(self, ratings: list) -> int:\\n        lenratings = len(ratings)       # call len only once. It is used 3 times\\n        ans = [1] * lenratings\\n        b = []\\n        for i in range(1, lenratings):\\n            if ratings[i] > ratings[i-1]:\\n                ans[i] = ans[i-1] + 1\\n            else:\\n                b.append(i-1)\\n        b.reverse()\\n        for i in b:\\n            a = i+1                     # a is used 2 times in if\\n            # compare rantings and candys is faster than use \"max\" to calculate.\\n            if ratings[i] > ratings[a] and ans[i] <= ans[a]:\\n                ans[i] = ans[a] + 1\\n        return sum(ans)\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        lenratings = len(ratings)       # call len only once. It is used 3 times\\n        ans = [1] * lenratings\\n        for i in range(1, lenratings):\\n            if ratings[i] > ratings[i-1]:\\n                ans[i] = ans[i-1] + 1\\n        for i in range(lenratings-2, -1, -1):\\n            a = i+1                     # a is used 2 times in if\\n            # compare rantings and candys is faster than use \"max\" to calculate.\\n            if ratings[i] > ratings[a] and ans[i] <= ans[a]:\\n                ans[i] = ans[a] + 1\\n        return sum(ans)\\n```\n```\\nclass Solution:\\n    def candy(self, ratings: list) -> int:\\n        lenratings = len(ratings)       # call len only once. It is used 3 times\\n        ans = [1] * lenratings\\n        b = []\\n        for i in range(1, lenratings):\\n            if ratings[i] > ratings[i-1]:\\n                ans[i] = ans[i-1] + 1\\n            else:\\n                b.append(i-1)\\n        b.reverse()\\n        for i in b:\\n            a = i+1                     # a is used 2 times in if\\n            # compare rantings and candys is faster than use \"max\" to calculate.\\n            if ratings[i] > ratings[a] and ans[i] <= ans[a]:\\n                ans[i] = ans[a] + 1\\n        return sum(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037690,
                "title": "c-greedy-vs-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s a greedy problem.\\nLook at this example. You\\'ll find how unfair this rule is.\\n```\\n[60, 80, 100, 100, 100, 100, 100]\\n```\\ncandies for children\\n```\\n1, 2, 3, 1, 1, 1, 1\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse prefix sum.It\\'s easier to understand. Transverse forward & backward. 3 conditions to consider\\n1. ratings[i-1] < ratings[i]: c[i]=c[i-1]+1;\\n2. ratings[i-1] ==ratings[i]==ratings[i+1]: c[i]; 1 candy is enough\\n3. ratings[i]>ratings[i+1]: c[i]=max(c[i], c[i+1]+1); Use it when backward \\n\\nThis can be done just using one loop. But the handeling is a little bit subtle.\\n\\nSupposed one has arrived the peak, i.e. ```c[i]=peak+1```. From index i on, ```ratings[i]``` form a strictly decreasing sebsequence of length down+1. If peak>=down the candies for subdsequence of length ```down+1```.\\n```\\ncs=[peak+1,down, down-1, ...., 2, 1] \\n```\\notherwise, i.e. peak<down, when adding 1 more ```ratings[i]``` with ```ratings[i-1]>ratings[i]```\\nevery element in ```cs```should be increased by 1 whose total amount is ```down+1```.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1st code: $O(1)$\\n2nd code: $O(n)$\\n#  Code using 1 transversal &  O(1) SC\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        int ans = 1;\\n        int up = 0, down = 0, peak = 0;\\n         for (int i = 1; i <n; i++) {\\n             //ascending\\n            if (ratings[i-1] < ratings[i]) {\\n                peak = ++up;\\n                down = 0;\\n                ans+= 1+peak;//c[i]=1+peak\\n            } \\n            //slope=0\\n            else if (ratings[i-1] == ratings[i])  {\\n                peak =up = down = 0;\\n                ans++;//c[i]=1\\n            } \\n            else {//decreasing\\n                up = 0;\\n                down++;//length for decreasing subsequence\\n                ans += (peak<down)? down+1: down;\\n                //If peak>=down the candies for subdsequence of length down+1\\n                //cs=[peak+1,down, down-1, ...., 2, 1] otherwise when adding 1 more \\n                //every element in cs should be increased by 1 which amount down+1\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Prefix Sum\\n```\\nclass Solution {\\npublic:\\n    void print(vector<int>& c){\\n        for(int i=0; i<c.size(); i++)\\n            cout<<c[i]<<\",\";\\n        cout<<endl;\\n    }\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int> c(n, 1);\\n\\n        for (int i=1; i<n; i++){\\n            if (ratings[i]>ratings[i-1]) \\n                c[i]=c[i-1]+1;\\n        }\\n        for (int i=n-2; i>=0; i--)\\n            if (ratings[i]>ratings[i+1]) \\n                c[i]=max(c[i], c[i+1]+1);\\n    //    print(c);\\n        return accumulate(c.begin(), c.begin()+n,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\n[60, 80, 100, 100, 100, 100, 100]\\n```\n```\\n1, 2, 3, 1, 1, 1, 1\\n```\n```c[i]=peak+1```\n```ratings[i]```\n```down+1```\n```\\ncs=[peak+1,down, down-1, ...., 2, 1] \\n```\n```ratings[i]```\n```ratings[i-1]>ratings[i]```\n```cs```\n```down+1```\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        int ans = 1;\\n        int up = 0, down = 0, peak = 0;\\n         for (int i = 1; i <n; i++) {\\n             //ascending\\n            if (ratings[i-1] < ratings[i]) {\\n                peak = ++up;\\n                down = 0;\\n                ans+= 1+peak;//c[i]=1+peak\\n            } \\n            //slope=0\\n            else if (ratings[i-1] == ratings[i])  {\\n                peak =up = down = 0;\\n                ans++;//c[i]=1\\n            } \\n            else {//decreasing\\n                up = 0;\\n                down++;//length for decreasing subsequence\\n                ans += (peak<down)? down+1: down;\\n                //If peak>=down the candies for subdsequence of length down+1\\n                //cs=[peak+1,down, down-1, ...., 2, 1] otherwise when adding 1 more \\n                //every element in cs should be increased by 1 which amount down+1\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void print(vector<int>& c){\\n        for(int i=0; i<c.size(); i++)\\n            cout<<c[i]<<\",\";\\n        cout<<endl;\\n    }\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int> c(n, 1);\\n\\n        for (int i=1; i<n; i++){\\n            if (ratings[i]>ratings[i-1]) \\n                c[i]=c[i-1]+1;\\n        }\\n        for (int i=n-2; i>=0; i--)\\n            if (ratings[i]>ratings[i+1]) \\n                c[i]=max(c[i], c[i+1]+1);\\n    //    print(c);\\n        return accumulate(c.begin(), c.begin()+n,0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3812877,
                "title": "python-easy-code-beats-95-82-runtime-and-94-23-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI used the approach of once iterating from left to right and then from right to left. Here, we had to consider kids on either sides, hence this was a good technique to achieve O(n).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo maintain our O(n) complexity target, dynamic programming seems to be a likable option. We initialize our dp array with all 1s as each child has to have atleast one candy. We then iterate and compare with the neighbours and keep adding candies so that a child with higher rating gets more candies than neighbours.\\nNote: We have to check whether the high rated child already has more candies, if so then we do not add more. So we have to compare ratings as well as candies at hand before assigning. This is because we need to allot \\'minimum\\' number of candies.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/05ae6b88-ee2c-4f3c-9fd0-81abdea06599_1690264401.968263.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        dp = [1]*n\\n        #left to right\\n        for i in range(1,n):\\n            if ratings[i]>ratings[i-1] and dp[i]<=dp[i-1]:\\n                dp[i] = dp[i-1]+1\\n        #right to left\\n        for i in range(n-2,-1,-1):\\n            if ratings[i]>ratings[i+1] and dp[i]<=dp[i+1]:\\n                dp[i] = dp[i+1]+1\\n        return sum(dp)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        dp = [1]*n\\n        #left to right\\n        for i in range(1,n):\\n            if ratings[i]>ratings[i-1] and dp[i]<=dp[i-1]:\\n                dp[i] = dp[i-1]+1\\n        #right to left\\n        for i in range(n-2,-1,-1):\\n            if ratings[i]>ratings[i+1] and dp[i]<=dp[i+1]:\\n                dp[i] = dp[i+1]+1\\n        return sum(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640353,
                "title": "easy-and-fast",
                "content": "# Intuition\\nThis is array based question.\\n\\n# Approach\\n1. Take candy array with size ratings and initialize with one.\\n2. Move left to right and compare the ratings and candy value if ratings high and candy value less or equal to then increase the candy array value.\\n3. Move right to left and do same #2.\\n4. Sum the values of candy array.\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} ratings\\n * @return {number}\\n */\\nvar candy = function(ratings) {\\n    let candy = new Array(ratings.length).fill(1);\\n\\n// left to right \\n    for(let i=1;i<ratings.length;i++){\\n        if(ratings[i]>ratings[i-1] && candy[i] <= candy[i-1]){\\n            candy[i]=candy[i-1]+1;\\n        }\\n    }\\n\\n// right to left\\n    for(let i=ratings.length-2;i>=0;i--){\\n    if(ratings[i]>ratings[i+1] && candy[i] <= candy[i+1]){\\n            candy[i]=candy[i+1]+1;\\n        }\\n    }\\n\\n    let sum = candy.reduce((cur,acc)=> acc=cur+acc);\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} ratings\\n * @return {number}\\n */\\nvar candy = function(ratings) {\\n    let candy = new Array(ratings.length).fill(1);\\n\\n// left to right \\n    for(let i=1;i<ratings.length;i++){\\n        if(ratings[i]>ratings[i-1] && candy[i] <= candy[i-1]){\\n            candy[i]=candy[i-1]+1;\\n        }\\n    }\\n\\n// right to left\\n    for(let i=ratings.length-2;i>=0;i--){\\n    if(ratings[i]>ratings[i+1] && candy[i] <= candy[i+1]){\\n            candy[i]=candy[i+1]+1;\\n        }\\n    }\\n\\n    let sum = candy.reduce((cur,acc)=> acc=cur+acc);\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2236598,
                "title": "python-o-n-time-o-n-space-explained",
                "content": "```\\n#Baraa\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        \"\"\"\\n        Good Example to check: \\n        [8, 4, 2, 1, 3, 6, 7, 9, 5]\\n        \\n        STEP 1: we compare each number with number before it\\n        if current number > number before it we have to increment our reward\\n        i.e: res[i] = res[i - 1] + 1\\n        \\n        STEP 2: We compare same way but from end of the array to beggining of it\\n        if current number > number after it we increment if and only if there is a need to increment\\n        because maybe when we incremented in the first step we already gave more rewards for current number\\n        this can be observed in the above example \\n        \"\"\"\\n        \\n        n = len(ratings)\\n        res = [1] * (n)\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i - 1] and res[i] <= res[i - 1]:\\n                res[i] = res[i - 1] + 1\\n        for i in range(n - 2, -1, -1):\\n            if ratings[i] > ratings[i + 1] and res[i] <= res[i + 1]:\\n                res[i] = res[i + 1] + 1\\n        return sum(res)\\n    \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n#Baraa\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        \"\"\"\\n        Good Example to check: \\n        [8, 4, 2, 1, 3, 6, 7, 9, 5]\\n        \\n        STEP 1: we compare each number with number before it\\n        if current number > number before it we have to increment our reward\\n        i.e: res[i] = res[i - 1] + 1\\n        \\n        STEP 2: We compare same way but from end of the array to beggining of it\\n        if current number > number after it we increment if and only if there is a need to increment\\n        because maybe when we incremented in the first step we already gave more rewards for current number\\n        this can be observed in the above example \\n        \"\"\"\\n        \\n        n = len(ratings)\\n        res = [1] * (n)\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i - 1] and res[i] <= res[i - 1]:\\n                res[i] = res[i - 1] + 1\\n        for i in range(n - 2, -1, -1):\\n            if ratings[i] > ratings[i + 1] and res[i] <= res[i + 1]:\\n                res[i] = res[i + 1] + 1\\n        return sum(res)\\n    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235735,
                "title": "candy-java-solution-optimized",
                "content": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n =  ratings.length;\\n        if(n <= 1)\\n            return n;\\n        int up = 0,down = 0;\\n        int prevSlope = 0;\\n        int candies = 0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            //calculate the slope\\n            //assign -ve +iv or zero for the decreasing increasing or plain slope\\n            //increasing slope = 1\\n            //decreasing slope = -1\\n            //plain slope = 0\\n            int current_Slope = ratings[i]>ratings[i-1]?1:\\n                                (ratings[i]<ratings[i-1]?-1:0);\\n            //divide the mountains on 3 conditions\\n            /*Condition 1:\\n              If we are getting a mountain like \\\\/ i.e the slope is decreasing and then increasing,\\n              \\n            */\\n            \\n            /*Condition 2:\\n              If we are getting a mountain like \\\\_ i.e the slope is decreasing and then plain,\\n              \\n            */\\n            \\n            /*Condition 3:\\n                                               _\\n              If we are getting mountain like /  i.e the slope is decreasing and then increasing,\\n              \\n            */\\n            if((prevSlope<0 && current_Slope>=0) || (prevSlope>0 && current_Slope==0))\\n            {\\n                candies = candies + sum(up) + sum(down) + Math.max(up,down);\\n                up=0;\\n                down=0;\\n            }\\n            if(current_Slope > 0)\\n                up++;\\n            else if(current_Slope < 0)\\n                down++;\\n            else\\n                candies++;\\n            prevSlope = current_Slope;\\n        }\\n        //add the candies that are there for the last mountain\\n        candies = candies + sum(up) + sum(down) + Math.max(up,down) + 1;\\n        return candies;\\n    }\\n    public int sum(int n)\\n    {\\n        return (n*(n+1))/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n =  ratings.length;\\n        if(n <= 1)\\n            return n;\\n        int up = 0,down = 0;\\n        int prevSlope = 0;\\n        int candies = 0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            //calculate the slope\\n            //assign -ve +iv or zero for the decreasing increasing or plain slope\\n            //increasing slope = 1\\n            //decreasing slope = -1\\n            //plain slope = 0\\n            int current_Slope = ratings[i]>ratings[i-1]?1:\\n                                (ratings[i]<ratings[i-1]?-1:0);\\n            //divide the mountains on 3 conditions\\n            /*Condition 1:\\n              If we are getting a mountain like \\\\/ i.e the slope is decreasing and then increasing,\\n              \\n            */\\n            \\n            /*Condition 2:\\n              If we are getting a mountain like \\\\_ i.e the slope is decreasing and then plain,\\n              \\n            */\\n            \\n            /*Condition 3:\\n                                               _\\n              If we are getting mountain like /  i.e the slope is decreasing and then increasing,\\n              \\n            */\\n            if((prevSlope<0 && current_Slope>=0) || (prevSlope>0 && current_Slope==0))\\n            {\\n                candies = candies + sum(up) + sum(down) + Math.max(up,down);\\n                up=0;\\n                down=0;\\n            }\\n            if(current_Slope > 0)\\n                up++;\\n            else if(current_Slope < 0)\\n                down++;\\n            else\\n                candies++;\\n            prevSlope = current_Slope;\\n        }\\n        //add the candies that are there for the last mountain\\n        candies = candies + sum(up) + sum(down) + Math.max(up,down) + 1;\\n        return candies;\\n    }\\n    public int sum(int n)\\n    {\\n        return (n*(n+1))/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234474,
                "title": "c-from-the-left-from-the-right-max-of-both",
                "content": "iterate from the left to right\\niterate from right to left\\nadd max of left pass and right pass at each index\\n\\n**SOLVED LIVE ON TWITCH.   Everyday 6pm PT.  Link in profile.**\\n\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        \\n        vector<int> lefts(n, 1);\\n        vector<int> rights(n, 1);\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                lefts[i] = lefts[i-1] + 1;\\n            }\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                rights[i] = rights[i+1] + 1;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < n; i++) {\\n            ans += max(lefts[i], rights[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        \\n        vector<int> lefts(n, 1);\\n        vector<int> rights(n, 1);\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                lefts[i] = lefts[i-1] + 1;\\n            }\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                rights[i] = rights[i+1] + 1;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < n; i++) {\\n            ans += max(lefts[i], rights[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739602,
                "title": "solution-swift-candy-test-cases",
                "content": "```swift\\nclass Solution {\\n    func candy(_ ratings: [Int]) -> Int {\\n        let len = ratings.count\\n        guard len > 1 else { return len }\\n        \\n        var value = 0\\n        \\n        var lhs2rhs = [Int](repeating: 1, count: len)\\n        var rhs2lhs = [Int](repeating: 1, count: len)\\n        \\n        for i in 1..<len where ratings[i] > ratings[i - 1] {\\n            lhs2rhs[i] = lhs2rhs[i - 1] + 1\\n        }\\n        for i in (0..<(len - 1)).reversed() where ratings[i] > ratings[i + 1] {\\n            rhs2lhs[i] = rhs2lhs[ i + 1] + 1\\n        }\\n        for i in 0..<len {\\n            value += max(lhs2rhs[i], rhs2lhs[i])\\n        }\\n        return value\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.010 (0.012) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\\n    func test0() {\\n        let value = solution.candy([1,0,2])\\n        XCTAssertEqual(value, 5)\\n    }\\n    \\n    // You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\\n    // The third child gets 1 candy because it satisfies the above two conditions.\\n    func test1() {\\n        let value = solution.candy([1,2,2])\\n        XCTAssertEqual(value, 4)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func candy(_ ratings: [Int]) -> Int {\\n        let len = ratings.count\\n        guard len > 1 else { return len }\\n        \\n        var value = 0\\n        \\n        var lhs2rhs = [Int](repeating: 1, count: len)\\n        var rhs2lhs = [Int](repeating: 1, count: len)\\n        \\n        for i in 1..<len where ratings[i] > ratings[i - 1] {\\n            lhs2rhs[i] = lhs2rhs[i - 1] + 1\\n        }\\n        for i in (0..<(len - 1)).reversed() where ratings[i] > ratings[i + 1] {\\n            rhs2lhs[i] = rhs2lhs[ i + 1] + 1\\n        }\\n        for i in 0..<len {\\n            value += max(lhs2rhs[i], rhs2lhs[i])\\n        }\\n        return value\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\\n    func test0() {\\n        let value = solution.candy([1,0,2])\\n        XCTAssertEqual(value, 5)\\n    }\\n    \\n    // You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\\n    // The third child gets 1 candy because it satisfies the above two conditions.\\n    func test1() {\\n        let value = solution.candy([1,2,2])\\n        XCTAssertEqual(value, 4)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917156,
                "title": "java-greedy-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int candy(int[] arr) {\\n        int n=arr.length;\\n        int a[]=new int[n];\\n        Arrays.fill(a,1);\\n        for(int i=0;i<n-1;i++){\\n            if(arr[i]<arr[i+1]){\\n                a[i+1]=1+a[i];\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            if(arr[i]<arr[i-1]&&a[i-1]<=a[i]){\\n                a[i-1]=a[i]+1;\\n            }\\n        }\\n        int sum=0;\\n        for(int i:a)sum+=i;\\n        return sum;\\n    }\\n}\\n```\\n# Please upvote",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] arr) {\\n        int n=arr.length;\\n        int a[]=new int[n];\\n        Arrays.fill(a,1);\\n        for(int i=0;i<n-1;i++){\\n            if(arr[i]<arr[i+1]){\\n                a[i+1]=1+a[i];\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            if(arr[i]<arr[i-1]&&a[i-1]<=a[i]){\\n                a[i-1]=a[i]+1;\\n            }\\n        }\\n        int sum=0;\\n        for(int i:a)sum+=i;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702993,
                "title": "5-lines-of-efficient-code-step-by-step-approach",
                "content": "# Intuition\\nMy initial thoughts on how to solve this problem are to iterate through the ratings array and compare each element with its neighboring elements. If an element is greater than its previous element, I would assign it one more candy than the previous element. Similarly, if an element is greater than its next element, I would assign it one more candy than the next element. This way, I can ensure that higher-rated students receive more candies than their neighbors.\\n\\n# Approach\\nTo solve the problem, I will use a greedy approach. I will initialize a result variable as 0 to keep track of the total number of candies needed. I will also create two arrays, ltr and rtl, both of length n (where n is the number of elements in the ratings array). The ltr array will store the number of candies assigned to each student from left to right, and the rtl array will store the number of candies assigned to each student from right to left.\\n\\nFirst, I will iterate through the ratings array from index 1 to n-1. If the current rating is greater than the previous rating, I will assign one more candy than the previous student to the current student by updating the ltr array.\\n\\nThen, I will iterate through the ratings array from index n-2 to 0. If the current rating is greater than the next rating, I will assign one more candy than the next student to the current student by updating the rtl array.\\n\\nFinally, I will iterate through the ratings array and add the maximum value between ltr[i] and rtl[i] to the result variable.\\n\\nAfter the iterations, the result variable will contain the minimum number of candies needed to satisfy the given conditions. I will return this result.\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution is O(n), where n is the number of elements in the ratings array. This is because we iterate through the ratings array three times, which takes linear time.\\n- Space complexity: The space complexity is also O(n) because we create two arrays, ltr and rtl, of length n to store the number of candies assigned to each student.\\n\\n# Code\\n```\\nfunction candy(ratings: number[]): number {\\n    let res = 0 , n = ratings.length, ltr = new Array(n).fill(1) , rtl = new Array(n).fill(1);\\n    for( let i = 1 ; i < n ; i++ )if( ratings[i] > ratings[i - 1])ltr[i] = ltr[i - 1] + 1;\\n    for( let i = n - 2 ; i >= 0 ; i-- )if( ratings[i] > ratings[i + 1])rtl[i] = rtl[i + 1] + 1;\\n    for( let i = 0 ; i < n ; i++ )res += Math.max(ltr[i] , rtl[i])\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nfunction candy(ratings: number[]): number {\\n    let res = 0 , n = ratings.length, ltr = new Array(n).fill(1) , rtl = new Array(n).fill(1);\\n    for( let i = 1 ; i < n ; i++ )if( ratings[i] > ratings[i - 1])ltr[i] = ltr[i - 1] + 1;\\n    for( let i = n - 2 ; i >= 0 ; i-- )if( ratings[i] > ratings[i + 1])rtl[i] = rtl[i + 1] + 1;\\n    for( let i = 0 ; i < n ; i++ )res += Math.max(ltr[i] , rtl[i])\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3490359,
                "title": "java-solution-for-candy-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to use two passes to distribute candies to children. In the first pass, we traverse the ratings from left to right and assign candies to each child based on the ratings of the previous child. If the rating of the current child is higher than the previous child, we assign one more candy than the previous child. Otherwise, we assign one candy. In the second pass, we traverse the ratings from right to left and update the candies assigned to each child based on the ratings of the next child. If the rating of the current child is higher than the next child, we assign one more candy than the next child. We take the maximum of the candies assigned in both passes for each child and return the sum of all candies assigned.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if the input array ratings is null or empty. If so, return 0, as there are no children to distribute candies to.\\n2. Initialize an array candies of the same length as ratings to store the candies assigned to each child.\\n3. Assign one candy to the first child.\\n4. Traverse the ratings from left to right and assign candies to each child based on the ratings of the previous child. If the rating of the current child is higher than the previous child, assign one more candy than the previous child. Otherwise, assign one candy.\\n5. Traverse the ratings from right to left and update the candies assigned to each child based on the ratings of the next child. If the rating of the current child is higher than the next child, assign one more candy than the next child. Take the maximum of the candies assigned in both passes for each child.\\n6. Return the sum of all candies assigned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of the input array ratings. The algorithm iterates through the array twice, performing constant-time operations for each element.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), as the algorithm uses an additional array candies of the same length as ratings to store the candies assigned to each child.\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int candy(int[] ratings) \\n    {\\n        if (ratings == null || ratings.length == 0) \\n        {\\n            return 0;\\n        }\\n        int[] candies = new int[ratings.length];\\n        candies[0] = 1;\\n        //from let to right\\n        for (int i = 1; i < ratings.length; i++) \\n        {\\n            if (ratings[i] > ratings[i - 1]) \\n            {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n            else \\n            {\\n                // if not ascending, assign 1\\n                candies[i] = 1;\\n            }\\n        }\\n        int result = candies[ratings.length - 1];\\n        //from right to left\\n        for (int i = ratings.length - 2; i >= 0; i--) \\n        {\\n            int cur = 1;\\n            if (ratings[i] > ratings[i + 1]) \\n            {\\n                cur = candies[i + 1] + 1;\\n            }\\n            result += Math.max(cur, candies[i]);\\n            candies[i] = cur;\\n        }\\n        return result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int candy(int[] ratings) \\n    {\\n        if (ratings == null || ratings.length == 0) \\n        {\\n            return 0;\\n        }\\n        int[] candies = new int[ratings.length];\\n        candies[0] = 1;\\n        //from let to right\\n        for (int i = 1; i < ratings.length; i++) \\n        {\\n            if (ratings[i] > ratings[i - 1]) \\n            {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n            else \\n            {\\n                // if not ascending, assign 1\\n                candies[i] = 1;\\n            }\\n        }\\n        int result = candies[ratings.length - 1];\\n        //from right to left\\n        for (int i = ratings.length - 2; i >= 0; i--) \\n        {\\n            int cur = 1;\\n            if (ratings[i] > ratings[i + 1]) \\n            {\\n                cur = candies[i + 1] + 1;\\n            }\\n            result += Math.max(cur, candies[i]);\\n            candies[i] = cur;\\n        }\\n        return result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300609,
                "title": "very-simple-approach-with-explained-theory-and-code-using-one-array-o-n",
                "content": "**To solve this problem we will traverse the Rating array two times , Once Left to right ,second\\nRight to left\\nFirst we will make a resultant array equal to the size of ratings and fill it with 1 at every index\\nWhile Traversing left to right we will start from 2nd element and check if this is greater then prev elem then we will increase resultant array[i] = resultant[i-1]+1\\nNow second traversal \\nwe will start from right second element and check if  this is greater then next element  then we will check further if res[i]<=res[i+1] then we will inc res[i]=  res[i+1]+1\\nNow we will traverse the res array and return sum of its element\\nNow below is the code \\nDo Upvote please!  :)\\nHappy Leetcoding**\\n\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] res = new int[n];\\n        Arrays.fill(res,1);\\n        //Left to right scan and check whether ratings[i]>ratings[i-1] if yes then increment by res[i-1]+1\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                res[i] = res[i-1]+1;\\n            }\\n        }\\n        \\n        System.out.println(Arrays.toString(res));\\n        // Right to left scan and check whether raings[i]>ratings[i+1] if yes then check whether res[i]<=res[i+1] \\n        //inc by res[i+1]+1\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                if(res[i]<=res[i+1]){\\n                    res[i] = res[i+1]+1;\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            cnt+=res[i];\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] res = new int[n];\\n        Arrays.fill(res,1);\\n        //Left to right scan and check whether ratings[i]>ratings[i-1] if yes then increment by res[i-1]+1\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                res[i] = res[i-1]+1;\\n            }\\n        }\\n        \\n        System.out.println(Arrays.toString(res));\\n        // Right to left scan and check whether raings[i]>ratings[i+1] if yes then check whether res[i]<=res[i+1] \\n        //inc by res[i+1]+1\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                if(res[i]<=res[i+1]){\\n                    res[i] = res[i+1]+1;\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            cnt+=res[i];\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016949,
                "title": "java-one-pass-o-1-space-4-line-solution",
                "content": "The general idea of one-pass solution with constant space is to use a few variables (rather than an array) to keep track of \"how many candies are needed\" in each section (with the same trend of fluctuation) and to reset these variables at good timing (when the trend changes).\\n\\nThe main logic consist of only 4 lines of code, dealing with the increasing trend, the stable trend, the decreasing trend and the compensation settlement, respectively.\\n\\n**case 1: increasing trend**\\nIf the current kid\\'s rating is higher than its preceding term: we increment `inc` and add it to `sum`. A simple explanation is that if this kid\\'s rating is higher than the preceding one, he/she should be assigned one more candy.\\n\\n**case 2: stable trend**\\nIf the current kid\\'s has the same rating with the preceding kid: we reset `inc` to be `0`.\\n\\n**case 3: decreasing trend**\\nThis case is a bit of complicated.  We add `dec` to `sum`, then increment `dec`. After doing so, we check whether the decresing trend terminates or changes. If the current element is the last element, we say \"the trend terminates\". If the next kid\\'s rating is not less than this one, we say \"the trend changes\". In either situation, a \\'compensation settlement\\' should be processed.\\n\\nThere are two tasks in the **compensation settlement**: first, we check whether `dec` is greater than `inc`, if so, we append their difference to `sum`. That is, `if (dec > ince) sum += (dec - inc); ` Note, `inc` is not updated in the decreasing section, it holds the peak value at the top of this downward slope. That\\'s why we compare `inc` and `dec` and update `sum`. The second task is to reset `inc` and `dec` to `0`.\\n\\nThe following code combines these two tasks in one statement (which is not very readable yet makes the whole code block more \\'compressed\\').\\n\\n```\\npublic int candy(int[] kid) {\\n  int sum = kid.length;\\n  int inc = 0;\\n  int dec = 0;\\n  \\n  for (int i = 1; i < kid.length; ++i) {\\n    if (kid[i - 1] < kid[i]) {\\n\\t  sum += (++inc);\\n\\t}\\n\\telse if (kid[i - 1] == kid[i]) {\\n\\t  inc = 0;\\n\\t}\\n\\telse {\\n\\t  sum += (dec++);\\n      // compensation settlement\\n\\t  if (i + 1 == kid.length || kid[i] <= kid[i + 1])\\n\\t    sum += Math.max(dec - inc, dec = inc = 0);\\n\\t}\\n  }\\n  return sum;\\n}\\n```\\n\\n\\n**Supplements:**\\n1. `sum` is initialized with the value of `kid.length`, which means that we already give each kid at least one candy.\\n\\n2. why the default value of `inc` and `dec` are `0`\\'s and why `sum` is updated in the form `(++inc)` and `(dec++)`? A simple explanation is that they (initial values and updating logic) are not fixed, however, they need to be consistent with each other (and other conditions). By comparing different initial values and corresponding update statements, I think the following code is concisest. You can, say, set the default value of `inc` to be `1` or set the default value of `dec` to be `-1`, etc. Yet, if so, you need also to adjust your code. \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int candy(int[] kid) {\\n  int sum = kid.length;\\n  int inc = 0;\\n  int dec = 0;\\n  \\n  for (int i = 1; i < kid.length; ++i) {\\n    if (kid[i - 1] < kid[i]) {\\n\\t  sum += (++inc);\\n\\t}\\n\\telse if (kid[i - 1] == kid[i]) {\\n\\t  inc = 0;\\n\\t}\\n\\telse {\\n\\t  sum += (dec++);\\n      // compensation settlement\\n\\t  if (i + 1 == kid.length || kid[i] <= kid[i + 1])\\n\\t    sum += Math.max(dec - inc, dec = inc = 0);\\n\\t}\\n  }\\n  return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172118,
                "title": "python-simple-10-line-two-passes-solution-with-explanation",
                "content": "1. Scan the ratings forward, comparing ratings[i] to ratings[i-1]. candies[i] = candies[i-1] + 1 if rating is larger than the previous neighbor. After this pass, we know each child gets more candies to its left neighbor if the rating is higher.\\n2. Scan the ratings backward, comparing ratings[i] to ratings[i+1]. Update candies if candies[i+1] > candies[i] and ratings[i] < ratings[i+1]. Because we have detected an inversion in the number of candies, we have to increment candies[i] to candies[i+1] + 1. After the second pass, we maintain the order from first pass and also make sure each child gets more candies to its right neighbor if the rating is higher. \\n3. Return total candies\\n```\\nclass Solution(object):\\n    def candy(self, ratings):\\n        \"\"\"\\n        :type ratings: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if ratings == []:\\n            return 0\\n        \\n        candies = [1] * len(ratings)\\n        \\n        for i in range(1, len(ratings)):\\n            if ratings[i] > ratings[i-1]:\\n                candies[i] = candies[i-1] + 1\\n                \\n        for i in range(len(ratings)-2, -1, -1):\\n            if ratings[i] > ratings[i+1] and candies[i] <= candies[i+1]:\\n                candies[i] = candies[i+1] + 1\\n        \\n        return sum(candies)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def candy(self, ratings):\\n        \"\"\"\\n        :type ratings: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if ratings == []:\\n            return 0\\n        \\n        candies = [1] * len(ratings)\\n        \\n        for i in range(1, len(ratings)):\\n            if ratings[i] > ratings[i-1]:\\n                candies[i] = candies[i-1] + 1\\n                \\n        for i in range(len(ratings)-2, -1, -1):\\n            if ratings[i] > ratings[i+1] and candies[i] <= candies[i+1]:\\n                candies[i] = candies[i+1] + 1\\n        \\n        return sum(candies)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42954,
                "title": "my-accepted-solution-is-quite-neat-but-not-sure-if-can-further-optimize-it",
                "content": "    public class Solution {\\n        public int candy(int[] ratings) {\\n    \\n            if(ratings.length < 2) return ratings.length;\\n            int[] leftTrav = new int[ratings.length];\\n            int[] rightTrav = new int[ratings.length];\\n            for(int i=0; i<length; i++) {\\n                leftTrav[i] = 1;\\n                rightTrav[i] = 1;\\n            }\\n            \\n            for(int i=0; i<length - 1; i++) {\\n                int j = (length - 1) - i;\\n                if(ratings[i+1] > ratings[i]) leftTrav[i+1] = leftTrav[i] + 1;\\n                if(ratings[j-1] > ratings[j]) rightTrav[j-1] = rightTrav[j] + 1;\\n            }\\n            int total = 0;\\n            for(int i=0; i<length; i++) total += Math.max(leftTrav[i], rightTrav[i]);\\n            return total;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int candy(int[] ratings) {\\n    \\n            if(ratings.length < 2) return ratings.length;\\n            int[] leftTrav = new int[ratings.length];\\n            int[] rightTrav = new int[ratings.length];\\n            for(int i=0; i<length; i++) {\\n                leftTrav[i] = 1;\\n                rightTrav[i] = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4040520,
                "title": "greedy-c-java-python-commented-code",
                "content": "# Intuition && approach\\n<!--  -->\\nThe first step is to create a vector of integers called candies with the same size as the ratings array. Each element of candies will store the number of candies that the corresponding child should get. We initialize all elements of candies to 1.\\n\\nIn the next step, we iterate through the ratings array from left to right. For each child, we check if its rating is higher than the rating of its left neighbor. If so, we update the value of candies[i] to candies[i-1] + 1. This is because a child with a higher rating should get more candies than its neighbor.\\n\\nWe also iterate through the ratings array from right to left. For each child, we check if its rating is higher than the rating of its right neighbor. If so, we update the value of candies[i] to the maximum of candies[i] and candies[i+1] + 1. This is because a child with a higher rating should never get fewer candies than its neighbor.\\n\\nFinally, we iterate through the candies array and add up all the elements. This gives us the total number of candies that we need to distribute.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\nThe time complexity of this solution is O(n), where n is the number of children. This is because we iterate through the ratings array twice.\\n- Space complexity:O(n)\\nThe space complexity of this solution is O(n), where n is the number of children. This is because we create a vector of size n to store the number of candies for each child.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> candies(n, 1);\\n\\n        // Iterate from left to right and update candies[i] if ratings[i] > ratings[i - 1].\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        // Iterate from right to left and update candies[i] to the maximum of candies[i] and candies[i + 1] + 1.\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {\\n                candies[i] = candies[i + 1] + 1;\\n            }\\n        }\\n\\n        // Calculate the total number of candies.\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            total += candies[i];\\n        }\\n\\n        return total;\\n    }\\n};\\n\\n```\\n```\\n//java code \\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, 1);\\n\\n        // Iterate from left to right and update dp[i] if ratings[i] > ratings[i - 1].\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                dp[i] = dp[i - 1] + 1;\\n            }\\n        }\\n\\n        // Iterate from right to left and update dp[i] to the maximum of dp[i] and dp[i + 1] + 1.\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                dp[i] = Math.max(dp[i], dp[i + 1] + 1);\\n            }\\n        }\\n\\n        // Calculate the total number of candies.\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            total += dp[i];\\n        }\\n\\n        return total;\\n    }\\n}\\n```\\n```\\n//python code\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        dp = [1] * n\\n\\n        # Iterate from left to right and update dp[i] if ratings[i] > ratings[i - 1].\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i - 1]:\\n                dp[i] = dp[i - 1] + 1\\n\\n        # Iterate from right to left and update dp[i] to the maximum of dp[i] and dp[i + 1] + 1.\\n        for i in range(n - 2, -1, -1):\\n            if ratings[i] > ratings[i + 1]:\\n                dp[i] = max(dp[i], dp[i + 1] + 1)\\n\\n        # Calculate the total number of candies.\\n        total = sum(dp)\\n\\n        return total\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> candies(n, 1);\\n\\n        // Iterate from left to right and update candies[i] if ratings[i] > ratings[i - 1].\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n\\n        // Iterate from right to left and update candies[i] to the maximum of candies[i] and candies[i + 1] + 1.\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {\\n                candies[i] = candies[i + 1] + 1;\\n            }\\n        }\\n\\n        // Calculate the total number of candies.\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            total += candies[i];\\n        }\\n\\n        return total;\\n    }\\n};\\n\\n```\n```\\n//java code \\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, 1);\\n\\n        // Iterate from left to right and update dp[i] if ratings[i] > ratings[i - 1].\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                dp[i] = dp[i - 1] + 1;\\n            }\\n        }\\n\\n        // Iterate from right to left and update dp[i] to the maximum of dp[i] and dp[i + 1] + 1.\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                dp[i] = Math.max(dp[i], dp[i + 1] + 1);\\n            }\\n        }\\n\\n        // Calculate the total number of candies.\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            total += dp[i];\\n        }\\n\\n        return total;\\n    }\\n}\\n```\n```\\n//python code\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        dp = [1] * n\\n\\n        # Iterate from left to right and update dp[i] if ratings[i] > ratings[i - 1].\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i - 1]:\\n                dp[i] = dp[i - 1] + 1\\n\\n        # Iterate from right to left and update dp[i] to the maximum of dp[i] and dp[i + 1] + 1.\\n        for i in range(n - 2, -1, -1):\\n            if ratings[i] > ratings[i + 1]:\\n                dp[i] = max(dp[i], dp[i + 1] + 1)\\n\\n        # Calculate the total number of candies.\\n        total = sum(dp)\\n\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039128,
                "title": "simple-approach-always-for-you",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*We distribute candies in two passes, ```left-to-right and right-to-left```, ensuring higher-rated children get more while meeting constraints. This approach maintains two arrays (`left` and `right`) to guarantee maximum candies for each child, satisfying both the \"at least one candy\" and \"higher than neighbors\" constraints. It minimizes the total number of candies needed.*\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n*Step-1 -> Create arrays ```left``` and ```right``` filled with 1\\'s for initial candies.\\nStep-2 -> Traverse ratings ```left to right``` and check if ```current > previous rating if so add a candy to previous``` , incrementing left for higher ratings.\\nStep-3 -> Traverse ratings ```right to left``` and check if ```current rating > next if so add a candy to next```, incrementing right for higher ratings.\\nStep-4 -> Initialize totalCandies to 0.\\nStep-5 -> Iterate arrays, adding ```max of left and right``` to totalCandies.\\nStep-6 -> Return ```totalCandies``` as the minimum total candies needed.*\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] left = new int[n];\\n        Arrays.fill(left,1);\\n        for(int i=1; i<n; i++){\\n            if(ratings[i] > ratings[i-1]) left[i] = left[i-1]+1;      \\n        }\\n        int[] right = new int[n];\\n        Arrays.fill(right,1);\\n        for(int i=n-2; i>=0; i--){\\n            if(ratings[i] > ratings[i+1]) right[i] = right[i+1]+1;\\n        }\\n        int totalCandies = 0;\\n        for(int i=0; i<n; i++){\\n            totalCandies += Math.max(left[i],right[i]);\\n        }\\n        return totalCandies;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```left-to-right and right-to-left```\n```left```\n```right```\n```left to right```\n```current > previous rating if so add a candy to previous```\n```right to left```\n```current rating > next if so add a candy to next```\n```max of left and right```\n```totalCandies```\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] left = new int[n];\\n        Arrays.fill(left,1);\\n        for(int i=1; i<n; i++){\\n            if(ratings[i] > ratings[i-1]) left[i] = left[i-1]+1;      \\n        }\\n        int[] right = new int[n];\\n        Arrays.fill(right,1);\\n        for(int i=n-2; i>=0; i--){\\n            if(ratings[i] > ratings[i+1]) right[i] = right[i+1]+1;\\n        }\\n        int totalCandies = 0;\\n        for(int i=0; i<n; i++){\\n            totalCandies += Math.max(left[i],right[i]);\\n        }\\n        return totalCandies;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038470,
                "title": "simple-java-solution-leftcandyarray-rightcandyarray",
                "content": "# Intuition\\nSimple Left Max Array and Right Max Array\\n\\n# Approach\\n1.First consider at any cost you will distrubute one candy to every child, so take left Max Array and store 1 in every index.\\n2.Next you start traversing from i=1 to N-1 and checking if the rating of before is greater than current if so you add one to the current.\\n\\nKeep in Mind that he said both the neighbhours not a single side, so we do the same for right Max Array also\\n\\nAt last we need to take max of both such that if we pick an index i then for sure if his rating is greater than his neighbours he will be getting more chocolates.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n      int N = ratings.length;\\n         int[] leftCandy = new int[N];\\n        int[] rightCandy=new int[N];\\n        Arrays.fill(leftCandy,1);\\n        Arrays.fill(rightCandy,1);\\n        for(int i=1;i<N;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                leftCandy[i]=leftCandy[i-1]+1;\\n            }\\n        }\\n        for(int i=N-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                rightCandy[i]=rightCandy[i+1]+1;\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<N;i++){\\n            res+=Math.max(leftCandy[i],rightCandy[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n      int N = ratings.length;\\n         int[] leftCandy = new int[N];\\n        int[] rightCandy=new int[N];\\n        Arrays.fill(leftCandy,1);\\n        Arrays.fill(rightCandy,1);\\n        for(int i=1;i<N;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                leftCandy[i]=leftCandy[i-1]+1;\\n            }\\n        }\\n        for(int i=N-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                rightCandy[i]=rightCandy[i+1]+1;\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<N;i++){\\n            res+=Math.max(leftCandy[i],rightCandy[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813440,
                "title": "o-n-solution-with-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& r) {\\n        int n=r.size();\\n        vector<int>c(n,1);\\n        //0 1 2 1 3\\n        if(n==1)return 1;\\n        if(r[0]>r[1])c[0]=2;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(r[i]>r[i-1] )\\n            {\\n                c[i]+=c[i-1];\\n            }\\n           \\n        }\\n        \\n         for(int i=n-2;i>=0;i--)\\n        {\\n            if(r[i]>r[i+1] && c[i]<=c[i+1] )\\n            {\\n                c[i]=max(c[i],c[i+1]+1);\\n            }\\n           \\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n          ans+=c[i];\\n         \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& r) {\\n        int n=r.size();\\n        vector<int>c(n,1);\\n        //0 1 2 1 3\\n        if(n==1)return 1;\\n        if(r[0]>r[1])c[0]=2;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(r[i]>r[i-1] )\\n            {\\n                c[i]+=c[i-1];\\n            }\\n           \\n        }\\n        \\n         for(int i=n-2;i>=0;i--)\\n        {\\n            if(r[i]>r[i+1] && c[i]<=c[i+1] )\\n            {\\n                c[i]=max(c[i],c[i+1]+1);\\n            }\\n           \\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n          ans+=c[i];\\n         \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782563,
                "title": "super-simple-solution",
                "content": "# Intuition:\\nThe approach to solving this problem involves using the concept of two passes. In the first pass, we scan the ratings from left to right and assign candies to each child based on the increasing ratings from left to right. In the second pass, we scan the ratings from right to left and adjust the candies assigned based on the increasing ratings from right to left. The idea is to ensure that each child gets at least one candy and children with higher ratings get more candies than their neighbors.\\n\\n# Algorithm:\\n\\nInitialize an array left of size n+1 to store the number of candies assigned to each child based on the increasing ratings from left to right. Set all elements of left to 1, as each child must have at least one candy.\\nPerform the first pass (left to right) over the ratings array and update the left array as follows:\\na. If the rating of the current child ratings[i] is greater than the rating of the previous child ratings[i-1], assign one more candy than the previous child to the current child (i.e., left[i] = left[i-1] + 1).\\nInitialize a variable right to 1, which will be used to keep track of the candies for the second pass (right to left).\\nPerform the second pass (right to left) over the ratings array and update the left array as follows:\\na. If the rating of the current child ratings[i] is greater than the rating of the next child ratings[i+1], we increment the right variable by 1.\\nb. We then update the number of candies for the current child by taking the maximum between the current value in the left array and the value of right. This step ensures that we consider both the left-to-right and right-to-left information while assigning candies.\\nAfter both passes are completed, sum up all the elements in the left array to get the minimum number of candies needed to satisfy the requirements.\\nComplexity Analysis:\\n\\n# Time Complexity:\\n The algorithm performs two passes through the ratings array, which takes O(n) time, where n is the number of children.\\n# Space Complexity:\\n The algorithm uses a left array of size n+1 to store the candies assigned to each child, which takes O(n) extra space.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n      vector<int> left(n+1,1);\\n      for(int i=1;i<n;i++){\\n          if(ratings[i]>ratings[i-1]) left[i]=left[i-1]+1;\\n      }  \\n\\n      int right=1;\\n      for(int i=n-2;i>=0;i--){\\n          if(ratings[i]>ratings[i+1]){\\n            right++;\\n            left[i]=max(left[i],right);\\n          }else right=1;\\n      }\\n\\n      int sum=0;\\n      for(int i=0;i<n;i++){\\n            sum+=left[i];\\n      }\\n      return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n      vector<int> left(n+1,1);\\n      for(int i=1;i<n;i++){\\n          if(ratings[i]>ratings[i-1]) left[i]=left[i-1]+1;\\n      }  \\n\\n      int right=1;\\n      for(int i=n-2;i>=0;i--){\\n          if(ratings[i]>ratings[i+1]){\\n            right++;\\n            left[i]=max(left[i],right);\\n          }else right=1;\\n      }\\n\\n      int sum=0;\\n      for(int i=0;i<n;i++){\\n            sum+=left[i];\\n      }\\n      return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649454,
                "title": "easy-c-solution-t-c-o-n-s-c-o-n",
                "content": "**Up vote if found useful**\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int> l (ratings.size(),1);\\n        vector<int> r (ratings.size(),1);\\n\\n        for(int i=1; i<ratings.size(); i++){\\n            if(ratings[i]>ratings[i-1]){\\n                l[i]=l[i-1]+1;\\n            }\\n        }\\n\\n        for(int i = ratings.size()-2; i>=0; i--){\\n            if(ratings[i+1]<ratings[i]){\\n                r[i]= r[i+1]+1;\\n            }\\n        }\\n        \\n        int sum =0;\\n        for(int i=0; i<ratings.size();i++){\\n            sum+=max(l[i],r[i]);\\n        }\\n\\n        return sum;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int> l (ratings.size(),1);\\n        vector<int> r (ratings.size(),1);\\n\\n        for(int i=1; i<ratings.size(); i++){\\n            if(ratings[i]>ratings[i-1]){\\n                l[i]=l[i-1]+1;\\n            }\\n        }\\n\\n        for(int i = ratings.size()-2; i>=0; i--){\\n            if(ratings[i+1]<ratings[i]){\\n                r[i]= r[i+1]+1;\\n            }\\n        }\\n        \\n        int sum =0;\\n        for(int i=0; i<ratings.size();i++){\\n            sum+=max(l[i],r[i]);\\n        }\\n\\n        return sum;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564844,
                "title": "using-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<vector<int>> v;//make vector for store element of rating with index and want get fist minimum rating element and give him minimum candy 1\\n        for(int i = 0; i < ratings.size(); i++){\\n            v.push_back({ratings[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        int n = ratings.size(),x = 0, k= 0;\\n        vector<int> ans(n,0);\\n        for(auto &i: v){\\n            x = 0;\\n            if(i[1]-1>=0&&ratings[i[1]]>ratings[i[1]-1]){//if ith index person have rating >= left person than he desirve more candy compare to left\\n                x = max(x,ans[i[1]-1]);\\n            }\\n            if(i[1]+1 < n&&ratings[i[1]]>ratings[i[1]+1]){//same for right.\\n                x = max(x,ans[i[1]+1]);\\n            }\\n            ans[i[1]] = x+1;//how much candy ith person get\\n            k += x+1;//total candy allocated\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<vector<int>> v;//make vector for store element of rating with index and want get fist minimum rating element and give him minimum candy 1\\n        for(int i = 0; i < ratings.size(); i++){\\n            v.push_back({ratings[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        int n = ratings.size(),x = 0, k= 0;\\n        vector<int> ans(n,0);\\n        for(auto &i: v){\\n            x = 0;\\n            if(i[1]-1>=0&&ratings[i[1]]>ratings[i[1]-1]){//if ith index person have rating >= left person than he desirve more candy compare to left\\n                x = max(x,ans[i[1]-1]);\\n            }\\n            if(i[1]+1 < n&&ratings[i[1]]>ratings[i[1]+1]){//same for right.\\n                x = max(x,ans[i[1]+1]);\\n            }\\n            ans[i[1]] = x+1;//how much candy ith person get\\n            k += x+1;//total candy allocated\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316575,
                "title": "c-90-faster-easy-and-clean-with-best-explanation",
                "content": "# Intuition\\nWe can divide this problem into 3 sub parts, that is\\n1) Incresing sequence\\n2) Decresing sequence\\n3) Sequence with same elements\\n\\nFor example:\\nSequence A with ratings - [1, 5, 10, 15, 20]\\nwe will assign candies optimisely as [1, 2, 3, 4, 5]\\n\\nSequence B with ratings - [10, 5, 3, 2, 1]\\nAssign candies as [5, 4, 3, 2, 1]\\n\\nSequence C with ratings - [5, 5, 5, 5]\\nAssign candies as [1, 1, 1, 1]\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int> count(ratings.size(), 1);\\n\\n        int i=0, j=0;\\n        while(j < ratings.size()-1){\\n            if(ratings[j] < ratings[j+1]){\\n                while(j < ratings.size()-1 && ratings[j] < ratings[j+1]){\\n                    j++;\\n                }\\n\\n                int num = 1;\\n\\n                for(int k=i; k<=j; k++){\\n                    count[k] = max(count[k], num);\\n                    num++;\\n                }\\n\\n                i = j;\\n            }\\n            else if(ratings[j] > ratings[j+1]){\\n                while(j < ratings.size()-1 && ratings[j] > ratings[j+1]){\\n                    j++;\\n                }\\n\\n                int num = 1;\\n\\n                for(int k=j; k>=i; k--){\\n                    count[k] = max(count[k], num);\\n                    num++;\\n                }\\n\\n                i = j;\\n            }\\n            else{\\n                while(j < ratings.size()-1 && ratings[j] == ratings[j+1]){\\n                    j++;\\n                }\\n\\n                i = j;\\n            }\\n        }\\n        \\n\\n        int ans = 0;\\n        for(auto i : count){\\n            ans += i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int> count(ratings.size(), 1);\\n\\n        int i=0, j=0;\\n        while(j < ratings.size()-1){\\n            if(ratings[j] < ratings[j+1]){\\n                while(j < ratings.size()-1 && ratings[j] < ratings[j+1]){\\n                    j++;\\n                }\\n\\n                int num = 1;\\n\\n                for(int k=i; k<=j; k++){\\n                    count[k] = max(count[k], num);\\n                    num++;\\n                }\\n\\n                i = j;\\n            }\\n            else if(ratings[j] > ratings[j+1]){\\n                while(j < ratings.size()-1 && ratings[j] > ratings[j+1]){\\n                    j++;\\n                }\\n\\n                int num = 1;\\n\\n                for(int k=j; k>=i; k--){\\n                    count[k] = max(count[k], num);\\n                    num++;\\n                }\\n\\n                i = j;\\n            }\\n            else{\\n                while(j < ratings.size()-1 && ratings[j] == ratings[j+1]){\\n                    j++;\\n                }\\n\\n                i = j;\\n            }\\n        }\\n        \\n\\n        int ans = 0;\\n        for(auto i : count){\\n            ans += i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029049,
                "title": "my-very-first-solution-contribution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy very first solution contribution, based on my Python solution\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInstead of using loop twice, to solve 3 cases happened between ratings[i] and ratings[i-1]:\\n- ratings[i]==ratings[i-1]: new start, because no condition\\n- ratings[i]>ratings[i-1]: increase, and record the maximum\\n- ratings[i]<ratings[i-1]: add 1 at new position, but be careful for the violation:\\n    a. The candies from previous maximum index to the i-1th should increase by 1 to maintain the relation\\n    b. The candies from 1+previous maximum index should increase by 1.\\nI created 3 variables for curr candy (val), index of previous \\'peak\\' (maxIdx) and number of candies at the previous peak (maxVal)\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int Candy(int[] ratings) {\\n        int maxVal = 1;\\n        int val = 1;\\n        int ans = 1;\\n        int maxIdx = 0;\\n        for(int i = 1; i<ratings.Length;i++){\\n            if(ratings[i]> ratings[i-1]){\\n                ++val;\\n                ans += val;\\n                maxIdx = i;\\n                maxVal = val;\\n            }\\n            else if(ratings[i] < ratings[i-1]) {\\n                val = 1;\\n                ans+= i - maxIdx;\\n                if (i - maxIdx == maxVal) {\\n                    maxVal+=1;\\n                    ans+=1;\\n                }\\n            }\\n            else {\\n                maxVal = 1;\\n                val =1;\\n                maxIdx = i;\\n                ans +=1;\\n            }\\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int Candy(int[] ratings) {\\n        int maxVal = 1;\\n        int val = 1;\\n        int ans = 1;\\n        int maxIdx = 0;\\n        for(int i = 1; i<ratings.Length;i++){\\n            if(ratings[i]> ratings[i-1]){\\n                ++val;\\n                ans += val;\\n                maxIdx = i;\\n                maxVal = val;\\n            }\\n            else if(ratings[i] < ratings[i-1]) {\\n                val = 1;\\n                ans+= i - maxIdx;\\n                if (i - maxIdx == maxVal) {\\n                    maxVal+=1;\\n                    ans+=1;\\n                }\\n            }\\n            else {\\n                maxVal = 1;\\n                val =1;\\n                maxIdx = i;\\n                ans +=1;\\n            }\\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641180,
                "title": "solution-using-multi-source-bfs-idk-why",
                "content": "Approach: \\n1) Start with the positions that are smaller than both their neighbors and add this to a set.\\n2) Then loop until this set has elements and for each iteration add the neighbor for the positions in the set that have a higher rating. At each iteration the number of candies for a position increments by 1 (shown in code by variable curr). \\n```\\nclass Solution(object):\\n    def candy(self, ratings):\\n        \"\"\"\\n        :type ratings: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(ratings)\\n        if n == 1:\\n            return 1\\n        \\n\\t\\t#stores the elements that are smaller than both its neighbors\\n        s = set()\\n        \\n        if ratings[0] <= ratings[1]:\\n            s.add(0) # first position\\n            \\n        if ratings[n-1] <= ratings[n-2]:\\n            s.add(n-1) # last position \\n        \\n        for i in range(1, n-1):\\n            if ratings[i] <= ratings[i-1] and ratings[i] <= ratings[i+1]:\\n                s.add(i) # everything in between\\n  \\n        curr = 0\\n        count = [1] * n # start with everyone having one candy\\n        \\n        while s:\\n            curr += 1\\n            ns = set()\\n            \\n            for i in s:\\n                count[i] = curr\\n                if i != 0 and ratings[i-1] > ratings[i]:\\n                    ns.add(i-1) # add left neighbor if it is greater\\n                if i != n-1 and ratings[i+1] > ratings[i]:\\n                    ns.add(i+1) # add right neighbor if it is greater\\n            s = ns\\n            \\n        return sum(count)```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def candy(self, ratings):\\n        \"\"\"\\n        :type ratings: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(ratings)\\n        if n == 1:\\n            return 1\\n        \\n\\t\\t#stores the elements that are smaller than both its neighbors\\n        s = set()\\n        \\n        if ratings[0] <= ratings[1]:\\n            s.add(0) # first position\\n            \\n        if ratings[n-1] <= ratings[n-2]:\\n            s.add(n-1) # last position \\n        \\n        for i in range(1, n-1):\\n            if ratings[i] <= ratings[i-1] and ratings[i] <= ratings[i+1]:\\n                s.add(i) # everything in between\\n  \\n        curr = 0\\n        count = [1] * n # start with everyone having one candy\\n        \\n        while s:\\n            curr += 1\\n            ns = set()\\n            \\n            for i in s:\\n                count[i] = curr\\n                if i != 0 and ratings[i-1] > ratings[i]:\\n                    ns.add(i-1) # add left neighbor if it is greater\\n                if i != n-1 and ratings[i+1] > ratings[i]:\\n                    ns.add(i+1) # add right neighbor if it is greater\\n            s = ns\\n            \\n        return sum(count)```",
                "codeTag": "Java"
            },
            {
                "id": 2237293,
                "title": "c-yt-link-easy-explanation",
                "content": "https://www.youtube.com/watch?v=PzBYQA6FshA\\n\\n\\tc++ code\\n\\t\\n\\t\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint candy(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<int> left(n, 1);\\n\\t\\t\\tvector<int> right(n, 1);\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]>nums[i-1])left[i]=left[i-1]+1;\\n\\t\\t\\t}\\n\\t\\t\\t for(int i=n-2;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]>nums[i+1])right[i]=right[i+1]+1;\\n\\t\\t\\t}       \\n\\t\\t\\tint s=0;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t   s+=max(left[i],right[i]);\\n\\t\\t\\t}\\n\\t\\t   return s;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint candy(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<int> left(n, 1);\\n\\t\\t\\tvector<int> right(n, 1);\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]>nums[i-1])left[i]=left[i-1]+1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2235576,
                "title": "very-easy-c-sol-o-n-sol-using-single-array",
                "content": "int n=nums.size();\\n        \\n        vector<int>ans(n,1);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>nums[i-1] )\\n            {\\n                ans[i]=ans[i-1]+1;\\n                \\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]>nums[i+1] and ans[i]<=ans[i+1])\\n            {\\n                ans[i]=ans[i+1]+1;\\n            }\\n        }\\n        int sum=0;\\n        for(auto itr:ans)\\n        {\\n            sum+=itr;\\n        }\\n        \\n        return sum;",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Greedy"
                ],
                "code": "int n=nums.size();\\n        \\n        vector<int>ans(n,1);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>nums[i-1] )\\n            {\\n                ans[i]=ans[i-1]+1;\\n                \\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]>nums[i+1] and ans[i]<=ans[i+1])\\n            {\\n                ans[i]=ans[i+1]+1;\\n            }\\n        }\\n        int sum=0;\\n        for(auto itr:ans)\\n        {\\n            sum+=itr;\\n        }\\n        \\n        return sum;",
                "codeTag": "Unknown"
            },
            {
                "id": 2235548,
                "title": "easy-to-understand-solution-with-explanation",
                "content": "## **Problem**: \\nWe are given a vector of integer, ratings which contain ratings of \\'n\\' children standing in a line. We have to distribute candies to these children such that the total number of candies distributed are minimum. We have to consider the following conditions while distributing:\\n* Each child must recieve atleast 1 candy.\\n* The child with higher rating than his neighbours, must recieve more candies than them.\\n\\n## **Approach**:\\nWe will take a vector of integer, candies, of size \\'n\\' and initialize all values with \\'1\\'. Then we would check whether the size of ratings, i.e., the number of children is less than or equal to 1, in which case, we would return the size itself.\\n\\nThen we will run a loop from 1 till n, where we will check if the rating of the current child is greater than the previous one, if yes, we would set the value of candies with the child as 1 more than the candies with the previous one.\\n\\nWe would then run a loop from n-1, i.e., the last child till i is greater than 0, and we would check if the previous, i.e., i-1 has more rating than i, then we would set value of i-1th one as, the maximum of increment of ith one and his own candies.\\n\\nFinally, we have assigned the candies to be distributed to each child, now we would just run an iteration for each child and add the number of candies to total number of candies.\\n\\nAnd we will return the total candies.\\n\\n## **Solution**:\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size(); //total number of children\\n        int totalcandies = 0; //set total candies as 0\\n        \\n        if(n<=1) //check if the number of children are 1 or less\\n            return n;\\n        \\n        vector<int> candies(n,1); // initialize a vector candies with 1 of size n\\n        for(int i=1;i<n;i++)\\n            if(ratings[i]>ratings[i-1]) //if the current child\\'s rating is more than the previous one\\n                candies[i]=candies[i-1]+1; //set his candies as 1 more than the previous one\\n        \\n        for(int i=n-1;i>0;i--)\\n            if(ratings[i-1]>ratings[i]) //if the i-1th child has more rating than ith one\\n                candies[i-1]=max(candies[i-1],candies[i]+1); //set the i-1th candies as maximum of his own and 1 more than the previous one\\n        \\n        for(int i=0;i<n;i++)\\n            totalcandies+=candies[i]; //add each child\\'s number of candies to the total\\n        \\n        return totalcandies; //return the total number of candies\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size(); //total number of children\\n        int totalcandies = 0; //set total candies as 0\\n        \\n        if(n<=1) //check if the number of children are 1 or less\\n            return n;\\n        \\n        vector<int> candies(n,1); // initialize a vector candies with 1 of size n\\n        for(int i=1;i<n;i++)\\n            if(ratings[i]>ratings[i-1]) //if the current child\\'s rating is more than the previous one\\n                candies[i]=candies[i-1]+1; //set his candies as 1 more than the previous one\\n        \\n        for(int i=n-1;i>0;i--)\\n            if(ratings[i-1]>ratings[i]) //if the i-1th child has more rating than ith one\\n                candies[i-1]=max(candies[i-1],candies[i]+1); //set the i-1th candies as maximum of his own and 1 more than the previous one\\n        \\n        for(int i=0;i<n;i++)\\n            totalcandies+=candies[i]; //add each child\\'s number of candies to the total\\n        \\n        return totalcandies; //return the total number of candies\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235182,
                "title": "c-o-n-time-o-n-space-easy-brute-force-solution-with-explanation",
                "content": "1. traverse towards towards left-right then towards right-left\\n 2. if not understood why dry run this testcase once 1 2 87 87 87 2 1\\n```\\nint candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        if(n==1) return 1;\\n        vector<int> ans(n,1);\\n        //firsly traverse owards right\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==0 && ratings[i]>ratings[i+1])\\n            {\\n                ans[i]=ans[i+1]+1;\\n            }\\n            else if(i>0 && i<n-1)\\n            {\\n                if(ratings[i]>ratings[i-1] && ratings[i]>ratings[i+1])\\n                {\\n                    ans[i]=max(ans[i+1],ans[i-1])+1;\\n                }\\n                else if(ratings[i]>ratings[i-1])\\n                {\\n                    ans[i]=ans[i-1]+1;\\n                }\\n                else if(ratings[i]>ratings[i+1] )\\n                {\\n                    ans[i]=ans[i+1]+1;\\n                }\\n            }\\n            else if(i==n-1)\\n            {\\n                if(ratings[i]>ratings[i-1])\\n                {\\n                    ans[i]=ans[i-1]+1;\\n                }\\n            }\\n        }\\n        \\n\\t\\t//then traverse towards left\\n\\t\\t\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i==0 && ratings[i]>ratings[i+1])\\n            {\\n                ans[i]=ans[i+1]+1;\\n            }\\n            else if(i>0 && i<n-1)\\n            {\\n                if(ratings[i]>ratings[i-1] && ratings[i]>ratings[i+1])\\n                {\\n                    ans[i]=max(ans[i+1],ans[i-1])+1;\\n                }\\n                else if(ratings[i]>ratings[i-1])\\n                {\\n                    ans[i]=ans[i-1]+1;\\n                }\\n                else if(ratings[i]>ratings[i+1] )\\n                {\\n                    ans[i]=ans[i+1]+1;\\n                }\\n            }\\n            else if(i==n-1)\\n            {\\n                if(ratings[i]>ratings[i-1])\\n                {\\n                    ans[i]=ans[i-1]+1;\\n                }\\n            }\\n        }\\n       \\n       \\n        int res=accumulate(ans.begin(),ans.end(),0);\\n        return res;\\n    }\\n\\t\\t```\\n\\t\\tif you have reached there then you would have probably understood the solution , So\\n\\t\\t**upvote please**\\n\\t\\t",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nint candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        if(n==1) return 1;\\n        vector<int> ans(n,1);\\n        //firsly traverse owards right\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==0 && ratings[i]>ratings[i+1])\\n            {\\n                ans[i]=ans[i+1]+1;\\n            }\\n            else if(i>0 && i<n-1)\\n            {\\n                if(ratings[i]>ratings[i-1] && ratings[i]>ratings[i+1])\\n                {\\n                    ans[i]=max(ans[i+1],ans[i-1])+1;\\n                }\\n                else if(ratings[i]>ratings[i-1])\\n                {\\n                    ans[i]=ans[i-1]+1;\\n                }\\n                else if(ratings[i]>ratings[i+1] )\\n                {\\n                    ans[i]=ans[i+1]+1;\\n                }\\n            }\\n            else if(i==n-1)\\n            {\\n                if(ratings[i]>ratings[i-1])\\n                {\\n                    ans[i]=ans[i-1]+1;\\n                }\\n            }\\n        }\\n        \\n\\t\\t//then traverse towards left\\n\\t\\t\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i==0 && ratings[i]>ratings[i+1])\\n            {\\n                ans[i]=ans[i+1]+1;\\n            }\\n            else if(i>0 && i<n-1)\\n            {\\n                if(ratings[i]>ratings[i-1] && ratings[i]>ratings[i+1])\\n                {\\n                    ans[i]=max(ans[i+1],ans[i-1])+1;\\n                }\\n                else if(ratings[i]>ratings[i-1])\\n                {\\n                    ans[i]=ans[i-1]+1;\\n                }\\n                else if(ratings[i]>ratings[i+1] )\\n                {\\n                    ans[i]=ans[i+1]+1;\\n                }\\n            }\\n            else if(i==n-1)\\n            {\\n                if(ratings[i]>ratings[i-1])\\n                {\\n                    ans[i]=ans[i-1]+1;\\n                }\\n            }\\n        }\\n       \\n       \\n        int res=accumulate(ans.begin(),ans.end(),0);\\n        return res;\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2235181,
                "title": "simple-o-n-python-solution-faster-than-99-with-explanation",
                "content": "**In Short :**\\nSplit ratings array to multi **strictly decreasing** sub ratings, and update candy with each sub ratings(suppose to be like n, n-1, ......, 2, 1) base on length and the last candy from last sub ratings .\\n\\n**Detail :**\\nWe have three cases :  current rating  (\\'>\\'  , \\'=\\'  , \\'<\\' )  last rating\\n\\nIf is greater, then we simply take last candy + 1.\\nif is equal, then we set candy to 1.\\nIf is less, then we set candy to 1, however if the last candy is also 1,  we have to update the last candy to 2, since the last rating is greater.\\nWe need to keep updating former candy to make sure higher rating get more candy. After finish all update we can find out the candy we updated is a sequence like n, n-1, ......, 2, 1 or n-1, ......, 2, 1. (depends on whether we update the head of current strictly decreasing sub ratings and n is the number of strictly decreasing sub ratings)\\n\\ntake ratings : [1,2,4,3,2,1] as example \\n\\n![image](https://assets.leetcode.com/users/images/f7cae0dd-1835-44d8-8bd1-fd98245f7315_1656912730.3116095.png)\\n![image](https://assets.leetcode.com/users/images/eacdb5d5-72b1-4318-afb5-d4dedd68953f_1656912740.543344.png)\\n![image](https://assets.leetcode.com/users/images/791024f9-503e-41fc-acb1-9af3e46b41f9_1656912749.0252995.png)\\n![image](https://assets.leetcode.com/users/images/ede5c705-b8f8-4014-9403-c8abb76a06e1_1656912758.5754123.png)\\n![image](https://assets.leetcode.com/users/images/516a20aa-43c1-43fa-a707-7da05604bde9_1656912765.297426.png)\\n\\nWe can have some observations from above.( taking sc as the start of current strictly decreasing sub ratings)\\n1. Update candy to the sc at most.\\n2. Sc\\'s candy only update if the length of strictly decreasing sub ratings is  >  Sc\\'s candy.\\n\\nSo we can maintin a stack to keep track on strictly decreasing sub ratings, and update the candy after we get a new strictly decreasing sub ratings. \\n(in fact we can calculate total candy for every sub ratings thus we can reduce space complexity to O(1))\\n\\t\\n\\tdef candy(self, ratings: List[int]) -> int:\\n        #make sure last stack is calculated \\n        ratings.append(float(\\'inf\\'))\\n\\n        #default set candy to 1\\n        candy = [1] * len(ratings)\\n\\n        #stack init with index 0\\n        stack_startindex, stack_leftcandy, stack_count  = 0, 1, 1\\n\\n        for i in range(1, len(ratings)) :\\n\\n            #if rating is greater or equal : start new stack and update candy for old stack\\n            if ratings[i] >= ratings[i-1] :\\n\\n                #set candy to n, n-1, ......, 1 in the stack\\n                if stack_count > stack_leftcandy :\\n                    for j in range(stack_startindex, i) :\\n                        candy[j] = stack_count \\n                        stack_count -= 1\\n\\n                #set candy to k(leftcandy), n, n-1, ......, 1 in the stack \\n                else :\\n                    for j in range(stack_startindex+1, i) :\\n                        candy[j] = stack_count-1 \\n                        stack_count -= 1\\n\\n                #set current candy to left + 1 if rating is greater\\n                #set current candy to 1 if rating is equal\\n                if ratings[i] > ratings[i-1] : candy[i] = candy[i-1] + 1\\n                else : candy[i] = 1\\n\\n                #init new stack start from i\\n                stack_startindex, stack_leftcandy, stack_count = i, candy[i], 1\\n\\n            #if rating is less : update stack count\\n            else : stack_count += 1\\n\\n        #sum all candy except the last one we added first\\n        return sum(candy[:-1])\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "**In Short :**\\nSplit ratings array to multi **strictly decreasing** sub ratings, and update candy with each sub ratings(suppose to be like n, n-1, ......, 2, 1) base on length and the last candy from last sub ratings .\\n\\n**Detail :**\\nWe have three cases :  current rating  (\\'>\\'  , \\'=\\'  , \\'<\\' )  last rating\\n\\nIf is greater, then we simply take last candy + 1.\\nif is equal, then we set candy to 1.\\nIf is less, then we set candy to 1, however if the last candy is also 1,  we have to update the last candy to 2, since the last rating is greater.\\nWe need to keep updating former candy to make sure higher rating get more candy. After finish all update we can find out the candy we updated is a sequence like n, n-1, ......, 2, 1 or n-1, ......, 2, 1. (depends on whether we update the head of current strictly decreasing sub ratings and n is the number of strictly decreasing sub ratings)\\n\\ntake ratings : [1,2,4,3,2,1] as example \\n\\n![image](https://assets.leetcode.com/users/images/f7cae0dd-1835-44d8-8bd1-fd98245f7315_1656912730.3116095.png)\\n![image](https://assets.leetcode.com/users/images/eacdb5d5-72b1-4318-afb5-d4dedd68953f_1656912740.543344.png)\\n![image](https://assets.leetcode.com/users/images/791024f9-503e-41fc-acb1-9af3e46b41f9_1656912749.0252995.png)\\n![image](https://assets.leetcode.com/users/images/ede5c705-b8f8-4014-9403-c8abb76a06e1_1656912758.5754123.png)\\n![image](https://assets.leetcode.com/users/images/516a20aa-43c1-43fa-a707-7da05604bde9_1656912765.297426.png)\\n\\nWe can have some observations from above.( taking sc as the start of current strictly decreasing sub ratings)\\n1. Update candy to the sc at most.\\n2. Sc\\'s candy only update if the length of strictly decreasing sub ratings is  >  Sc\\'s candy.\\n\\nSo we can maintin a stack to keep track on strictly decreasing sub ratings, and update the candy after we get a new strictly decreasing sub ratings. \\n(in fact we can calculate total candy for every sub ratings thus we can reduce space complexity to O(1))\\n\\t\\n\\tdef candy(self, ratings: List[int]) -> int:\\n        #make sure last stack is calculated \\n        ratings.append(float(\\'inf\\'))\\n\\n        #default set candy to 1\\n        candy = [1] * len(ratings)\\n\\n        #stack init with index 0\\n        stack_startindex, stack_leftcandy, stack_count  = 0, 1, 1\\n\\n        for i in range(1, len(ratings)) :\\n\\n            #if rating is greater or equal : start new stack and update candy for old stack\\n            if ratings[i] >= ratings[i-1] :\\n\\n                #set candy to n, n-1, ......, 1 in the stack\\n                if stack_count > stack_leftcandy :\\n                    for j in range(stack_startindex, i) :\\n                        candy[j] = stack_count \\n                        stack_count -= 1\\n\\n                #set candy to k(leftcandy), n, n-1, ......, 1 in the stack \\n                else :\\n                    for j in range(stack_startindex+1, i) :\\n                        candy[j] = stack_count-1 \\n                        stack_count -= 1\\n\\n                #set current candy to left + 1 if rating is greater\\n                #set current candy to 1 if rating is equal\\n                if ratings[i] > ratings[i-1] : candy[i] = candy[i-1] + 1\\n                else : candy[i] = 1\\n\\n                #init new stack start from i\\n                stack_startindex, stack_leftcandy, stack_count = i, candy[i], 1\\n\\n            #if rating is less : update stack count\\n            else : stack_count += 1\\n\\n        #sum all candy except the last one we added first\\n        return sum(candy[:-1])\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2235027,
                "title": "unique-solution-using-sorting",
                "content": "Question - \\n**You are giving candies to these children subjected to the following requirements:**\\n\\n- Each child must have at least one candy.\\n- Children with a higher rating get more candies than their neighbors.\\n\\nSo I thought, we can distribute candies to student with minimum ratings first, and if nearby childrens have candies, and they have lower rating than current student then we will take max of (1, 1 + candy on left, 1 + candy on right) for the current student\\n\\nBut you might think what if we haven\\'t yet assigned the candy to neighbor childrens??\\n- It will not happen as we are going in sorted order of rating. \\n- So, if we are at some rating **x+1** and neaby childrens have rating **x**, it would have been already filled. \\n- And if rating of nearby children is higher, then we just assign 1 candy to this student.\\n\\n```\\n    int candy(vector<int>& ratings) {\\n        vector<pair<int,int>> vec;\\n        int n = ratings.size();\\n        vec.reserve(n);\\n        \\n        for(int i = 0; i<n; i++){\\n            vec.push_back({ratings[i], i});\\n        }\\n        \\n        sort(vec.begin(), vec.end());\\n        vector<int> candy(n, 0);\\n        int ans = 0;\\n        \\n        for(int i = 0; i<n; i++){\\n            int rating = vec[i].first;\\n            int ind = vec[i].second;\\n            \\n            int candies = 1;\\n            if(ind > 0 && ratings[ind] > ratings[ind-1]){\\n                candies = max(candies, candy[ind-1] + 1);\\n            }\\n            if(ind < n-1 && ratings[ind] > ratings[ind+1]){\\n                candies = max(candies, candy[ind+1] + 1);\\n            }\\n            ans += candies;\\n            candy[ind] = candies;\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nI know there is a better complexity solution in *O(N) time*.\\nJust thought to share a different approach. :)\\n\\n\\nT.C. -> O(nlogn)\\nS.C. -> O(n)\\n\\nIf something is not understood you can comment below \\uD83D\\uDC47\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n    int candy(vector<int>& ratings) {\\n        vector<pair<int,int>> vec;\\n        int n = ratings.size();\\n        vec.reserve(n);\\n        \\n        for(int i = 0; i<n; i++){\\n            vec.push_back({ratings[i], i});\\n        }\\n        \\n        sort(vec.begin(), vec.end());\\n        vector<int> candy(n, 0);\\n        int ans = 0;\\n        \\n        for(int i = 0; i<n; i++){\\n            int rating = vec[i].first;\\n            int ind = vec[i].second;\\n            \\n            int candies = 1;\\n            if(ind > 0 && ratings[ind] > ratings[ind-1]){\\n                candies = max(candies, candy[ind-1] + 1);\\n            }\\n            if(ind < n-1 && ratings[ind] > ratings[ind+1]){\\n                candies = max(candies, candy[ind+1] + 1);\\n            }\\n            ans += candies;\\n            candy[ind] = candies;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2234593,
                "title": "4ms-java-solution-greedy-approach",
                "content": "**Time Complexity: O(N)**\\n\\n**```Java Code```**\\n\\n```\\nimport java.util.*;  \\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int size = ratings.length;\\n        int[] left = new int[size];\\n        int[] right = new int[size];\\n        left[0] = 1;\\n        right[size-1] = 1;\\n        for(int i = 1; i < size; i++){\\n            if(ratings[i] > ratings[i - 1])\\n                left[i] = left[i - 1] + 1;\\n            else \\n                left[i] = 1;\\n        }\\n        \\n        for(int i = size - 2; i >= 0; i--){\\n            if(ratings[i] > ratings[i + 1])\\n                right[i] = right[i + 1] + 1;\\n            else \\n                right[i] = 1;\\n        }\\n        \\n        int answer = 0;\\n        for(int i = 0; i < size; i++){\\n            answer+=Math.max(left[i], right[i]);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```Java Code```\n```\\nimport java.util.*;  \\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int size = ratings.length;\\n        int[] left = new int[size];\\n        int[] right = new int[size];\\n        left[0] = 1;\\n        right[size-1] = 1;\\n        for(int i = 1; i < size; i++){\\n            if(ratings[i] > ratings[i - 1])\\n                left[i] = left[i - 1] + 1;\\n            else \\n                left[i] = 1;\\n        }\\n        \\n        for(int i = size - 2; i >= 0; i--){\\n            if(ratings[i] > ratings[i + 1])\\n                right[i] = right[i + 1] + 1;\\n            else \\n                right[i] = 1;\\n        }\\n        \\n        int answer = 0;\\n        for(int i = 0; i < size; i++){\\n            answer+=Math.max(left[i], right[i]);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187052,
                "title": "simple-solution-using-min-heap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> ans(n,1);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> qe;\\n        for(int i = 0 ; i < n ; i++){\\n            qe.push({ratings[i],i});\\n        }\\n        while(!qe.empty()){\\n            auto it = qe.top();\\n            qe.pop();\\n            if(it.second > 0 && ratings[it.second-1] > ratings[it.second])\\n                ans[it.second-1] = max(ans[it.second-1],ans[it.second]+1);\\n            if(it.second < n-1 && ratings[it.second+1] > ratings[it.second])\\n                ans[it.second+1] = max(ans[it.second+1],ans[it.second]+1);\\n        }\\n        int x = 0;\\n        for(auto &it : ans)\\n            x += it;\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> ans(n,1);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> qe;\\n        for(int i = 0 ; i < n ; i++){\\n            qe.push({ratings[i],i});\\n        }\\n        while(!qe.empty()){\\n            auto it = qe.top();\\n            qe.pop();\\n            if(it.second > 0 && ratings[it.second-1] > ratings[it.second])\\n                ans[it.second-1] = max(ans[it.second-1],ans[it.second]+1);\\n            if(it.second < n-1 && ratings[it.second+1] > ratings[it.second])\\n                ans[it.second+1] = max(ans[it.second+1],ans[it.second]+1);\\n        }\\n        int x = 0;\\n        for(auto &it : ans)\\n            x += it;\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300298,
                "title": "c-simple-approach-o-n-easy-to-undersatand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int> num(ratings.size(),1);\\n //  if only one element then just return the size\\n        \\n        if(ratings.size()<=1)\\n            return ratings.size();\\n        \\n       /* The first loop makes sure children with a higher rating get more candy than its left neighbor \\n       */   \\n        \\n        for(int i=0;i<ratings.size()-1;i++)\\n        {\\n            if(ratings[i]<ratings[i+1])\\n                num[i+1]=num[i]+1;\\n        }\\n        \\n      /*  the second loop makes sure children with a higher rating get more candy than its right neighbor\\n      to increase */\\n        \\n        for(int i=ratings.size()-1;i>0;i--)\\n        {\\n            if(ratings[i-1]>ratings[i])\\n                // make sure that the increase in candies is minimum\\n                num[i-1]=max(num[i]+1,num[i-1]); \\n        }\\n        /*   sum the array formed and return it  \\n        */\\n        return accumulate(num.begin(),num.end(),0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int> num(ratings.size(),1);\\n //  if only one element then just return the size\\n        \\n        if(ratings.size()<=1)\\n            return ratings.size();\\n        \\n       /* The first loop makes sure children with a higher rating get more candy than its left neighbor \\n       */   \\n        \\n        for(int i=0;i<ratings.size()-1;i++)\\n        {\\n            if(ratings[i]<ratings[i+1])\\n                num[i+1]=num[i]+1;\\n        }\\n        \\n      /*  the second loop makes sure children with a higher rating get more candy than its right neighbor\\n      to increase */\\n        \\n        for(int i=ratings.size()-1;i>0;i--)\\n        {\\n            if(ratings[i-1]>ratings[i])\\n                // make sure that the increase in candies is minimum\\n                num[i-1]=max(num[i]+1,num[i-1]); \\n        }\\n        /*   sum the array formed and return it  \\n        */\\n        return accumulate(num.begin(),num.end(),0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743469,
                "title": "simple-bfs",
                "content": "Idea: \\n1. Find the worst-rated children and start with them\\n2. For Each worst child, give them just one candy (c)\\n3. For each of neighbour, \\n\\t- If they have a  higher rating, give them c + 1 candies\\n\\t- Otherwise give them 1 candy\\n4. If ever there is a conflict, round up.\\n\\nThe code is a straightforward breadth-first search. O(n) space and time. \\n\\n```\\nvar candy = function(ratings) {\\n    \\n    const result = new Array(ratings.length).fill(0);\\n    const min = Math.min(...ratings, 0);\\n\\n    const q = [];\\n    ratings.forEach((r, i) => {\\n        if(r === min) q.push([i, 1]);\\n    });\\n    \\n    while(q.length){    \\n        const [index, candies] = q.shift();\\n        \\n        if(result[index] < candies) result[index] = candies;\\n        else continue;\\n        \\n        if(index > 0){\\n            const left = index - 1;\\n            const leftCandy = ratings[left] > ratings[index] ? (candies+1) : 1;\\n            if(leftCandy > result[left]) q.push([left, leftCandy]);\\n        }\\n        \\n        if(index < ratings.length-1){\\n            const right = index + 1;\\n            const rightCandy = ratings[right] > ratings[index] ? (candies+1) : 1;\\n            if(rightCandy > result[right]) q.push([right, rightCandy]);\\n        }\\n    }\\n    \\n    return result.reduce((a, b) => a + b, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nvar candy = function(ratings) {\\n    \\n    const result = new Array(ratings.length).fill(0);\\n    const min = Math.min(...ratings, 0);\\n\\n    const q = [];\\n    ratings.forEach((r, i) => {\\n        if(r === min) q.push([i, 1]);\\n    });\\n    \\n    while(q.length){    \\n        const [index, candies] = q.shift();\\n        \\n        if(result[index] < candies) result[index] = candies;\\n        else continue;\\n        \\n        if(index > 0){\\n            const left = index - 1;\\n            const leftCandy = ratings[left] > ratings[index] ? (candies+1) : 1;\\n            if(leftCandy > result[left]) q.push([left, leftCandy]);\\n        }\\n        \\n        if(index < ratings.length-1){\\n            const right = index + 1;\\n            const rightCandy = ratings[right] > ratings[index] ? (candies+1) : 1;\\n            if(rightCandy > result[right]) q.push([right, rightCandy]);\\n        }\\n    }\\n    \\n    return result.reduce((a, b) => a + b, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 636991,
                "title": "simple-python-solution-runtime-o-n",
                "content": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        \\n        left=[1]*(len(ratings))\\n        right=[1]*len(ratings)\\n        \\n        for i in range(1,len(ratings)):\\n            if ratings[i]>ratings[i-1]:\\n                left[i]=left[i-1]+1\\n            \\n        for i in range(len(ratings)-2, -1,-1):\\n            if ratings[i]>ratings[i+1]:\\n                right[i]=right[i+1]+1\\n        \\n        total=[0]*len(ratings)\\n        for i in range(len(ratings)):\\n            total[i]=max(left[i], right[i])\\n        \\n        return sum(total)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        \\n        left=[1]*(len(ratings))\\n        right=[1]*len(ratings)\\n        \\n        for i in range(1,len(ratings)):\\n            if ratings[i]>ratings[i-1]:\\n                left[i]=left[i-1]+1\\n            \\n        for i in range(len(ratings)-2, -1,-1):\\n            if ratings[i]>ratings[i+1]:\\n                right[i]=right[i+1]+1\\n        \\n        total=[0]*len(ratings)\\n        for i in range(len(ratings)):\\n            total[i]=max(left[i], right[i])\\n        \\n        return sum(total)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326395,
                "title": "c-98-beat-o-n-speed-o-n-space-intuitive-solution",
                "content": "\\nDraw it out on paper.\\n\\n[2, 1, 1, 2, 3, 2, 3, 4, 0, 0, 1]\\n\\nHow many candies can be distribute? Manually plug in the values.\\n\\n[2, 1, 1, 2, 3, 1, 2, 3, 1, 1, 2]\\n\\nNotice that the numbers are influences by how many in a row are either ascending or descending.\\n\\nLike, [1, 5, 7, 8, 100] Would requre a distribution which was [1, 2, 3, 4, 5]\\n\\nAnd [100, 8, 7, 5, 1] Would requre a distribution which was [5, 4, 3, 2, 1]\\n\\nThrough inspection, we can see that the correct answer for each array slot is the max of these two values (ascending or descending).\\n\\nThis is how I figured it out. \\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        \\n        int aCount = ratings.size();\\n        \\n        int aAscend[aCount + 1];\\n        int aStreak = 1;\\n        aAscend[0] = 1;\\n        for (int i=1;i<aCount;i++) {\\n            if (ratings[i - 1] < ratings[i]) {\\n                ++aStreak;\\n            } else {\\n                aStreak = 1;\\n            }\\n            aAscend[i] = aStreak;\\n        }\\n        \\n        int aDescend[aCount + 1];\\n        aDescend[aCount - 1] = 1;\\n        aStreak = 1;\\n        for (int i=aCount-2;i>=0;i--) {\\n            if (ratings[i + 1] < ratings[i]) {\\n                ++aStreak;\\n            } else {\\n                aStreak = 1;\\n            }\\n            aDescend[i] = aStreak;\\n        }\\n        \\n        int aResult = 0;\\n        \\n        for (int i=0;i<aCount;i++) {\\n            aResult += max(aAscend[i], aDescend[i]);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        \\n        int aCount = ratings.size();\\n        \\n        int aAscend[aCount + 1];\\n        int aStreak = 1;\\n        aAscend[0] = 1;\\n        for (int i=1;i<aCount;i++) {\\n            if (ratings[i - 1] < ratings[i]) {\\n                ++aStreak;\\n            } else {\\n                aStreak = 1;\\n            }\\n            aAscend[i] = aStreak;\\n        }\\n        \\n        int aDescend[aCount + 1];\\n        aDescend[aCount - 1] = 1;\\n        aStreak = 1;\\n        for (int i=aCount-2;i>=0;i--) {\\n            if (ratings[i + 1] < ratings[i]) {\\n                ++aStreak;\\n            } else {\\n                aStreak = 1;\\n            }\\n            aDescend[i] = aStreak;\\n        }\\n        \\n        int aResult = 0;\\n        \\n        for (int i=0;i<aCount;i++) {\\n            aResult += max(aAscend[i], aDescend[i]);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247235,
                "title": "python-topological-sort-approach-o-n-time-and-o-n-space",
                "content": "The problem can be represented as a graph, where there is a node for each person, and a directed edge between two nodes if one node needs to get more candy than the other. \\nWith this graph, an easy variation of topological sort can solve the problem:\\n\\n\\tclass Solution(object):\\n\\t\\tdef candy(self, ratings):\\n\\t\\t\\tfrom collections import deque\\n\\t\\t\\tclass Node(object):\\n\\t\\t\\t\\tdef __init__(self,children):\\n\\t\\t\\t\\t\\tself.children = children\\n\\t\\t\\t\\t\\tself.visited = 0\\n\\t\\t\\t\\t\\tself.in_degree = 0\\n        \\n        #build graph:\\n        nodes = {}\\n        for i in range(len(ratings)):\\n            nodes[i] = Node([])\\n        \\n        for i,r in enumerate(ratings):\\n            if i > 0:\\n                if ratings[i-1] > r:\\n                    nodes[i].children.append(nodes[i-1])\\n                    nodes[i-1].in_degree += 1\\n                elif ratings[i-1] < r:\\n                    nodes[i-1].children.append(nodes[i])\\n                    nodes[i].in_degree += 1\\n            if i < len(ratings)-1 and ratings[i+1] > r:\\n                    nodes[i].children.append(nodes[i+1])\\n                    nodes[i+1].in_degree += 1\\n            elif i < len(ratings)-1 and ratings[i+1] < r:\\n                nodes[i+1].children.append(nodes[i])\\n                nodes[i].in_degree += 1\\n        \\n        #topological sort:\\n        sum_ = 0 \\n        q = deque([])\\n        for n in nodes.values():\\n            if n.in_degree == 0:\\n                q.append((n,1))\\n        while q:\\n            n,h = q.popleft()\\n            sum_ += h\\n            for neigh in n.children:\\n                neigh.in_degree -= 1\\n                if neigh.in_degree == 0:\\n                    q.append((neigh,h+1))\\n        return sum_\\n\\t\\t",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\t\\tdef candy(self, ratings):\\n\\t\\t\\tfrom collections import deque\\n\\t\\t\\tclass Node(object):\\n\\t\\t\\t\\tdef __init__(self,children):\\n\\t\\t\\t\\t\\tself.children = children\\n\\t\\t\\t\\t\\tself.visited = 0\\n\\t\\t\\t\\t\\tself.in_degree = 0\\n        \\n        #build graph:\\n        nodes = {}",
                "codeTag": "Java"
            },
            {
                "id": 42855,
                "title": "my-c-o-n-solution-with-good-explanation",
                "content": "The key of my solution is to eliminate backtrace and that can be achieved by introducing a decrease array, which stores the length of degressive sub arrary starting from any index. \\n\\nFor example, if the ratings array is [ 5, 1, 2, 3, 4, 9, 5, 3, 2, 2, 8 ], it's corresponding decrease array should look like this: [ 2, 1, 1, 1, 1, 4, 3, 2, 1, 1, 1 ]. sub array [ 9, 5, 3, 2 ] is degressive and its length is 4, that's where the 4 comes from. Any single-element sub array can make a degressive array of length 1. Obviously, this decrease array can be easily created by scanning ratings array from tail to head. \\n\\nWith this decrease array constructed, we can calculate candies for each child without backtrace.\\n\\n    int candy(vector<int>& ratings) {\\n        if( ratings.empty()) return 0;\\n        vector<int> decrease(ratings.size());\\n        decrease[ratings.size()-1] = 1;\\n        for( int i=ratings.size()-2; i>=0; i-- ) {\\n            if( ratings[i] > ratings[i+1] ) decrease[i] = decrease[i+1]+1;\\n            else decrease[i] = 1;\\n        }        \\n        vector<int> candy(ratings.size());\\n        candy[0] = decrease[0];\\n        int sum = candy[0];\\n        for( int i=1; i<ratings.size(); i++ ) {\\n            if( ratings[i] > ratings[i-1] ) candy[i] = max( decrease[i], candy[i-1]+1);\\n            else if( ratings[i] == ratings[i-1] ) {\\n                candy[i] = max( decrease[i], 1);\\n            }\\n            else candy[i] = min(candy[i-1]-1, decrease[i]);\\n            sum += candy[i];\\n        }\\n        return sum;\\n    }\\n\\nAnd, if you want to save more space, you can reuse the decrease array.\\n\\n    int candy(vector<int>& ratings) {\\n        if( ratings.empty()) return 0;\\n        vector<int> decrease(ratings.size());\\n        decrease[ratings.size()-1] = 1;\\n        for( int i=ratings.size()-2; i>=0; i-- ) {\\n            decrease[i] = ratings[i] > ratings[i+1] ? decrease[i+1] + 1 : 1;\\n        }        \\n        int sum = decrease[0];\\n        for( int i=1; i<ratings.size(); i++ ) {\\n            if( ratings[i] > ratings[i-1] ) \\n                decrease[i] = max( decrease[i], decrease[i-1]+1);\\n            else if( ratings[i] == ratings[i-1] ) \\n                decrease[i] = max( decrease[i], 1);\\n            else \\n                decrease[i] = min(decrease[i-1]-1, decrease[i]);\\n            sum += decrease[i];\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "The key of my solution is to eliminate backtrace and that can be achieved by introducing a decrease array, which stores the length of degressive sub arrary starting from any index. \\n\\nFor example, if the ratings array is [ 5, 1, 2, 3, 4, 9, 5, 3, 2, 2, 8 ], it's corresponding decrease array should look like this: [ 2, 1, 1, 1, 1, 4, 3, 2, 1, 1, 1 ]. sub array [ 9, 5, 3, 2 ] is degressive and its length is 4, that's where the 4 comes from. Any single-element sub array can make a degressive array of length 1. Obviously, this decrease array can be easily created by scanning ratings array from tail to head. \\n\\nWith this decrease array constructed, we can calculate candies for each child without backtrace.\\n\\n    int candy(vector<int>& ratings) {\\n        if( ratings.empty()) return 0;\\n        vector<int> decrease(ratings.size());\\n        decrease[ratings.size()-1] = 1;\\n        for( int i=ratings.size()-2; i>=0; i-- ) {\\n            if( ratings[i] > ratings[i+1] ) decrease[i] = decrease[i+1]+1;\\n            else decrease[i] = 1;\\n        }        \\n        vector<int> candy(ratings.size());\\n        candy[0] = decrease[0];\\n        int sum = candy[0];\\n        for( int i=1; i<ratings.size(); i++ ) {\\n            if( ratings[i] > ratings[i-1] ) candy[i] = max( decrease[i], candy[i-1]+1);\\n            else if( ratings[i] == ratings[i-1] ) {\\n                candy[i] = max( decrease[i], 1);\\n            }\\n            else candy[i] = min(candy[i-1]-1, decrease[i]);\\n            sum += candy[i];\\n        }\\n        return sum;\\n    }\\n\\nAnd, if you want to save more space, you can reuse the decrease array.\\n\\n    int candy(vector<int>& ratings) {\\n        if( ratings.empty()) return 0;\\n        vector<int> decrease(ratings.size());\\n        decrease[ratings.size()-1] = 1;\\n        for( int i=ratings.size()-2; i>=0; i-- ) {\\n            decrease[i] = ratings[i] > ratings[i+1] ? decrease[i+1] + 1 : 1;\\n        }        \\n        int sum = decrease[0];\\n        for( int i=1; i<ratings.size(); i++ ) {\\n            if( ratings[i] > ratings[i-1] ) \\n                decrease[i] = max( decrease[i], decrease[i-1]+1);\\n            else if( ratings[i] == ratings[i-1] ) \\n                decrease[i] = max( decrease[i], 1);\\n            else \\n                decrease[i] = min(decrease[i-1]-1, decrease[i]);\\n            sum += decrease[i];\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 42919,
                "title": "python-two-pass-solution",
                "content": "First, make sure I have right number of candy when compared to my left kid.\\nThen, make sure I have the right number of candy when compared to my right kid.\\n\\n    class Solution:\\n        # @param ratings, a list of integer\\n        # @return an integer\\n        # 5:46\\n        def candy(self, ratings):\\n            if not ratings:\\n                return 0\\n    \\n            n = len(ratings)\\n            candy = [1] * n\\n            for i in range(1, n):\\n                if ratings[i] > ratings[i - 1]:\\n                    candy[i] = candy[i - 1] + 1\\n                \\n            for i in range(n - 2, -1, -1):\\n                if ratings[i] > ratings[i + 1] and candy[i] <= candy[i + 1]:\\n                    candy[i] = candy[i + 1] + 1\\n    \\n            return sum(candy)",
                "solutionTags": [
                    "Python"
                ],
                "code": "First, make sure I have right number of candy when compared to my left kid.\\nThen, make sure I have the right number of candy when compared to my right kid.\\n\\n    class Solution:\\n        # @param ratings, a list of integer\\n        # @return an integer\\n        # 5:46\\n        def candy(self, ratings):\\n            if not ratings:\\n                return 0\\n    \\n            n = len(ratings)\\n            candy = [1] * n\\n            for i in range(1, n):\\n                if ratings[i] > ratings[i - 1]:\\n                    candy[i] = candy[i - 1] + 1\\n                \\n            for i in range(n - 2, -1, -1):\\n                if ratings[i] > ratings[i + 1] and candy[i] <= candy[i + 1]:\\n                    candy[i] = candy[i + 1] + 1\\n    \\n            return sum(candy)",
                "codeTag": "Java"
            },
            {
                "id": 42940,
                "title": "a-concise-c-solution-for-stl-lovers",
                "content": "If you like C++ and STL, you may also like the following solution:\\n\\n    class Solution {\\n    public:\\n        int candy(vector<int> &ratings) {\\n            \\n            // Corner case:\\n            if (ratings.size( ) <= 1)\\n            {\\n                return ratings.size( ); // Zero or one.\\n            }\\n            \\n            vector<int> candies(ratings.size(), 1);             // One candy per children at least.\\n            extraCandies(begin(candies), end(candies),          // Extra candies, left to right.\\n                         begin(ratings));\\n            extraCandies(candies.rbegin(), candies.rend(),      // Extra candies, right to left.\\n                         ratings.rbegin());\\n            return accumulate(begin(candies), end(candies), 0); // Total summ of candies.\\n        }\\n        \\n        template<typename It>\\n        int extraCandies(It candyIt, It candyEnd, It ratingIt)\\n        {\\n            int prevCandy = *candyIt;\\n            int prevRating = *ratingIt;\\n            while(candyIt != candyEnd)\\n            {\\n                if (*ratingIt > prevRating\\n                    && *candyIt <= prevCandy)\\n                {\\n                    // Bingo, extra candies for him!\\n                    (*candyIt) = prevCandy + 1;\\n                }\\n                \\n                prevRating = *ratingIt;\\n                prevCandy = *candyIt;\\n                ++candyIt;\\n                ++ratingIt;\\n            }\\n        }\\n    };\\n\\nComplexity:\\n - CPU: O(n)\\n - Memory: O(n)",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n        int candy(vector<int> &ratings) {\\n            \\n            // Corner case:\\n            if (ratings.size( ) <= 1)\\n            {\\n                return ratings.size( ); // Zero or one.\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 42960,
                "title": "my-accepted-o-n-o-1-solution",
                "content": "    class Solution {\\n    public:\\n    \\tint candy(vector<int> &ratings) \\n    \\t{\\n    \\t\\tint i = 0; // start of the sequence\\n    \\t\\tint count = 1; //total number of candy needed\\n    \\t\\tint n = ratings.size();  //number of childen\\n    \\t\\tint lastCandy=1; //number of Candy the last child of previous sequence hold\\n    \\t\\twhile ( i < n - 1)\\n    \\t\\t{\\n    \\t\\t\\tint j = i+1; // j is the next node of end of this sequence\\n    \\t\\t\\tint tmp =0;\\n    \\t\\t\\tif (ratings[j] > ratings[i])\\n    \\t\\t\\t{//find the whole upside sequence, it's from i to j - 1, \\n    \\t\\t\\t\\twhile(j < n && ratings[j]>ratings[j-1]) j++;\\n    \\t\\t\\t\\ttmp = j - i - 1; // total number in up sequence, count them from 2 to (count +1) because the first one is already included in previous sequence\\n    \\t\\t\\t\\tcount += (tmp*(tmp+3)/2); // add them up\\n    \\t\\t\\t\\tlastCandy = tmp+lastCandy;\\n    \\t\\t\\t\\ti = j - 1;\\n    \\t\\t\\t}\\n    \\t\\t\\telse if (ratings[j] < ratings[i]) \\n    \\t\\t\\t{//find the downside sequence, it's from i to j - 1;\\n    \\t\\t\\t\\twhile(j<n && ratings[j]<ratings[j-1]) j++;\\n    \\t\\t\\t\\t// total number in down sequence, count them from (count - 1) to 1,\\n    \\t\\t\\t\\ttmp = j - i - 1; \\n    \\t\\t\\t\\tcount += (tmp*(tmp+1)/2);\\n    \\t\\t\\t\\t// if the last child in previous sequence has less candy than he/she should have, add it up by the down sequence number\\n    \\t\\t\\t\\tif (tmp >= lastCandy)\\n    \\t\\t\\t\\t\\tcount += (tmp + 1 - lastCandy);\\n    \\t\\t\\t\\tlastCandy = 1;\\n    \\t\\t\\t\\ti = j - 1;\\n    \\t\\t\\t}\\n    \\t\\t\\telse\\n    \\t\\t\\t{//same rating as previous one, start with only 1 candy\\n    \\t\\t\\t\\tcount++;\\n    \\t\\t\\t\\tlastCandy = 1;\\n    \\t\\t\\t\\ti = j;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn count;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tint candy(vector<int> &ratings) \\n    \\t{\\n    \\t\\tint i = 0; // start of the sequence\\n    \\t\\tint count = 1; //total number of candy needed\\n    \\t\\tint n = ratings.size();  //number of childen\\n    \\t\\tint lastCandy=1; //number of Candy the last child of previous sequence hold\\n    \\t\\twhile ( i < n - 1)\\n    \\t\\t{\\n    \\t\\t\\tint j = i+1; // j is the next node of end of this sequence\\n    \\t\\t\\tint tmp =0;\\n    \\t\\t\\tif (ratings[j] > ratings[i])\\n    \\t\\t\\t{//find the whole upside sequence, it's from i to j - 1, \\n    \\t\\t\\t\\twhile(j < n && ratings[j]>ratings[j-1]) j++;\\n    \\t\\t\\t\\ttmp = j - i - 1; // total number in up sequence, count them from 2 to (count +1) because the first one is already included in previous sequence\\n    \\t\\t\\t\\tcount += (tmp*(tmp+3)/2); // add them up\\n    \\t\\t\\t\\tlastCandy = tmp+lastCandy;\\n    \\t\\t\\t\\ti = j - 1;\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 42934,
                "title": "candy-problem-on-oj",
                "content": "> There are N children standing in a line. Each child is assigned a\\n> rating value. You are giving candies to these children subjected to\\n> the following requirements:\\n>      Each child must have at least one candy.      Children with a higher rating get more candies than their neighbors.           What is\\n> the minimum candies you must give?\\n\\n\\nI thought I got it correctly, but my code seems to fail for some test cases. The logic I was following:   \\ninitialize an array of size n, called candies, with all values set to 0    \\nset first value to 1    \\niterate through ratings array, starting at one, and check:   \\n  for element i in array rating:   \\n\\n 1. if rating[i] is greater than rating[i-1], set current candy nr. to\\n    previous nr.+1\\n 2. if rating[i] is equal to rating[i-1], set current candy nr. to the same nr. as previous\\n 3. if rating[i] is less than rating[i-1], there are two possible  situations:\\n\\n \\n - a) we can safely subtract 1 for previous candy number and still get a number that is greater than one; in that case set current candy nr.  to 1   \\n - b) setting the current candy nr. to previous-1 would be less than 1; in    that case we need to backtrack; continue backtracking     while    previous rating is greater than the current && previous  candy    nr.    is less than or equal to the current; in each   iteration increase       the previous candy nr.\\n\\n\\nI think my code now is pretty straighforward:\\n\\n    public int candy(int[] ratings) {\\n             \\n                if (ratings== null) return -1;\\n                int n = ratings.length;\\n                int[] candies = new int[n];\\n                if (n==0) return 0;\\n                candies[0] = 1;\\n                int sum = 1;\\n                for (int i=1; i<n; i++) {\\n                    if (ratings[i] > ratings[i-1]) {\\n\\n                        candies[i] = candies[i-1] + 1;\\n                        sum+=candies[i];\\n\\n                    } else if (ratings[i] == ratings[i-1]) {\\n                        \\n                        candies[i] = candies[i-1];\\n                        sum+=candies[i];\\n                    \\n                   }else {\\n                        if (candies[i-1]-1 >= 1) {\\n                             candies[i] = 1;\\n                            sum+= candies[i];\\n                        } else {\\n                            int k = i;\\n                            candies[k]++;\\n                            sum++;\\n                            while (k>0 && ratings[k]<ratings[k-1] && candies[k-1]<=candies[k]) {\\n                                candies[k-1]++;\\n                                sum++;\\n                                k--;\\n                            }\\n                        } \\n                    }\\n                }\\n                return sum;\\n            }\\n\\n[UPDATE:] Here is the failed case: [58,21,72,77,48,9,38,71,68,77,82,47,25,94,89,54,26,54,54,99,64,71,76,63,81,82,60,64,29,51,87,87,72,12,16,20,21,54,43,41,83,77,41,61,72,82,15,50,36,69,49,53,92,77,16,73,12,28,37,41,79,25,80,3,37,48,23,10,55,19,51,38,96,92,99,68,75,14,18,63,35,19,68,28,49,36,53,61,64,91,2,43,68,34,46,57,82,22,67,89]\\n\\nExpected: 208, I got: 210.",
                "solutionTags": [],
                "code": "> There are N children standing in a line. Each child is assigned a\\n> rating value. You are giving candies to these children subjected to\\n> the following requirements:\\n>      Each child must have at least one candy.      Children with a higher rating get more candies than their neighbors.           What is\\n> the minimum candies you must give?\\n\\n\\nI thought I got it correctly, but my code seems to fail for some test cases. The logic I was following:   \\ninitialize an array of size n, called candies, with all values set to 0    \\nset first value to 1    \\niterate through ratings array, starting at one, and check:   \\n  for element i in array rating:   \\n\\n 1. if rating[i] is greater than rating[i-1], set current candy nr. to\\n    previous nr.+1\\n 2. if rating[i] is equal to rating[i-1], set current candy nr. to the same nr. as previous\\n 3. if rating[i] is less than rating[i-1], there are two possible  situations:\\n\\n \\n - a) we can safely subtract 1 for previous candy number and still get a number that is greater than one; in that case set current candy nr.  to 1   \\n - b) setting the current candy nr. to previous-1 would be less than 1; in    that case we need to backtrack; continue backtracking     while    previous rating is greater than the current && previous  candy    nr.    is less than or equal to the current; in each   iteration increase       the previous candy nr.\\n\\n\\nI think my code now is pretty straighforward:\\n\\n    public int candy(int[] ratings) {\\n             \\n                if (ratings== null) return -1;\\n                int n = ratings.length;\\n                int[] candies = new int[n];\\n                if (n==0) return 0;\\n                candies[0] = 1;\\n                int sum = 1;\\n                for (int i=1; i<n; i++) {\\n                    if (ratings[i] > ratings[i-1]) {\\n\\n                        candies[i] = candies[i-1] + 1;\\n                        sum+=candies[i];\\n\\n                    } else if (ratings[i] == ratings[i-1]) {\\n                        \\n                        candies[i] = candies[i-1];\\n                        sum+=candies[i];\\n                    \\n                   }else {\\n                        if (candies[i-1]-1 >= 1) {\\n                             candies[i] = 1;\\n                            sum+= candies[i];\\n                        } else {\\n                            int k = i;\\n                            candies[k]++;\\n                            sum++;\\n                            while (k>0 && ratings[k]<ratings[k-1] && candies[k-1]<=candies[k]) {\\n                                candies[k-1]++;\\n                                sum++;\\n                                k--;\\n                            }\\n                        } \\n                    }\\n                }\\n                return sum;\\n            }\\n\\n[UPDATE:] Here is the failed case: [58,21,72,77,48,9,38,71,68,77,82,47,25,94,89,54,26,54,54,99,64,71,76,63,81,82,60,64,29,51,87,87,72,12,16,20,21,54,43,41,83,77,41,61,72,82,15,50,36,69,49,53,92,77,16,73,12,28,37,41,79,25,80,3,37,48,23,10,55,19,51,38,96,92,99,68,75,14,18,63,35,19,68,28,49,36,53,61,64,91,2,43,68,34,46,57,82,22,67,89]\\n\\nExpected: 208, I got: 210.",
                "codeTag": "Unknown"
            },
            {
                "id": 4038208,
                "title": "2-approach-brute-force-better-approach-easy-explanation-c",
                "content": "\\n# Approach\\n#### 1st Approach\\n- Go to every index and check how many neighbours are bigger than that ```max(left-neighbour, right-neighbour)```\\n\\n#### Better Approach\\n- Make two vertors ```left and right```\\n- ```left``` for storing the maximum neighbours to its recent left if any is equal to or bigger than the ```ith``` number then  we cannot further calculate\\n- ```right``` for storing the maximum neighbours to its recent right\\n- Now take the maximum of ```max(left[i], right[i] + 1``` and add it to the answer\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Approach 1:\\n    - Time complexity -- $$O(n^2)$$\\n    - Space complexity -- $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Approach 2:\\n    - Time complexity -- $$O(n)$$\\n    - Space complexity -- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Approach 1\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        if(n == 1)\\n            return 1;\\n\\n        int ans = n; \\n        int i = 0;\\n        while(i < n){\\n            int j = i - 1;\\n            int count = 0;\\n            while(j >= 0 && ratings[j + 1] > ratings[j]){\\n                count++, j--;\\n            }\\n            int count2 = 0;\\n            j = i + 1;\\n            while(j < n && ratings[j - 1] > ratings[j]){\\n                count2++, j++;\\n            }\\n            ans += max(count, count2);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Approach 2\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> left(n, 0), right(n, 0);\\n        for(int i = 1; i < n; i++)\\n            if(ratings[i] > ratings[i - 1])\\n                left[i] = left[i - 1] + 1;\\n\\n        for(int i = n - 2; i >= 0; i--)\\n            if(ratings[i] > ratings[i + 1])\\n                right[i] = right[i + 1] + 1;\\n\\n        int ans = n;\\n        for(int i = 0; i < n; i++)\\n            ans += max(left[i], right[i]);\\n        return ans;\\n    }\\n};\\n\\n```\\n![upvote_leetcode.jpeg](https://assets.leetcode.com/users/images/4a49ab74-4aa1-4097-82a2-240682ea3352_1694580760.1023214.jpeg)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```max(left-neighbour, right-neighbour)```\n```left and right```\n```left```\n```ith```\n```right```\n```max(left[i], right[i] + 1```\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        if(n == 1)\\n            return 1;\\n\\n        int ans = n; \\n        int i = 0;\\n        while(i < n){\\n            int j = i - 1;\\n            int count = 0;\\n            while(j >= 0 && ratings[j + 1] > ratings[j]){\\n                count++, j--;\\n            }\\n            int count2 = 0;\\n            j = i + 1;\\n            while(j < n && ratings[j - 1] > ratings[j]){\\n                count2++, j++;\\n            }\\n            ans += max(count, count2);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> left(n, 0), right(n, 0);\\n        for(int i = 1; i < n; i++)\\n            if(ratings[i] > ratings[i - 1])\\n                left[i] = left[i - 1] + 1;\\n\\n        for(int i = n - 2; i >= 0; i--)\\n            if(ratings[i] > ratings[i + 1])\\n                right[i] = right[i + 1] + 1;\\n\\n        int ans = n;\\n        for(int i = 0; i < n; i++)\\n            ans += max(left[i], right[i]);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038027,
                "title": "easy-0-n-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n### **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n### **[https://www.instagram.com/pratay_nandy/]()**\\n# Problem Statement\\n- The problem statement is as follows: You are given a list of ratings for a group of children, and you want to distribute candies to these children based on the following rules:\\n\\n1. Each child must have at least one candy.\\n2. Children with a higher rating than their neighbors must get more candies.\\n- The goal is to minimize the total number of candies used while satisfying these rules\\n# Approach\\n\\nHere\\'s the approach used in the provided C++ code:\\n\\n- Initialize a vector left with the same size as the input ratings vector. This vector will store the number of candies given to each child based on the ratings from the left side.\\n\\n- First Pass (from left to right):\\n\\n- Iterate through the ratings vector from left to right (from index 1 to the end).\\nIf the current child\\'s rating is greater than the previous child\\'s rating, increment the number of candies given to the current child by one more than what the previous child received (i.e., left[i] = left[i-1] + 1).Otherwise, leave left[i] as 1 because the current child\\'s rating is not greater than the previous one.\\nInitialize a variable right to 1. This variable will be used to keep track of the number of candies given to the children from the right side.\\n\\n- Second Pass (from right to left):\\n\\n- Iterate through the ratings vector from right to left (from the second-to-last element to the first element).\\nIf the current child\\'s rating is greater than the next child\\'s rating, increment right by 1 (since this child needs more candies than the next one).\\n- Update left[i] by taking the maximum of its current value and right (to ensure that the child gets the maximum of what they need from both sides).\\n- If the current child\\'s rating is not greater than the next one, reset right to 1, indicating that this child starts a new descending sequence.\\n- Calculate the total sum of candies in the left vector, which represents the minimum total number of candies needed to satisfy the given rules.\\n\\n- Return the total sum as the result.\\n\\nThis approach ensures that each child receives the required minimum number of candies while taking into account both left and right ratings comparisons. The final result is the minimum total number of candies needed to satisfy the rulesThe problem statement is as follows: You are given a list of ratings for a group of children, and you want to distribute candies to these children based on the following rules:\\n\\n# Complexity\\n- Time complexity:**0(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**0(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int>left(ratings.size()+1,1);\\n        // vector<int>right(ratings.size()+1,1);\\n        for(int i = 1; i < ratings.size(); i++ )\\n        {\\n            if(ratings[i]>ratings[i-1])\\n            {\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        int right = 1;\\n        for(int i = ratings.size()-2;i>=0;i--)\\n        {\\n            if(ratings[i] > ratings[i+1])\\n            {\\n                right++;\\n                left[i]=max(right, left[i]);\\n            }\\n            else\\n            right = 1;\\n        }\\n        int sum = 0 ;\\n        for(int i = 0; i < ratings.size(); i++ )\\n            sum+=left[i];\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int>left(ratings.size()+1,1);\\n        // vector<int>right(ratings.size()+1,1);\\n        for(int i = 1; i < ratings.size(); i++ )\\n        {\\n            if(ratings[i]>ratings[i-1])\\n            {\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        int right = 1;\\n        for(int i = ratings.size()-2;i>=0;i--)\\n        {\\n            if(ratings[i] > ratings[i+1])\\n            {\\n                right++;\\n                left[i]=max(right, left[i]);\\n            }\\n            else\\n            right = 1;\\n        }\\n        int sum = 0 ;\\n        for(int i = 0; i < ratings.size(); i++ )\\n            sum+=left[i];\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037939,
                "title": "easy-c-solution-using-prefix-and-suffix-vectors",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two arrays `pref` and `suff` with the same size as the ratings array, all set to 1. This ensures that each child starts with at least `one` candy.\\n\\n2. Loop through the ratings array from left to right. For each child, compare their rating with the rating of the previous child (if any). If the current child\\'s rating is greater than the previous child\\'s rating, increment the number of candies given to the current child by 1 more than what the previous child received `(pref[i] = 1 + pref[i-1])`.\\n\\n3. Loop through the ratings array from right to left. For each child, compare their rating with the rating of the next child (if any). If the current child\\'s rating is greater than the next child\\'s rating, update the number of candies given to the current child by taking the maximum of its current value and 1 plus what the next child received `(suff[i] = max(suff[i], 1 + suff[i+1]))`.\\n\\n4. Initialize a variable `ans` to keep track of the total number of candies needed.\\n\\n5. Loop through the ratings array one more time, and for each child, calculate the maximum number of candies they should receive by taking the maximum of the values in `pref` and `suff` for that child. Add this maximum value to `ans`.\\n\\n6. Return `ans`, which represents the` total minimum number of candies required to satisfy the conditions`.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n We traverse the ratings array three times independently, and each traversal takes `linear time`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n We use two additional arrays `pref` and `suff`, each of size `n`, for storing intermediate results.\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int>pref(n , 1);\\n        vector<int>suff(n , 1);\\n        for(int i = 1;i<n; i++){\\n            if(ratings[i]>ratings[i-1]) pref[i] = 1 + pref[i-1];\\n        }\\n        for(int i = n-2;i>=0; i--){\\n            if(ratings[i]>ratings[i+1]) suff[i] = 1 + suff[i+1];\\n        }\\n\\n        int ans = 0; \\n        for(int i=0;i<n; i++) ans += max(pref[i] , suff[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int>pref(n , 1);\\n        vector<int>suff(n , 1);\\n        for(int i = 1;i<n; i++){\\n            if(ratings[i]>ratings[i-1]) pref[i] = 1 + pref[i-1];\\n        }\\n        for(int i = n-2;i>=0; i--){\\n            if(ratings[i]>ratings[i+1]) suff[i] = 1 + suff[i+1];\\n        }\\n\\n        int ans = 0; \\n        for(int i=0;i<n; i++) ans += max(pref[i] , suff[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001238,
                "title": "java-easy-solution-with-proper-explanation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->1.We will make two array and we will keep each element value as 1 for those two array. Now we will move from left to right and if we found the element to be greater than the neightbouring element, then we will make the value of that index to be 1 greater than the previous index value and store this all value in array named as LtoR\\n2.Similarly we will move from right to left (we will start from n-2 element) and compare and do the same thing as mentioned above and store all value in RtoL array.\\n3.After that we will make another array named as \\'ans\\' and store the max value of LtoR and RtoL arrays.\\n4.Then we will sum up the value of res and get the final output.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] LtoR = new int[n];//LtoR(Left to right)\\n        int[] RtoL = new int[n];//RtoL(Right to left)\\n        for(int i=0; i<n; i++){\\n            LtoR[i]=RtoL[i]=1;// assign each element value as 1\\n        }\\n        for(int i=1; i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                LtoR[i]=LtoR[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2; i>=0; i--){\\n            if(ratings[i]>ratings[i+1]){\\n                RtoL[i]=RtoL[i+1]+1;\\n            }\\n        }\\n        int[] ans = new int[n];\\n        int sum =0;\\n        for(int i=0; i<n; i++){\\n            ans[i] = Math.max(LtoR[i],RtoL[i]);\\n            sum += ans[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] LtoR = new int[n];//LtoR(Left to right)\\n        int[] RtoL = new int[n];//RtoL(Right to left)\\n        for(int i=0; i<n; i++){\\n            LtoR[i]=RtoL[i]=1;// assign each element value as 1\\n        }\\n        for(int i=1; i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                LtoR[i]=LtoR[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2; i>=0; i--){\\n            if(ratings[i]>ratings[i+1]){\\n                RtoL[i]=RtoL[i+1]+1;\\n            }\\n        }\\n        int[] ans = new int[n];\\n        int sum =0;\\n        for(int i=0; i<n; i++){\\n            ans[i] = Math.max(LtoR[i],RtoL[i]);\\n            sum += ans[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747874,
                "title": "easy-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n\\n- Space complexity:O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> candies(n, 1);\\n        \\n        // Forward pass\\n        for(int i = 1; i < n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        \\n        // Backward pass\\n        for(int i = n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1] + 1);\\n            }\\n        }\\n        \\n        // Sum up the candies\\n        int sum = 0;\\n        for(int c : candies) sum += c;\\n        \\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> candies(n, 1);\\n        \\n        // Forward pass\\n        for(int i = 1; i < n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        \\n        // Backward pass\\n        for(int i = n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1] + 1);\\n            }\\n        }\\n        \\n        // Sum up the candies\\n        int sum = 0;\\n        for(int c : candies) sum += c;\\n        \\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689006,
                "title": "easy-solution-greedy-o-n",
                "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) \\n    {\\n        int n=ratings.size();\\n        if(ratings.size()==1)\\n        {\\n            return 1;\\n        }\\n        vector<int> temp(ratings.size(),1);\\n        int ans=0;\\n        if(ratings[0]>ratings[1])\\n        {\\n            temp[0]=max(temp[0]+1,temp[1]+1);\\n        }\\n        for(int i=1;i<ratings.size()-1;i++)\\n        {\\n            if(ratings[i]>ratings[i+1]||ratings[i]>ratings[i-1])\\n            {\\n                if(ratings[i]>ratings[i+1]&&ratings[i]>ratings[i-1])\\n                {\\n                    temp[i]=max(temp[i]+1,max(temp[i+1]+1,temp[i-1]+1));\\n                }\\n                else if(ratings[i]>ratings[i-1])\\n                {\\n                    temp[i]=max(temp[i]+1,temp[i-1]+1);\\n                }\\n                else if(ratings[i]>ratings[i+1])\\n                {\\n                     temp[i]=max(temp[i]+1,temp[i+1]+1);\\n                }\\n            }\\n        }\\n        if(n>=2) \\n        {\\n            if(ratings[n-1]>ratings[n-2])\\n            {\\n                temp[n-1]=max(temp[n-1]+1,temp[n-2]+1);\\n            }\\n        }\\n        for(int i=ratings.size()-1;i>=1;i--)\\n        {\\n            if(ratings[i]<ratings[i-1])\\n            {\\n                if(temp[i]>=temp[i-1])\\n                {\\n                    temp[i-1]=temp[i]+1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            ans+=temp[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) \\n    {\\n        int n=ratings.size();\\n        if(ratings.size()==1)\\n        {\\n            return 1;\\n        }\\n        vector<int> temp(ratings.size(),1);\\n        int ans=0;\\n        if(ratings[0]>ratings[1])\\n        {\\n            temp[0]=max(temp[0]+1,temp[1]+1);\\n        }\\n        for(int i=1;i<ratings.size()-1;i++)\\n        {\\n            if(ratings[i]>ratings[i+1]||ratings[i]>ratings[i-1])\\n            {\\n                if(ratings[i]>ratings[i+1]&&ratings[i]>ratings[i-1])\\n                {\\n                    temp[i]=max(temp[i]+1,max(temp[i+1]+1,temp[i-1]+1));\\n                }\\n                else if(ratings[i]>ratings[i-1])\\n                {\\n                    temp[i]=max(temp[i]+1,temp[i-1]+1);\\n                }\\n                else if(ratings[i]>ratings[i+1])\\n                {\\n                     temp[i]=max(temp[i]+1,temp[i+1]+1);\\n                }\\n            }\\n        }\\n        if(n>=2) \\n        {\\n            if(ratings[n-1]>ratings[n-2])\\n            {\\n                temp[n-1]=max(temp[n-1]+1,temp[n-2]+1);\\n            }\\n        }\\n        for(int i=ratings.size()-1;i>=1;i--)\\n        {\\n            if(ratings[i]<ratings[i-1])\\n            {\\n                if(temp[i]>=temp[i-1])\\n                {\\n                    temp[i-1]=temp[i]+1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            ans+=temp[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376636,
                "title": "easiest-approach-c-code-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& r) {\\n        vector< int> left(r.size(), 1);\\n        vector< int> right(r.size(), 1);\\n\\n        for(int i = 1; i<r.size(); i++){\\n            if(r[i]>r[i-1]) left[i] += left[i-1];\\n        }\\n\\n        for(int i = r.size()-2; i>=0; i--){\\n            if(r[i]>r[i+1]) right[i] += right[i+1];\\n        }\\n\\n        int ans = 0;\\n        for(int i = 0; i<left.size(); i++){\\n            ans = ans + max(left[i],right[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& r) {\\n        vector< int> left(r.size(), 1);\\n        vector< int> right(r.size(), 1);\\n\\n        for(int i = 1; i<r.size(); i++){\\n            if(r[i]>r[i-1]) left[i] += left[i-1];\\n        }\\n\\n        for(int i = r.size()-2; i>=0; i--){\\n            if(r[i]>r[i+1]) right[i] += right[i+1];\\n        }\\n\\n        int ans = 0;\\n        for(int i = 0; i<left.size(); i++){\\n            ans = ans + max(left[i],right[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305021,
                "title": "easy-java-greedy-approach-3ms-solution",
                "content": "# Approach\\n\\n1. **Just make an array of same size as the provided array and initilize it to 1 as the minimum count of candies is 1**\\n2. **Now 1st check for the condition from start to end and then from end to start and finally return the sum of new array**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int[] res = new int[ratings.length];\\n\\n        Arrays.fill(res, 1);\\n\\n        for(int i = 1;i < ratings.length;i++){\\n            if(ratings[i] > ratings[i-1]){\\n                res[i] = res[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i = ratings.length-2;i >= 0;i--){\\n            if(ratings[i] > ratings[i+1]){\\n                res[i] = Math.max(res[i], res[i+1]+1);\\n            }\\n        }\\n\\n        int sum = 0;\\n\\n        for(int i = 0;i < res.length;i++){\\n            sum += res[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int[] res = new int[ratings.length];\\n\\n        Arrays.fill(res, 1);\\n\\n        for(int i = 1;i < ratings.length;i++){\\n            if(ratings[i] > ratings[i-1]){\\n                res[i] = res[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i = ratings.length-2;i >= 0;i--){\\n            if(ratings[i] > ratings[i+1]){\\n                res[i] = Math.max(res[i], res[i+1]+1);\\n            }\\n        }\\n\\n        int sum = 0;\\n\\n        for(int i = 0;i < res.length;i++){\\n            sum += res[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076505,
                "title": "c-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& arr) {\\n        int n = arr.size();\\n        if( n == 1)\\n            return 1;\\n        vector<int> res(n , 1);\\n\\n        \\n        for( int i = 1 ; i < n  ; ++i){\\n            if( arr[i] > arr[i-1] ){\\n                res[i] = res[i-1]+1;\\n            }\\n        }\\n\\n        for( int i = n - 1 ; i > 0 ; --i){\\n            if( arr[i-1] > arr[i] ){\\n                res[i-1] = max(res[i] + 1 , res[i-1]);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto i : res){\\n            // cout<<i<<\" \";\\n            ans+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& arr) {\\n        int n = arr.size();\\n        if( n == 1)\\n            return 1;\\n        vector<int> res(n , 1);\\n\\n        \\n        for( int i = 1 ; i < n  ; ++i){\\n            if( arr[i] > arr[i-1] ){\\n                res[i] = res[i-1]+1;\\n            }\\n        }\\n\\n        for( int i = n - 1 ; i > 0 ; --i){\\n            if( arr[i-1] > arr[i] ){\\n                res[i-1] = max(res[i] + 1 , res[i-1]);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto i : res){\\n            // cout<<i<<\" \";\\n            ans+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3015077,
                "title": "c-o-n-time-solution-explanation",
                "content": "\\n# Upvote if Found Helpful\\n# Approach\\n\\n\\n**According to question**\\nThe child whose rating is higher than that of his left or right neighbors should get more candies than his neighbors and the total amount of candies should also be minimum.\\n```\\n// so we can say that \\nif current_child_rating > left_child_rating or current_child_rating > right_child_rating \\nthen \\ncurrent_child_get_candy = max( left_child_candy, right_child_candy ) + 1\\n```\\n\\n```\\ncase 1:For the minimum amount of all candies, each child will receive the minimum amount of candy possible (each child must have a minimum of 1 candy)\\ncase 2: Child with same rating can get minimum possible candies\\n```\\n```\\ncase 3: when  current_child_rating > left_child_rating \\n    then current_child_candy = left_child_candy + 1\\n```\\n**Let us take an example:**\\narr = [1, 0, 2]\\n1. for index 0 : because he is the first and don\\'t having left neighbor so we continue,\\n2. for index 1 : he is having left neighbor but because currnt child having low rating then left child he don\\'n get extra candy\\n3. for index 2 : he is having left neighbour and also high ratings then neighbor so he will get more candies then his neighbour \\n \\n    \\n```\\ncase 4: when  current_child_rating > right_child_rating \\n    then current_child_candy = right_child_candy + 1\\n```\\nnow we go from right to left:\\n1. for index 2: don\\'t have right child so continue,\\n2. for index 1: he is having right neighbor but don\\'t have high rating as compare to his right\\n3. for index 0: he is have right neighbor and also high rating then right neighbor so he will get more candy more candy as compare to right neighbor\\n\\n**but wait**...What if the current child has a higher rating than the left and right neighbors combined, and the left neighbor has more candies then the right neighbor? so to solve this problem we take max candy + 1\\n```\\nupdate case 4 : \\nwhen  current_child_rating > right_child_rating \\n    then current_child_candy = max (current_child_candy, right_child_candy + 1)\\n```\\nAnd finally we\\'ll add all the candy and return it.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {        \\n        int n = ratings.size();\\n        int total_candies =0;\\n        vector<int>candy(n,1);\\n        // case 1: Each child will get minimum 1 candy\\n        // case 2: children with same rating will get minimum candy.\\n\\n        for(int i=1;i<n;i++){\\n            // case 3: currend child having more rating left neighbor then he get more candy then left neighbor\\n            if( ratings[i] > ratings[i-1]) \\n                candy[i] = candy[i-1]+1;\\n        }\\n\\n        for(int i=n-1;i>=0;i--){\\n            // case 4: current child having more rating then right neighbor then he will get more candy then right child\\n            if( i<n-1 and ratings[i]>ratings[i+1])\\n                arr[i]=max(candy[i], candy[i+1]+1);\\n\\n            total_candies += candy[i];\\n            // add all the candies\\n        }\\n        \\n        return total_candies;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// so we can say that \\nif current_child_rating > left_child_rating or current_child_rating > right_child_rating \\nthen \\ncurrent_child_get_candy = max( left_child_candy, right_child_candy ) + 1\\n```\n```\\ncase 1:For the minimum amount of all candies, each child will receive the minimum amount of candy possible (each child must have a minimum of 1 candy)\\ncase 2: Child with same rating can get minimum possible candies\\n```\n```\\ncase 3: when  current_child_rating > left_child_rating \\n    then current_child_candy = left_child_candy + 1\\n```\n```\\ncase 4: when  current_child_rating > right_child_rating \\n    then current_child_candy = right_child_candy + 1\\n```\n```\\nupdate case 4 : \\nwhen  current_child_rating > right_child_rating \\n    then current_child_candy = max (current_child_candy, right_child_candy + 1)\\n```\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {        \\n        int n = ratings.size();\\n        int total_candies =0;\\n        vector<int>candy(n,1);\\n        // case 1: Each child will get minimum 1 candy\\n        // case 2: children with same rating will get minimum candy.\\n\\n        for(int i=1;i<n;i++){\\n            // case 3: currend child having more rating left neighbor then he get more candy then left neighbor\\n            if( ratings[i] > ratings[i-1]) \\n                candy[i] = candy[i-1]+1;\\n        }\\n\\n        for(int i=n-1;i>=0;i--){\\n            // case 4: current child having more rating then right neighbor then he will get more candy then right child\\n            if( i<n-1 and ratings[i]>ratings[i+1])\\n                arr[i]=max(candy[i], candy[i+1]+1);\\n\\n            total_candies += candy[i];\\n            // add all the candies\\n        }\\n        \\n        return total_candies;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919127,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int cnt = 0;\\n        vector<int> v(n, 1);\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) v[i] = max(v[i], v[i-1] + 1); \\n        }\\n        for(int i=n-2; i>=0; i--) {\\n            if(ratings[i] > ratings[i+1]) v[i] = max(v[i], v[i+1] + 1); \\n        }\\n        for(int i=0; i<n; i++) cnt += v[i];\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int cnt = 0;\\n        vector<int> v(n, 1);\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) v[i] = max(v[i], v[i-1] + 1); \\n        }\\n        for(int i=n-2; i>=0; i--) {\\n            if(ratings[i] > ratings[i+1]) v[i] = max(v[i], v[i+1] + 1); \\n        }\\n        for(int i=0; i<n; i++) cnt += v[i];\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754714,
                "title": "easy-to-understand-2-pass-solution",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/hard/greedy/Candy.java",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2589679,
                "title": "c-solution-solution-of-o-n-time-and-simple",
                "content": "```\\n  int candy(int* ra, int size){\\n    int a = 0;\\n    int s = size -1;\\n    int *r = malloc(4 * size);\\n    int *l = malloc(4 * size);\\n    l[0] = 1;\\n    r[size-1] = 1;\\n    for(int i = 1; i < size ; i++)\\n       l[i] = ra[i] > ra[i - 1] ? l[i - 1] + 1 :  1;\\n    for(int i = size - 2 ; i >=0 ; i--)\\n        r[i] = ra[i] > ra[i+1] ? r[i + 1] + 1 : 1;\\n    for(int i = 0 ; i < size ; i++)\\n       a += r[i] > l[i] ? r[i] :l[i];\\n    return a;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int candy(int* ra, int size){\\n    int a = 0;\\n    int s = size -1;\\n    int *r = malloc(4 * size);\\n    int *l = malloc(4 * size);\\n    l[0] = 1;\\n    r[size-1] = 1;\\n    for(int i = 1; i < size ; i++)\\n       l[i] = ra[i] > ra[i - 1] ? l[i - 1] + 1 :  1;\\n    for(int i = size - 2 ; i >=0 ; i--)\\n        r[i] = ra[i] > ra[i+1] ? r[i + 1] + 1 : 1;\\n    for(int i = 0 ; i < size ; i++)\\n       a += r[i] > l[i] ? r[i] :l[i];\\n    return a;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2238440,
                "title": "candy-java-o-n-tc-sc-easy-concept-greedy-solution-pre-computational-explanation",
                "content": "We keeps the track of the neighbour\\'s candy and stores it in the double array used, one from left side and other from right side using the greedy apporach which finally helps in getting the sum of the max of two values.\\nHere, values can be stored by using a precalculated value in the previous or, next array.\\n\\n\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int ans=0;\\n        int [] arr1=new int[ratings.length];\\n        int [] arr2=new int[ratings.length];\\n        for(int i=0;i<ratings.length;i++){\\n            arr1[i]++;\\n            arr2[i]++;\\n        }\\n        for(int i=0;i<ratings.length-1;i++){\\n            if(ratings[i]>ratings[i+1] && arr1[i]<=arr1[i+1]){\\n                arr1[i]=arr1[i+1]+1;\\n            }\\n            else if(ratings[i]<ratings[i+1] && arr1[i]>=arr1[i+1]){\\n                arr1[i+1]=arr1[i]+1;\\n            }\\n        }\\n        for(int i=ratings.length-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1] && arr2[i]<=arr2[i+1]){\\n                arr2[i]=arr2[i+1]+1;\\n            }\\n            else if(ratings[i]<ratings[i+1] && arr2[i]>=arr2[i+1]){\\n                arr2[i+1]=arr2[i]+1;\\n            }\\n        }\\n        for(int i=0;i<ratings.length;i++){\\n            ans+=Math.max(arr1[i],arr2[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\nKindly upvote, if you like it!!!",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int ans=0;\\n        int [] arr1=new int[ratings.length];\\n        int [] arr2=new int[ratings.length];\\n        for(int i=0;i<ratings.length;i++){\\n            arr1[i]++;\\n            arr2[i]++;\\n        }\\n        for(int i=0;i<ratings.length-1;i++){\\n            if(ratings[i]>ratings[i+1] && arr1[i]<=arr1[i+1]){\\n                arr1[i]=arr1[i+1]+1;\\n            }\\n            else if(ratings[i]<ratings[i+1] && arr1[i]>=arr1[i+1]){\\n                arr1[i+1]=arr1[i]+1;\\n            }\\n        }\\n        for(int i=ratings.length-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1] && arr2[i]<=arr2[i+1]){\\n                arr2[i]=arr2[i+1]+1;\\n            }\\n            else if(ratings[i]<ratings[i+1] && arr2[i]>=arr2[i+1]){\\n                arr2[i+1]=arr2[i]+1;\\n            }\\n        }\\n        for(int i=0;i<ratings.length;i++){\\n            ans+=Math.max(arr1[i],arr2[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236153,
                "title": "c-easy-left-and-right-traversal",
                "content": "\\t *****please upvote if you like \\u2764\\uD83D\\uDE0D\\n\\t class Solution {\\n\\tpublic:\\n    int candy(vector<int>& ratings) {\\n      int n=ratings.size();\\n        vector<int>v1(n,1),v2(n,1),ans;\\n        for(int i=1;i<n;i++){  // left to right\\n            if(ratings[i]>ratings[i-1])\\n                v1[i]+=v1[i-1];\\n        }\\n         for(int i=n-2;i>=0;i--){// right to left\\n            if(ratings[i]>ratings[i+1])\\n                v2[i]+=v2[i+1];\\n        }\\n        for(int i=0;i<n;i++){\\n            ans.push_back(max(v1[i],v2[i]));// take maximum no of candy in left and right vector\\n        }\\n        return accumulate(ans.begin(),ans.end(),0);//sum of all candies\\n        \\n    }\\n\\t };",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int candy(vector<int>& ratings) {\\n      int n=ratings.size();\\n        vector<int>v1(n,1),v2(n,1),ans;\\n        for(int i=1;i<n;i++){  // left to right\\n            if(ratings[i]>ratings[i-1])\\n                v1[i]+=v1[i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2236101,
                "title": "rust-o-n-time-o-1-space-using-functional-paradigm-0-ms",
                "content": "This corresponds to the \"slope\" solution. \\n\\n`front` denotes the number of candies at the \"front\". What is the front? It depends on the slope:\\n- if the slope is increasing or plateau-ing, the front is just the number of candies to give to the next kid;\\n- if the slope is decreasing, the front is the bottom of the slope - which is always `1`.\\n\\n`top` denotes the number of candies at the top of the hill, which is the element that is joining the previous (increasing) slope and the next (decreasing) slope.\\n\\nWhen we are in a decreasing slope, we need to make sure that we are not giving more candies to the kids in this slope than to the kid at the top. To ensure this, we record the number of kids in the slope aka `dec_count`. If there are `dec_count` kids in the slope, it means we should have given `dec_count` candies to the right neighbour of the `top` kid. Thus, since the `top` kid needs to have strictly more candies, he will end up having `dec_count + 1`.\\n\\nImplementation-wise, when we enter the decreasing slope, the top kid has whatever number of candies he had to satisfy the previous slope. Then we slide down the slope, and we count the kids: whenever the top kid has less than the current number of kids + 1, we give him one more candy. The code can be confusing: keep in mind that, on the ith iteration, we are not computing the number to give to the ith kid based on the i - 1 kid: we are computing the number of candies to give to the i + 1 th kid, and correcting the total number of candies `res` a posteriori after we witness that there is one more kid in the slope, and the top kid had fewer candies than what he should have. In a nutshell, we are simply correcting our mistake on the top kid by giving him more candies as needed, 1 by 1.\\n\\nComplexity: O(n) time - O(1) space\\n\\n```\\nuse std::cmp::{self, Ordering};\\n\\npub fn candy(ratings: Vec<i32>) -> i32 {\\n        ratings\\n        .windows(2)\\n        .map(|x| x[0].cmp(&x[1]))\\n        .fold((1, 1, 1, 0), |(res, front, top, dec_count): (i32, i32, i32, i32), x| {\\n           match x {\\n            Ordering::Greater => {\\n                if top <= dec_count + 1 {\\n                    (res + dec_count + 1 + 1, 1, top + 1, dec_count + 1)\\n                } else {\\n                    (res + dec_count + 1, 1, top, dec_count + 1)\\n                }\\n            },\\n            Ordering::Equal => {\\n                (res + 1, 1, 1, 0)\\n            },\\n            Ordering::Less => {\\n                (res + front + 1, front + 1, front + 1, 0)\\n            }\\n           } \\n        })\\n        .0\\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::{self, Ordering};\\n\\npub fn candy(ratings: Vec<i32>) -> i32 {\\n        ratings\\n        .windows(2)\\n        .map(|x| x[0].cmp(&x[1]))\\n        .fold((1, 1, 1, 0), |(res, front, top, dec_count): (i32, i32, i32, i32), x| {\\n           match x {\\n            Ordering::Greater => {\\n                if top <= dec_count + 1 {\\n                    (res + dec_count + 1 + 1, 1, top + 1, dec_count + 1)\\n                } else {\\n                    (res + dec_count + 1, 1, top, dec_count + 1)\\n                }\\n            },\\n            Ordering::Equal => {\\n                (res + 1, 1, 1, 0)\\n            },\\n            Ordering::Less => {\\n                (res + front + 1, front + 1, front + 1, 0)\\n            }\\n           } \\n        })\\n        .0\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2235477,
                "title": "c-array-greedy-easy-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n         int n = ratings.size();\\n        map<int,vector<int>> m;\\n        for(int i = 0;i<n;i++){\\n            m[ratings[i]].push_back(i);\\n        }\\n        vector<int> res(n,1);\\n        for(auto it : m){\\n            vector<int> index = it.second;\\n            int val = it.first;\\n            for(auto idx : index){\\n                int pre = (idx-1)<0?INT_MAX:ratings[idx-1];\\n                int preres = (idx-1)<0?INT_MIN:res[idx-1];\\n            \\n                int suc = (idx+1)>=n?INT_MAX:ratings[idx+1];\\n                int sucres = (idx+1)>=n?INT_MIN:res[idx+1];\\n            \\n                if(pre>val && suc>val) continue;\\n                if(pre<val && suc<val) res[idx] = max(preres,sucres)+1;\\n                else if(pre<val) res[idx] = preres+1;\\n                else if(suc<val) res[idx] = sucres+1;\\n            }\\n            \\n        }\\n        \\n        int ans = 0;\\n        for(auto it : res){\\n            ans += it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n         int n = ratings.size();\\n        map<int,vector<int>> m;\\n        for(int i = 0;i<n;i++){\\n            m[ratings[i]].push_back(i);\\n        }\\n        vector<int> res(n,1);\\n        for(auto it : m){\\n            vector<int> index = it.second;\\n            int val = it.first;\\n            for(auto idx : index){\\n                int pre = (idx-1)<0?INT_MAX:ratings[idx-1];\\n                int preres = (idx-1)<0?INT_MIN:res[idx-1];\\n            \\n                int suc = (idx+1)>=n?INT_MAX:ratings[idx+1];\\n                int sucres = (idx+1)>=n?INT_MIN:res[idx+1];\\n            \\n                if(pre>val && suc>val) continue;\\n                if(pre<val && suc<val) res[idx] = max(preres,sucres)+1;\\n                else if(pre<val) res[idx] = preres+1;\\n                else if(suc<val) res[idx] = sucres+1;\\n            }\\n            \\n        }\\n        \\n        int ans = 0;\\n        for(auto it : res){\\n            ans += it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234927,
                "title": "single-array-implementation-o-n-time-o-n-space-java",
                "content": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int candies[] = new int[n];\\n        candies[0] = 1;\\n        // left traversal to cover the left neighbour condition\\n        for(int i = 1; i < n; i ++)\\n        {\\n            candies[i] = 1;\\n            if(ratings[i - 1] < ratings[i])\\n            {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        \\n        // Right Traversal to cover the right neighbour\\n        for(int i = n - 1; i >=1 ; i--)\\n        {\\n            if(ratings[i - 1] > ratings[i] && candies[i-1] <= candies[i] )\\n            {\\n                candies[i - 1] = candies[i] + 1;\\n            }\\n        }\\n        int res = 0;\\n        for(int a: candies) res += a;\\n        return res;\\n    }\\n}\\n```\\n\\n**If you like Please Upvote the solution**\\n\\n**Feel Free to Suggest any optimization possible**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int candies[] = new int[n];\\n        candies[0] = 1;\\n        // left traversal to cover the left neighbour condition\\n        for(int i = 1; i < n; i ++)\\n        {\\n            candies[i] = 1;\\n            if(ratings[i - 1] < ratings[i])\\n            {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        \\n        // Right Traversal to cover the right neighbour\\n        for(int i = n - 1; i >=1 ; i--)\\n        {\\n            if(ratings[i - 1] > ratings[i] && candies[i-1] <= candies[i] )\\n            {\\n                candies[i - 1] = candies[i] + 1;\\n            }\\n        }\\n        int res = 0;\\n        for(int a: candies) res += a;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234683,
                "title": "priority-queue-solution",
                "content": "Although it takes more running time and space than optimal solution, thought of sharing it.\\n\\nThe approach I came up with was to assign candies first to give minimum rating candidates. Then we use it to give candidates to higher rated candidates.\\n\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>  pq;\\n        vector<int> v(ratings.size(), 1);\\n        int ans = 0;\\n        \\n        for ( int i = 0; i < ratings.size(); i++ ) pq.push( { ratings[i], i } );\\n        \\n        while ( !pq.empty() ) {\\n            \\n            int rate = pq.top().first, ind = pq.top().second;\\n            pq.pop();\\n            \\n            \\n            if ( ind < ratings.size() - 1 && ind > 0 && rate > ratings[ind - 1] && rate > ratings[ind + 1] ) {\\n                v[ind] = max(v[ind - 1], v[ind + 1]) + 1;\\n            } else if ( ind < ratings.size() - 1 && rate > ratings[ind + 1] ) {\\n                v[ind] = v[ind + 1] + 1;\\n            } else if ( ind > 0 && rate > ratings[ind - 1] ) {\\n                v[ind] = v[ind - 1] + 1;\\n            }\\n            \\n        }\\n        \\n        \\n        ans = accumulate(v.begin(), v.end(), 0);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>  pq;\\n        vector<int> v(ratings.size(), 1);\\n        int ans = 0;\\n        \\n        for ( int i = 0; i < ratings.size(); i++ ) pq.push( { ratings[i], i } );\\n        \\n        while ( !pq.empty() ) {\\n            \\n            int rate = pq.top().first, ind = pq.top().second;\\n            pq.pop();\\n            \\n            \\n            if ( ind < ratings.size() - 1 && ind > 0 && rate > ratings[ind - 1] && rate > ratings[ind + 1] ) {\\n                v[ind] = max(v[ind - 1], v[ind + 1]) + 1;\\n            } else if ( ind < ratings.size() - 1 && rate > ratings[ind + 1] ) {\\n                v[ind] = v[ind + 1] + 1;\\n            } else if ( ind > 0 && rate > ratings[ind - 1] ) {\\n                v[ind] = v[ind - 1] + 1;\\n            }\\n            \\n        }\\n        \\n        \\n        ans = accumulate(v.begin(), v.end(), 0);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122040,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Greedy***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        \\n        int n = ratings.size();\\n        \\n        vector<int> left(n, 1);\\n        \\n        vector<int> right(n, 1);\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(ratings[i] > ratings[i - 1])\\n            {\\n                left[i] += left[i - 1];\\n            }\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            if(ratings[i] > ratings[i + 1])\\n            {\\n                right[i] += right[i + 1];\\n            }\\n        }\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            count += max(left[i], right[i]);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        \\n        int n = ratings.size();\\n        \\n        vector<int> left(n, 1);\\n        \\n        vector<int> right(n, 1);\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(ratings[i] > ratings[i - 1])\\n            {\\n                left[i] += left[i - 1];\\n            }\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            if(ratings[i] > ratings[i + 1])\\n            {\\n                right[i] += right[i + 1];\\n            }\\n        }\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            count += max(left[i], right[i]);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481857,
                "title": "python-simple-solution-greedy-approach-forward-and-backward-iteration",
                "content": "```\\nclass Solution:\\n    def backwardDistribution(self, ratings, start, end, candies):\\n        # Assign the max of current candies and one more then the next student candies to the current student if ratings of current student is more then the ratings of next student.\\n        for i in range(end - 1, start - 1, -1):\\n            if ratings[i] > ratings[i + 1]:\\n                candies[i] = max(candies[i], candies[i + 1] + 1)\\n    \\n    def forwardDistribution(self, ratings, start, end, candies):\\n        # Assign 1 candy more then the previous student to the current student if the ratings of current student is more then the previous student.\\n        for i in range(start, end):\\n            if ratings[i] > ratings[i - 1]:\\n                candies[i] = candies[i - 1] + 1\\n\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        candies = [1] * n\\n        self.forwardDistribution(ratings, 1, n, candies)\\n        self.backwardDistribution(ratings, 0, n - 1, candies)\\n        return sum(candies)\\n```\\n\\n***If you likes the above solution the please upvote!***",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def backwardDistribution(self, ratings, start, end, candies):\\n        # Assign the max of current candies and one more then the next student candies to the current student if ratings of current student is more then the ratings of next student.\\n        for i in range(end - 1, start - 1, -1):\\n            if ratings[i] > ratings[i + 1]:\\n                candies[i] = max(candies[i], candies[i + 1] + 1)\\n    \\n    def forwardDistribution(self, ratings, start, end, candies):\\n        # Assign 1 candy more then the previous student to the current student if the ratings of current student is more then the previous student.\\n        for i in range(start, end):\\n            if ratings[i] > ratings[i - 1]:\\n                candies[i] = candies[i - 1] + 1\\n\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        candies = [1] * n\\n        self.forwardDistribution(ratings, 1, n, candies)\\n        self.backwardDistribution(ratings, 0, n - 1, candies)\\n        return sum(candies)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322217,
                "title": "java-solution-0ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        \\n        int[] candies = new int[ratings.length];\\n        \\n        for(int i=0; i<candies.length; i++) candies[i] = 1;\\n        \\n        for(int i=0; i<ratings.length-1; i++) {\\n            if(ratings[i+1]>ratings[i]) candies[i+1]=candies[i]+1;\\n        }\\n        \\n        for(int i=ratings.length-1; i>0; i--) {\\n            if(ratings[i-1]>ratings[i]) {\\n                if(candies[i-1]<candies[i]+1) candies[i-1]=candies[i]+1; \\n            }\\n        }\\n        \\n        int total = 0;\\n        \\n        for(int i=0; i<candies.length; i++) total+=candies[i];\\n        \\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        \\n        int[] candies = new int[ratings.length];\\n        \\n        for(int i=0; i<candies.length; i++) candies[i] = 1;\\n        \\n        for(int i=0; i<ratings.length-1; i++) {\\n            if(ratings[i+1]>ratings[i]) candies[i+1]=candies[i]+1;\\n        }\\n        \\n        for(int i=ratings.length-1; i>0; i--) {\\n            if(ratings[i-1]>ratings[i]) {\\n                if(candies[i-1]<candies[i]+1) candies[i-1]=candies[i]+1; \\n            }\\n        }\\n        \\n        int total = 0;\\n        \\n        for(int i=0; i<candies.length; i++) total+=candies[i];\\n        \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301435,
                "title": "python-solution",
                "content": "Hope it helps\\n\\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        candies = [1] * n\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i - 1]:\\n                candies[i] = candies[i - 1] + 1\\n        for i in range(n - 1, 0, -1):\\n            if ratings[i] < ratings[i - 1] and candies[i] >= candies[i - 1]:\\n                candies[i - 1] = candies[i] + 1\\n        return sum(candies)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        candies = [1] * n\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i - 1]:\\n                candies[i] = candies[i - 1] + 1\\n        for i in range(n - 1, 0, -1):\\n            if ratings[i] < ratings[i - 1] and candies[i] >= candies[i - 1]:\\n                candies[i - 1] = candies[i] + 1\\n        return sum(candies)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300753,
                "title": "python",
                "content": "```\\ndef candy(self, ratings: List[int]) -> int:\\n        record = [1]*len(ratings)\\n        for i in range(1,len(ratings)):\\n            if ratings[i]>ratings[i-1]:\\n                record[i] = record[i-1]+1\\n\\n        for j in range(len(ratings)-2,-1,-1):\\n            if ratings[j]>ratings[j+1]:\\n                record[j] = max(record[j], record[j+1]+1)   \\n        return sum(record)",
                "solutionTags": [],
                "code": "```\\ndef candy(self, ratings: List[int]) -> int:\\n        record = [1]*len(ratings)\\n        for i in range(1,len(ratings)):\\n            if ratings[i]>ratings[i-1]:\\n                record[i] = record[i-1]+1\\n\\n        for j in range(len(ratings)-2,-1,-1):\\n            if ratings[j]>ratings[j+1]:\\n                record[j] = max(record[j], record[j+1]+1)   \\n        return sum(record)",
                "codeTag": "Python3"
            },
            {
                "id": 841226,
                "title": "c-o-n-52ms",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int>ans(ratings.size(),1);\\n        for(int i=1;i<ratings.size();i++)\\n            if(ratings[i]>ratings[i-1])\\n                ans[i]=ans[i-1]+1;\\n        for(int i=ratings.size()-2;i>=0;i--)\\n            if(ratings[i]>ratings[i+1])\\n                ans[i]=max(ans[i],ans[i+1]+1);\\n        int sum=0;\\n        for(int s:ans)\\n            sum+=s;\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int>ans(ratings.size(),1);\\n        for(int i=1;i<ratings.size();i++)\\n            if(ratings[i]>ratings[i-1])\\n                ans[i]=ans[i-1]+1;\\n        for(int i=ratings.size()-2;i>=0;i--)\\n            if(ratings[i]>ratings[i+1])\\n                ans[i]=max(ans[i],ans[i+1]+1);\\n        int sum=0;\\n        for(int s:ans)\\n            sum+=s;\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394961,
                "title": "simple-three-pass-javascript-solution-o-3n-o-n",
                "content": "This solution goes through the ratings array forward and sets the first value to 1, then if the next value is greater then its immidiate previous one, the candy allocated to that one is 1 greater than the previous. Then it iterates through the ratings array again, backward, in order to cover the values that were less than their previous value. This time, it sets the value to one greater than its previous if the ratings is higher, or to the current candy amount, whichever is larger. \\n\\nThen it goes through the candy array and sums up all of the values\\n\\n```\\nvar candy = function(ratings) {\\n    var candies = [], i;\\n    var currentNum = 1;\\n    candies[0] = 1; // set first value to 1\\n    for(i = 1; i < ratings.length; i++){\\n\\t\\t/* set value to one greater if greater than previous value, otherwise to 1 */\\n        if (ratings[i] > ratings[i-1]) currentNum++;\\n        else currentNum = 1;\\n        candies[i] = currentNum;\\n    }\\n    for(i = ratings.length - 2; i >= 0; i--){\\n\\t\\t/* set value to max of one greater than previous or to current value */\\n        if (ratings[i] > ratings[i+1]) currentNum++;\\n        else currentNum = 1;\\n        candies[i] = Math.max(currentNum, candies[i]);\\n    }\\n\\t/* return sum of all candies array */\\n    return candies.reduce(function(total, value){\\n        return total + value;\\n    });\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar candy = function(ratings) {\\n    var candies = [], i;\\n    var currentNum = 1;\\n    candies[0] = 1; // set first value to 1\\n    for(i = 1; i < ratings.length; i++){\\n\\t\\t/* set value to one greater if greater than previous value, otherwise to 1 */\\n        if (ratings[i] > ratings[i-1]) currentNum++;\\n        else currentNum = 1;\\n        candies[i] = currentNum;\\n    }\\n    for(i = ratings.length - 2; i >= 0; i--){\\n\\t\\t/* set value to max of one greater than previous or to current value */\\n        if (ratings[i] > ratings[i+1]) currentNum++;\\n        else currentNum = 1;\\n        candies[i] = Math.max(currentNum, candies[i]);\\n    }\\n\\t/* return sum of all candies array */\\n    return candies.reduce(function(total, value){\\n        return total + value;\\n    });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166568,
                "title": "very-simple-greedy-solution-python",
                "content": "```\\nclass Solution:\\n    def candy(self, ratings):\\n        candies = [1]*len(ratings)\\n        give(ratings, candies)\\n        ratings.reverse()\\n        candies.reverse()\\n        give(ratings, candies)\\n        return sum(candies)\\n\\ndef give(ratings, candies):\\n    for i in range(len(ratings)):\\n        if i > 0 and ratings[i] > ratings[i-1]:\\n            candies[i] = max(candies[i], candies[i-1] + 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings):\\n        candies = [1]*len(ratings)\\n        give(ratings, candies)\\n        ratings.reverse()\\n        candies.reverse()\\n        give(ratings, candies)\\n        return sum(candies)\\n\\ndef give(ratings, candies):\\n    for i in range(len(ratings)):\\n        if i > 0 and ratings[i] > ratings[i-1]:\\n            candies[i] = max(candies[i], candies[i-1] + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157649,
                "title": "java-one-pass-o-1-space-easy-to-understand-version",
                "content": "If you draw all the rating points on a graph, there are peaks and bottoms and apparently:\\n\\n1. All the bottoms should be given 1 candy in the final result.\\n2. The neighbors of the bottoms should be given 1 more candy as we move from bottom point to peak point.\\n\\nFor example if you have an array [1,2,4,3,2,1], bottoms are the 1s on both sides and the peak is 4, both 1s should be given 1 candy and their neighbors 2s should be given 1+1=2 candies. Likewise, 3 should be given 2+1=3 candies and 4 which is the peak should be given 4 candies. If we know the lengths from the peak to bottom on both sides, we can figure out how many candies should be given to the peak (Math.max(left, right)) and the total candies needed for the array. For the above example, the length on the left is 2 ([1,2] peak not included) and length on the right is 3([3,2,1] peak not included), thus the peak should be assign Math.max(left, right)+1 candies and the total candies needed for the array will be (1+left)*left/2 + (1+right)*right/2 + peak. In the codes below, we minus it by 1 because the left bottom was calculated once in the previous round.\\n\\nIn real test cases, we can have array with multiple peaks and bottoms. For example: [1,2,4,3,2,1,5,6,9,4,2]. In this case, we just split the array by the bottoms and calculate each sub arr and merge the result. \\n[1,2,4,3,2,1,5,6,9,4,2] -> [1,2,4,3,2,1] and [1,5,6,9,4,2]\\nFor rating with same value, we just add 1 to the result.\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        if(ratings == null || ratings.length == 0) return 0;\\n        int n = ratings.length;\\n        int i = 0;\\n        int s = 0; //record the start index of the left and right sides of the peaks\\n        int sum = 1; //initialize as 1 because in each round we minus 1 for the left bottom \\n                   //since it was calculated once in the previous round\\n        while(i < n-1){\\n            //calculate the length from bottom -> peak on the left side of peak point, peak not included\\n            while(i < n-1 && ratings[i+1] > ratings[i]){\\n                i++;\\n            }\\n            int left = i-s;\\n            s = i;\\n            //calculate the length from peak-> bottom on the right side of peak point, peak not included\\n            while(i < n-1 && ratings[i+1] < ratings[i]){\\n                i++;\\n            }\\n            int right = i-s;\\n            s = i;\\n            //calculate the candies that needs to be assign to the peak\\n            int max = Math.max(left, right)+1;\\n            //total candies needed for current bottom->peak->bottom sub array\\n            sum += (1+left)*left/2+(1+right)*right/2+max-1;\\n            //skip points that have same value, increase i and final result by 1\\n            while(i < n-1 && ratings[i+1] == ratings[i]){\\n                i++;\\n                sum++;\\n            }\\n            s = i;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        if(ratings == null || ratings.length == 0) return 0;\\n        int n = ratings.length;\\n        int i = 0;\\n        int s = 0; //record the start index of the left and right sides of the peaks\\n        int sum = 1; //initialize as 1 because in each round we minus 1 for the left bottom \\n                   //since it was calculated once in the previous round\\n        while(i < n-1){\\n            //calculate the length from bottom -> peak on the left side of peak point, peak not included\\n            while(i < n-1 && ratings[i+1] > ratings[i]){\\n                i++;\\n            }\\n            int left = i-s;\\n            s = i;\\n            //calculate the length from peak-> bottom on the right side of peak point, peak not included\\n            while(i < n-1 && ratings[i+1] < ratings[i]){\\n                i++;\\n            }\\n            int right = i-s;\\n            s = i;\\n            //calculate the candies that needs to be assign to the peak\\n            int max = Math.max(left, right)+1;\\n            //total candies needed for current bottom->peak->bottom sub array\\n            sum += (1+left)*left/2+(1+right)*right/2+max-1;\\n            //skip points that have same value, increase i and final result by 1\\n            while(i < n-1 && ratings[i+1] == ratings[i]){\\n                i++;\\n                sum++;\\n            }\\n            s = i;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42828,
                "title": "40-ms-cpp-dp-solution",
                "content": "    class Solution {\\n        vector<int> dp;\\n        int min_candy(int k,vector<int>& ratings){\\n            dp[k]=1;\\n            if(k>0 && ratings[k]>ratings[k-1]) dp[k] = max(dp[k],(dp[k-1]>0?dp[k-1]:min_candy(k-1,ratings))+1);\\n            if(k<ratings.size()-1 && ratings[k]>ratings[k+1]) dp[k] = max(dp[k],(dp[k+1]>0?dp[k+1]:min_candy(k+1,ratings))+1);\\n            return dp[k];\\n        }\\n    public:\\n        int candy(vector<int>& ratings) {\\n            if(ratings.empty()) return 0;\\n            dp.assign(ratings.size(),0);\\n            int sum = 0;\\n            for(int i=0;i<ratings.size();i++) sum += dp[i]>0?dp[i]:min_candy(i,ratings);\\n            return sum;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        vector<int> dp;\\n        int min_candy(int k,vector<int>& ratings){\\n            dp[k]=1;\\n            if(k>0 && ratings[k]>ratings[k-1]) dp[k] = max(dp[k],(dp[k-1]>0?dp[k-1]:min_candy(k-1,ratings))+1);\\n            if(k<ratings.size()-1 && ratings[k]>ratings[k+1]) dp[k] = max(dp[k],(dp[k+1]>0?dp[k+1]:min_candy(k+1,ratings))+1);\\n            return dp[k];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 42836,
                "title": "o-n-time-constant-space-beats-90-in-c",
                "content": "\\n    if (ratings.size() <= 1) return ratings.size();\\n        int left=0, right=0, pos=0, n=ratings.size(), sum=0;\\n        while(left < n) {\\n        \\tint i, lval = 1, rval;\\n        \\tif(left!=0 && ratings[left]>ratings[left-1]) lval++;\\n        \\tfor(i = left+1; i<n && ratings[i]>ratings[i-1]; i++) {// gradient increase\\n        \\t\\tsum += lval;\\n        \\t\\tif (ratings[i] > ratings[i-1]) lval++;\\n        \\t}\\n        \\tpos = --i; // find local max\\n        \\tfor(right = i+1; right<n && ratings[right]<ratings[right-1]; right++); // gradient decrease\\n        \\tright--; // right point to the last local decrease element\\n        \\tfor(i = right, rval = 1; i > pos; i--) {\\n        \\t\\tsum += rval;\\n        \\t\\tif (ratings[i] < ratings[i-1]) {\\n        \\t\\t\\trval++;\\n        \\t\\t}\\n        \\t}\\n        \\tsum += max(max(lval, rval), 1);\\n        \\tleft = right+1;\\n        }\\n        return sum;\\n\\nI know my code may look ugly... =\\u3002=",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "\\n    if (ratings.size() <= 1) return ratings.size();\\n        int left=0, right=0, pos=0, n=ratings.size(), sum=0;\\n        while(left < n) {\\n        \\tint i, lval = 1, rval;\\n        \\tif(left!=0 && ratings[left]>ratings[left-1]) lval++;\\n        \\tfor(i = left+1; i<n && ratings[i]>ratings[i-1]; i++) {// gradient increase\\n        \\t\\tsum += lval;\\n        \\t\\tif (ratings[i] > ratings[i-1]) lval++;\\n        \\t}\\n        \\tpos = --i; // find local max\\n        \\tfor(right = i+1; right<n && ratings[right]<ratings[right-1]; right++); // gradient decrease\\n        \\tright--; // right point to the last local decrease element\\n        \\tfor(i = right, rval = 1; i > pos; i--) {\\n        \\t\\tsum += rval;\\n        \\t\\tif (ratings[i] < ratings[i-1]) {\\n        \\t\\t\\trval++;\\n        \\t\\t}\\n        \\t}\\n        \\tsum += max(max(lval, rval), 1);\\n        \\tleft = right+1;\\n        }\\n        return sum;\\n\\nI know my code may look ugly... =\\u3002=",
                "codeTag": "Unknown"
            },
            {
                "id": 42841,
                "title": "5ms-o-n-ac-solution-with-comments",
                "content": "public int candy(int[] ratings) {\\n\\t\\n\\tint candies[] = new int[ratings.length];\\n\\tcandies[0] = 1;//no need to initialize whole array, we only need the first for the first pass\\n\\n\\t// left to right\\n\\tfor (int i = 1; i < ratings.length; i++) {\\n\\t    // left neighbor\\n\\t    if (ratings[i - 1] < ratings[i])\\n\\t\\tcandies[i] = candies[i - 1] + 1;\\n\\t    else\\n\\t\\tcandies[i] = 1;\\n\\t}\\n\\n\\tint candy = candies[ratings.length - 1]; // second pass, now we add up the candies for the return value\\n\\n\\t// right to left\\n\\tfor (int i = ratings.length - 2; i >= 0; i--) {\\n\\t    // right neighbor\\n\\t    if (ratings[i + 1] < ratings[i] && (candies[i] < candies[i + 1] + 1))//right neighbor could have lower have less candy than i already has\\n\\t\\tcandies[i] = candies[i + 1] + 1;\\n\\n\\t    candy += candies[i];\\n\\t}\\n\\treturn candy;\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int candy(int[] ratings) {\\n\\t\\n\\tint candies[] = new int[ratings.length];\\n\\tcandies[0] = 1;//no need to initialize whole array, we only need the first for the first pass\\n\\n\\t// left to right\\n\\tfor (int i = 1; i < ratings.length; i++) {\\n\\t    // left neighbor\\n\\t    if (ratings[i - 1] < ratings[i])\\n\\t\\tcandies[i] = candies[i - 1] + 1;\\n\\t    else\\n\\t\\tcandies[i] = 1;\\n\\t}\\n\\n\\tint candy = candies[ratings.length - 1]; // second pass, now we add up the candies for the return value\\n\\n\\t// right to left\\n\\tfor (int i = ratings.length - 2; i >= 0; i--) {\\n\\t    // right neighbor\\n\\t    if (ratings[i + 1] < ratings[i] && (candies[i] < candies[i + 1] + 1))//right neighbor could have lower have less candy than i already has\\n\\t\\tcandies[i] = candies[i + 1] + 1;\\n\\n\\t    candy += candies[i];\\n\\t}\\n\\treturn candy;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 42892,
                "title": "simple-2-pass-python-code",
                "content": "Never take some guess for granted!\\n[1, 2, 2] is not 5, should be 4!\\n\\nUseq/Dseq stores one should have ?+1 candies since he/her has higher rating than left/right neighbor!\\n\\n    class Solution:\\n        # @param {integer[]} ratings\\n        # @return {integer}\\n        def candy(self, ratings):\\n            n = len(ratings)\\n            Useq = [0 for i in range(n)]\\n            for i in xrange(1, n):\\n                if ratings[i]>ratings[i-1]:\\n                    Useq[i] = Useq[i-1]+1\\n            \\n            Dseq = [0 for i in range(n)]\\n            for i in xrange(n-2, -1, -1):  #from i = n-2, ... 1, 0 ## will not reach -1!!\\n                if ratings[i]>ratings[i+1]:\\n                    Dseq[i] = Dseq[i+1]+1\\n            \\n            candies = [max(Useq[i], Dseq[i])+1 for i in range(n)]\\n            return sum(candies)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 42910,
                "title": "share-an-alternative-solution-by-using-a-stack",
                "content": "Though the smartest solution to this problem is the two-pass solution, I have come up with a stack-based solution which requires O(n) space. It can be further optimized to eliminate the stack structure.\\n\\nThe idea is as follows: assign as few candies as possible. First assign 1 candy to the first kid, then go through the kid one by one. If we encounter kids in increasing rating value, we simply increment the candy number for each kid and we are done. But if we encounter kids in decreasing rating value, we need to fix previous candy values to avoid zero or negative candies to the current kid. Thus I use a stack to keep track of the kids with decreasing ratings, so that we can give more candies to them when the 2nd requirement is violated. I use a subroutine `clearStack` to count the actual number of candies required for these kids. For each kid, there are three cases:\\n\\n1. current kid has higher rating than previous kid: in this case, we assign one more candy to this kid. Also pop all previous kids out (and count candies for them), and push current kid's candy number\\n2. current kid has equal rating to previous kid: we just assign 1 candy to this kid. Use the same stack operation as 1.\\n3. current kid has less rating to previous kid: we also assign only 1 candy to this kid temporarily, and push it to stack (to be fixed later)\\n\\nI also use a sentinel in the end of ratings to trigger `clearStack` at the last element.\\n\\nCode is as follows:\\n\\n\\n    class Solution {\\n    public:\\n        int candy(vector<int>& ratings) {\\n            ratings.insert(ratings.end(), INT_MAX); //sentinel at the end\\n            \\n            int n = ratings.size();\\n            if(n <= 1) return n; //corner cases\\n            \\n            int sum(0); //total number of candies\\n            int curr(0); //number of candies for current kid\\n            \\n            stack<int> s;\\n            s.push(1); //candy for the first kid\\n            for(int k = 1; k < n; ++k) {\\n                if(ratings[k] >= ratings[k-1]) { //current higher or equal than previous\\n                    if(ratings[k] == ratings[k-1]) curr = 1; \\n                    else curr = s.top()+1;\\n                    sum += clearStack(s); //count all previous\\n                    s.push(curr); //push current candy number in stack (don't count yet)\\n                } else { //lower than previous\\n                    s.push(1); //just give one candy to this kid, don't count yet\\n                }\\n            }\\n    \\n            return sum;\\n        }\\n        \\n        //count the actual number of candies of kids in the stack\\n        int clearStack(stack<int>& s) {\\n            int sum = 0;\\n            int curr(0), last(0);\\n            while(!s.empty()) {\\n                int curr = s.top(); s.pop();\\n                if(curr <= last) curr = last+1;\\n                sum += curr;\\n                last = curr;\\n            }\\n            return sum;\\n        }\\n    };",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n    public:\\n        int candy(vector<int>& ratings) {\\n            ratings.insert(ratings.end(), INT_MAX); //sentinel at the end\\n            \\n            int n = ratings.size();\\n            if(n <= 1) return n; //corner cases\\n            \\n            int sum(0); //total number of candies\\n            int curr(0); //number of candies for current kid\\n            \\n            stack<int> s;\\n            s.push(1); //candy for the first kid\\n            for(int k = 1; k < n; ++k) {\\n                if(ratings[k] >= ratings[k-1]) { //current higher or equal than previous\\n                    if(ratings[k] == ratings[k-1]) curr = 1; \\n                    else curr = s.top()+1;\\n                    sum += clearStack(s); //count all previous\\n                    s.push(curr); //push current candy number in stack (don't count yet)\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 42914,
                "title": "c-o-n-solution",
                "content": "    class Solution {\\n    public:\\n        int candy(vector<int> &ratings) {\\n            int sz=ratings.size();\\n            vector<int> scan0(sz);\\n            vector<int> scan1(sz);\\n            \\n            scan0[0] = 1; scan1[sz-1] = 1;\\n            for (int i=1; i<sz; i++) {\\n                scan0[i] = (ratings[i]>ratings[i-1] ? scan0[i-1]+1 : 1);\\n                scan1[sz-1-i] = (ratings[sz-1-i]>ratings[sz-i] ? scan1[sz-i]+1 : 1);\\n            }\\n            int sum = 0;\\n            for (int i=0; i<sz; i++) {\\n                sum += max(scan0[i], scan1[i]);\\n            }\\n            \\n            return sum;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int candy(vector<int> &ratings) {\\n            int sz=ratings.size();\\n            vector<int> scan0(sz);\\n            vector<int> scan1(sz);\\n            \\n            scan0[0] = 1; scan1[sz-1] = 1;\\n            for (int i=1; i<sz; i++) {\\n                scan0[i] = (ratings[i]>ratings[i-1] ? scan0[i-1]+1 : 1);\\n                scan1[sz-1-i] = (ratings[sz-1-i]>ratings[sz-i] ? scan1[sz-i]+1 : 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4040643,
                "title": "candy-c-solution",
                "content": "# Approach\\nTwo Pass Approach\\n\\nSteps\\n\\nInitialize variables:\\nn is number of children.\\ncandies to store candies for each child..\\n\\nFirst Pass (Left to Right):\\nFor each child, check if the previous child has a lower rating and has more or equal candies.\\nIf true, give the current child one more candy than the previous child.\\n\\nSecond Pass (Right to Left):\\nFor each child, check if the next child has a lower rating and has more or equal candies.\\n\\nIf true, give the current child one more candy than the next child.\\nCalculate and return totalCandies.\\nComplexity\\n\\n# Complexity\\n- Time complexity: O(N)O(N)O(N)\\nSince we are looping over the ratings array twice then the time complexity is 2*N which is O(N).\\n\\n- Space complexity: O(N)O(N)O(N)\\nSince we are storing the number of candies for each child then the space complexity is O(N).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        \\n        vector<int> candies(n, 1); \\n        \\n        for(int i = 1; i < n; i++){\\n            if(ratings[i - 1] < ratings[i] && candies[i - 1] >= candies[i]){\\n            \\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--){\\n            if(ratings[i + 1] < ratings[i] && candies[i + 1] >= candies[i]){\\n            \\n                candies[i] = candies[i + 1] + 1;\\n            }\\n        }\\n        \\n        int totalCandies = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            totalCandies += candies[i];\\n        }\\n        \\n        return totalCandies;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        \\n        vector<int> candies(n, 1); \\n        \\n        for(int i = 1; i < n; i++){\\n            if(ratings[i - 1] < ratings[i] && candies[i - 1] >= candies[i]){\\n            \\n                candies[i] = candies[i - 1] + 1;\\n            }\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--){\\n            if(ratings[i + 1] < ratings[i] && candies[i + 1] >= candies[i]){\\n            \\n                candies[i] = candies[i + 1] + 1;\\n            }\\n        }\\n        \\n        int totalCandies = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            totalCandies += candies[i];\\n        }\\n        \\n        return totalCandies;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040505,
                "title": "python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def candy(self, rating: List[int]) -> int:\\n        cand=[1]*len(rating)\\n        for i in range(1,len(cand)):\\n            if rating[i]>rating[i-1]:\\n                if cand[i]<=cand[i-1]:\\n                    cand[i]=max(cand[i],cand[i-1]+1)\\n        print(cand)\\n        for i in range(len(cand)-2, -1, -1):\\n            if rating[i]>rating[i+1]:\\n                if cand[i]<=cand[i+1]:\\n                    cand[i]=max(cand[i],cand[i+1]+1)\\n        print(cand)\\n        return sum(cand)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, rating: List[int]) -> int:\\n        cand=[1]*len(rating)\\n        for i in range(1,len(cand)):\\n            if rating[i]>rating[i-1]:\\n                if cand[i]<=cand[i-1]:\\n                    cand[i]=max(cand[i],cand[i-1]+1)\\n        print(cand)\\n        for i in range(len(cand)-2, -1, -1):\\n            if rating[i]>rating[i+1]:\\n                if cand[i]<=cand[i+1]:\\n                    cand[i]=max(cand[i],cand[i+1]+1)\\n        print(cand)\\n        return sum(cand)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040195,
                "title": "one-pass-betch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n You can really put two brain cells together to see that two loops are running same number of times, just one forward and one backward, so we can fit that into one loop and not be a betch about it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe basic thing is whenever we see any rating of a child with higher rating than neighbour, we need on more candy than that neighbour, if not that child is already getting more, so we store the maximized value of candies for each child in the vector. Lastly, we return the sum with a little accumulate function and save ourselves from being a betch again by nothaving to write another 3-4 lines of code.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the number of children in your basement.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ an extra array to calculate the result, technically the array is the result, but sneekily these mfs asked for the sum only, so this array counts as extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& r) {\\n        int n=r.size();vector<int> v(n,1);\\n        for(int i=1;i<n;i++){   int j=n-i-1;\\n            if(r[i]>r[i-1]) v[i]=max(v[i],v[i-1]+1);\\n            if(r[j]>r[j+1]) v[j]=max(v[j],v[j+1]+1);\\n        }return(accumulate(v.begin(),v.end(),0));\\n    }\\n};\\n```\\n\\n_**UPVOTE IF NOT BETCH**_",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& r) {\\n        int n=r.size();vector<int> v(n,1);\\n        for(int i=1;i<n;i++){   int j=n-i-1;\\n            if(r[i]>r[i-1]) v[i]=max(v[i],v[i-1]+1);\\n            if(r[j]>r[j+1]) v[j]=max(v[j],v[j+1]+1);\\n        }return(accumulate(v.begin(),v.end(),0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039284,
                "title": "c-simple-two-loops-o-n",
                "content": "\\n# Approach\\n**two loops**\\nThe first loop from left to right, starting from the ratings[1], ensures children with a higher rating get more candy than its left neighbor.\\nThe second loop from right to left, starting from the ratings[size - 2], ensures that each children with a higher rating get more candy than its right neighbor.\\n\\n**extra check** \\nEach comparison also needs to check whether the candy has met the conditions, otherwise there may be a situation where the current number of candies decreases while hoping increase. For example:\\n\\nratings[1,2,3,4,5,2] after first loop, the candy should be [1,2,3,4,5,1]. Then during the second loop, we find 5 > 2, and try to make candy[4] = candy[5] + 1 = 2, but that will change the results of the first loop. In fact candy[4] = 5 just meet the requirement, so we continue.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int> candy(ratings.size(), 1);\\n        for(int i = 1; i < ratings.size(); i++) {\\n            if(ratings[i] > ratings[i - 1]) {\\n                candy[i] = candy[i - 1] + 1;\\n            }\\n        }\\n        for(int i = ratings.size() - 2; i > -1; i--) {\\n            if(ratings[i] > ratings[i + 1] && candy[i] <= candy[i + 1]) {\\n                candy[i] = candy[i + 1] + 1;\\n            } \\n        }\\n        return accumulate(candy.begin(), candy.end(), 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int> candy(ratings.size(), 1);\\n        for(int i = 1; i < ratings.size(); i++) {\\n            if(ratings[i] > ratings[i - 1]) {\\n                candy[i] = candy[i - 1] + 1;\\n            }\\n        }\\n        for(int i = ratings.size() - 2; i > -1; i--) {\\n            if(ratings[i] > ratings[i + 1] && candy[i] <= candy[i + 1]) {\\n                candy[i] = candy[i + 1] + 1;\\n            } \\n        }\\n        return accumulate(candy.begin(), candy.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038405,
                "title": "o-n-beginner-friendly-100-beats-fully-explained",
                "content": "# Intuition\\nThe problem requires distributing candies to a line of children based on their ratings while satisfying two conditions: each child must have at least one candy, and children with higher ratings should get more candies than their neighbors. To minimize the total number of candies, we can follow a simple approach that ensures these conditions are met.\\n\\n# Approach\\nWe can start by initializing an array `candies` to keep track of the number of candies each child receives. We\\'ll initialize all elements of `candies` to 1 since each child must have at least one candy.\\n\\nWe then iterate through the ratings array from left to right, and for each child `i`, we compare their rating with the rating of the previous child (`i-1`). If the current child has a higher rating, we give them one more candy than the previous child by setting `candies[i] = candies[i-1] + 1`. If not, we leave their candy count as 1.\\n\\nNext, we iterate through the ratings array from right to left, and for each child `i`, we compare their rating with the rating of the next child (`i+1`). If the current child has a higher rating and has fewer or equal candies than the next child, we update their candy count to be one more than the next child\\'s candy count by setting `candies[i] = candies[i+1] + 1`.\\n\\nFinally, we calculate the total number of candies by summing up all the elements in the `candies` array.\\n\\nThis approach ensures that both conditions are met, and it minimizes the total number of candies required.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ - We iterate through the ratings array twice, once from left to right and once from right to left, where n is the number of children.\\n- Space complexity: $$O(n)$$ - We use an additional array `candies` of size n to store the number of candies for each child.\\n\\n# Code\\n```java\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] candies = new int[n];\\n        candies[0] = 1;\\n\\n        // First pass: Left to right\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            } else {\\n                candies[i] = 1;\\n            }\\n        }\\n\\n        // Second pass: Right to left\\n        int totalCandies = candies[n - 1];\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {\\n                candies[i] = candies[i + 1] + 1;\\n            }\\n            totalCandies += candies[i];\\n        }\\n\\n        return totalCandies;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```java\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n        int[] candies = new int[n];\\n        candies[0] = 1;\\n\\n        // First pass: Left to right\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                candies[i] = candies[i - 1] + 1;\\n            } else {\\n                candies[i] = 1;\\n            }\\n        }\\n\\n        // Second pass: Right to left\\n        int totalCandies = candies[n - 1];\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {\\n                candies[i] = candies[i + 1] + 1;\\n            }\\n            totalCandies += candies[i];\\n        }\\n\\n        return totalCandies;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038303,
                "title": "easy-python-java-c-javascript-c-100",
                "content": "\\n```Python []\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        if n <= 1:\\n            return n\\n\\n        nums = [1] * n\\n\\n        # Make sure children with a higher rating get more candy than their left neighbor\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i - 1]:\\n                nums[i] += nums[i - 1]\\n\\n    # Make sure children with a higher rating get more candy than their right neighbor\\n        for i in range(n - 1, 0, -1):\\n            if ratings[i - 1] > ratings[i]:\\n                nums[i - 1] = max(nums[i] + 1, nums[i - 1])\\n\\n        candies = sum(nums)\\n\\n        return candies\\n```\\n```Java []\\nint n = ratings.length;\\n        if (n <= 1) return n;\\n\\n        int[] nums = new int[n];\\n        Arrays.fill(nums, 1);\\n\\n        // Make sure children with a higher rating get more candy than their left neighbor\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                nums[i] += nums[i - 1];\\n            }\\n        }\\n\\n        // Make sure children with a higher rating get more candy than their right neighbor\\n        for (int i = n - 1; i > 0; i--) {\\n            if (ratings[i - 1] > ratings[i]) {\\n                nums[i - 1] = Math.max(nums[i] + 1, nums[i - 1]);\\n            }\\n        }\\n\\n        int candies = 0;\\n        for (int e : nums) {\\n            candies += e;\\n        }\\n\\n        return candies;\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        if(n <= 1) return n;\\n\\n        vector<int> nums( n , 1);\\n        // make sure children with a higher rating gets more candy than its left neighbour\\n        for(int i =1 ; i< n ; i++){\\n            if(ratings[i] > ratings[i-1]){\\n                nums[i]+=nums[i-1];\\n            }\\n        }\\n        // make sure children with higher rating get more candy than its right neighbour\\n        for(int i = n-1 ; i>0 ; i--){\\n            if(ratings[i-1] > ratings[i]){\\n                nums[i-1] = max(nums[i]+1 , nums[i-1]);\\n            }\\n        }\\n\\n        int candies = 0;\\n\\n        for(auto e : nums) candies+=e;\\n\\n        return candies;\\n    }\\n};\\n```\\n```JavaScript []\\nconst n = ratings.length;\\n    if (n <= 1) return n;\\n\\n    const nums = new Array(n).fill(1);\\n\\n    // Make sure children with a higher rating get more candy than their left neighbor\\n    for (let i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) {\\n            nums[i] += nums[i - 1];\\n        }\\n    }\\n\\n    // Make sure children with higher rating get more candy than their right neighbor\\n    for (let i = n - 1; i > 0; i--) {\\n        if (ratings[i - 1] > ratings[i]) {\\n            nums[i - 1] = Math.max(nums[i] + 1, nums[i - 1]);\\n        }\\n    }\\n\\n    let candies = 0;\\n\\n    for (const e of nums) {\\n        candies += e;\\n    }\\n\\n    return candies;\\n```\\n```C# []\\n int n = ratings.Length;\\n    if (n <= 1) return n;\\n\\n    int[] nums = new int[n];\\n    for (int i = 0; i < n; i++)\\n    {\\n        nums[i] = 1;\\n    }\\n\\n    // Make sure children with a higher rating get more candy than their left neighbor\\n    for (int i = 1; i < n; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1])\\n        {\\n            nums[i] += nums[i - 1];\\n        }\\n    }\\n\\n    // Make sure children with higher rating get more candy than their right neighbor\\n    for (int i = n - 1; i > 0; i--)\\n    {\\n        if (ratings[i - 1] > ratings[i])\\n        {\\n            nums[i - 1] = Math.Max(nums[i] + 1, nums[i - 1]);\\n        }\\n    }\\n\\n    int candies = 0;\\n    foreach (int e in nums)\\n    {\\n        candies += e;\\n    }\\n\\n    return candies;\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "```Python []\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        if n <= 1:\\n            return n\\n\\n        nums = [1] * n\\n\\n        # Make sure children with a higher rating get more candy than their left neighbor\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i - 1]:\\n                nums[i] += nums[i - 1]\\n\\n    # Make sure children with a higher rating get more candy than their right neighbor\\n        for i in range(n - 1, 0, -1):\\n            if ratings[i - 1] > ratings[i]:\\n                nums[i - 1] = max(nums[i] + 1, nums[i - 1])\\n\\n        candies = sum(nums)\\n\\n        return candies\\n```\n```Java []\\nint n = ratings.length;\\n        if (n <= 1) return n;\\n\\n        int[] nums = new int[n];\\n        Arrays.fill(nums, 1);\\n\\n        // Make sure children with a higher rating get more candy than their left neighbor\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                nums[i] += nums[i - 1];\\n            }\\n        }\\n\\n        // Make sure children with a higher rating get more candy than their right neighbor\\n        for (int i = n - 1; i > 0; i--) {\\n            if (ratings[i - 1] > ratings[i]) {\\n                nums[i - 1] = Math.max(nums[i] + 1, nums[i - 1]);\\n            }\\n        }\\n\\n        int candies = 0;\\n        for (int e : nums) {\\n            candies += e;\\n        }\\n\\n        return candies;\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        if(n <= 1) return n;\\n\\n        vector<int> nums( n , 1);\\n        // make sure children with a higher rating gets more candy than its left neighbour\\n        for(int i =1 ; i< n ; i++){\\n            if(ratings[i] > ratings[i-1]){\\n                nums[i]+=nums[i-1];\\n            }\\n        }\\n        // make sure children with higher rating get more candy than its right neighbour\\n        for(int i = n-1 ; i>0 ; i--){\\n            if(ratings[i-1] > ratings[i]){\\n                nums[i-1] = max(nums[i]+1 , nums[i-1]);\\n            }\\n        }\\n\\n        int candies = 0;\\n\\n        for(auto e : nums) candies+=e;\\n\\n        return candies;\\n    }\\n};\\n```\n```JavaScript []\\nconst n = ratings.length;\\n    if (n <= 1) return n;\\n\\n    const nums = new Array(n).fill(1);\\n\\n    // Make sure children with a higher rating get more candy than their left neighbor\\n    for (let i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) {\\n            nums[i] += nums[i - 1];\\n        }\\n    }\\n\\n    // Make sure children with higher rating get more candy than their right neighbor\\n    for (let i = n - 1; i > 0; i--) {\\n        if (ratings[i - 1] > ratings[i]) {\\n            nums[i - 1] = Math.max(nums[i] + 1, nums[i - 1]);\\n        }\\n    }\\n\\n    let candies = 0;\\n\\n    for (const e of nums) {\\n        candies += e;\\n    }\\n\\n    return candies;\\n```\n```C# []\\n int n = ratings.Length;\\n    if (n <= 1) return n;\\n\\n    int[] nums = new int[n];\\n    for (int i = 0; i < n; i++)\\n    {\\n        nums[i] = 1;\\n    }\\n\\n    // Make sure children with a higher rating get more candy than their left neighbor\\n    for (int i = 1; i < n; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1])\\n        {\\n            nums[i] += nums[i - 1];\\n        }\\n    }\\n\\n    // Make sure children with higher rating get more candy than their right neighbor\\n    for (int i = n - 1; i > 0; i--)\\n    {\\n        if (ratings[i - 1] > ratings[i])\\n        {\\n            nums[i - 1] = Math.Max(nums[i] + 1, nums[i - 1]);\\n        }\\n    }\\n\\n    int candies = 0;\\n    foreach (int e in nums)\\n    {\\n        candies += e;\\n    }\\n\\n    return candies;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038055,
                "title": "c-easy-solution",
                "content": "# Intuition\\nWe will approach it using greedy.We wil distribut one candy to each and then according to condition given in que we will increase the required candy.\\n\\n\\n# Approach\\n We will start by declaring two array left_to_right and right_to_left\\nFirst we will travel from left to right fillling our array with the number of candy we are giving to ith child..Now here we need to see the child with more rating should get more candy than their neighbour we satisfied this for left neighbour but we need to check for right neighbour also maybe they have more candy so we need to update it accordingly..You would have used only single array and updated that but creating different array gives more clear idea. We wil travel form right to left and will fill the another array satisfying the condition given in que. After it for each index we will take max from both array as we need to make sure higher rating child get higher candy compared to its both left and rightr neighbour./\\n\\n# Complexity\\n- Time complexity:\\n0(n) where n is size of given ratings\\n\\n- Space complexity:\\n0(n) for two n sized array \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> left_to_right(n,1);\\n        vector<int> right_to_left(n,1);\\n       \\n        for(int i =1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                left_to_right[i] =left_to_right[i-1]+1;\\n            }\\n        }\\n          for(int i =n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                right_to_left[i] =right_to_left[i+1]+1;\\n            }\\n        }\\n\\n        int ans =0;\\n\\n        for(int i =0;i<n;i++){\\n           ans = ans+max(right_to_left[i],left_to_right[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> left_to_right(n,1);\\n        vector<int> right_to_left(n,1);\\n       \\n        for(int i =1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                left_to_right[i] =left_to_right[i-1]+1;\\n            }\\n        }\\n          for(int i =n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                right_to_left[i] =right_to_left[i+1]+1;\\n            }\\n        }\\n\\n        int ans =0;\\n\\n        for(int i =0;i<n;i++){\\n           ans = ans+max(right_to_left[i],left_to_right[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038017,
                "title": "greedy-very-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nApproach is Very Simple:-\\n- Firstly handle Rating[i]>Rating[i+1]\\n- Now handle     Rating[i-1]>Rating[i]\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& arr) {\\n      int n = arr.size(),ans = 0;\\n      vector<int> candies(n,1);\\n\\n      for(int i = 1;i<n;i++)\\n      {\\n        if(arr[i]>arr[i-1])\\n        candies[i] = candies[i-1]+1;\\n      }\\n      for(int i = n-1;i>0;i--)\\n      {\\n        if(arr[i-1]>arr[i] && candies[i-1]<=candies[i])\\n        candies[i-1]  = candies[i]+1;\\n      }\\n      for(auto x : candies) ans+=x;\\n      return  ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& arr) {\\n      int n = arr.size(),ans = 0;\\n      vector<int> candies(n,1);\\n\\n      for(int i = 1;i<n;i++)\\n      {\\n        if(arr[i]>arr[i-1])\\n        candies[i] = candies[i-1]+1;\\n      }\\n      for(int i = n-1;i>0;i--)\\n      {\\n        if(arr[i-1]>arr[i] && candies[i-1]<=candies[i])\\n        candies[i-1]  = candies[i]+1;\\n      }\\n      for(auto x : candies) ans+=x;\\n      return  ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037973,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n=len(ratings)\\n        dp=[1]*n\\n        for i in range(1,n):\\n            if ratings[i]>ratings[i-1]:\\n                dp[i]=dp[i-1]+1\\n\\n        for i in range(n-2,-1,-1):\\n            if ratings[i]>ratings[i+1]:\\n                dp[i]=max(dp[i],dp[i+1]+1)\\n\\n        return sum(dp)        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n=len(ratings)\\n        dp=[1]*n\\n        for i in range(1,n):\\n            if ratings[i]>ratings[i-1]:\\n                dp[i]=dp[i-1]+1\\n\\n        for i in range(n-2,-1,-1):\\n            if ratings[i]>ratings[i+1]:\\n                dp[i]=max(dp[i],dp[i+1]+1)\\n\\n        return sum(dp)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037962,
                "title": "video-solution-explanation-with-drawings-in-depth-c-java",
                "content": "# Intuition and approach discussed in video solution in detail\\nhttps://youtu.be/3-2IBELK-iM\\n\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int sz = ratings.size();\\n        int maxRat = 2 * 10000 + 1;\\n        vector<int> cand(sz, 1);\\n        int minCand = 0;\\n        for(int indx = 0; indx < sz; indx++){\\n           int leftNeigh = (indx - 1) > -1 ? ratings[indx-1] : maxRat;\\n           int self = ratings[indx];\\n           if(self > leftNeigh){\\n              cand[indx] = cand[indx-1] + 1;\\n           }\\n        }\\n        for(int indx = sz-1; indx > -1; indx--){\\n           int rightNeigh =(indx + 1) < sz ? ratings[indx + 1] : maxRat;\\n           int self = ratings[indx];\\n           if(self > rightNeigh){\\n             if(cand[indx] <= cand[indx+1])\\n              cand[indx] = cand[indx+1] + 1;\\n           }\\n        }\\n\\n        minCand = accumulate(cand.begin(), cand.end(), 0);\\n\\n        return minCand; \\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int sz = ratings.length;\\n        int maxRat = 2 * 10000 + 1;\\n        int cand[] = new int[sz];\\n        Arrays.fill(cand, 1);\\n        int minCand = 0;\\n        for(int indx = 0; indx < sz; indx++){\\n           int leftNeigh = (indx - 1) > -1 ? ratings[indx-1] : maxRat;\\n           int self = ratings[indx];\\n           if(self > leftNeigh){\\n              cand[indx] = cand[indx-1] + 1;\\n           }\\n        }\\n        for(int indx = sz-1; indx > -1; indx--){\\n           int rightNeigh =(indx + 1) < sz ? ratings[indx + 1] : maxRat;\\n           int self = ratings[indx];\\n           if(self > rightNeigh){\\n             if(cand[indx] <= cand[indx+1])\\n              cand[indx] = cand[indx+1] + 1;\\n           }\\n        }\\n        for(var c : cand){\\n          minCand += c;\\n        }\\n        return minCand; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int sz = ratings.size();\\n        int maxRat = 2 * 10000 + 1;\\n        vector<int> cand(sz, 1);\\n        int minCand = 0;\\n        for(int indx = 0; indx < sz; indx++){\\n           int leftNeigh = (indx - 1) > -1 ? ratings[indx-1] : maxRat;\\n           int self = ratings[indx];\\n           if(self > leftNeigh){\\n              cand[indx] = cand[indx-1] + 1;\\n           }\\n        }\\n        for(int indx = sz-1; indx > -1; indx--){\\n           int rightNeigh =(indx + 1) < sz ? ratings[indx + 1] : maxRat;\\n           int self = ratings[indx];\\n           if(self > rightNeigh){\\n             if(cand[indx] <= cand[indx+1])\\n              cand[indx] = cand[indx+1] + 1;\\n           }\\n        }\\n\\n        minCand = accumulate(cand.begin(), cand.end(), 0);\\n\\n        return minCand; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int sz = ratings.length;\\n        int maxRat = 2 * 10000 + 1;\\n        int cand[] = new int[sz];\\n        Arrays.fill(cand, 1);\\n        int minCand = 0;\\n        for(int indx = 0; indx < sz; indx++){\\n           int leftNeigh = (indx - 1) > -1 ? ratings[indx-1] : maxRat;\\n           int self = ratings[indx];\\n           if(self > leftNeigh){\\n              cand[indx] = cand[indx-1] + 1;\\n           }\\n        }\\n        for(int indx = sz-1; indx > -1; indx--){\\n           int rightNeigh =(indx + 1) < sz ? ratings[indx + 1] : maxRat;\\n           int self = ratings[indx];\\n           if(self > rightNeigh){\\n             if(cand[indx] <= cand[indx+1])\\n              cand[indx] = cand[indx+1] + 1;\\n           }\\n        }\\n        for(var c : cand){\\n          minCand += c;\\n        }\\n        return minCand; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019202,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(n) + O(n) + O(n), which simplifies to O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for using an extra array left.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n= ratings.size();\\n        vector<int>left(n+1, 1);\\n        for(int i =1; i<n; i++){\\n            if(ratings[i]>ratings[i-1]){\\n                left[i]= left[i-1]+1;\\n\\n            }\\n        }\\n        int right=1;\\n        for(int j=n-2; j>=0; j--){\\n            if(ratings[j]>ratings[j+1]){\\n                right++;\\n                left[j]= max(left[j], right);\\n            }\\n            else{\\n                right=1;\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            sum+= left[i];\\n        }\\n\\nreturn sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n= ratings.size();\\n        vector<int>left(n+1, 1);\\n        for(int i =1; i<n; i++){\\n            if(ratings[i]>ratings[i-1]){\\n                left[i]= left[i-1]+1;\\n\\n            }\\n        }\\n        int right=1;\\n        for(int j=n-2; j>=0; j--){\\n            if(ratings[j]>ratings[j+1]){\\n                right++;\\n                left[j]= max(left[j], right);\\n            }\\n            else{\\n                right=1;\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            sum+= left[i];\\n        }\\n\\nreturn sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797765,
                "title": "c-solution-in-o-n-super-easy-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& r) {\\n        int n=r.size();\\n        vector<int>v(n,1);\\n        for(int j=0;j<n-1;++j)\\n        {\\n            if(r[j]<r[j+1])\\n            v[j+1]=max(v[j+1],v[j]+1);\\n            if(r[n-1-j]<r[n-j-2])\\n            v[n-2-j]=max(v[n-j-2],v[n-1-j]+1);\\n        }\\n        n=0;\\n        for(auto it:v)\\n        n+=it;\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& r) {\\n        int n=r.size();\\n        vector<int>v(n,1);\\n        for(int j=0;j<n-1;++j)\\n        {\\n            if(r[j]<r[j+1])\\n            v[j+1]=max(v[j+1],v[j]+1);\\n            if(r[n-1-j]<r[n-j-2])\\n            v[n-2-j]=max(v[n-j-2],v[n-1-j]+1);\\n        }\\n        n=0;\\n        for(auto it:v)\\n        n+=it;\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620854,
                "title": "easy-approach-in-dart-and-also-in-typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nA shorter and easier-to-write solution to the problem of distributing candies to children based on their ratings can be achieved using a single iteration through the ratings array. Here\\'s a simplified approach:\\n1. Initialize the candies array with all elements set to 1, ensuring that each child receives at least one candy.\\n2. Traverse the ratings array from left to right, starting from the second child.\\n3. If the current child\\'s rating is greater than the previous child\\'s rating, assign candies[i] = candies[i - 1] + 1, ensuring the current child receives one more candy than the previous child.\\n4. Traverse the ratings array from right to left, starting from the second-to-last child.\\n5. If the current child\\'s rating is greater than the next child\\'s rating, and their current assigned number of candies (candies[i]) is less than or equal to the next child\\'s candies plus one (candies[i + 1] + 1), update candies[i] to be one more than the next child\\'s candies.\\n6. Calculate and return the sum of all elements in the candies array. This represents the minimum number of candies needed to distribute among the children while meeting the requirements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an array candies of the same length as the ratings array, with all elements set to 1.\\n2. Traverse the ratings array from left to right:\\n   - Compare the current child\\'s rating with its left neighbor\\'s     rating.\\n   - If the current child has a higher rating than its left neighbor, assign candies[i] = candies[i - 1] + 1, ensuring the current child receives one more candy than the left neighbor\\n3. Traverse the ratings array from right to left:\\n   - Compare the current child\\'s rating with its right neighbor\\'s rating\\n   - If the current child has a higher rating than its right neighbor and its assigned number of candies (candies[i]) is less than or equal to its right neighbor\\'s candies plus one (candies[i + 1] + 1), update candies[i] to be one more than its right neighbor\\'s candies.\\n4. Calculate the sum of all elements in the candies array, representing the minimum number of candies needed to distribute among the children.\\n5. Return the sum as the result.\\n```\\nfunction distributeCandies(ratings):\\n    n = length of ratings\\n    candies = array of size n with all elements initialized to 1\\n    \\n    // Traverse from left to right\\n    for i from 1 to n-1 do:\\n        if ratings[i] > ratings[i-1] then:\\n            candies[i] = candies[i-1] + 1\\n            \\n    // Traverse from right to left\\n    for i from n-2 to 0 do:\\n        if ratings[i] > ratings[i+1] and candies[i] <= candies[i+1] + 1 then:\\n            candies[i] = candies[i+1] + 1\\n            \\n    sum = sum of all elements in candies\\n    return sum\\n```\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Dart\\n```\\nclass Solution {\\n  int candy(List<int> ratings) {\\n      int n = ratings.length;\\n      List<int> candies = List<int>.filled(n,1);\\n      for(int i=1;i<n;i++){\\n          if(ratings[i] > ratings[i-1]){\\n              candies[i] = candies[i-1]+1;\\n          }\\n      }\\n      for(int i =n-2;i>=0;i--){\\n          if(ratings[i+1] < ratings[i] && candies[i] <= candies[i+1]){\\n            candies[i] = candies[i+1]+1;\\n          }\\n      }\\n      \\n      int sum = candies.reduce((a,b) => a+b);\\n      return sum;\\n  }\\n}\\n```\\n## TypeScript\\n```\\nlet candies = new Array(ratings.length).fill(1);\\n    for(let i=1;i<ratings.length;i++){\\n        if(ratings[i] > ratings[i-1]){\\n            candies[i] = candies[i-1]+1\\n        }\\n    } \\n\\n    for(let i = ratings.length-2;i>=0;i--){\\n        if(ratings[i] > ratings[i+1] && candies[i] <= candies[i+1]){\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }  \\n    \\n    // console.log(candies)\\n    let sum = candies.reduce((a,b) => a+b);\\n    return sum;\\n```    \\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dart"
                ],
                "code": "```\\nfunction distributeCandies(ratings):\\n    n = length of ratings\\n    candies = array of size n with all elements initialized to 1\\n    \\n    // Traverse from left to right\\n    for i from 1 to n-1 do:\\n        if ratings[i] > ratings[i-1] then:\\n            candies[i] = candies[i-1] + 1\\n            \\n    // Traverse from right to left\\n    for i from n-2 to 0 do:\\n        if ratings[i] > ratings[i+1] and candies[i] <= candies[i+1] + 1 then:\\n            candies[i] = candies[i+1] + 1\\n            \\n    sum = sum of all elements in candies\\n    return sum\\n```\n```\\nclass Solution {\\n  int candy(List<int> ratings) {\\n      int n = ratings.length;\\n      List<int> candies = List<int>.filled(n,1);\\n      for(int i=1;i<n;i++){\\n          if(ratings[i] > ratings[i-1]){\\n              candies[i] = candies[i-1]+1;\\n          }\\n      }\\n      for(int i =n-2;i>=0;i--){\\n          if(ratings[i+1] < ratings[i] && candies[i] <= candies[i+1]){\\n            candies[i] = candies[i+1]+1;\\n          }\\n      }\\n      \\n      int sum = candies.reduce((a,b) => a+b);\\n      return sum;\\n  }\\n}\\n```\n```\\nlet candies = new Array(ratings.length).fill(1);\\n    for(let i=1;i<ratings.length;i++){\\n        if(ratings[i] > ratings[i-1]){\\n            candies[i] = candies[i-1]+1\\n        }\\n    } \\n\\n    for(let i = ratings.length-2;i>=0;i--){\\n        if(ratings[i] > ratings[i+1] && candies[i] <= candies[i+1]){\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }  \\n    \\n    // console.log(candies)\\n    let sum = candies.reduce((a,b) => a+b);\\n    return sum;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584789,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        if(ratings.size()==1){\\n            return 1;\\n        }\\n\\n        else{\\n        int n = ratings.size();\\n\\n        vector<int> cnt;\\n\\n\\n        for(int i = 0 ; i < n ; i++){\\n            cnt.push_back(1);\\n        }\\n        for(int i = 1 ; i < n ; i++){\\n            if(ratings[i] > ratings[i-1]){\\n                cnt[i] = cnt[i-1] + 1;\\n            }\\n        }\\n        for(int i = n-2 ; i >= 0 ; i--){\\n            if(ratings[i] > ratings[i+1] && cnt[i] <= cnt[i+1]){\\n                cnt[i] = cnt[i+1] + 1;\\n            }\\n        }\\n\\n        return accumulate(cnt.begin() , cnt.end() , 0LL);\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        if(ratings.size()==1){\\n            return 1;\\n        }\\n\\n        else{\\n        int n = ratings.size();\\n\\n        vector<int> cnt;\\n\\n\\n        for(int i = 0 ; i < n ; i++){\\n            cnt.push_back(1);\\n        }\\n        for(int i = 1 ; i < n ; i++){\\n            if(ratings[i] > ratings[i-1]){\\n                cnt[i] = cnt[i-1] + 1;\\n            }\\n        }\\n        for(int i = n-2 ; i >= 0 ; i--){\\n            if(ratings[i] > ratings[i+1] && cnt[i] <= cnt[i+1]){\\n                cnt[i] = cnt[i+1] + 1;\\n            }\\n        }\\n\\n        return accumulate(cnt.begin() , cnt.end() , 0LL);\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579951,
                "title": "135-candy-java",
                "content": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        if(ratings.length==1)\\n            return 1;\\n        int candies[]=new int[ratings.length];\\n        Arrays.fill(candies,1);\\n        for(int i=1;i<ratings.length;i++)\\n        {\\n            if(ratings[i]>ratings[i-1]&&candies[i]<=candies[i-1])\\n                candies[i]=candies[i-1]+1;\\n        }\\n        \\n        for(int i=ratings.length-2;i>=0;i--)\\n        {\\n            if(ratings[i]>ratings[i+1]&&candies[i]<=candies[i+1])\\n                candies[i]=candies[i+1]+1;\\n        }\\n        int sum=0;\\n        for(int x:candies)\\n            sum+=x;\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        if(ratings.length==1)\\n            return 1;\\n        int candies[]=new int[ratings.length];\\n        Arrays.fill(candies,1);\\n        for(int i=1;i<ratings.length;i++)\\n        {\\n            if(ratings[i]>ratings[i-1]&&candies[i]<=candies[i-1])\\n                candies[i]=candies[i-1]+1;\\n        }\\n        \\n        for(int i=ratings.length-2;i>=0;i--)\\n        {\\n            if(ratings[i]>ratings[i+1]&&candies[i]<=candies[i+1])\\n                candies[i]=candies[i+1]+1;\\n        }\\n        int sum=0;\\n        for(int x:candies)\\n            sum+=x;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433875,
                "title": "2-array-approach-easy-solution-left-right",
                "content": "\\n# Approach\\n2 Array Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>l2r(n,1);\\n        vector<int>r2l(n,1);\\n        vector<int> ans;\\n        int sum=0;\\n        for(int i=1;i<n;i++){\\n          if(ratings[i]>ratings[i-1]){\\n              l2r[i]+=l2r[i-1];\\n          }\\n }\\n  for(int i=n-2;i>=0;i--){\\n          if(ratings[i]>ratings[i+1]){\\n              r2l[i]+=r2l[i+1];\\n          }\\n }\\n for(int i=0;i<n;i++){\\n     if(l2r[i]>=r2l[i]){\\n         ans.push_back(l2r[i]);\\n     }\\n     else{\\n         ans.push_back(r2l[i]);\\n     }\\n sum=sum+ans[i];\\n }\\nreturn sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>l2r(n,1);\\n        vector<int>r2l(n,1);\\n        vector<int> ans;\\n        int sum=0;\\n        for(int i=1;i<n;i++){\\n          if(ratings[i]>ratings[i-1]){\\n              l2r[i]+=l2r[i-1];\\n          }\\n }\\n  for(int i=n-2;i>=0;i--){\\n          if(ratings[i]>ratings[i+1]){\\n              r2l[i]+=r2l[i+1];\\n          }\\n }\\n for(int i=0;i<n;i++){\\n     if(l2r[i]>=r2l[i]){\\n         ans.push_back(l2r[i]);\\n     }\\n     else{\\n         ans.push_back(r2l[i]);\\n     }\\n sum=sum+ans[i];\\n }\\nreturn sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040094,
                "title": "java-99-2-percent-faster-greedy",
                "content": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int[] nums=new int[ratings.length];\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=1;\\n        }\\n        for(int i=1;i<nums.length;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                nums[i]=nums[i-1]+1;\\n            }\\n        }\\n        for(int i=nums.length-1;i>=1;i--){\\n            if(ratings[i-1]>ratings[i] && nums[i-1]<=nums[i]){\\n                nums[i-1]=nums[i]+1;\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum=sum+nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int[] nums=new int[ratings.length];\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=1;\\n        }\\n        for(int i=1;i<nums.length;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                nums[i]=nums[i-1]+1;\\n            }\\n        }\\n        for(int i=nums.length-1;i>=1;i--){\\n            if(ratings[i-1]>ratings[i] && nums[i-1]<=nums[i]){\\n                nums[i-1]=nums[i]+1;\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum=sum+nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976395,
                "title": "c-short-easy-100-fast",
                "content": "# Please upvote if you like my solution .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int candy(vector<int>& A) {\\n        \\n        int n = A.size();\\n    \\n        vector<int> ans(n, 1);\\n\\n        for(int i=1;i<n;i++) {\\n            if(A[i]>A[i-1]) {       \\n                ans[i] = ans[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i=n-1;i>=1;i--) {\\n\\n            if(A[i-1]>A[i]) {\\n                ans[i-1] = max(ans[i] + 1, ans[i-1]);\\n            }\\n\\n        }\\n\\n        int sum = 0;\\n        \\n    \\n\\n        for(int i=0;i<n;i++) {\\n            sum += ans[i];\\n        }\\n\\n        return sum;\\n    \\n        \\n    }\\n};\\n```\\n\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on Linkedin https://www.linkedin.com/in/kailas-rathod/",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int candy(vector<int>& A) {\\n        \\n        int n = A.size();\\n    \\n        vector<int> ans(n, 1);\\n\\n        for(int i=1;i<n;i++) {\\n            if(A[i]>A[i-1]) {       \\n                ans[i] = ans[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i=n-1;i>=1;i--) {\\n\\n            if(A[i-1]>A[i]) {\\n                ans[i-1] = max(ans[i] + 1, ans[i-1]);\\n            }\\n\\n        }\\n\\n        int sum = 0;\\n        \\n    \\n\\n        for(int i=0;i<n;i++) {\\n            sum += ans[i];\\n        }\\n\\n        return sum;\\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962105,
                "title": "c-two-way-to-solve-easiest-way-ever",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int>left(ratings.size(),1);\\n        for(int i=1;i<ratings.size();++i){\\n            if(ratings[i]>ratings[i-1]){\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        int right=1;\\n        for(int j=ratings.size()-2;j>=0;--j){\\n        if(ratings[j]>ratings[j+1]){\\n            right++;\\n            left[j]=max(left[j],right);\\n            \\n        }\\n        else{\\n            right=1;\\n        }}\\n        //    vector<int>right(ratings.size(),1);\\n        // for(int i=ratings.size()-2;i>=0;--i){\\n        //     if(ratings[i]>ratings[i+1]){\\n        //         right[i]=right[i+1]+1;\\n        //     }\\n        // }\\n        int Total_candies=0;\\n        for(int i=0;i<ratings.size();++i){\\n            Total_candies+=left[i];\\n        }\\n        return Total_candies;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int>left(ratings.size(),1);\\n        for(int i=1;i<ratings.size();++i){\\n            if(ratings[i]>ratings[i-1]){\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n           vector<int>right(ratings.size(),1);\\n        for(int i=ratings.size()-2;i>=0;--i){\\n            if(ratings[i]>ratings[i+1]){\\n                right[i]=right[i+1]+1;\\n            }\\n        }\\n        int Total_candies=0;\\n        for(int i=0;i<ratings.size();++i){\\n            Total_candies+=max(right[i],left[i]);\\n        }\\n        return Total_candies;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int>left(ratings.size(),1);\\n        for(int i=1;i<ratings.size();++i){\\n            if(ratings[i]>ratings[i-1]){\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        int right=1;\\n        for(int j=ratings.size()-2;j>=0;--j){\\n        if(ratings[j]>ratings[j+1]){\\n            right++;\\n            left[j]=max(left[j],right);\\n            \\n        }\\n        else{\\n            right=1;\\n        }}\\n        //    vector<int>right(ratings.size(),1);\\n        // for(int i=ratings.size()-2;i>=0;--i){\\n        //     if(ratings[i]>ratings[i+1]){\\n        //         right[i]=right[i+1]+1;\\n        //     }\\n        // }\\n        int Total_candies=0;\\n        for(int i=0;i<ratings.size();++i){\\n            Total_candies+=left[i];\\n        }\\n        return Total_candies;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        vector<int>left(ratings.size(),1);\\n        for(int i=1;i<ratings.size();++i){\\n            if(ratings[i]>ratings[i-1]){\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n           vector<int>right(ratings.size(),1);\\n        for(int i=ratings.size()-2;i>=0;--i){\\n            if(ratings[i]>ratings[i+1]){\\n                right[i]=right[i+1]+1;\\n            }\\n        }\\n        int Total_candies=0;\\n        for(int i=0;i<ratings.size();++i){\\n            Total_candies+=max(right[i],left[i]);\\n        }\\n        return Total_candies;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727637,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int candy(vector<int>& A) {\\n        \\n        int n = A.size();\\n    \\n        vector<int> ans(n, 1);\\n\\n        for(int i=1;i<n;i++) {\\n            if(A[i]>A[i-1]) {       \\n                ans[i] = ans[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i=n-1;i>=1;i--) {\\n\\n            if(A[i-1]>A[i]) {\\n                ans[i-1] = max(ans[i] + 1, ans[i-1]);\\n            }\\n\\n        }\\n\\n        int sum = 0;\\n        \\n    \\n\\n        for(int i=0;i<n;i++) {\\n            sum += ans[i];\\n        }\\n\\n        return sum;\\n    \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int candy(vector<int>& A) {\\n        \\n        int n = A.size();\\n    \\n        vector<int> ans(n, 1);\\n\\n        for(int i=1;i<n;i++) {\\n            if(A[i]>A[i-1]) {       \\n                ans[i] = ans[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i=n-1;i>=1;i--) {\\n\\n            if(A[i-1]>A[i]) {\\n                ans[i-1] = max(ans[i] + 1, ans[i-1]);\\n            }\\n\\n        }\\n\\n        int sum = 0;\\n        \\n    \\n\\n        for(int i=0;i<n;i++) {\\n            sum += ans[i];\\n        }\\n\\n        return sum;\\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701595,
                "title": "java-two-solutions-two-pass",
                "content": "### **Please Upvote** :D\\n##### 1. Greedy approach:\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n\\n        int[] l2r = new int[n], r2l = new int[n];\\n\\t\\t\\n        Arrays.fill(l2r, 1);\\n        Arrays.fill(r2l, 1);\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            if (ratings[i + 1] > ratings[i]) {\\n                l2r[i + 1] = l2r[i] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 1; i > 0; i--) {\\n            if (ratings[i - 1] > ratings[i]) {\\n                r2l[i - 1] = r2l[i] + 1;\\n            }\\n        }\\n\\n        int[] finalArr = new int[n];\\n\\t\\t\\n        for (int i = 0; i < n; i++) {\\n            finalArr[i] = Math.max(l2r[i], r2l[i]);\\n        }\\n\\n        int totalCandies = 0;\\n        for (int i : finalArr) totalCandies += i;\\n\\n        return totalCandies;\\n    }\\n}\\n\\n// TC: 6 * O(n) => O(n)\\n// SC: 3 * O(n) => O(n)\\n```\\n\\n##### 2. Extra space reduced (Two pass):\\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n\\n        int[] distribution = new int[n];\\n\\t\\t\\n        Arrays.fill(distribution, 1);\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            if (ratings[i + 1] > ratings[i]) {\\n                distribution[i + 1] = distribution[i] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 1; i > 0; i--) {\\n            if (ratings[i - 1] > ratings[i]) {\\n                if (distribution[i - 1] <= distribution[i]) {\\n                    distribution[i - 1] = distribution[i] + 1;\\n                }\\n            }\\n        }\\n\\n        int totalCandies = 0;\\n        for (int i : distribution) totalCandies += i;\\n\\n        return totalCandies;\\n    }\\n}\\n\\n// TC: 4 * O(n) => O(n)\\n// SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n\\n        int[] l2r = new int[n], r2l = new int[n];\\n\\t\\t\\n        Arrays.fill(l2r, 1);\\n        Arrays.fill(r2l, 1);\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            if (ratings[i + 1] > ratings[i]) {\\n                l2r[i + 1] = l2r[i] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 1; i > 0; i--) {\\n            if (ratings[i - 1] > ratings[i]) {\\n                r2l[i - 1] = r2l[i] + 1;\\n            }\\n        }\\n\\n        int[] finalArr = new int[n];\\n\\t\\t\\n        for (int i = 0; i < n; i++) {\\n            finalArr[i] = Math.max(l2r[i], r2l[i]);\\n        }\\n\\n        int totalCandies = 0;\\n        for (int i : finalArr) totalCandies += i;\\n\\n        return totalCandies;\\n    }\\n}\\n\\n// TC: 6 * O(n) => O(n)\\n// SC: 3 * O(n) => O(n)\\n```\n```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n = ratings.length;\\n\\n        int[] distribution = new int[n];\\n\\t\\t\\n        Arrays.fill(distribution, 1);\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            if (ratings[i + 1] > ratings[i]) {\\n                distribution[i + 1] = distribution[i] + 1;\\n            }\\n        }\\n\\n        for (int i = n - 1; i > 0; i--) {\\n            if (ratings[i - 1] > ratings[i]) {\\n                if (distribution[i - 1] <= distribution[i]) {\\n                    distribution[i - 1] = distribution[i] + 1;\\n                }\\n            }\\n        }\\n\\n        int totalCandies = 0;\\n        for (int i : distribution) totalCandies += i;\\n\\n        return totalCandies;\\n    }\\n}\\n\\n// TC: 4 * O(n) => O(n)\\n// SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2405865,
                "title": "c-o-n-time-o-1-space-99-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& a) {\\n        int indexOfLatestLocalMax = 0;\\n        int ans = 1;\\n        int latestLocalMaxCandies = 1;\\n        int currCandies=1;\\n        int offSetCandies;\\n        for(int i=1;i<a.size();i++) {\\n            if (a[i] >= a[i-1]) {\\n                currCandies = a[i] == a[i-1] ? 1 : currCandies + 1;\\n                ans += currCandies;\\n                latestLocalMaxCandies = currCandies;\\n                indexOfLatestLocalMax = i;\\n            } else {\\n                currCandies = 1;\\n                offSetCandies = i - indexOfLatestLocalMax;\\n                if (offSetCandies < latestLocalMaxCandies) {\\n                    offSetCandies -= 1;\\n                }\\n                ans += currCandies + offSetCandies;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& a) {\\n        int indexOfLatestLocalMax = 0;\\n        int ans = 1;\\n        int latestLocalMaxCandies = 1;\\n        int currCandies=1;\\n        int offSetCandies;\\n        for(int i=1;i<a.size();i++) {\\n            if (a[i] >= a[i-1]) {\\n                currCandies = a[i] == a[i-1] ? 1 : currCandies + 1;\\n                ans += currCandies;\\n                latestLocalMaxCandies = currCandies;\\n                indexOfLatestLocalMax = i;\\n            } else {\\n                currCandies = 1;\\n                offSetCandies = i - indexOfLatestLocalMax;\\n                if (offSetCandies < latestLocalMaxCandies) {\\n                    offSetCandies -= 1;\\n                }\\n                ans += currCandies + offSetCandies;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252930,
                "title": "34-ms-solution-c-easy-to-understand",
                "content": "\\'\\'\\'\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint candy(vector<int>& arr) {\\n\\t\\t\\tint l=arr.size();\\n\\t\\t\\tint c[l];\\n\\t\\t\\tfor(int i=0;i<l;i++){\\n\\t\\t\\t\\tc[i]=1;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<l-1;i++){\\n\\t\\t\\t\\tif (arr[i+1]>arr[i]){\\n\\t\\t\\t\\t\\tc[i+1]=c[i]+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint s=c[l-1];\\n\\t\\t\\tfor(int i=l-1;i>0;i--){\\n\\t\\t\\t\\tif ((arr[i-1]>arr[i])&&(c[i-1]<=c[i])){\\n\\t\\t\\t\\t\\tc[i-1]=c[i]+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ts=s+c[i-1];\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn s;\\n\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint candy(vector<int>& arr) {\\n\\t\\t\\tint l=arr.size();\\n\\t\\t\\tint c[l];\\n\\t\\t\\tfor(int i=0;i<l;i++){\\n\\t\\t\\t\\tc[i]=1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2242600,
                "title": "java-o-n-time-space-complexity",
                "content": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n= ratings.length;\\n        int candies=0;\\n        int[] left= new int[n];\\n        int[] right=new int[n];\\n        \\n        Arrays.fill(left,1);\\n        Arrays.fill(right,1);\\n        \\n        for(int i =1; i<n; i++){\\n            if(ratings[i]>ratings[i-1]) left[i]=left[i-1]+1;\\n        }\\n        \\n        for(int i =n-2; i>=0; i--){\\n            if(ratings[i]>ratings[i+1]) right[i]=right[i+1]+1;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            candies= candies+Math.max(left[i],right[i]);\\n        }\\n        \\n        return candies;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int candy(int[] ratings) {\\n        int n= ratings.length;\\n        int candies=0;\\n        int[] left= new int[n];\\n        int[] right=new int[n];\\n        \\n        Arrays.fill(left,1);\\n        Arrays.fill(right,1);\\n        \\n        for(int i =1; i<n; i++){\\n            if(ratings[i]>ratings[i-1]) left[i]=left[i-1]+1;\\n        }\\n        \\n        for(int i =n-2; i>=0; i--){\\n            if(ratings[i]>ratings[i+1]) right[i]=right[i+1]+1;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            candies= candies+Math.max(left[i],right[i]);\\n        }\\n        \\n        return candies;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238317,
                "title": "struggled-with-it-solved-it-and-tried-to-explain-it",
                "content": "Every sequence of numbers in this multiverse can be somehow generalized as a group of following sequence :\\n\\n![image](https://assets.leetcode.com/users/images/571888c5-c40e-4928-a943-504b6b1cfbf6_1656963258.6447163.png)\\n\\na climb of length ***a*** and a descent of length ***b*** where ***a, b*** can be from 0 till any value. i.e even monotonus sequences follow this. Even straight line is a group of above sequence with ***a, b = 0***. \\n\\nThe value of ***a, b*** can be different for different sequences in a group, ofcourse.\\n\\nSo let us go through each such sequence:\\n* \\tThe candies of the climb would be ***1 + 2 + 3 + 4 +...... + a    i.e. (a x (a+1))/2*** , we can start with 1 as the first element in the climb is smaller than both its neighbours.\\n* \\tThe same goes with the descent\\n* \\tand for the peak it would be max(a, b) + 1 as we know it has to be greater than both its neigbours candies values\\n\\n\\n\\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        \\n        ans = 0\\n        i = 0\\n        n = len(ratings)\\n        left = 0\\n        right = 0\\n        it = 0\\n        while i<n-1:\\n            #climb\\n            while i < n-1 and ratings[i] < ratings[i+1]:\\n                left +=1\\n                i+=1\\n            #descent\\n            while i  <n-1 and ratings[i] > ratings[i+1]:\\n                right +=1\\n                i+=1\\n                \\n\\t\\t\\t#candies\\n            ans = ans +  (left*(left+1)//2 + right*(right+1)//2) + max(left, right) + 1\\n            \\n\\t\\t\\t# the painful plateu part where the values are same like x, x, x, x. \\n\\t\\t\\t#Apart from the last one and first one for all x we could give 1 candy \\n\\t\\t\\t#and 1st one and last one are just part of different sequences \\n\\t\\t\\t#so we dont have to care about them.\\n            p = 0\\n        \\n            while i < n-1 and ratings[i] == ratings[i+1]:\\n                p += 1\\n                i+=1\\n    \\n            ans += p\\n            \\n            left = 0\\n            right = 0\\n\\t\\t\\t\\n\\t\\t\\t#every junction of two sequences would be double counted due to which\\n\\t\\t\\t#we can add all the junctions and remove the double counting see the\\n\\t\\t\\t#diagram below to see the double counting junction\\n\\t\\t\\t\\n            it+=1\\n        \\n        \\n        return ans-it+1\\n                \\n                \\n            \\n````\\n\\n![image](https://assets.leetcode.com/users/images/fcce1e1b-ce9e-4958-b628-970c130f9c63_1656963978.974529.png)\\n\\n\\n**Time complexity would be linear and space complexity would be constant**\\n\\n**This problem really felt difficult and a lot of cases needed to be handled and thought about but is really a fun problem to solve and learn from**\\n\\nThank you \\uD83D\\uDE09\\u270C\\uFE0F",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        \\n        ans = 0\\n        i = 0\\n        n = len(ratings)\\n        left = 0\\n        right = 0\\n        it = 0\\n        while i<n-1:\\n            #climb\\n            while i < n-1 and ratings[i] < ratings[i+1]:\\n                left +=1\\n                i+=1\\n            #descent\\n            while i  <n-1 and ratings[i] > ratings[i+1]:\\n                right +=1\\n                i+=1\\n                \\n\\t\\t\\t#candies\\n            ans = ans +  (left*(left+1)//2 + right*(right+1)//2) + max(left, right) + 1\\n            \\n\\t\\t\\t# the painful plateu part where the values are same like x, x, x, x. \\n\\t\\t\\t#Apart from the last one and first one for all x we could give 1 candy \\n\\t\\t\\t#and 1st one and last one are just part of different sequences \\n\\t\\t\\t#so we dont have to care about them.\\n            p = 0\\n        \\n            while i < n-1 and ratings[i] == ratings[i+1]:\\n                p += 1\\n                i+=1\\n    \\n            ans += p\\n            \\n            left = 0\\n            right = 0\\n\\t\\t\\t\\n\\t\\t\\t#every junction of two sequences would be double counted due to which\\n\\t\\t\\t#we can add all the junctions and remove the double counting see the\\n\\t\\t\\t#diagram below to see the double counting junction\\n\\t\\t\\t\\n            it+=1\\n        \\n        \\n        return ans-it+1\\n                \\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237812,
                "title": "c-o-n-space-o-n-time-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int candy(vector<int>& a) {\\n        int n=a.size();\\n        vector<int> ans(n,1);\\n        if(n==1)\\n        {\\n            return 1; // if there is only one element then answer will always be 1.\\n        }\\n        for(int i=1;i<n;i++) // considering i-1 and i index from left to right\\n        {\\n            if(a[i]>a[i-1] and ans[i-1]>=ans[i])\\n            {\\n                ans[i]=ans[i-1]+1;\\n            }\\n            \\n            if(a[i-1]>a[i] and ans[i]>=a[i-1])\\n            {\\n                ans[i-1]=ans[i]+1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--) //considering i and i+1 index from  right to left\\n        {\\n            if(a[i]>a[i+1] and ans[i+1]>=ans[i])\\n            {\\n                ans[i]=ans[i+1]+1;\\n            }\\n            if(a[i+1]>a[i] and ans[i]>=a[i+1])\\n            {\\n                ans[i+1]=ans[i]+1;\\n            }\\n        }\\n        int sum=0;\\n        for(auto x: ans)\\n        {\\n            sum+=x;\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int candy(vector<int>& a) {\\n        int n=a.size();\\n        vector<int> ans(n,1);\\n        if(n==1)\\n        {\\n            return 1; // if there is only one element then answer will always be 1.\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2237477,
                "title": "c-very-simple-o-n-time",
                "content": "```\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> lefttoright(n, -1);\\n        vector<int> righttoleft(n, -1);\\n        vector<int> ans(n, -1);\\n        int res = 0;\\n        lefttoright[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i-1]) {\\n                lefttoright[i] = lefttoright[i-1]+1;\\n            } else {\\n                lefttoright[i] = 1;\\n            }\\n        }\\n        righttoleft[n-1] = 1;\\n        for (int i = n-2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i+1]) {\\n                righttoleft[i] = righttoleft[i+1] + 1;\\n            } else {\\n                righttoleft[i] = 1;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = max(lefttoright[i], righttoleft[i]);\\n            res += ans[i];\\n        }\\n        return res;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> lefttoright(n, -1);\\n        vector<int> righttoleft(n, -1);\\n        vector<int> ans(n, -1);\\n        int res = 0;\\n        lefttoright[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i-1]) {\\n                lefttoright[i] = lefttoright[i-1]+1;\\n            } else {\\n                lefttoright[i] = 1;\\n            }\\n        }\\n        righttoleft[n-1] = 1;\\n        for (int i = n-2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i+1]) {\\n                righttoleft[i] = righttoleft[i+1] + 1;\\n            } else {\\n                righttoleft[i] = 1;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = max(lefttoright[i], righttoleft[i]);\\n            res += ans[i];\\n        }\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1631504,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1798500,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1890028,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1564922,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1565662,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 2055303,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 2046203,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1566480,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1570291,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1568954,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1631504,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1798500,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1890028,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1564922,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1565662,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 2055303,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 2046203,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1566480,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1570291,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1568954,
                "content": [
                    {
                        "username": "sharma_shubham",
                        "content": "Cool question but IMO all children should get equal candies."
                    },
                    {
                        "username": "sergei99",
                        "content": "No envy? No self-exaltation of \"successful\" chaps? How would the capitalism survive without that?"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "No of course not; have you never heard of capitalism? the kids with lots of candy get even more"
                    },
                    {
                        "username": "rayg1483",
                        "content": "[@VictorKoch](/VictorKoch) of course you\\'d say that \\uD83D\\uDE06 "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@kodyczasupl1](/kodyczasupl1) Don\\'t confuse \"Russian\" with \"Soviet\". Also, many modern countries are considered Socialist nowadays, Finland\\'s one of them."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "For the sake of their health/teeth, no children should get candies."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Some children are more equal than other."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "that would be socialism and it\\'s not russian school"
                    },
                    {
                        "username": "superpoulenc",
                        "content": "This problem statement is written by someone who cannot code."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s the nature of the challenge. Certainly not algorithm, which is simple."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "[@123GJWEQ2](/123GJWEQ2) https://www.youtube.com/watch?v=NS3hr2B2ZfE check out this to know about question"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "what\\'s wrong with it"
                    },
                    {
                        "username": "dilpreetgrover2",
                        "content": "[@lazarevzubov](/lazarevzubov) upvoted :)"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "That's life. Requirements are not written by programmers."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "very poor problem description"
                    },
                    {
                        "username": "sergei99",
                        "content": "That's the main reason why it's rated \"Hard\"."
                    },
                    {
                        "username": "fasiloon",
                        "content": "The expect Output of [1,2,2] is 4, not 5. I think it's not reasonable."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "[@Amantvn1234](/Amantvn1234) who gave the condition we need not do anything? Just because a condition is not specified doesn\\'t mean nothing must be done. The question is incomplete in my opinion."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yes, it is unfair. For example,\n```\n[1, 2, 3, 4, ..., 100, 100]\n```\nThe last kid has the same rating as the penultimate kid, but the penultimate kid has 100 candies, but the last only 1."
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Bcoz : \\n\\n1. for any no. at index (i)if any of its \\n    Neighbours (i+1,i-1) has greater rating \\n     then it should have more candies than its \\n    neighbor\\n\\n2.  In case neighbors is equal we need not to \\n     do anything."
                    },
                    {
                        "username": "at218808",
                        "content": "[@cartesPerforees](/cartesPerforees) ohh ho ho ho scientist"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you\\'re not reasonable to think that we think that your thinking about what is reasonable is the most reasonable"
                    },
                    {
                        "username": "punchoyeah",
                        "content": "I got wrong answer here :\\n\\nInput:\\t[1,2,2]\\nOutput:\\t5\\nExpected:\\t4\\n\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@daring-calf](/daring-calf) not at all if you ask me. But I\\'m afraid that\\'s exactly what is happening in many societies. It\\'s called a \"competitive environment\" and such."
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@sergei99](/sergei99) so is it wise to make kid 2 everyone\\'s enemy?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@button_chicken](/button_chicken) Frankly I wouldn't call it wisdom. I worked for one of top 10 investment banks for several years and learned some of their crooked, unholy, cannibalistic management principles."
                    },
                    {
                        "username": "button_chicken",
                        "content": "[@sergei99](/sergei99) who are you and why are you so wise?"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's not for understanding, it's for implementation I guess. The third kid does not have a higher rating than its one and only neighbour, and as such you could give them 1 candy. Even if some other kid with the same rating gets 1000 candies. This looks like a principle of salary and awards distribution: no justice at all, pay good performers the minimal amount that would cause envy and greed within their neighbours, and that would do. There are no neighbours to envy the third kid, so why spend more money?"
                    },
                    {
                        "username": "evgeniymish",
                        "content": "it is all about word \"neighbors\""
                    },
                    {
                        "username": "roku216133",
                        "content": "\"higher\" is defined to be \">\" not \">=\""
                    },
                    {
                        "username": "Zeus_abhi",
                        "content": "[@Aman_gupta-9833](/Aman_gupta-9833) itz than not then."
                    },
                    {
                        "username": "raphamber",
                        "content": "Let r(i) and c(i) represent the rating and number of candies for child i respectively. \\nif r(i) > r(j) where j == r + 1 or j == r - 1, c(i) > c(j)\\nif r(i) == r(j) where j == r + 1 or j == r - 1, then c(i) and c(j) can be anything. "
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "itz more( not more then or equal to )"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Children are very greedy for candy. but if ratings[i-1] == ratings[i]==ratings[i+1], c[i]=1.\nThe same rating with the neighbor, it is sad for child i.\n\n# Look at this example. You'll find how unfair this rule is.\n[60, 80, 100, 100, 100, 100, 100]\ncandies for children\n1, 2, 3, 1, 1, 1, 1"
                    },
                    {
                        "username": "sergei99",
                        "content": "Is it not the same at jobs? If there is no one around to envy your higher salary, then you won't get it. It has nothing to do with usefullness of your job for your employer."
                    },
                    {
                        "username": "ssredotime",
                        "content": "As an interviewer, this is problem is a life saver for when we unexpectedly lose headcount but already scheduled a few interviews for the role!"
                    },
                    {
                        "username": "gary2008",
                        "content": "ROFL, emotional damage!!!"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Is your company still hiring?"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "lmao XD.....don\\'t do that to me :) thats the reason i feel the dying after rejections in interviews  T_T"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "to eliminate people?"
                    },
                    {
                        "username": "iaming",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?"
                    },
                    {
                        "username": "harshvardhan_dhwaj",
                        "content": "1,2,2,3"
                    },
                    {
                        "username": "jeetu_prajapati5647",
                        "content": "yes, 1 2 1 2"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "1,2,1,2 more likely cuz its the minimum"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Dominating_](/Dominating_) Yes you are absolutely correct, my idea was just to tell him that it is not necessary than we have to give equal candies to children with same ratings. If constraint was that \"children with same rating should get same candies\", then first one would have been correct. But as per given constraints first one is wrong.\nForgive me for poor choice of words will update my comment right away."
                    },
                    {
                        "username": "Dominating_",
                        "content": "[@arnavsingh31](/arnavsingh31) Isn\\'t the first one wrong as it requires more candy?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": " Second answer is correct, as per the problem statement, firstly there is no constraint on students with equal rating i.e. there might be testcases where children with same rating are given equal candies also (if rating = [1, 3, 3, 1] then in this case our candy requirement for each children will be [1, 2, 2, 1]). The second thing is that you are forgetting the key aspect of the problem i.e. to minimise the number candy, so as per your example the first answer leads to 8 candies whereas in second answer we only need 6 candies (also satisfying both given constraint)."
                    },
                    {
                        "username": "user5714Oj",
                        "content": "1 2 1 2"
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "arr[i] : no of candies ith child have\\n\\n1. First give every child 1 candy so arr[i] = 1 for all i .\\n2. Traverse from left to right and if :\\n\\n\\tratings[i] > ratings[i-1] : we must give ith child atleast one more candy than (i-1)th child :\\n    arr[i] = arr[i-1] +1 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3. Traverse from Right to Left and if :\\n\\tratings[i] > ratings[i+1] : we must give ith child atleast one more candy than (i+1)th child:\\n\\tif(arr[i]<=arr[i+1])arr[i]=arr[i+1]+1 ;\\n\\t\\n 4. During the second traversal , we can observe that changing the values of arr doesn\\'t affects the relation maintained in the first traversal\\n 5. Hence, both the right and left neighbours relation are maintained, without affecting each other.\\n 6. We must observe that this is the minimum number of increament we can perform\\n"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "[@prashant_vish](/prashant_vish) Here\\nhttps://leetcode.com/submissions/detail/1048249860/"
                    },
                    {
                        "username": "prashant_vish",
                        "content": "Can you please provide solution link."
                    },
                    {
                        "username": "mridul",
                        "content": "The candy question on OJ is not clear..\\nCan someone helps me to understand the question..\\n\\nI mean what so you mean if child has higher rating (than whom??) it should have more candies than its neigbours (which neigbours ??)\\n\\ncan someone can give the sample test cases.. PLZ.."
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Refers to i+1 and i-1 as I think so"
                    },
                    {
                        "username": "sergei99",
                        "content": "Year 2014: \"Oh I don't understand this inconsistent and incomplete question\".\nYear 2023: \"Such a poor problem description\".\n9 years... nobody have addressed the matter."
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    }
                ]
            },
            {
                "id": 1568952,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 1567883,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 2055648,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 1756142,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 1566239,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 2055694,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 1566457,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 2055384,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 2055304,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 2055291,
                "content": [
                    {
                        "username": "cwang",
                        "content": "After reading the two-scanning solution to this question several times, I still cannot make myself sure that the result is optimal. Could anyone give a strict proof to it? Thanks!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "check out this https://www.youtube.com/watch?v=NS3hr2B2ZfE"
                    },
                    {
                        "username": "zzjjbb",
                        "content": "You can think this in a greedy way: first consider the \"valleys\" whose ratings are not higher than both neighbors. They can just get the minimum candies which is 1. Then you expand from the valleys and increase the candies. This is a more obvious way to think it is optimal and it's the same as the 2 scanning solution."
                    },
                    {
                        "username": "kmukund87",
                        "content": "Hi\\nWhen the question said children with higher rating get more candies than their neighbors, I assumed \\nthat neighbor children with equal rating get equal candies\\n\\nCase 1 (I agree with this)\\nProblem: [2, 2] \\nSolution: 2 Explanation: children are given [1,1] candies\\n\\nCase 2 (Not clear)\\nProblem: [1, 2, 2]\\nActual Solution: 5.\\n\\nThe children must be given [1, 2, 2] candies. The first one must get atleast 1. Which means the second one must get atleast 2.\\nSo the third child is also given 1? So neighbor children with equal rating get unequal candies?\\n\\nIs this not the case?\\n\\nThank you\\nMukund"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Your assumption is incorrect- the question doesn\\'t place any such constraint"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "New leetcode layout looks cool\\n"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Discrimination between children. They all deserve equal candy."
                    },
                    {
                        "username": "hzhang14",
                        "content": "Wrong Anser:\\nInput:\\t [1,2,2]      \\nOutput:\\t5        \\nExpected:\\t4  \\n\\nWhy expected answer is 4?\\ni think that should be given 1,2,2 candy. 5 in total.\\nAnyone can explain it to me?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "the result is [1,2,1] not [1,2,2]"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "Last child needs to be given only one candy, since there is no requirement for children with equal ratings to be given equal candies"
                    },
                    {
                        "username": "khe1154",
                        "content": "what a terrible question description."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/candy/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using two arrays\n\n  \n**Approach 3:** Using one array\n\n  \n**Approach 4:** Single Pass Approach with Constant Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Make sure to test against these three testcases:\\n```\\n[100, 80, 70, 60, 70, 80, 90, 100, 90, 80, 70, 60, 60]\\n[6, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 1, 0]\\n[20000, 20000, 16001, 16001, 16002, 16002, 16003, 16003, 16004, 16004, 16005, 16005, 16006, 16006, 16007, 16007, 16008, 16008, 16009, 16009, 16010, 16010, 16011, 16011, 16012, 16012, 16013, 16013, 16014, 16014, 16015, 16015, 16016, 16016, 16017, 16017, 16018, 16018, 16019, 16019, 16020, 16020, 16021, 16021, 16022, 16022, 16023, 16023, 16024, 16024]\\n```"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks "
                    },
                    {
                        "username": "callmecodeslayer",
                        "content": "I\\'m never gonna distribute candies like this."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "gg if you see this in an interview "
                    },
                    {
                        "username": "sergei99",
                        "content": "If they state the problem description in such a poor way, I would instantly remember of an urgent matter and escape that place forever. Working with people who can't express their thought is a nightmare."
                    }
                ]
            },
            {
                "id": 1968326,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 1968139,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 1571291,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 2056404,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 2056021,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 2055393,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 1980587,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 1927921,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 1571292,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 1568955,
                "content": [
                    {
                        "username": "mm541145",
                        "content": "very poor choice of words"
                    },
                    {
                        "username": "vhood",
                        "content": "[1,2,87,87,87,2,1]\\nWhy expected answer is 13? Are candies [1,1,2,3,4,1,1]? If so, the result of [1,2,2] should be [1,2,3] = 6."
                    },
                    {
                        "username": "ashish15678",
                        "content": "[@arnavsingh31](/arnavsingh31) i can\\'t even see your comment that you have tagged , please help :-)\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "for this test case candy array will look like :-\n[1,2,3,1,3,2,1] = 13 candies.\nif you want to know how read this :-\nhttps://leetcode.com/problems/candy/description/comments/1957038\nIf any issue please reply back will be happy to help."
                    },
                    {
                        "username": "axia",
                        "content": "One test case input is [1,2,2], the expected result is 4. I can not understand it. Should it be 5?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This is easier than I thought it was... greedy two passes got accepted."
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Sound like a problem written by managers of a cobalt mine in Africa."
                    },
                    {
                        "username": "sergei99",
                        "content": "or by an investment bank\\'s equity trader."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis is a tricky question, and you can come `close` to the solution but still it\\'s not fully intuitive.\\n\\nImagine, that the questions required that give more candy if the neighbour only on the `left` have `lesser` rating.\\n\\nThen, you would initially give `1` candies to all of them as it\\'s required to give minimum 1, then iterate and check if `ratings[i] > ratings[i-1]` , if yes, then `candies[i] = candies[i-1]+1`.\\n\\nBut in this question, neighbour is on` both side`.\\n\\nSo, you need to repeat the same iteration from `right to left`, for `right` neighbours and make edit in the same `candies` array.\\n\\nBut, make sure during the second iteration, that you fill up `candies[i]` only if the new value is `greater` than the previously stored value, so that both conditions are satisfied .\\n\\nreturn the sum of candies array.\\n\\nAlso, as many people mentioned, very unfair way to distributing candies `:( `\\n\\n\\n"
                    },
                    {
                        "username": "SakSwift",
                        "content": "Never in a million years i would have thought of this logic on my own!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is actually quite easy once you figure out the algorithm:\\nTraverse the children from left to right. Any child that has a higher rating than their LH neighbour gets 1 more candy than their LH neighbour. Otherwise they get 1 candy.\\nNext, traverse the children from right to left. Any child that has a higher rating than their RH neighbour gets 1 more candy than their RH neighbour - unless they already have more candies than their RH neighbour in which case the number of candies is unchanged.\\nFinally, add up all the candies and return the total to the caller."
                    },
                    {
                        "username": "lzhao",
                        "content": "Does it mean the kid is only required to have more candy than those next to him?\\n\\nSay\\n\\nrating: \\n[ 1, 15, 13 ]\\n\\nIs \\n[1, 2, 1] a valid answer?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@vaishali_p14](/vaishali_p14) ten years past :D"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Yes"
                    },
                    {
                        "username": "wasatch",
                        "content": "The requirements are : \\n  1.  Each child must have at least one candy.\\n  2.  Children with a higher rating get more candies than their neighbors.\\n\\nWill children with the same rating get the same number of candies? \\n\\nIs [1, 2, 1, 2, 1] an acceptable assignment for the rating list  [3, 4, 4, 4, 3]?"
                    }
                ]
            },
            {
                "id": 2056186,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 2056104,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 2055947,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 2055867,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 2055503,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 2055496,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 1957668,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 1922920,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 1914263,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 1856636,
                "content": [
                    {
                        "username": "Raman_Lamba",
                        "content": "try  1 2 87 4 3 2 1 and 1 2 87 87 87 2 1 first as test case if you understand them you understand this problem, oh btw they come out as 1 2 5 4 3 2 1 and 1 2 3 1 3 2 1"
                    },
                    {
                        "username": "anshu673",
                        "content": "thanks it helped!!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Q. prove coding is an art how many agree with me"
                    },
                    {
                        "username": "Ayush0208",
                        "content": "One of the worst written questions I\\'ve ever come across on LeetCode."
                    },
                    {
                        "username": "nt34542",
                        "content": "Everyone should get equal candies :<"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a great explanation](https://leetcode.com/problems/candy/solutions/4038177/100-easy-solution-with-explanation-and-example-visualization/) with visualization"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Hint: you can try prefix and suffix sum"
                    },
                    {
                        "username": "seeker_747",
                        "content": "why the solution of this question is not intuitive at all\\n"
                    },
                    {
                        "username": "3boodr",
                        "content": "I still didn\\'t solve this problem but to be honest i understood it much faster than the gas station one."
                    },
                    {
                        "username": "JJdeW",
                        "content": "how do i even pass the final test case if the output is supposed to be an invalid return value"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Didn\\'t solve the problem yet, just read the question and I\\'m laughing my ass off.\\nI feel like this question must have been written by Aldous Huxley\\'s grandson, what a dystopian world those few lines are setting up\\n\"sorry honey, you\\'re only getting two candies because you are not worth as much as your brother. He is simply the better child, why are you crying? :)\""
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "lol"
                    }
                ]
            },
            {
                "id": 1716445,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 1571289,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 1571290,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 1733697,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 1571287,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 1571288,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 2072078,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 2066897,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 2061625,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 2059743,
                "content": [
                    {
                        "username": "tsun_ud",
                        "content": "Can anyone explain why:\\nreturn len(ratings)\\nis not accepted? I don\\'t believe giving various amount of candy to children based on arbitrary rating is fair (and doing this in front of one another!)"
                    },
                    {
                        "username": "cycleo",
                        "content": "why the AC program give answer 10 in test example[ 3,2,1,1,4,3,3 ], how to give candies?"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "There is a O(n) solution, which scans the ratings[] twice. I have detailed algorithm and kind of proof in my blog [here][1]. However, I do think it is a proof... May be we can prove the correctness by contradiction. Anyway, I describe my solution briefly as follows.\\n\\nLet M[i] be the number of candies the i-th child has, M[i] is 1 at least. Additinally, it should meet two requirements:\\n\\n1) LEFT. For i > 0, M[i] > M[i-1] if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, M[i] > M[i+1] if ratings[i] > ratins[i+1].\\n\\nTo get the minimum sum of M[], we change the two requirements as:\\n\\n1) LEFT. For i > 0, **M[i] = M[i-1] + 1** if ratings[i] > ratings[i-1].\\n\\n2) RIGHT. For i < n-1, **M[i] = M[i+1] + 1** if ratings[i] > ratins[i+1].\\n\\nThen, the algorithm starts from i = 0 to n-2 for the first pass and compute M[] only following LEFT. Then in the second pass, starts from i = n-2 to 0 and update M[] following RIGHT and LEFT.\\n\\nAnyone has idea to prove that the algorithm would give the correct answer? or we do not need to prove since it is naturally correct?\\n\\n\\n  [1]: http://www.cnblogs.com/zzzdevil/p/3649525.html"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I would classify this as a medium "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I would classify you as a show off"
                    },
                    {
                        "username": "nanomag0",
                        "content": "Input: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\ncan anyone tell me why it's expected to be 4 not 5?"
                    },
                    {
                        "username": "lpicha3",
                        "content": "[@tonic2000](/tonic2000) 8 years later"
                    },
                    {
                        "username": "thinhnguyeniosdev",
                        "content": "By default, every child will get 1 candy. The child in the middle has 1 point more than the first child so she has 2 candies, the last child has the same point as the middle child so he still has the default number of candy which is 1. Therefore: (1)+(1+1)+(1) = 4"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "I got a wrong answer:\\nInput:\\t[1,2,4,4,3]\\nOutput:\\t10\\nExpected:\\t9\\n\\nmy output is 1+2+3+3+1 = 10. and \\nI think OJ's is 1+2+3+2+1 = 9\\n\\nhow can the third child has more candies than the fourth?\\n\\nbecause the requirement is \"Children with a higher rating get more candies than their neighbors\", the third child does not have higher rating than the fourth does."
                    },
                    {
                        "username": "aadithya18",
                        "content": "If you have ranking [1 1 1 2 2 2] it means only the 4 th child have a better ranking than its neighbour. So candies will be [1 1 1 2 1 1] but not [1 1 1 2 2 2] as the 5th and 6th child do not have better ranking than it\\'s neighbours."
                    },
                    {
                        "username": "aadithya18",
                        "content": "Here when there is a repeated rank, it means the rank is not more than its neighbour... hence [ 1 2 3 2 1] will be your answer"
                    },
                    {
                        "username": "derrickhuang",
                        "content": "I got confused on the test cases.\\nTextcase input :[29,51,87,87,72,12]\\nMy code generates :[1,1,2,3,1,1], and the total candies are 9.\\n\\nBut the excepted answer is 12.\\nCan somebody tell me what am I missing? Or the expected answer is wrong?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be =\n[1,2,3,3,2,1]= 12 candies \n \nYou gave only one candy to child at index 1 he should get 2 candy as he has a higher rating than his left neighbour."
                    },
                    {
                        "username": "aasthad27",
                        "content": "question is not clear , equal case ? "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah, I think that was made intentional. Or Leetcode just sucks with wording sometimes.\nTake these 2 cases.\n1. [5,5] \n- There are no neighbors here with a higher rating so both get 1 candy, so 2 total.\n2. [4,5,5,4] \n- First child no neighbor with higher rating so 1 candy. The second child has a higher rating than the first so he gets 2 candies, the third child has the same rating as second child, so he remains with 1, BUT the last child has a lower rating than the third one, so obviously the third child needs more so we give him 2 candies, the last gets 1. So [1,2,2,1] which is 6.\nNow imagine this group - [4,6,5,4] "
                    },
                    {
                        "username": "CoderLFG",
                        "content": "Hello all,\\nWhat is the ideal distribution for the input:\\n[1,2,87,87,87,2,1]\\nThe expected output is 13.\\nHow?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey, check out this comment thread, i asked about this question earlier.\\n\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "luised2094",
                        "content": "[1,2,87,87,87,2,1]\\n\\nWhy is this expected to be 13? I thiught that if the ratings were equal they don\\'t get an extra candy?\\n\\nThe example gives us [1,2,2] and returns 4, 1 for the first, 2 for the second (since he has a higher rating that the first but is equal to the third) and 1 for the third (since he has the same rating than the second).\\n\\nBut [1,2,87,87,87,2,1] it\\'s giving 2 extra candies to someone? I am guessing the ones in the middle?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Hey check out this comment thread. I asked about this question earlier.\\nhttps://leetcode.com/problems/candy/description/comments/2055757"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,1,3,2,1]=13 candies "
                    }
                ]
            },
            {
                "id": 2057852,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056713,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056595,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056578,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056533,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056493,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056485,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056469,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056432,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056422,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "<strong>I completed a 365-day streak with this problem.<strong>"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Congrats man. Great job\\uD83D\\uDC4C\\uD83D\\uDC4C"
                    },
                    {
                        "username": "sergei99",
                        "content": "Congrats."
                    },
                    {
                        "username": "cybyss",
                        "content": "I don't understand the requirements. Hypothetically, if the ratings are [1, 2, 3] then how many candies should each child get? Child #3 should get the most candies, obviously, but what about #2? It's not possible for him to have more candies than his neighbors, but at the same time he does have a higher rating than kid #1. \n\nAlso, how in hell is the example rating of [1, 2, 2]  supposed to produce the output 1, 2, 1? Does that third child not count as having a \"higher rating\"? Is that second requirement supposed to mean \"Children with a higher rating than their neighbors get more candies than either of their neighbors.\" Of course, such a phrasing doesn't account for the possibility of kids having a higher rating than one neighbor, and a lower rating than another neighbor."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@andykimchris](/andykimchris) By my explanation, it\\'s evident why [1,2,2] produces [1,2,1] candies. Remember the rule is a child must have a HIGHER rating than ANY of his neighbors. The last child here has only one neighbor and his rating is not higher. So he remains with 1"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Children with ratings [1,2,3] get [1,2,3] candies. The first child has only one neighbor to the right with a HIGHER rating, not just High. It\\'s comparison. So he remains with at least 1. The second child has a higher rating than his left neighbor so he gets 2. The third and final child has only one neighbor to the left and he has a higher rating, so gets more candies than him which is 3."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "I kind of get it but don\\'t get it ! It\\'s like i know what we should do but its just not working (gotta do brute force first then might get hints for better approach)"
                    },
                    {
                        "username": "aadithya18",
                        "content": "As a hint, I can make some tags for this problem like DP, Forward Pass and Backward Pass. \\n\\nIf you still feel blue, here is my solution. :) :) :)\\nhttps://leetcode.com/problems/candy/solutions/4041752/simple-solution-with-forward-pass-and-backward-pass-cpp-fully-explained-with-example/\\n\\nHappy Coding :)\\n"
                    },
                    {
                        "username": "pratham200209",
                        "content": "Not a hard question demote to medium"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "important test case \n`[1,2,87,87,87,2,1]`\n`[5,4,3,2,1]`"
                    },
                    {
                        "username": "Yuji-Itadorii",
                        "content": "Everyone is talking about the last child in the second test case that it is unfair for him to get 1 chocolate even though his rating is high :(\\n\\nI think, If you apply the idea of FCFS then you will get it :)"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "death by description"
                    },
                    {
                        "username": "sliiime",
                        "content": "Should be labeled as medium difficulty."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "input = [1,3,2,2,1]\\nexpected  =7;\\ni don\\'t get it how expected is 7\\naccording to second test case we have to give next same ratings less candies\\n\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@TanishkDhaka](/TanishkDhaka) no, it\\'s not. It\\'s [1,2,1,2,1], which sums up to 7. The third kid does not have less successful neighbours, so no payment. This is a cruel life."
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "as far as i can understand [1,4,3,2,1] \\nshould be the distribution"
                    }
                ]
            },
            {
                "id": 2056382,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056327,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056318,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056315,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056293,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056279,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056240,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056224,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056220,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056159,
                "content": [
                    {
                        "username": "problem_explorer",
                        "content": "A GREEdy algorithm would not be plenty for this algo?"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess \"greedy\" is related to the person distributing candies in such a manner, not to the algorithm. It\\'s a simple two-way scan of the array."
                    },
                    {
                        "username": "oamuga4057",
                        "content": "Haha. This is a problem\\nChildren with a higher rating get more candies than their neighbor. Goes ahead not to explain who a neighbor is. This guy\\'s a joke"
                    },
                    {
                        "username": "2200032870",
                        "content": "love the question but all children should get equal candies :)\\n\\n"
                    },
                    {
                        "username": "diggu18052002",
                        "content": "i cant believe i solved it already \\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "Bad Description make this question hard"
                    },
                    {
                        "username": "chengqqq",
                        "content": "Here are some good test cases to try out before submitting your solution:\\n\\nratings = [1,3,4,5,2]\\n\\nratings = [1, 2, 3, 3, 3]\\n\\nratings = [1, 3, 3, 4]"
                    },
                    {
                        "username": "anivaries",
                        "content": "I can (sadly) add a few more :   \\n  \\n[0, 1, 2, 5, 3, 2, 7]  \\n  \\n[1, 2, 87, 87, 87, 2, 1]  \\n  \\n[29, 51, 87, 87, 72, 12]  \\n  \\n[1, 6, 10, 8, 7, 3, 2]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Two Pass Approach:-\\n// Initialize each child with 1 candy\\n// First pass: Go from left to right, ensure right neighbor gets more candies if rating is higher\\n// Second pass: Go from right to left, ensure left neighbor gets more candies if rating is higher\\n// Calculate the total number of candies needed**"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "Another day spent half the time deciphering the question. "
                    },
                    {
                        "username": "mustafiz7",
                        "content": "And again an Update to Interface!!"
                    },
                    {
                        "username": "Boggers0",
                        "content": "unclear objective "
                    }
                ]
            },
            {
                "id": 2056122,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2056013,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2056005,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2055989,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2055961,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2055910,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2055906,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2055890,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2055882,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2055881,
                "content": [
                    {
                        "username": "shabha2004",
                        "content": "This is an easy question . A bit difficult to understand at first but then could solve under 30 mins . use two way search"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "can you explain how you came up with the idea"
                    },
                    {
                        "username": "deepakmadambi",
                        "content": "\\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D The problem is easy but problem description is hard to understand.\\n\\nEasy explanation of problem is: \\n\\nDistribute candy to all the children, ensuring that if a child has more ratings than their adjacent child, they receive extra candy \\uD83C\\uDF6C\\uD83D\\uDC66\\uD83C\\uDF6D."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "The goal is to find the minimum total number of candies needed to achieve this distribution. The code you provided solves this problem efficiently. Here\\'s a step-by-step explanation:\\n\\nInitialize variables:\\n\\nn is the number of children (equal to the size of the ratings vector).\\nCreate a new vector c of size n to store the number of candies each child will receive. Initialize all elements to 1 because initially, each child receives at least one candy.\\nFirst Pass - Forward:\\n\\nLoop through the ratings vector starting from the second child (index 1) to the last child (index n-1).\\nCompare the current child\\'s rating (ratings[i]) with the previous child\\'s rating (ratings[i-1]).\\nIf the current child\\'s rating is higher than the previous child\\'s, increment the number of candies for the current child (c[i]) by 1 compared to the previous child (c[i-1]). This ensures that higher-rated children receive more candies than their left neighbors.\\nSecond Pass - Backward:\\n\\nLoop through the ratings vector starting from the second-to-last child (index n-2) to the first child (index 0).\\nAgain, compare the current child\\'s rating (ratings[i]) with the next child\\'s rating (ratings[i+1]).\\nIf the current child\\'s rating is higher than the next child\\'s and the number of candies for the current child (c[i]) is less than or equal to the number of candies for the next child (c[i+1]), then update the number of candies for the current child (c[i]) to be one more than the next child. This ensures that higher-rated children receive more candies than their right neighbors, if necessary.\\nCalculate the Total:\\n\\nAfter both passes, the c vector contains the minimum number of candies required for each child while satisfying the given conditions.\\nFinally, calculate the total number of candies required by summing up all the values in the c vector using the accumulate function from the <numeric> library, and return that value as the result.\\n\\nGithub - https://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    },
                    {
                        "username": "Reptilianalien",
                        "content": "I have time limit exceeded on 44/48. Where can we see how much execution time are we allowed to know how far I am from getting it done?"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "I expected more complicated."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@SSHshadow2222](/SSHshadow2222) thanks for noticing."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looks like someone\\'s back at doing daily. Nice seeing you here again. \\uD83D\\uDCAA"
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "The children having same rank have no conditions, meaning\\nin case [1, 1, 1, 0] the candies will be distributed as [1, 1, 2, 1]\\nThe one next two zero should get more candies as its the higher ranking neighbor, but it is okay for 1, 1 neighbor to not have same candy amount. Hope this helps clarify the statement a bit more."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "For test case [1,2,87,87,87,2,1] shouldn\\'t the distribution as [ 1, 2, 3, 1, 2, 2, 1 ] be valid as conditions seem to be fulfilled. What am I missing can anyone please rectify? My ans for this test case = 12. But actual answer = 13."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy for this will be: \\n[1,2,3,1,3,2,1] =13 "
                    },
                    {
                        "username": "sergei99",
                        "content": "It\\'s symmetric. If you give the 3rd child 3, then you also give 3 to the 3rd child counted backwards from the end."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Hey leetcode please work on your problem statements. They are not clear at all and also the test cases are also not enough  to make the question clear.\\nAt least give such test cases which makes sense ."
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "This description is so poor written, literally had to look up a video only to understand what the problem is"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Back to the problems with diabetes. \\uD83D\\uDC80\\uD83D\\uDC4D\\n\\n**Note:** It took me `2h` to solve this problem alone (no inspiration, hints, or additional resources), so I\\'m sure you can do it too"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just solving the problem is easy. Solving it with a top execution time is hard."
                    }
                ]
            },
            {
                "id": 2055863,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055862,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055846,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055837,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055757,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055721,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055716,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055689,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055680,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055658,
                "content": [
                    {
                        "username": "MdFaisalHameed",
                        "content": "An easy one"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "Hello developers, I feel like this problem feels like it should be medium? Correct me if I am wrong! Otherwise, I think to improve at solving greedy problems, grind greedy questions on CodeForces to improve your intuition!"
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@sergei99](/sergei99) I completely agree with you! The problem statement is very ambiguous, further clarifications would\\'ve been better. For example, if they gave an example test case for: \\nratings = [1, 2, 2, 1]."
                    },
                    {
                        "username": "sergei99",
                        "content": "It is Hard... to understand the incomplete and ambiguous description of this problem."
                    },
                    {
                        "username": "anantverma711",
                        "content": "Solved it using Priority queues, which is not even mentioned in the topic tags."
                    },
                    {
                        "username": "SOHEL440",
                        "content": "int candy(vector<int>& ratings) {\\n      int n = ratings.size();\\n\\n        vector<int> pre(n , 1);\\n        vector<int> suff(n , 1);\\n\\n\\n/// at fist check for towards to left \\n        for(int  i = 1 ; i < n ; i ++){\\n          if(ratings[i] > ratings[i-1]){\\n            pre[i] = pre[i]+1;\\n\\n          }\\n\\n        }\\n\\n// then check toward right \\n\\n        for(int i = n-2 ; i >=0 ; i--){\\n          if(ratings[i] > ratings[i+1]){\\n\\n            suff[i] = suff[i]+1;\\n\\n          }\\n        }\\n \\n\\n        int sum =0;\\n/// sum the max no. of the pre and suff array\\n\\n        for(int i = 0 ; i < suff.size() ;i++){\\n          sum += max(pre[i] , suff[i]);\\n\\n        }\\n\\n\\n\\n       /* for(auto i : suff){\\n          cout << i << \" \";\\n        }*/\\n\\n        return sum;\\n\\n    } why not running [1,2,87,87,87,2,1] for this example\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Can someone help me understand why this [29,51,87,87,72,12] returns 12?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) np man, glad I was able to help you. :)"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Ahh got it, thanks man"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) sorry my bad I meant right neighbour. Let me correct it."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) and his left neighbor is 87?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@andykimchris](/andykimchris) because its rating is higher than his right neighbour."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@arnavsingh31](/arnavsingh31) Wait, why is the second 87 rating given 3 candies, why not 2?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case is :\\n[1,2,3,3,2,1]= 12 candies "
                    },
                    {
                        "username": "JigarRajput",
                        "content": "It should be tagged as very very easy!"
                    },
                    {
                        "username": "sanketpu",
                        "content": "Use prefix sum and postfix sum logic. Take their max and return the sum."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "this is my second time struggling with same question"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "https://www.youtube.com/watch?v=NS3hr2B2ZfE\\nPlz check out the video to know the questio n and solution"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I don\\'t think it\\'s hard."
                    }
                ]
            },
            {
                "id": 2055639,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055629,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055620,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055575,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055573,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055552,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055551,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055546,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055533,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055498,
                "content": [
                    {
                        "username": "nikhiljn",
                        "content": "If a child has a rating higher than one of its neighbors and lower than the other neighbor, then does he receive more candies than the one with the lower rating or more candies than both?"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Child should always get more candy than the neighbor with lower rating. "
                    },
                    {
                        "username": "Siddharth_Singh29",
                        "content": "[1, 2, 87, 87, 87, 2, 1]\\nhow does this test case give 13 as the result ??\\nthe max I can count is 11 - [1, 2, 2, 1, 2, 2, 1]"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "child at index 2 should receive more candy than at index 1 because it has higher rating than left neighbour.  Similar, should be done at index 4 then your total candy will increase to 13. Candy array will be\n[1,2,3,1,3,2,1]=13"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int count(int[] arr){\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n    public int candy(int[] ratings) {\\n        if(ratings.length==0){\\n            return 0;\\n        } else if (ratings.length==1){\\n            return 1;\\n        }\\n        int[] ans = new int[ratings.length];\\n       int check=0;\\n       while(check==0){\\n           check=1;\\n           if(ratings[0]>ratings[1] && ans[0]<=ans[1]){\\n               ans[0]=ans[1]+1;\\n               check=0;\\n           }\\n           for(int i=1;i<ratings.length-1;i++){\\n               if(ratings[i]>ratings[i-1] && ans[i]<=ans[i-1]){\\n                   ans[i]=ans[i-1]+1;\\n                   check=0;\\n               }\\n               if(ratings[i]>ratings[i+1] && ans[i]<=ans[i+1]){\\n                   ans[i]=ans[i+1]+1;\\n                   check=0;\\n               }\\n           }\\n           if(ratings[ratings.length-1]>ratings[ratings.length-2] && ans[ans.length-1]<=ans[ans.length-2]){\\n               ans[ans.length-1]=ans[ans.length-2]+1;\\n               check=0;\\n           }\\n\\n       }\\n       return count(ans)+ans.length;\\n    }\\n\\n}"
                    },
                    {
                        "username": "loziuu",
                        "content": "hard one came pretty early this week"
                    },
                    {
                        "username": "FaceToFaceBryce",
                        "content": "A tip I would give:\\n\\nI would look at one neighbor at a time. Go left to right, then right to left.\\n\\nMake sure the neighbor is strictly greater.\\n\\nIf the next neighbor already has more candy, you don\\'t give the current child anymore.\\n\\nFor example 2:\\n\\nlook behind\\nindex 1:  [1,1,1]\\nindex 2: [1,2,1] <----- We don\\'t check its left hand neighbor because they have the same rating.\\n\\n\\nlook ahead\\nindex 1: [1,2,1] <----- We don\\'t check its right hand neighbor because they have the same rating.\\nindex 0: [1,2,1]\\n\\nThink of it like you are giving kids candy in a line and you check the person behind them and see what\\'s in their bag. Then, you reverse their order and repeat to make sure you checked all possible neighbors.\\n\\nHope this made sense lol!"
                    },
                    {
                        "username": "Ankush_Kumar_",
                        "content": "optimal solution in C++\\n    int candy(vector<int>& ratings) {\\n        long long int n = ratings.size();\\n        long long int sum = 0;\\n        std :: vector<int> candies(n,1);\\n\\n       for (long long int i = 1; i < n; i++) {\\n        if (ratings[i] > ratings[i - 1]) \\n        {\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n       }\\n\\n       for (long long int i = n - 2; i >= 0; i--) {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n         {\\n            candies[i] = candies[i + 1] + 1;\\n         }\\n        }\\n        for(long long int i=0; i< n ; i++){\\n            sum += candies[i];\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Who else doesn\\'t like the new UI? I hate it!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Solution is not to hard but it\\'s hard to come up with the solution."
                    },
                    {
                        "username": "Xngzdai",
                        "content": "I found this helpful to understand the criteria of getting more candy...\\nA child may have two neighboring children if s/he is in the middle.\\nThen, two comparisons are made: one to the left neighbor and the other to the right neighbor.\\nWhichever, or may be both, comparison(s) are successful, this child gets one more candy.\\nThat is, one child could get up to 2 candies if s/he has the highest ratings among his/her two neighboring children."
                    },
                    {
                        "username": "user5400vw",
                        "content": "for those shooting for 100% - this is a performance test (second to last testcase):  \\narray of ints sequentially decreasing from 20000 to 1."
                    }
                ]
            },
            {
                "id": 2055495,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055481,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055474,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055468,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055464,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055378,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055363,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055325,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055324,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2055272,
                "content": [
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out below:\n```\n[1,3,2,2,1]\n[1,2,87,87,87,2,1]\n[2, 4, 2, 6, 1, 7, 3]\n```"
                    },
                    {
                        "username": "sourabhbarnawal",
                        "content": "[1,2,87,87,87,2,1]\\noutput - 12\\nexpected - 13\\ncan anybody explain this test case "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Give one candy to each child. Then give children extra candies depending upon whether their rating is higher than neighbours. \nCandy array for this test case would be \n[1,2,3,1,3,2,1]=13 candies. Note child at index 3 get only 1 candy because his rating is equal to both neighbours ratings. So in order to minimise total candy, we give him only 1 candy, such that both constraints are satisfied."
                    },
                    {
                        "username": "ibram-reda",
                        "content": "# More useful test Cases\n\n**Input:** : [2, 2, 2, 2]\n**candy** : [1, 1, 1, 1]\n**Output** : 4\n\n**Input:** : [1, 2, 3, 4, 5]\n**candy** : [1, 2, 3, 4, 5]\n**Output** : 15\n\n**Input:** : [5, 4, 3, 2, 1]\n**candy** : [5, 4, 3, 2, 1]\n**Output** : 15\n\n**Input:** : [1, 3, 3, 3, 3, 3, 1]\n**candy** : [1, 2, 1, 1, 1, 2, 1]\n**Output** : 9\n\n**Input:** : [4, 3, 3, 3, 3, 3, 4]\n**candy** : [2, 1, 1, 1, 1, 1, 2]\n**Output**: 9\n\n**Input:** : [1, 2, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 3, 2, 1]\n**Output** : 12\n\n**Input:** : [1, 2, 3, 3, 3, 2, 1]\n**candy** : [1, 2, 3, 1, 3, 2, 1]\n**Output**: 13\n\n\n\n### Explanation\nThe following conditions should be true.\n- each child has at least one candy\n- if the rating of chilled i bigger than ratings of chilled **i-1**, then candies given for chilled i must be greater than candies given for chilled **i-1**\n- if the rating of chilled i bigger than ratings of chilled **i+1**, then candies given for chilled i must be greater than candies given for chilled **i+1**\n- Minimize the candy count"
                    },
                    {
                        "username": "JayPokale",
                        "content": "It should be a medium level problem "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "After one year, I absolutely fogot the way I ever solved the problem. This time I use divide and conquer optimized by segment tree to solve it, with tc O(NlogN)."
                    },
                    {
                        "username": "mailtovishal29",
                        "content": "how the answer of this array [1,2,87,87,87,2,1] is expected 13?"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right:\\nratings[4] is greatest than ratings[5] and ratings[6] ---> give 2 candies\\nratings[5] is greatest than ratings[6] ---> give 1 candy\\nnow read it from right to left:\\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 13"
                    },
                    {
                        "username": "vu-dinh-hung",
                        "content": "It seems most solutions are doing two passes. IMO, a topological sort approach is a bit more intuitive.\n\nhttps://leetcode.com/problems/candy/solutions/4037814/python-topological-sort-o-n/?envType=daily-question&envId=2023-09-13"
                    },
                    {
                        "username": "hashiraaaama",
                        "content": "The description of the problem is difficult to understand. Which neighbors (left, right, both)? How many more candies (x2, x3)?"
                    },
                    {
                        "username": "a0518",
                        "content": "neighbour means both left and right, and it does not matter how many more candy you give i-th child, as long as it satisfy the condition"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you\\'re doing a recursive approach then one way you can avoid an infinite loop with score comparisons is to only compare the candy counts if the rating of i - 1 or i + 1 is less than the rating at i. That way it just travels down to the minimum neighbor in a recursive chain and returns 1, which then next up in the stack returns 2, etc.."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Nice look. :)"
                    }
                ]
            },
            {
                "id": 2053577,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2052251,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2048369,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2044715,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2040266,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2038699,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2032295,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2013753,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2008738,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 2000594,
                "content": [
                    {
                        "username": "aacontr",
                        "content": "For ratings of [1,2,87,87,87,2,1] I got [1, 2, 2, 1,2, 2, 1] = 11, but it claims correct answer is 13. If we\\'re just comparing neighbors then I believe my answer is correct, what am I missing?\\n\\nindex[0] = 1 < 2 = 1\\nindex[1] = 2 > 1 = 2\\nindex[2] = 87 > 2 = 2\\nindex[3] = 87 === 87 = 1\\nindex[4] = 87 > 2 = 2\\nindex[5] = 2 > 1 = 2\\nindex[6] = 1 < 2 = 1"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "You are giving same number of candies to child at i=1 and i=2, which is wrong \\u2026child at i= 2 has higher rating than child at i=1, so he should get more candy as per constraints. Similarly child at i=4 should get more candy than child at i=5. Then your total will increase up to 13."
                    },
                    {
                        "username": "x544D",
                        "content": "poorly written."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "how the output of [1,2,87,87,87,2,1] is 13 ? why not 12 as [1, 2, 3, 2, 1, 2, 1]."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Thank you for your answer"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Akshagrawal](/Akshagrawal) Question asks for minimum candies so, we try to find what min number of candies we should give to each child such that both given constraints are satisfied. For this case if give only 1 candy to child at index 3, our both constraints are fulfilled.\\n\\nHope you get it :) .Ask if u still have any doubts."
                    },
                    {
                        "username": "Akshagrawal",
                        "content": "Got it. Why not 2 at index 3, instead of 1."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :- [1,2,3,1,3,2,1]= 13 candies. You are giving less candy to children at index 4 even though he has higher rating than his right neighbour."
                    },
                    {
                        "username": "shekhawatdatarsingh08",
                        "content": "If yes, their candies are equal?\\nif ratings are [1, 3, 3, 4], candies can be 1, 2, 2, 3 ? or 1, 2, 1, 2?\\n\\n\\n"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "For this test case candy array will be = [1,2,1,2]"
                    },
                    {
                        "username": "little_late",
                        "content": "thats partiality and favouritism :( "
                    },
                    {
                        "username": "sohaibsyed",
                        "content": "the example 2 doesn\\'t make sense as both the kid and neighbor have same rating of 2 but one gets 1 and the other gets 2 candies. "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "There is no constraint stating that children with same rating get same candy. Child at index 1 gets more candy than child at index 2 because it has a neighbour whose rating is lower(child at index 0), so as per 2nd constraint he should get more candy than child at i =0. While for child at i =2 doesn\\u2019t have any neighbour whose rating is lower than him so by giving him 1 candy only satisfies both given constraints."
                    },
                    {
                        "username": "chegusyam396",
                        "content": "poor explanation\\n"
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem Statement is not clear.\n[ 1, 2, 2 ] should output 3 as we give [1, 1, 1] i.e. no peak found in ratings.\n(children with higher ratings gets...) this point is not clear.\n\nWhen Non-Programmers design Problems. "
                    },
                    {
                        "username": "__sig",
                        "content": "Poorly phrased question.\\n\"Children with a higher rating get more candies than their neighbors.\"\\n???\\nInformal and incomplete."
                    },
                    {
                        "username": "noauziel",
                        "content": "[1,6,10,8,7,3,2] why is the result of this test is - 18 and not 16 \\ncan someone please write the corresponding candies array ? \\nThanks "
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "Candy array for this test case will be :\\n[1,2,5,4,3,2,1] = 18 candies "
                    }
                ]
            },
            {
                "id": 1993462,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1992595,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1990592,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1983190,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1959773,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1957016,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1955646,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1954632,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1935964,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1930264,
                "content": [
                    {
                        "username": "as_runtime123",
                        "content": "Why this question is in Hard difficulty?? And even likes are so much. Do you actually find this hard??"
                    },
                    {
                        "username": "aruvian",
                        "content": "It says time limit exceeded, but all test cases passed, and just shows an empty test case as the last one. I don't get what's going on...\nEdit: nvm, figured it out. I still don't know why it reacted that way in particular instead of showing which test cases actually failed, but oh well."
                    },
                    {
                        "username": "Ryz3N",
                        "content": "what is the 48 th testcase my code timelimit at  at that test case but when i use the test case its empty !!"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "proper explanation of question (updating last part): \\n1. for any no. at index (i)if any of its Neighbours (i+1,i-1) has greater rating then it should have more  candies than its neighbor\\n\\n2. In case neighbors is equal we need not to do anything."
                    },
                    {
                        "username": "Vucius",
                        "content": "I cannot understand why the result of `ratings = [1,3,2,2,1]` is 7. According to rule 2, shouldn\\u2019t the result be 1+3+2+2+1 == 9?"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31) Thank you for your answer, although I still don\\u2019t understand your thought process. I am now adding candy by traversing from left to right and then from right to left. Sincerely thank you."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@Vucius](/Vucius) No i think you misunderstood the explanation....for this test case, child at i=2 has higher rating than child at i=1 so he should receive 3 candy instead of 2. And similary child at i=4 should also receive 3 candy instead of 2 as this child rating is higher than child at i=5. So candy array would look like :- [1,2,3,1,3,2,1] = 13 candies. \n\n** Children with more rating than their neighbour should get more candy.\nRead this if you still have a doubt:-> https://leetcode.com/problems/candy/description/comments/1955647"
                    },
                    {
                        "username": "Vucius",
                        "content": "[@arnavsingh31](/arnavsingh31)  So, what about the case of ratings = `[1,2,87,87,87,2,1]`?According to your explanation, the answer should it be `1+2+2+1+2+2+1`?\\u201D"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "First give 1 candy to each child, which brings up the total candy to 5. Now child at i=3 should receive more candy due to its higher rating than child at i=4. So we give +1 candy to child i =3, but it isn\\u2019t necessary to give same number of candies to children with same ratings i.e child at i =2 need not to receive one extra candy. Now child at i=1 should also receive +1 more candy due to higher rating than both neighbours. So now candy array looks like =[1,2,1,2,1] = 7 candies."
                    },
                    {
                        "username": "somniumcaeruleum",
                        "content": "[1,2,87,87,87,2,1]\\nOutput: 9\\nExpected: 13\\n\\nI don\\'t get it. Why should expected answer is 13? And the definition of \"neighbors\" in 2nd rule is very tricky."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "[@vhood](/vhood) it is true that child at i=1 has lower rating than child at i=2 but it also has higher rating than child at i =0thats y we add +1 more candy. It doesnt mean rating should be higher than both neighborsif rating is higher than only 1 neighbor then also we will be giving extra candy to the respective child. Question doesnt say that rating has to be higher than BOTH neighbors."
                    },
                    {
                        "username": "vhood",
                        "content": "[@arnavsingh31](/arnavsingh31) \"Children with a higher rating get more candies than their neighbors\", Child(i=1) hasn\\'t a higher rating, because Child(i=2) has. Why should we add one more candy to it? It deserves only 1 candy"
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "As per the given constraints all children must receive at least 1 candy and Children with a higher rating get more candies than their neighbours. for example [1,2,87,87,87,2,1]----> (fyi :- i means index)\nfirst we give 1 candy to each child. (satisfying our first constraint)\nNow we see that Child(i=1) has higher rating than Child(i=0) so we give +1 more candy to Child(i=1), now Child(i=1) has total 2 candies. \nChild(i=2) also have higher rating than Child(i=1), so as per our 2nd constraint Child(i=2) should receive more candy than neighbour Child(i=1), so we have to give him 2 more candies to satisfies our constraint, now Child(i=2) have total 3 candies. \nChild(i=3) has same rating as its neighbour children so we don't have to give  more candy to that child.\nChild(i=5) has higher rating than child(6) so we must give him also +1 more candy, resulting in total of 2 candies for child(i=5).\nChild(i=4) has higher rating than child(5) so we need to give him +2 more candies to satisfy our 2nd constraint, so child(i=4) gets total of 3 candies.\nNow if we look at how many candies each child gets are:---\n[1,2,3,1,3,2,1]= 13 candies in total. \n\n2nd constraint only says that if the current child has higher rating than his neighbouring child/s then he must get more candies than his neighbours.\n\nHere neighbours mean immediate neighbours, for any child at index i its neighbours are child at i-1 and child at i+1. for child at i=0 will have only 1 neighbour( child at i=1) and similarly for child at i = length(ratings) - 1 will also have only one neighbour(child at i-1)."
                    },
                    {
                        "username": "kadamsanjeevpatil",
                        "content": "var candy = function(ratings) {\n    const n = ratings.length;\n    const candies = new Array(n).fill(1);\n    for(let i=1; i<n; i++){\n        if(ratings[i] > ratings[i-1]){\n            candies[i] = candies[i-1]+1;\n        }\n    }\n    for(let i=n-2; i>=0; i--){\n        if(ratings[i] > ratings[i+1]){\n            candies[i] = Math.max(candies[i], candies[i+1]+1)\n        }\n    }\n    return candies.reduce((a,b)=>a+b, 0);\n};"
                    },
                    {
                        "username": "anugrahaparameswar",
                        "content": " public int candy(int[] ratings) {\\n        int candies = ratings.length;\\n\\n        for(int i=0;i<ratings.length;++i){\\n            if(i==0 && ratings[i]>ratings[i+1]){\\n                candies += 1;\\n            }\\n            else if(i==ratings.length-1 && ratings[i]>ratings[i-1]){\\n                candies += 1;\\n            }\\n            else if(i>0 && i<ratings.length-1 && (ratings[i]>ratings[i+1] || ratings[i]>ratings[i-1])){\\n                candies += 1;\\n            }\\n        }\\n        return candies;\\n    }\\n[1,2,87,87,87,2,1] for this input my code is giving the output as 11 but the correct output is 13.but i didnt understand that."
                    },
                    {
                        "username": "arnavsingh31",
                        "content": "After doing a dry run of the above code each child receives following number of candies :\\n[1,2,2,1,2,2,1] which equals 11. The problem with code is that your code doesn\\'t take into account that children  at index(2), rating 87 and index(4) ,rating 87 should receive more candy than children with rating 2 index(1) & (5) respectively. \\nfor this test case :--->\\nAt i=1, last if-else will be executed only (as i>0 && i< ratings.length && ratings[1] > ratings[0] ) here you increase total candy by 1 which also means that you gave +1 candy to the child, so child (i=1) receives 2 candies in total (since you are already giving 1 candy to each child at the beginning) . Then at i =2 , again last if-else will be executed, this time ratings[2] (=87)  > ratings[1] (=2), and you again increase total candy by 1 which means that you gave +1 candy to child(i=2), so child(i=2) received 2 candies in total but as we can see its rating is higher than child(i=1) [who also received 2 candies] so child(i=2) should received more candy than child (i=1) (as per given constraints of the problem). Similarly,  child(i=4) should also receive more candy than child(i=5). That is y there is difference of 2 candies in your o/p(11) and correct answer(13). Correct distribution for this test case will be [1,2,3,1,3,2,1] = 13 candies."
                    },
                    {
                        "username": "nerdstv",
                        "content": "First, Give 1 candy to each, then compare every i th  child with (i-1) th child and take total candies and do same while comparing i th with i+1 th child. Then the total which is greater is your answer.\n\nPlease try yourself first.\nHere is my code: https://leetcode.com/problems/candy/solutions/3656893/explained-through-comments-c-simple-logic/"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Hi,\\n[1,2,87,87,87,2,1] for this test case, the distribution as per my understanding should be -> [1,2,2,1,2,2,1] which equals to a sum of 11 candies, however, the answer is 13. My understanding is that there should be at least 1 candy to each child, and a child with rating higher than it\\'s neighbor should get +1(Assuming +1 as we would need to find the minimum no. of candies to be distributed).\\nAny insights ?\\nThanks in advance "
                    },
                    {
                        "username": "psionl0",
                        "content": "87 > 2 so the third child should get 3 candies as should the 3rd child from the left"
                    }
                ]
            },
            {
                "id": 1923261,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1921648,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1917501,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1917348,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1915249,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1913837,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1913297,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1900216,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1878409,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1868469,
                "content": [
                    {
                        "username": "saurabh36521",
                        "content": "I Think This Problem Is Designed By My school\\n"
                    },
                    {
                        "username": "pravinkanna",
                        "content": "Can Someone please explain \\n\\n`Given Input: [29,51,87,87,72,12]`\\n\\n`Expected Output: 16`\\n\\n`Actual Output: 12`"
                    },
                    {
                        "username": "iburgos72",
                        "content": "Read the input from left to right: \\nratings[3] is greatest than ratings[4] and ratings[5] ---> give 2 candies\\nratings[4] is greatest than ratings[5] ---> give 1 candy\\nnow read it from right to left: \\nratings[2] is greatest than ratings[1] and ratings[0] ---> give 2 candies\\nratings[1] is greatest than ratings[0] ---> give 1 candies\\n\\n6 candies so far\\n\\nnow give each children 1 candy and you get 12"
                    },
                    {
                        "username": "psionl0",
                        "content": "This test case is now giving the expected output as 12."
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "What does your candy array look like? I'm still working on a non-copilot version myself, but given the rules it should be [1, 2, 3, 3,2,1] which is 12.. So I agree with you that this is weird."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Morally Isn\\'t it incorrect to give less candy to someone who has higher rating?????????\\nSo the followup question is that you give candies with same conditions but one more point and that is children with higher rating should have more candies!!!!!"
                    },
                    {
                        "username": "devangmp",
                        "content": "One another constraint should.\\nNo three children can have same ratings."
                    },
                    {
                        "username": "aman1320",
                        "content": "How many of you are thinking to hash the number of increasing sequences? PLease don\\'t to it !!"
                    },
                    {
                        "username": "Amortal",
                        "content": "i am keeping track of asending and descending sequences. \\n"
                    },
                    {
                        "username": "virajlanghnoda",
                        "content": "[1,2,87,87,87,2,1] for this testcase why the answer is 13 not 11.\\n"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s."
                    },
                    {
                        "username": "ismoilhasanov68",
                        "content": "how output for this test [1,2,87,87,87,2,1] can be 13?? Isnt it 11?\nratings[0] = 1\nratings[1] = 2\nratings[2] = 2\nratings[3] = 1\nratings[4] = 2\nratings[5] = 2\nratings[6] = 1\nSo output is 11\nPlease correct me if smth is wrong"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 3\\'s. "
                    },
                    {
                        "username": "raj_krish",
                        "content": "If the ratings are [29,51,87,78,72,12], how should the candies be distributed?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "candies: [ 1, 2, 4, 3, 2, 1] = 13, right?"
                    },
                    {
                        "username": "sanghota4567",
                        "content": "Can someone tell me how  [1,2,87,87,87,2,1] gives ans as 13, for me it is 14 -> [1, 2, 3, 2, 3, 2, 1]. "
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Should be [ 1, 2, 3, 1, 3, 2, 1 ], you are missing the 1 in the middle since it is not higher than the left of the right."
                    },
                    {
                        "username": "nandoaires",
                        "content": "Isn\\'t this problem too simple to a hard problem? I spent more time making sure my solution was correct than actually designing the solution..."
                    }
                ]
            },
            {
                "id": 1859191,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 1764545,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 1756354,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 1749431,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 1745986,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 1745516,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 1715052,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 1706741,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 1568953,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            },
            {
                "id": 2064421,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "I proposed another original O(n) approach, based on graphs [here](https://leetcode.com/problems/candy/solutions/3399841/simple-graph-approach-kahns-algorithm-humiliates-children-in-on/).\n\nDon't worry it is actually super simple! It is in fact a reformulation as a very famous algorithm that you probably already know. Have a look!"
                    },
                    {
                        "username": "divyangtiwari52",
                        "content": "The following program is of the  Candy problem , my question is that the program is giving correct result on VsCode on test case  [1,0,2]  the result is 5 and it is also expected result but LeetCode is showing the result 6 on the same program . \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\nint candy(vector<int> & ratings) {\\n      \\n     int length = ratings.size();\\n\\n    int sum  ;\\n\\n    vector<int> candies(length, 1);\\n\\n    for (int i = 1; i < length; i++)\\n    {\\n        if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1])\\n        {\\n\\n            candies[i] = candies[i - 1] + 1;\\n        }\\n    }\\n\\n    for (int i = length - 2; i >= 0; i--)\\n    {\\n        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])\\n        {\\n\\n            candies[i] = candies[i + 1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0 ; i < length ; i++ )\\n    {\\n\\n        sum +=candies[i] ;\\n    }\\n\\n    return sum;\\n}\\n\\n\\n\\n\\n \\n};\\n\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "abishek129",
                        "content": " In 16th test case \\nratings=[1, 2, 87, 87, 87, 2, 1]\\n1st everyone gets a candy so candy count C= 7.\\nNow 1st element is greater than 0th element so C++,C=8\\n2rd element is greater than 1st element so C++, C=9\\n2nd, 3rd ,4th are equal so no change in C, C=9\\n4th element is greater than 5th element  so C++, C=10\\n5th element is greater than 6th so C++, C=11\\nBut expected output is 13\\nAnyone please explain this"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[29,51,87,87,72,12]\\nwhat will be the output of this 16 or 12??\\n"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "its 12 . the final distribution would be [1, 2, 3, 3, 2, 1]"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "I got wrong answer here :\\n\\nInput: [1,2,2]\\nOutput: 5\\nExpected: 4\\n\\nThe requirement is : Children with a higher rating get more candies than their neighbors.\\nHow about equal ratings ? Guys, how do you understand such requirement ?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "looks specifically at: Children with a higher rating get more candies than their neighbors.\\n\\nMap the candies out [1, 2, 1]"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is provided as an example case, and it is here to make it clear that an equal rating is not considered higher, I don't see a problem here"
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        int candies[n];\\n\\n        for(int i=0; i<n; i++) {\\n            candies[i] = 1;\\n        }\\n        // Left to right comparsion:\\n        for(int i=1; i<n; i++) {\\n            if(ratings[i] > ratings[i-1]) {\\n                candies[i] = candies[i-1] + 1;\\n            }\\n        }\\n        // Right to left comparsion:\\n        for(int i=n-2; i >= 0; i--) {\\n            if(ratings[i] > ratings[i+1]) {\\n                candies[i] = max(candies[i], candies[i+1]+1);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto x : candies) {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "shubhampathak0809",
                        "content": "can anyone tell what is time and space complexity in this question?\\n"
                    },
                    {
                        "username": "alex6",
                        "content": "test case [1, 2, 2] needs 5 candies, but the expecting is 4, why?"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n=ratings.size();\\n        vector<int>pre(n);\\n        int max=1;\\n        pre[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(ratings[i]>ratings[i-1]){\\n                max=max+1;\\n                pre[i]=max;\\n            }\\n            else{\\n                max=1;\\n                pre[i]=max;\\n            }\\n        }\\n        \\n        vector<int>suff(n);\\n        max=1;\\n        suff[n-1]=max;\\n        for(int i=n-2;i>=0;i--){\\n            if(ratings[i]>ratings[i+1]){\\n                max=max+1;\\n                suff[i]=max;\\n            }\\n            else{\\n                max=1;\\n                suff[i]=max;\\n            }\\n        }\\n\\n        int sum=0;\\n        int d;\\n        for(int i=0;i<n;i++){\\n           if(pre[i]>suff[i]){\\n               d=pre[i];\\n           }\\n           else{\\n               d=suff[i];\\n           }\\n           sum+=d;\\n        }\\n        return sum;\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Why are you posting a solution here?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Shopping Offers",
        "question_content": "<p>In LeetCode Store, there are <code>n</code> items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.</p>\n\n<p>You are given an integer array <code>price</code> where <code>price[i]</code> is the price of the <code>i<sup>th</sup></code> item, and an integer array <code>needs</code> where <code>needs[i]</code> is the number of pieces of the <code>i<sup>th</sup></code> item you want to buy.</p>\n\n<p>You are also given an array <code>special</code> where <code>special[i]</code> is of size <code>n + 1</code> where <code>special[i][j]</code> is the number of pieces of the <code>j<sup>th</sup></code> item in the <code>i<sup>th</sup></code> offer and <code>special[i][n]</code> (i.e., the last integer in the array) is the price of the <code>i<sup>th</sup></code> offer.</p>\n\n<p>Return <em>the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers</em>. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]\n<strong>Output:</strong> 14\n<strong>Explanation:</strong> There are two kinds of items, A and B. Their prices are $2 and $5 respectively. \nIn special offer 1, you can pay $5 for 3A and 0B\nIn special offer 2, you can pay $10 for 1A and 2B. \nYou need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> The price of A is $2, and $3 for B, $4 for C. \nYou may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. \nYou need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. \nYou cannot add more items, though only $9 for 2A ,2B and 1C.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == price.length == needs.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 6</code></li>\n\t<li><code>0 &lt;= price[i], needs[i] &lt;= 10</code></li>\n\t<li><code>1 &lt;= special.length &lt;= 100</code></li>\n\t<li><code>special[i].length == n + 1</code></li>\n\t<li><code>0 &lt;= special[i][j] &lt;= 50</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 105212,
                "title": "very-easy-to-understand-java-solution-beats-95-with-explanation",
                "content": "The idea is very similar to combination sum. In combination sum where each element can be repeated, check each element to see if it can be used (in this case, if the sum doesn't exceed the target). If so, use it. Repeat this until we get the result.\\n\\nFor this question, we check each promotion offers, if the offer can be used, use it. Repeat the process and find the minimum result. In this question, the condition whether one offer can be used is the number of items in the offer doesn't exceed the needed number. Find the minimum among all combinations. \\n\\nThe thing to remember, which also happens in real life is that some special offers are actually more expensive than buying each individual item in the offers!!! Thus be smart and compare if buying directly is cheaper.\\n\\nhere is my code:\\n\\n```\\npublic class Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n    \\treturn helper(price, special, needs, 0);\\n    }\\n    \\n    private int helper(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int pos) {\\n    \\tint local_min = directPurchase(price, needs);\\n    \\tfor (int i = pos; i < special.size(); i++) {\\n    \\t\\tList<Integer> offer = special.get(i);\\n    \\t\\tList<Integer> temp = new ArrayList<Integer>();\\n        \\tfor (int j= 0; j < needs.size(); j++) {\\n        \\t\\tif (needs.get(j) < offer.get(j)) { // check if the current offer is valid\\n        \\t\\t\\ttemp =  null;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t\\ttemp.add(needs.get(j) - offer.get(j));\\n        \\t}\\n        \\t\\n    \\t\\tif (temp != null) { // use the current offer and try next\\n    \\t\\t\\tlocal_min = Math.min(local_min, offer.get(offer.size() - 1) + helper(price, special, temp, i)); \\n    \\t\\t}\\n    \\t}\\n\\n    \\treturn  local_min;\\n    }\\n    \\n    private int directPurchase(List<Integer> price, List<Integer> needs) {\\n    \\tint total = 0;\\n    \\tfor (int i = 0; i < needs.size(); i++) {\\n    \\t\\ttotal += price.get(i) * needs.get(i);\\n    \\t}\\n    \\t\\n    \\treturn total;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n    \\treturn helper(price, special, needs, 0);\\n    }\\n    \\n    private int helper(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int pos) {\\n    \\tint local_min = directPurchase(price, needs);\\n    \\tfor (int i = pos; i < special.size(); i++) {\\n    \\t\\tList<Integer> offer = special.get(i);\\n    \\t\\tList<Integer> temp = new ArrayList<Integer>();\\n        \\tfor (int j= 0; j < needs.size(); j++) {\\n        \\t\\tif (needs.get(j) < offer.get(j)) { // check if the current offer is valid\\n        \\t\\t\\ttemp =  null;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t\\ttemp.add(needs.get(j) - offer.get(j));\\n        \\t}\\n        \\t\\n    \\t\\tif (temp != null) { // use the current offer and try next\\n    \\t\\t\\tlocal_min = Math.min(local_min, offer.get(offer.size() - 1) + helper(price, special, temp, i)); \\n    \\t\\t}\\n    \\t}\\n\\n    \\treturn  local_min;\\n    }\\n    \\n    private int directPurchase(List<Integer> price, List<Integer> needs) {\\n    \\tint total = 0;\\n    \\tfor (int i = 0; i < needs.size(); i++) {\\n    \\t\\ttotal += price.get(i) * needs.get(i);\\n    \\t}\\n    \\t\\n    \\treturn total;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105252,
                "title": "concise-c-dfs-solution-6ms",
                "content": "```\\nint shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int cost = 0) {\\n    if (needs < 0)\\n        return INT_MAX;\\n\\n    int m = inner_product(needs.begin(), needs.end(), price.begin(), cost);\\n\\n    for (auto &offer : special) {\\n        if (cost + offer.back() >= m) // pruning\\n            continue;\\n        needs -= offer;\\n        m = min(m, shoppingOffers(price, special, needs, cost + offer.back()));\\n        needs += offer;\\n    }\\n\\n    return m;\\n}\\n```\\n\\nwith the following operators defined above the Solution class:\\n```\\nvoid operator+=(vector<int> &a, const vector<int> &b) {\\n    for (int i = 0; i < a.size(); i++)\\n        a[i] += b[i];\\n}\\n\\nvoid operator-=(vector<int> &a, const vector<int> &b) {\\n    for (int i = 0; i < a.size(); i++)\\n        a[i] -= b[i];\\n}\\n\\nbool operator<(const vector<int> &a, const int &n) {\\n    for (int i : a)\\n        if (i < n)\\n            return true;\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int cost = 0) {\\n    if (needs < 0)\\n        return INT_MAX;\\n\\n    int m = inner_product(needs.begin(), needs.end(), price.begin(), cost);\\n\\n    for (auto &offer : special) {\\n        if (cost + offer.back() >= m) // pruning\\n            continue;\\n        needs -= offer;\\n        m = min(m, shoppingOffers(price, special, needs, cost + offer.back()));\\n        needs += offer;\\n    }\\n\\n    return m;\\n}\\n```\n```\\nvoid operator+=(vector<int> &a, const vector<int> &b) {\\n    for (int i = 0; i < a.size(); i++)\\n        a[i] += b[i];\\n}\\n\\nvoid operator-=(vector<int> &a, const vector<int> &b) {\\n    for (int i = 0; i < a.size(); i++)\\n        a[i] -= b[i];\\n}\\n\\nbool operator<(const vector<int> &a, const int &n) {\\n    for (int i : a)\\n        if (i < n)\\n            return true;\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 992433,
                "title": "c-recursion-clean-code",
                "content": "The algorithm is:\\n1. Calculate the total price without using any offers.\\n2. For each offer:\\n\\t2.a) Apply it to the current needs\\n\\t2.b) Check if needs doesn\\'t have any negative values, i.e. that we are not buying more items than needed (this is not allowed by definition)\\n\\t2.c) Calculate the best price with the current offer by adding the offer\\'s value and recursing with the updated needs.\\n\\t2.d) Backtrack by adding the offer back to the needs. \\n\\n```\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int bestPrice = calculateWOOffers(price, needs);\\n        for (const auto& sp : special) {\\n            substractOffer(sp, needs);\\n            if (noNegatives(needs)) {\\n                int withOffer = sp.back() + shoppingOffers(price, special, needs);\\n                bestPrice = min(bestPrice, withOffer);\\n            }\\n            addOffer(sp, needs);\\n        }\\n\\n        return bestPrice;\\n    }\\n    \\n    int calculateWOOffers(const vector<int>& price, const vector<int>& needs) {\\n        int totalPrice{0};\\n        for (size_t i = 0; i < price.size(); ++i)\\n            totalPrice += price[i] * needs[i];\\n        return totalPrice;\\n    }\\n    \\n    void substractOffer(const vector<int>& special, vector<int>& needs) {\\n        for (size_t i = 0; i < needs.size(); ++i)\\n            needs[i] -= special[i];\\n    }\\n    \\n    void addOffer(const vector<int>& special, vector<int>& needs) {\\n        for (size_t i = 0; i < needs.size(); ++i)\\n            needs[i] += special[i];\\n    }\\n    \\n    bool noNegatives(const vector<int>& needs) {\\n        for (int n : needs)\\n            if (n < 0)\\n                return false;\\n        return true;\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "The algorithm is:\\n1. Calculate the total price without using any offers.\\n2. For each offer:\\n\\t2.a) Apply it to the current needs\\n\\t2.b) Check if needs doesn\\'t have any negative values, i.e. that we are not buying more items than needed (this is not allowed by definition)\\n\\t2.c) Calculate the best price with the current offer by adding the offer\\'s value and recursing with the updated needs.\\n\\t2.d) Backtrack by adding the offer back to the needs. \\n\\n```\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int bestPrice = calculateWOOffers(price, needs);\\n        for (const auto& sp : special) {\\n            substractOffer(sp, needs);\\n            if (noNegatives(needs)) {\\n                int withOffer = sp.back() + shoppingOffers(price, special, needs);\\n                bestPrice = min(bestPrice, withOffer);\\n            }\\n            addOffer(sp, needs);\\n        }\\n\\n        return bestPrice;\\n    }\\n    \\n    int calculateWOOffers(const vector<int>& price, const vector<int>& needs) {\\n        int totalPrice{0};\\n        for (size_t i = 0; i < price.size(); ++i)\\n            totalPrice += price[i] * needs[i];\\n        return totalPrice;\\n    }\\n    \\n    void substractOffer(const vector<int>& special, vector<int>& needs) {\\n        for (size_t i = 0; i < needs.size(); ++i)\\n            needs[i] -= special[i];\\n    }\\n    \\n    void addOffer(const vector<int>& special, vector<int>& needs) {\\n        for (size_t i = 0; i < needs.size(); ++i)\\n            needs[i] += special[i];\\n    }\\n    \\n    bool noNegatives(const vector<int>& needs) {\\n        for (int n : needs)\\n            if (n < 0)\\n                return false;\\n        return true;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 105204,
                "title": "python-dfs-with-memorization",
                "content": "```\\ndef shoppingOffers(self, price, special, needs):\\n        d = {}\\n        def dfs(cur):\\n            val = sum(cur[i]*price[i] for i in range(len(needs))) #cost without special\\n            for spec in special:\\n                tmp = [cur[j] - spec[j] for j in range(len(needs))]\\n                if min(tmp) >= 0: # skip deals that exceed needs\\n                    val = min(val, d.get(tuple(tmp), dfs(tmp)) + spec[-1]) # .get check the dictionary first for result, otherwise perform dfs.\\n            d[tuple(cur)] = val\\n            return val\\n        return dfs(needs)\\n```",
                "solutionTags": [],
                "code": "```\\ndef shoppingOffers(self, price, special, needs):\\n        d = {}\\n        def dfs(cur):\\n            val = sum(cur[i]*price[i] for i in range(len(needs))) #cost without special\\n            for spec in special:\\n                tmp = [cur[j] - spec[j] for j in range(len(needs))]\\n                if min(tmp) >= 0: # skip deals that exceed needs\\n                    val = min(val, d.get(tuple(tmp), dfs(tmp)) + spec[-1]) # .get check the dictionary first for result, otherwise perform dfs.\\n            d[tuple(cur)] = val\\n            return val\\n        return dfs(needs)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2082501,
                "title": "c-knapsack-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& price, vector<vector<int>>& special, vector<int> needs, int index){\\n        if(index==special.size()){\\n            //Buy everything at the normal price\\n            int res = 0;\\n            for(int i=0;i<needs.size();i++){\\n                res += needs[i] * price[i];\\n            }\\n            return res;\\n        }\\n        \\n        //Reject Offer\\n        int reject = solve(price, special, needs, index + 1);\\n        \\n        //Apply Offer \\n        for(int i=0;i<needs.size();i++){\\n            needs[i] = needs[i] - special[index][i]; //Decrement the needs\\n            if(needs[i] < 0) return reject; //Can\\'t use this offer\\n        }\\n        \\n        int accept = special[index][needs.size()] + solve(price, special, needs, index);\\n        \\n        return min(accept, reject);\\n    }\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return solve(price, special, needs, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& price, vector<vector<int>>& special, vector<int> needs, int index){\\n        if(index==special.size()){\\n            //Buy everything at the normal price\\n            int res = 0;\\n            for(int i=0;i<needs.size();i++){\\n                res += needs[i] * price[i];\\n            }\\n            return res;\\n        }\\n        \\n        //Reject Offer\\n        int reject = solve(price, special, needs, index + 1);\\n        \\n        //Apply Offer \\n        for(int i=0;i<needs.size();i++){\\n            needs[i] = needs[i] - special[index][i]; //Decrement the needs\\n            if(needs[i] < 0) return reject; //Can\\'t use this offer\\n        }\\n        \\n        int accept = special[index][needs.size()] + solve(price, special, needs, index);\\n        \\n        return min(accept, reject);\\n    }\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return solve(price, special, needs, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105251,
                "title": "c-dp-dfs-with-memoization",
                "content": "The idea is to try every special offer using DFS, and memorize intermediate results, which is one type of DP. \\n1) There is at most 6 items and each item is at most 6, so we can use a 6 digit int as the key.\\n2) Test every special offer. If invalid, break. We have to pay for **EXACTLY** certain items, no more no less.\\n3) Greedy doesn't work. One example is [3, 2], [[1, 2, 4] [2, 1, 5]], [6, 6]. We need 2 first offers and 2 second offers. Greedy would choose 3 first offers.\\n```\\nclass Solution {\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        // memorize intermediate results \\n        unordered_map<int, int> mp;\\n        return helper(price, special, mp, get_key(needs));\\n    }\\nprivate:\\n    int helper(vector<int>& price, vector<vector<int>>& special, unordered_map<int, int>& mp, int k) {\\n        if (mp.count(k)) return mp[k];\\n        int n = price.size(), ans = 0;\\n        // pows is to help get each digit of key\\n        vector<int> pows(n, 1);\\n        for (int i = n-2; i >= 0; i--) pows[i] = pows[i+1]*10;\\n        for (int i = 0; i < n; i++) ans += ((k/pows[i])%10)*price[i];\\n        for (auto spe:special) {\\n            int key = 0, i = 0;\\n            // check whether this offer is valid\\n            while (i < n) {\\n                int t = (k/pows[i])%10;\\n                if (t >= spe[i]) \\n                    key = key*10+(t-spe[i++]);\\n                else\\n                    break;\\n            } \\n            if (i == n) ans = min(ans, spe[n]+helper(price, special, mp, key));\\n        }\\n        mp[k] = ans;\\n        return ans;\\n    }\\n    int get_key(vector<int>& needs) {\\n        int n = needs.size(), key = 0;\\n        for (int i = n-1, p = 1; i >= 0; i--, p *= 10)\\n            key += needs[i]*p;\\n        return key;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        // memorize intermediate results \\n        unordered_map<int, int> mp;\\n        return helper(price, special, mp, get_key(needs));\\n    }\\nprivate:\\n    int helper(vector<int>& price, vector<vector<int>>& special, unordered_map<int, int>& mp, int k) {\\n        if (mp.count(k)) return mp[k];\\n        int n = price.size(), ans = 0;\\n        // pows is to help get each digit of key\\n        vector<int> pows(n, 1);\\n        for (int i = n-2; i >= 0; i--) pows[i] = pows[i+1]*10;\\n        for (int i = 0; i < n; i++) ans += ((k/pows[i])%10)*price[i];\\n        for (auto spe:special) {\\n            int key = 0, i = 0;\\n            // check whether this offer is valid\\n            while (i < n) {\\n                int t = (k/pows[i])%10;\\n                if (t >= spe[i]) \\n                    key = key*10+(t-spe[i++]);\\n                else\\n                    break;\\n            } \\n            if (i == n) ans = min(ans, spe[n]+helper(price, special, mp, key));\\n        }\\n        mp[k] = ans;\\n        return ans;\\n    }\\n    int get_key(vector<int>& needs) {\\n        int n = needs.size(), key = 0;\\n        for (int i = n-1, p = 1; i >= 0; i--, p *= 10)\\n            key += needs[i]*p;\\n        return key;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105194,
                "title": "simple-java-recursive-solution",
                "content": "The basic idea is to pick each offer, and subtract the needs. And then compute the price without the offer. \\nPick whichever is minimum.\\n\\nEdit : ) much appreciated if someone can shorten the code with Java8 :)\\n\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int result = Integer.MAX_VALUE;\\n        //apply each offer to the needs, and recurse\\n        for(int i = 0; i < special.size(); i++) {\\n            List<Integer> offer = special.get(i);\\n            boolean invalidOffer = false;\\n            for(int j = 0; j < needs.size(); j++) { // subtract offer items from needs\\n                int remain = needs.get(j) - offer.get(j);\\n                needs.set(j, remain);\\n                if(!invalidOffer && remain < 0) invalidOffer = true; // if offer has more items than needs\\n            }\\n            if(!invalidOffer) { //if valid offer, add offer price and recurse remaining needs\\n                result = Math.min(result, shoppingOffers(price, special, needs) + offer.get(needs.size()));\\n            }\\n            for(int j = 0; j < needs.size(); j++) { // reset the needs\\n                int remain = needs.get(j) + offer.get(j);\\n                needs.set(j, remain);\\n            }\\n        }\\n        // choose b/w offer and non offer\\n        int nonOfferPrice = 0;\\n        for(int i = 0; i < needs.size(); i++) {\\n            nonOfferPrice += price.get(i) * needs.get(i);\\n        }\\n        return Math.min(result, nonOfferPrice);\\n    }\\n\\n**`UPDATE 1` :** For the below test case, we get time limit exceeded since it's exponential. TLE due to needs=30+.\\nI've requested admins to add this testcase.\\n```\\n[2,5]\\n[[1,0,5],[1,2,10]]\\n[39,39]\\n```\\n\\n~~So I made some optimization to reduce the recursive calls, by precomputing the number of times offer can be applied.~~  See **UPDATE 3**, there's an example that breaks this greedy optimization.\\n\\n```java\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int result = Integer.MAX_VALUE;\\n        //apply each offer to the needs, and recurse\\n        for(int i = 0; i < special.size(); i++) {\\n            List<Integer> offer = special.get(i);\\n            boolean invalidOffer = false;\\n            int offerCount = Integer.MAX_VALUE; // number of times offer can be applied\\n            for(int j = 0; j < needs.size(); j++) { // pre-compute number of times offer can be called\\n                int remain = needs.get(j) - offer.get(j);\\n                if(!invalidOffer && remain < 0) invalidOffer = true; // if offer has more items than needs\\n                if(offer.get(j) > 0)\\n                offerCount = Math.min(offerCount, needs.get(j)/offer.get(j));\\n            }\\n            for(int j = 0; j < needs.size(); j++) { // subtract offer items from needs\\n                int remain = needs.get(j) - offer.get(j) * offerCount;\\n                needs.set(j, remain);\\n            }\\n            if(!invalidOffer) { //if valid offer, add offer price and recurse remaining needs\\n                result = Math.min(result, shoppingOffers(price, special, needs) + (offerCount * offer.get(needs.size())));\\n            }\\n\\n            for(int j = 0; j < needs.size(); j++) { // reset the needs\\n                int remain = needs.get(j) + offer.get(j) * offerCount;\\n                needs.set(j, remain);\\n            }\\n        }\\n\\n        // choose b/w offer and non offer\\n        int nonOfferPrice = 0;\\n        for(int i = 0; i < needs.size(); i++) {\\n            nonOfferPrice += price.get(i) * needs.get(i);\\n        }\\n        return Math.min(result, nonOfferPrice);\\n    }\\n```\\n\\n**`UPDATE 2:`** I think OJ is breaking with the below test case. My code handles it though. Expected output is 8000, since it has two items of 1$ each. I've requested to add the test case. Also, another assumption is that result doesn't exceed Integer.MAX_VALUE. @administrators \\n```\\n[1,1]\\n[[1,1,2],[1,1,3]]\\n[4000,4000]\\n```\\n\\n**`UPDATE 3:`** From @Red_Eden 's thought, I found a test case that breaks my optimization. OJ is missing this test as well. My solution gives answer = 6, but actual is pick one offer just once = 4.\\n```\\n[500]\\n[[2,1],[3,2],[4,1]]\\n[9]\\n```",
                "solutionTags": [],
                "code": "```\\n[2,5]\\n[[1,0,5],[1,2,10]]\\n[39,39]\\n```\n```java\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int result = Integer.MAX_VALUE;\\n        //apply each offer to the needs, and recurse\\n        for(int i = 0; i < special.size(); i++) {\\n            List<Integer> offer = special.get(i);\\n            boolean invalidOffer = false;\\n            int offerCount = Integer.MAX_VALUE; // number of times offer can be applied\\n            for(int j = 0; j < needs.size(); j++) { // pre-compute number of times offer can be called\\n                int remain = needs.get(j) - offer.get(j);\\n                if(!invalidOffer && remain < 0) invalidOffer = true; // if offer has more items than needs\\n                if(offer.get(j) > 0)\\n                offerCount = Math.min(offerCount, needs.get(j)/offer.get(j));\\n            }\\n            for(int j = 0; j < needs.size(); j++) { // subtract offer items from needs\\n                int remain = needs.get(j) - offer.get(j) * offerCount;\\n                needs.set(j, remain);\\n            }\\n            if(!invalidOffer) { //if valid offer, add offer price and recurse remaining needs\\n                result = Math.min(result, shoppingOffers(price, special, needs) + (offerCount * offer.get(needs.size())));\\n            }\\n\\n            for(int j = 0; j < needs.size(); j++) { // reset the needs\\n                int remain = needs.get(j) + offer.get(j) * offerCount;\\n                needs.set(j, remain);\\n            }\\n        }\\n\\n        // choose b/w offer and non offer\\n        int nonOfferPrice = 0;\\n        for(int i = 0; i < needs.size(); i++) {\\n            nonOfferPrice += price.get(i) * needs.get(i);\\n        }\\n        return Math.min(result, nonOfferPrice);\\n    }\\n```\n```\\n[1,1]\\n[[1,1,2],[1,1,3]]\\n[4000,4000]\\n```\n```\\n[500]\\n[[2,1],[3,2],[4,1]]\\n[9]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 145989,
                "title": "clean-python-solution-top-down-memorization-beats-100",
                "content": "```\\nclass Solution:\\n    def find_lowest_price(self, price, special, needs):\\n        # Memorization\\n        if tuple(needs) in self.dp:\\n            return self.dp[tuple(needs)]\\n        # Don\\'t take offers\\n        cost = 0\\n        for i, need in enumerate(needs):\\n            cost += need * price[i]\\n        \\n        # Take one offer\\n        for offer in special:\\n            # Make sure it can take at least one offer\\n            for i, need in enumerate(needs):\\n                if need < offer[i]:\\n                    break\\n            else:\\n                new_needs = [need - offer[i] for i, need in enumerate(needs)]\\n                # Update cost\\n                cost = min(cost, offer[-1] + self.find_lowest_price(price, special, new_needs))\\n        self.dp[tuple(needs)] = cost\\n        return cost\\n        \\n    def shoppingOffers(self, price, special, needs):\\n        \"\"\"\\n        :type price: List[int]\\n        :type special: List[List[int]]\\n        :type needs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        self.dp = {}\\n        return self.find_lowest_price(price, special, needs)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def find_lowest_price(self, price, special, needs):\\n        # Memorization\\n        if tuple(needs) in self.dp:\\n            return self.dp[tuple(needs)]\\n        # Don\\'t take offers\\n        cost = 0\\n        for i, need in enumerate(needs):\\n            cost += need * price[i]\\n        \\n        # Take one offer\\n        for offer in special:\\n            # Make sure it can take at least one offer\\n            for i, need in enumerate(needs):\\n                if need < offer[i]:\\n                    break\\n            else:\\n                new_needs = [need - offer[i] for i, need in enumerate(needs)]\\n                # Update cost\\n                cost = min(cost, offer[-1] + self.find_lowest_price(price, special, new_needs))\\n        self.dp[tuple(needs)] = cost\\n        return cost\\n        \\n    def shoppingOffers(self, price, special, needs):\\n        \"\"\"\\n        :type price: List[int]\\n        :type special: List[List[int]]\\n        :type needs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        self.dp = {}\\n        return self.find_lowest_price(price, special, needs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105214,
                "title": "a-just-for-fun-only-dp-solution",
                "content": "it seems very like the dynamic programming problem. But when I solve the dp problem such like knapsack problem. I need the end of this problem, i.e. the volume of knapsack. If I know this, then the problem totally a knapsack problem. luckily, I get this from\\n1. There are at most 6 kinds of items, 100 special offers.\\n2. For each item, you need to buy at most 6 of them.\\nThen I add to 6 item for every input argument.\\nThis code have O(special offers size) time complex. When the input is small, it's not the best time complex. And it also not very general.\\n```\\nint shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs)\\n{\\n\\tint n = price.size();\\n\\tfor (int i = n; i < 6; i++)\\n\\t{\\n\\t\\tprice.push_back(0);\\n\\t\\tneeds.push_back(0);\\n\\t}\\n\\tfor (int i = special.size() - 1; i >= 0; i--)  // fill special to 6 items\\n\\t{\\n\\t\\tint t = special[i][n];\\n\\t\\tspecial[i][n] = 0;\\n\\t\\tfor (int j = n + 1; j < 7; j++)\\n\\t\\t\\tspecial[i].push_back(0);\\n\\t\\tspecial[i][6] = t;\\n\\t}\\n\\tint dp[7][7][7][7][7][7], m = special.size();\\n\\t//memset(dp, INT_MAX, 7 * 7 * 7 * 7 * 7 * 7);      \\n\\t//as @vallentin-petrov point out, memset fill the space by byte\\n\\tfor (int j = 0; j < 7; j++)\\n\\t{\\n\\t\\tfor (int k = 0; k < 7; k++)\\n\\t\\tfor (int p = 0; p < 7; p++)\\n\\t\\tfor (int q = 0; q < 7; q++)\\n\\t\\tfor (int r = 0; r < 7; r++)\\n\\t\\tfor (int s = 0; s < 7; s++)\\n\\t\\t\\tdp[j][k][p][q][r][s]=j*price[0]+k*price[1]+p*price[2]+q*price[3]+r*price[4]+s*price[5];\\n\\t}\\n\\tfor (int i = 0; i < m; i++)  // then it just a dynamic programming problem\\n\\t{\\n\\t\\tfor (int j = special[i][0]; j < 7; j++)\\n\\t\\tfor (int k = special[i][1]; k < 7; k++)\\n\\t\\tfor (int p = special[i][2]; p < 7; p++)\\n\\t\\tfor (int q = special[i][3]; q < 7; q++)\\n\\t\\tfor (int r = special[i][4]; r < 7; r++)\\n\\t\\tfor (int s = special[i][5]; s < 7; s++)\\n\\t\\t{\\n\\t\\t\\tint tt=dp[j-special[i][0]][k-special[i][1]][p-special[i][2]]\\n\\t\\t\\t\\t[q-special[i][3]][r-special[i][4]][s-special[i][5]];\\n\\t\\t\\tif (tt != INT_MAX)\\n\\t\\t\\t\\tdp[j][k][p][q][r][s]=min(dp[j][k][p][q][r][s],tt+special[i][6]);\\n\\t\\t}\\n\\t}\\n\\treturn dp[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\\n}\\n```\\nspecial thanks to @vallentin-petrov for point out the problem about memset~~\\nAnd thanks to @wulingyun16 for his advice~~",
                "solutionTags": [],
                "code": "```\\nint shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs)\\n{\\n\\tint n = price.size();\\n\\tfor (int i = n; i < 6; i++)\\n\\t{\\n\\t\\tprice.push_back(0);\\n\\t\\tneeds.push_back(0);\\n\\t}\\n\\tfor (int i = special.size() - 1; i >= 0; i--)  // fill special to 6 items\\n\\t{\\n\\t\\tint t = special[i][n];\\n\\t\\tspecial[i][n] = 0;\\n\\t\\tfor (int j = n + 1; j < 7; j++)\\n\\t\\t\\tspecial[i].push_back(0);\\n\\t\\tspecial[i][6] = t;\\n\\t}\\n\\tint dp[7][7][7][7][7][7], m = special.size();\\n\\t//memset(dp, INT_MAX, 7 * 7 * 7 * 7 * 7 * 7);      \\n\\t//as @vallentin-petrov point out, memset fill the space by byte\\n\\tfor (int j = 0; j < 7; j++)\\n\\t{\\n\\t\\tfor (int k = 0; k < 7; k++)\\n\\t\\tfor (int p = 0; p < 7; p++)\\n\\t\\tfor (int q = 0; q < 7; q++)\\n\\t\\tfor (int r = 0; r < 7; r++)\\n\\t\\tfor (int s = 0; s < 7; s++)\\n\\t\\t\\tdp[j][k][p][q][r][s]=j*price[0]+k*price[1]+p*price[2]+q*price[3]+r*price[4]+s*price[5];\\n\\t}\\n\\tfor (int i = 0; i < m; i++)  // then it just a dynamic programming problem\\n\\t{\\n\\t\\tfor (int j = special[i][0]; j < 7; j++)\\n\\t\\tfor (int k = special[i][1]; k < 7; k++)\\n\\t\\tfor (int p = special[i][2]; p < 7; p++)\\n\\t\\tfor (int q = special[i][3]; q < 7; q++)\\n\\t\\tfor (int r = special[i][4]; r < 7; r++)\\n\\t\\tfor (int s = special[i][5]; s < 7; s++)\\n\\t\\t{\\n\\t\\t\\tint tt=dp[j-special[i][0]][k-special[i][1]][p-special[i][2]]\\n\\t\\t\\t\\t[q-special[i][3]][r-special[i][4]][s-special[i][5]];\\n\\t\\t\\tif (tt != INT_MAX)\\n\\t\\t\\t\\tdp[j][k][p][q][r][s]=min(dp[j][k][p][q][r][s],tt+special[i][6]);\\n\\t\\t}\\n\\t}\\n\\treturn dp[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 105200,
                "title": "c-solution",
                "content": "    class Solution {\\n    public:\\n        int shoppingOffers(const vector<int>& price, const vector<vector<int>>& special, const vector<int>& needs) {\\n            int result = inner_product(price.begin(), price.end(), needs.begin(), 0);\\n            for (const vector<int>& offer : special) {\\n                vector<int> r = can(needs, offer);\\n                if (r.empty()) continue;\\n                result = min(result, offer.back() + shoppingOffers(price, special, r));\\n            }\\n            return result;\\n        }\\n        vector<int> can(const vector<int>& needs, const vector<int>& offer) {\\n            vector<int> r(needs.size(), 0);\\n            for (int i = 0, n = needs.size(); i < n; ++i) {\\n                if (offer[i] > needs[i]) return vector<int>();\\n                r[i] = needs[i] - offer[i];\\n            }\\n            return r;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int shoppingOffers(const vector<int>& price, const vector<vector<int>>& special, const vector<int>& needs) {\\n            int result = inner_product(price.begin(), price.end(), needs.begin(), 0);\\n            for (const vector<int>& offer : special) {\\n                vector<int> r = can(needs, offer);\\n                if (r.empty()) continue;\\n                result = min(result, offer.back() + shoppingOffers(price, special, r));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 105211,
                "title": "java-dfs-dp",
                "content": "```public class Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        Map<List<Integer>, Integer> dp = new HashMap<>();\\n        List<Integer> allZero = new ArrayList<>();\\n        for(int i=0;i<needs.size();i++) {\\n            allZero.add(0);\\n        }\\n        dp.put(allZero, 0);\\n        return dfs(needs, price, special, dp);\\n    }\\n    private int dfs(List<Integer> needs, List<Integer> price, List<List<Integer>> special, Map<List<Integer>, Integer> dp) {\\n        if(dp.containsKey(needs)) return dp.get(needs);\\n        int res = Integer.MAX_VALUE;\\n        for(List<Integer> s : special) {\\n            List<Integer> needsCopy = new ArrayList<>(needs);\\n            boolean valid = true;\\n            for(int i=0;i<needs.size();i++) {\\n                needsCopy.set(i, needsCopy.get(i) - s.get(i));\\n                if(needsCopy.get(i) < 0) {\\n                    valid = false;\\n                    break;\\n                }\\n            }\\n            if(valid) {\\n                res = Math.min(res, s.get(needs.size()) + dfs(needsCopy, price, special, dp));\\n            }\\n        }\\n        //What if we do not use specials? specials can be deceiving,\\n        //perhaps buying using regular prices is cheaper.\\n        int noSpecial = 0;\\n            for(int i=0;i<needs.size();i++) {\\n                noSpecial += needs.get(i) * price.get(i);\\n            }\\n        res = Math.min(res, noSpecial);    \\n\\n        dp.put(needs, res);\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        Map<List<Integer>, Integer> dp = new HashMap<>();\\n        List<Integer> allZero = new ArrayList<>();\\n        for(int i=0;i<needs.size();i++) {\\n            allZero.add(0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1127168,
                "title": "c-dfs-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> need){\\n        for(int i = 0; i < need.size(); i++){\\n            if(need[i] < 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    map<vector<int>, int> umap;\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        if(umap[needs] > 0){\\n            return umap[needs];\\n        }\\n        int minimum = 0;\\n        for(int i = 0; i < needs.size(); i++){\\n            minimum += needs[i] * price[i];\\n        }        \\n        for(auto spec : special){\\n            vector<int> need = needs;\\n            for(int i = 0; i < need.size(); i++){\\n                need[i] -= spec[i];\\n            }\\n            if(check(need)){\\n                minimum = min(minimum, spec[spec.size() - 1] + shoppingOffers(price, special, need));    \\n            }            \\n        }\\n        return umap[needs] = minimum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> need){\\n        for(int i = 0; i < need.size(); i++){\\n            if(need[i] < 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    map<vector<int>, int> umap;\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        if(umap[needs] > 0){\\n            return umap[needs];\\n        }\\n        int minimum = 0;\\n        for(int i = 0; i < needs.size(); i++){\\n            minimum += needs[i] * price[i];\\n        }        \\n        for(auto spec : special){\\n            vector<int> need = needs;\\n            for(int i = 0; i < need.size(); i++){\\n                need[i] -= spec[i];\\n            }\\n            if(check(need)){\\n                minimum = min(minimum, spec[spec.size() - 1] + shoppingOffers(price, special, need));    \\n            }            \\n        }\\n        return umap[needs] = minimum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146711,
                "title": "easy-java-beat-100",
                "content": "```\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        return helper(price, special, needs);\\n    }\\n    \\n    public int helper(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int sum = 0, len = price.size();\\n        for (int i = 0; i < len; i++) sum += needs.get(i)*price.get(i);\\n        for (List<Integer> list : special) {\\n             if (qualify(list, needs)){\\n                 for (int i = 0; i < len; i++) needs.set(i,needs.get(i)-list.get(i));\\n                 int temp = helper(price, special, needs);\\n                 sum = Math.min(sum,temp + list.get(len));\\n                 for (int i = 0; i < len; i++) needs.set(i,needs.get(i)+list.get(i));\\n             }  \\n        }\\n        return sum;\\n    }\\n    \\n    public boolean qualify(List<Integer> list, List<Integer> needs) {\\n        int len = needs.size();\\n        for (int i = 0; i < len; i++) \\n            if (list.get(i) > needs.get(i)) return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        return helper(price, special, needs);\\n    }\\n    \\n    public int helper(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int sum = 0, len = price.size();\\n        for (int i = 0; i < len; i++) sum += needs.get(i)*price.get(i);\\n        for (List<Integer> list : special) {\\n             if (qualify(list, needs)){\\n                 for (int i = 0; i < len; i++) needs.set(i,needs.get(i)-list.get(i));\\n                 int temp = helper(price, special, needs);\\n                 sum = Math.min(sum,temp + list.get(len));\\n                 for (int i = 0; i < len; i++) needs.set(i,needs.get(i)+list.get(i));\\n             }  \\n        }\\n        return sum;\\n    }\\n    \\n    public boolean qualify(List<Integer> list, List<Integer> needs) {\\n        int len = needs.size();\\n        for (int i = 0; i < len; i++) \\n            if (list.get(i) > needs.get(i)) return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3158993,
                "title": "c-map-as-dp-knapsack-solution-with-crisp-explanation",
                "content": "# Intuition\\nIntuition is pretty simple. We will try to pick each offer or skip it.\\n\\n# Approach\\nStart with `0th` index. At each index of offers we have two choice. Either we use that offer or we don\\'t use that.\\n\\n- `Choice: 1` First check if we can use that offer if we can then pick that offer present on that index and stay on that index because we can use a offer any number of times.\\n\\n- `Choice: 2` Don\\'t use that offer and move to next offer to do the same. \\n\\n# UPVOTE PLEASEEEEEEEEE :)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int ex(int ind, vector<int> ds, vector<int> &price, vector<vector<int>> &offer, vector<int> &need,  map<int,map<vector<int>,int>> &dp){\\n        if(ind==offer.size()){\\n            int tot=0;\\n            for(int i=0; i<need.size(); i++){\\n                tot+=(need[i]-ds[i])*price[i];\\n            }\\n            return tot;\\n        }\\n        \\n        if(dp.find(ind)!=dp.end() && dp[ind].find(ds)!=dp[ind].end()){\\n            return dp[ind][ds];\\n        }\\n\\n        int offer_notTake=ex(ind+1,ds,price,offer,need,dp);\\n\\n        int offer_take=1e9;\\n        vector<int> copyDS=ds;\\n\\n        for(int i=0; i<need.size(); i++){\\n            if(copyDS[i]+offer[ind][i]<=need[i]){\\n                copyDS[i]+=offer[ind][i];\\n            }else{\\n                return dp[ind][ds]=min(offer_notTake,offer_take);\\n            }\\n        }\\n        offer_take=offer[ind][price.size()]+ex(ind,copyDS,price,offer,need,dp);\\n\\n        return dp[ind][ds]=min(offer_notTake,offer_take); \\n    }\\n\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& offer, vector<int>& need) {\\n        map<int,map<vector<int>,int>> dp;\\n        vector<int> ds(need.size(),0);\\n        return ex(0,ds,price,offer,need,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int ex(int ind, vector<int> ds, vector<int> &price, vector<vector<int>> &offer, vector<int> &need,  map<int,map<vector<int>,int>> &dp){\\n        if(ind==offer.size()){\\n            int tot=0;\\n            for(int i=0; i<need.size(); i++){\\n                tot+=(need[i]-ds[i])*price[i];\\n            }\\n            return tot;\\n        }\\n        \\n        if(dp.find(ind)!=dp.end() && dp[ind].find(ds)!=dp[ind].end()){\\n            return dp[ind][ds];\\n        }\\n\\n        int offer_notTake=ex(ind+1,ds,price,offer,need,dp);\\n\\n        int offer_take=1e9;\\n        vector<int> copyDS=ds;\\n\\n        for(int i=0; i<need.size(); i++){\\n            if(copyDS[i]+offer[ind][i]<=need[i]){\\n                copyDS[i]+=offer[ind][i];\\n            }else{\\n                return dp[ind][ds]=min(offer_notTake,offer_take);\\n            }\\n        }\\n        offer_take=offer[ind][price.size()]+ex(ind,copyDS,price,offer,need,dp);\\n\\n        return dp[ind][ds]=min(offer_notTake,offer_take); \\n    }\\n\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& offer, vector<int>& need) {\\n        map<int,map<vector<int>,int>> dp;\\n        vector<int> ds(need.size(),0);\\n        return ex(0,ds,price,offer,need,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105201,
                "title": "dfs-pruning-beats-100-python",
                "content": "regular DFS\\nthe only difference is that  in the dfs search start with\\npicking special offer 2, we don't need to picking special offer 1 again as the combination would be already calculated.\\nexample:\\npick sp1,sp1,sp2  is the same as pick sp2, sp1, sp1\\n```\\n    def shoppingOffers(self, price, special, needs):\\n        \"\"\"\\n        :type price: List[int]\\n        :type special: List[List[int]]\\n        :type needs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        self.res = sys.maxint\\n        self.dfs(needs,special,price,0,0)\\n        return self.res\\n        \\n    def dfs(self, needs, special, price, currentprice, specialindex):\\n        if needs == [ 0 for x in xrange(len(needs))]:\\n            self.res = min(self.res,currentprice)\\n            return\\n        for x in xrange(specialindex,len(special)):\\n            vaild = True\\n            for y in xrange(len(needs)):\\n                if needs[y] < special[x][y]:\\n                    vaild = False\\n                    break\\n            if vaild == True:\\n                nextneeds = [needs[a] - special[x][a] for a in xrange(len(needs))]\\n                self.dfs(nextneeds,special,price,currentprice+special[x][-1],x)\\n        for z in xrange(len(needs)):\\n            if needs[z] >= 1:\\n                currentprice += price[z]*needs[z]\\n        self.res = min(self.res,currentprice)\\n```",
                "solutionTags": [],
                "code": "```\\n    def shoppingOffers(self, price, special, needs):\\n        \"\"\"\\n        :type price: List[int]\\n        :type special: List[List[int]]\\n        :type needs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        self.res = sys.maxint\\n        self.dfs(needs,special,price,0,0)\\n        return self.res\\n        \\n    def dfs(self, needs, special, price, currentprice, specialindex):\\n        if needs == [ 0 for x in xrange(len(needs))]:\\n            self.res = min(self.res,currentprice)\\n            return\\n        for x in xrange(specialindex,len(special)):\\n            vaild = True\\n            for y in xrange(len(needs)):\\n                if needs[y] < special[x][y]:\\n                    vaild = False\\n                    break\\n            if vaild == True:\\n                nextneeds = [needs[a] - special[x][a] for a in xrange(len(needs))]\\n                self.dfs(nextneeds,special,price,currentprice+special[x][-1],x)\\n        for z in xrange(len(needs)):\\n            if needs[z] >= 1:\\n                currentprice += price[z]*needs[z]\\n        self.res = min(self.res,currentprice)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 689874,
                "title": "cpp-simple-code",
                "content": "Runtime: 36 ms, faster than 46.86% of C++ online submissions for Shopping Offers.\\nMemory Usage: 12.8 MB, less than 52.98% of C++ online submissions for Shopping Offers.\\n```\\nclass Solution {\\n    int calculatePrice(vector<int>& price, vector<int>& needs){\\n        int ans = 0;\\n        for(int i = 0; i < price.size(); i++){\\n            ans += (price[i]*needs[i]);\\n        }\\n        return ans;\\n    }\\n    int helper(vector<int>& price, vector<vector<int>>& special, vector<int>& needs,unordered_map<string,int>& map){\\n        string needString = \"\";\\n        for(int i = 0; i < needs.size(); i++){\\n            needString += (to_string(i)+\" \"+to_string(needs[i]));\\n        }\\n       if(map.find(needString) != map.end()) return map[needString];\\n        int minPrice = calculatePrice(price,needs);\\n        for(int i = 0; i < special.size(); i++){\\n            vector<int> temp;\\n            int j;\\n            for(j = 0; j < special[i].size() - 1; j++){\\n                if(needs[j] < special[i][j]) break;\\n                temp.push_back(needs[j] - special[i][j]);\\n            }\\n            if(j == needs.size()){\\n               int ans =  helper(price,special,temp,map);\\n                ans += special[i][j];\\n                if(ans < minPrice){\\n                    minPrice = ans;\\n                }\\n            }\\n        }\\n        map[needString] = minPrice;\\n        return minPrice;\\n    }\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        unordered_map<string,int> map;\\n        return helper(price, special, needs,map);\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    int calculatePrice(vector<int>& price, vector<int>& needs){\\n        int ans = 0;\\n        for(int i = 0; i < price.size(); i++){\\n            ans += (price[i]*needs[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3128471,
                "title": "c-recursion-backtracking-brute-force-beats-94",
                "content": "# Approach\\n**First find cost of dirct buy without special offers. Then check for special offers (with unbounded knapsack intuition) and minimise the cost.**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int ans;\\n\\n    bool check(vector<int> &nds, vector<vector<int>> &sp, int idx)\\n    {\\n        int n=nds.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nds[i]-sp[idx][i]<0) return false;\\n        }\\n        return true;\\n    }\\n\\n    int directBuy(vector<int> &nds, vector<int> &pr)\\n    {\\n        int n=nds.size(), total=0;\\n        for(int i=0; i<n; i++) total+=(nds[i]*pr[i]);\\n        return total;\\n    }\\n\\n    void solve(vector<int> &pr, vector<vector<int>> &sp, vector<int> &nds, int idx, int n, int cost)\\n    {\\n        if(cost>ans) return;\\n        if(idx==sp.size())\\n        {\\n            cost+=directBuy(nds, pr);\\n            ans=min(ans, cost);\\n            return;\\n        }\\n        if(check(nds, sp, idx))\\n        {\\n            for(int i=0; i<n; i++) nds[i]-=sp[idx][i];\\n            solve(pr, sp, nds, idx, n, cost+sp[idx][n]);\\n            for(int i=0; i<n; i++) nds[i]+=sp[idx][i];\\n        }\\n        solve(pr, sp, nds, idx+1, n, cost);\\n    }\\n\\n    int shoppingOffers(vector<int>& pr, vector<vector<int>>& sp, vector<int>& nds) \\n    {\\n        int n=pr.size();\\n        ans=directBuy(nds, pr);\\n        solve(pr, sp, nds, 0, n, 0);\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int ans;\\n\\n    bool check(vector<int> &nds, vector<vector<int>> &sp, int idx)\\n    {\\n        int n=nds.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nds[i]-sp[idx][i]<0) return false;\\n        }\\n        return true;\\n    }\\n\\n    int directBuy(vector<int> &nds, vector<int> &pr)\\n    {\\n        int n=nds.size(), total=0;\\n        for(int i=0; i<n; i++) total+=(nds[i]*pr[i]);\\n        return total;\\n    }\\n\\n    void solve(vector<int> &pr, vector<vector<int>> &sp, vector<int> &nds, int idx, int n, int cost)\\n    {\\n        if(cost>ans) return;\\n        if(idx==sp.size())\\n        {\\n            cost+=directBuy(nds, pr);\\n            ans=min(ans, cost);\\n            return;\\n        }\\n        if(check(nds, sp, idx))\\n        {\\n            for(int i=0; i<n; i++) nds[i]-=sp[idx][i];\\n            solve(pr, sp, nds, idx, n, cost+sp[idx][n]);\\n            for(int i=0; i<n; i++) nds[i]+=sp[idx][i];\\n        }\\n        solve(pr, sp, nds, idx+1, n, cost);\\n    }\\n\\n    int shoppingOffers(vector<int>& pr, vector<vector<int>>& sp, vector<int>& nds) \\n    {\\n        int n=pr.size();\\n        ans=directBuy(nds, pr);\\n        solve(pr, sp, nds, 0, n, 0);\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930014,
                "title": "backtracking-memoization-detailed-explanation-c",
                "content": "# Intuition\\nLooking at the problem statement, we can see that this problem resembles a multidimensional knapsack problem, which we know to be NP-hard, and the small input size constraints seem to confirm that we may be dealing with an exponential-time solution. One approach here that comes to mind is that of backtracking.\\n\\n# Approach\\nIf we consider a recursive backtracking depth-first search approach, we would follow something like this:\\n1. For any given state, if it is a solution, report it. Otherwise...\\n2. Construct the set of possible candidates for the next choice\\n3. For each candidate, make a move that modifies the state\\n4. Using this new state, recur to continue backtracking\\n5. After returning from this recursion, unmake the move to undo any state modification\\n\\nIn this problem, we know what our possible candidates are: at each step in our backtracking process, our next move could be to either use the original item prices, or to use an offer.\\n\\nNext, for making a move, we need to be careful with efficiency. When we make a move, it just boils down to buying some quantity of some items, so we can remove those items from the `needs` vector. We could try clone the vector and modify the clone, then pass this clone down to recursive calls, but this will require space proportional to the needs size multiplied by the recursion tree height. Instead, we\\'ll opt for an approach that doesn\\'t clone the vector thus saving space: before recurring deeper, modify the original vector to its new state. This is fine, since we\\'ll never need the previous state in any children calls. Then once we finish that recursion, we can simply undo our vector modifications. Through all recursion then, simply pass a reference to the original vector.\\n\\n---\\n\\n### Details\\n\\nWith a basic scaffold, we can work on the details. At any recursive call, define our state to be value of the `needs` vector. Since we can use the original prices and specials as many times as we want, their states don\\'t depend on our choices, so our recursive state is completely defined by the value of this vector.\\n\\nSo, at each recursive call, we keep track of a minimum cost achievable moving forward from the current state. This minimum cost will initially be the trivial case where we buy all the remaining items using their original prices. This is just the inner product between the `price` and `needs` vectors, i.e. `price[0]*needs[0] + price[1]*needs[1] + ...`.\\n\\nThe remaining candidates are now the `special`s. We can iterate through each special offer. At each iteration, we \\'apply\\' the special to the needs vector, which just means going through the offer and \\'buying\\' each item required by the offer (subtracting each `offer[i]` from `needs[i]`). But, we aren\\'t allowed to buy any more items than we originally needed, so if any value of `needs` ever becomes < 0, that means we bought too much of that item and we aren\\'t allowed to use that special from the current state, in which case we\\'ll just undo the \\'application\\' of the special and skip to looking at the next special.\\n\\nAfter we have validly applied a special from `special` to `needs`, we can now backtrack using our new state. After that recursive call returns with the minimum cost from that new state, we have two options for updating the `min_cost` at our current state: 1. we keep `min_cost` the same, since our recursion did not reveal a cheaper path by using the selected special, or 2. the cost of the special offer we selected plus the minimum cost of that resulting state is less than our current cheapest known option, in which case we\\'ll set that to the new current `min_cost` from this state.\\n\\nAfter backtracking further and updating the minimum cost so far for this state, we can undo the modifications to the `needs` vector.\\n\\nFinally, we will return the `min_cost` found from this state.\\n\\nOne thing to note is that we never explicitly check if the state is a solution as was outlined in the approach, since at any given state, if it is a solution, then all `needs` will be 0. So, all subsequent attempts to apply a special offer will fail since they will all cause a `needs[i]` to be < 0, and so the recursive call will just return as if a solution were detected.\\n\\n---\\n\\n### Optimisations\\n\\nWith a backtracking approach, proper optimisations and search pruning can have a significant performance improvement. In this case, 2 obvious optimisations come to mind.\\n\\nFirst, as we iterate through our special offers, if ever the cost of that offer would exceed the current `min_cost`, then we know that selecting that offer cannot lead to any cheaper path, so we can skip recurring with that offer entirely.\\n\\nSecond, we can identify that through the recursion, there will be many backtracking calls to the exact same `needs` state. However, since each subproblem is completely uniquely identified by its `needs` vector, that means that any call to `shoppingOffers` with the same `needs` will always return the same minimum cost. So, it makes sense to try a memoization approach, where we cache a `min_cost` value whenever we compute it, so if we ever end up with a duplicate call, we can just immediately return with the cached value without having to waste time going all the way down the recursion tree again.\\n\\nWhen doing memoization in this way, one approach would be to use some sort of associative map to relate the state (key) to the resulting `min_cost` (value). In this case, our key would be the `needs` vector, but we need a way of producing a hash of this vector to act as a lookup key. An effective approach here is to build a bitmask: we know that `needs` can have at most `6` elements, and each of these elements is between `0` and `10` inclusive. So, each element can be represented using 4 bits, and so all 6 elements can be represented using `6*4=24` bits, which means we can store our entire state in a single 32-bit integer, which will become our bitmask.\\n\\nWith this in mind, at each recursive call, first compute the mask and check if a memoized value for that mask already exists. If so, just return that value and don\\'t recur further. Otherwise, run the computation, then insert the resultant `min_cost` into the map using the mask as its key before returning.\\n\\n# Complexity\\n\\n### Time complexity\\n$O(s \\\\cdot n \\\\cdot m^n)$, where $s$ is the length of `special`, $n$ is the length of `price` and `needs`, and $m$ is the number of unique values `price[i]` and `needs[i]` can take on.\\n**Explanation**: Since we\\'re memoizing intermediate values, the number of times the function will be run is proportional to the maximum number of unique cache keys. In this case, the state of `needs` is being used as a key, and with $n$ elements which can each take on up to $m$ unique values, this gives $m^n$ possible unique cache values. For each of these function calls, all `special`s are iterated over totalling $s$ times, and for each of those iterations, all `needs` are iterated over totalling up to $2n$ times. Multiplying these together gives the total time complexity.\\n\\n### Space complexity\\n$O(m^n)$, where $m$ is the number of unique values `price[i]` and `needs[i]` can take on, and $n$ is the length of `price` and `needs`.\\n**Explanation**: We store in the worst case all possible unique states of `needs`, and as described in the time complexity analysis, this is poportional to $m^n$. The stack depth from recursion will also be proportional to the number of unique states, as recursion will stop and return immediately when a memoized value is found.\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    // Store the minimum cost found for subproblems at a given state of needs.\\n    // Since each need is in [0,10], each need can be represented in 4 bits.\\n    // Since there are up to 6 needs, the entire needs state can be represented in 6*4=24 bits.\\n    // So, we can use a 32-bit integer mask as a key in the map to uniquely identify a needs state.\\n    unordered_map<int32_t, int> min_cost_for_state;\\n\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        // Make a bitmask of the current needs state\\n        int32_t mask = 0;\\n        for (int need : needs)\\n            mask = (mask | need) << 4;\\n\\n        // If already cached result of this needs state, return that\\n        if (min_cost_for_state.count(mask))\\n            return min_cost_for_state[mask];\\n\\n        // At this point, can either pick the regular item prices, or specials.\\n        // Start of by setting the minimum cost as that of using the regular prices for the remaining needed items.\\n        int min_cost = inner_product(price.begin(), price.end(), needs.begin(), 0);\\n\\n        // Now test all the specials\\n        for (const auto &special_offer : special) {\\n            // Prune the search: if buying a special causes a price > current min, don\\'t bother\\n            if (special_offer.back() > min_cost)\\n                continue;\\n\\n            // Keep track of if come across negative needs, where we would buy more than needed\\n            int bought_too_much = false;\\n            // Temporarily apply the special to the needs vector, subtracting the purchased items from the needed items\\n            for (int i = 0; i < needs.size(); ++i) {\\n                needs[i] -= special_offer[i];\\n                // Stop if we\\'ve found a negative need, since that\\'s invalid - undo the application\\n                if (needs[i] < 0) {\\n                    while (i >= 0) {\\n                        needs[i] += special_offer[i];\\n                        --i;\\n                    }\\n                    bought_too_much = true;\\n                    break;\\n                }\\n            }\\n\\n            // Don\\'t recur if we\\'ve found a negative need, since that is invalid\\n            if (bought_too_much) continue;\\n\\n            // Update the current minimum cost if applying this special leads to a lower cost\\n            min_cost = min(min_cost, special_offer.back() + shoppingOffers(price, special, needs));\\n\\n            // Undo the temporary application of the special to the needs vector\\n            for (int i = 0; i < needs.size(); ++i)\\n                needs[i] += special_offer[i];\\n        }\\n\\n        // Cache this min cost value\\n        min_cost_for_state[mask] = min_cost;\\n\\n        // Return the current minimum cost\\n        return min_cost;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // Store the minimum cost found for subproblems at a given state of needs.\\n    // Since each need is in [0,10], each need can be represented in 4 bits.\\n    // Since there are up to 6 needs, the entire needs state can be represented in 6*4=24 bits.\\n    // So, we can use a 32-bit integer mask as a key in the map to uniquely identify a needs state.\\n    unordered_map<int32_t, int> min_cost_for_state;\\n\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        // Make a bitmask of the current needs state\\n        int32_t mask = 0;\\n        for (int need : needs)\\n            mask = (mask | need) << 4;\\n\\n        // If already cached result of this needs state, return that\\n        if (min_cost_for_state.count(mask))\\n            return min_cost_for_state[mask];\\n\\n        // At this point, can either pick the regular item prices, or specials.\\n        // Start of by setting the minimum cost as that of using the regular prices for the remaining needed items.\\n        int min_cost = inner_product(price.begin(), price.end(), needs.begin(), 0);\\n\\n        // Now test all the specials\\n        for (const auto &special_offer : special) {\\n            // Prune the search: if buying a special causes a price > current min, don\\'t bother\\n            if (special_offer.back() > min_cost)\\n                continue;\\n\\n            // Keep track of if come across negative needs, where we would buy more than needed\\n            int bought_too_much = false;\\n            // Temporarily apply the special to the needs vector, subtracting the purchased items from the needed items\\n            for (int i = 0; i < needs.size(); ++i) {\\n                needs[i] -= special_offer[i];\\n                // Stop if we\\'ve found a negative need, since that\\'s invalid - undo the application\\n                if (needs[i] < 0) {\\n                    while (i >= 0) {\\n                        needs[i] += special_offer[i];\\n                        --i;\\n                    }\\n                    bought_too_much = true;\\n                    break;\\n                }\\n            }\\n\\n            // Don\\'t recur if we\\'ve found a negative need, since that is invalid\\n            if (bought_too_much) continue;\\n\\n            // Update the current minimum cost if applying this special leads to a lower cost\\n            min_cost = min(min_cost, special_offer.back() + shoppingOffers(price, special, needs));\\n\\n            // Undo the temporary application of the special to the needs vector\\n            for (int i = 0; i < needs.size(); ++i)\\n                needs[i] += special_offer[i];\\n        }\\n\\n        // Cache this min cost value\\n        min_cost_for_state[mask] = min_cost;\\n\\n        // Return the current minimum cost\\n        return min_cost;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381625,
                "title": "c-easy-to-understand-recursion-memoization",
                "content": "```\\nclass Solution {\\n    unordered_map<string, int> map;\\n    int dot(vector<int> &needs, vector<int> price){\\n        int sum=0;\\n        for(int i=0; i<needs.size(); i++){\\n            sum += needs[i]*price[i];\\n        }\\n        return sum;\\n    }\\n    int shopping(vector<int>& price, vector<vector<int>>& special, vector<int>& needs){\\n        string key;\\n        for(int n: needs) key += to_string(n);\\n        if(map.count(key)) return map[key];\\n        int j=0, res = dot(needs, price);\\n        for(auto s: special){\\n            vector<int> clone = needs;\\n            for(j=0; j<needs.size(); j++){\\n                int diff= clone[j] - s[j];\\n                if(diff < 0) break;\\n                clone[j] = diff;\\n            }\\n            if(j == needs.size())\\n                res = min(res, s[j] + shopping(price, special, clone));\\n        }\\n        return map[key] = res;\\n    }\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return shopping(price, special, needs);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<string, int> map;\\n    int dot(vector<int> &needs, vector<int> price){\\n        int sum=0;\\n        for(int i=0; i<needs.size(); i++){\\n            sum += needs[i]*price[i];\\n        }\\n        return sum;\\n    }\\n    int shopping(vector<int>& price, vector<vector<int>>& special, vector<int>& needs){\\n        string key;\\n        for(int n: needs) key += to_string(n);\\n        if(map.count(key)) return map[key];\\n        int j=0, res = dot(needs, price);\\n        for(auto s: special){\\n            vector<int> clone = needs;\\n            for(j=0; j<needs.size(); j++){\\n                int diff= clone[j] - s[j];\\n                if(diff < 0) break;\\n                clone[j] = diff;\\n            }\\n            if(j == needs.size())\\n                res = min(res, s[j] + shopping(price, special, clone));\\n        }\\n        return map[key] = res;\\n    }\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return shopping(price, special, needs);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126582,
                "title": "c-explained-memoization-approach",
                "content": "I have included the recursive code as well so you can relate how recursive code has been memoizied by just writing few more lines and storing the result of recusrsion.\\n\\nCode has been commented below:\\n```\\nclass Solution {\\n// map will store the minimum value to pay for a particular values of needs vector\\n    map<vector<int>, int>mp;\\npublic:\\n    int shopping(vector<int>&price, vector<vector<int>>& special, vector<int>&needs){\\n    //first we check if we have already calculated the value to pay for this particular\\n// vlaues in needs vector if yes just return value\\n        if(mp.find(needs)!= mp.end())return mp[needs];\\n \\n// now we calulated the value to be paid if we don\\'t avail any offer in special vector\\n        int j=0, res = original_cost(price, needs);\\n       mp.insert({needs,res}); //store that in map\\n        \\n//Now we consider each offer in special vector to see if we can minimize the value to\\n// to be paid \\n        for(auto v: special){\\n  //we create a new vector to conatain new remaining needs we we apply a certain offer\\n           vector<int> new_needs = needs; \\n//Any offer can only be applied if the number of each items in offer is <= needs \\n//beacuse we want exactly the number of items as given in needs not more then that\\n            for(j=0;j<new_needs.size();j++){\\n                int dif = new_needs[j] - v[j];\\n                if(dif<0)break; //if items is more than required this offer can be availed\\n    \\n                new_needs[j] =  dif; // else we avail this offer & at the same time reduce\\n        // the needs of items after availing the offer\\n            }\\n            if(j==needs.size()) //j==needs.size means we can avil this offer \\n            //we take the minimum of values with availing a certain offer anf without \\n            // aviling the any offer and recur for remaining items in needs\\n                res = min(res, v[j]+shopping(price,special, new_needs));\\n        }\\n        mp.insert({needs,res});// memoizie the result\\n        return res;\\n        \\n    }\\n    \\n//This original_cost calulate the price to be paid if we don\\'t avail any offer\\n int original_cost(vector<int>& price, vector<int>& needs){\\n     int sum =0;\\n     for(int i=0;i<needs.size();i++){\\n         sum+= price[i]*needs[i];\\n     }\\n     return sum;\\n }\\n    \\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return shopping(price, special, needs);\\n    }\\n};\\n```\\n\\n**RECURSIVE CODE**\\n```\\nclass Solution {\\npublic:\\n    int shopping(vector<int>&price, vector<vector<int>>& special, vector<int>&needs){\\n        int j=0, res = original_cost(price, needs);\\n       \\n        for(auto v: special){\\n            \\n           vector<int> new_needs = needs;  \\n            for(j=0;j<new_needs.size();j++){\\n                int dif = new_needs[j] - v[j];\\n                if(dif<0)break;\\n                \\n                new_needs[j] =  dif;\\n            }\\n            if(j==needs.size())\\n                res = min(res, v[j]+shopping(price,special, new_needs));\\n        }\\n        return res;\\n        \\n    }\\n int original_cost(vector<int>& price, vector<int>& needs){\\n     int sum =0;\\n     for(int i=0;i<needs.size();i++){\\n         sum+= price[i]*needs[i];\\n     }\\n     return sum;\\n }\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return shopping(price, special, needs);\\n    }\\n};\\n```\\nDo upvote if explanation was useful & you liked the code :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n// map will store the minimum value to pay for a particular values of needs vector\\n    map<vector<int>, int>mp;\\npublic:\\n    int shopping(vector<int>&price, vector<vector<int>>& special, vector<int>&needs){\\n    //first we check if we have already calculated the value to pay for this particular\\n// vlaues in needs vector if yes just return value\\n        if(mp.find(needs)!= mp.end())return mp[needs];\\n \\n// now we calulated the value to be paid if we don\\'t avail any offer in special vector\\n        int j=0, res = original_cost(price, needs);\\n       mp.insert({needs,res}); //store that in map\\n        \\n//Now we consider each offer in special vector to see if we can minimize the value to\\n// to be paid \\n        for(auto v: special){\\n  //we create a new vector to conatain new remaining needs we we apply a certain offer\\n           vector<int> new_needs = needs; \\n//Any offer can only be applied if the number of each items in offer is <= needs \\n//beacuse we want exactly the number of items as given in needs not more then that\\n            for(j=0;j<new_needs.size();j++){\\n                int dif = new_needs[j] - v[j];\\n                if(dif<0)break; //if items is more than required this offer can be availed\\n    \\n                new_needs[j] =  dif; // else we avail this offer & at the same time reduce\\n        // the needs of items after availing the offer\\n            }\\n            if(j==needs.size()) //j==needs.size means we can avil this offer \\n            //we take the minimum of values with availing a certain offer anf without \\n            // aviling the any offer and recur for remaining items in needs\\n                res = min(res, v[j]+shopping(price,special, new_needs));\\n        }\\n        mp.insert({needs,res});// memoizie the result\\n        return res;\\n        \\n    }\\n    \\n//This original_cost calulate the price to be paid if we don\\'t avail any offer\\n int original_cost(vector<int>& price, vector<int>& needs){\\n     int sum =0;\\n     for(int i=0;i<needs.size();i++){\\n         sum+= price[i]*needs[i];\\n     }\\n     return sum;\\n }\\n    \\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return shopping(price, special, needs);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int shopping(vector<int>&price, vector<vector<int>>& special, vector<int>&needs){\\n        int j=0, res = original_cost(price, needs);\\n       \\n        for(auto v: special){\\n            \\n           vector<int> new_needs = needs;  \\n            for(j=0;j<new_needs.size();j++){\\n                int dif = new_needs[j] - v[j];\\n                if(dif<0)break;\\n                \\n                new_needs[j] =  dif;\\n            }\\n            if(j==needs.size())\\n                res = min(res, v[j]+shopping(price,special, new_needs));\\n        }\\n        return res;\\n        \\n    }\\n int original_cost(vector<int>& price, vector<int>& needs){\\n     int sum =0;\\n     for(int i=0;i<needs.size();i++){\\n         sum+= price[i]*needs[i];\\n     }\\n     return sum;\\n }\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return shopping(price, special, needs);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783072,
                "title": "python-3-dfs-memoization-lru-cache",
                "content": "```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        n = len(price)\\n        @lru_cache(maxsize=None)\\n        def dfs(needs):\\n            ans = sum([i*j for i, j in zip(price, needs)]) \\n            cur = sys.maxsize\\n            for s in special:\\n                new_needs, ok = [], True\\n                for i in range(n):\\n                    need, give = needs[i], s[i]\\n                    if need < give:  # if over purchase, ignore this combination\\n                        ok = False\\n                        break\\n                    new_needs.append(need-give)    \\n                if ok: cur = min(cur, dfs(tuple(new_needs)) + s[-1])\\n            return min(ans, cur)\\n        return dfs(tuple(needs))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        n = len(price)\\n        @lru_cache(maxsize=None)\\n        def dfs(needs):\\n            ans = sum([i*j for i, j in zip(price, needs)]) \\n            cur = sys.maxsize\\n            for s in special:\\n                new_needs, ok = [], True\\n                for i in range(n):\\n                    need, give = needs[i], s[i]\\n                    if need < give:  # if over purchase, ignore this combination\\n                        ok = False\\n                        break\\n                    new_needs.append(need-give)    \\n                if ok: cur = min(cur, dfs(tuple(new_needs)) + s[-1])\\n            return min(ans, cur)\\n        return dfs(tuple(needs))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 714740,
                "title": "java-solution-with-detailed-explanations",
                "content": "```\\n1. We can see this problem as a graph traversal problem. \\n2. Graph representation: \\n\\t** vertex: `needs` array.  In example1:  [3, 2], number of items need to buy\\n\\t** neighbors:  \\n\\t\\t\\t- Not using special offer, buy directly  [0, 0]\\n\\t\\t\\t- Using special offer:  [0, 2] and [2, 0]\\n3. What we need to do in this graph\\n\\t\\t- we need to find a path from [3, 2] to [0, 0] which has the smallest cost\\n\\t\\t- so this is a all paths problem, we can use dfs backtracking.\\n\\t** what is the base case: when we reach the  vertex [0, 0]\\n\\t** what we need to return: the smallest cost we can get when starting from vertex [a, b]\\n\\t** in the meantime, we can use memorization to record the result we already know to avoid duplicated computation\\n4. Time Complexity: \\n\\t- We can think of the corresponding recursion tree.\\n\\t- Braching factor: the number of valid special offers + 1 (buy directly)\\n\\t- Height of tree: the largetest number of special offers we can use\\n\\t- O(branching factor ^ height of tree)\\n5. Space Complexity:\\n\\t- O(height of tree)\\n\\t\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        if (price == null || price.size() == 0 || needs == null || needs.size() == 0) {\\n            return 0;\\n        }\\n        \\n        int[] min = new int[]{Integer.MAX_VALUE};\\n        Map<List<Integer>, Integer> memo = new HashMap<>();\\n        int res= dfs(needs, price, special, memo);\\n        return res;\\n    }\\n    \\n    private int dfs(List<Integer> needs, List<Integer> price, List<List<Integer>> special, Map<List<Integer>, Integer> memo) {\\n        if (memo.containsKey(needs)) {\\n            return memo.get(needs);\\n        }\\n        if (allZero(needs)) {  \\n            return 0;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        // not using special offer, buy directly\\n        int total1 = 0;\\n        for (int i = 0; i < needs.size(); i++) {\\n            total1 += needs.get(i) * price.get(i);\\n        }\\n        min = Math.min(total1, min);\\n        // buy special offer\\n        int total2 = Integer.MAX_VALUE;\\n        for (int i = 0; i < special.size(); i++) {\\n            List<Integer> offer = special.get(i);\\n            int val = offer.get(offer.size()-1);\\n            boolean valid = true;\\n            for (int j = 0; j < offer.size()-1; j++) {\\n                if (needs.get(j) < offer.get(j)) {\\n                    valid = false;\\n                }\\n            }\\n            if (valid) {\\n                for (int j = 0; j < offer.size()-1; j++) {\\n                    int pre = needs.get(j);\\n                    needs.set(j, pre - offer.get(j));\\n                }\\n                total2 = val + dfs(needs, price, special, memo);\\n                for (int j = 0; j < offer.size()-1; j++) {\\n                    int pre = needs.get(j);\\n                    needs.set(j, pre + offer.get(j));\\n                }\\n                min = Math.min(total2, min);\\n            }\\n        }\\n        if (!memo.containsKey(needs)) {\\n            memo.put(needs, min);\\n        }\\n        return min;\\n    }\\n    \\n    private boolean allZero(List<Integer> list) {\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) < 0 || list.get(i) > 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        if (price == null || price.size() == 0 || needs == null || needs.size() == 0) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 462006,
                "title": "python-dp-solution",
                "content": "This is my first version which leads to TLE.\\t\\n\\n\\t\\tclass Solution(object):\\n\\t\\t\\tdef shoppingOffers(self, price, special, needs):\\n\\t\\t\\t\\n\\t\\t\\t\\tdef helper(needs):\\n\\t\\t\\t\\t\\tif needs == [0]*m:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\t\\tres = float(\\'inf\\')\\n\\n\\t\\t\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\t\\t\\tneeds[i] -= 1\\n\\t\\t\\t\\t\\t\\tif needs[i] >= 0:\\n\\t\\t\\t\\t\\t\\t\\tres = min(res, helper(needs[:])+price[i])\\n\\t\\t\\t\\t\\t\\tneeds[i] += 1\\n\\n\\t\\t\\t\\t\\tfor sp in special:\\n\\t\\t\\t\\t\\t\\tfor i in range(len(needs)):\\n\\t\\t\\t\\t\\t\\t\\tneeds[i] -= sp[i]\\n\\t\\t\\t\\t\\t\\tif all(needs[i] >= 0 for i in range(len(needs))):\\n\\t\\t\\t\\t\\t\\t\\tres = min(res, helper(needs[:])+sp[-1])\\n\\t\\t\\t\\t\\t\\tfor i in range(len(needs)):\\n\\t\\t\\t\\t\\t\\t\\tneeds[i] += sp[i]\\n\\n\\t\\t\\t\\t\\treturn res\\n\\n\\t\\t\\t\\tn = max(needs)+1\\n\\t\\t\\t\\tm = len(needs)\\n\\n\\t\\t\\t\\t#call helper function to solve this problem recursively\\n\\t\\t\\t\\treturn helper(needs)\\n\\t\\t\\t\\t\\nThen I use memerization to avoid calculating the existed minimum price twice. This is version 2 which still leads to TLE.\\n\\n\\tclass Solution(object):\\n\\t\\tdef shoppingOffers(self, price, special, needs):\\n\\n\\t\\t\\tdef helper(needs):\\n\\t\\t\\t\\tif needs == [0]*m:\\n\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tif tuple(needs) in d:\\n\\t\\t\\t\\t\\treturn d[tuple(needs)]\\n\\n\\t\\t\\t\\tres = float(\\'inf\\')\\n\\n\\t\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\t\\tneeds[i] -= 1\\n\\t\\t\\t\\t\\tif needs[i] >= 0:\\n\\t\\t\\t\\t\\t\\tres = min(res, helper(needs[:])+price[i])\\n\\t\\t\\t\\t\\tneeds[i] += 1\\n\\n\\t\\t\\t\\tfor sp in special:\\n\\t\\t\\t\\t\\tfor i in range(len(needs)):\\n\\t\\t\\t\\t\\t\\tneeds[i] -= sp[i]\\n\\t\\t\\t\\t\\tif all(needs[i] >= 0 for i in range(len(needs))):\\n\\t\\t\\t\\t\\t\\tres = min(res, helper(needs[:])+sp[-1])\\n\\t\\t\\t\\t\\tfor i in range(len(needs)):\\n\\t\\t\\t\\t\\t\\tneeds[i] += sp[i]\\n\\n\\t\\t\\t\\td[tuple(needs)] = res\\n            \\n\\t\\t\\t\\treturn res\\n\\n\\n\\t\\t\\tn = max(needs)+1\\n\\t\\t\\tm = len(needs)\\n\\n\\t\\t\\td = {}\\n\\n\\t\\t\\t#call helper function to solve this problem recursively\\n\\t\\t\\treturn helper(needs)\\n\\t\\t\\t\\nWe can calculate the minimum price without special offers easily without recursion. This intuition leads to version 3 and it is accepted.\\n\\n\\tclass Solution(object):\\n\\t\\tdef shoppingOffers(self, price, special, needs):\\n\\n\\t\\t\\tdef helper(needs):\\n\\t\\t\\t\\tif needs == [0]*m:\\n\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tif tuple(needs) in d:\\n\\t\\t\\t\\t\\treturn d[tuple(needs)]\\n\\n\\t\\t\\t\\tres = 0\\n\\n\\t\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\t\\tres += needs[i]*price[i]\\n\\n\\t\\t\\t\\tfor sp in special:\\n\\t\\t\\t\\t\\tfor i in range(len(needs)):\\n\\t\\t\\t\\t\\t\\tneeds[i] -= sp[i]\\n\\t\\t\\t\\t\\tif all(needs[i] >= 0 for i in range(len(needs))):\\n\\t\\t\\t\\t\\t\\tres = min(res, helper(needs[:])+sp[-1])\\n\\t\\t\\t\\t\\tfor i in range(len(needs)):\\n\\t\\t\\t\\t\\t\\tneeds[i] += sp[i]\\n\\n\\t\\t\\t\\td[tuple(needs)] = res\\n\\n\\t\\t\\t\\treturn res\\n\\n\\n\\t\\t\\tn = max(needs)+1\\n\\t\\t\\tm = len(needs)\\n\\n\\t\\t\\td = {}\\n\\n\\t\\t\\t#call helper function to solve this problem recursively\\n\\t\\t\\treturn helper(needs)\\n        \\n        \\n        \\n        \\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "class Solution(object):\\n\\t\\t\\tdef shoppingOffers(self, price, special, needs):\\n\\t\\t\\t\\n\\t\\t\\t\\tdef helper(needs):\\n\\t\\t\\t\\t\\tif needs == [0]*m:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\t\\tres = float(\\'inf\\')\\n\\n\\t\\t\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\t\\t\\tneeds[i] -= 1\\n\\t\\t\\t\\t\\t\\tif needs[i] >= 0:\\n\\t\\t\\t\\t\\t\\t\\tres = min(res, helper(needs[:])+price[i])\\n\\t\\t\\t\\t\\t\\tneeds[i] += 1\\n\\n\\t\\t\\t\\t\\tfor sp in special:\\n\\t\\t\\t\\t\\t\\tfor i in range(len(needs)):\\n\\t\\t\\t\\t\\t\\t\\tneeds[i] -= sp[i]\\n\\t\\t\\t\\t\\t\\tif all(needs[i] >= 0 for i in range(len(needs))):\\n\\t\\t\\t\\t\\t\\t\\tres = min(res, helper(needs[:])+sp[-1])\\n\\t\\t\\t\\t\\t\\tfor i in range(len(needs)):\\n\\t\\t\\t\\t\\t\\t\\tneeds[i] += sp[i]\\n\\n\\t\\t\\t\\t\\treturn res\\n\\n\\t\\t\\t\\tn = max(needs)+1\\n\\t\\t\\t\\tm = len(needs)\\n\\n\\t\\t\\t\\t#call helper function to solve this problem recursively\\n\\t\\t\\t\\treturn helper(needs)\\n\\t\\t\\t\\t\\nThen I use memerization to avoid calculating the existed minimum price twice. This is version 2 which still leads to TLE.\\n\\n\\tclass Solution(object):\\n\\t\\tdef shoppingOffers(self, price, special, needs):\\n\\n\\t\\t\\tdef helper(needs):\\n\\t\\t\\t\\tif needs == [0]*m:\\n\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tif tuple(needs) in d:\\n\\t\\t\\t\\t\\treturn d[tuple(needs)]\\n\\n\\t\\t\\t\\tres = float(\\'inf\\')\\n\\n\\t\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\t\\tneeds[i] -= 1\\n\\t\\t\\t\\t\\tif needs[i] >= 0:\\n\\t\\t\\t\\t\\t\\tres = min(res, helper(needs[:])+price[i])\\n\\t\\t\\t\\t\\tneeds[i] += 1\\n\\n\\t\\t\\t\\tfor sp in special:\\n\\t\\t\\t\\t\\tfor i in range(len(needs)):\\n\\t\\t\\t\\t\\t\\tneeds[i] -= sp[i]\\n\\t\\t\\t\\t\\tif all(needs[i] >= 0 for i in range(len(needs))):\\n\\t\\t\\t\\t\\t\\tres = min(res, helper(needs[:])+sp[-1])\\n\\t\\t\\t\\t\\tfor i in range(len(needs)):\\n\\t\\t\\t\\t\\t\\tneeds[i] += sp[i]\\n\\n\\t\\t\\t\\td[tuple(needs)] = res\\n            \\n\\t\\t\\t\\treturn res\\n\\n\\n\\t\\t\\tn = max(needs)+1\\n\\t\\t\\tm = len(needs)\\n\\n\\t\\t\\td = {}",
                "codeTag": "Java"
            },
            {
                "id": 3165959,
                "title": "python-3-10-lines-dfs-w-comments-t-m-75-34",
                "content": "```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], specials: List[List[int]], needs: List[int]) -> int:\\n\\n        @lru_cache(None)\\n        def dfs(needs):\\n\\n            cost = sum(map(mul, needs, price))          # cost with no specials applied\\n\\n            for special in specials:\\n                specPrice = special.pop()\\n                tmp = tuple(map(sub, needs, special))   # reset need if special applied\\n\\n                if min(tmp) < 0: continue               # special cannot be applied\\n\\n                cost = min(cost, dfs(tmp)) + specPrice  # id special best buy?\\n\\n            return cost                                 # return best cost for needs\\n\\n        return dfs(tuple(needs))\\n```\\n[https://leetcode.com/problems/shopping-offers/submissions/894987964/](http://)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], specials: List[List[int]], needs: List[int]) -> int:\\n\\n        @lru_cache(None)\\n        def dfs(needs):\\n\\n            cost = sum(map(mul, needs, price))          # cost with no specials applied\\n\\n            for special in specials:\\n                specPrice = special.pop()\\n                tmp = tuple(map(sub, needs, special))   # reset need if special applied\\n\\n                if min(tmp) < 0: continue               # special cannot be applied\\n\\n                cost = min(cost, dfs(tmp)) + specPrice  # id special best buy?\\n\\n            return cost                                 # return best cost for needs\\n\\n        return dfs(tuple(needs))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139964,
                "title": "unbounded-knapsack-recursion-memoization",
                "content": "# Code\\n```\\nclass Solution // Unbounded Knapsack\\n{\\npublic:\\n    map<vector<int>,int> m;\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) \\n    {\\n        int n=price.size();\\n        int withoutOffer=0;\\n        for(int x=0; x<n; x++) withoutOffer+=price[x]*needs[x];\\n        int mn=withoutOffer;\\n        if(m.find(needs)!=m.end()) return m[needs];\\n        for(int x=0; x<special.size(); x++)\\n        {\\n            int f=1;\\n            for(int y=0; y<n; y++) \\n            {\\n                if(special[x][y]>needs[y])\\n                {\\n                    f=0; break;\\n                }\\n            }\\n            if(f)\\n            {\\n                vector<int> newneeds(n);\\n                for(int y=0; y<n; y++)\\n                {\\n                    newneeds[y]=needs[y]-special[x][y];\\n                }\\n                int offer=special[x][n]+shoppingOffers(price,special,newneeds);\\n                if(offer<mn) mn=offer;\\n            }\\n        }\\n        return m[needs]=mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution // Unbounded Knapsack\\n{\\npublic:\\n    map<vector<int>,int> m;\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) \\n    {\\n        int n=price.size();\\n        int withoutOffer=0;\\n        for(int x=0; x<n; x++) withoutOffer+=price[x]*needs[x];\\n        int mn=withoutOffer;\\n        if(m.find(needs)!=m.end()) return m[needs];\\n        for(int x=0; x<special.size(); x++)\\n        {\\n            int f=1;\\n            for(int y=0; y<n; y++) \\n            {\\n                if(special[x][y]>needs[y])\\n                {\\n                    f=0; break;\\n                }\\n            }\\n            if(f)\\n            {\\n                vector<int> newneeds(n);\\n                for(int y=0; y<n; y++)\\n                {\\n                    newneeds[y]=needs[y]-special[x][y];\\n                }\\n                int offer=special[x][n]+shoppingOffers(price,special,newneeds);\\n                if(offer<mn) mn=offer;\\n            }\\n        }\\n        return m[needs]=mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902901,
                "title": "knapsack-dp-vector-as-a-key",
                "content": "Either use all special offers which satisfy the condition or don\\'t use special offers( instead by them).\\n```\\nclass Solution {\\npublic:\\n    \\n    map<vector<int>,int> dp;\\n    int solve(vector<int> price, vector<vector<int>> special, vector<int> needs){\\n      \\n        if(dp[needs]!=0){\\n            return dp[needs];\\n        }\\n       int cost=INT_MAX,idx=0;\\n        for(idx=0;idx<needs.size();idx++){\\n            if(needs[idx]>0)\\n                break;\\n        }\\n        \\n        if(idx==needs.size()){\\n            return 0;\\n        }\\n       int t=price[idx]*needs[idx],p=needs[idx];\\n       needs[idx]=0;\\n       cost=min(cost,t+solve(price,special,needs));\\n       needs[idx]=p;  \\n      for(int i=0;i<special.size();i++){\\n          int f=0;\\n          for(int j=0;j<special[i].size()-1;j++){\\n              if(special[i][j]>needs[j]){\\n                  f=1;\\n                  break;\\n              }\\n          }\\n          if(!f){\\n              vector<int> temp(needs.begin(),needs.end());\\n              for(int j=0;j<needs.size();j++){\\n                  temp[j]-=special[i][j];\\n              }\\n              cost=min(cost,special[i][special[i].size()-1]+solve(price,special,temp));\\n          }\\n      }\\n        return dp[needs]=cost;\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return solve(price,special,needs);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    map<vector<int>,int> dp;\\n    int solve(vector<int> price, vector<vector<int>> special, vector<int> needs){\\n      \\n        if(dp[needs]!=0){\\n            return dp[needs];\\n        }\\n       int cost=INT_MAX,idx=0;\\n        for(idx=0;idx<needs.size();idx++){\\n            if(needs[idx]>0)\\n                break;\\n        }\\n        \\n        if(idx==needs.size()){\\n            return 0;\\n        }\\n       int t=price[idx]*needs[idx],p=needs[idx];\\n       needs[idx]=0;\\n       cost=min(cost,t+solve(price,special,needs));\\n       needs[idx]=p;  \\n      for(int i=0;i<special.size();i++){\\n          int f=0;\\n          for(int j=0;j<special[i].size()-1;j++){\\n              if(special[i][j]>needs[j]){\\n                  f=1;\\n                  break;\\n              }\\n          }\\n          if(!f){\\n              vector<int> temp(needs.begin(),needs.end());\\n              for(int j=0;j<needs.size();j++){\\n                  temp[j]-=special[i][j];\\n              }\\n              cost=min(cost,special[i][special[i].size()-1]+solve(price,special,temp));\\n          }\\n      }\\n        return dp[needs]=cost;\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return solve(price,special,needs);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741734,
                "title": "0-1-knapsack-idea-dp-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    map<pair<int,vector<int>>,int>mp;               // for memorization of dp states\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return solve(price,special,needs,0);\\n    }\\n    \\n    int solve(vector<int>& price, vector<vector<int>>& special, vector<int> needs,int st){\\n        if(st==special.size()){\\n            int cost=0;\\n            for(int i=0;i<needs.size();++i){\\n                cost+=needs[i]*price[i];\\n            }\\n            return cost;\\n        }\\n        if(mp.find({st,needs})!=mp.end()) return mp[{st,needs}];\\n        vector<int>need=needs;\\n        for(int j=0;j<price.size();++j){\\n            need[j]=needs[j]-special[st][j];\\n            if(need[j]<0) return mp[{st,needs}]=solve(price,special,needs,st+1);\\n        }\\n        return mp[{st,needs}]=min(solve(price,special,needs,st+1),solve(price,special,need,st)+special[st][price.size()]);          // either choose it or don\\'t choose\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    map<pair<int,vector<int>>,int>mp;               // for memorization of dp states\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return solve(price,special,needs,0);\\n    }\\n    \\n    int solve(vector<int>& price, vector<vector<int>>& special, vector<int> needs,int st){\\n        if(st==special.size()){\\n            int cost=0;\\n            for(int i=0;i<needs.size();++i){\\n                cost+=needs[i]*price[i];\\n            }\\n            return cost;\\n        }\\n        if(mp.find({st,needs})!=mp.end()) return mp[{st,needs}];\\n        vector<int>need=needs;\\n        for(int j=0;j<price.size();++j){\\n            need[j]=needs[j]-special[st][j];\\n            if(need[j]<0) return mp[{st,needs}]=solve(price,special,needs,st+1);\\n        }\\n        return mp[{st,needs}]=min(solve(price,special,needs,st+1),solve(price,special,need,st)+special[st][price.size()]);          // either choose it or don\\'t choose\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545221,
                "title": "python-recursion-bitmask-with-thought-process-when-being-asked-on-interviews",
                "content": "### Recursion + Memoziation + Bitmask\\nIt requires to return the minimum price we use to purchase all of `needs` items without more unneeded items, which means the special offer can\\'t be used as long as the count for any item is more than the number of `needed` item. For example, we need `[3,2]` for a and b items, then the special `[3,1]` is availble but `[2,3]` is not. Because the `3` for b is more than `2` even `2` for a is smaller than needed `3`.\\n\\nBesides, the special offers can be used as many times as we can, we can just iterate each special offer to see if it\\'s possible to use, and recursively call the same function to get the minimum price with changed `needs`.\\nThen it comes to the most difficult part of this prolem, how to memorize the result according to `needs`.  If you don\\'t understand why we need memorization, you might need recall that recursion will invovle redundant calculation that can be cached for further use to save time.\\n\\nYou might come up with the approach that we can use tuple/list of `needs` as `key` to represent the state, However it might inefficient. Note that the number of items is up to 6, and the number of pieces for each item up to 10, which indicates we might be able to use bitmask as counter for the `state`. Since we can use 4 bits to represent up to 16 which is larger than 10, and `4 * 6 = 24 < 32 bit`, we can use one integer number `state` simply to represent counters of `needs`. \\nWell, how to get the count and set new count to `state` might take you more time to settle down. \\n\\n**Get Count**\\nSince we use 4 bits for one counter, we can simply shift right `state` to ignore other counters and get the least 4 significant bits \\n```\\nget(i):\\n     state >> 4 * i & ((1 << 4) - 1)\\n```\\n\\n**Set Count**\\nWe do the similar thing as getting count, shift right `state` to set the least significant 4 bits and shift left back and union the other bits from original `state`.\\n```\\nset(i, count):\\n    ((state >> 4 * i) | ~((1 << 4)  - 1)| count) << 4 * i) | (state & ((1 << 4 * i) - 1))\\n```\\n\\nSince we always set the `state` sequentially, so we can just incrementally set the least 4 significant bits without shifting back, which can simplify the code. At the same time, the `getCount` should be modified to shift right reversely. (the 0 indexed counter is the most significant bit then)\\n```\\nget(i, count):\\n    return (state >> 4 * (m - i - 1)) & ((1 << 4) - 1)\\n\\nset(count):\\n   return (state << 4) | count\\n```\\n\\n\\nLastly, it\\'s possible to get minimum price without using special offers, so we also calculate the price using the original `price`.\\n\\n```python\\ndef shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n\\tn = len(special)\\n\\tm = len(needs)\\n        \\n\\tdef getCount(state, i):\\n\\t\\t (state >> 4 * (m - i - 1)) & ((1 << 4) - 1)\\n         \\n\\tdef setCount(state, count):\\n\\t\\treturn (state << 4) | count\\n\\n\\t@cache\\n\\tdef helper(state):\\n\\t\\tif not state:\\n\\t\\t\\treturn 0\\n\\t\\tres = sum(price[j] * getCount(state, j) for j in range(m))\\n        for i in range(n):\\n\\t\\t\\tnext_state = 0\\n            for j in range(m):\\n\\t\\t\\t\\tcount = getCount(state, j)\\n                if count < special[i][j]:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tnext_state = setCount(next_state, count - special[i][j])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres = min(res, special[i][-1] + helper(next_state))\\n\\t\\treturn res\\n        \\n\\tstate = 0\\n    for i, num in enumerate(needs): \\n\\t\\tstate = setCount(state, num)\\n\\treturn helper(state)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nget(i):\\n     state >> 4 * i & ((1 << 4) - 1)\\n```\n```\\nset(i, count):\\n    ((state >> 4 * i) | ~((1 << 4)  - 1)| count) << 4 * i) | (state & ((1 << 4 * i) - 1))\\n```\n```\\nget(i, count):\\n    return (state >> 4 * (m - i - 1)) & ((1 << 4) - 1)\\n\\nset(count):\\n   return (state << 4) | count\\n```\n```python\\ndef shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n\\tn = len(special)\\n\\tm = len(needs)\\n        \\n\\tdef getCount(state, i):\\n\\t\\t (state >> 4 * (m - i - 1)) & ((1 << 4) - 1)\\n         \\n\\tdef setCount(state, count):\\n\\t\\treturn (state << 4) | count\\n\\n\\t@cache\\n\\tdef helper(state):\\n\\t\\tif not state:\\n\\t\\t\\treturn 0\\n\\t\\tres = sum(price[j] * getCount(state, j) for j in range(m))\\n        for i in range(n):\\n\\t\\t\\tnext_state = 0\\n            for j in range(m):\\n\\t\\t\\t\\tcount = getCount(state, j)\\n                if count < special[i][j]:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tnext_state = setCount(next_state, count - special[i][j])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres = min(res, special[i][-1] + helper(next_state))\\n\\t\\treturn res\\n        \\n\\tstate = 0\\n    for i, num in enumerate(needs): \\n\\t\\tstate = setCount(state, num)\\n\\treturn helper(state)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1231722,
                "title": "just-like-knapsack-nothing-special-in-special-offers-simple-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&price,vector<vector<int>>&special,vector<int> needs,int splIterator)\\n    {\\n        if(splIterator>=special.size())\\n        {\\n            int ans=0;\\n            for(int i=0;i<needs.size();i++)\\n            {\\n                ans+=(needs[i]*price[i]);\\n            }\\n            return ans;\\n        }\\n        \\n        int n=needs.size();\\n        int leaveThisOffer = solve(price,special,needs,splIterator+1);\\n        \\n        bool flag=0;\\n        for(int i=0;i<needs.size();i++)\\n        {\\n            if(needs[i]<special[splIterator][i])\\n            {\\n                flag=1;\\n                break;\\n            }\\n            needs[i]=needs[i]-special[splIterator][i];\\n        }\\n        int takeThisOffer=INT_MAX;\\n        if(flag==0)\\n        {\\n             takeThisOffer = special[splIterator][n] + solve(price,special,needs,splIterator);\\n        }\\n        return min(takeThisOffer,leaveThisOffer);\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return solve(price,special,needs,0);\\n    }\\n};\\n```\\n\\n**If you like the post and the clear code, please do upvote so that it reaches others. Thanks.**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&price,vector<vector<int>>&special,vector<int> needs,int splIterator)\\n    {\\n        if(splIterator>=special.size())\\n        {\\n            int ans=0;\\n            for(int i=0;i<needs.size();i++)\\n            {\\n                ans+=(needs[i]*price[i]);\\n            }\\n            return ans;\\n        }\\n        \\n        int n=needs.size();\\n        int leaveThisOffer = solve(price,special,needs,splIterator+1);\\n        \\n        bool flag=0;\\n        for(int i=0;i<needs.size();i++)\\n        {\\n            if(needs[i]<special[splIterator][i])\\n            {\\n                flag=1;\\n                break;\\n            }\\n            needs[i]=needs[i]-special[splIterator][i];\\n        }\\n        int takeThisOffer=INT_MAX;\\n        if(flag==0)\\n        {\\n             takeThisOffer = special[splIterator][n] + solve(price,special,needs,splIterator);\\n        }\\n        return min(takeThisOffer,leaveThisOffer);\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return solve(price,special,needs,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257113,
                "title": "python-simple-recursion",
                "content": "```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n\\t\\n        def helper(res, specials, needs):\\n            if sum(needs) == 0:\\n                return res\\n            \\n            if not specials:\\n                return res + sum([price[i]*needs[i] for i in range(len(needs))])\\n            \\n            special = specials[0]\\n            for i in range(len(needs)):\\n                if special[i] > needs[i]:\\n                    return helper(res, specials[1:], needs)\\n            \\n            return min(helper(res, specials[1:], needs), helper(res+special[-1], specials, [needs[i]-special[i] for i in range(len(needs))]))\\n        \\n        return helper(0, special, needs)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n\\t\\n        def helper(res, specials, needs):\\n            if sum(needs) == 0:\\n                return res\\n            \\n            if not specials:\\n                return res + sum([price[i]*needs[i] for i in range(len(needs))])\\n            \\n            special = specials[0]\\n            for i in range(len(needs)):\\n                if special[i] > needs[i]:\\n                    return helper(res, specials[1:], needs)\\n            \\n            return min(helper(res, specials[1:], needs), helper(res+special[-1], specials, [needs[i]-special[i] for i in range(len(needs))]))\\n        \\n        return helper(0, special, needs)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180141,
                "title": "c-without-dp-simple-recursion-knapsack-pattern",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& price, vector<vector<int>>& special, vector<int>& needs,int ind)\\n    {\\n        int n = needs.size();\\n        if(ind<0)\\n        {\\n            int ans =0;\\n            \\n            for(int i=0;i<needs.size();i++)\\n            {\\n                ans += needs[i]*price[i];\\n            }   \\n            return ans;\\n        }\\n        else\\n        {\\n            bool lte = true;\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                if(needs[i]<special[ind][i])\\n                {\\n                    lte = false;\\n                    break;\\n                }\\n            }\\n            if(lte)\\n            {\\n                //op1\\n                int op1 = solve(price,special,needs,ind-1);\\n                \\n                \\n                //op2\\n                int op2 = 0;\\n                for(int i=0;i<n;i++)\\n                {\\n                    needs[i] = needs[i] - special[ind][i];\\n                }\\n                \\n                op2 = special[ind][n] + solve(price,special,needs,ind);\\n                \\n                for(int i=0;i<n;i++)\\n                {\\n                    needs[i] = needs[i] + special[ind][i];\\n                }\\n                \\n                return min(op1,op2);\\n            }\\n            else\\n            {\\n                return solve(price,special,needs,ind-1);\\n            }\\n        }\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int ind=special.size()-1;\\n        return solve(price,special,needs,ind);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& price, vector<vector<int>>& special, vector<int>& needs,int ind)\\n    {\\n        int n = needs.size();\\n        if(ind<0)\\n        {\\n            int ans =0;\\n            \\n            for(int i=0;i<needs.size();i++)\\n            {\\n                ans += needs[i]*price[i];\\n            }   \\n            return ans;\\n        }\\n        else\\n        {\\n            bool lte = true;\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                if(needs[i]<special[ind][i])\\n                {\\n                    lte = false;\\n                    break;\\n                }\\n            }\\n            if(lte)\\n            {\\n                //op1\\n                int op1 = solve(price,special,needs,ind-1);\\n                \\n                \\n                //op2\\n                int op2 = 0;\\n                for(int i=0;i<n;i++)\\n                {\\n                    needs[i] = needs[i] - special[ind][i];\\n                }\\n                \\n                op2 = special[ind][n] + solve(price,special,needs,ind);\\n                \\n                for(int i=0;i<n;i++)\\n                {\\n                    needs[i] = needs[i] + special[ind][i];\\n                }\\n                \\n                return min(op1,op2);\\n            }\\n            else\\n            {\\n                return solve(price,special,needs,ind-1);\\n            }\\n        }\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int ind=special.size()-1;\\n        return solve(price,special,needs,ind);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880623,
                "title": "100-faster-solution-c-recusion-map-hashing-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    map<vector<int>, int> mp;\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int> needs) {\\n        if(accumulate(needs.begin(), needs.end(), 0) == 0) return 0;  //sums up all the needs \\n        if(mp.find(needs) != mp.end()) return mp[needs];   // If previously calculated results exist for this need array we will return those result\\n        int cost = 0;\\n        for(int k = 0; k < price.size(); k++) cost += price[k]*needs[k]; //price with  no special offer\\n        vector<int> aux = needs; // auxilary array to restore needs after making necessary changes\\n        for(int i = 0; i < special.size(); i++){\\n            int j = 0;\\n            for(j = 0; j < needs.size(); j++) \\n                if(needs[j] < special[i][j]) break; \\n            if(j < needs.size()) continue; // if there exists a need which is less than what\\'s offered in special offer we will not calculate for that offer\\n            for(j = 0; j < needs.size(); j++) needs[j]-=special[i][j]; // reducing needs as offer is applied\\n            cost = min(cost,special[i][needs.size()] + shoppingOffers(price, special, needs));\\n            needs = aux;\\n        }\\n        return mp[aux] = cost;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<vector<int>, int> mp;\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int> needs) {\\n        if(accumulate(needs.begin(), needs.end(), 0) == 0) return 0;  //sums up all the needs \\n        if(mp.find(needs) != mp.end()) return mp[needs];   // If previously calculated results exist for this need array we will return those result\\n        int cost = 0;\\n        for(int k = 0; k < price.size(); k++) cost += price[k]*needs[k]; //price with  no special offer\\n        vector<int> aux = needs; // auxilary array to restore needs after making necessary changes\\n        for(int i = 0; i < special.size(); i++){\\n            int j = 0;\\n            for(j = 0; j < needs.size(); j++) \\n                if(needs[j] < special[i][j]) break; \\n            if(j < needs.size()) continue; // if there exists a need which is less than what\\'s offered in special offer we will not calculate for that offer\\n            for(j = 0; j < needs.size(); j++) needs[j]-=special[i][j]; // reducing needs as offer is applied\\n            cost = min(cost,special[i][needs.size()] + shoppingOffers(price, special, needs));\\n            needs = aux;\\n        }\\n        return mp[aux] = cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548873,
                "title": "c-readable-code-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int shopping(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int res = 0;\\n        for(int i=0;i<needs.size();i++) {\\n            res += needs[i]*price[i];\\n        }\\n        for(auto offer:special) {\\n            bool flag = true;\\n            vector<int> clone = needs;\\n            for(int i=0;i<offer.size()-1;i++) {\\n                if(needs[i]<offer[i]) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) {\\n                 int offer_cost = offer[offer.size()-1];\\n                 for(int i=0;i<clone.size();i++) {\\n                        clone[i] -= offer[i];\\n                 }\\n                 res = min(res, offer_cost + shopping(price,special,clone));\\n             }\\n        }\\n        return res;\\n        \\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs)    {\\n        return shopping(price, special, needs);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shopping(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int res = 0;\\n        for(int i=0;i<needs.size();i++) {\\n            res += needs[i]*price[i];\\n        }\\n        for(auto offer:special) {\\n            bool flag = true;\\n            vector<int> clone = needs;\\n            for(int i=0;i<offer.size()-1;i++) {\\n                if(needs[i]<offer[i]) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) {\\n                 int offer_cost = offer[offer.size()-1];\\n                 for(int i=0;i<clone.size();i++) {\\n                        clone[i] -= offer[i];\\n                 }\\n                 res = min(res, offer_cost + shopping(price,special,clone));\\n             }\\n        }\\n        return res;\\n        \\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs)    {\\n        return shopping(price, special, needs);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258356,
                "title": "c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int directbuy(vector<int>& price, vector<int>& needs)\\n    {\\n        int sum = 0;\\n        for(int i=0;i<price.size();i++) sum += price[i]*needs[i];\\n        return sum;\\n    }\\n    \\n    int solve(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int pos)\\n    {\\n        int n = needs.size();\\n        int ans = directbuy(price,needs);\\n        for(int i=pos;i<special.size();i++)\\n        {\\n            vector<int> temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(special[i][j]>needs[j])\\n                {\\n                    temp.clear();\\n                    break;\\n                }\\n                temp.push_back(needs[j]-special[i][j]);\\n            }\\n            if(temp.size()>0) ans = min(ans, special[i][n] + solve(price,special,temp,i));\\n        }\\n        return ans;\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return solve(price,special,needs,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int directbuy(vector<int>& price, vector<int>& needs)\\n    {\\n        int sum = 0;\\n        for(int i=0;i<price.size();i++) sum += price[i]*needs[i];\\n        return sum;\\n    }\\n    \\n    int solve(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int pos)\\n    {\\n        int n = needs.size();\\n        int ans = directbuy(price,needs);\\n        for(int i=pos;i<special.size();i++)\\n        {\\n            vector<int> temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(special[i][j]>needs[j])\\n                {\\n                    temp.clear();\\n                    break;\\n                }\\n                temp.push_back(needs[j]-special[i][j]);\\n            }\\n            if(temp.size()>0) ans = min(ans, special[i][n] + solve(price,special,temp,i));\\n        }\\n        return ans;\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return solve(price,special,needs,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197763,
                "title": "c-solution-using-backtracking-with-explaination",
                "content": "\\'\\'\\'\\n\\n    void increase_needs(vector<int>&needs,vector<vector<int>>&special,int i,int n)\\n    {\\n        for(int j=0;j<n;j++)\\n        {\\n            needs[j]+=special[i][j];\\n        }\\n        return;\\n    }\\n    \\n    void decrease_needs(vector<int>&needs,vector<vector<int>>&special,int i,int n)\\n    {\\n        for(int j=0;j<n;j++)\\n        {\\n            needs[j]-=special[i][j];\\n        }\\n        return;\\n    }\\n    \\n    bool isValid(vector<int>&needs,vector<vector<int>>&special,int i,int n)\\n    {\\n        for(int j=0;j<n;j++)\\n        {\\n            if(needs[j]<special[i][j]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int solve(vector<int>&price,vector<vector<int>>&special,vector<int>&needs,int n,int m)\\n    {\\n        int ans=INT_MAX;\\n        int tmp_ans=0;\\n//          We are recursively check to grab every offer that we can grab.\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n//             check wether we are eligible for i\\'th offer.\\n\\n            if(isValid(needs,special,i,n))\\n            {\\n//             if we can grab this offer.then decrease items that we need. \\n\\n                decrease_needs(needs,special,i,n);\\n//                 add the amount of this particular offer in tmp_ans and recursively check for the remaining items that we need.\\n\\n                tmp_ans=special[i][n]+solve(price,special,needs,n,m);\\n//             if tmp_ans is minimum then previous answer then update the ans with tmp_ans.\\n\\n                ans=min(ans,tmp_ans);\\n//                 backtracking.Increase the items that we have decreased earlier for i\\'th offer.\\n\\n                increase_needs(needs,special,i,n);\\n            }\\n        }\\n//         calcuate the answer without grabing any offer.maybe the regular price is lesser than special offer price.\\n\\n        tmp_ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(needs[i]>0)\\n            {\\n                tmp_ans+=price[i]*needs[i];\\n            }\\n        }\\n        // return the minimum of amount with special offer or without special offer.\\n        ans=min(ans,tmp_ans);\\n        return ans;\\n    }\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs)\\n    {\\n        int n=price.size();\\n        int m=special.size();\\n        return solve(price,special,needs,n,m);\\n\\t\\t\\n    }\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    void increase_needs(vector<int>&needs,vector<vector<int>>&special,int i,int n)\\n    {\\n        for(int j=0;j<n;j++)\\n        {\\n            needs[j]+=special[i][j];\\n        }\\n        return;\\n    }\\n    \\n    void decrease_needs(vector<int>&needs,vector<vector<int>>&special,int i,int n)\\n    {\\n        for(int j=0;j<n;j++)\\n        {\\n            needs[j]-=special[i][j];\\n        }\\n        return;\\n    }\\n    \\n    bool isValid(vector<int>&needs,vector<vector<int>>&special,int i,int n)\\n    {\\n        for(int j=0;j<n;j++)\\n        {\\n            if(needs[j]<special[i][j]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int solve(vector<int>&price,vector<vector<int>>&special,vector<int>&needs,int n,int m)\\n    {\\n        int ans=INT_MAX;\\n        int tmp_ans=0;\\n//          We are recursively check to grab every offer that we can grab.\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n//             check wether we are eligible for i\\'th offer.\\n\\n            if(isValid(needs,special,i,n))\\n            {\\n//             if we can grab this offer.then decrease items that we need. \\n\\n                decrease_needs(needs,special,i,n);\\n//                 add the amount of this particular offer in tmp_ans and recursively check for the remaining items that we need.\\n\\n                tmp_ans=special[i][n]+solve(price,special,needs,n,m);\\n//             if tmp_ans is minimum then previous answer then update the ans with tmp_ans.\\n\\n                ans=min(ans,tmp_ans);\\n//                 backtracking.Increase the items that we have decreased earlier for i\\'th offer.\\n\\n                increase_needs(needs,special,i,n);\\n            }\\n        }\\n//         calcuate the answer without grabing any offer.maybe the regular price is lesser than special offer price.\\n\\n        tmp_ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(needs[i]>0)\\n            {\\n                tmp_ans+=price[i]*needs[i];\\n            }\\n        }\\n        // return the minimum of amount with special offer or without special offer.\\n        ans=min(ans,tmp_ans);\\n        return ans;\\n    }\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs)\\n    {\\n        int n=price.size();\\n        int m=special.size();\\n        return solve(price,special,needs,n,m);\\n\\t\\t\\n    }\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1134998,
                "title": "java-2ms-beats-90-well-documented-dfs-solution",
                "content": "I don\\'t see many codes with good documentation. Many used variables hard to understand. Here\\'s this post to solve this problem. I believe a varaible called as \"newNeeds\" is much easier to understand than \"temp\".\\n```\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        return dfs(special, 0, needs, price);\\n    }\\n\\n    /**\\n     * @param special -> special offers\\n     * @param specialPosition -> id of special offers\\n     * @param needs -> needs list\\n     * @param price -> price list\\n     * @return min cost to reach target, \\n     *         trying to use id of specialPosition (and all the followings) in special offers, and with current needs.\\n     *         maybe we can add a mem which is a combination of specialPosition and current needs to do a fast return.\\n     */\\n    private int dfs(List<List<Integer>> special, int specialPosition, List<Integer> needs, List<Integer> price) {\\n        // get base price if only purchasing single items\\n        int base = getBase(price, needs);\\n        for (int i = specialPosition; i < special.size(); i++) {\\n            List<Integer> newNeeds = canUseSpecial(special.get(i), needs);\\n            // if somehow cannot use current offer any more, continue\\n            if (newNeeds == null) continue;\\n            // can use current offer, update with further dfs results\\n            base = Math.min(base, special.get(i).get(special.get(i).size() - 1) + dfs(special, i, newNeeds, price));\\n        }\\n        return base;\\n    }\\n\\n    /**\\n     * @param price -> price list\\n     * @param needs -> need list\\n     * @return what if using all single item purchase, what\\'s the base price\\n     */\\n    private int getBase(List<Integer> price, List<Integer> needs) {\\n        int res = 0;\\n        for (int i = 0 ;i < price.size(); i++) res += needs.get(i) * price.get(i);\\n        return res;\\n    }\\n\\n    /**\\n     * @param special -> special offer\\n     * @param needs -> current needs input\\n     * @return if current needs are all zeros, means cannot use any offer, return null.\\n     *         if special offers more than needs, return null.\\n     */\\n    private List<Integer> canUseSpecial(List<Integer> special, List<Integer> needs) {\\n        List<Integer> newNeeds = new ArrayList<>();\\n        boolean needsAllZero = true;\\n        for (int i = 0; i < needs.size(); i++) {\\n            if (special.get(i) > needs.get(i)) return null;\\n            if (needs.get(i) != 0) needsAllZero = false;\\n            newNeeds.add(needs.get(i) - special.get(i));\\n        }\\n        return needsAllZero ? null : newNeeds;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        return dfs(special, 0, needs, price);\\n    }\\n\\n    /**\\n     * @param special -> special offers\\n     * @param specialPosition -> id of special offers\\n     * @param needs -> needs list\\n     * @param price -> price list\\n     * @return min cost to reach target, \\n     *         trying to use id of specialPosition (and all the followings) in special offers, and with current needs.\\n     *         maybe we can add a mem which is a combination of specialPosition and current needs to do a fast return.\\n     */\\n    private int dfs(List<List<Integer>> special, int specialPosition, List<Integer> needs, List<Integer> price) {\\n        // get base price if only purchasing single items\\n        int base = getBase(price, needs);\\n        for (int i = specialPosition; i < special.size(); i++) {\\n            List<Integer> newNeeds = canUseSpecial(special.get(i), needs);\\n            // if somehow cannot use current offer any more, continue\\n            if (newNeeds == null) continue;\\n            // can use current offer, update with further dfs results\\n            base = Math.min(base, special.get(i).get(special.get(i).size() - 1) + dfs(special, i, newNeeds, price));\\n        }\\n        return base;\\n    }\\n\\n    /**\\n     * @param price -> price list\\n     * @param needs -> need list\\n     * @return what if using all single item purchase, what\\'s the base price\\n     */\\n    private int getBase(List<Integer> price, List<Integer> needs) {\\n        int res = 0;\\n        for (int i = 0 ;i < price.size(); i++) res += needs.get(i) * price.get(i);\\n        return res;\\n    }\\n\\n    /**\\n     * @param special -> special offer\\n     * @param needs -> current needs input\\n     * @return if current needs are all zeros, means cannot use any offer, return null.\\n     *         if special offers more than needs, return null.\\n     */\\n    private List<Integer> canUseSpecial(List<Integer> special, List<Integer> needs) {\\n        List<Integer> newNeeds = new ArrayList<>();\\n        boolean needsAllZero = true;\\n        for (int i = 0; i < needs.size(); i++) {\\n            if (special.get(i) > needs.get(i)) return null;\\n            if (needs.get(i) != 0) needsAllZero = false;\\n            newNeeds.add(needs.get(i) - special.get(i));\\n        }\\n        return needsAllZero ? null : newNeeds;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 888324,
                "title": "python3-top-down-dp",
                "content": "\\n```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(*args): \\n            \"\"\"Return the lowest price one has to pay to get items in args.\"\"\"\\n            ans = sum(x*y for x, y in zip(args, price))\\n            for offer in special: \\n                if all(x >= y for x, y in zip(args, offer)):\\n                    ans = min(ans, fn(*(x-y for x, y in zip(args, offer))) + offer[-1])\\n            return ans \\n            \\n        return fn(*needs)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(*args): \\n            \"\"\"Return the lowest price one has to pay to get items in args.\"\"\"\\n            ans = sum(x*y for x, y in zip(args, price))\\n            for offer in special: \\n                if all(x >= y for x, y in zip(args, offer)):\\n                    ans = min(ans, fn(*(x-y for x, y in zip(args, offer))) + offer[-1])\\n            return ans \\n            \\n        return fn(*needs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645013,
                "title": "c-solution-simple-recursive-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    //unordered_map<vector<int>,int>m1;\\n    bool canoffer(vector<int>needs,vector<int>special){\\n        \\n        for(int i=0;i<special.size()-1;i++){\\n            if(special[i]>needs[i])return 0;\\n        }\\n        \\n        return 1;\\n    }\\n    vector<int> naya_needs(vector<int>special,vector<int>needs){\\n        \\n        vector<int>naya;\\n        for(int i=0;i<special.size()-1;i++){\\n            naya.push_back(needs[i]-special[i]);\\n        }\\n        \\n        return naya;\\n        \\n        \\n    }\\n    int offer(vector<int>price, vector<vector<int>>special, vector<int>needs){\\n            \\n       // if(m1.find(needs)!=m1.end())return m1[needs];\\n        \\n        int ans=0;\\n        for(int i=0;i<needs.size();i++){\\n            ans+=(needs[i]*price[i]);\\n        }\\n        \\n        \\n        for(auto i:special){\\n            \\n            int temp=i[i.size()-1];\\n            if(canoffer(needs,i))\\n            {   vector<int>newneeds=naya_needs(i,needs);\\n                ans=min(ans,temp+offer(price,special,newneeds));\\n            }\\n        }\\n       // m1[needs]=ans;\\n        \\n        return ans;\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n    return offer(price,special,needs);\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //unordered_map<vector<int>,int>m1;\\n    bool canoffer(vector<int>needs,vector<int>special){\\n        \\n        for(int i=0;i<special.size()-1;i++){\\n            if(special[i]>needs[i])return 0;\\n        }\\n        \\n        return 1;\\n    }\\n    vector<int> naya_needs(vector<int>special,vector<int>needs){\\n        \\n        vector<int>naya;\\n        for(int i=0;i<special.size()-1;i++){\\n            naya.push_back(needs[i]-special[i]);\\n        }\\n        \\n        return naya;\\n        \\n        \\n    }\\n    int offer(vector<int>price, vector<vector<int>>special, vector<int>needs){\\n            \\n       // if(m1.find(needs)!=m1.end())return m1[needs];\\n        \\n        int ans=0;\\n        for(int i=0;i<needs.size();i++){\\n            ans+=(needs[i]*price[i]);\\n        }\\n        \\n        \\n        for(auto i:special){\\n            \\n            int temp=i[i.size()-1];\\n            if(canoffer(needs,i))\\n            {   vector<int>newneeds=naya_needs(i,needs);\\n                ans=min(ans,temp+offer(price,special,newneeds));\\n            }\\n        }\\n       // m1[needs]=ans;\\n        \\n        return ans;\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n    return offer(price,special,needs);\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538238,
                "title": "c-4ms-98-recursion",
                "content": "C++ with easy-to-read recursion\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) \\n    {\\n        unordered_map<int, int> cache;\\n\\n        return shoppingOffersImp(price, special, needs, cache);\\n    }\\n\\n    int shoppingOffersImp( vector<int>& price, vector<vector<int>>& special, vector<int>& needs, unordered_map<int, int>& cache)\\n    {\\n        int state = needsToState(needs);\\n        if (cache.find(state) != cache.end())return cache[state]; //early return if found result in cache\\n\\n        int minPrice = 0;\\n        for (int i = 0; i < needs.size(); ++i) minPrice += needs[i] * price[i];//directly buy without consider any offer\\n\\n        for (int i = 0; i < special.size(); ++i)\\n        {\\n            if (isOfferUsable(special[i], needs))\\n            {\\n                vector<int> newNeeds = needs;\\n                reduceByOffer(special[i], newNeeds);\\n\\n                int offerPrice = special[i].back();\\n                int pricei = offerPrice + shoppingOffersImp(price, special, newNeeds,cache);\\n\\n                minPrice = min(minPrice, pricei);\\n            }\\n        }\\n\\n        cache[state] = minPrice;\\n\\n        return minPrice;\\n    }\\n\\n    void reduceByOffer(vector<int>& specialOffer, vector<int>& needs)\\n    {\\n        for (int i = 0; i < needs.size(); ++i)\\n            needs[i] -= specialOffer[i];\\n    }\\n\\n    bool isOfferUsable(vector<int>& specialOffer, vector<int>& needs)\\n    {\\n        for (int i = 0; i < needs.size(); ++i)\\n            if (needs[i] < specialOffer[i])\\n                return false;\\n\\n        return true;\\n    }\\n\\n    \\n    //encode the needs into a single int value represents as a state value for easier/faster cache\\n    int needsToState(vector<int>& needs)\\n    {\\n        int r = 0;\\n        int d = 1;\\n\\n        for (int i = 0; i < needs.size(); ++i)\\n        {\\n            r += d*needs[i];\\n            d = d * 10;\\n        }\\n\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) \\n    {\\n        unordered_map<int, int> cache;\\n\\n        return shoppingOffersImp(price, special, needs, cache);\\n    }\\n\\n    int shoppingOffersImp( vector<int>& price, vector<vector<int>>& special, vector<int>& needs, unordered_map<int, int>& cache)\\n    {\\n        int state = needsToState(needs);\\n        if (cache.find(state) != cache.end())return cache[state]; //early return if found result in cache\\n\\n        int minPrice = 0;\\n        for (int i = 0; i < needs.size(); ++i) minPrice += needs[i] * price[i];//directly buy without consider any offer\\n\\n        for (int i = 0; i < special.size(); ++i)\\n        {\\n            if (isOfferUsable(special[i], needs))\\n            {\\n                vector<int> newNeeds = needs;\\n                reduceByOffer(special[i], newNeeds);\\n\\n                int offerPrice = special[i].back();\\n                int pricei = offerPrice + shoppingOffersImp(price, special, newNeeds,cache);\\n\\n                minPrice = min(minPrice, pricei);\\n            }\\n        }\\n\\n        cache[state] = minPrice;\\n\\n        return minPrice;\\n    }\\n\\n    void reduceByOffer(vector<int>& specialOffer, vector<int>& needs)\\n    {\\n        for (int i = 0; i < needs.size(); ++i)\\n            needs[i] -= specialOffer[i];\\n    }\\n\\n    bool isOfferUsable(vector<int>& specialOffer, vector<int>& needs)\\n    {\\n        for (int i = 0; i < needs.size(); ++i)\\n            if (needs[i] < specialOffer[i])\\n                return false;\\n\\n        return true;\\n    }\\n\\n    \\n    //encode the needs into a single int value represents as a state value for easier/faster cache\\n    int needsToState(vector<int>& needs)\\n    {\\n        int r = 0;\\n        int d = 1;\\n\\n        for (int i = 0; i < needs.size(); ++i)\\n        {\\n            r += d*needs[i];\\n            d = d * 10;\\n        }\\n\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502519,
                "title": "c-solution-using-dp-without-recursion",
                "content": "class Solution {\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int a[6]={0};\\n        int p[6]={0};\\n        for(int i=0;i<needs.size();i++){\\n            a[i]=needs[i];\\n        \\n        }\\n        for(int i=0;i<price.size();i++){\\n            p[i]=price[i];\\n           \\n        }\\n        \\n        int mini[a[0]+1][a[1]+1][a[2]+1][a[3]+1][a[4]+1][a[5]+1]={INT_MAX};\\n     \\n        int y[6]={0};\\n        int n1=special[0].size();\\n        int i,i1,i2,i3,i4,i5,pro;\\n         for(i=0;i<=a[0];i++){\\n            for(i1=0;i1<=a[1];i1++){\\n                for(i2=0;i2<=a[2];i2++){\\n                    for(i3=0;i3<=a[3];i3++){\\n                        for(i4=0;i4<=a[4];i4++){\\n                            for(i5=0;i5<=a[5];i5++){\\n                                mini[i][i1][i2][i3][i4][i5]=INT_MAX;\\n                            }}}}}}\\n        for(i=0;i<=a[0];i++){\\n            for(i1=0;i1<=a[1];i1++){\\n                for(i2=0;i2<=a[2];i2++){\\n                    for(i3=0;i3<=a[3];i3++){\\n                        for(i4=0;i4<=a[4];i4++){\\n                            for(i5=0;i5<=a[5];i5++){\\n                                pro=(i*p[0])+(i1*p[1])+(i2*p[2])+(i3*p[3])+(i4*p[4])+(i5*p[5]);\\n                                mini[i][i1][i2][i3][i4][i5]=min(mini[i][i1][i2][i3][i4][i5],pro);\\n                              \\n                                for(int k=0;k<special.size();k++){\\n                                    \\n                                    for(int l=0;l<special[k].size()-1;l++){\\n                                        y[l]=special[k][l];\\n                                                                            }\\n                                    if((i+y[0]<=a[0]) && (i1+y[1]<=a[1]) && (i2+y[2]<=a[2]) && (i3+y[3]<=a[3]) && (i4+y[4]<=a[4]) && (i5+y[5]<=a[5]))\\n                                    {mini[i+y[0]][i1+y[1]][i2+y[2]][i3+y[3]][i4+y[4]][i5+y[5]]=min(mini[i+y[0]][i1+y[1]][i2+y[2]][i3+y[3]][i4+y[4]][i5+y[5]],(mini[i][i1][i2][i3][i4][i5]+special[k][n1-1]));\\n                              \\n                                    }\\n                                }\\n                                \\n                            }\\n                        }\\n                    }\\n                }}}\\n        \\n             \\n        \\n    return mini[a[0]][a[1]][a[2]][a[3]][a[4]][a[5]];}};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int a[6]={0}",
                "codeTag": "Java"
            },
            {
                "id": 487396,
                "title": "rz-top-down-solution-with-memoization-in-python",
                "content": "**Thinking process**\\n1. First question: what is the state in this problem? As we know price and special arrays are fixed and won\\'t change, the only thing changes is \\'needs\\' array, i.e. how many remaining items of each kind for us to buy.\\n2. One reasonable assumption is that for any special offer, its price is lower than buying all the items in it separately. With this observation, each time we are dealing with a \\'needs\\' array, we can first calculate the price to buy everything separately without using any special offer, this price will be the upper bound, then apply all the valid special offers (with the restriction that we cannot buy more than needed) and find the minimum price.\\n3. Apply memoization to accelerate calculations\\n```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        if not price or not special or not needs:\\n            return 0\\n        return self.helper(price, special, needs, {})\\n        \\n    def helper(self, price, special, needs, cache):\\n        needs = tuple(needs)\\n        if needs in cache:\\n            return cache[needs]\\n        \\n        n = len(needs)\\n\\t\\t# calculate the upper bound price by buying everything separately\\n        minPrice = sum(needs[i] * price[i] for i in range(n))\\n        for s in special:\\n\\t\\t    # apply all valid special offers and find the optimal price\\n            if all(s[i] <= needs[i] for i in range(n)):\\n                newNeeds = [needs[i] - s[i] for i in range(n)]\\n                minPrice = min(minPrice, self.helper(price, special, newNeeds, cache) + s[-1])\\n        cache[needs] = minPrice\\n        return minPrice\\n```",
                "solutionTags": [
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        if not price or not special or not needs:\\n            return 0\\n        return self.helper(price, special, needs, {})\\n        \\n    def helper(self, price, special, needs, cache):\\n        needs = tuple(needs)\\n        if needs in cache:\\n            return cache[needs]\\n        \\n        n = len(needs)\\n\\t\\t# calculate the upper bound price by buying everything separately\\n        minPrice = sum(needs[i] * price[i] for i in range(n))\\n        for s in special:\\n\\t\\t    # apply all valid special offers and find the optimal price\\n            if all(s[i] <= needs[i] for i in range(n)):\\n                newNeeds = [needs[i] - s[i] for i in range(n)]\\n                minPrice = min(minPrice, self.helper(price, special, newNeeds, cache) + s[-1])\\n        cache[needs] = minPrice\\n        return minPrice\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446779,
                "title": "javascript-dfs-100",
                "content": "```\\n/**\\n * @param {number[]} price\\n * @param {number[][]} special\\n * @param {number[]} needs\\n * @return {number}\\n */\\nvar shoppingOffers = function(price, special, needs) {\\n    let solve = (left)=>{\\n        let mn = left.reduce((acc,cur,ind)=>acc+(price[ind]*cur),0);/*direct purchase*/\\n        let ar = new Array();/*new needs */\\n        for(let offer of special){/*loop over all offers*/\\n            for(let [ind,unit] of offer.entries()){/*loop over an offer */\\n                if(ind>=left.length)\\n                    break;\\n                if(unit>left[ind]){/*offer is invalid*/\\n                    ar = [];/*empty new - needs*/\\n                    break;/*continue over to next offer*/\\n                }\\n                    \\n                ar.push(left[ind]-unit);/*push new need item*/\\n            }\\n            if(ar.length>0)/*if this offer was valid*/\\n                mn=Math.min(mn,offer[offer.length-1]+solve(ar));/*update min from Recursion on left over needs*/\\n            ar=[];/*empty new needs for next offer*/\\n        }\\n        return mn;/*return result*/\\n    };\\n    return solve(needs);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} price\\n * @param {number[][]} special\\n * @param {number[]} needs\\n * @return {number}\\n */\\nvar shoppingOffers = function(price, special, needs) {\\n    let solve = (left)=>{\\n        let mn = left.reduce((acc,cur,ind)=>acc+(price[ind]*cur),0);/*direct purchase*/\\n        let ar = new Array();/*new needs */\\n        for(let offer of special){/*loop over all offers*/\\n            for(let [ind,unit] of offer.entries()){/*loop over an offer */\\n                if(ind>=left.length)\\n                    break;\\n                if(unit>left[ind]){/*offer is invalid*/\\n                    ar = [];/*empty new - needs*/\\n                    break;/*continue over to next offer*/\\n                }\\n                    \\n                ar.push(left[ind]-unit);/*push new need item*/\\n            }\\n            if(ar.length>0)/*if this offer was valid*/\\n                mn=Math.min(mn,offer[offer.length-1]+solve(ar));/*update min from Recursion on left over needs*/\\n            ar=[];/*empty new needs for next offer*/\\n        }\\n        return mn;/*return result*/\\n    };\\n    return solve(needs);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 355503,
                "title": "concise-c-solution-dfs",
                "content": "```\\nint shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int res = inner_product(price.begin(), price.end(), needs.begin(), 0);\\n        auto src = needs;\\n        for(auto &s : special){\\n            int idx = 0;\\n            for(auto &n : needs)\\n                if((n -= s[idx++]) < 0)\\n                    break;\\n            if(needs[idx-1] >= 0)\\n                res = min(res, shoppingOffers(price, special, needs) + s.back());\\n            needs = src;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int res = inner_product(price.begin(), price.end(), needs.begin(), 0);\\n        auto src = needs;\\n        for(auto &s : special){\\n            int idx = 0;\\n            for(auto &n : needs)\\n                if((n -= s[idx++]) < 0)\\n                    break;\\n            if(needs[idx-1] >= 0)\\n                res = min(res, shoppingOffers(price, special, needs) + s.back());\\n            needs = src;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 277466,
                "title": "python-dfs-memo",
                "content": "We are not allowed to buy more items than you want. Thus the high level idea is that we maintain a ```needs``` array and use DFS to keep reducing ```needs``` unit (either from unit sale or special offer) and updating the minimal cost. Once any shopping unit\\'s need is lower than supply, we end current search path.\\nAs we can get a minimal cost for current ```needs```, we can use memoization to avoid repeat path search.\\n```\\ndef shoppingOffers(price, special, needs):\\n\\tmemo = {}\\n\\tdef dfs(needs):\\n\\t\\tif tuple(needs) not in memo:\\n\\t\\t\\tcost = sum(n*p for n,p in zip(needs, price))\\n\\t\\t\\tfor s in special:\\n\\t\\t\\t\\tleft = []\\n\\t\\t\\t\\tfor i, n in enumerate(needs):\\n\\t\\t\\t\\t\\tif n < s[i]: break\\n\\t\\t\\t\\t\\tleft.append(n-s[i])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcost = min(cost, memo.get(tuple(left), dfs(left)) + s[-1])\\n\\t\\t\\tmemo[tuple(needs)] = cost\\n\\t\\treturn memo[tuple(needs)]\\n\\treturn dfs(needs)\\n```",
                "solutionTags": [],
                "code": "```needs```\n```needs```\n```needs```\n```\\ndef shoppingOffers(price, special, needs):\\n\\tmemo = {}\\n\\tdef dfs(needs):\\n\\t\\tif tuple(needs) not in memo:\\n\\t\\t\\tcost = sum(n*p for n,p in zip(needs, price))\\n\\t\\t\\tfor s in special:\\n\\t\\t\\t\\tleft = []\\n\\t\\t\\t\\tfor i, n in enumerate(needs):\\n\\t\\t\\t\\t\\tif n < s[i]: break\\n\\t\\t\\t\\t\\tleft.append(n-s[i])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcost = min(cost, memo.get(tuple(left), dfs(left)) + s[-1])\\n\\t\\t\\tmemo[tuple(needs)] = cost\\n\\t\\treturn memo[tuple(needs)]\\n\\treturn dfs(needs)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 164902,
                "title": "c-concise-dfs-solution-with-comments",
                "content": "```\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return dfs(price, special, needs, 0);\\n    }\\n\\nprivate:\\n    int dfs(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int path_cost)\\n    {\\n        if (std::any_of(needs.begin(), needs.end(), [](const auto& n) { return n < 0; }))\\n        {\\n            return std::numeric_limits<int>::max(); // backtracking, if need for an item is negative, return\\n        }\\n        int cost = std::inner_product(price.begin(), price.end(), needs.begin(), 0) + path_cost;\\n        for (const auto& offer : special)\\n        {\\n            std::transform(needs.begin(), needs.end(), offer.begin(), needs.begin(), std::minus<int>());\\n            cost = std::min(cost, dfs(price, special, needs, path_cost + offer.back())); // check for a better choice\\n            std::transform(needs.begin(), needs.end(), offer.begin(), needs.begin(), std::plus<int>()); // recover calling stack\\n        }\\n        return cost;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return dfs(price, special, needs, 0);\\n    }\\n\\nprivate:\\n    int dfs(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int path_cost)\\n    {\\n        if (std::any_of(needs.begin(), needs.end(), [](const auto& n) { return n < 0; }))\\n        {\\n            return std::numeric_limits<int>::max(); // backtracking, if need for an item is negative, return\\n        }\\n        int cost = std::inner_product(price.begin(), price.end(), needs.begin(), 0) + path_cost;\\n        for (const auto& offer : special)\\n        {\\n            std::transform(needs.begin(), needs.end(), offer.begin(), needs.begin(), std::minus<int>());\\n            cost = std::min(cost, dfs(price, special, needs, path_cost + offer.back())); // check for a better choice\\n            std::transform(needs.begin(), needs.end(), offer.begin(), needs.begin(), std::plus<int>()); // recover calling stack\\n        }\\n        return cost;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 156286,
                "title": "c-elegant-knapsack-dp-but-tle-so-sad-life-is-so-hard",
                "content": "```\\n#include <vector>\\n#include <limits>\\n#include <numeric>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nconst int INF = numeric_limits<int>::max();\\nconst int MAX_N = 106;\\n\\nint dp[MAX_N + 1][117649];\\n\\nclass Solution {\\nprivate:\\n    int encode(vector<int>& needs) {\\n        int res = 0;\\n        for (int num : needs) {\\n            res = res * 7 + num;\\n        }\\n        return res;\\n    }\\n    int minPrice(vector<vector<int>>& offers, int n, vector<int>& needs, int tot) {\\n        if (tot == 0) {\\n            return 0;\\n        }\\n\\n        if (n == 0) {\\n            return INF;\\n        }\\n\\n        int key = encode(needs);\\n        if (dp[n][key] != -1) {\\n            return dp[n][key];\\n        }\\n\\n        int res1 = minPrice(offers, n - 1, needs, tot);\\n        int res2 = INF;\\n\\n        bool possible = true;\\n        int items = needs.size();\\n        for (int i = 0; i < items; ++i) {\\n            if (offers[n - 1][i] > needs[i]) {\\n                possible = false;\\n                break;\\n            }\\n        }\\n\\n        if (possible) {\\n            for (int i = 0; i < items; ++i) {\\n                needs[i] -= offers[n - 1][i];\\n                tot -= offers[n - 1][i];\\n            }\\n            res2 = minPrice(offers, n, needs, tot);\\n            if (res2 != INF) {\\n                res2 += offers[n - 1][items];\\n            }\\n            for (int i = 0; i < items; ++i) {\\n                needs[i] += offers[n - 1][i];\\n                tot += offers[n - 1][i];\\n            }\\n        }\\n\\n        int res = min(res1, res2);\\n        dp[n][key] = res;\\n        return res;\\n    }\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int n = price.size();\\n        for (int i = 0; i < n; ++i) {\\n            vector<int> offer(n + 1, 0);\\n            offer[i] = 1;\\n            offer[n] = price[i];\\n            special.push_back(offer);\\n        }\\n\\n        int maxK = encode(needs);\\n\\n        int numOffer = special.size();\\n        for (int i = 0; i <= numOffer; ++i) {\\n            fill(dp[i], dp[i] + maxK, -1);\\n        }\\n        int tot = accumulate(needs.begin(), needs.end(), 0);\\n        return minPrice(special, numOffer, needs, tot);\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <limits>\\n#include <numeric>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nconst int INF = numeric_limits<int>::max();\\nconst int MAX_N = 106;\\n\\nint dp[MAX_N + 1][117649];\\n\\nclass Solution {\\nprivate:\\n    int encode(vector<int>& needs) {\\n        int res = 0;\\n        for (int num : needs) {\\n            res = res * 7 + num;\\n        }\\n        return res;\\n    }\\n    int minPrice(vector<vector<int>>& offers, int n, vector<int>& needs, int tot) {\\n        if (tot == 0) {\\n            return 0;\\n        }\\n\\n        if (n == 0) {\\n            return INF;\\n        }\\n\\n        int key = encode(needs);\\n        if (dp[n][key] != -1) {\\n            return dp[n][key];\\n        }\\n\\n        int res1 = minPrice(offers, n - 1, needs, tot);\\n        int res2 = INF;\\n\\n        bool possible = true;\\n        int items = needs.size();\\n        for (int i = 0; i < items; ++i) {\\n            if (offers[n - 1][i] > needs[i]) {\\n                possible = false;\\n                break;\\n            }\\n        }\\n\\n        if (possible) {\\n            for (int i = 0; i < items; ++i) {\\n                needs[i] -= offers[n - 1][i];\\n                tot -= offers[n - 1][i];\\n            }\\n            res2 = minPrice(offers, n, needs, tot);\\n            if (res2 != INF) {\\n                res2 += offers[n - 1][items];\\n            }\\n            for (int i = 0; i < items; ++i) {\\n                needs[i] += offers[n - 1][i];\\n                tot += offers[n - 1][i];\\n            }\\n        }\\n\\n        int res = min(res1, res2);\\n        dp[n][key] = res;\\n        return res;\\n    }\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int n = price.size();\\n        for (int i = 0; i < n; ++i) {\\n            vector<int> offer(n + 1, 0);\\n            offer[i] = 1;\\n            offer[n] = price[i];\\n            special.push_back(offer);\\n        }\\n\\n        int maxK = encode(needs);\\n\\n        int numOffer = special.size();\\n        for (int i = 0; i <= numOffer; ++i) {\\n            fill(dp[i], dp[i] + maxK, -1);\\n        }\\n        int tot = accumulate(needs.begin(), needs.end(), 0);\\n        return minPrice(special, numOffer, needs, tot);\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 105223,
                "title": "python-recursion-with-detailed-comments",
                "content": "This problem is similar to the complete knapsack problem. However, even a simple recursion with not dynamic programming can be accepted, as follows. The key is: for each special offer, we can choose to buy or not buy it. Even we have determined to buy it, we can still buy it again since one offer can be bought multiple times.  Then, the following recursion turns out. \\n```\\nclass Solution:\\n    def shoppingOffers(self, price, special, needs):\\n        \"\"\"\\n        :type price: List[int]\\n        :type special: List[List[int]]\\n        :type needs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not needs:\\n            return 0\\n        self.special = special\\n        self.price = price\\n        return self.lowestPrice(0, needs)\\n        \\n    def lowestPrice(self, i, needs):\\n        \"\"\"\\n        The lowest price to buy exact needs from the [i, end) specials and normal items\\n        \"\"\"\\n        # base case: all the specials have been exhausted and we can only buy normal ones\\n        if i == len(self.special):\\n            return sum(n * p for n, p in zip(needs, self.price))\\n        # can we buy the i special?\\n        ispecial = self.special[i]\\n        for j in range(len(needs)):\\n            if ispecial[j] > needs[j]: # cannot\\n                return self.lowestPrice(i + 1, needs)\\n        # we can buy, but whether to buy it? Choose the min.\\n        needs_after_buy = [n - s for n, s in zip(needs, ispecial)]\\n        buy_price = ispecial[-1] + self.lowestPrice(i, needs_after_buy) # we can buy multiple times\\n        not_buy_price = self.lowestPrice(i + 1, needs)\\n        return min(buy_price, not_buy_price)",
                "solutionTags": [],
                "code": "This problem is similar to the complete knapsack problem. However, even a simple recursion with not dynamic programming can be accepted, as follows. The key is: for each special offer, we can choose to buy or not buy it. Even we have determined to buy it, we can still buy it again since one offer can be bought multiple times.  Then, the following recursion turns out. \\n```\\nclass Solution:\\n    def shoppingOffers(self, price, special, needs):\\n        \"\"\"\\n        :type price: List[int]\\n        :type special: List[List[int]]\\n        :type needs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not needs:\\n            return 0\\n        self.special = special\\n        self.price = price\\n        return self.lowestPrice(0, needs)\\n        \\n    def lowestPrice(self, i, needs):\\n        \"\"\"\\n        The lowest price to buy exact needs from the [i, end) specials and normal items\\n        \"\"\"\\n        # base case: all the specials have been exhausted and we can only buy normal ones\\n        if i == len(self.special):\\n            return sum(n * p for n, p in zip(needs, self.price))\\n        # can we buy the i special?\\n        ispecial = self.special[i]\\n        for j in range(len(needs)):\\n            if ispecial[j] > needs[j]: # cannot\\n                return self.lowestPrice(i + 1, needs)\\n        # we can buy, but whether to buy it? Choose the min.\\n        needs_after_buy = [n - s for n, s in zip(needs, ispecial)]\\n        buy_price = ispecial[-1] + self.lowestPrice(i, needs_after_buy) # we can buy multiple times\\n        not_buy_price = self.lowestPrice(i + 1, needs)\\n        return min(buy_price, not_buy_price)",
                "codeTag": "Java"
            },
            {
                "id": 105235,
                "title": "java-8-recursion-with-cache-very-short-solution",
                "content": "The idea behind the recursion is :\\n - at every stage, return the lowest of the two choices of including this special offer and excluding this special offer.\\n- use a cache to store the intermediate results\\n```\\npublic static int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int index, Map<String, Integer> map) {\\n        int lowest = Integer.MAX_VALUE;\\n        if(needs.stream().allMatch(x -> x == 0)) return 0;\\n        String key = needs.stream().map(x -> \"\"+x).collect(Collectors.joining(\" \"));\\n        if(map.containsKey(key)) return map.get(key);\\n\\n        if(index == special.size()) {\\n            return IntStream.range(0, needs.size()).map(i -> needs.get(i) * price.get(i)).sum();\\n        }\\n        List<Integer> updatedNeeds = IntStream.range(0, needs.size()).mapToObj(i -> needs.get(i) - special.get(index).get(i)).collect(Collectors.toList());\\n        if(updatedNeeds.stream().allMatch(x -> x >= 0) ){\\n            lowest = Math.min(lowest, special.get(index).get(special.get(index).size() - 1) + shoppingOffers(price, special, updatedNeeds, index, map));\\n        }\\n        return Math.min(lowest, shoppingOffers(price, special, needs, index + 1, map));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int index, Map<String, Integer> map) {\\n        int lowest = Integer.MAX_VALUE;\\n        if(needs.stream().allMatch(x -> x == 0)) return 0;\\n        String key = needs.stream().map(x -> \"\"+x).collect(Collectors.joining(\" \"));\\n        if(map.containsKey(key)) return map.get(key);\\n\\n        if(index == special.size()) {\\n            return IntStream.range(0, needs.size()).map(i -> needs.get(i) * price.get(i)).sum();\\n        }\\n        List<Integer> updatedNeeds = IntStream.range(0, needs.size()).mapToObj(i -> needs.get(i) - special.get(index).get(i)).collect(Collectors.toList());\\n        if(updatedNeeds.stream().allMatch(x -> x >= 0) ){\\n            lowest = Math.min(lowest, special.get(index).get(special.get(index).size() - 1) + shoppingOffers(price, special, updatedNeeds, index, map));\\n        }\\n        return Math.min(lowest, shoppingOffers(price, special, needs, index + 1, map));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 105241,
                "title": "java-code-using-dfs-with-memorization",
                "content": "```\\npublic class Solution {\\n    List<Integer> a,c;\\n    List<List<Integer>> b;\\n    int n,m;\\n    Map<Integer,Integer> map=new HashMap<>();\\n    int hashc(List<Integer> a) //Hashcode for the needs list (we turn an state array to an integer)\\n    {\\n        int num=0;\\n        for (int i=0;i<a.size();i++) num=num*10+a.get(i);\\n        return num;\\n    }\\n    int dfs(List<Integer> c)\\n    {\\n        for (int i=0;i<n;i++) // needs<0 is illegal\\n            if (c.get(i)<0) return 10000000;\\n        int ha=hashc(c);\\n        if (map.containsKey(ha)) return map.get(ha); // If we have dealt with this state before, just use our previous result (to avoid repetitive computation)\\n        int ans=0;\\n        for (int i=0;i<n;i++) ans+=c.get(i)*a.get(i); // buy all goods one by one\\n        for (int i=0;i<m;i++) //use each offer\\n        {\\n            List<Integer> now=b.get(i);\\n            int price=now.get(n);\\n            for (int j=0;j<n;j++) c.set(j,c.get(j)-now.get(j));\\n            ans=Math.min(ans,price+dfs(c));\\n            for (int j=0;j<n;j++) c.set(j,c.get(j)+now.get(j));\\n        }\\n        map.put(ha,ans); //Store the result for this state\\n        return ans;\\n    }\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        a=price;\\n        b=special;\\n        n=price.size();\\n        m=special.size();\\n        return dfs(needs);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    List<Integer> a,c;\\n    List<List<Integer>> b;\\n    int n,m;\\n    Map<Integer,Integer> map=new HashMap<>();\\n    int hashc(List<Integer> a) //Hashcode for the needs list (we turn an state array to an integer)\\n    {\\n        int num=0;\\n        for (int i=0;i<a.size();i++) num=num*10+a.get(i);\\n        return num;\\n    }\\n    int dfs(List<Integer> c)\\n    {\\n        for (int i=0;i<n;i++) // needs<0 is illegal\\n            if (c.get(i)<0) return 10000000;\\n        int ha=hashc(c);\\n        if (map.containsKey(ha)) return map.get(ha); // If we have dealt with this state before, just use our previous result (to avoid repetitive computation)\\n        int ans=0;\\n        for (int i=0;i<n;i++) ans+=c.get(i)*a.get(i); // buy all goods one by one\\n        for (int i=0;i<m;i++) //use each offer\\n        {\\n            List<Integer> now=b.get(i);\\n            int price=now.get(n);\\n            for (int j=0;j<n;j++) c.set(j,c.get(j)-now.get(j));\\n            ans=Math.min(ans,price+dfs(c));\\n            for (int j=0;j<n;j++) c.set(j,c.get(j)+now.get(j));\\n        }\\n        map.put(ha,ans); //Store the result for this state\\n        return ans;\\n    }\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        a=price;\\n        b=special;\\n        n=price.size();\\n        m=special.size();\\n        return dfs(needs);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105249,
                "title": "python-dfs-solution",
                "content": "Just recursively try every possible combination.\\nCompare how much it costs among retail price (no offer) and using each offer.\\nTerminate when\\n(1) The condition met: return accumulated value\\n(2) The condition violated: not an option, hence infinity\\n```\\ndef shoppingOffers(self, price, special, needs):\\n        def dfs(remain, acc):\\n            if all(x == 0 for x in remain):\\n                return acc\\n            elif any(x < 0 for x in remain):\\n                return float('inf')\\n            ans = sum(map(lambda x, y: x*y, remain, price))\\n            for spc in special:\\n                ans = min(ans, dfs(map(lambda x, y: x-y, remain, spc[:-1]), spc[-1]))                \\n            return ans+acc\\n        return dfs(needs, 0)\\n```",
                "solutionTags": [],
                "code": "```\\ndef shoppingOffers(self, price, special, needs):\\n        def dfs(remain, acc):\\n            if all(x == 0 for x in remain):\\n                return acc\\n            elif any(x < 0 for x in remain):\\n                return float('inf')\\n            ans = sum(map(lambda x, y: x*y, remain, price))\\n            for spc in special:\\n                ans = min(ans, dfs(map(lambda x, y: x-y, remain, spc[:-1]), spc[-1]))                \\n            return ans+acc\\n        return dfs(needs, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4102672,
                "title": "simple-recursion-unbounded-knapsack-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    \\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        solve(0, price, special, needs, 0);\\n        return min;\\n    }\\n    \\n    public void solve(int idx, List<Integer> price, List<List<Integer>> special, List<Integer> needs, int bought) {\\n        if (isFulfilled(needs)) {\\n            min = Math.min(min, bought);\\n            return;\\n        }\\n        if (idx >= special.size()) {\\n            //if we didnt use any special offers the we buy them individually \\n            int total = bought;\\n            for (int i = 0; i < needs.size(); i++) {\\n                total += needs.get(i) * price.get(i);\\n            }\\n            min = Math.min(min, total);\\n            return;\\n        }\\n        \\n        //Skip the current special offer.\\n        solve(idx + 1, price, special, needs, bought);\\n        \\n        //Try to buy the current special offer.\\n        if (canBuy(needs, special.get(idx))) {\\n            List<Integer> newNeeds = buyProduct(needs, special.get(idx));\\n            solve(idx, price, special, newNeeds, bought + special.get(idx).get(needs.size()));\\n        }\\n    }\\n    \\n    public boolean isFulfilled(List<Integer> needs) {\\n        for (int need : needs) {\\n            if (need != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public boolean canBuy(List<Integer> needs, List<Integer> offer) {\\n        for (int i = 0; i < needs.size(); i++) {\\n            if (needs.get(i) < offer.get(i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public List<Integer> buyProduct(List<Integer> needs, List<Integer> offer) {\\n        List<Integer> newNeeds = new ArrayList<>(needs);\\n        for (int i = 0; i < needs.size(); i++) {\\n            newNeeds.set(i, needs.get(i) - offer.get(i));\\n        }\\n        return newNeeds;\\n    }\\n}\\n\\n```\\n\\n# PLEASE  UPVOTE :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    \\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        solve(0, price, special, needs, 0);\\n        return min;\\n    }\\n    \\n    public void solve(int idx, List<Integer> price, List<List<Integer>> special, List<Integer> needs, int bought) {\\n        if (isFulfilled(needs)) {\\n            min = Math.min(min, bought);\\n            return;\\n        }\\n        if (idx >= special.size()) {\\n            //if we didnt use any special offers the we buy them individually \\n            int total = bought;\\n            for (int i = 0; i < needs.size(); i++) {\\n                total += needs.get(i) * price.get(i);\\n            }\\n            min = Math.min(min, total);\\n            return;\\n        }\\n        \\n        //Skip the current special offer.\\n        solve(idx + 1, price, special, needs, bought);\\n        \\n        //Try to buy the current special offer.\\n        if (canBuy(needs, special.get(idx))) {\\n            List<Integer> newNeeds = buyProduct(needs, special.get(idx));\\n            solve(idx, price, special, newNeeds, bought + special.get(idx).get(needs.size()));\\n        }\\n    }\\n    \\n    public boolean isFulfilled(List<Integer> needs) {\\n        for (int need : needs) {\\n            if (need != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public boolean canBuy(List<Integer> needs, List<Integer> offer) {\\n        for (int i = 0; i < needs.size(); i++) {\\n            if (needs.get(i) < offer.get(i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public List<Integer> buyProduct(List<Integer> needs, List<Integer> offer) {\\n        List<Integer> newNeeds = new ArrayList<>(needs);\\n        for (int i = 0; i < needs.size(); i++) {\\n            newNeeds.set(i, needs.get(i) - offer.get(i));\\n        }\\n        return newNeeds;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975698,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int n, m;\\n    int solve(vector<int>& price, vector<vector<int>>& special, \\n        vector<int>& needs, int i) {\\n        // base case\\n        if(i == m) {\\n            int ret = 0;\\n            for(int i = 0; i < n; i++) {\\n                ret += needs[i] * price[i];\\n            }\\n            return ret;\\n        }\\n        // calling recursion\\n        bool flag = true;\\n        for(int j = 0; j < n; j++) {\\n            if(needs[j] < special[i][j]) {\\n                flag = false;\\n                break;\\n            }\\n        }\\n        int op1 = INT_MAX;\\n        if(flag) {\\n            // if can take curr offer\\n            for(int j = 0; j < n; j++) {\\n                needs[j] -= special[i][j];\\n            }\\n            op1 = special[i][n] + solve(price, special, needs, i);\\n            for(int j = 0; j < n; j++) {\\n                needs[j] += special[i][j];\\n            }\\n        }\\n        int op2 = solve(price, special, needs, i + 1);\\n        return min(op2, op1);\\n    }\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, \\n        vector<int>& needs) {\\n        // using backtracking\\n        n = price.size();\\n        m = special.size();\\n        int ans = solve(price, special, needs, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n, m;\\n    int solve(vector<int>& price, vector<vector<int>>& special, \\n        vector<int>& needs, int i) {\\n        // base case\\n        if(i == m) {\\n            int ret = 0;\\n            for(int i = 0; i < n; i++) {\\n                ret += needs[i] * price[i];\\n            }\\n            return ret;\\n        }\\n        // calling recursion\\n        bool flag = true;\\n        for(int j = 0; j < n; j++) {\\n            if(needs[j] < special[i][j]) {\\n                flag = false;\\n                break;\\n            }\\n        }\\n        int op1 = INT_MAX;\\n        if(flag) {\\n            // if can take curr offer\\n            for(int j = 0; j < n; j++) {\\n                needs[j] -= special[i][j];\\n            }\\n            op1 = special[i][n] + solve(price, special, needs, i);\\n            for(int j = 0; j < n; j++) {\\n                needs[j] += special[i][j];\\n            }\\n        }\\n        int op2 = solve(price, special, needs, i + 1);\\n        return min(op2, op1);\\n    }\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, \\n        vector<int>& needs) {\\n        // using backtracking\\n        n = price.size();\\n        m = special.size();\\n        int ans = solve(price, special, needs, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788490,
                "title": "easy-implementation-using-concept-of-unbounded-knapsack-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int idx, int n){\\n        if(idx == special.size()){\\n            int temp = 0;\\n            for(int i=0; i<n; i++){\\n                temp += (needs[i] * price[i]);\\n            }\\n            return temp;\\n        }\\n\\n        int flag = 0;\\n        for(int i=0; i<n; i++){\\n            if(special[idx][i] > needs[i]) flag = 1;\\n        }\\n\\n\\n        if(flag == 0){\\n            for(int i=0; i<n; i++){\\n                needs[i] -= special[idx][i];\\n            }\\n            int consider = special[idx][n] + solve(price, special,needs,idx,n);\\n            for(int i=0; i<n; i++){\\n                needs[i] += special[idx][i];\\n            }\\n            return min(consider, solve(price, special,needs,idx+1,n));\\n        }\\n\\n        return solve(price, special,needs,idx+1,n);;\\n    }\\n\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int n = price.size();\\n        int ans = solve(price,special,needs,0,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int idx, int n){\\n        if(idx == special.size()){\\n            int temp = 0;\\n            for(int i=0; i<n; i++){\\n                temp += (needs[i] * price[i]);\\n            }\\n            return temp;\\n        }\\n\\n        int flag = 0;\\n        for(int i=0; i<n; i++){\\n            if(special[idx][i] > needs[i]) flag = 1;\\n        }\\n\\n\\n        if(flag == 0){\\n            for(int i=0; i<n; i++){\\n                needs[i] -= special[idx][i];\\n            }\\n            int consider = special[idx][n] + solve(price, special,needs,idx,n);\\n            for(int i=0; i<n; i++){\\n                needs[i] += special[idx][i];\\n            }\\n            return min(consider, solve(price, special,needs,idx+1,n));\\n        }\\n\\n        return solve(price, special,needs,idx+1,n);;\\n    }\\n\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int n = price.size();\\n        int ans = solve(price,special,needs,0,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418035,
                "title": "solution",
                "content": "```C++ []\\nbool operator >= (const vector<int>& a, const vector<int>& b)\\n{\\n    for (int i = 0; i < a.size(); ++i)\\n    {\\n        if (a[i] < b[i]) return false;\\n    }\\n    return true;\\n}\\nint operator* (const vector<int>& a, const vector<int>& b)\\n{\\n    int res = 0;\\n    for (int i = 0; i < a.size(); ++i)\\n    {\\n        res += a[i] * b[i];\\n    }\\n    return res;\\n}\\nvoid operator-= (vector<int>& a, vector<int>& b)\\n{\\n    for (int i = 0; i < a.size(); ++i)\\n    {\\n        a[i] -= b[i];\\n    }\\n}\\nvoid operator += (vector<int>& a, vector<int>& b)\\n{\\n    for (int i = 0; i < a.size(); ++i)\\n    {\\n        a[i] += b[i];\\n    }\\n}\\nclass Solution123 {\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int cost = needs * price;\\n        for (auto s : special)\\n        {\\n            if (cost < s.back()) continue;\\n            if (needs > s)\\n            {\\n                needs -= s;\\n                cost = min(cost, s.back() + shoppingOffers(price, special, needs));\\n                needs += s;\\n            }\\n        }\\n        return cost;\\n    }\\n};\\nclass Solution {\\npublic:\\n    unordered_map<string, int> m;\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        string s;\\n        for (int i : needs)\\n        {\\n            s.append(1, i);\\n        }\\n        if (m.count(s)) \\n            return m[s];\\n\\n        int cost = needs * price;\\n\\n        for (auto& spe : special) {\\n            if (spe.back() > cost) continue;\\n            if (needs >= spe) {\\n                needs -= spe;\\n                cost = min(cost, spe.back() + shoppingOffers(price, special, needs));\\n                needs += spe;\\n            }\\n        }\\n        m[s] = cost;\\n        return cost;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def shoppingOffers(\\n        self, price: List[int], special: List[List[int]], needs: List[int]\\n    ) -> int:\\n        def _impl(current_needs, dp_table):\\n            if current_needs in dp_table:\\n                return dp_table[current_needs]\\n            length = len(price)\\n            min_price = float(\"inf\")\\n            for spec in special:\\n                can_use = True\\n                for i in range(length):\\n                    if spec[i] > current_needs[i]:\\n                        can_use = False\\n                        break\\n                if can_use:\\n                    current_price = spec[-1] + _impl(\\n                        tuple([need - consume for consume, need in zip(spec, current_needs)]),\\n                        dp_table\\n                    )\\n                    if current_price < min_price:\\n                        min_price = current_price\\n            if not math.isinf(min_price):\\n                dp_table[current_needs] = min_price\\n                return min_price\\n            current_price = 0\\n            for i, n in enumerate(current_needs):\\n                current_price += n * price[i]\\n            dp_table[current_needs] = current_price\\n            return current_price\\n        length = len(price)\\n        useful_special = []\\n        for spec in special:\\n            current = 0\\n            for i in range(length):\\n                current += price[i] * spec[i]\\n            if current > spec[-1]:\\n                useful_special.append(spec)\\n        special = useful_special\\n        return _impl(tuple(needs), {})\\n```\\n\\n```Java []\\nclass Solution {\\n    int minPrice;\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        minPrice=directlyBuy(price,needs);\\n        help(price,special,needs,0,0);\\n        return minPrice;\\n    }\\n    private int directlyBuy(List<Integer> price,List<Integer> needs){\\n        int total=0;\\n        int n=needs.size();\\n        for(int i=0;i<n;i++){\\n            total+=price.get(i)*needs.get(i);\\n        }\\n        return total;\\n    }\\n    private boolean canUse(List<Integer> offer,List<Integer> needs){\\n        int n=needs.size();\\n        for(int i=0;i<n;i++){\\n            if(offer.get(i)>needs.get(i))return false;\\n        }\\n        return true;\\n    }\\n    private void help(List<Integer> price,List<List<Integer>> special,List<Integer> needs,int used,int index){\\n        if(used>=minPrice)return;\\n        if(index==special.size()){\\n            used+=directlyBuy(price,needs);\\n            if(used<minPrice){\\n                minPrice=used;\\n            }\\n            return;\\n        }\\n        List<Integer> offer=special.get(index);\\n        if(canUse(offer,needs)){\\n            int n=needs.size();\\n            List<Integer> updatedNeeds=new ArrayList<>();\\n            for(int i=0;i<n;i++){\\n                updatedNeeds.add(needs.get(i)-offer.get(i));\\n            }\\n            help(price,special,updatedNeeds,used+offer.get(n),index);\\n        }\\n        help(price,special,needs,used,index+1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nbool operator >= (const vector<int>& a, const vector<int>& b)\\n{\\n    for (int i = 0; i < a.size(); ++i)\\n    {\\n        if (a[i] < b[i]) return false;\\n    }\\n    return true;\\n}\\nint operator* (const vector<int>& a, const vector<int>& b)\\n{\\n    int res = 0;\\n    for (int i = 0; i < a.size(); ++i)\\n    {\\n        res += a[i] * b[i];\\n    }\\n    return res;\\n}\\nvoid operator-= (vector<int>& a, vector<int>& b)\\n{\\n    for (int i = 0; i < a.size(); ++i)\\n    {\\n        a[i] -= b[i];\\n    }\\n}\\nvoid operator += (vector<int>& a, vector<int>& b)\\n{\\n    for (int i = 0; i < a.size(); ++i)\\n    {\\n        a[i] += b[i];\\n    }\\n}\\nclass Solution123 {\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int cost = needs * price;\\n        for (auto s : special)\\n        {\\n            if (cost < s.back()) continue;\\n            if (needs > s)\\n            {\\n                needs -= s;\\n                cost = min(cost, s.back() + shoppingOffers(price, special, needs));\\n                needs += s;\\n            }\\n        }\\n        return cost;\\n    }\\n};\\nclass Solution {\\npublic:\\n    unordered_map<string, int> m;\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        string s;\\n        for (int i : needs)\\n        {\\n            s.append(1, i);\\n        }\\n        if (m.count(s)) \\n            return m[s];\\n\\n        int cost = needs * price;\\n\\n        for (auto& spe : special) {\\n            if (spe.back() > cost) continue;\\n            if (needs >= spe) {\\n                needs -= spe;\\n                cost = min(cost, spe.back() + shoppingOffers(price, special, needs));\\n                needs += spe;\\n            }\\n        }\\n        m[s] = cost;\\n        return cost;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def shoppingOffers(\\n        self, price: List[int], special: List[List[int]], needs: List[int]\\n    ) -> int:\\n        def _impl(current_needs, dp_table):\\n            if current_needs in dp_table:\\n                return dp_table[current_needs]\\n            length = len(price)\\n            min_price = float(\"inf\")\\n            for spec in special:\\n                can_use = True\\n                for i in range(length):\\n                    if spec[i] > current_needs[i]:\\n                        can_use = False\\n                        break\\n                if can_use:\\n                    current_price = spec[-1] + _impl(\\n                        tuple([need - consume for consume, need in zip(spec, current_needs)]),\\n                        dp_table\\n                    )\\n                    if current_price < min_price:\\n                        min_price = current_price\\n            if not math.isinf(min_price):\\n                dp_table[current_needs] = min_price\\n                return min_price\\n            current_price = 0\\n            for i, n in enumerate(current_needs):\\n                current_price += n * price[i]\\n            dp_table[current_needs] = current_price\\n            return current_price\\n        length = len(price)\\n        useful_special = []\\n        for spec in special:\\n            current = 0\\n            for i in range(length):\\n                current += price[i] * spec[i]\\n            if current > spec[-1]:\\n                useful_special.append(spec)\\n        special = useful_special\\n        return _impl(tuple(needs), {})\\n```\n```Java []\\nclass Solution {\\n    int minPrice;\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        minPrice=directlyBuy(price,needs);\\n        help(price,special,needs,0,0);\\n        return minPrice;\\n    }\\n    private int directlyBuy(List<Integer> price,List<Integer> needs){\\n        int total=0;\\n        int n=needs.size();\\n        for(int i=0;i<n;i++){\\n            total+=price.get(i)*needs.get(i);\\n        }\\n        return total;\\n    }\\n    private boolean canUse(List<Integer> offer,List<Integer> needs){\\n        int n=needs.size();\\n        for(int i=0;i<n;i++){\\n            if(offer.get(i)>needs.get(i))return false;\\n        }\\n        return true;\\n    }\\n    private void help(List<Integer> price,List<List<Integer>> special,List<Integer> needs,int used,int index){\\n        if(used>=minPrice)return;\\n        if(index==special.size()){\\n            used+=directlyBuy(price,needs);\\n            if(used<minPrice){\\n                minPrice=used;\\n            }\\n            return;\\n        }\\n        List<Integer> offer=special.get(index);\\n        if(canUse(offer,needs)){\\n            int n=needs.size();\\n            List<Integer> updatedNeeds=new ArrayList<>();\\n            for(int i=0;i<n;i++){\\n                updatedNeeds.add(needs.get(i)-offer.get(i));\\n            }\\n            help(price,special,updatedNeeds,used+offer.get(n),index);\\n        }\\n        help(price,special,needs,used,index+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304922,
                "title": "java-solution-recursive-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n       return help(price,special,needs,0); \\n    }\\n    public int help(List<Integer> price, List<List<Integer>> special, List<Integer> needs,int start){\\n        int sum = 0;\\n        for(int i=0;i<needs.size();i++){\\n            sum = sum + needs.get(i) * price.get(i);\\n        }\\n        for(int i=start;i<special.size();i++){\\n            List<Integer> list = special.get(i);\\n            List<Integer> temp = new ArrayList<>();\\n            for(int j=0;j<needs.size();j++){\\n                if(needs.get(j) < list.get(j)){\\n                    temp = null;\\n                    break;\\n                }// invalid offer\\n                temp.add(needs.get(j) - list.get(j));\\n            }\\n            if(temp != null){\\n                sum = Math.min(sum,list.get(list.size()-1) + help(price,special,temp,i));\\n            }\\n\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n       return help(price,special,needs,0); \\n    }\\n    public int help(List<Integer> price, List<List<Integer>> special, List<Integer> needs,int start){\\n        int sum = 0;\\n        for(int i=0;i<needs.size();i++){\\n            sum = sum + needs.get(i) * price.get(i);\\n        }\\n        for(int i=start;i<special.size();i++){\\n            List<Integer> list = special.get(i);\\n            List<Integer> temp = new ArrayList<>();\\n            for(int j=0;j<needs.size();j++){\\n                if(needs.get(j) < list.get(j)){\\n                    temp = null;\\n                    break;\\n                }// invalid offer\\n                temp.add(needs.get(j) - list.get(j));\\n            }\\n            if(temp != null){\\n                sum = Math.min(sum,list.get(list.size()-1) + help(price,special,temp,i));\\n            }\\n\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989019,
                "title": "java-recursive-memoization-using-map-dp-intuitive",
                "content": "**Recursive Code** \\n\\n- Time complexity: Highly Exponential \\n```\\nclass Solution {\\n    public static int fun(int index,List<Integer> price,List<List<Integer>> special, List<Integer> needs){\\n        // Base \\n        if(index < 0){\\n            int addAmount = 0;\\n            for(int i=0;i<needs.size();i++){\\n                addAmount += (needs.get(i) * price.get(i));\\n            }\\n            return addAmount;\\n        }\\n\\n        // Not Take Offer\\n        int notTakeOffer = 0 + fun(index-1,price,special,new ArrayList<>(needs));\\n\\n        // Take Offer \\n        int takeOffer = 1000000000;\\n        if(canTakeOffer(special.get(index),new ArrayList<>(needs))){\\n            List<Integer> current_special = special.get(index);\\n            for(int i=0;i<current_special.size()-1;i++){\\n                int current_need = needs.get(i);\\n                int update = current_special.get(i);\\n                needs.set(i,current_need-update);\\n            }\\n            takeOffer = current_special.get(current_special.size()-1) + fun(index,price,special,new ArrayList<>(needs));\\n        }\\n        return Math.min(notTakeOffer,takeOffer);\\n    }\\n\\n    public static boolean canTakeOffer(List<Integer> current_special, List<Integer> needs){\\n        boolean canTake = true;\\n        for(int i=0;i<current_special.size()-1;i++){\\n            if(needs.get(i) < current_special.get(i)){\\n                canTake = false;\\n                break;\\n            }\\n        }\\n        return canTake;\\n    }\\n\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int items = price.size();\\n        int offers = special.size();\\n        return fun(offers-1,price,special,needs);\\n    }\\n}\\n```\\n\\n**Memoization Code** \\n- Time complexity: O(offers x items)\\n```\\nclass Solution {\\n    // Memoization Code\\n    public static int fun(int index,List<Integer> price,List<List<Integer>> special, List<Integer> needs,Map<List<Integer>,Integer> dp){\\n        // Base \\n        if(index < 0){\\n            int addAmount = 0;\\n            for(int i=0;i<needs.size();i++){\\n                addAmount += (needs.get(i) * price.get(i));\\n            }\\n            return addAmount;\\n        }\\n\\n        if(dp.containsKey(needs)) return dp.get(needs);\\n\\n        // Not Take Offer\\n        int notTakeOffer = 0 + fun(index-1,price,special,new ArrayList<>(needs),new HashMap<>(dp));\\n\\n        // Take Offer \\n        int takeOffer = 1000000000;\\n        if(canTakeOffer(special.get(index),new ArrayList<>(needs))){\\n            List<Integer> current_special = special.get(index);\\n            for(int i=0;i<current_special.size()-1;i++){\\n                int current_need = needs.get(i);\\n                int update = current_special.get(i);\\n                needs.set(i,current_need-update);\\n            }\\n            takeOffer = current_special.get(current_special.size()-1) + fun(index,price,special,new ArrayList<>(needs),new HashMap<>(dp));\\n        }\\n        dp.put(new ArrayList<>(needs),Math.min(notTakeOffer,takeOffer));\\n        return Math.min(notTakeOffer,takeOffer);\\n    }\\n\\n    public static boolean canTakeOffer(List<Integer> current_special, List<Integer> needs){\\n        boolean canTake = true;\\n        for(int i=0;i<current_special.size()-1;i++){\\n            if(needs.get(i) < current_special.get(i)){\\n                canTake = false;\\n                break;\\n            }\\n        }\\n        return canTake;\\n    }\\n\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int items = price.size();\\n        int offers = special.size();\\n        Map<List<Integer>,Integer> dp = new HashMap<>();\\n        return fun(offers-1,price,special,needs,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n    public static int fun(int index,List<Integer> price,List<List<Integer>> special, List<Integer> needs){\\n        // Base \\n        if(index < 0){\\n            int addAmount = 0;\\n            for(int i=0;i<needs.size();i++){\\n                addAmount += (needs.get(i) * price.get(i));\\n            }\\n            return addAmount;\\n        }\\n\\n        // Not Take Offer\\n        int notTakeOffer = 0 + fun(index-1,price,special,new ArrayList<>(needs));\\n\\n        // Take Offer \\n        int takeOffer = 1000000000;\\n        if(canTakeOffer(special.get(index),new ArrayList<>(needs))){\\n            List<Integer> current_special = special.get(index);\\n            for(int i=0;i<current_special.size()-1;i++){\\n                int current_need = needs.get(i);\\n                int update = current_special.get(i);\\n                needs.set(i,current_need-update);\\n            }\\n            takeOffer = current_special.get(current_special.size()-1) + fun(index,price,special,new ArrayList<>(needs));\\n        }\\n        return Math.min(notTakeOffer,takeOffer);\\n    }\\n\\n    public static boolean canTakeOffer(List<Integer> current_special, List<Integer> needs){\\n        boolean canTake = true;\\n        for(int i=0;i<current_special.size()-1;i++){\\n            if(needs.get(i) < current_special.get(i)){\\n                canTake = false;\\n                break;\\n            }\\n        }\\n        return canTake;\\n    }\\n\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int items = price.size();\\n        int offers = special.size();\\n        return fun(offers-1,price,special,needs);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    // Memoization Code\\n    public static int fun(int index,List<Integer> price,List<List<Integer>> special, List<Integer> needs,Map<List<Integer>,Integer> dp){\\n        // Base \\n        if(index < 0){\\n            int addAmount = 0;\\n            for(int i=0;i<needs.size();i++){\\n                addAmount += (needs.get(i) * price.get(i));\\n            }\\n            return addAmount;\\n        }\\n\\n        if(dp.containsKey(needs)) return dp.get(needs);\\n\\n        // Not Take Offer\\n        int notTakeOffer = 0 + fun(index-1,price,special,new ArrayList<>(needs),new HashMap<>(dp));\\n\\n        // Take Offer \\n        int takeOffer = 1000000000;\\n        if(canTakeOffer(special.get(index),new ArrayList<>(needs))){\\n            List<Integer> current_special = special.get(index);\\n            for(int i=0;i<current_special.size()-1;i++){\\n                int current_need = needs.get(i);\\n                int update = current_special.get(i);\\n                needs.set(i,current_need-update);\\n            }\\n            takeOffer = current_special.get(current_special.size()-1) + fun(index,price,special,new ArrayList<>(needs),new HashMap<>(dp));\\n        }\\n        dp.put(new ArrayList<>(needs),Math.min(notTakeOffer,takeOffer));\\n        return Math.min(notTakeOffer,takeOffer);\\n    }\\n\\n    public static boolean canTakeOffer(List<Integer> current_special, List<Integer> needs){\\n        boolean canTake = true;\\n        for(int i=0;i<current_special.size()-1;i++){\\n            if(needs.get(i) < current_special.get(i)){\\n                canTake = false;\\n                break;\\n            }\\n        }\\n        return canTake;\\n    }\\n\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int items = price.size();\\n        int offers = special.size();\\n        Map<List<Integer>,Integer> dp = new HashMap<>();\\n        return fun(offers-1,price,special,needs,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849205,
                "title": "cleanest-easiest-fastest-memoization",
                "content": "# Intuition\\nTry all ways.\\n\\n# Approach\\n1. There are 2 ways of purchasing.\\n    - special offers: we need to check if we can purchase an offer by checking do we need the number of items the offer is offering.\\n    - just buy at direct price\\n2. **(Base case)** Once the needs becomes 0, we stop.\\n3. We also memoize the needs to handle the overlapping subproblems.\\n\\n# Complexity\\nPlease comment down below if anyone can figure out the time complexity for this algorithm. \\n- Time complexity:\\n**TBD**\\n\\n- Space complexity:\\n**TBD**\\n\\n# Code\\n```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        dp = {}\\n        def dfs(needs):\\n            if sum(needs)==0: return 0\\n            key = tuple(needs)\\n            if key in dp: return dp[key]\\n\\n            best = self.buyOut(needs,price)\\n            for offer in special:\\n                new_needs = self.canTake(offer,needs[:])\\n                \\n                if new_needs: best = min(best,offer[-1] + dfs(new_needs))\\n            \\n            dp[key] = best\\n            return best\\n\\n        return dfs(needs)\\n\\n    def buyOut(self,needs,prices):\\n        return sum([n*p for n,p in zip(needs,prices)])\\n\\n    def canTake(self,offer,needs):\\n        for i in range(len(needs)):\\n            needs[i] -= offer[i]\\n            if needs[i] < 0: return []\\n        return needs\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        dp = {}\\n        def dfs(needs):\\n            if sum(needs)==0: return 0\\n            key = tuple(needs)\\n            if key in dp: return dp[key]\\n\\n            best = self.buyOut(needs,price)\\n            for offer in special:\\n                new_needs = self.canTake(offer,needs[:])\\n                \\n                if new_needs: best = min(best,offer[-1] + dfs(new_needs))\\n            \\n            dp[key] = best\\n            return best\\n\\n        return dfs(needs)\\n\\n    def buyOut(self,needs,prices):\\n        return sum([n*p for n,p in zip(needs,prices)])\\n\\n    def canTake(self,offer,needs):\\n        for i in range(len(needs)):\\n            needs[i] -= offer[i]\\n            if needs[i] < 0: return []\\n        return needs\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602929,
                "title": "shopping-offers-backtracking-c-very-good-question",
                "content": "This is a very good question. \\n\\nFind the similar question, after this: https://leetcode.com/problems/closest-dessert-cost/discuss/2611975/Closes-Dessert-Cost-or-C%2B%2B-or-Backtracking-or-Good-Question\\n```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    \\n    void helper(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int n, int k){\\n        \\n        if(!n){\\n            ans=min(ans, k);\\n        }\\n        \\n        if(k>ans) return;\\n        \\n        for(int i=0; i<special.size(); i++){\\n            bool suff=true;\\n            int s=0;\\n            \\n            for(int j=0; j<needs.size(); j++){\\n                if(needs[j]<special[i][j]) suff=false;\\n            }\\n            \\n            if(suff){\\n                for(int j=0; j<needs.size(); j++){\\n                    needs[j]-=special[i][j];\\n                    s+=special[i][j];\\n                }\\n                helper(price, special, needs, n-s, k+special[i].back());\\n                \\n                for(int j=0; j<needs.size(); j++){\\n                    needs[j]+=special[i][j];\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<needs.size(); i++) k+=needs[i]*price[i];\\n        \\n        ans=min(ans, k);\\n        return;\\n    }\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n        int n=0;\\n        \\n        for(auto a:needs) n+=a;\\n        \\n        helper(price, special, needs, n, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    \\n    void helper(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int n, int k){\\n        \\n        if(!n){\\n            ans=min(ans, k);\\n        }\\n        \\n        if(k>ans) return;\\n        \\n        for(int i=0; i<special.size(); i++){\\n            bool suff=true;\\n            int s=0;\\n            \\n            for(int j=0; j<needs.size(); j++){\\n                if(needs[j]<special[i][j]) suff=false;\\n            }\\n            \\n            if(suff){\\n                for(int j=0; j<needs.size(); j++){\\n                    needs[j]-=special[i][j];\\n                    s+=special[i][j];\\n                }\\n                helper(price, special, needs, n-s, k+special[i].back());\\n                \\n                for(int j=0; j<needs.size(); j++){\\n                    needs[j]+=special[i][j];\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<needs.size(); i++) k+=needs[i]*price[i];\\n        \\n        ans=min(ans, k);\\n        return;\\n    }\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n        int n=0;\\n        \\n        for(auto a:needs) n+=a;\\n        \\n        helper(price, special, needs, n, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551491,
                "title": "easy-faster-efficient-java-soln-using-backtracking-dfs",
                "content": "```\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        return helper(price, special, needs, 0);\\n    }\\n    \\n    public int helper(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int pos) {\\n        int sum = 0, len = price.size();\\n        for (int i = 0; i < len; i++) sum += needs.get(i)*price.get(i);\\n        \\n        for (int i = pos; i < special.size(); i++) {\\n            List<Integer> list = special.get(i);\\n            List<Integer> temp = new ArrayList<>();\\n            for (int j= 0; j < needs.size(); j++) {\\n        \\t\\tif (needs.get(j) < list.get(j)) { // check if the current offer is valid\\n        \\t\\t\\ttemp =  null;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t\\ttemp.add(needs.get(j) - list.get(j));\\n        \\t}\\n            if (temp != null) { // use the current offer and try next\\n    \\t\\t\\tsum = Math.min(sum, list.get(list.size() - 1) + helper(price, special, temp, i)); \\n    \\t\\t}\\n        }\\n        return sum;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        return helper(price, special, needs, 0);\\n    }\\n    \\n    public int helper(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int pos) {\\n        int sum = 0, len = price.size();\\n        for (int i = 0; i < len; i++) sum += needs.get(i)*price.get(i);\\n        \\n        for (int i = pos; i < special.size(); i++) {\\n            List<Integer> list = special.get(i);\\n            List<Integer> temp = new ArrayList<>();\\n            for (int j= 0; j < needs.size(); j++) {\\n        \\t\\tif (needs.get(j) < list.get(j)) { // check if the current offer is valid\\n        \\t\\t\\ttemp =  null;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t\\ttemp.add(needs.get(j) - list.get(j));\\n        \\t}\\n            if (temp != null) { // use the current offer and try next\\n    \\t\\t\\tsum = Math.min(sum, list.get(list.size() - 1) + helper(price, special, temp, i)); \\n    \\t\\t}\\n        }\\n        return sum;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547155,
                "title": "python-dfs-easy-to-understand",
                "content": "```\\nfrom functools import cache\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        @cache\\n        def dfs(i, needs):\\n            res = sum(p*n for p,n in zip(price, needs))\\n            if i == len(special):\\n                return res\\n            cur = 0\\n            while min(needs)>=0:\\n                res = min(res, cur + dfs(i+1, tuple(needs)))\\n                needs = [a-b for a,b in zip(needs, special[i])]\\n                cur += special[i][-1]\\n            return res\\n        return dfs(0, tuple(needs))",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom functools import cache\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        @cache\\n        def dfs(i, needs):\\n            res = sum(p*n for p,n in zip(price, needs))\\n            if i == len(special):\\n                return res\\n            cur = 0\\n            while min(needs)>=0:\\n                res = min(res, cur + dfs(i+1, tuple(needs)))\\n                needs = [a-b for a,b in zip(needs, special[i])]\\n                cur += special[i][-1]\\n            return res\\n        return dfs(0, tuple(needs))",
                "codeTag": "Java"
            },
            {
                "id": 2411554,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    int n;\\n\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        n = price.size();\\n        return helper(price, special, needs, 0);\\n    }\\n\\n    private int helper(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int i) {\\n        if (i == special.size()) {\\n            int res = 0;\\n            for (int j = 0; j < n; j++) {\\n                res += price.get(j) * needs.get(j);\\n            }\\n            return res;\\n        }\\n        List<Integer> needs1 = new ArrayList<>();\\n        if (!check(special.get(i), needs)) {\\n            return helper(price, special, needs, i + 1);\\n        }\\n        for (int k = 0; k < n; k++) {\\n            needs1.add(k, needs.get(k) - special.get(i).get(k));\\n        }\\n        return Math.min(helper(price, special, needs1, i) + special.get(i).get(n),\\n                helper(price, special, needs, i + 1));\\n    }\\n\\n    private boolean check(List<Integer> list, List<Integer> needs) {\\n        for (int i = 0; i < n; i++) {\\n            if (list.get(i) > needs.get(i))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\n\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        n = price.size();\\n        return helper(price, special, needs, 0);\\n    }\\n\\n    private int helper(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int i) {\\n        if (i == special.size()) {\\n            int res = 0;\\n            for (int j = 0; j < n; j++) {\\n                res += price.get(j) * needs.get(j);\\n            }\\n            return res;\\n        }\\n        List<Integer> needs1 = new ArrayList<>();\\n        if (!check(special.get(i), needs)) {\\n            return helper(price, special, needs, i + 1);\\n        }\\n        for (int k = 0; k < n; k++) {\\n            needs1.add(k, needs.get(k) - special.get(i).get(k));\\n        }\\n        return Math.min(helper(price, special, needs1, i) + special.get(i).get(n),\\n                helper(price, special, needs, i + 1));\\n    }\\n\\n    private boolean check(List<Integer> list, List<Integer> needs) {\\n        for (int i = 0; i < n; i++) {\\n            if (list.get(i) > needs.get(i))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381359,
                "title": "java-dp-solution-with-memoization",
                "content": "```\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int n=price.size();\\n        int offers=special.size();\\n        Map<List<Integer>,Integer>hs=new HashMap<List<Integer>,Integer>();//For memoization\\n        return getResult(price,special,needs,n,offers,hs);\\n        \\n    }\\n    \\n    int getResult(List<Integer> price, List<List<Integer>> special, List<Integer> needs,int n,int offers,Map<List<Integer>,Integer>hs){\\n       boolean done=true;\\n        for(int i=0;i<n;i++){\\n            if(needs.get(i)!=0){done=false;break;};\\n        }\\n        if(done)return 0;\\n       \\n        if(hs.containsKey(needs))return hs.get(needs); //Checking for overlapping needs  \\n        \\n        int cost=Integer.MAX_VALUE;\\n        for(int i=0;i<offers;i++){\\n            \\n            //Checking if offer can be applied or not.\\n            boolean isValid=isOfferValid(special,i,needs,n);\\n            if(isValid){\\n                List<Integer>newNeeds=new ArrayList<>();\\n                for(int j=0;j<n;j++){\\n                    newNeeds.add(needs.get(j)-special.get(i).get(j));\\n                }\\n                cost=Math.min(cost,special.get(i).get(n)+getResult(price,special,newNeeds,n,offers,hs));\\n            }\\n            \\n            //Price if offer is not applied.\\n                int tempPrice=0;\\n                for(int k=0;k<n;k++){\\n                    tempPrice=tempPrice+needs.get(k)*price.get(k);\\n                }\\n                \\n                cost=Math.min(tempPrice,cost);\\n            \\n        }\\n       \\n       hs.put(needs,cost);\\n        return cost;\\n        \\n    }\\n    \\n    boolean isOfferValid( List<List<Integer>> special,int offer,List<Integer>needs,int n){\\n        \\n        for(int i=0;i<n;i++){\\n            if(needs.get(i)<special.get(offer).get(i))return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int n=price.size();\\n        int offers=special.size();\\n        Map<List<Integer>,Integer>hs=new HashMap<List<Integer>,Integer>();//For memoization\\n        return getResult(price,special,needs,n,offers,hs);\\n        \\n    }\\n    \\n    int getResult(List<Integer> price, List<List<Integer>> special, List<Integer> needs,int n,int offers,Map<List<Integer>,Integer>hs){\\n       boolean done=true;\\n        for(int i=0;i<n;i++){\\n            if(needs.get(i)!=0){done=false;break;};\\n        }\\n        if(done)return 0;\\n       \\n        if(hs.containsKey(needs))return hs.get(needs); //Checking for overlapping needs  \\n        \\n        int cost=Integer.MAX_VALUE;\\n        for(int i=0;i<offers;i++){\\n            \\n            //Checking if offer can be applied or not.\\n            boolean isValid=isOfferValid(special,i,needs,n);\\n            if(isValid){\\n                List<Integer>newNeeds=new ArrayList<>();\\n                for(int j=0;j<n;j++){\\n                    newNeeds.add(needs.get(j)-special.get(i).get(j));\\n                }\\n                cost=Math.min(cost,special.get(i).get(n)+getResult(price,special,newNeeds,n,offers,hs));\\n            }\\n            \\n            //Price if offer is not applied.\\n                int tempPrice=0;\\n                for(int k=0;k<n;k++){\\n                    tempPrice=tempPrice+needs.get(k)*price.get(k);\\n                }\\n                \\n                cost=Math.min(tempPrice,cost);\\n            \\n        }\\n       \\n       hs.put(needs,cost);\\n        return cost;\\n        \\n    }\\n    \\n    boolean isOfferValid( List<List<Integer>> special,int offer,List<Integer>needs,int n){\\n        \\n        for(int i=0;i<n;i++){\\n            if(needs.get(i)<special.get(offer).get(i))return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227749,
                "title": "unordered-map-int-int-is-faster-than-vector-int",
                "content": "I was using `vector<int>` as a cache table (size was ~(1<<24) because I was storing `needs` values in 4 bit sections in an `int`). But that solution would Time out very easily. But when I swapped out `vector<int>` for `unordered_map<int,int>`, that same code was accepted with very good runtime. \\n\\nWhy is that?\\nWell, lets look at the limits. I was initializing my old cache using `dp.resize((1<<24)+10, -1);`. Let\\'s say that space allocation takes very little time. The loop to change every value to \\'-1\\' would run 16777216 times. Or, ~1.6x(10^7) times. This number is very important (and very big!). We know that C++ can do ~(10^8) operations in a second. Which means that the cache init loop alone would take 1/10 of a second to run. Regardless of whether all these values are used or not. \\n\\nSo I guess it is not always beneficial to use `vector<int>` instead of `unordered_map<int,int>`. Watch those limits closely!\\n\\nHere is my old code for reference:\\n```c++\\n/* Note: This code results in a Timeout. */\\nclass Solution {\\npublic:\\n    int n, c;\\n    vector<int> dp;\\n    int compute(const vector<int> &price, const vector<vector<int>> &offers, int needs){\\n        if(dp[needs] != -1) return dp[needs];\\n        // Compute the min cost to satisfy these needs\\n        int best{}, new_needs, i;\\n        for(int i=0; i<n; i++){\\n            c = ((needs>>(i*4))&0xf);\\n            best += c * price[i];\\n        }\\n        if(best == 0) return 0;\\n        for(const vector<int> &offer : offers){\\n            new_needs = 0;\\n            for(i=0; i<n; i++){\\n                c = ((needs>>(i*4))&0xf);\\n                if(c >= offer[i]) new_needs |= ((c-offer[i])<<(i*4));\\n                else break;\\n            };\\n            if(i == n) best = min(best, compute(price, offers, new_needs) + offer.back());\\n        }\\n        return dp[needs] = best;\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        dp.resize((1<<24)+10, -1);\\n        n = needs.size();\\n        int needs_hash{};\\n        for(int i=0; i<n; i++) needs_hash |= ((needs[i])<<(i*4));\\n        return compute(price, special, needs_hash);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\n/* Note: This code results in a Timeout. */\\nclass Solution {\\npublic:\\n    int n, c;\\n    vector<int> dp;\\n    int compute(const vector<int> &price, const vector<vector<int>> &offers, int needs){\\n        if(dp[needs] != -1) return dp[needs];\\n        // Compute the min cost to satisfy these needs\\n        int best{}, new_needs, i;\\n        for(int i=0; i<n; i++){\\n            c = ((needs>>(i*4))&0xf);\\n            best += c * price[i];\\n        }\\n        if(best == 0) return 0;\\n        for(const vector<int> &offer : offers){\\n            new_needs = 0;\\n            for(i=0; i<n; i++){\\n                c = ((needs>>(i*4))&0xf);\\n                if(c >= offer[i]) new_needs |= ((c-offer[i])<<(i*4));\\n                else break;\\n            };\\n            if(i == n) best = min(best, compute(price, offers, new_needs) + offer.back());\\n        }\\n        return dp[needs] = best;\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        dp.resize((1<<24)+10, -1);\\n        n = needs.size();\\n        int needs_hash{};\\n        for(int i=0; i<n; i++) needs_hash |= ((needs[i])<<(i*4));\\n        return compute(price, special, needs_hash);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114579,
                "title": "c-code-memoization-66-faster",
                "content": "**Please upvote if it helps**\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int func(vector<int>& price, vector<vector<int>>& special, vector<int>needs,int i){\\n        if (i==special.size()){\\n            int val=0;\\n            for (int j=0; j<needs.size(); j++){\\n                val+=(needs[j]*price[j]);\\n            }\\n            return val;\\n        }\\n        \\n       \\n        \\n        int leave_offer=0,take_offer=0;\\n        leave_offer=func(price,special,needs,i+1);\\n        \\n        //accepting the offer\\n        bool flag=true;\\n        for (int j=0; j<needs.size(); j++){\\n            if (needs[j]<special[i][j]){\\n                flag=false;\\n            }\\n        }\\n        \\n        if (flag){\\n            for (int j=0; j<needs.size(); j++){\\n                needs[j]-=special[i][j];\\n            }\\n            take_offer=special[i][needs.size()]+func(price,special,needs,i);\\n        }\\n        \\n        if (!flag){\\n            take_offer=leave_offer;\\n        }\\n        \\n      return min(leave_offer,take_offer);  \\n    } \\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n        return func(price,special,needs,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int func(vector<int>& price, vector<vector<int>>& special, vector<int>needs,int i){\\n        if (i==special.size()){\\n            int val=0;\\n            for (int j=0; j<needs.size(); j++){\\n                val+=(needs[j]*price[j]);\\n            }\\n            return val;\\n        }\\n        \\n       \\n        \\n        int leave_offer=0,take_offer=0;\\n        leave_offer=func(price,special,needs,i+1);\\n        \\n        //accepting the offer\\n        bool flag=true;\\n        for (int j=0; j<needs.size(); j++){\\n            if (needs[j]<special[i][j]){\\n                flag=false;\\n            }\\n        }\\n        \\n        if (flag){\\n            for (int j=0; j<needs.size(); j++){\\n                needs[j]-=special[i][j];\\n            }\\n            take_offer=special[i][needs.size()]+func(price,special,needs,i);\\n        }\\n        \\n        if (!flag){\\n            take_offer=leave_offer;\\n        }\\n        \\n      return min(leave_offer,take_offer);  \\n    } \\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n        return func(price,special,needs,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962982,
                "title": "c-backtracking-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        dfs(price, special, needs, 0);\\n        return ans;\\n    }\\nprivate:\\n    void dfs(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int currPrice) {\\n        if (accumulate(needs.begin(), needs.end(), 0) == 0) {\\n            ans = min(ans, currPrice);\\n            return;\\n        }\\n        int len = special.size();\\n        for (int i = 0; i < len; i++) {\\n            if (canSpecialBeUsed(needs, special[i])) {\\n                currPrice += special[i].back();\\n                needs = updateNeeds(needs, special[i], \"-\");\\n                dfs(price, special, needs, currPrice);\\n                currPrice -= special[i].back();\\n                needs = updateNeeds(needs, special[i], \"+\");\\n            }\\n        }\\n        if (accumulate(needs.begin(), needs.end(), 0) != 0) {\\n            currPrice += addLeftOverItems(needs, price);\\n            ans = min(ans, currPrice);\\n        }\\n    }\\n    \\n    bool canSpecialBeUsed(vector<int>& needs, vector<int>& special) {\\n        int len = needs.size();\\n        for (int i = 0; i < len; i++) {\\n            if (special[i] > needs[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    vector<int>& updateNeeds(vector<int>& needs, vector<int>& special, string op) {\\n        int len = needs.size();\\n        for (int i = 0; i < len; i++) {\\n            if (op == \"-\") {\\n                needs[i] -= special[i];\\n            } else {\\n                needs[i] += special[i];\\n            }\\n        }\\n        return needs;\\n    }\\n    \\n    int addLeftOverItems(vector<int>& needs, vector<int>& price) {\\n        int len = needs.size();\\n        int sum = 0;\\n        for (int i = 0; i < len; i++) {\\n            sum += needs[i] * price[i];\\n        }\\n        return sum;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        dfs(price, special, needs, 0);\\n        return ans;\\n    }\\nprivate:\\n    void dfs(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int currPrice) {\\n        if (accumulate(needs.begin(), needs.end(), 0) == 0) {\\n            ans = min(ans, currPrice);\\n            return;\\n        }\\n        int len = special.size();\\n        for (int i = 0; i < len; i++) {\\n            if (canSpecialBeUsed(needs, special[i])) {\\n                currPrice += special[i].back();\\n                needs = updateNeeds(needs, special[i], \"-\");\\n                dfs(price, special, needs, currPrice);\\n                currPrice -= special[i].back();\\n                needs = updateNeeds(needs, special[i], \"+\");\\n            }\\n        }\\n        if (accumulate(needs.begin(), needs.end(), 0) != 0) {\\n            currPrice += addLeftOverItems(needs, price);\\n            ans = min(ans, currPrice);\\n        }\\n    }\\n    \\n    bool canSpecialBeUsed(vector<int>& needs, vector<int>& special) {\\n        int len = needs.size();\\n        for (int i = 0; i < len; i++) {\\n            if (special[i] > needs[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    vector<int>& updateNeeds(vector<int>& needs, vector<int>& special, string op) {\\n        int len = needs.size();\\n        for (int i = 0; i < len; i++) {\\n            if (op == \"-\") {\\n                needs[i] -= special[i];\\n            } else {\\n                needs[i] += special[i];\\n            }\\n        }\\n        return needs;\\n    }\\n    \\n    int addLeftOverItems(vector<int>& needs, vector<int>& price) {\\n        int len = needs.size();\\n        int sum = 0;\\n        for (int i = 0; i < len; i++) {\\n            sum += needs[i] * price[i];\\n        }\\n        return sum;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936602,
                "title": "python-dp-with-cache",
                "content": "This is a typical DP problem.\\nThe options are whether we\\'re going to use each special offer, \\nand the state is current needed items and current total price.\\n\\n```\\nclass Solution:\\n    def shoppingOffers(\\n        self, price: List[int], special: List[List[int]], needs: List[int]\\n    ) -> int:\\n        N = len(price)\\n\\n        @cache\\n        def dp(needed: Tuple[int]) -> int:\\n            cur = sum(price[i] * needed[i] for i in range(N))\\n            for s in special:\\n                if all(s[i] <= needed[i] for i in range(N)):\\n                    cur = min(\\n                        cur, s[-1] + dp(tuple(needed[i] - s[i] for i in range(N)))\\n                    )\\n            return cur\\n\\n        return dp(tuple(needs))\\n```\\n\\n1 trick here: \\nsince we have to make parameters hashable when using `@cache`, convert `needList` to `Tuple`.\\nIt won\\'t cost too much as `1 <= n <= 6`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shoppingOffers(\\n        self, price: List[int], special: List[List[int]], needs: List[int]\\n    ) -> int:\\n        N = len(price)\\n\\n        @cache\\n        def dp(needed: Tuple[int]) -> int:\\n            cur = sum(price[i] * needed[i] for i in range(N))\\n            for s in special:\\n                if all(s[i] <= needed[i] for i in range(N)):\\n                    cur = min(\\n                        cur, s[-1] + dp(tuple(needed[i] - s[i] for i in range(N)))\\n                    )\\n            return cur\\n\\n        return dp(tuple(needs))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832103,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    map<vector<int>,int> mp; \\n    int func(vector<int>& price, vector<vector<int>>& special, vector<int> needs, int &n, int &m){\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(needs[i]==0){\\n                cnt++;\\n            }\\n        }\\n        \\n        if(cnt==n)\\n            return 0;\\n        \\n        if(mp.find(needs)!=mp.end()){\\n            return mp[needs];\\n        }\\n        \\n        \\n        int mn=INT_MAX;\\n        int len=special[0].size();\\n        vector<int> v(n,0);\\n        for(int i=0;i<m;i++){\\n            bool flag=true;\\n            for(int j=0;j<len-1;j++){\\n                if(needs[j]-special[i][j]<0){\\n                    flag=false;\\n                }\\n                v[j]=needs[j]-special[i][j];\\n            }\\n            \\n            if(flag){\\n                mn=min(mn,special[i][len-1]+func(price,special,v,n,m));\\n            }\\n            \\n        }\\n        \\n        int val=0;\\n        for(int i=0;i<n;i++){\\n            if(needs[i]){\\n                val=val+price[i];\\n                v[i]=needs[i]-1;\\n            }else{\\n                v[i]=0;\\n            }\\n        }\\n        \\n        mn=min(mn,val+func(price,special,v,n,m));\\n        return mp[needs]=mn;\\n        \\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int n=price.size();\\n        int m=special.size();\\n        return func(price,special,needs,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<vector<int>,int> mp; \\n    int func(vector<int>& price, vector<vector<int>>& special, vector<int> needs, int &n, int &m){\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(needs[i]==0){\\n                cnt++;\\n            }\\n        }\\n        \\n        if(cnt==n)\\n            return 0;\\n        \\n        if(mp.find(needs)!=mp.end()){\\n            return mp[needs];\\n        }\\n        \\n        \\n        int mn=INT_MAX;\\n        int len=special[0].size();\\n        vector<int> v(n,0);\\n        for(int i=0;i<m;i++){\\n            bool flag=true;\\n            for(int j=0;j<len-1;j++){\\n                if(needs[j]-special[i][j]<0){\\n                    flag=false;\\n                }\\n                v[j]=needs[j]-special[i][j];\\n            }\\n            \\n            if(flag){\\n                mn=min(mn,special[i][len-1]+func(price,special,v,n,m));\\n            }\\n            \\n        }\\n        \\n        int val=0;\\n        for(int i=0;i<n;i++){\\n            if(needs[i]){\\n                val=val+price[i];\\n                v[i]=needs[i]-1;\\n            }else{\\n                v[i]=0;\\n            }\\n        }\\n        \\n        mn=min(mn,val+func(price,special,v,n,m));\\n        return mp[needs]=mn;\\n        \\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int n=price.size();\\n        int m=special.size();\\n        return func(price,special,needs,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767980,
                "title": "c-simple-dynamic-programming-full-explanation",
                "content": "# Explanation\\n\\nThe **DP state** that we are going to use in this problem is the ***needs vector array***.\\n\\nWe will define a subproblem according to the needs.\\n\\nFor Example:\\nLet\\'s say : needs = [1,4,3,5]\\n\\nNow we get an offer that offers 1 of all types of items in a reasonable price, so we will buy it.\\n\\n ***Since we bought an offer the needs array is reduced down to the following***\\nneeds = **[1-1,4-1,3-1,5-1]**\\n\\nAnd then call the function again to solve the new subproblem for **needs = [0,3,2,4]**.\\n\\n\\n# This is a normal DP Problem which looks complicated.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    map<vector<int>,int> dp;\\n    int calculateMin(vector<int>& needs,vector<vector<int>>& special,vector<int>& price){\\n        // IF SUBPROBLEM ALREADY SOLVED RETURN THE STORED ANSWER\\n        if(dp.find(needs)!=dp.end()){\\n            return dp[needs];\\n        }\\n\\t\\t\\n\\t\\t//IF NOT SOLVED , THEN WE WILL SOLVE IT\\n        int result = INT_MAX;\\n\\t\\t\\n\\t\\t//TRYING ALL THE POSSIBLE COMBINATIONS WITH THE SPECIAL OFFERS\\n        for(vector<int> offer: special){\\n            bool flag = true;\\n            for(int i=0;i<needs.size();i++){\\n                needs[i] -= offer[i];\\n                if(needs[i]<0)\\n                    flag = false;\\n            }\\n            if(flag){\\n                result = min(result,offer[needs.size()] + calculateMin(needs,special,price));\\n            }\\n            for(int i=0;i<needs.size();i++){\\n                needs[i] += offer[i];\\n            }\\n        }\\n\\t\\t//IF WE CAN\\'T GET A SUITABLE OFFER FOR THE ABOVE NEEDS THE WE WILL BUY THEM AT ORIGINAL PRICES\\n\\t\\tint tempResult = 0;\\n\\t\\tfor(int i=0;i<needs.size();i++){\\n\\t\\t\\ttempResult += needs[i]*price[i];\\n\\t\\t}\\n\\t\\t\\n        result = min(result,tempResult);\\n        return dp[needs] = result;\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return calculateMin(needs,special,price);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<vector<int>,int> dp;\\n    int calculateMin(vector<int>& needs,vector<vector<int>>& special,vector<int>& price){\\n        // IF SUBPROBLEM ALREADY SOLVED RETURN THE STORED ANSWER\\n        if(dp.find(needs)!=dp.end()){\\n            return dp[needs];\\n        }\\n\\t\\t\\n\\t\\t//IF NOT SOLVED , THEN WE WILL SOLVE IT\\n        int result = INT_MAX;\\n\\t\\t\\n\\t\\t//TRYING ALL THE POSSIBLE COMBINATIONS WITH THE SPECIAL OFFERS\\n        for(vector<int> offer: special){\\n            bool flag = true;\\n            for(int i=0;i<needs.size();i++){\\n                needs[i] -= offer[i];\\n                if(needs[i]<0)\\n                    flag = false;\\n            }\\n            if(flag){\\n                result = min(result,offer[needs.size()] + calculateMin(needs,special,price));\\n            }\\n            for(int i=0;i<needs.size();i++){\\n                needs[i] += offer[i];\\n            }\\n        }\\n\\t\\t//IF WE CAN\\'T GET A SUITABLE OFFER FOR THE ABOVE NEEDS THE WE WILL BUY THEM AT ORIGINAL PRICES\\n\\t\\tint tempResult = 0;\\n\\t\\tfor(int i=0;i<needs.size();i++){\\n\\t\\t\\ttempResult += needs[i]*price[i];\\n\\t\\t}\\n\\t\\t\\n        result = min(result,tempResult);\\n        return dp[needs] = result;\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return calculateMin(needs,special,price);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695504,
                "title": "6-dimension-knapsack-dp",
                "content": "This is a classic knapsack DP. \\uFF08\\u591A\\u7EF4\\u8D39\\u7528\\uFF09\\nItems are offers. Constraints are needs.\\n\\nHowever the test cases are not strong enough. Time complexity is O(10^8). LC expects you to use DFS to search the answer.\\n\\nThe solution below will AC.\\n\\n```\\nclass Solution {\\npublic:\\n    static const int N = 11;\\n    int dp[N][N][N][N][N][N];\\n    \\n    int shoppingOffers(vector<int>& prices, vector<vector<int>>& special, vector<int>& needs) {    \\n        prices.resize(6);\\n        needs.resize(6);\\n        \\n        for (vector<int> & offer: special) {\\n            int p = offer.back();\\n            offer.pop_back();\\n            offer.resize(6);\\n            offer.push_back(p);\\n        }\\n        \\n        for (int a = 0; a <= needs[0]; a++) {\\n            for (int b = 0; b <= needs[1]; b++) {\\n                for (int c = 0; c <= needs[2]; c++) {\\n                    for (int d = 0; d <= needs[3]; d++) {\\n                        for (int e = 0; e <= needs[4]; e++) {\\n                            for (int f = 0; f <= needs[5]; f++) {\\n                                dp[a][b][c][d][e][f] += a*prices[0] +  b*prices[1] + c*prices[2] + d*prices[3] + e*prices[4] + f*prices[5];\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (vector<int> & offer: special) {\\n            for (int a = offer[0]; a <= needs[0]; a++) {\\n                for (int b = offer[1]; b <= needs[1]; b++) {\\n                    for (int c = offer[2]; c <= needs[2]; c++) {\\n                        for (int d = offer[3]; d <= needs[3]; d++) {\\n                            for (int e = offer[4]; e <= needs[4]; e++) {\\n                                for (int f = offer[5]; f <= needs[5]; f++) {   \\n                                    int & t = dp[a][b][c][d][e][f];\\n                                    int a1 = a - offer[0];\\n                                    int b1 = b - offer[1];\\n                                    int c1 = c - offer[2];\\n                                    int d1 = d - offer[3];\\n                                    int e1 = e - offer[4];\\n                                    int f1 = f - offer[5];\\n\\n                                    t = min(t, dp[a1][b1][c1][d1][e1][f1] + offer.back());\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static const int N = 11;\\n    int dp[N][N][N][N][N][N];\\n    \\n    int shoppingOffers(vector<int>& prices, vector<vector<int>>& special, vector<int>& needs) {    \\n        prices.resize(6);\\n        needs.resize(6);\\n        \\n        for (vector<int> & offer: special) {\\n            int p = offer.back();\\n            offer.pop_back();\\n            offer.resize(6);\\n            offer.push_back(p);\\n        }\\n        \\n        for (int a = 0; a <= needs[0]; a++) {\\n            for (int b = 0; b <= needs[1]; b++) {\\n                for (int c = 0; c <= needs[2]; c++) {\\n                    for (int d = 0; d <= needs[3]; d++) {\\n                        for (int e = 0; e <= needs[4]; e++) {\\n                            for (int f = 0; f <= needs[5]; f++) {\\n                                dp[a][b][c][d][e][f] += a*prices[0] +  b*prices[1] + c*prices[2] + d*prices[3] + e*prices[4] + f*prices[5];\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (vector<int> & offer: special) {\\n            for (int a = offer[0]; a <= needs[0]; a++) {\\n                for (int b = offer[1]; b <= needs[1]; b++) {\\n                    for (int c = offer[2]; c <= needs[2]; c++) {\\n                        for (int d = offer[3]; d <= needs[3]; d++) {\\n                            for (int e = offer[4]; e <= needs[4]; e++) {\\n                                for (int f = offer[5]; f <= needs[5]; f++) {   \\n                                    int & t = dp[a][b][c][d][e][f];\\n                                    int a1 = a - offer[0];\\n                                    int b1 = b - offer[1];\\n                                    int c1 = c - offer[2];\\n                                    int d1 = d - offer[3];\\n                                    int e1 = e - offer[4];\\n                                    int f1 = f - offer[5];\\n\\n                                    t = min(t, dp[a1][b1][c1][d1][e1][f1] + offer.back());\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691117,
                "title": "c-solution-that-works",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int shoppingOffersHelper(vector<int>&price, vector<vector<int>>&spl, vector<int>&needs, map<vector<int>,int>&m){\\n        bool flag = false;\\n        for(int i=0; i<needs.size(); i++){\\n            if(needs[i] < 0)\\n                return INT_MAX;\\n            if(needs[i] > 0)\\n                flag = true;\\n        }\\n        \\n        if(!flag)\\n            return 0;\\n        \\n        if(m.find(needs) != m.end())\\n            return m[needs];\\n        \\n        long minCost = INT_MAX;\\n        int cost = 0;\\n        for(int i=0; i<price.size(); i++){\\n            cost += price[i] * needs[i];\\n        }\\n        \\n        minCost = min(minCost, (long)cost);\\n        \\n        for(int i=0; i<spl.size(); i++){\\n            for(int j=0; j<price.size(); j++)\\n                needs[j] -= spl[i][j];\\n                minCost = min(minCost, (long)spl[i][price.size()] + shoppingOffersHelper(price, spl, needs, m));\\n            for(int j=0; j<price.size(); j++)\\n                needs[j] += spl[i][j];\\n            \\n        }\\n        \\n        m[needs] = (int)minCost;\\n        return (int)minCost;\\n        \\n        \\n    }\\n    \\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n        map<vector<int>, int>m;\\n        return shoppingOffersHelper(price, special, needs, m);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int shoppingOffersHelper(vector<int>&price, vector<vector<int>>&spl, vector<int>&needs, map<vector<int>,int>&m){\\n        bool flag = false;\\n        for(int i=0; i<needs.size(); i++){\\n            if(needs[i] < 0)\\n                return INT_MAX;\\n            if(needs[i] > 0)\\n                flag = true;\\n        }\\n        \\n        if(!flag)\\n            return 0;\\n        \\n        if(m.find(needs) != m.end())\\n            return m[needs];\\n        \\n        long minCost = INT_MAX;\\n        int cost = 0;\\n        for(int i=0; i<price.size(); i++){\\n            cost += price[i] * needs[i];\\n        }\\n        \\n        minCost = min(minCost, (long)cost);\\n        \\n        for(int i=0; i<spl.size(); i++){\\n            for(int j=0; j<price.size(); j++)\\n                needs[j] -= spl[i][j];\\n                minCost = min(minCost, (long)spl[i][price.size()] + shoppingOffersHelper(price, spl, needs, m));\\n            for(int j=0; j<price.size(); j++)\\n                needs[j] += spl[i][j];\\n            \\n        }\\n        \\n        m[needs] = (int)minCost;\\n        return (int)minCost;\\n        \\n        \\n    }\\n    \\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n        map<vector<int>, int>m;\\n        return shoppingOffersHelper(price, special, needs, m);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623136,
                "title": "c-dijkstra",
                "content": "dijkstra\\n1. it\\'s a graph problem\\n2. all edge weight is positive\\n3. all the node has a edge to destination (i.e. `pq.emplace(needs.size(), cost(cur));`)\\n\\nlet `n` = `needs.size()`\\nlet `V` = `needs[0] * needs[1] * ... * needs[n - 1]`\\nlet `e` = `special.size()`\\nlet `E` = `Ve`\\nin worst case we have `V` nodes, and for each nodes we have `E + 1` edges, so there will be `O(E)` edges in total\\n\\ntime complexity: `O(E(n + lgE))` = `O(E(n +lgV))` for `pq` + `O(V(n + lgV))` = `O((V + E)(n + lgV))`\\n\\n\\\\*`n` is for processing the vector\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) { \\n        auto cost = [&price] (auto &p) {\\n            return \\n                inner_product(p.first.begin(), p.first.end(), price.begin(), p.second);\\n        };\\n        \\n        auto cmp = [] (auto &a, auto &b) {\\n            return a.second > b.second;\\n        };\\n        \\n        using P = pair<vector<int>, int>;\\n        priority_queue<P, vector<P>, decltype(cmp)> pq(cmp);\\n        pq.push({needs, 0});\\n        map<vector<int>, int> min_cost;\\n        \\n        for (; !pq.empty();) {\\n            auto cur = pq.top();\\n            pq.pop();\\n            if (all_of(cur.first.begin(), cur.first.end(), [] (int need) { return !need; }))\\n                return cur.second;\\n            if (min_cost.count(cur.first) && cur.second != min_cost[cur.first])\\n                continue;\\n            \\n            pq.emplace(needs.size(), cost(cur));\\n            \\n            for (int i = 0; i < special.size(); i++) {\\n                for (int j = 0; j < needs.size(); j++) {\\n                    cur.first[j] -= special[i][j];\\n                }\\n                if (all_of(cur.first.begin(), cur.first.end(), [] (int need) { return need >= 0; })) {\\n                    int cur_cost = cur.second + special[i].back();\\n                    if (!min_cost.count(cur.first) || cur_cost < min_cost[cur.first]) {\\n                        min_cost[cur.first] = cur_cost;\\n                        pq.emplace(cur.first, cur_cost);\\n                    }\\n                }\\n                for (int j = 0; j < needs.size(); j++) {\\n                    cur.first[j] += special[i][j];\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\\n\\nDFS `O((V + E)n)`\\n```\\nclass Solution {\\npublic:\\n    map<vector<int>, int> dp;\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        if (count(needs.begin(), needs.end(), 0) == needs.size())\\n            return 0;\\n        if (dp.count(needs))\\n            return dp[needs];\\n        \\n        int res = inner_product(needs.begin(), needs.end(), price.begin(), 0);\\n        for (int i = 0; i < special.size(); i++) {\\n            for (int j = 0; j < needs.size(); j++) {\\n                needs[j] -= special[i][j];\\n            }\\n            if (none_of(needs.begin(), needs.end(), [] (int need) { return need < 0; })) {\\n                    res = min(res, special[i].back() + shoppingOffers(price, special, needs));\\n            }\\n            for (int j = 0; j < needs.size(); j++) {\\n                needs[j] += special[i][j];\\n            }\\n        }\\n        \\n        return dp[needs] = res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) { \\n        auto cost = [&price] (auto &p) {\\n            return \\n                inner_product(p.first.begin(), p.first.end(), price.begin(), p.second);\\n        };\\n        \\n        auto cmp = [] (auto &a, auto &b) {\\n            return a.second > b.second;\\n        };\\n        \\n        using P = pair<vector<int>, int>;\\n        priority_queue<P, vector<P>, decltype(cmp)> pq(cmp);\\n        pq.push({needs, 0});\\n        map<vector<int>, int> min_cost;\\n        \\n        for (; !pq.empty();) {\\n            auto cur = pq.top();\\n            pq.pop();\\n            if (all_of(cur.first.begin(), cur.first.end(), [] (int need) { return !need; }))\\n                return cur.second;\\n            if (min_cost.count(cur.first) && cur.second != min_cost[cur.first])\\n                continue;\\n            \\n            pq.emplace(needs.size(), cost(cur));\\n            \\n            for (int i = 0; i < special.size(); i++) {\\n                for (int j = 0; j < needs.size(); j++) {\\n                    cur.first[j] -= special[i][j];\\n                }\\n                if (all_of(cur.first.begin(), cur.first.end(), [] (int need) { return need >= 0; })) {\\n                    int cur_cost = cur.second + special[i].back();\\n                    if (!min_cost.count(cur.first) || cur_cost < min_cost[cur.first]) {\\n                        min_cost[cur.first] = cur_cost;\\n                        pq.emplace(cur.first, cur_cost);\\n                    }\\n                }\\n                for (int j = 0; j < needs.size(); j++) {\\n                    cur.first[j] += special[i][j];\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    map<vector<int>, int> dp;\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        if (count(needs.begin(), needs.end(), 0) == needs.size())\\n            return 0;\\n        if (dp.count(needs))\\n            return dp[needs];\\n        \\n        int res = inner_product(needs.begin(), needs.end(), price.begin(), 0);\\n        for (int i = 0; i < special.size(); i++) {\\n            for (int j = 0; j < needs.size(); j++) {\\n                needs[j] -= special[i][j];\\n            }\\n            if (none_of(needs.begin(), needs.end(), [] (int need) { return need < 0; })) {\\n                    res = min(res, special[i].back() + shoppingOffers(price, special, needs));\\n            }\\n            for (int j = 0; j < needs.size(); j++) {\\n                needs[j] += special[i][j];\\n            }\\n        }\\n        \\n        return dp[needs] = res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511883,
                "title": "c-easy-solution",
                "content": "\\tpublic class Solution\\n\\t\\t{\\n\\t\\t\\tpublic int ShoppingOffers(IList<int> price, IList<IList<int>> special, IList<int> needs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint cost = GetCost(price, needs);\\n\\n\\t\\t\\t\\tif (cost == 0)\\n\\t\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t\\tfor(int i = 0; i < special.Count; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tIList<int> temp = needs.ToList();\\n\\t\\t\\t\\t\\t(bool, int) res = CheckIfApplicable(special[i], temp);\\n\\n\\t\\t\\t\\t\\tif (res.Item1)\\n\\t\\t\\t\\t\\t\\tcost = Math.Min(cost, ShoppingOffers(price, special, temp) + res.Item2);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn cost;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic int GetCost(IList<int> price, IList<int> needs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint cost = 0;\\n\\n\\t\\t\\t\\tfor(int i = 0; i < price.Count; i++)\\n\\t\\t\\t\\t\\tcost += (price[i] * needs[i]);\\n\\n\\t\\t\\t\\treturn cost;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic (bool, int) CheckIfApplicable(IList<int> special, IList<int> needs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = 0; i < needs.Count; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (needs[i] < special[i])\\n\\t\\t\\t\\t\\t\\treturn (false, 0);\\n\\n\\t\\t\\t\\t\\tneeds[i] -= special[i];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn (true, special[special.Count - 1]);\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [],
                "code": "class Solution\\n\\t\\t{\\n\\t\\t\\tpublic int ShoppingOffers(IList<int> price, IList<IList<int>> special, IList<int> needs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint cost = GetCost(price, needs);\\n\\n\\t\\t\\t\\tif (cost == 0)\\n\\t\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t\\tfor(int i = 0; i < special.Count; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tIList<int> temp = needs.ToList();\\n\\t\\t\\t\\t\\t(bool, int) res = CheckIfApplicable(special[i], temp);\\n\\n\\t\\t\\t\\t\\tif (res.Item1)\\n\\t\\t\\t\\t\\t\\tcost = Math.Min(cost, ShoppingOffers(price, special, temp) + res.Item2);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1394489,
                "title": "java-top-down-approach-with-memoization",
                "content": "```\\n\\nclass Solution {\\n    String createKey(List<Integer> needs) {\\n        String res = new String();\\n        for(Integer i : needs) {\\n            res+=Integer.toString(i)+\"_\";\\n        }\\n        return res;\\n    }\\n    int findMinBuyCost(List<Integer> price, List<List<Integer>> special, List<Integer> needs, Map<String, Integer> dp ) {\\n        String key = createKey(needs);\\n        if(dp.containsKey(key)) {\\n            return dp.get(key);\\n        }\\n        int maxPrice = 0, offerPrice = Integer.MAX_VALUE;\\n        for(int i = 0;i<price.size();i++) {\\n            maxPrice+= needs.get(i) * price.get(i);\\n        }\\n            for(int j = 0; j<special.size();j++) {\\n                boolean canAvailOffer = true;\\n                List<Integer> newNeed = new ArrayList<>();\\n                for(int k = 0;k<needs.size();k++) {\\n                    if(special.get(j).get(k) > needs.get(k)) {\\n                        canAvailOffer = false;\\n                        break;\\n                    } \\n                    newNeed.add(needs.get(k) - special.get(j).get(k));\\n                }\\n                if(canAvailOffer) {\\n                    offerPrice = Math.min(offerPrice, special.get(j).get(needs.size()) + findMinBuyCost(price, special, newNeed, dp));\\n                }\\n            }\\n        dp.put(key, Math.min(maxPrice, offerPrice));\\n        return dp.get(key);\\n    }\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        Map<String, Integer> dp = new HashMap<>();\\n        return findMinBuyCost(price, special, needs, dp);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    String createKey(List<Integer> needs) {\\n        String res = new String();\\n        for(Integer i : needs) {\\n            res+=Integer.toString(i)+\"_\";\\n        }\\n        return res;\\n    }\\n    int findMinBuyCost(List<Integer> price, List<List<Integer>> special, List<Integer> needs, Map<String, Integer> dp ) {\\n        String key = createKey(needs);\\n        if(dp.containsKey(key)) {\\n            return dp.get(key);\\n        }\\n        int maxPrice = 0, offerPrice = Integer.MAX_VALUE;\\n        for(int i = 0;i<price.size();i++) {\\n            maxPrice+= needs.get(i) * price.get(i);\\n        }\\n            for(int j = 0; j<special.size();j++) {\\n                boolean canAvailOffer = true;\\n                List<Integer> newNeed = new ArrayList<>();\\n                for(int k = 0;k<needs.size();k++) {\\n                    if(special.get(j).get(k) > needs.get(k)) {\\n                        canAvailOffer = false;\\n                        break;\\n                    } \\n                    newNeed.add(needs.get(k) - special.get(j).get(k));\\n                }\\n                if(canAvailOffer) {\\n                    offerPrice = Math.min(offerPrice, special.get(j).get(needs.size()) + findMinBuyCost(price, special, newNeed, dp));\\n                }\\n            }\\n        dp.put(key, Math.min(maxPrice, offerPrice));\\n        return dp.get(key);\\n    }\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        Map<String, Integer> dp = new HashMap<>();\\n        return findMinBuyCost(price, special, needs, dp);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375901,
                "title": "c-recursion-o-1-extra-space-faster-than-100-0ms-explanation",
                "content": "Idea is to try every offer and reduce the quantity required in a particular offer. Though the solution of memoization must be fast but due to some checks it makes the solution fastest. So we don\\'t need to store the every state, which will save space for us.\\n\\n```\\nclass Solution {\\npublic:\\n    int n,minPrice;\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        minPrice =0;\\n        n = price.size();\\n        int rem = 0;\\n        for(int i=0;i<n;i++) {\\n            rem+=needs[i];\\n            minPrice+=price[i]*needs[i];\\n        }\\n        applyOffers(price,special,needs,0,rem);\\n        return minPrice;\\n    }\\n    \\n    void applyOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs,int sum,int remaining) {\\n        if(remaining<0 || sum>=minPrice) return;\\n        if(remaining == 0) {\\n            minPrice = min(minPrice,sum);\\n            return;\\n        }\\n        vector<int> needTemp;\\n\\t\\t\\n\\t\\t// try each possible offer\\n        for(int i=0;i<special.size();i++) {\\n            int offerItems = 0;\\n            bool valid = true;\\n            needTemp.clear();\\n\\t\\t\\t\\n\\t\\t\\t// Check if we have the required quantity in the offer\\n            for(int j=0;j<n;j++) {\\n                if(special[i][j]>needs[j]) {\\n                    valid = false;\\n                    break;\\n                }\\n                needTemp.push_back(needs[j]-special[i][j]);\\n                offerItems+=special[i][j];\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// If valid offer then call the function and pass the remaining items;\\n            if(valid) {\\n                applyOffers(price,special,needTemp,sum+special[i][n],remaining-offerItems);\\n            }\\n        }\\n\\t\\t\\n\\t\\t// check price without any offer\\n        int temp = 0;\\n        for(int i=0;i<n;i++) {\\n            temp+=price[i]*needs[i];\\n        }\\n        minPrice = min(minPrice,temp+sum);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/1c40a18b-0b1b-44b6-8f4f-d0f06dbdf671_1627800635.162455.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,minPrice;\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        minPrice =0;\\n        n = price.size();\\n        int rem = 0;\\n        for(int i=0;i<n;i++) {\\n            rem+=needs[i];\\n            minPrice+=price[i]*needs[i];\\n        }\\n        applyOffers(price,special,needs,0,rem);\\n        return minPrice;\\n    }\\n    \\n    void applyOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs,int sum,int remaining) {\\n        if(remaining<0 || sum>=minPrice) return;\\n        if(remaining == 0) {\\n            minPrice = min(minPrice,sum);\\n            return;\\n        }\\n        vector<int> needTemp;\\n\\t\\t\\n\\t\\t// try each possible offer\\n        for(int i=0;i<special.size();i++) {\\n            int offerItems = 0;\\n            bool valid = true;\\n            needTemp.clear();\\n\\t\\t\\t\\n\\t\\t\\t// Check if we have the required quantity in the offer\\n            for(int j=0;j<n;j++) {\\n                if(special[i][j]>needs[j]) {\\n                    valid = false;\\n                    break;\\n                }\\n                needTemp.push_back(needs[j]-special[i][j]);\\n                offerItems+=special[i][j];\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// If valid offer then call the function and pass the remaining items;\\n            if(valid) {\\n                applyOffers(price,special,needTemp,sum+special[i][n],remaining-offerItems);\\n            }\\n        }\\n\\t\\t\\n\\t\\t// check price without any offer\\n        int temp = 0;\\n        for(int i=0;i<n;i++) {\\n            temp+=price[i]*needs[i];\\n        }\\n        minPrice = min(minPrice,temp+sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297495,
                "title": "c-backtracking-easy",
                "content": "```\\nint minshoppingprice=INT_MAX;\\n    void minshopping(vector<int>&price,vector<vector<int>>&special,vector<int>&needs,int cost,int i)\\n    {\\n      \\n        if(i==special.size())\\n        {\\n              \\n            for(int k=0;k<needs.size();++k)\\n            {\\n                if(needs[k])\\n                {\\n                    cost=cost+price[k]*needs[k];\\n                }\\n                \\n            }\\n            minshoppingprice=min(minshoppingprice,cost);\\n            return;\\n        }\\n        \\n      \\n        vector<int>reducedn;\\n        for(int j=0;j<special[i].size()-1;++j)\\n        {\\n            if(special[i][j]<=needs[j])\\n            {\\n                reducedn.push_back(needs[j]-special[i][j]);\\n            }\\n        }\\n        \\n        if(needs.size()==reducedn.size())\\n        {\\n            minshopping(price,special,reducedn,cost+special[i][needs.size()],i);            \\n            \\n        }\\n        \\n        minshopping(price,special,needs,cost,i+1);\\n            \\n            return;\\n            \\n            \\n            \\n            \\n            \\n        }\\n        \\n        \\n    \\n    \\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n        minshopping(price,special,needs,0,0);\\n        cout<<minshoppingprice;\\n        return minshoppingprice;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint minshoppingprice=INT_MAX;\\n    void minshopping(vector<int>&price,vector<vector<int>>&special,vector<int>&needs,int cost,int i)\\n    {\\n      \\n        if(i==special.size())\\n        {\\n              \\n            for(int k=0;k<needs.size();++k)\\n            {\\n                if(needs[k])\\n                {\\n                    cost=cost+price[k]*needs[k];\\n                }\\n                \\n            }\\n            minshoppingprice=min(minshoppingprice,cost);\\n            return;\\n        }\\n        \\n      \\n        vector<int>reducedn;\\n        for(int j=0;j<special[i].size()-1;++j)\\n        {\\n            if(special[i][j]<=needs[j])\\n            {\\n                reducedn.push_back(needs[j]-special[i][j]);\\n            }\\n        }\\n        \\n        if(needs.size()==reducedn.size())\\n        {\\n            minshopping(price,special,reducedn,cost+special[i][needs.size()],i);            \\n            \\n        }\\n        \\n        minshopping(price,special,needs,cost,i+1);\\n            \\n            return;\\n            \\n            \\n            \\n            \\n            \\n        }\\n        \\n        \\n    \\n    \\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n        minshopping(price,special,needs,0,0);\\n        cout<<minshoppingprice;\\n        return minshoppingprice;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1272678,
                "title": "java-dynamic-programming-with-immutable-keys",
                "content": "My solutions timed out for this problem, so I won\\'t be sharing them here. Instead I referred to the Leetcode solutions and typed the code for their approach. While the approach is good, for the second solution, where they optimize using memoization, I found one bad coding style that could lead to errors in the future.\\n\\nThe second leetcode solution used HashMap as a memo table, with the keys being the needs ArrayList itself. ArrayList is a mutable data structure, and it is highly recommended to use only immutable data structures as a key for HashMap.\\n\\nSo, here is my solution with the only modification being using String (immutable) as key for the HashMap.\\n\\n# Solution\\n```java\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        Map<String, Integer> memo = new HashMap<>();\\n        return recurse(price, special, needs, memo);\\n    }\\n    \\n    private int recurse(List<Integer> price, List<List<Integer>> special, List<Integer> needs, Map<String, Integer> memo) {\\n        // check in dp table by creating unique string\\n        String key = getKey(needs);\\n        if (memo.containsKey(key))\\n            return memo.get(key);\\n        \\n        // 1. fulfill the needs without any offers\\n        int res = dot(price, needs);\\n        \\n        // 2. fulfill the needs using the offers\\n        for (List<Integer> offer: special) {\\n            \\n            // copy the needs array\\n            List<Integer> clone  = new ArrayList<>(needs);\\n            \\n            // appply the offer on clone\\n            int i = 0;\\n            for (i = 0; i < needs.size(); i++) {\\n                clone.set(i, needs.get(i) - offer.get(i));\\n                if (clone.get(i) < 0)\\n                    break;\\n            }\\n            \\n            // find answer for the second case\\n            if (i == needs.size())\\n                res = Math.min(res, \\n                               offer.get(offer.size() - 1) + recurse(price, special, clone, memo));\\n        }\\n                \\n        memo.put(key, res);\\n        return res;\\n    }\\n    \\n    private int dot(List<Integer> a, List<Integer> b) {\\n        // calculate dot product of two arrays\\n        int res = 0;\\n        for (int i = 0; i < a.size(); i++)\\n            res += (a.get(i) * b.get(i));\\n        \\n        return res;\\n    }\\n    \\n    private String getKey(List<Integer> arr) {\\n        // convert array to a unique string\\n        StringBuilder sb = new StringBuilder();\\n        for (int ele: arr)\\n            sb.append(ele);\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        Map<String, Integer> memo = new HashMap<>();\\n        return recurse(price, special, needs, memo);\\n    }\\n    \\n    private int recurse(List<Integer> price, List<List<Integer>> special, List<Integer> needs, Map<String, Integer> memo) {\\n        // check in dp table by creating unique string\\n        String key = getKey(needs);\\n        if (memo.containsKey(key))\\n            return memo.get(key);\\n        \\n        // 1. fulfill the needs without any offers\\n        int res = dot(price, needs);\\n        \\n        // 2. fulfill the needs using the offers\\n        for (List<Integer> offer: special) {\\n            \\n            // copy the needs array\\n            List<Integer> clone  = new ArrayList<>(needs);\\n            \\n            // appply the offer on clone\\n            int i = 0;\\n            for (i = 0; i < needs.size(); i++) {\\n                clone.set(i, needs.get(i) - offer.get(i));\\n                if (clone.get(i) < 0)\\n                    break;\\n            }\\n            \\n            // find answer for the second case\\n            if (i == needs.size())\\n                res = Math.min(res, \\n                               offer.get(offer.size() - 1) + recurse(price, special, clone, memo));\\n        }\\n                \\n        memo.put(key, res);\\n        return res;\\n    }\\n    \\n    private int dot(List<Integer> a, List<Integer> b) {\\n        // calculate dot product of two arrays\\n        int res = 0;\\n        for (int i = 0; i < a.size(); i++)\\n            res += (a.get(i) * b.get(i));\\n        \\n        return res;\\n    }\\n    \\n    private String getKey(List<Integer> arr) {\\n        // convert array to a unique string\\n        StringBuilder sb = new StringBuilder();\\n        for (int ele: arr)\\n            sb.append(ele);\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216773,
                "title": "help-backtracking-solution-works-but-memoization-doesn-t",
                "content": "Can anyone help me figure out why memoization doesn\\'t work. i denotes the ith offer. curr = currently the items we have, temp is clone for curr + add items from new offer\\n```\\n//This is memoized solution (doesn\\'t work)\\nclass Solution {\\npublic:\\n    map<vector<int>, int> mp;\\n    int maxPrice(vector<int> price, vector<vector<int>> special, vector<int> needs, vector<int> curr, int i, int numOff) {\\n        if(i >= numOff) {\\n            int ans = 0;\\n            for(int index = 0; index < needs.size(); index++) {\\n                ans += ((needs[index] - curr[index]) * price[index]);\\n            }\\n            return ans;\\n        }\\n        if(mp.count(curr) > 0) {\\n            return mp[curr];\\n        }\\n        bool found = true;\\n        for(int index = 0; index < needs.size(); index++) {\\n            if(curr[index] + special[i][index] > needs[index]) {\\n                found = false;\\n                break;\\n            }\\n        }\\n        int a = INT_MAX, b = INT_MAX;\\n        if(found) {\\n            vector<int> temp(needs.size());\\n            for(int index = 0; index < needs.size(); index++) {\\n                temp[index] = curr[index] + special[i][index];\\n            }\\n            a = special[i][needs.size()] + maxPrice(price, special, needs, temp, i, numOff);\\n        }\\n        b = maxPrice(price, special, needs, curr, i + 1, numOff);\\n        return mp[curr] = min(a, b);\\n    }\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        vector<int> curr(needs.size(), 0);\\n        return maxPrice(price, special, needs, curr, 0, special.size());\\n    }\\n};\\n```\\n\\n```\\n//This is backtracking without memoization (works)\\nclass Solution {\\npublic:\\n    int maxPrice(vector<int> price, vector<vector<int>> special, vector<int> needs, vector<int> curr, int i, int numOff) {\\n        if(i >= numOff) {\\n            int ans = 0;\\n            for(int index = 0; index < needs.size(); index++) {\\n                ans += ((needs[index] - curr[index]) * price[index]);\\n            }\\n            return ans;\\n        }\\n        bool found = true;\\n        for(int index = 0; index < needs.size(); index++) {\\n            if(curr[index] + special[i][index] > needs[index]) {\\n                found = false;\\n                break;\\n            }\\n        }\\n        int a = INT_MAX, b = INT_MAX;\\n        if(found) {\\n            vector<int> temp(needs.size());\\n            for(int index = 0; index < needs.size(); index++) {\\n                temp[index] = curr[index] + special[i][index];\\n            }\\n            a = special[i][needs.size()] + maxPrice(price, special, needs, temp, i, numOff);\\n        }\\n        b = maxPrice(price, special, needs, curr, i + 1, numOff);\\n        return min(a, b);\\n    }\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        vector<int> curr(needs.size(), 0);\\n        return maxPrice(price, special, needs, curr, 0, special.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n//This is memoized solution (doesn\\'t work)\\nclass Solution {\\npublic:\\n    map<vector<int>, int> mp;\\n    int maxPrice(vector<int> price, vector<vector<int>> special, vector<int> needs, vector<int> curr, int i, int numOff) {\\n        if(i >= numOff) {\\n            int ans = 0;\\n            for(int index = 0; index < needs.size(); index++) {\\n                ans += ((needs[index] - curr[index]) * price[index]);\\n            }\\n            return ans;\\n        }\\n        if(mp.count(curr) > 0) {\\n            return mp[curr];\\n        }\\n        bool found = true;\\n        for(int index = 0; index < needs.size(); index++) {\\n            if(curr[index] + special[i][index] > needs[index]) {\\n                found = false;\\n                break;\\n            }\\n        }\\n        int a = INT_MAX, b = INT_MAX;\\n        if(found) {\\n            vector<int> temp(needs.size());\\n            for(int index = 0; index < needs.size(); index++) {\\n                temp[index] = curr[index] + special[i][index];\\n            }\\n            a = special[i][needs.size()] + maxPrice(price, special, needs, temp, i, numOff);\\n        }\\n        b = maxPrice(price, special, needs, curr, i + 1, numOff);\\n        return mp[curr] = min(a, b);\\n    }\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        vector<int> curr(needs.size(), 0);\\n        return maxPrice(price, special, needs, curr, 0, special.size());\\n    }\\n};\\n```\n```\\n//This is backtracking without memoization (works)\\nclass Solution {\\npublic:\\n    int maxPrice(vector<int> price, vector<vector<int>> special, vector<int> needs, vector<int> curr, int i, int numOff) {\\n        if(i >= numOff) {\\n            int ans = 0;\\n            for(int index = 0; index < needs.size(); index++) {\\n                ans += ((needs[index] - curr[index]) * price[index]);\\n            }\\n            return ans;\\n        }\\n        bool found = true;\\n        for(int index = 0; index < needs.size(); index++) {\\n            if(curr[index] + special[i][index] > needs[index]) {\\n                found = false;\\n                break;\\n            }\\n        }\\n        int a = INT_MAX, b = INT_MAX;\\n        if(found) {\\n            vector<int> temp(needs.size());\\n            for(int index = 0; index < needs.size(); index++) {\\n                temp[index] = curr[index] + special[i][index];\\n            }\\n            a = special[i][needs.size()] + maxPrice(price, special, needs, temp, i, numOff);\\n        }\\n        b = maxPrice(price, special, needs, curr, i + 1, numOff);\\n        return min(a, b);\\n    }\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        vector<int> curr(needs.size(), 0);\\n        return maxPrice(price, special, needs, curr, 0, special.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188415,
                "title": "python3-simple-and-fast-iteration",
                "content": "```python\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        # we make sure that the special offers can be used, and that it offers a discount, otherwise we remove it\\n        good_offers = set()\\n        for offer in special:\\n            can_use = all(a - b >= 0 for a, b in zip(needs, offer))\\n            discount = sum(p * quantity for p, quantity in zip(price, offer)) > offer[-1]\\n            if can_use and discount:\\n                good_offers.add(tuple(offer))\\n\\n        # first we get all the specials\\n        paths = {(tuple(needs), 0)}\\n        seen = set()\\n        while True:\\n            new_paths = set()\\n            for path, cost in paths:\\n                if path in seen:\\n                    continue\\n                seen.add(path)\\n                for offer in good_offers:\\n                    if all(a - b >= 0 for a, b in zip(path, offer)):  # no need to slice offer here\\n                        new_path = tuple(path[i] - offer[i] for i in range(len(path)))\\n                        new_paths.add((new_path, cost + offer[-1]))\\n            if not new_paths:\\n                break\\n            paths.update(new_paths)\\n\\n        # fill the remainder of the offer, return the minimum\\n        return min(sum(path[i] * price[i] for i in range(len(path))) + cost for path, cost in paths) if paths else 0\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        # we make sure that the special offers can be used, and that it offers a discount, otherwise we remove it\\n        good_offers = set()\\n        for offer in special:\\n            can_use = all(a - b >= 0 for a, b in zip(needs, offer))\\n            discount = sum(p * quantity for p, quantity in zip(price, offer)) > offer[-1]\\n            if can_use and discount:\\n                good_offers.add(tuple(offer))\\n\\n        # first we get all the specials\\n        paths = {(tuple(needs), 0)}\\n        seen = set()\\n        while True:\\n            new_paths = set()\\n            for path, cost in paths:\\n                if path in seen:\\n                    continue\\n                seen.add(path)\\n                for offer in good_offers:\\n                    if all(a - b >= 0 for a, b in zip(path, offer)):  # no need to slice offer here\\n                        new_path = tuple(path[i] - offer[i] for i in range(len(path)))\\n                        new_paths.add((new_path, cost + offer[-1]))\\n            if not new_paths:\\n                break\\n            paths.update(new_paths)\\n\\n        # fill the remainder of the offer, return the minimum\\n        return min(sum(path[i] * price[i] for i in range(len(path))) + cost for path, cost in paths) if paths else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142930,
                "title": "java-simple-recursion",
                "content": "\\tpublic int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs)\\n\\t\\t{\\n\\t\\t\\tint localMin = getDirectBuyCost(price, needs);\\n\\n\\t\\t\\tfor (List<Integer> offer : special)\\n\\t\\t\\t{\\n\\t\\t\\t\\tList<Integer> needsLeft = checkNeeds(needs, offer);\\n\\t\\t\\t\\tif (!needsLeft.isEmpty()) {\\n\\t\\t\\t\\t\\tlocalMin = Math.min(localMin, offer.get(offer.size() - 1) + shoppingOffers(price, special, needsLeft));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn localMin;\\n\\t\\t}\\n\\n\\t\\tprivate int getDirectBuyCost(List<Integer> price, List<Integer> needs)\\n\\t\\t{\\n\\t\\t\\tint cost = 0;\\n\\t\\t\\tfor (int i = 0; i < price.size(); ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcost += (price.get(i) * needs.get(i));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn cost;\\n\\t\\t}\\n\\n\\t\\tprivate List<Integer> checkNeeds(List<Integer> needs, List<Integer> offer)\\n\\t\\t{\\n\\t\\t\\tint len = needs.size();\\n\\t\\t\\tList<Integer> needsLeft = new ArrayList<>();\\n\\t\\t\\tfor (int i = 0; i < len; ++i) {\\n\\t\\t\\t\\tint left = needs.get(i) - offer.get(i);\\n\\t\\t\\t\\tif (left < 0) return new ArrayList<>();\\n\\t\\t\\t\\tneedsLeft.add(left);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn needsLeft;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tpublic int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs)\\n\\t\\t{\\n\\t\\t\\tint localMin = getDirectBuyCost(price, needs);\\n\\n\\t\\t\\tfor (List<Integer> offer : special)\\n\\t\\t\\t{\\n\\t\\t\\t\\tList<Integer> needsLeft = checkNeeds(needs, offer);\\n\\t\\t\\t\\tif (!needsLeft.isEmpty()) {\\n\\t\\t\\t\\t\\tlocalMin = Math.min(localMin, offer.get(offer.size() - 1) + shoppingOffers(price, special, needsLeft));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn localMin;\\n\\t\\t}\\n\\n\\t\\tprivate int getDirectBuyCost(List<Integer> price, List<Integer> needs)\\n\\t\\t{\\n\\t\\t\\tint cost = 0;\\n\\t\\t\\tfor (int i = 0; i < price.size(); ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcost += (price.get(i) * needs.get(i));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn cost;\\n\\t\\t}\\n\\n\\t\\tprivate List<Integer> checkNeeds(List<Integer> needs, List<Integer> offer)\\n\\t\\t{\\n\\t\\t\\tint len = needs.size();\\n\\t\\t\\tList<Integer> needsLeft = new ArrayList<>();\\n\\t\\t\\tfor (int i = 0; i < len; ++i) {\\n\\t\\t\\t\\tint left = needs.get(i) - offer.get(i);\\n\\t\\t\\t\\tif (left < 0) return new ArrayList<>();\\n\\t\\t\\t\\tneedsLeft.add(left);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn needsLeft;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1090675,
                "title": "intuitive-approach-by-using-lru-cache-and-recursion",
                "content": "```\\nimport sys\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        def price_without_so(needs):\\n            return sum(list(map(lambda t: t[0]*t[1], zip(price, needs))))\\n            \\n        def meet_need(needs, so):\\n            return all(map(lambda t: t[0]>=t[1], zip(needs, so[:-1])))\\n        \\n        def deduct_so(needs, so):\\n            deduct_list = []\\n            for i, j in zip(needs, so):\\n                deduct_list.append(i-j)\\n                \\n            return tuple(deduct_list)\\n            \\n        @lru_cache\\n        def search_optm_price(needs):\\n            optm_price = price_without_so(needs)\\n            for so in special:\\n                if meet_need(needs, so):\\n                    deduct_list = deduct_so(needs, so)\\n                    optm_price = min(optm_price, so[-1]+search_optm_price(deduct_list))\\n        \\n            return optm_price\\n        \\n        return search_optm_price(tuple(needs))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport sys\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        def price_without_so(needs):\\n            return sum(list(map(lambda t: t[0]*t[1], zip(price, needs))))\\n            \\n        def meet_need(needs, so):\\n            return all(map(lambda t: t[0]>=t[1], zip(needs, so[:-1])))\\n        \\n        def deduct_so(needs, so):\\n            deduct_list = []\\n            for i, j in zip(needs, so):\\n                deduct_list.append(i-j)\\n                \\n            return tuple(deduct_list)\\n            \\n        @lru_cache\\n        def search_optm_price(needs):\\n            optm_price = price_without_so(needs)\\n            for so in special:\\n                if meet_need(needs, so):\\n                    deduct_list = deduct_so(needs, so)\\n                    optm_price = min(optm_price, so[-1]+search_optm_price(deduct_list))\\n        \\n            return optm_price\\n        \\n        return search_optm_price(tuple(needs))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089377,
                "title": "backtracking-and-the-code-can-also-be-used-as-a-base-for-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n        for(int i = 0; i < needs.size(); i++)\\n            ans += price[i] * needs[i];\\n        \\n        solve(price, special, needs, 0);\\n        return ans;\\n    }\\n    \\n    void solve(vector<int>& price, vector<vector<int>>& special, vector<int> needs, int cost)\\n    {\\n        if(check(needs))\\n        {\\n            ans = min(ans, cost);\\n            return;\\n        }\\n        \\n        if(cost >= ans)\\n            return;\\n        \\n        bool flag = false;\\n        for(int i = 0; i < special.size(); i++)\\n        {\\n            vector <int> temp = needs;\\n            for(int j = 0; j < needs.size(); j++)\\n            {\\n                needs[j] = needs[j] - special[i][j];\\n                \\n                if(needs[j] < 0)\\n                {\\n                    flag = true;\\n                    needs = temp;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag)\\n            {\\n                flag = false;\\n                continue;\\n            }\\n            \\n            solve(price, special, needs, cost + special[i].back());\\n            needs = temp;\\n            \\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < needs.size(); i++)\\n        {\\n            int x = needs[i];\\n            needs[i] = 0;\\n            \\n            res += x * price[i];\\n        }\\n        \\n        solve(price, special, needs, cost + res);\\n        \\n    }//[1,2,1]\\n     //[2,3,4]\\n    bool check(vector <int>& needs)\\n    {\\n        int count0 = count(needs.begin(), needs.end(), 0);\\n        \\n        return count0 == needs.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n        for(int i = 0; i < needs.size(); i++)\\n            ans += price[i] * needs[i];\\n        \\n        solve(price, special, needs, 0);\\n        return ans;\\n    }\\n    \\n    void solve(vector<int>& price, vector<vector<int>>& special, vector<int> needs, int cost)\\n    {\\n        if(check(needs))\\n        {\\n            ans = min(ans, cost);\\n            return;\\n        }\\n        \\n        if(cost >= ans)\\n            return;\\n        \\n        bool flag = false;\\n        for(int i = 0; i < special.size(); i++)\\n        {\\n            vector <int> temp = needs;\\n            for(int j = 0; j < needs.size(); j++)\\n            {\\n                needs[j] = needs[j] - special[i][j];\\n                \\n                if(needs[j] < 0)\\n                {\\n                    flag = true;\\n                    needs = temp;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag)\\n            {\\n                flag = false;\\n                continue;\\n            }\\n            \\n            solve(price, special, needs, cost + special[i].back());\\n            needs = temp;\\n            \\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < needs.size(); i++)\\n        {\\n            int x = needs[i];\\n            needs[i] = 0;\\n            \\n            res += x * price[i];\\n        }\\n        \\n        solve(price, special, needs, cost + res);\\n        \\n    }//[1,2,1]\\n     //[2,3,4]\\n    bool check(vector <int>& needs)\\n    {\\n        int count0 = count(needs.begin(), needs.end(), 0);\\n        \\n        return count0 == needs.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059644,
                "title": "javascript-100-simply-solution",
                "content": "All you need to do is just check the total regular price vs all the special prices applicable in each steps and then return the minimum price.\\n\\n```\\nvar shoppingOffers = function(price, special, needs) {\\n    const check = (need) => {\\n        let pay = 0;\\n        for (let i = 0; i < price.length; i++) {\\n            pay += price[i] * need[i];\\n        }\\n\\n        for(let spe of special) {   \\n            let canUse = true;\\n            for (let i = 0; i < spe.length; i++) {\\n                if (need[i] < spe[i]) {\\n                    canUse = false;\\n                    break;\\n                }\\n            }\\n            if (canUse) {\\n                let newNeed = [];\\n                for(let i = 0; i < spe.length - 1; i++) {\\n                    newNeed.push(need[i] - spe[i]);\\n                }\\n                let totalPrice = spe[spe.length - 1] + check(newNeed);\\n                if (totalPrice < pay) {\\n                    pay = totalPrice;\\n                }\\n            }\\n        }\\n\\n        return pay;\\n    }\\n\\n    return check(needs);\\n};",
                "solutionTags": [],
                "code": "All you need to do is just check the total regular price vs all the special prices applicable in each steps and then return the minimum price.\\n\\n```\\nvar shoppingOffers = function(price, special, needs) {\\n    const check = (need) => {\\n        let pay = 0;\\n        for (let i = 0; i < price.length; i++) {\\n            pay += price[i] * need[i];\\n        }\\n\\n        for(let spe of special) {   \\n            let canUse = true;\\n            for (let i = 0; i < spe.length; i++) {\\n                if (need[i] < spe[i]) {\\n                    canUse = false;\\n                    break;\\n                }\\n            }\\n            if (canUse) {\\n                let newNeed = [];\\n                for(let i = 0; i < spe.length - 1; i++) {\\n                    newNeed.push(need[i] - spe[i]);\\n                }\\n                let totalPrice = spe[spe.length - 1] + check(newNeed);\\n                if (totalPrice < pay) {\\n                    pay = totalPrice;\\n                }\\n            }\\n        }\\n\\n        return pay;\\n    }\\n\\n    return check(needs);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1026309,
                "title": "python-easy-to-understand-memoization-dhruv-vavliya",
                "content": "```\\n# written by : Dhruv vavliya\\n\\n\\nprice = [2,3,4]\\nspecial = [[1,1,0,4],[2,2,1,9]]\\nneeds = [1,2,1]\\n\\ndef is_valid(sale,needs):\\n    return all([ needs[i] >= sale[i] for i in range(len(needs))])          # if in sale ,gives more than recuirement\\n\\ndef go(price,special,needs,dp):\\n\\n    key = tuple(needs)\\n    if key in dp:\\n        return dp[key]\\n    ans = float(\\'inf\\')\\n\\n    for sale in special:                                                        # offer take or not\\n        if is_valid(sale,needs):\\n            remain = [ needs[i] - sale[i] for i in range(len(needs)) ]          # after taking offer ,remain things to buy\\n            ans = min( ans , sale[-1] + go(price,special,remain,dp) )           # go to buy remain things\\n    ans = min(ans ,sum( [needs[i]*price[i] for i in range(len(needs))] ))       # eventually ,buy remaining things saperately\\n    dp[key] = ans\\n    return ans\\n\\ndef shopping_offers(price,special,needs):\\n    dp = {}\\n    return go(price,special,needs,dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n# written by : Dhruv vavliya\\n\\n\\nprice = [2,3,4]\\nspecial = [[1,1,0,4],[2,2,1,9]]\\nneeds = [1,2,1]\\n\\ndef is_valid(sale,needs):\\n    return all([ needs[i] >= sale[i] for i in range(len(needs))])          # if in sale ,gives more than recuirement\\n\\ndef go(price,special,needs,dp):\\n\\n    key = tuple(needs)\\n    if key in dp:\\n        return dp[key]\\n    ans = float(\\'inf\\')\\n\\n    for sale in special:                                                        # offer take or not\\n        if is_valid(sale,needs):\\n            remain = [ needs[i] - sale[i] for i in range(len(needs)) ]          # after taking offer ,remain things to buy\\n            ans = min( ans , sale[-1] + go(price,special,remain,dp) )           # go to buy remain things\\n    ans = min(ans ,sum( [needs[i]*price[i] for i in range(len(needs))] ))       # eventually ,buy remaining things saperately\\n    dp[key] = ans\\n    return ans\\n\\ndef shopping_offers(price,special,needs):\\n    dp = {}\\n    return go(price,special,needs,dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1010717,
                "title": "swift-readable-dfs-with-memoization-and-comments",
                "content": "Time Complexity - O(N^k) where N is the number of specials and k is the number of items\\nSpace Complexity - O(k)\\n```\\nclass Solution {\\n    func shoppingOffers(_ price: [Int], _ special: [[Int]], _ needs: [Int]) -> Int {\\n        \\n        // Gets the price for the items if no special is used and the individual item price\\n        // is used\\n        func getPriceBuyingIndividually(for items: [Int]) -> Int {\\n            var totalPrice = 0\\n            for i in 0..<items.count {\\n                totalPrice += items[i] * price[i]\\n            }\\n            return totalPrice\\n        }\\n        \\n        // Checks if the offer can be applied to the needs list\\n        func isValid(_ offer: [Int], _ req: [Int]) -> Bool {\\n            for i in 0..<req.count {\\n                if req[i] < offer[i] {\\n                    return false\\n                }\\n            }\\n            return true\\n        }\\n        \\n        // Returns the updated needs list once the given offer is applied\\n        func update( _ req: [Int], by offer: [Int]) -> [Int] {\\n            var cReq = req\\n            for i in 0..<req.count {\\n                cReq[i] -= offer[i]\\n            }\\n            return cReq\\n        }\\n        \\n        func helper(_ remNeeds: [Int], _ cache: inout [[Int]:Int]) -> Int {\\n            // Chech the cache\\n            if let val = cache[remNeeds] {\\n                return val\\n            }\\n            \\n            var minSpent = getPriceBuyingIndividually(for: remNeeds)\\n            \\n            // Check all the valid specials\\n            for offer in special where isValid(offer, remNeeds) {\\n                minSpent = min(minSpent, offer[offer.count - 1] + helper(update(remNeeds, by: offer), &cache))\\n            }\\n                \\n            // add the result to the cache\\n            cache[remNeeds] = minSpent\\n            return minSpent\\n        }\\n        \\n        var cache = [[Int]:Int]()\\n        return helper(needs, &cache)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func shoppingOffers(_ price: [Int], _ special: [[Int]], _ needs: [Int]) -> Int {\\n        \\n        // Gets the price for the items if no special is used and the individual item price\\n        // is used\\n        func getPriceBuyingIndividually(for items: [Int]) -> Int {\\n            var totalPrice = 0\\n            for i in 0..<items.count {\\n                totalPrice += items[i] * price[i]\\n            }\\n            return totalPrice\\n        }\\n        \\n        // Checks if the offer can be applied to the needs list\\n        func isValid(_ offer: [Int], _ req: [Int]) -> Bool {\\n            for i in 0..<req.count {\\n                if req[i] < offer[i] {\\n                    return false\\n                }\\n            }\\n            return true\\n        }\\n        \\n        // Returns the updated needs list once the given offer is applied\\n        func update( _ req: [Int], by offer: [Int]) -> [Int] {\\n            var cReq = req\\n            for i in 0..<req.count {\\n                cReq[i] -= offer[i]\\n            }\\n            return cReq\\n        }\\n        \\n        func helper(_ remNeeds: [Int], _ cache: inout [[Int]:Int]) -> Int {\\n            // Chech the cache\\n            if let val = cache[remNeeds] {\\n                return val\\n            }\\n            \\n            var minSpent = getPriceBuyingIndividually(for: remNeeds)\\n            \\n            // Check all the valid specials\\n            for offer in special where isValid(offer, remNeeds) {\\n                minSpent = min(minSpent, offer[offer.count - 1] + helper(update(remNeeds, by: offer), &cache))\\n            }\\n                \\n            // add the result to the cache\\n            cache[remNeeds] = minSpent\\n            return minSpent\\n        }\\n        \\n        var cache = [[Int]:Int]()\\n        return helper(needs, &cache)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1007508,
                "title": "simple-c-solu-using-bfs-8ms",
                "content": "```\\n// Runtime: 8 ms, faster than 99.13% of C++ online submissions for Shopping Offers.\\n// Memory Usage: 11 MB, less than 67.32% of C++ online submissions for Shopping Offers.\\nclass Solution {\\npublic:\\n    bool check(const vector<int>&A,const vector<int>&B)\\n   {\\n       for(int i=0;i<A.size();++i)\\n       {\\n           if(B[i]>A[i]) return 0;\\n       }\\n       return 1;\\n   }\\n    vector<int> update(const vector<int>&A,const vector<int>&B)\\n    {\\n        vector<int> v(A.size(),0);\\n        for(int i=0;i<A.size();++i)\\n            v[i]=A[i]-B[i];\\n        return v;\\n    }\\nint shoppingOffers(vector<int>& A, vector<vector<int>>& B, vector<int>& n){\\n        int sze = A.size(), ans=0;\\n    \\n        for(int i=0;i<A.size();++i)    // buying all items without offers \\n            ans+=A[i]*n[i];\\n    \\n        queue<pair<vector<int>,int >> q;\\n        q.push({n,0});\\n    \\n        while(!q.empty())\\n        {\\n            pair<vector<int>,int> t = q.front(); \\n            q.pop();\\n            bool updated=1;\\n            for(int i=0;i<B.size();++i)\\n            {\\n                if(check(t.first,B[i]))\\n                {\\n                    vector<int> k = update(t.first,B[i]);\\n                    q.push({k,t.second + B[i][sze]});\\n                    updated = 0; \\n                }\\n            }\\n            if(updated)\\n            {\\n                // we couldnt apply any offer so we have to purchase sole items \\n                // or we have no items left to purchase , in that case we need the cost only\\n                for(int i=0;i<t.first.size();++i)\\n                    t.second +=t.first[i]*A[i];\\n                ans=min(ans,t.second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// Runtime: 8 ms, faster than 99.13% of C++ online submissions for Shopping Offers.\\n// Memory Usage: 11 MB, less than 67.32% of C++ online submissions for Shopping Offers.\\nclass Solution {\\npublic:\\n    bool check(const vector<int>&A,const vector<int>&B)\\n   {\\n       for(int i=0;i<A.size();++i)\\n       {\\n           if(B[i]>A[i]) return 0;\\n       }\\n       return 1;\\n   }\\n    vector<int> update(const vector<int>&A,const vector<int>&B)\\n    {\\n        vector<int> v(A.size(),0);\\n        for(int i=0;i<A.size();++i)\\n            v[i]=A[i]-B[i];\\n        return v;\\n    }\\nint shoppingOffers(vector<int>& A, vector<vector<int>>& B, vector<int>& n){\\n        int sze = A.size(), ans=0;\\n    \\n        for(int i=0;i<A.size();++i)    // buying all items without offers \\n            ans+=A[i]*n[i];\\n    \\n        queue<pair<vector<int>,int >> q;\\n        q.push({n,0});\\n    \\n        while(!q.empty())\\n        {\\n            pair<vector<int>,int> t = q.front(); \\n            q.pop();\\n            bool updated=1;\\n            for(int i=0;i<B.size();++i)\\n            {\\n                if(check(t.first,B[i]))\\n                {\\n                    vector<int> k = update(t.first,B[i]);\\n                    q.push({k,t.second + B[i][sze]});\\n                    updated = 0; \\n                }\\n            }\\n            if(updated)\\n            {\\n                // we couldnt apply any offer so we have to purchase sole items \\n                // or we have no items left to purchase , in that case we need the cost only\\n                for(int i=0;i<t.first.size();++i)\\n                    t.second +=t.first[i]*A[i];\\n                ans=min(ans,t.second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 912554,
                "title": "rust-cheapest-best",
                "content": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn shopping_offers(price: Vec<i32>, mut special: Vec<Vec<i32>>, needs: Vec<i32>) -> i32 {\\n        let mut cache = HashMap::new();\\n        cache.insert(vec![0; needs.len()], 0);\\n\\n        // Remove specials that aren\\'t actually a good deal\\n        special.retain(|v| {\\n            v.last().unwrap() < &(0..price.len()).fold(0, |acc, i| acc + price[i] * v[i])\\n        });\\n\\n        Self::go(&mut cache, &price, special.iter().collect(), needs)\\n    }\\n\\n    fn go(\\n        cache: &mut HashMap<Vec<i32>, i32>,\\n        price: &Vec<i32>,\\n        special: Vec<&Vec<i32>>,\\n        needs: Vec<i32>,\\n    ) -> i32 {\\n        if cache.contains_key(&needs) {\\n            *cache.get(&needs).unwrap()\\n        } else {\\n            let mut min_price = (0..needs.len()).fold(0, |acc, i| acc + needs[i] * price[i]);\\n\\n            let relevant_specials = special\\n                .iter()\\n                .filter(|v| (0..needs.len()).all(|i| v[i] <= needs[i]))\\n                .cloned()\\n                .collect::<Vec<&Vec<i32>>>();\\n\\n            for s in &relevant_specials {\\n                let new_needs = (0..needs.len())\\n                    .map(|i| needs[i] - s[i])\\n                    .collect::<Vec<i32>>();\\n                min_price = min_price.min(\\n                    s.last().unwrap()\\n                        + Self::go(cache, price, relevant_specials.clone(), new_needs),\\n                );\\n            }\\n\\n            cache.insert(needs, min_price);\\n\\n            min_price\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn shopping_offers(price: Vec<i32>, mut special: Vec<Vec<i32>>, needs: Vec<i32>) -> i32 {\\n        let mut cache = HashMap::new();\\n        cache.insert(vec![0; needs.len()], 0);\\n\\n        // Remove specials that aren\\'t actually a good deal\\n        special.retain(|v| {\\n            v.last().unwrap() < &(0..price.len()).fold(0, |acc, i| acc + price[i] * v[i])\\n        });\\n\\n        Self::go(&mut cache, &price, special.iter().collect(), needs)\\n    }\\n\\n    fn go(\\n        cache: &mut HashMap<Vec<i32>, i32>,\\n        price: &Vec<i32>,\\n        special: Vec<&Vec<i32>>,\\n        needs: Vec<i32>,\\n    ) -> i32 {\\n        if cache.contains_key(&needs) {\\n            *cache.get(&needs).unwrap()\\n        } else {\\n            let mut min_price = (0..needs.len()).fold(0, |acc, i| acc + needs[i] * price[i]);\\n\\n            let relevant_specials = special\\n                .iter()\\n                .filter(|v| (0..needs.len()).all(|i| v[i] <= needs[i]))\\n                .cloned()\\n                .collect::<Vec<&Vec<i32>>>();\\n\\n            for s in &relevant_specials {\\n                let new_needs = (0..needs.len())\\n                    .map(|i| needs[i] - s[i])\\n                    .collect::<Vec<i32>>();\\n                min_price = min_price.min(\\n                    s.last().unwrap()\\n                        + Self::go(cache, price, relevant_specials.clone(), new_needs),\\n                );\\n            }\\n\\n            cache.insert(needs, min_price);\\n\\n            min_price\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 893887,
                "title": "java-memoization-using-map",
                "content": "Recursive java solution. \\nWe first evaluated price when each item/needs is bought individually. This is our current cost. \\nNow for each offer first check if offer is valid or not. Offer is only valid if it has all the item <= needs. If an offer is valid take the offer and recursively check for price of rest of needs. Map(cache) is used to cache result .\\n\\n```\\n public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        return shoppingOffers(price, special, needs, new HashMap<>());\\n    }\\n\\n    /**\\n     * Recursively check for minimum price\\n     * @param price\\n     * @param special\\n     * @param needs\\n     * @param cache\\n     * @return\\n     */\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs, HashMap<List<Integer>, Integer> cache) {\\n        int cachedPrice = cache.getOrDefault(needs, -1); // if cache has this result then return the already calculated price for this needs\\n        if (cachedPrice != -1) return cachedPrice;\\n        int total =getIndividualPrice(price, needs); // calculate price if every item is bought individually\\n        for(int i=0;i<special.size();i++){\\n            if(isOfferValid(special.get(i), needs)){ // check if offer is valid\\n\\n                List<Integer> cloned = new ArrayList<>(); // remaining needs after taking this special offer\\n                for(int k = 0; k<needs.size();k++){\\n                    //  update the \\n                    cloned.add(needs.get(k)-special.get(i).get(k)); // update remaining needs \\n                }\\n                // calculate price for rest of needs recursively\\n                int priceWithThisOffer =  shoppingOffers(price, special, cloned, cache)+special.get(i).get(needs.size());\\n                total=Math.min(priceWithThisOffer, total); // total would be minimum of total or price with this offer\\n            }\\n        }\\n\\n        cache.put(needs, total);\\n        return total;\\n    }\\n\\n    public int getIndividualPrice(List<Integer> price, List<Integer> needs) {\\n        int cost = 0;\\n        for (int i = 0; i < needs.size(); i++) {\\n            cost += (needs.get(i) * price.get(i));\\n        }\\n        return cost;\\n    }\\n\\n    // Offer is only valid if each item\\'s count is <= needs\\n    boolean isOfferValid(List<Integer> offer, List<Integer> needs){\\n        for(int i =0;i<needs.size();i++){\\n            if(needs.get(i)<offer.get(i)) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        return shoppingOffers(price, special, needs, new HashMap<>());\\n    }\\n\\n    /**\\n     * Recursively check for minimum price\\n     * @param price\\n     * @param special\\n     * @param needs\\n     * @param cache\\n     * @return\\n     */\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs, HashMap<List<Integer>, Integer> cache) {\\n        int cachedPrice = cache.getOrDefault(needs, -1); // if cache has this result then return the already calculated price for this needs\\n        if (cachedPrice != -1) return cachedPrice;\\n        int total =getIndividualPrice(price, needs); // calculate price if every item is bought individually\\n        for(int i=0;i<special.size();i++){\\n            if(isOfferValid(special.get(i), needs)){ // check if offer is valid\\n\\n                List<Integer> cloned = new ArrayList<>(); // remaining needs after taking this special offer\\n                for(int k = 0; k<needs.size();k++){\\n                    //  update the \\n                    cloned.add(needs.get(k)-special.get(i).get(k)); // update remaining needs \\n                }\\n                // calculate price for rest of needs recursively\\n                int priceWithThisOffer =  shoppingOffers(price, special, cloned, cache)+special.get(i).get(needs.size());\\n                total=Math.min(priceWithThisOffer, total); // total would be minimum of total or price with this offer\\n            }\\n        }\\n\\n        cache.put(needs, total);\\n        return total;\\n    }\\n\\n    public int getIndividualPrice(List<Integer> price, List<Integer> needs) {\\n        int cost = 0;\\n        for (int i = 0; i < needs.size(); i++) {\\n            cost += (needs.get(i) * price.get(i));\\n        }\\n        return cost;\\n    }\\n\\n    // Offer is only valid if each item\\'s count is <= needs\\n    boolean isOfferValid(List<Integer> offer, List<Integer> needs){\\n        for(int i =0;i<needs.size();i++){\\n            if(needs.get(i)<offer.get(i)) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 793908,
                "title": "java-dfs-memoization",
                "content": "```\\nclass Solution {\\n    int n;\\n    List<List<Integer>> special;\\n    List<Integer> price;\\n    List<Integer> needs;\\n    HashMap<List<Integer>, Integer> memo = new HashMap();\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        n = price.size();\\n        this.price = price;\\n        this.needs = needs;\\n        this.special = special;\\n        return dfs();\\n    }\\n    \\n    public int dfs() {\\n        if(memo.containsKey(needs)) return memo.get(needs);\\n\\n        // Let\\'s get the max cost at this point without any offer.\\n        int cost = finalCost();\\n\\n        for(List<Integer> sp: special) {\\n            int size = sp.size();\\n            boolean takeOffer = true;\\n            int offerPrice = sp.get(size - 1);\\n            for(int i = 0; i < size - 1; i++) {\\n                // can\\'t take this offer, quantity limit execeeded\\n                if(needs.get(i) < sp.get(i)) {\\n                    takeOffer = false;\\n                    break;\\n                }\\n            }\\n              \\n            if(takeOffer) {\\n                // backtracking\\n                setNeed(sp, true);\\n                int val = offerPrice + dfs();\\n                cost = Math.min(cost, val);\\n                setNeed(sp, false);\\n            } \\n        }\\n        memo.put(needs, cost);        \\n        return cost;\\n    }\\n    \\n    public int finalCost() {\\n        int cost = 0;\\n        for(int i = 0; i < n; i++) {\\n            int val = price.get(i) * needs.get(i);\\n            cost += val;\\n        }\\n        return cost;\\n    }\\n    \\n    public void setNeed(List<Integer> offer, boolean addOffer) {\\n        for(int i = 0; i < offer.size() - 1; i++) {\\n            int val = 0;\\n            if(addOffer)\\n                val = needs.get(i) - offer.get(i);\\n            else\\n                val = needs.get(i) + offer.get(i);\\n            needs.set(i, val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\n    List<List<Integer>> special;\\n    List<Integer> price;\\n    List<Integer> needs;\\n    HashMap<List<Integer>, Integer> memo = new HashMap();\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        n = price.size();\\n        this.price = price;\\n        this.needs = needs;\\n        this.special = special;\\n        return dfs();\\n    }\\n    \\n    public int dfs() {\\n        if(memo.containsKey(needs)) return memo.get(needs);\\n\\n        // Let\\'s get the max cost at this point without any offer.\\n        int cost = finalCost();\\n\\n        for(List<Integer> sp: special) {\\n            int size = sp.size();\\n            boolean takeOffer = true;\\n            int offerPrice = sp.get(size - 1);\\n            for(int i = 0; i < size - 1; i++) {\\n                // can\\'t take this offer, quantity limit execeeded\\n                if(needs.get(i) < sp.get(i)) {\\n                    takeOffer = false;\\n                    break;\\n                }\\n            }\\n              \\n            if(takeOffer) {\\n                // backtracking\\n                setNeed(sp, true);\\n                int val = offerPrice + dfs();\\n                cost = Math.min(cost, val);\\n                setNeed(sp, false);\\n            } \\n        }\\n        memo.put(needs, cost);        \\n        return cost;\\n    }\\n    \\n    public int finalCost() {\\n        int cost = 0;\\n        for(int i = 0; i < n; i++) {\\n            int val = price.get(i) * needs.get(i);\\n            cost += val;\\n        }\\n        return cost;\\n    }\\n    \\n    public void setNeed(List<Integer> offer, boolean addOffer) {\\n        for(int i = 0; i < offer.size() - 1; i++) {\\n            int val = 0;\\n            if(addOffer)\\n                val = needs.get(i) - offer.get(i);\\n            else\\n                val = needs.get(i) + offer.get(i);\\n            needs.set(i, val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786596,
                "title": "c-dfs-dp-with-high-dimensional-space-saving-approach",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint dfs(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, vector<int>& dp, int j) {\\n\\t\\t// n -> number of items\\n\\t\\tint n = price.size();\\n\\n\\t\\t// curNum -> current items purchased\\n\\t\\tvector<int> curNum(n);\\n\\t\\t\\n\\t\\tint tmp = j;\\n\\t\\tfor (int k = 0; k < n; ++k) {\\n\\t\\t\\tcurNum[k] = tmp % (needs[k] + 1);\\n\\t\\t\\ttmp /= (needs[k] + 1);\\n\\t\\t\\tif (!tmp) break;\\n\\t\\t\\t}\\n\\n\\t\\t// consider offer one by one\\n\\t\\tfor (auto offer : special) {\\n\\t\\t\\tbool can = true;\\n\\t\\t\\tint diff = 0;\\t\\n\\t\\t\\t\\n\\t\\t\\t// check whether offer can be taken or not\\n\\t\\t\\tint mul = 1;\\n\\t\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\t\\tdiff += offer[i] * mul;\\n\\t\\t\\t\\tmul *= needs[i] + 1;\\n\\t\\t\\t\\tif (offer[i] > curNum[i]) {can = false; break;}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// if offer is a valid option\\n\\t\\t\\tif (can) {\\n\\t\\t\\t\\tdfs(price, special, needs, dp, j - diff);\\n\\t\\t\\t\\tdp[j] = min(dp[j-diff] + offer[n], dp[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\n\\t\\treturn 0;\\n\\t}\\n\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n\\t\\t// n -> number of items\\n\\t\\tint n = price.size();\\n\\t\\t\\n\\t\\t// construct the serialized dp\\t\\n\\t\\tint mul = 1;\\n\\t\\tfor (int need : needs) mul *= (need + 1);\\n\\n\\t\\tvector<int> dp(mul);\\n\\n\\t\\t// dp base -> purchase without offers\\n\\t\\tfor (int i = 0; i < mul; ++i) {\\n\\t\\t\\tint tmp = i, cost = 0;\\n\\t\\t\\tfor (int k = 0; k < n; ++k) {\\n\\t\\t\\t\\tcost += tmp % (needs[k] + 1) * price[k];\\n\\t\\t\\t\\ttmp /= (needs[k] + 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tdp[i] = cost;\\n\\t\\t}\\n\\n\\t\\t// update dp in a dfs way\\n\\t\\tdfs(price, special, needs, dp, mul-1);\\n\\n\\t\\treturn dp[mul-1]; \\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint dfs(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, vector<int>& dp, int j) {\\n\\t\\t// n -> number of items\\n\\t\\tint n = price.size();\\n\\n\\t\\t// curNum -> current items purchased\\n\\t\\tvector<int> curNum(n);\\n\\t\\t\\n\\t\\tint tmp = j;\\n\\t\\tfor (int k = 0; k < n; ++k) {\\n\\t\\t\\tcurNum[k] = tmp % (needs[k] + 1);\\n\\t\\t\\ttmp /= (needs[k] + 1);\\n\\t\\t\\tif (!tmp) break;\\n\\t\\t\\t}\\n\\n\\t\\t// consider offer one by one\\n\\t\\tfor (auto offer : special) {\\n\\t\\t\\tbool can = true;\\n\\t\\t\\tint diff = 0;\\t\\n\\t\\t\\t\\n\\t\\t\\t// check whether offer can be taken or not\\n\\t\\t\\tint mul = 1;\\n\\t\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\t\\tdiff += offer[i] * mul;\\n\\t\\t\\t\\tmul *= needs[i] + 1;\\n\\t\\t\\t\\tif (offer[i] > curNum[i]) {can = false; break;}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// if offer is a valid option\\n\\t\\t\\tif (can) {\\n\\t\\t\\t\\tdfs(price, special, needs, dp, j - diff);\\n\\t\\t\\t\\tdp[j] = min(dp[j-diff] + offer[n], dp[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\n\\t\\treturn 0;\\n\\t}\\n\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n\\t\\t// n -> number of items\\n\\t\\tint n = price.size();\\n\\t\\t\\n\\t\\t// construct the serialized dp\\t\\n\\t\\tint mul = 1;\\n\\t\\tfor (int need : needs) mul *= (need + 1);\\n\\n\\t\\tvector<int> dp(mul);\\n\\n\\t\\t// dp base -> purchase without offers\\n\\t\\tfor (int i = 0; i < mul; ++i) {\\n\\t\\t\\tint tmp = i, cost = 0;\\n\\t\\t\\tfor (int k = 0; k < n; ++k) {\\n\\t\\t\\t\\tcost += tmp % (needs[k] + 1) * price[k];\\n\\t\\t\\t\\ttmp /= (needs[k] + 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tdp[i] = cost;\\n\\t\\t}\\n\\n\\t\\t// update dp in a dfs way\\n\\t\\tdfs(price, special, needs, dp, mul-1);\\n\\n\\t\\treturn dp[mul-1]; \\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767777,
                "title": "dp-top-down-memoized-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    map<vector<int>,int> memo;\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int rem_sum = findBestOffers(price, special, needs);\\n        \\n        int best_sum = memo.size() > 0 ? memo.rbegin()->second : INT_MAX;\\n        return min(rem_sum, best_sum);\\n    }\\n    \\n    int findBestOffers(vector<int>& price, vector<vector<int>>& special, vector<int> needs) {\\n        int best_price = INT_MAX-1000;\\n        int rem_sum = 0;\\n        \\n        for (int i = 0; i < special.size(); i++) {\\n            \\n            vector<int> curr_offer(price.size(), 0);\\n            for(int k = 0; k < price.size(); k++) curr_offer[k] = special[i][k];\\n            \\n            if (isValidOffer(curr_offer, needs)) {\\n                \\n                if(memo.find(needs) != memo.end()) return memo[needs];\\n                \\n                vector<int> new_needs(needs.size(), 0);\\n                for(int j = 0; j < needs.size(); j++) new_needs[j] = needs[j] - curr_offer[j];\\n                \\n                best_price = min(best_price, special[i][price.size()] + findBestOffers(price, special, new_needs));\\n                memo[new_needs] = best_price;\\n            }\\n        }\\n        \\n        for (int i = 0; i < needs.size(); i++) rem_sum += needs[i]*price[i];\\n        return min(best_price, rem_sum);\\n    }\\n    \\n    bool isValidOffer(vector<int>& offer, vector<int>& needs) {\\n        for(int i = 0; i < offer.size(); i++) if(needs[i] < offer[i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<vector<int>,int> memo;\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int rem_sum = findBestOffers(price, special, needs);\\n        \\n        int best_sum = memo.size() > 0 ? memo.rbegin()->second : INT_MAX;\\n        return min(rem_sum, best_sum);\\n    }\\n    \\n    int findBestOffers(vector<int>& price, vector<vector<int>>& special, vector<int> needs) {\\n        int best_price = INT_MAX-1000;\\n        int rem_sum = 0;\\n        \\n        for (int i = 0; i < special.size(); i++) {\\n            \\n            vector<int> curr_offer(price.size(), 0);\\n            for(int k = 0; k < price.size(); k++) curr_offer[k] = special[i][k];\\n            \\n            if (isValidOffer(curr_offer, needs)) {\\n                \\n                if(memo.find(needs) != memo.end()) return memo[needs];\\n                \\n                vector<int> new_needs(needs.size(), 0);\\n                for(int j = 0; j < needs.size(); j++) new_needs[j] = needs[j] - curr_offer[j];\\n                \\n                best_price = min(best_price, special[i][price.size()] + findBestOffers(price, special, new_needs));\\n                memo[new_needs] = best_price;\\n            }\\n        }\\n        \\n        for (int i = 0; i < needs.size(); i++) rem_sum += needs[i]*price[i];\\n        return min(best_price, rem_sum);\\n    }\\n    \\n    bool isValidOffer(vector<int>& offer, vector<int>& needs) {\\n        for(int i = 0; i < offer.size(); i++) if(needs[i] < offer[i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679520,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    void dfs(vector<int>& price, vector<vector<int>>& special, vector<int>& needs,vector<int>& curr,int cost){\\n        for(int i=0;i<curr.size();i++){\\n            if(curr[i]<0) return;\\n        }\\n        if(needs==curr){\\n            if(cost<ans){\\n                ans=cost;\\n                return;\\n            }\\n        }\\n        if(cost>=ans) return;\\n        for(int i=0;i<special.size();i++){\\n            bool possible = true;\\n            for(int j=0;j<special[i].size()-1;j++){\\n                if(special[i][j]+curr[j]>needs[j]){\\n                    possible =false;\\n                    break;\\n                }\\n            }\\n            if(possible){\\n                vector<int> temp=curr;\\n                for(int j=0;j<special[i].size()-1;j++){\\n                    curr[j]+=special[i][j];\\n                }\\n                int x=special[i].size();\\n                dfs(price,special,needs,curr,cost+special[i][x-1]);\\n                curr=temp;\\n            }\\n        }\\n        vector<int> temp=curr;\\n        int t=0;\\n        for(int i=0;i<curr.size();i++){\\n            t+=(needs[i]-curr[i])*price[i];\\n        }\\n        dfs(price,special,needs,needs,cost+t);\\n        curr=temp;\\n    }\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int n=price.size();\\n        if(n==0) return 0;\\n        vector<int> curr(n,0);\\n        dfs(price,special,needs,curr,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    void dfs(vector<int>& price, vector<vector<int>>& special, vector<int>& needs,vector<int>& curr,int cost){\\n        for(int i=0;i<curr.size();i++){\\n            if(curr[i]<0) return;\\n        }\\n        if(needs==curr){\\n            if(cost<ans){\\n                ans=cost;\\n                return;\\n            }\\n        }\\n        if(cost>=ans) return;\\n        for(int i=0;i<special.size();i++){\\n            bool possible = true;\\n            for(int j=0;j<special[i].size()-1;j++){\\n                if(special[i][j]+curr[j]>needs[j]){\\n                    possible =false;\\n                    break;\\n                }\\n            }\\n            if(possible){\\n                vector<int> temp=curr;\\n                for(int j=0;j<special[i].size()-1;j++){\\n                    curr[j]+=special[i][j];\\n                }\\n                int x=special[i].size();\\n                dfs(price,special,needs,curr,cost+special[i][x-1]);\\n                curr=temp;\\n            }\\n        }\\n        vector<int> temp=curr;\\n        int t=0;\\n        for(int i=0;i<curr.size();i++){\\n            t+=(needs[i]-curr[i])*price[i];\\n        }\\n        dfs(price,special,needs,needs,cost+t);\\n        curr=temp;\\n    }\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int n=price.size();\\n        if(n==0) return 0;\\n        vector<int> curr(n,0);\\n        dfs(price,special,needs,curr,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663672,
                "title": "simple-c-recursive-with-memorization",
                "content": "```\\nint shoppingOffers_(string target, vector<int>& price, vector<vector<int>>& special, unordered_map<string, int>& m) {\\n\\n\\tif (m.count(target)) return m[target];\\n\\n\\tint res = 0;\\n\\n\\tfor (int i = 0; i < target.length(); ++i) res += price[i] * (target[i] - \\'0\\');\\n\\n\\tfor (vector<int>& vec : special) {\\n\\t\\tstring tmp = target;\\n\\t\\tint i = 0;\\n\\t\\tfor (; i < target.length(); ++i) {\\n\\t\\t\\tif (target[i] - \\'0\\' >=  vec[i]) tmp[i] -= vec[i];\\n\\t\\t\\telse break;\\n\\t\\t}\\n\\t\\tif (i == target.length()) res = min(res, vec.back() + shoppingOffers_(tmp, price, special, m));\\n\\t}\\n\\n\\tm[target] = res;\\n\\treturn res;\\n\\n}\\n\\nint shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n\\n\\tunordered_map<string, int> m;\\n\\tstring target = \"\";\\n\\tfor (int& need : needs) target.push_back(\\'0\\' + need);\\n\\treturn shoppingOffers_(target, price, special, m);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint shoppingOffers_(string target, vector<int>& price, vector<vector<int>>& special, unordered_map<string, int>& m) {\\n\\n\\tif (m.count(target)) return m[target];\\n\\n\\tint res = 0;\\n\\n\\tfor (int i = 0; i < target.length(); ++i) res += price[i] * (target[i] - \\'0\\');\\n\\n\\tfor (vector<int>& vec : special) {\\n\\t\\tstring tmp = target;\\n\\t\\tint i = 0;\\n\\t\\tfor (; i < target.length(); ++i) {\\n\\t\\t\\tif (target[i] - \\'0\\' >=  vec[i]) tmp[i] -= vec[i];\\n\\t\\t\\telse break;\\n\\t\\t}\\n\\t\\tif (i == target.length()) res = min(res, vec.back() + shoppingOffers_(tmp, price, special, m));\\n\\t}\\n\\n\\tm[target] = res;\\n\\treturn res;\\n\\n}\\n\\nint shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n\\n\\tunordered_map<string, int> m;\\n\\tstring target = \"\";\\n\\tfor (int& need : needs) target.push_back(\\'0\\' + need);\\n\\treturn shoppingOffers_(target, price, special, m);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525622,
                "title": "python-dfs-memorization",
                "content": "```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        def dfs(needs, memo, price, special):\\n            key = tuple(needs)\\n            if not key in memo:\\n                memo[key] = sum(needs[i]*price[i] for i in range(len(needs)))\\n                for offer in special:\\n                    new_needs = [needs[i] - offer[i] for i in range(len(needs)) if needs[i] >= offer[i]]\\n                    if len(new_needs) == len(needs):\\n                        memo[key] = min(memo[key], dfs(new_needs, memo, price, special) + offer[-1])\\n            return memo[key]\\n        \\n        memo = {}\\n        return dfs(needs, memo, price, special)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        def dfs(needs, memo, price, special):\\n            key = tuple(needs)\\n            if not key in memo:\\n                memo[key] = sum(needs[i]*price[i] for i in range(len(needs)))\\n                for offer in special:\\n                    new_needs = [needs[i] - offer[i] for i in range(len(needs)) if needs[i] >= offer[i]]\\n                    if len(new_needs) == len(needs):\\n                        memo[key] = min(memo[key], dfs(new_needs, memo, price, special) + offer[-1])\\n            return memo[key]\\n        \\n        memo = {}\\n        return dfs(needs, memo, price, special)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481740,
                "title": "couldn-t-find-where-the-problem-is-need-help",
                "content": "Hi Friends, I was trying to debug this problem but couldn\\'t find where is the issue. I\\'ll explain the thought process.\\n1. The minimum possible amount needed to buy the **needs** is basically calculating the price with the quantities needed without applying any offers. That is the first loop doing.\\n2. The next thing, the offers can be applied only if the items offered by that particular offer is less than or equal to the  needs.\\n3. For each offer, i can apply more than one time if the second rule holds. I\\'m itreating each offer and trying to apply again and again. (**offerTimes**)\\n4. Itreating through each offer, first i\\'ll apply for a single time i\\'ll calculate the remaining amounts needed (**sum value in the third for loop**) and add up the offer value and save the current buyable items with the offer value for future use.\\n5. If i can able to find the remaining items needed from the map i.e there is already an offer satisfying this particular needs, then i can use it and check if it is minimum.\\n\\nI\\'m not sure where the bug is. If you had time please help me find where the problem is. Thanks in advance.\\n```\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int min = Integer.MAX_VALUE;\\n        int itemsSize = price.size();\\n\\n        HashMap<String,Integer> map = new HashMap<String,Integer>();\\n\\n        int sum = 0;\\n        for(int i = 0;i < itemsSize;i++)\\n            sum += (price.get(i) * needs.get(i));\\n\\n        min = Math.min(sum, min);\\n\\n        for(int i = 0;i < special.size();i++) {\\n            List<Integer> offer = special.get(i);\\n            int offerTimes = 1;\\n            boolean isOfferApplicableAgain = true;\\n            do {\\n                sum = 0;\\n                boolean isOfferApplicable = true;\\n                isOfferApplicableAgain = true;\\n                StringBuffer s = new StringBuffer();\\n                StringBuffer bal = new StringBuffer();\\n                for(int j = 0;j < offer.size() - 1;j++){\\n                    if((offer.get(j) * offerTimes) <= needs.get(j)){\\n                        sum += (needs.get(j) - (offer.get(j) * offerTimes)) * price.get(j);\\n                    }\\n                    else\\n                        isOfferApplicable = false;\\n                    isOfferApplicableAgain = isOfferApplicableAgain && (offer.get(j) * (offerTimes + 1) <= needs.get(j));\\n                    s.append((offer.get(j) * offerTimes) + \",\");\\n                    bal.append((needs.get(j) - (offer.get(j) * offerTimes)) + \",\");\\n                }\\n                \\n                if(isOfferApplicable){\\n                    if(map.get(s.toString()) == null)\\n                        map.put(s.toString(), (offer.get(itemsSize) * offerTimes));\\n                    else{\\n                        int oldVal = map.get(s.toString());\\n                        map.put(s.toString(), Math.min((offer.get(itemsSize) * offerTimes), oldVal));\\n                    }\\n                    \\n                    sum += (offer.get(itemsSize) * offerTimes);\\n                    min = Math.min(sum, min);\\n\\n                    if(map.get(bal.toString()) != null){\\n                        min = Math.min(map.get(bal.toString()) + (offer.get(itemsSize) * offerTimes), min);\\n                    }\\n                }\\n\\n                offerTimes++;\\n            } while(isOfferApplicableAgain);\\n        }\\n\\n        return min;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int min = Integer.MAX_VALUE;\\n        int itemsSize = price.size();\\n\\n        HashMap<String,Integer> map = new HashMap<String,Integer>();\\n\\n        int sum = 0;\\n        for(int i = 0;i < itemsSize;i++)\\n            sum += (price.get(i) * needs.get(i));\\n\\n        min = Math.min(sum, min);\\n\\n        for(int i = 0;i < special.size();i++) {\\n            List<Integer> offer = special.get(i);\\n            int offerTimes = 1;\\n            boolean isOfferApplicableAgain = true;\\n            do {\\n                sum = 0;\\n                boolean isOfferApplicable = true;\\n                isOfferApplicableAgain = true;\\n                StringBuffer s = new StringBuffer();\\n                StringBuffer bal = new StringBuffer();\\n                for(int j = 0;j < offer.size() - 1;j++){\\n                    if((offer.get(j) * offerTimes) <= needs.get(j)){\\n                        sum += (needs.get(j) - (offer.get(j) * offerTimes)) * price.get(j);\\n                    }\\n                    else\\n                        isOfferApplicable = false;\\n                    isOfferApplicableAgain = isOfferApplicableAgain && (offer.get(j) * (offerTimes + 1) <= needs.get(j));\\n                    s.append((offer.get(j) * offerTimes) + \",\");\\n                    bal.append((needs.get(j) - (offer.get(j) * offerTimes)) + \",\");\\n                }\\n                \\n                if(isOfferApplicable){\\n                    if(map.get(s.toString()) == null)\\n                        map.put(s.toString(), (offer.get(itemsSize) * offerTimes));\\n                    else{\\n                        int oldVal = map.get(s.toString());\\n                        map.put(s.toString(), Math.min((offer.get(itemsSize) * offerTimes), oldVal));\\n                    }\\n                    \\n                    sum += (offer.get(itemsSize) * offerTimes);\\n                    min = Math.min(sum, min);\\n\\n                    if(map.get(bal.toString()) != null){\\n                        min = Math.min(map.get(bal.toString()) + (offer.get(itemsSize) * offerTimes), min);\\n                    }\\n                }\\n\\n                offerTimes++;\\n            } while(isOfferApplicableAgain);\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 460797,
                "title": "c-dp-state-encoding",
                "content": "Inspired by this post https://leetcode.com/problems/shopping-offers/discuss/105252/Concise-c%2B%2B-DFS-solution-6ms, but implemented in dp style.\\n\\n```cpp   \\nint shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n\\tint limit = encode(needs), N = price.size();\\n\\t// dp[i] = minimum cost to get to i from limit, i: remaining needs\\n\\tvector<int> dp(limit+1, INT_MAX);\\n\\tdp[limit] = 0;\\n\\tfor (int i = limit; i > 0; i--) {\\n\\t\\tif (dp[i] == INT_MAX)\\n\\t\\t\\tcontinue;\\n\\t\\tint sum = 0;\\n\\t\\tvector<int> v = decode(i, N);\\n\\t\\t// Case 1: use no specials to get to 0 \\n\\t\\tfor (int j = 0; j < N; j++)\\n\\t\\t\\tsum += v[j]*price[j];\\n\\t\\tdp[0] = min(dp[0], dp[i] + sum);\\n\\t\\t// Case 2: use at least one special\\n\\t\\tfor (auto & sp: special) {\\n\\t\\t\\tminus(v, sp);\\n\\t\\t\\tif (isNonNeg(v)) {\\n\\t\\t\\t\\tdp[encode(v)] = min(dp[encode(v)], dp[i] + sp.back());\\n\\t\\t\\t}\\n\\t\\t\\tplus(v, sp);\\n\\t\\t}\\n\\t}\\n\\treturn dp[0];\\n}\\n```\\n\\nHelper functions:\\n```cpp\\nint encode(vector<int>& needs) {\\n\\tint res = 0;\\n\\tfor (int i = 0, radix = 1; i < needs.size(); i++, radix *= 7) {\\n\\t\\tres += radix * needs[i];\\n\\t}\\n\\treturn res;\\n}\\nvector<int> decode(int needs, int N) {\\n\\tvector<int> res(N);\\n\\tfor (int i = 0; i < N; i++) {\\n\\t\\tres[i] = needs % 7;\\n\\t\\tneeds = needs/7;\\n\\t}\\n\\treturn res;\\n}\\nvoid plus(vector<int>& v1, const vector<int>& v2) {\\n\\tfor (int i = 0; i < v1.size(); i++)\\n\\t\\tv1[i] += v2[i];\\n}\\nvoid minus(vector<int>& v1, const vector<int>& v2) {\\n\\tfor (int i = 0; i < v1.size(); i++)\\n\\t\\tv1[i] -= v2[i];\\n}\\nbool isNonNeg(const vector<int>& v) {\\n\\tfor (auto n: v)\\n\\t\\tif (n < 0)\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```cpp   \\nint shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n\\tint limit = encode(needs), N = price.size();\\n\\t// dp[i] = minimum cost to get to i from limit, i: remaining needs\\n\\tvector<int> dp(limit+1, INT_MAX);\\n\\tdp[limit] = 0;\\n\\tfor (int i = limit; i > 0; i--) {\\n\\t\\tif (dp[i] == INT_MAX)\\n\\t\\t\\tcontinue;\\n\\t\\tint sum = 0;\\n\\t\\tvector<int> v = decode(i, N);\\n\\t\\t// Case 1: use no specials to get to 0 \\n\\t\\tfor (int j = 0; j < N; j++)\\n\\t\\t\\tsum += v[j]*price[j];\\n\\t\\tdp[0] = min(dp[0], dp[i] + sum);\\n\\t\\t// Case 2: use at least one special\\n\\t\\tfor (auto & sp: special) {\\n\\t\\t\\tminus(v, sp);\\n\\t\\t\\tif (isNonNeg(v)) {\\n\\t\\t\\t\\tdp[encode(v)] = min(dp[encode(v)], dp[i] + sp.back());\\n\\t\\t\\t}\\n\\t\\t\\tplus(v, sp);\\n\\t\\t}\\n\\t}\\n\\treturn dp[0];\\n}\\n```\n```cpp\\nint encode(vector<int>& needs) {\\n\\tint res = 0;\\n\\tfor (int i = 0, radix = 1; i < needs.size(); i++, radix *= 7) {\\n\\t\\tres += radix * needs[i];\\n\\t}\\n\\treturn res;\\n}\\nvector<int> decode(int needs, int N) {\\n\\tvector<int> res(N);\\n\\tfor (int i = 0; i < N; i++) {\\n\\t\\tres[i] = needs % 7;\\n\\t\\tneeds = needs/7;\\n\\t}\\n\\treturn res;\\n}\\nvoid plus(vector<int>& v1, const vector<int>& v2) {\\n\\tfor (int i = 0; i < v1.size(); i++)\\n\\t\\tv1[i] += v2[i];\\n}\\nvoid minus(vector<int>& v1, const vector<int>& v2) {\\n\\tfor (int i = 0; i < v1.size(); i++)\\n\\t\\tv1[i] -= v2[i];\\n}\\nbool isNonNeg(const vector<int>& v) {\\n\\tfor (auto n: v)\\n\\t\\tif (n < 0)\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 407867,
                "title": "knapsack-cpp",
                "content": "```\\nclass Solution {\\n    map<vector<int>,int>mymap;\\n    int find(vector<int>&price,vector<vector<int>>&special,vector<int>needs){\\n        if(mymap.find(needs)!=mymap.end())\\n            return mymap[needs];\\n        int p=0;\\n        for(int i=0;i<needs.size();i++)\\n            p+=(needs[i]*price[i]);\\n        if(p==0)\\n            return 0;\\n        \\n        for(int i=0;i<special.size();i++){\\n            bool x=true;\\n            for(int j=0;j<special[i].size()-1;j++){\\n                if(special[i][j]>needs[j]){\\n                    x=false;\\n                }\\n            }\\n            if(x==false)\\n                continue;\\n            vector<int>temp;\\n            for(int j=0;j<special[i].size()-1;j++){\\n                temp.push_back(needs[j]-special[i][j]);\\n            }\\n            p=min(special[i][special[i].size()-1]+find(price,special,temp),p);\\n        }\\n        mymap[needs]=p;\\n        return p;\\n    }\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return find(price,special,needs);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    map<vector<int>,int>mymap;\\n    int find(vector<int>&price,vector<vector<int>>&special,vector<int>needs){\\n        if(mymap.find(needs)!=mymap.end())\\n            return mymap[needs];\\n        int p=0;\\n        for(int i=0;i<needs.size();i++)\\n            p+=(needs[i]*price[i]);\\n        if(p==0)\\n            return 0;\\n        \\n        for(int i=0;i<special.size();i++){\\n            bool x=true;\\n            for(int j=0;j<special[i].size()-1;j++){\\n                if(special[i][j]>needs[j]){\\n                    x=false;\\n                }\\n            }\\n            if(x==false)\\n                continue;\\n            vector<int>temp;\\n            for(int j=0;j<special[i].size()-1;j++){\\n                temp.push_back(needs[j]-special[i][j]);\\n            }\\n            p=min(special[i][special[i].size()-1]+find(price,special,temp),p);\\n        }\\n        mymap[needs]=p;\\n        return p;\\n    }\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return find(price,special,needs);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400813,
                "title": "python-recursive-memo-calculated-max-money-you-can-save",
                "content": "Calculate the money that can be saved by each special offer, you need to ignore the special offer with negative saved money. In DFS, go through offers that saves most money first.\\nFinal result is the total money without special offer minus the total money saved by special offers\\n```\\nimport functools\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        n=len(price)\\n        tmp=[sum(s[i]*price[i] for i in range(n))-s[-1] for s in special]\\n        for i in range(len(special)):\\n            special[i][-1]=tmp[i]\\n        special=[s for s in special if s[-1]>0]\\n        special.sort(key=lambda x: x[-1],reverse=True)\\n        @functools.lru_cache(None)\\n        def dfs(rest):\\n            res=0\\n            for s in special:\\n                tmp=[]\\n                for i in range(n):\\n                    if rest[i]<s[i]:\\n                        break\\n                    tmp.append(rest[i]-s[i])\\n                else:\\n                    cur=dfs(tuple(tmp))+s[-1]\\n                    res=max(res,cur)\\n            return res\\n        saved=dfs(tuple(needs))\\n        unsaved=sum(price[i]*n for i,n in enumerate(needs))\\n        return unsaved-saved\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        n=len(price)\\n        tmp=[sum(s[i]*price[i] for i in range(n))-s[-1] for s in special]\\n        for i in range(len(special)):\\n            special[i][-1]=tmp[i]\\n        special=[s for s in special if s[-1]>0]\\n        special.sort(key=lambda x: x[-1],reverse=True)\\n        @functools.lru_cache(None)\\n        def dfs(rest):\\n            res=0\\n            for s in special:\\n                tmp=[]\\n                for i in range(n):\\n                    if rest[i]<s[i]:\\n                        break\\n                    tmp.append(rest[i]-s[i])\\n                else:\\n                    cur=dfs(tuple(tmp))+s[-1]\\n                    res=max(res,cur)\\n            return res\\n        saved=dfs(tuple(needs))\\n        unsaved=sum(price[i]*n for i,n in enumerate(needs))\\n        return unsaved-saved\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352076,
                "title": "javascript-beast-90-using-dfs-clean-and-simple",
                "content": "```\\n\\n```var shoppingOffers = function(price, special, needs) {\\n    var directBuy=function(price, needs){\\n        let res=0;\\n        for(let i=0; i<price.length; i++){\\n            res+= price[i]*needs[i];\\n        }\\n        return res;\\n    }\\n    var isValid=function(offer, needs){\\n        for(let i=0; i<offer.length; i++){\\n            if(offer[i]> needs[i]) return false;\\n        }\\n         return true;\\n    }\\n    var help= (price, special, needs) => {\\n        let curMin=directBuy(price, needs);\\n        for (let i=0; i< special.length; i++){\\n            let curOf= special[i];\\n            if(isValid(curOf, needs)){\\n                let tem=[];\\n                for(let j=0; j<needs.length; j++){\\n                    tem.push(needs[j] - curOf[j]);\\n                }\\n                if(tem.length>0){\\n                    curMin = Math.min(curMin, curOf[curOf.length-1]+ help(price, special, tem))\\n                }\\n            }\\n        }\\n        return curMin;\\n    }\\n    return help(price, special, needs)\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 325064,
                "title": "python-solution",
                "content": "```\\nfrom collections import deque\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def shoppingOffers(self, price, special, needs):\\n        \"\"\"\\n        :type price: List[int]\\n        :type special: List[List[int]]\\n        :type needs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def neighbor(state,cost):\\n            for s in special:\\n                items,p = s[:-1],s[-1]\\n                new_cost,new_state = cost,list(state)\\n                for i,num in enumerate(items):\\n                    if new_state[i]+num<=needs[i]:\\n                        new_state[i] = new_state[i]+num\\n                    else:\\n                        break\\n                else:\\n                    new_cost = cost+p\\n                    yield (new_cost,tuple(new_state))\\n        def add(state,cost):\\n            for i,num in enumerate(state):\\n                cost+= price[i] *(needs[i] - num)\\n            return cost\\n        \\n        ans = float(\"inf\")\\n        \\n        initial_state = tuple([0 for _ in needs])\\n        dists = defaultdict(lambda:float(\\'inf\\'))\\n        \\n        q = deque()\\n        q.append((0,initial_state))\\n        \\n        \\n        while q:\\n            cost,state = q.popleft()\\n            if cost>dists[state] or cost>=ans:\\n                continue\\n            real_cost = add(state,cost)\\n            ans = min(real_cost , ans)\\n            for c_cost,c_state in neighbor(state,cost):\\n                if c_cost>=dists[c_state]:\\n                    continue\\n                dists[c_state] = c_cost\\n                q.append((c_cost,c_state))\\n        return ans\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def shoppingOffers(self, price, special, needs):\\n        \"\"\"\\n        :type price: List[int]\\n        :type special: List[List[int]]\\n        :type needs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def neighbor(state,cost):\\n            for s in special:\\n                items,p = s[:-1],s[-1]\\n                new_cost,new_state = cost,list(state)\\n                for i,num in enumerate(items):\\n                    if new_state[i]+num<=needs[i]:\\n                        new_state[i] = new_state[i]+num\\n                    else:\\n                        break\\n                else:\\n                    new_cost = cost+p\\n                    yield (new_cost,tuple(new_state))\\n        def add(state,cost):\\n            for i,num in enumerate(state):\\n                cost+= price[i] *(needs[i] - num)\\n            return cost\\n        \\n        ans = float(\"inf\")\\n        \\n        initial_state = tuple([0 for _ in needs])\\n        dists = defaultdict(lambda:float(\\'inf\\'))\\n        \\n        q = deque()\\n        q.append((0,initial_state))\\n        \\n        \\n        while q:\\n            cost,state = q.popleft()\\n            if cost>dists[state] or cost>=ans:\\n                continue\\n            real_cost = add(state,cost)\\n            ans = min(real_cost , ans)\\n            for c_cost,c_state in neighbor(state,cost):\\n                if c_cost>=dists[c_state]:\\n                    continue\\n                dists[c_state] = c_cost\\n                q.append((c_cost,c_state))\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 320713,
                "title": "c-4ms-beats-100-submissions",
                "content": "```\\nstatic auto fast=[]{ios_base::sync_with_stdio(false); cin.tie(nullptr);return 0;}();\\nclass Solution \\n{\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) \\n    {\\n        if(needs.size()==0)\\n            return 0;\\n        return find(price,special,needs,0);   \\n    }\\n    int find(vector<int>& price,vector<vector<int>>& special,vector<int> &needs,int index)\\n    {\\n        if(index>=special.size())\\n        {\\n            int cost=0;\\n            for(int i=0;i<needs.size();i++)\\n                cost+=needs[i]*price[i];\\n            return cost;\\n        }\\n        int flag=1;\\n        for(int i=0;i<needs.size();i++)\\n        {\\n            if(special[index][i]>needs[i])\\n            {\\n                flag=0;\\n                break;\\n            }\\n        }\\n        if(flag==0)\\n           return find(price,special,needs,index+1);\\n        else\\n        {\\n            int cost1=find(price,special,needs,index+1);\\n            int cost2;\\n            vector<int> new_need;\\n            for(int i=0;i<needs.size();i++)\\n                new_need.push_back(needs[i]-special[index][i]);\\n            cost2=special[index][needs.size()]+find(price,special,new_need,index);\\n            return (cost1>cost2?cost2:cost1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic auto fast=[]{ios_base::sync_with_stdio(false); cin.tie(nullptr);return 0;}();\\nclass Solution \\n{\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) \\n    {\\n        if(needs.size()==0)\\n            return 0;\\n        return find(price,special,needs,0);   \\n    }\\n    int find(vector<int>& price,vector<vector<int>>& special,vector<int> &needs,int index)\\n    {\\n        if(index>=special.size())\\n        {\\n            int cost=0;\\n            for(int i=0;i<needs.size();i++)\\n                cost+=needs[i]*price[i];\\n            return cost;\\n        }\\n        int flag=1;\\n        for(int i=0;i<needs.size();i++)\\n        {\\n            if(special[index][i]>needs[i])\\n            {\\n                flag=0;\\n                break;\\n            }\\n        }\\n        if(flag==0)\\n           return find(price,special,needs,index+1);\\n        else\\n        {\\n            int cost1=find(price,special,needs,index+1);\\n            int cost2;\\n            vector<int> new_need;\\n            for(int i=0;i<needs.size();i++)\\n                new_need.push_back(needs[i]-special[index][i]);\\n            cost2=special[index][needs.size()]+find(price,special,new_need,index);\\n            return (cost1>cost2?cost2:cost1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300951,
                "title": "golang-solution-with-dfs-map",
                "content": "```go\\nfunc shoppingOffers(price []int, special [][]int, needs []int) int {\\n    Map := make(map[[6]int]int)\\n    return dfs(price, special, needs, Map)\\n}\\n\\nfunc dfs(price []int, special [][]int, needs []int, Map map[[6]int]int) int {\\n    key := toArray(needs)\\n    sum, ok := Map[key]\\n    if ok {\\n        return sum\\n    }\\n    n := len(needs)\\n    for i := 0; i < n; i++ {\\n        sum += price[i] * needs[i]\\n    }\\n    for _, sp := range special {\\n        nd := make([]int, n)\\n        i := 0\\n        for ; i < n; i++ {\\n            nd[i] = needs[i] - sp[i]\\n            if nd[i] < 0 {\\n                break\\n            }\\n        }\\n        if i == n {\\n            sum = min(sum, sp[n] + dfs(price, special, nd, Map))\\n            Map[key] = sum\\n        }\\n    }\\n    return sum\\n}\\n\\nfunc toArray(slice []int) [6]int {\\n    array := [6]int{}\\n    for i := 0; i < len(slice); i++ {\\n        array[i] = slice[i]\\n    }\\n    return array\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc shoppingOffers(price []int, special [][]int, needs []int) int {\\n    Map := make(map[[6]int]int)\\n    return dfs(price, special, needs, Map)\\n}\\n\\nfunc dfs(price []int, special [][]int, needs []int, Map map[[6]int]int) int {\\n    key := toArray(needs)\\n    sum, ok := Map[key]\\n    if ok {\\n        return sum\\n    }\\n    n := len(needs)\\n    for i := 0; i < n; i++ {\\n        sum += price[i] * needs[i]\\n    }\\n    for _, sp := range special {\\n        nd := make([]int, n)\\n        i := 0\\n        for ; i < n; i++ {\\n            nd[i] = needs[i] - sp[i]\\n            if nd[i] < 0 {\\n                break\\n            }\\n        }\\n        if i == n {\\n            sum = min(sum, sp[n] + dfs(price, special, nd, Map))\\n            Map[key] = sum\\n        }\\n    }\\n    return sum\\n}\\n\\nfunc toArray(slice []int) [6]int {\\n    array := [6]int{}\\n    for i := 0; i < len(slice); i++ {\\n        array[i] = slice[i]\\n    }\\n    return array\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 281827,
                "title": "python-heapq-solution",
                "content": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        q = [(0, tuple(needs))]\\n        while q:\\n            p, state = heappop(q)\\n            if max(state) == 0: return p\\n            for s in special:\\n                if any(s[i] > state[i] for i in range(len(state))): continue\\n                new_state = tuple(state[i] - s[i] for i in range(len(state)))\\n                heappush(q, ((p + s[-1], new_state)))\\n            heappush(q, (p + sum(x * y for (x, y) in zip(price, state)), tuple(0 for i in range(len(state)))))\\n",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        q = [(0, tuple(needs))]\\n        while q:\\n            p, state = heappop(q)\\n            if max(state) == 0: return p\\n            for s in special:\\n                if any(s[i] > state[i] for i in range(len(state))): continue\\n                new_state = tuple(state[i] - s[i] for i in range(len(state)))\\n                heappush(q, ((p + s[-1], new_state)))\\n            heappush(q, (p + sum(x * y for (x, y) in zip(price, state)), tuple(0 for i in range(len(state)))))\\n",
                "codeTag": "Java"
            },
            {
                "id": 258515,
                "title": "java-dfs-memorization-beat-96",
                "content": "```\\npublic int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int[] arr = new int[needs.size()];\\n        int key = hash(arr);\\n        map.put(key, 0);\\n        for (int i = 0; i < needs.size(); i++) arr[i] = needs.get(i);\\n        return helper(map, price, special, arr);\\n    }\\n    \\n    private int helper(HashMap<Integer, Integer> map,List<Integer> price, \\n                       List<List<Integer>> special, int[] needs) {\\n        int key = hash(needs);\\n        if (map.containsKey(key)) return map.get(key);\\n        int sum = 0;\\n        for (int i = 0; i < needs.length; i++) sum += price.get(i) * needs[i];\\n        for (List<Integer> l : special) {\\n            boolean flag = true;\\n            for (int i = 0; i <  needs.length; i++) {\\n                if (needs[i] - l.get(i) < 0) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                for (int i = 0; i <  needs.length; i++) needs[i] -= l.get(i);\\n                sum = Math.min(sum, l.get(l.size() - 1) + helper(map, price, special, needs));\\n                for (int i = 0; i <  needs.length; i++) needs[i] += l.get(i);\\n            }\\n        }\\n        map.put(key, sum);\\n        return sum;\\n    }\\n    \\n    private int hash(int[] arr) {\\n        int num = 0;\\n        for (int i : arr) {\\n            num = num * 10 + (i + 1);\\n        }\\n        return num;\\n    }  \\n```",
                "solutionTags": [],
                "code": "```\\npublic int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int[] arr = new int[needs.size()];\\n        int key = hash(arr);\\n        map.put(key, 0);\\n        for (int i = 0; i < needs.size(); i++) arr[i] = needs.get(i);\\n        return helper(map, price, special, arr);\\n    }\\n    \\n    private int helper(HashMap<Integer, Integer> map,List<Integer> price, \\n                       List<List<Integer>> special, int[] needs) {\\n        int key = hash(needs);\\n        if (map.containsKey(key)) return map.get(key);\\n        int sum = 0;\\n        for (int i = 0; i < needs.length; i++) sum += price.get(i) * needs[i];\\n        for (List<Integer> l : special) {\\n            boolean flag = true;\\n            for (int i = 0; i <  needs.length; i++) {\\n                if (needs[i] - l.get(i) < 0) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                for (int i = 0; i <  needs.length; i++) needs[i] -= l.get(i);\\n                sum = Math.min(sum, l.get(l.size() - 1) + helper(map, price, special, needs));\\n                for (int i = 0; i <  needs.length; i++) needs[i] += l.get(i);\\n            }\\n        }\\n        map.put(key, sum);\\n        return sum;\\n    }\\n    \\n    private int hash(int[] arr) {\\n        int num = 0;\\n        for (int i : arr) {\\n            num = num * 10 + (i + 1);\\n        }\\n        return num;\\n    }  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 231954,
                "title": "python-pure-bottom-up-dp-without-recursion-concise-solution",
                "content": "Here is DP solution without any recursive calls at all, maintain DP table as hashmap because it can be very sparse. In the worst case size of the DP table is 6^6 for every possible combination of needs. Time is thus proportional to number of offers multiplied by the the size of the DP table. Another multiplication factor is for every offer we try to add it to every state up to 6 times at most, which in current problem statement is a constant factor. If we consider 6^6 to be a constant as well, then total runtime is `O(n)` where `n` is the number of offers.\\n```\\nclass Solution:\\n    def shoppingOffers(self, price, special, needs):\\n        def subtract(a_list, b_list):\\n            out = tuple(a - b for a, b in zip(a_list, b_list))\\n            return None if any(x < 0 for x in out) else out\\n        \\n        dp = {tuple(needs): 0}\\n        for offer in special:\\n            for needs, state_price in list(dp.items()):\\n                new_state, new_price = subtract(needs, offer), state_price + offer[-1]\\n                while new_state:\\n                    dp[new_state] = min(dp.get(new_state, math.inf), new_price)\\n                    new_state, new_price = subtract(new_state, offer), new_price + offer[-1]\\n                    \\n        return min(sum(p*x for p, x in zip(price, needs)) + state_price for needs, state_price in dp.items())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shoppingOffers(self, price, special, needs):\\n        def subtract(a_list, b_list):\\n            out = tuple(a - b for a, b in zip(a_list, b_list))\\n            return None if any(x < 0 for x in out) else out\\n        \\n        dp = {tuple(needs): 0}\\n        for offer in special:\\n            for needs, state_price in list(dp.items()):\\n                new_state, new_price = subtract(needs, offer), state_price + offer[-1]\\n                while new_state:\\n                    dp[new_state] = min(dp.get(new_state, math.inf), new_price)\\n                    new_state, new_price = subtract(new_state, offer), new_price + offer[-1]\\n                    \\n        return min(sum(p*x for p, x in zip(price, needs)) + state_price for needs, state_price in dp.items())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204483,
                "title": "c-dfs-deal-with-this-problem",
                "content": "```\\nauto __=[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        //how to deal this problem some time is eaisly ,but some time may be diffcult\\n        //this problem how to deal with also is question ,so for me how to deal with?\\n        //dfs \\u9012\\u5F52\\u8BA1\\u7B97\\n        int res = 0;\\n        for(int i =0;i<needs.size();i++)\\n        {\\n            res+=price[i]*needs[i];\\n        }\\n        for(int i = 0;i<special.size();i++)\\n        {\\n            bool isValue = true;\\n            for(int j = 0;j<needs.size();j++)\\n            {\\n                if(special[i][j]>needs[j])\\n                {\\n                    isValue = false;\\n                }\\n                needs[j]-=special[i][j];\\n            }\\n            \\n            if(isValue)\\n            {\\n                res = min(res,shoppingOffers(price,special,needs)+special[i].back());\\n            }\\n            for(int j =0;j<needs.size();j++)\\n            {\\n                needs[j]+=special[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nauto __=[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        //how to deal this problem some time is eaisly ,but some time may be diffcult\\n        //this problem how to deal with also is question ,so for me how to deal with?\\n        //dfs \\u9012\\u5F52\\u8BA1\\u7B97\\n        int res = 0;\\n        for(int i =0;i<needs.size();i++)\\n        {\\n            res+=price[i]*needs[i];\\n        }\\n        for(int i = 0;i<special.size();i++)\\n        {\\n            bool isValue = true;\\n            for(int j = 0;j<needs.size();j++)\\n            {\\n                if(special[i][j]>needs[j])\\n                {\\n                    isValue = false;\\n                }\\n                needs[j]-=special[i][j];\\n            }\\n            \\n            if(isValue)\\n            {\\n                res = min(res,shoppingOffers(price,special,needs)+special[i].back());\\n            }\\n            for(int j =0;j<needs.size();j++)\\n            {\\n                needs[j]+=special[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150658,
                "title": "python-recursion-solution",
                "content": "```\\nclass Solution(object):\\n    def shoppingOffers(self, price, special, needs):\\n        \"\"\"\\n        :type price: List[int]\\n        :type special: List[List[int]]\\n        :type needs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        l = len(needs)\\n        maxPrice = sum(price[i] * needs[i] for i in range(l))\\n        # Offers that can be used for current needs\\n        valid_offers = [offer for offer in special if sum([needs[i] >= offer[i] for i in range(l)]) == l]\\n        if sum(needs) == 0 or l == 0:\\n            return 0\\n        if not valid_offers:\\n            return maxPrice\\n        for offer in valid_offers:\\n            next_needs = [needs[i] - offer[i] for i in range(l)]\\n            maxPrice = min(maxPrice, offer[-1] + self.shoppingOffers(price, valid_offers, next_needs))\\n        return maxPrice\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def shoppingOffers(self, price, special, needs):\\n        \"\"\"\\n        :type price: List[int]\\n        :type special: List[List[int]]\\n        :type needs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        l = len(needs)\\n        maxPrice = sum(price[i] * needs[i] for i in range(l))\\n        # Offers that can be used for current needs\\n        valid_offers = [offer for offer in special if sum([needs[i] >= offer[i] for i in range(l)]) == l]\\n        if sum(needs) == 0 or l == 0:\\n            return 0\\n        if not valid_offers:\\n            return maxPrice\\n        for offer in valid_offers:\\n            next_needs = [needs[i] - offer[i] for i in range(l)]\\n            maxPrice = min(maxPrice, offer[-1] + self.shoppingOffers(price, valid_offers, next_needs))\\n        return maxPrice\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141391,
                "title": "dfs-memoization-with-detailed-explanation",
                "content": "A few extra comment about the effect of using memoization here, which varies depending on the specific input pattern.\\nFirst notice that hashing and looking up of a tuple in a dict is not constant time, it is **O(N)** where N is the length of the tuple.\\n\\nHowever, it is worth this extra time if there are **many** overlapping sub-problem, which can result from the range of item count in needs being huge, and those in specialty being small. In that case, we must try many special combination, which **makes the DFS quite deep, and significantly increase the probability of overlapping sub-problems.**\\n\\nOn the other hand, if the range of item count in specialty is close to those in needs, then the DFS won\\'t be too deep, which causes less overlapping sub-problems. Also, if the needs contain a long list of item, then \\nhashing would be very expensive, and we might want to consider the trade-off here. \\n\\nIn some sense, this is simply a knapsack problem with multiple bags, each can only handle a certain type of good. The **needs** is the capacity (a little different but still similar); **price** is like the paddings we use when knapsack cannot be filled up integrally; each **special** contains a combination of each type of goods\\' weight, and its total value; we are only allowed to pick one combination at a time.\\n\\n    def shoppingOffers(self, price, special, needs):\\n        \"\"\"\\n        :type price: List[int]\\n        :type special: List[List[int]]\\n        :type needs: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        # notice it will be naive to use tabulation in this case,\\n        # since the overlapped sub-problem will be distributed sparsely around the table\\n        # It\\'s similar to the knapsack problem, in which it\\'s better to use memoization.\\n        cache = {}\\n\\n        def findMinimum(target):\\n            # using the @price and @special passed in from outter function\\n            # find the minimum cost needed to get to @target combination\\n            # Assume no number in @target is negative\\n\\n            tup = tuple(target)\\n            if tup in cache:\\n                return cache[tup]\\n\\n            # Else we will try to get each viable special once, and recursively\\n            # handle the remaining target.\\n            # we can also try buy each non-zero item at its price\\n            minimum = 0\\n            for index, n in enumerate(target):\\n                minimum += n * price[index]\\n\\n            for spec in special:\\n                # for a specialty to be vialble, all of its required item count\\n                # must <= corresponding target count\\n                remain = []\\n                viable = True\\n                for index, n in enumerate(target):\\n                    if spec[index] > n:\\n                        viable = False\\n                        break\\n                    # calculate remain target count for this item if viable\\n                    remain.append(n - spec[index])\\n\\n                if viable:\\n                    # calculate the cost of going down this path,\\n                    # and see if it beats previous minimum cost\\n                    minimum = min(minimum, spec[-1] + findMinimum(remain))\\n\\n            cache[tup] = minimum\\n            return minimum\\n\\n        return findMinimum(needs)\\n\\n",
                "solutionTags": [],
                "code": "A few extra comment about the effect of using memoization here, which varies depending on the specific input pattern.\\nFirst notice that hashing and looking up of a tuple in a dict is not constant time, it is **O(N)** where N is the length of the tuple.\\n\\nHowever, it is worth this extra time if there are **many** overlapping sub-problem, which can result from the range of item count in needs being huge, and those in specialty being small. In that case, we must try many special combination, which **makes the DFS quite deep, and significantly increase the probability of overlapping sub-problems.**\\n\\nOn the other hand, if the range of item count in specialty is close to those in needs, then the DFS won\\'t be too deep, which causes less overlapping sub-problems. Also, if the needs contain a long list of item, then \\nhashing would be very expensive, and we might want to consider the trade-off here. \\n\\nIn some sense, this is simply a knapsack problem with multiple bags, each can only handle a certain type of good. The **needs** is the capacity (a little different but still similar); **price** is like the paddings we use when knapsack cannot be filled up integrally; each **special** contains a combination of each type of goods\\' weight, and its total value; we are only allowed to pick one combination at a time.\\n\\n    def shoppingOffers(self, price, special, needs):\\n        \"\"\"\\n        :type price: List[int]\\n        :type special: List[List[int]]\\n        :type needs: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        # notice it will be naive to use tabulation in this case,\\n        # since the overlapped sub-problem will be distributed sparsely around the table\\n        # It\\'s similar to the knapsack problem, in which it\\'s better to use memoization.\\n        cache = {}\\n\\n        def findMinimum(target):\\n            # using the @price and @special passed in from outter function\\n            # find the minimum cost needed to get to @target combination\\n            # Assume no number in @target is negative\\n\\n            tup = tuple(target)\\n            if tup in cache:\\n                return cache[tup]\\n\\n            # Else we will try to get each viable special once, and recursively\\n            # handle the remaining target.\\n            # we can also try buy each non-zero item at its price\\n            minimum = 0\\n            for index, n in enumerate(target):\\n                minimum += n * price[index]\\n\\n            for spec in special:\\n                # for a specialty to be vialble, all of its required item count\\n                # must <= corresponding target count\\n                remain = []\\n                viable = True\\n                for index, n in enumerate(target):\\n                    if spec[index] > n:\\n                        viable = False\\n                        break\\n                    # calculate remain target count for this item if viable\\n                    remain.append(n - spec[index])\\n\\n                if viable:\\n                    # calculate the cost of going down this path,\\n                    # and see if it beats previous minimum cost\\n                    minimum = min(minimum, spec[-1] + findMinimum(remain))\\n\\n            cache[tup] = minimum\\n            return minimum\\n\\n        return findMinimum(needs)\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 123551,
                "title": "java-dfs-beat-97-07",
                "content": "```\\nclass Solution {\\n    private int total;\\n\\n    public int shoppingOffers(List<Integer> price,\\n                                     List<List<Integer>> special,\\n                                     List<Integer> needs) {\\n        total = Integer.MAX_VALUE;\\n        buy(price, special, needs, 0, 0);\\n        return total;\\n    }\\n\\n    /**\\n     * @param price   \\u5355\\u54C1\\u4EF7\\u683C\\n     * @param special \\u7279\\u552E\\u76EE\\u5F55\\n     * @param needs   \\u5C1A\\u9700\\u5546\\u54C1\\n     * @param cost    \\u5DF2\\u82B1\\u8D39\\n     * @param i       \\u6289\\u62E9\\u7B2Ci\\u4E2A\\u7279\\u4EF7\\n     */\\n    private void buy(List<Integer> price,\\n                            List<List<Integer>> special,\\n                            List<Integer> needs,\\n                            int cost, int i) {\\n        if (cost > total) {\\n            return;\\n        }\\n        if (i == special.size()) {\\n            for (int j = 0; j < needs.size(); j++) {\\n                cost += price.get(j) * needs.get(j);\\n            }\\n            total = Math.min(total, cost);\\n            return;\\n        }\\n\\n        //\\u9009\\u5F53\\u524D\\u7279\\u4EF7\\n        List<Integer> specialList = special.get(i);\\n        if (check(specialList, needs)) {\\n            for (int j = 0; j < needs.size(); j++) {\\n                needs.set(j, needs.get(j) - specialList.get(j));\\n            }\\n            //\\u53EF\\u91CD\\u590D\\u4E70\\n            buy(price, special, needs, cost + specialList.get(needs.size()), i);\\n            buy(price, special, needs, cost + specialList.get(needs.size()), i + 1);\\n            //\\u6B64\\u5904\\u53EF\\u4EE5\\u7A7A\\u95F4\\u6362\\u65F6\\u95F4\\uFF0C\\u4E0D\\u8FC7 = = \\u6211\\u4E0D\\u60F3~~~\\n            for (int j = 0; j < needs.size(); j++) {\\n                needs.set(j, needs.get(j) + specialList.get(j));\\n            }\\n        }\\n        //\\u4E0D\\u9009\\u5F53\\u524D\\u7279\\u4EF7\\n        buy(price, special, needs, cost, i + 1);\\n\\n    }\\n\\n    private boolean check(List<Integer> special,\\n                                 List<Integer> needs) {\\n        for (int j = 0; j < needs.size(); j++) {\\n            if (needs.get(j) - special.get(j) < 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int total;\\n\\n    public int shoppingOffers(List<Integer> price,\\n                                     List<List<Integer>> special,\\n                                     List<Integer> needs) {\\n        total = Integer.MAX_VALUE;\\n        buy(price, special, needs, 0, 0);\\n        return total;\\n    }\\n\\n    /**\\n     * @param price   \\u5355\\u54C1\\u4EF7\\u683C\\n     * @param special \\u7279\\u552E\\u76EE\\u5F55\\n     * @param needs   \\u5C1A\\u9700\\u5546\\u54C1\\n     * @param cost    \\u5DF2\\u82B1\\u8D39\\n     * @param i       \\u6289\\u62E9\\u7B2Ci\\u4E2A\\u7279\\u4EF7\\n     */\\n    private void buy(List<Integer> price,\\n                            List<List<Integer>> special,\\n                            List<Integer> needs,\\n                            int cost, int i) {\\n        if (cost > total) {\\n            return;\\n        }\\n        if (i == special.size()) {\\n            for (int j = 0; j < needs.size(); j++) {\\n                cost += price.get(j) * needs.get(j);\\n            }\\n            total = Math.min(total, cost);\\n            return;\\n        }\\n\\n        //\\u9009\\u5F53\\u524D\\u7279\\u4EF7\\n        List<Integer> specialList = special.get(i);\\n        if (check(specialList, needs)) {\\n            for (int j = 0; j < needs.size(); j++) {\\n                needs.set(j, needs.get(j) - specialList.get(j));\\n            }\\n            //\\u53EF\\u91CD\\u590D\\u4E70\\n            buy(price, special, needs, cost + specialList.get(needs.size()), i);\\n            buy(price, special, needs, cost + specialList.get(needs.size()), i + 1);\\n            //\\u6B64\\u5904\\u53EF\\u4EE5\\u7A7A\\u95F4\\u6362\\u65F6\\u95F4\\uFF0C\\u4E0D\\u8FC7 = = \\u6211\\u4E0D\\u60F3~~~\\n            for (int j = 0; j < needs.size(); j++) {\\n                needs.set(j, needs.get(j) + specialList.get(j));\\n            }\\n        }\\n        //\\u4E0D\\u9009\\u5F53\\u524D\\u7279\\u4EF7\\n        buy(price, special, needs, cost, i + 1);\\n\\n    }\\n\\n    private boolean check(List<Integer> special,\\n                                 List<Integer> needs) {\\n        for (int j = 0; j < needs.size(); j++) {\\n            if (needs.get(j) - special.get(j) < 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105208,
                "title": "c-dfs-memorization-vector-int-could-not-be-as-key-of-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        unordered_map<string,int> memorization;\\n        /*** in C++, we can not define the vector<int> as key\\n        unordered_map<vector<int>,int>memorization;*/\\n        return dfs(price,special,needs,memorization);\\n    }\\nint dfs(vector<int>& price, vector<vector<int>>& special, vector<int>& needs,unordered_map<string,int> memorization)\\n{\\n    string _needs = convert(needs);\\n    if(memorization.find(_needs)!=memorization.end()) \\n        return memorization[_needs];\\n    int ans = dotproduct(price,needs);\\n    for(int i = 0;i<special.size();i++)\\n    {\\n        int j = 0;\\n        vector<int>clone = needs;\\n        for(;j<needs.size();j++)\\n        {\\n            if(special[i][j]>needs[j]) \\n                break;\\n            else\\n                clone[j] = needs[j]-special[i][j];\\n        }\\n        if(j == needs.size())\\n            ans = min(ans,special[i][j]+dfs(price,special,clone,memorization));\\n    }\\n    memorization[_needs] = ans;\\n    return ans;\\n}\\n    \\nprivate:\\n    string convert(vector<int>needs)\\n    {\\n        string result;\\n        for(int i = 0;i<needs.size();i++) result = result+to_string(needs[i])+\",\";\\n        return result.substr(0,result.size()-1);    \\n    }\\n    int dotproduct(vector<int>prices,vector<int>needs)\\n    {\\n        int sum = 0;\\n        for(int i = 0;i<prices.size();i++) sum+=prices[i]*needs[i];\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        unordered_map<string,int> memorization;\\n        /*** in C++, we can not define the vector<int> as key\\n        unordered_map<vector<int>,int>memorization;*/\\n        return dfs(price,special,needs,memorization);\\n    }\\nint dfs(vector<int>& price, vector<vector<int>>& special, vector<int>& needs,unordered_map<string,int> memorization)\\n{\\n    string _needs = convert(needs);\\n    if(memorization.find(_needs)!=memorization.end()) \\n        return memorization[_needs];\\n    int ans = dotproduct(price,needs);\\n    for(int i = 0;i<special.size();i++)\\n    {\\n        int j = 0;\\n        vector<int>clone = needs;\\n        for(;j<needs.size();j++)\\n        {\\n            if(special[i][j]>needs[j]) \\n                break;\\n            else\\n                clone[j] = needs[j]-special[i][j];\\n        }\\n        if(j == needs.size())\\n            ans = min(ans,special[i][j]+dfs(price,special,clone,memorization));\\n    }\\n    memorization[_needs] = ans;\\n    return ans;\\n}\\n    \\nprivate:\\n    string convert(vector<int>needs)\\n    {\\n        string result;\\n        for(int i = 0;i<needs.size();i++) result = result+to_string(needs[i])+\",\";\\n        return result.substr(0,result.size()-1);    \\n    }\\n    int dotproduct(vector<int>prices,vector<int>needs)\\n    {\\n        int sum = 0;\\n        for(int i = 0;i<prices.size();i++) sum+=prices[i]*needs[i];\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105203,
                "title": "java-optimal-solution-without-memorization-with-explanation",
                "content": "Let's take a look at the structure of the data:\\n*There are at most 6 kinds of items, 100 special offers.\\nFor each item, you need to buy at most 6 of them.*\\n\\nWe can see that: \\n* applying offers decrease amount at least by one\\n* max usage number of the same offer is 6\\n\\nIt would be easier to think about this problem as of a tree.\\nEvery offer is a node, and it can have at most 6 edges (numbers of times an offer was used). The tree depth is 100. \\n\\nThe running time is ~6^100 and space complexity is ~100 (depth of recursion/tree)\\nThe memorization is not needed because all combinations (paths) with promotions are unique. \\n\\n```\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int[] needsArray = new int[needs.size()];\\n        for(int i = 0; i < needsArray.length;i++) {\\n            needsArray[i] = needs.get(i);\\n        }\\n\\n        return minAmount(price, special, needsArray) ;\\n    }\\n\\n    int minAmount(List<Integer> price, List<List<Integer>> specials, int[] needs) {\\n\\n        int amountToPay = 0;\\n\\n        if (specials.isEmpty()) {\\n            // There are no special offers, so just buying the needed amount\\n            for (int i = 0; i < needs.length; i++) {\\n                amountToPay += needs[i] * price.get(i);\\n            }\\n\\n            return amountToPay;\\n        }\\n\\n        List<Integer> special = specials.remove(specials.size() - 1);\\n        int minAmount = Integer.MAX_VALUE;\\n\\n        boolean canApplyOffer = true;\\n        int count = 0;\\n        final int offerPriceIndex = needs.length;\\n\\n        while (canApplyOffer) {\\n\\n            amountToPay = minAmount(price, specials, needs);\\n            minAmount = Math.min(minAmount, special.get(offerPriceIndex) * count + amountToPay);\\n\\n            for (int j = 0; j < needs.length; j++) {\\n                needs[j] -= special.get(j);\\n\\n                if (needs[j] < 0) {\\n                    canApplyOffer = false;\\n                }\\n            }\\n\\n            count++;\\n        }\\n\\n        // Restore \"needs\" array\\n        for (int i = 0; i < needs.length; i++) {\\n            needs[i] += special.get(i) * count;\\n        }\\n\\n        // Restore offers list\\n        specials.add(special);\\n\\n        return minAmount;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int[] needsArray = new int[needs.size()];\\n        for(int i = 0; i < needsArray.length;i++) {\\n            needsArray[i] = needs.get(i);\\n        }\\n\\n        return minAmount(price, special, needsArray) ;\\n    }\\n\\n    int minAmount(List<Integer> price, List<List<Integer>> specials, int[] needs) {\\n\\n        int amountToPay = 0;\\n\\n        if (specials.isEmpty()) {\\n            // There are no special offers, so just buying the needed amount\\n            for (int i = 0; i < needs.length; i++) {\\n                amountToPay += needs[i] * price.get(i);\\n            }\\n\\n            return amountToPay;\\n        }\\n\\n        List<Integer> special = specials.remove(specials.size() - 1);\\n        int minAmount = Integer.MAX_VALUE;\\n\\n        boolean canApplyOffer = true;\\n        int count = 0;\\n        final int offerPriceIndex = needs.length;\\n\\n        while (canApplyOffer) {\\n\\n            amountToPay = minAmount(price, specials, needs);\\n            minAmount = Math.min(minAmount, special.get(offerPriceIndex) * count + amountToPay);\\n\\n            for (int j = 0; j < needs.length; j++) {\\n                needs[j] -= special.get(j);\\n\\n                if (needs[j] < 0) {\\n                    canApplyOffer = false;\\n                }\\n            }\\n\\n            count++;\\n        }\\n\\n        // Restore \"needs\" array\\n        for (int i = 0; i < needs.length; i++) {\\n            needs[i] += special.get(i) * count;\\n        }\\n\\n        // Restore offers list\\n        specials.add(special);\\n\\n        return minAmount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 105226,
                "title": "python-dfs-dp",
                "content": "```\\nclass Solution(object):\\n    def shoppingOffers(self, price, special, needs):\\n        dp = dict()\\n        return self.dfs(price, special, needs, dp)\\n    \\n    def dfs(self, price, special, needs, dp):\\n        key = tuple(needs)\\n        if key in dp:\\n            return dp[key]\\n        ans = float('inf')\\n        for sale in special:\\n            if self.valid(sale, needs):\\n                new_needs = [needs[i] - sale[i] for i in range(len(needs))]\\n                ans = min(ans, self.dfs(price, special, new_needs, dp) + sale[-1])\\n        ans = min(ans, sum([needs[i] * price[i] for i in range(len(needs))]))\\n        dp[key] = ans\\n        return ans\\n\\n    def valid(self, sale, needs):\\n        return all([needs[i] >= sale[i] for i in range(len(needs))])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def shoppingOffers(self, price, special, needs):\\n        dp = dict()\\n        return self.dfs(price, special, needs, dp)\\n    \\n    def dfs(self, price, special, needs, dp):\\n        key = tuple(needs)\\n        if key in dp:\\n            return dp[key]\\n        ans = float('inf')\\n        for sale in special:\\n            if self.valid(sale, needs):\\n                new_needs = [needs[i] - sale[i] for i in range(len(needs))]\\n                ans = min(ans, self.dfs(price, special, new_needs, dp) + sale[-1])\\n        ans = min(ans, sum([needs[i] * price[i] for i in range(len(needs))]))\\n        dp[key] = ans\\n        return ans\\n\\n    def valid(self, sale, needs):\\n        return all([needs[i] >= sale[i] for i in range(len(needs))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105232,
                "title": "python-solution-dfs-map",
                "content": "    def shoppingOffers(self, price, special, needs):\\n        dic = {}\\n        def dfs(tup):\\n            if tup in dic:\\n                return dic[tup]\\n            dic[tup] = sum(i*j for i,j in zip(tup, price))\\n            for sp in special:\\n                newtup = tuple(k-l for k,l in zip(tup, sp))\\n                if min(newtup) < 0:\\n                    continue\\n                dic[tup] = min(dic[tup], dfs(newtup) + sp[-1])\\n            return dic[tup]\\n        return dfs(tuple(needs))",
                "solutionTags": [],
                "code": "    def shoppingOffers(self, price, special, needs):\\n        dic = {}\\n        def dfs(tup):\\n            if tup in dic:\\n                return dic[tup]\\n            dic[tup] = sum(i*j for i,j in zip(tup, price))\\n            for sp in special:\\n                newtup = tuple(k-l for k,l in zip(tup, sp))\\n                if min(newtup) < 0:\\n                    continue\\n                dic[tup] = min(dic[tup], dfs(newtup) + sp[-1])\\n            return dic[tup]\\n        return dfs(tuple(needs))",
                "codeTag": "Python3"
            },
            {
                "id": 4083998,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&needs,vector<vector<int>>&special,int i){\\n        for(int j = 0;j < needs.size();j++)\\n            if(special[i][j] > needs[j])\\n                return false;\\n        return true;\\n    }\\n\\n    int solve(vector<int>&price,vector<vector<int>>& special,vector<int>&needs,int i){\\n        if(i == special.size()){\\n            int ans = 0;\\n            for(int j = 0;j < needs.size();j++)\\n                ans += needs[j]*price[j];\\n            return ans;\\n        }\\n        int x = solve(price,special,needs,i+1);\\n        int count = 0;\\n        while(check(needs,special,i)){\\n            count++;\\n            for(int j = 0;j < needs.size();j++){\\n                needs[j] -= special[i][j];\\n            }\\n            x = min(special[i][special[i].size()-1]*count+solve(price,special,needs,i+1),x);\\n        }\\n        for(int j = 0;j < needs.size();j++)\\n            needs[j] += count*special[i][j];\\n        return x;\\n    }\\n\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return solve(price,special,needs,0);\\n    }\\n};\\n\\n/*\\npublic class Solution {\\n    public int shoppingOffers(List < Integer > price, List < List < Integer >> special, List < Integer > needs) {\\n        return shopping(price, special, needs);\\n    }\\n    public int shopping(List < Integer > price, List < List < Integer >> special, List < Integer > needs) {\\n        int j = 0, res = dot(needs, price);\\n        for (List < Integer > s: special) {\\n            ArrayList < Integer > clone = new ArrayList < > (needs);\\n            for (j = 0; j < needs.size(); j++) {\\n                int diff = clone.get(j) - s.get(j);\\n                if (diff < 0)\\n                    break;\\n                clone.set(j, diff);\\n            }\\n            if (j == needs.size())\\n                res = Math.min(res, s.get(j) + shopping(price, special, clone));\\n        }\\n        return res;\\n    }\\n    public int dot(List < Integer > a, List < Integer > b) {\\n        int sum = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            sum += a.get(i) * b.get(i);\\n        }\\n        return sum;\\n    }\\n\\n}\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&needs,vector<vector<int>>&special,int i){\\n        for(int j = 0;j < needs.size();j++)\\n            if(special[i][j] > needs[j])\\n                return false;\\n        return true;\\n    }\\n\\n    int solve(vector<int>&price,vector<vector<int>>& special,vector<int>&needs,int i){\\n        if(i == special.size()){\\n            int ans = 0;\\n            for(int j = 0;j < needs.size();j++)\\n                ans += needs[j]*price[j];\\n            return ans;\\n        }\\n        int x = solve(price,special,needs,i+1);\\n        int count = 0;\\n        while(check(needs,special,i)){\\n            count++;\\n            for(int j = 0;j < needs.size();j++){\\n                needs[j] -= special[i][j];\\n            }\\n            x = min(special[i][special[i].size()-1]*count+solve(price,special,needs,i+1),x);\\n        }\\n        for(int j = 0;j < needs.size();j++)\\n            needs[j] += count*special[i][j];\\n        return x;\\n    }\\n\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return solve(price,special,needs,0);\\n    }\\n};\\n\\n/*\\npublic class Solution {\\n    public int shoppingOffers(List < Integer > price, List < List < Integer >> special, List < Integer > needs) {\\n        return shopping(price, special, needs);\\n    }\\n    public int shopping(List < Integer > price, List < List < Integer >> special, List < Integer > needs) {\\n        int j = 0, res = dot(needs, price);\\n        for (List < Integer > s: special) {\\n            ArrayList < Integer > clone = new ArrayList < > (needs);\\n            for (j = 0; j < needs.size(); j++) {\\n                int diff = clone.get(j) - s.get(j);\\n                if (diff < 0)\\n                    break;\\n                clone.set(j, diff);\\n            }\\n            if (j == needs.size())\\n                res = Math.min(res, s.get(j) + shopping(price, special, clone));\\n        }\\n        return res;\\n    }\\n    public int dot(List < Integer > a, List < Integer > b) {\\n        int sum = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            sum += a.get(i) * b.get(i);\\n        }\\n        return sum;\\n    }\\n\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066841,
                "title": "python3-memoization-top-down-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n ^ 2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n\\n- Space complexity: O(n ^ 2) and O(n + n) aux stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        if not price or not needs:\\n            return 0\\n        \\n        n = len(needs)\\n        dp = {}\\n        \\n        def canShop(offer, needs):\\n            for i in range(n):\\n                if needs[i] < offer[i]:\\n                    return False\\n            return True\\n        \\n        def findLowestPriceMemo(needs):\\n            key = str(needs)\\n            \\n            if key in dp:\\n                return dp[key]\\n\\n            notpick = sum(price[i] * needs[i] for i in range(n))\\n            pick = float(\\'inf\\')\\n\\n            for offer in special:\\n                offerPrice = offer[-1]\\n\\n                if canShop(offer, needs):\\n                    new_needs = [needs[i] - offer[i] for i in range(n)]\\n                    pick = min(pick, offerPrice + findLowestPriceMemo(new_needs))\\n            \\n            dp[key] = min(notpick, pick)\\n            return dp[key]\\n        \\n        \\n        # driver code\\n        return findLowestPriceMemo(needs)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        if not price or not needs:\\n            return 0\\n        \\n        n = len(needs)\\n        dp = {}\\n        \\n        def canShop(offer, needs):\\n            for i in range(n):\\n                if needs[i] < offer[i]:\\n                    return False\\n            return True\\n        \\n        def findLowestPriceMemo(needs):\\n            key = str(needs)\\n            \\n            if key in dp:\\n                return dp[key]\\n\\n            notpick = sum(price[i] * needs[i] for i in range(n))\\n            pick = float(\\'inf\\')\\n\\n            for offer in special:\\n                offerPrice = offer[-1]\\n\\n                if canShop(offer, needs):\\n                    new_needs = [needs[i] - offer[i] for i in range(n)]\\n                    pick = min(pick, offerPrice + findLowestPriceMemo(new_needs))\\n            \\n            dp[key] = min(notpick, pick)\\n            return dp[key]\\n        \\n        \\n        # driver code\\n        return findLowestPriceMemo(needs)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037616,
                "title": "shopping-offers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} price\\n * @param {number[][]} special\\n * @param {number[]} needs\\n * @return {number}\\n */\\nvar shoppingOffers = function(price, special, needs) {\\n    const memo = new Map();\\n\\n    function minCost(needs) {\\n        const key = needs.join(\\',\\');\\n\\n        if (memo.has(key)) {\\n            return memo.get(key);\\n        }\\n\\n        let cost = 0;\\n\\n        // Calculate the cost without using any special offer\\n        for (let i = 0; i < price.length; i++) {\\n            cost += price[i] * needs[i];\\n        }\\n\\n        // Try using each special offer\\n        for (const offer of special) {\\n            const newNeeds = [];\\n\\n            for (let i = 0; i < price.length; i++) {\\n                if (needs[i] < offer[i]) {\\n                    // Cannot use this offer, break\\n                    newNeeds.length = 0;\\n                    break;\\n                }\\n                newNeeds.push(needs[i] - offer[i]);\\n            }\\n\\n            if (newNeeds.length > 0) {\\n                cost = Math.min(cost, offer[offer.length - 1] + minCost(newNeeds));\\n            }\\n        }\\n\\n        memo.set(key, cost);\\n        return cost;\\n    }\\n\\n    return minCost(needs);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} price\\n * @param {number[][]} special\\n * @param {number[]} needs\\n * @return {number}\\n */\\nvar shoppingOffers = function(price, special, needs) {\\n    const memo = new Map();\\n\\n    function minCost(needs) {\\n        const key = needs.join(\\',\\');\\n\\n        if (memo.has(key)) {\\n            return memo.get(key);\\n        }\\n\\n        let cost = 0;\\n\\n        // Calculate the cost without using any special offer\\n        for (let i = 0; i < price.length; i++) {\\n            cost += price[i] * needs[i];\\n        }\\n\\n        // Try using each special offer\\n        for (const offer of special) {\\n            const newNeeds = [];\\n\\n            for (let i = 0; i < price.length; i++) {\\n                if (needs[i] < offer[i]) {\\n                    // Cannot use this offer, break\\n                    newNeeds.length = 0;\\n                    break;\\n                }\\n                newNeeds.push(needs[i] - offer[i]);\\n            }\\n\\n            if (newNeeds.length > 0) {\\n                cost = Math.min(cost, offer[offer.length - 1] + minCost(newNeeds));\\n            }\\n        }\\n\\n        memo.set(key, cost);\\n        return cost;\\n    }\\n\\n    return minCost(needs);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020299,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check(int i, vector<vector<int>>&special, vector<int>&needs) {\\n        for(int j=0;j<needs.size();j++) {\\n            if(special[i][j] > needs[j]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int minPrice(int i, vector<int>&price, vector<vector<int>>&special, vector<int>&needs) {\\n        if(i == special.size()) {\\n            int ans = 0;\\n            for(int j=0;j<needs.size();j++) {\\n                ans+=(needs[j] * price[j]);\\n            }\\n            return ans;\\n        }\\n\\n        int x = minPrice(i+1, price, special, needs);\\n        // cout<<\"Hello World \"<<i<<\" \"<<x<<\"\\\\n\";\\n\\n        int flag = 0;\\n        while(1) {\\n            if(check(i, special, needs)) {\\n                flag++;\\n                for(int j=0;j<needs.size();j++) {\\n                    needs[j] -= special[i][j];\\n                }\\n                x = min(x, special[i][special[i].size()-1]*flag + minPrice(i+1, price, special, needs));\\n            } else {\\n                for(int j=0;j<needs.size();j++) {\\n                    needs[j] += flag * special[i][j];\\n                }\\n                break;\\n            }\\n        }\\n\\n        \\n        // if(check(i, special, needs)) {\\n        //     for(int j=0;j<needs.size();j++) {\\n        //         needs[j] -= special[i][j];\\n        //     }\\n        //     x = min(x, special[i][special[i].size()-1] + minPrice(i+1, price, special, needs));\\n        //     // cout<<special[i][special[i].size()-1]<<\"ok\";\\n        //     // cout<<i<<\" \"<<x<<\"\\\\n\";\\n        //     for(int j=0;j<needs.size();j++) {\\n        //         needs[j] += special[i][j];\\n        //     }\\n        // }\\n\\n        return x;\\n\\n    }\\n\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return minPrice(0, price, special, needs);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool check(int i, vector<vector<int>>&special, vector<int>&needs) {\\n        for(int j=0;j<needs.size();j++) {\\n            if(special[i][j] > needs[j]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int minPrice(int i, vector<int>&price, vector<vector<int>>&special, vector<int>&needs) {\\n        if(i == special.size()) {\\n            int ans = 0;\\n            for(int j=0;j<needs.size();j++) {\\n                ans+=(needs[j] * price[j]);\\n            }\\n            return ans;\\n        }\\n\\n        int x = minPrice(i+1, price, special, needs);\\n        // cout<<\"Hello World \"<<i<<\" \"<<x<<\"\\\\n\";\\n\\n        int flag = 0;\\n        while(1) {\\n            if(check(i, special, needs)) {\\n                flag++;\\n                for(int j=0;j<needs.size();j++) {\\n                    needs[j] -= special[i][j];\\n                }\\n                x = min(x, special[i][special[i].size()-1]*flag + minPrice(i+1, price, special, needs));\\n            } else {\\n                for(int j=0;j<needs.size();j++) {\\n                    needs[j] += flag * special[i][j];\\n                }\\n                break;\\n            }\\n        }\\n\\n        \\n        // if(check(i, special, needs)) {\\n        //     for(int j=0;j<needs.size();j++) {\\n        //         needs[j] -= special[i][j];\\n        //     }\\n        //     x = min(x, special[i][special[i].size()-1] + minPrice(i+1, price, special, needs));\\n        //     // cout<<special[i][special[i].size()-1]<<\"ok\";\\n        //     // cout<<i<<\" \"<<x<<\"\\\\n\";\\n        //     for(int j=0;j<needs.size();j++) {\\n        //         needs[j] += special[i][j];\\n        //     }\\n        // }\\n\\n        return x;\\n\\n    }\\n\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return minPrice(0, price, special, needs);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3983288,
                "title": "easy-implementation-using-dfs-with-memorziable-dictionary-python-fast-solution",
                "content": "## 638. Shopping Offers\\n\\nIn LeetCode Store, there are n items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.\\n\\nYou are given an integer array price where price[i] is the price of the ith item, and an integer array needs where needs[i] is the number of pieces of the ith item you want to buy.\\n\\nYou are also given an array special where special[i] is of size n + 1 where special[i][j] is the number of pieces of the jth item in the ith offer and special[i][n] (i.e., the last integer in the array) is the price of the ith offer.\\n\\nReturn the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.\\n\\nConstraints:\\n\\n* n == price.length == needs.length\\n* 1 <= n <= 6\\n* 0 <= price[i], needs[i] <= 10\\n* 1 <= special.length <= 100\\n* special[i].length == n + 1\\n* 0 <= special[i][j] <= 50\\n\\n### Intuition\\nWhen seeing the function array which represent the price and nums. It definitely will be a dynamic programming problem, because we can it has a iteration property. Easyly to see. A knapsack problem. \\n* First, we have special offer - quantity1,q2,q3.. and the total price for this offer, price for each item and needed.\\n* You are not allowed to buy more items than you want, even if that would lower the overall price. But I don\\'t know how to build dp equation. Let me see the std solution.\\n* Because it\\'s a DP problem, we definitely can write a iteration solution, but it\\'s a little bit complex. So we can use recursion with memorizable variable to solve it.\\n\\n### Approach\\n* step 1:each time first we calculate if we all use the original without special offer, what\\'s the price.\\n* step 2: then we try to use each special offer, if we can use it, we will use it, and then we will dfs to next level with the new needs which the items we purchased has been deducted.\\n* step 3: we will compare the price we get from step 1 and step 2, and return the min one.\\n\\n\\n### Complexity\\n- Time complexity:\\nBecause we need to iterate all possible combination of special offer, so the time complexity is $$O(2^n)$$\\n\\n- Space complexity:\\nfor the recursion, we need to store the needs, so the space complexity is $$O(n^n)$$ because each elements in dict is a list with n elements, it has 0 - n possibilities, therefore in total we may have $$n^n$$ possibilities.\\n\\n### Code\\n```python\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        d = {}\\n        def dfs(price, special, needs):\\n            if not needs:\\n                return 0\\n            # calculate the price without special offer\\n            res = sum([price[i] * needs[i] for i in range(len(needs))])\\n            # try to use each special offer\\n            for offer in special:\\n                # check if we can use this offer\\n                for i in range(len(needs)):\\n                    if needs[i] < offer[i]:\\n                        break\\n                else:\\n                    # use this offer\\n                    tmp = [needs[j] - offer[j] for j in range(len(needs))]\\n                    if tuple(tmp) not in d:\\n                        d[tuple(tmp)] = dfs(price, special, tmp)\\n                    res = min(res, offer[-1] + d[tuple(tmp)])\\n            return res\\n        return dfs(price, special, needs)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        d = {}\\n        def dfs(price, special, needs):\\n            if not needs:\\n                return 0\\n            # calculate the price without special offer\\n            res = sum([price[i] * needs[i] for i in range(len(needs))])\\n            # try to use each special offer\\n            for offer in special:\\n                # check if we can use this offer\\n                for i in range(len(needs)):\\n                    if needs[i] < offer[i]:\\n                        break\\n                else:\\n                    # use this offer\\n                    tmp = [needs[j] - offer[j] for j in range(len(needs))]\\n                    if tuple(tmp) not in d:\\n                        d[tuple(tmp)] = dfs(price, special, tmp)\\n                    res = min(res, offer[-1] + d[tuple(tmp)])\\n            return res\\n        return dfs(price, special, needs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964483,
                "title": "c-dynamic-programming-memoization",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(len(special)*10^n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(len(special)*10^n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int k, unordered_map<int,unordered_map<string,int>>& dp) {\\n        int n = price.size();\\n        if (k >= special.size()) {\\n            int sum = 0;\\n            for (int i = 0; i < n; ++ i) sum += needs[i] * price[i];\\n            return sum;\\n        }\\n        bool chk = false;\\n        string key = \"\";\\n        for (int i = 0; i < n; ++ i) {\\n            if (needs[i] < special[k][i]) chk = true;\\n            if (needs[i] == 10) key += \"10\";\\n            else {\\n                key += \"0\";\\n                key += needs[i] + \\'0\\';\\n            }\\n        }\\n        if (dp.find(k) != dp.end() && dp[k].find(key) != dp[k].end()) return dp[k][key];\\n        int res = dfs(price, special, needs, k + 1, dp);\\n        if (!chk) {\\n            for (int i = 0; i < n; ++ i) needs[i] -= special[k][i];\\n            res = min(res, special[k][n] + dfs(price, special, needs, k, dp));\\n            for (int i = 0; i < n; ++ i) needs[i] += special[k][i];\\n        }\\n        dp[k][key] = res;\\n        return res;\\n        \\n    }\\n\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        unordered_map<int,unordered_map<string,int>> dp;\\n        return dfs(price, special, needs, 0, dp);\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int k, unordered_map<int,unordered_map<string,int>>& dp) {\\n        int n = price.size();\\n        if (k >= special.size()) {\\n            int sum = 0;\\n            for (int i = 0; i < n; ++ i) sum += needs[i] * price[i];\\n            return sum;\\n        }\\n        bool chk = false;\\n        string key = \"\";\\n        for (int i = 0; i < n; ++ i) {\\n            if (needs[i] < special[k][i]) chk = true;\\n            if (needs[i] == 10) key += \"10\";\\n            else {\\n                key += \"0\";\\n                key += needs[i] + \\'0\\';\\n            }\\n        }\\n        if (dp.find(k) != dp.end() && dp[k].find(key) != dp[k].end()) return dp[k][key];\\n        int res = dfs(price, special, needs, k + 1, dp);\\n        if (!chk) {\\n            for (int i = 0; i < n; ++ i) needs[i] -= special[k][i];\\n            res = min(res, special[k][n] + dfs(price, special, needs, k, dp));\\n            for (int i = 0; i < n; ++ i) needs[i] += special[k][i];\\n        }\\n        dp[k][key] = res;\\n        return res;\\n        \\n    }\\n\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        unordered_map<int,unordered_map<string,int>> dp;\\n        return dfs(price, special, needs, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939844,
                "title": "knapsack-dp-memoization",
                "content": "# Code\\n```\\nclass Solution {\\n   map<vector<int>,int> dp;\\n    int solve(int n,vector<int>& price, vector<vector<int>>& special, vector<int>& needs)\\n     {    \\n        if(dp.count(needs))\\n         return dp[needs];\\n   \\n       int buyDirectly = 0;\\n        for(int k=0; k<n; k++)\\n         buyDirectly += needs[k]*price[k];\\n      \\n        int buyWithOffer = 1e8;\\n         for(auto currOffer : special)\\n         {  \\n         vector<int> copy = needs;\\n         int isValidOffer = 1;\\n           for(int j=0; j<n; j++)\\n           {\\n             copy[j] -= currOffer[j];      \\n             if(copy[j] < 0)\\n              {\\n              isValidOffer = 0;\\n              break;\\n              }\\n            }\\n        if(isValidOffer) \\n         buyWithOffer = min(buyWithOffer, currOffer[n] + solve(n,price,special,copy));\\n         }   \\n      return dp[needs] =  min({buyWithOffer,buyDirectly});\\n     }\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int n = price.size();\\n        return solve(n,price,special,needs);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n   map<vector<int>,int> dp;\\n    int solve(int n,vector<int>& price, vector<vector<int>>& special, vector<int>& needs)\\n     {    \\n        if(dp.count(needs))\\n         return dp[needs];\\n   \\n       int buyDirectly = 0;\\n        for(int k=0; k<n; k++)\\n         buyDirectly += needs[k]*price[k];\\n      \\n        int buyWithOffer = 1e8;\\n         for(auto currOffer : special)\\n         {  \\n         vector<int> copy = needs;\\n         int isValidOffer = 1;\\n           for(int j=0; j<n; j++)\\n           {\\n             copy[j] -= currOffer[j];      \\n             if(copy[j] < 0)\\n              {\\n              isValidOffer = 0;\\n              break;\\n              }\\n            }\\n        if(isValidOffer) \\n         buyWithOffer = min(buyWithOffer, currOffer[n] + solve(n,price,special,copy));\\n         }   \\n      return dp[needs] =  min({buyWithOffer,buyDirectly});\\n     }\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int n = price.size();\\n        return solve(n,price,special,needs);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931019,
                "title": "simple-java-solution-using-map",
                "content": "# Code\\n```\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        //this map will help us to differntiate between each possible state of dp solution\\n        // telling which item is selcted and how much it is remaining in our needs list\\n        // every state will have it own cost \\n        Map<List<Integer>, Integer> memo = new HashMap<>();\\n        return minCost(price, special, needs, memo);\\n    }\\n    \\n    private int minCost(List<Integer> price, List<List<Integer>> special, List<Integer> needs, Map<List<Integer>, Integer> memo) {\\n        if (memo.containsKey(needs)) {\\n            return memo.get(needs);\\n        }\\n        //calculating base cost we get after we do simple purchases without any offers\\n        //every new needs array will be calculated as our needs list will be updated everytime\\n        int cost = calcCost(price, needs);\\n        \\n        for (List<Integer> offer : special) {\\n            boolean valid = true;\\n            List<Integer> newNeeds = new ArrayList<>(needs);\\n            \\n            for (int i = 0; i < price.size(); i++) {\\n                //checking if our current offer is valid or not depending on our current needs list\\n                if (offer.get(i) > newNeeds.get(i)) {\\n                    valid = false;\\n                    break;\\n                }\\n                newNeeds.set(i, newNeeds.get(i) - offer.get(i));\\n            }\\n            //the base would be this as there would be no further recusions when all elements are zero or one \\n            // of them is zero\\n            if (valid) {\\n                cost = Math.min(cost, offer.get(price.size()) + minCost(price, special, newNeeds, memo));\\n            }\\n        }\\n        \\n        memo.put(needs, cost);\\n        return cost;\\n    }\\n    \\n    private int calcCost(List<Integer> price, List<Integer> needs) {\\n        int cost = 0;\\n        for (int i = 0; i < price.size(); i++) {\\n            cost += price.get(i) * needs.get(i);\\n        }\\n        return cost;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        //this map will help us to differntiate between each possible state of dp solution\\n        // telling which item is selcted and how much it is remaining in our needs list\\n        // every state will have it own cost \\n        Map<List<Integer>, Integer> memo = new HashMap<>();\\n        return minCost(price, special, needs, memo);\\n    }\\n    \\n    private int minCost(List<Integer> price, List<List<Integer>> special, List<Integer> needs, Map<List<Integer>, Integer> memo) {\\n        if (memo.containsKey(needs)) {\\n            return memo.get(needs);\\n        }\\n        //calculating base cost we get after we do simple purchases without any offers\\n        //every new needs array will be calculated as our needs list will be updated everytime\\n        int cost = calcCost(price, needs);\\n        \\n        for (List<Integer> offer : special) {\\n            boolean valid = true;\\n            List<Integer> newNeeds = new ArrayList<>(needs);\\n            \\n            for (int i = 0; i < price.size(); i++) {\\n                //checking if our current offer is valid or not depending on our current needs list\\n                if (offer.get(i) > newNeeds.get(i)) {\\n                    valid = false;\\n                    break;\\n                }\\n                newNeeds.set(i, newNeeds.get(i) - offer.get(i));\\n            }\\n            //the base would be this as there would be no further recusions when all elements are zero or one \\n            // of them is zero\\n            if (valid) {\\n                cost = Math.min(cost, offer.get(price.size()) + minCost(price, special, newNeeds, memo));\\n            }\\n        }\\n        \\n        memo.put(needs, cost);\\n        return cost;\\n    }\\n    \\n    private int calcCost(List<Integer> price, List<Integer> needs) {\\n        int cost = 0;\\n        for (int i = 0; i < price.size(); i++) {\\n            cost += price.get(i) * needs.get(i);\\n        }\\n        return cost;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909017,
                "title": "solution-for-bignnrs",
                "content": "Hey in this question you have to calculate min cost of buying which can be done by calculating min cost of buying each item and then adding cost for all of the items.\\n```\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n       return help(price,special,needs,0); \\n    }\\n    public int help(List<Integer> price, List<List<Integer>> special, List<Integer> needs,int start){\\n        int sum = 0;\\n        for(int i=0;i<needs.size();i++){\\n            sum = sum + needs.get(i) * price.get(i);\\n        }\\n        for(int i=start;i<special.size();i++){\\n            List<Integer> list = special.get(i);\\n            List<Integer> temp = new ArrayList<>();\\n            for(int j=0;j<needs.size();j++){\\n                if(needs.get(j) < list.get(j)){\\n                    temp = null;\\n                    break;\\n                }// invalid offer\\n                temp.add(needs.get(j) - list.get(j));\\n            }\\n            if(temp != null){\\n                sum = Math.min(sum,list.get(list.size()-1) + help(price,special,temp,i));\\n            }\\n\\n        }\\n        return sum;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n       return help(price,special,needs,0); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3903822,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        return helper(price, special, needs, 0);\\n    }\\n    \\n    public int helper(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int pos) {\\n        int sum = 0, len = price.size();\\n        for (int i = 0; i < len; i++) sum += needs.get(i)*price.get(i);\\n        \\n        for (int i = pos; i < special.size(); i++) {\\n            List<Integer> list = special.get(i);\\n            List<Integer> temp = new ArrayList<>();\\n            for (int j= 0; j < needs.size(); j++) {\\n        \\t\\tif (needs.get(j) < list.get(j)) { // check if the current offer is valid\\n        \\t\\t\\ttemp =  null;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t\\ttemp.add(needs.get(j) - list.get(j));\\n        \\t}\\n            if (temp != null) { // use the current offer and try next\\n    \\t\\t\\tsum = Math.min(sum, list.get(list.size() - 1) + helper(price, special, temp, i)); \\n    \\t\\t}\\n        }\\n        return sum;\\n    }\\n    \\n}\\n```\\n\\n```c++ []\\nclass Solution // Unbounded Knapsack\\n{\\npublic:\\n    map<vector<int>,int> m;\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) \\n    {\\n        int n=price.size();\\n        int withoutOffer=0;\\n        for(int x=0; x<n; x++) withoutOffer+=price[x]*needs[x];\\n        int mn=withoutOffer;\\n        if(m.find(needs)!=m.end()) return m[needs];\\n        for(int x=0; x<special.size(); x++)\\n        {\\n            int f=1;\\n            for(int y=0; y<n; y++) \\n            {\\n                if(special[x][y]>needs[y])\\n                {\\n                    f=0; break;\\n                }\\n            }\\n            if(f)\\n            {\\n                vector<int> newneeds(n);\\n                for(int y=0; y<n; y++)\\n                {\\n                    newneeds[y]=needs[y]-special[x][y];\\n                }\\n                int offer=special[x][n]+shoppingOffers(price,special,newneeds);\\n                if(offer<mn) mn=offer;\\n            }\\n        }\\n        return m[needs]=mn;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        return helper(price, special, needs, 0);\\n    }\\n    \\n    public int helper(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int pos) {\\n        int sum = 0, len = price.size();\\n        for (int i = 0; i < len; i++) sum += needs.get(i)*price.get(i);\\n        \\n        for (int i = pos; i < special.size(); i++) {\\n            List<Integer> list = special.get(i);\\n            List<Integer> temp = new ArrayList<>();\\n            for (int j= 0; j < needs.size(); j++) {\\n        \\t\\tif (needs.get(j) < list.get(j)) { // check if the current offer is valid\\n        \\t\\t\\ttemp =  null;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t\\ttemp.add(needs.get(j) - list.get(j));\\n        \\t}\\n            if (temp != null) { // use the current offer and try next\\n    \\t\\t\\tsum = Math.min(sum, list.get(list.size() - 1) + helper(price, special, temp, i)); \\n    \\t\\t}\\n        }\\n        return sum;\\n    }\\n    \\n}\\n```\n```c++ []\\nclass Solution // Unbounded Knapsack\\n{\\npublic:\\n    map<vector<int>,int> m;\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) \\n    {\\n        int n=price.size();\\n        int withoutOffer=0;\\n        for(int x=0; x<n; x++) withoutOffer+=price[x]*needs[x];\\n        int mn=withoutOffer;\\n        if(m.find(needs)!=m.end()) return m[needs];\\n        for(int x=0; x<special.size(); x++)\\n        {\\n            int f=1;\\n            for(int y=0; y<n; y++) \\n            {\\n                if(special[x][y]>needs[y])\\n                {\\n                    f=0; break;\\n                }\\n            }\\n            if(f)\\n            {\\n                vector<int> newneeds(n);\\n                for(int y=0; y<n; y++)\\n                {\\n                    newneeds[y]=needs[y]-special[x][y];\\n                }\\n                int offer=special[x][n]+shoppingOffers(price,special,newneeds);\\n                if(offer<mn) mn=offer;\\n            }\\n        }\\n        return m[needs]=mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893862,
                "title": "python-unoptimized-top-down-tle-to-optimized-ac-top-down",
                "content": "### Intution\\n* Lets define a ```curr_state``` as some array with the current counts of items\\n* Example ```curr_state = [a,b,c,d]```with indices ```[i,j,k,l]``` meaning there are ```a``` counts of item ```i```, ```b``` counts of item ```j```, etc\\n* We define this ```curr_state``` as optimal, meaning it has the lowest price we can get\\n* Now for each item in ```curr_state``` we can aquire 1 unit if of an item\\n* For example, we can aquire one unit of item ```a``` and go up in price by ```price[i]```, \\n* And the state transitions moves from ```[a,b,c,d]```to ```next_state = [a+1,b,c,d] + price[i]```\\n* To find the minimum we just try all indices and add the price and increment count by 1. So we write this transition as:\\n```\\ndp(state) = {\\n\\n            for i in range(n):\\n                next_state = state[:]\\n                next_state[i] += 1\\n                ans = min(ans, price[i] + dp(next_state))\\n}\\n```  \\n\\n* But we also need to take into consideration the offers we can get from the ```specials[][]``` array\\n* So for each ```off``` array in specials, we can unpack the first n elements as the number of units that we can get and we go up by ```off[-1]```\\n* The second transition is\\n```\\ndp(state) = {\\n\\t            for off in special:\\n                next_state = state[:]\\n                for i in range(n):\\n                    next_state[i] += off[i] #add counts\\n                \\n                ans = min(ans, off[-1] + dp(next_state))\\n}\\n```\\n\\nWe cache each state as tuples (you could also use bit masks) but the inputs are small and just take the minimum. And in this version we start with an empty counts array.\\n\\n\\n### TLE 41/65\\n```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        \\n        memo = {}\\n        n = len(price)\\n        starting = [0]*(n)\\n        \\n        def dp(state):\\n            if state == needs:\\n                return 0\\n            if any([a > b for a,b in zip(state,needs)]):\\n                return float(\\'inf\\')\\n            \\n            if tuple(state) in memo:\\n                return memo[tuple(state)]\\n            \\n            #minimize by taking only a single item at a time\\n            ans = float(\\'inf\\')\\n            for i in range(n):\\n                next_state = state[:]\\n                next_state[i] += 1\\n                ans = min(ans, price[i] + dp(next_state))\\n            \\n            #or we try using the offers array[][]\\n            for off in special:\\n                next_state = state[:]\\n                for i in range(n):\\n                    next_state[i] += off[i] #add counts\\n                \\n                ans = min(ans, off[-1] + dp(next_state))\\n            \\n            memo[tuple(state)] = ans\\n            return ans\\n        \\n        \\n        return dp(starting)\\n```\\n\\t\\t\\n### Optimization 1:\\n* Instead of starting from the empty counts array, we start with the ```needs``` array and go to the base case as the zeros array\\n* This was we don\\'t have to check each count for a violation\\n* We also try pruning and only advance to valid states\\n\\n\\nTLE 55/65\\n```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n\\n        \\n        memo = {}\\n        n = len(price)\\n        ending = [0]*(n)\\n        \\n        def dp(state):\\n            if state == ending:\\n                return 0\\n            if tuple(state) in memo:\\n                return memo[tuple(state)]\\n            \\n            #minimize by taking only a single item at a time\\n            ans = float(\\'inf\\')\\n            for i in range(n):\\n                next_state = state[:]\\n                if next_state[i] > 0:\\n                    next_state[i] -= 1\\n                    ans = min(ans, price[i] + dp(next_state))\\n            \\n            #or we try using the offers array[][]\\n            for off in special:\\n                next_state = state[:]\\n                broken = False\\n                for i in range(n):\\n                    if next_state[i] >= off[i]:\\n                        next_state[i] -= off[i] #add counts\\n                    else:\\n                        broken = True\\n                        break\\n                if not broken:\\n                    ans = min(ans, off[-1] + dp(next_state))\\n            \\n            memo[tuple(state)] = ans\\n            return ans\\n        \\n        \\n        return dp(needs)\\n\\n```\\n\\n### Final Optimization:\\n* Instead of increaming 1 by 1 and mininzing without taking offers\\n* Just take the dot product between the ```state``` array and prices and the current minmum\\n\\nAC\\n```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n\\n        memo = {}\\n        n = len(price)\\n        ending = [0]*(n)\\n        \\n        def dp(state):\\n            if state == ending:\\n                return 0\\n            if tuple(state) in memo:\\n                return memo[tuple(state)]\\n            \\n            #minimize by taking only a single item at a time\\n            ans = sum([p*c for p,c in zip(price,state)])\\n            \\'\\'\\'\\n            for i in range(n):\\n                next_state = state[:]\\n                if next_state[i] > 0:\\n                    next_state[i] -= 1\\n                    ans = min(ans, price[i] + dp(next_state))\\n            \\'\\'\\'\\n            #or we try using the offers array[][]\\n            for off in special:\\n                next_state = state[:]\\n                broken = False\\n                for i in range(n):\\n                    if next_state[i] >= off[i]:\\n                        next_state[i] -= off[i] #add counts\\n                    else:\\n                        broken = True\\n                        break\\n                if not broken:\\n                    ans = min(ans, off[-1] + dp(next_state))\\n            \\n            memo[tuple(state)] = ans\\n            return ans\\n        \\n        \\n        return dp(needs)\\n```",
                "solutionTags": [],
                "code": "```curr_state```\n```curr_state = [a,b,c,d]```\n```[i,j,k,l]```\n```a```\n```i```\n```b```\n```j```\n```curr_state```\n```curr_state```\n```a```\n```price[i]```\n```[a,b,c,d]```\n```next_state = [a+1,b,c,d] + price[i]```\n```\\ndp(state) = {\\n\\n            for i in range(n):\\n                next_state = state[:]\\n                next_state[i] += 1\\n                ans = min(ans, price[i] + dp(next_state))\\n}\\n```\n```specials[][]```\n```off```\n```off[-1]```\n```\\ndp(state) = {\\n\\t            for off in special:\\n                next_state = state[:]\\n                for i in range(n):\\n                    next_state[i] += off[i] #add counts\\n                \\n                ans = min(ans, off[-1] + dp(next_state))\\n}\\n```\n```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        \\n        memo = {}\\n        n = len(price)\\n        starting = [0]*(n)\\n        \\n        def dp(state):\\n            if state == needs:\\n                return 0\\n            if any([a > b for a,b in zip(state,needs)]):\\n                return float(\\'inf\\')\\n            \\n            if tuple(state) in memo:\\n                return memo[tuple(state)]\\n            \\n            #minimize by taking only a single item at a time\\n            ans = float(\\'inf\\')\\n            for i in range(n):\\n                next_state = state[:]\\n                next_state[i] += 1\\n                ans = min(ans, price[i] + dp(next_state))\\n            \\n            #or we try using the offers array[][]\\n            for off in special:\\n                next_state = state[:]\\n                for i in range(n):\\n                    next_state[i] += off[i] #add counts\\n                \\n                ans = min(ans, off[-1] + dp(next_state))\\n            \\n            memo[tuple(state)] = ans\\n            return ans\\n        \\n        \\n        return dp(starting)\\n```\n```needs```\n```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n\\n        \\n        memo = {}\\n        n = len(price)\\n        ending = [0]*(n)\\n        \\n        def dp(state):\\n            if state == ending:\\n                return 0\\n            if tuple(state) in memo:\\n                return memo[tuple(state)]\\n            \\n            #minimize by taking only a single item at a time\\n            ans = float(\\'inf\\')\\n            for i in range(n):\\n                next_state = state[:]\\n                if next_state[i] > 0:\\n                    next_state[i] -= 1\\n                    ans = min(ans, price[i] + dp(next_state))\\n            \\n            #or we try using the offers array[][]\\n            for off in special:\\n                next_state = state[:]\\n                broken = False\\n                for i in range(n):\\n                    if next_state[i] >= off[i]:\\n                        next_state[i] -= off[i] #add counts\\n                    else:\\n                        broken = True\\n                        break\\n                if not broken:\\n                    ans = min(ans, off[-1] + dp(next_state))\\n            \\n            memo[tuple(state)] = ans\\n            return ans\\n        \\n        \\n        return dp(needs)\\n\\n```\n```state```\n```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n\\n        memo = {}\\n        n = len(price)\\n        ending = [0]*(n)\\n        \\n        def dp(state):\\n            if state == ending:\\n                return 0\\n            if tuple(state) in memo:\\n                return memo[tuple(state)]\\n            \\n            #minimize by taking only a single item at a time\\n            ans = sum([p*c for p,c in zip(price,state)])\\n            \\'\\'\\'\\n            for i in range(n):\\n                next_state = state[:]\\n                if next_state[i] > 0:\\n                    next_state[i] -= 1\\n                    ans = min(ans, price[i] + dp(next_state))\\n            \\'\\'\\'\\n            #or we try using the offers array[][]\\n            for off in special:\\n                next_state = state[:]\\n                broken = False\\n                for i in range(n):\\n                    if next_state[i] >= off[i]:\\n                        next_state[i] -= off[i] #add counts\\n                    else:\\n                        broken = True\\n                        break\\n                if not broken:\\n                    ans = min(ans, off[-1] + dp(next_state))\\n            \\n            memo[tuple(state)] = ans\\n            return ans\\n        \\n        \\n        return dp(needs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864307,
                "title": "java-solution-dp",
                "content": "# Intuition\\nWe have multiple choice here :\\n1. not to take any special offer.\\n2. if one of special offer taken then we can again apply choice on remaining needs\\n\\n# Code\\n```\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        HashMap<List<Integer> ,Integer> dp = new HashMap<>();\\n        return offers(price,special,needs,dp);\\n    }\\n    int offers(List<Integer> price, List<List<Integer>> special, List<Integer> need , HashMap<List<Integer> ,Integer> dp){\\n        if(dp.containsKey(need)){\\n            return dp.get(need);\\n        }\\n\\n        // not to take any special offer\\n        int nos = 0;\\n        for(int i=0 ; i<need.size() ; i++){\\n            nos +=(need.get(i)*price.get(i));\\n        }\\n\\n        // take any special offer and call recursion function on remaining needs\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0 ; i<special.size(); i++){\\n            List<Integer> sp = special.get(i);\\n            // check if no item is taken more than need\\n            if(cantake(sp,need)){\\n                for(int k=0 ; k<need.size() ; k++){\\n                    need.set(k,need.get(k)-sp.get(k));\\n                }\\n                int a = offers(price,special,need,dp) + sp.get(sp.size()-1);\\n                min = Math.min(min,a);\\n                for(int k=0 ; k<need.size() ; k++){\\n                    need.set(k,need.get(k)+sp.get(k));\\n                }\\n\\n            }\\n        }\\n        int ans = Math.min(min,nos);\\n        dp.put(need,ans);\\n        return ans;\\n    }\\n    boolean cantake(List<Integer> sp , List<Integer> nd){\\n        for(int i=0 ; i<nd.size() ; i++){\\n            if(nd.get(i)-sp.get(i)<0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        HashMap<List<Integer> ,Integer> dp = new HashMap<>();\\n        return offers(price,special,needs,dp);\\n    }\\n    int offers(List<Integer> price, List<List<Integer>> special, List<Integer> need , HashMap<List<Integer> ,Integer> dp){\\n        if(dp.containsKey(need)){\\n            return dp.get(need);\\n        }\\n\\n        // not to take any special offer\\n        int nos = 0;\\n        for(int i=0 ; i<need.size() ; i++){\\n            nos +=(need.get(i)*price.get(i));\\n        }\\n\\n        // take any special offer and call recursion function on remaining needs\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0 ; i<special.size(); i++){\\n            List<Integer> sp = special.get(i);\\n            // check if no item is taken more than need\\n            if(cantake(sp,need)){\\n                for(int k=0 ; k<need.size() ; k++){\\n                    need.set(k,need.get(k)-sp.get(k));\\n                }\\n                int a = offers(price,special,need,dp) + sp.get(sp.size()-1);\\n                min = Math.min(min,a);\\n                for(int k=0 ; k<need.size() ; k++){\\n                    need.set(k,need.get(k)+sp.get(k));\\n                }\\n\\n            }\\n        }\\n        int ans = Math.min(min,nos);\\n        dp.put(need,ans);\\n        return ans;\\n    }\\n    boolean cantake(List<Integer> sp , List<Integer> nd){\\n        for(int i=0 ; i<nd.size() ; i++){\\n            if(nd.get(i)-sp.get(i)<0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844096,
                "title": "easy-to-solve-dp-problem",
                "content": "# Intuition\\n\\n# Approach\\nIn every recursive step we changing the needs vector.so,to store the needs vector used map as our dp.\\n\\n# Complexity\\n- Time complexity:\\n    special.size()*special[0].size()* recursive space();\\n\\n- Space complexity:\\nspace of map\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<vector<int>,int>m;\\n    int solve(vector<int>& price, vector<vector<int>>& special, vector<int>& needs){\\n        int cnt_zeros=0;\\n        for(int i:needs){\\n            if(i==0)cnt_zeros++;\\n        }\\n        if(cnt_zeros==needs.size()) return 0;\\n        if(m.count(needs)) return m[needs];\\n        int ans=INT_MAX;\\n\\n        for(auto i:special){\\n            bool istrue=true;\\n            vector<int>a=needs;\\n            for(int j=0;j<i.size()-1;j++){\\n                if(a[j]<i[j]){\\n                    istrue=false;\\n                    break;\\n                }\\n                a[j]-=i[j];\\n            }\\n            if(istrue){\\n                ans=min(ans,i[i.size()-1]+solve(price,special,a));\\n            }\\n        }\\n        int curr_ans=0;\\n        for(int i=0;i<price.size();i++){\\n            curr_ans+=(price[i]*needs[i]);\\n        }\\n\\n        return m[needs]=min(ans,curr_ans);\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n\\n        return solve(price,special,needs);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<vector<int>,int>m;\\n    int solve(vector<int>& price, vector<vector<int>>& special, vector<int>& needs){\\n        int cnt_zeros=0;\\n        for(int i:needs){\\n            if(i==0)cnt_zeros++;\\n        }\\n        if(cnt_zeros==needs.size()) return 0;\\n        if(m.count(needs)) return m[needs];\\n        int ans=INT_MAX;\\n\\n        for(auto i:special){\\n            bool istrue=true;\\n            vector<int>a=needs;\\n            for(int j=0;j<i.size()-1;j++){\\n                if(a[j]<i[j]){\\n                    istrue=false;\\n                    break;\\n                }\\n                a[j]-=i[j];\\n            }\\n            if(istrue){\\n                ans=min(ans,i[i.size()-1]+solve(price,special,a));\\n            }\\n        }\\n        int curr_ans=0;\\n        for(int i=0;i<price.size();i++){\\n            curr_ans+=(price[i]*needs[i]);\\n        }\\n\\n        return m[needs]=min(ans,curr_ans);\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n\\n        return solve(price,special,needs);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810058,
                "title": "o-1-knapsack-dynamic-programming-brute-force-back-tracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    O/1 Kanpsack on special offers and backtrack with needs of items\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    take special offers or not take and take min of both if we take \\n    we have to check such that needs of items is non negative.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    100*(2^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    100*(2^n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,vector<int>>,int>dp;\\n    int solve(int pos,vector<int>&price,vector<int>&needs,vector<vector<int>>& special){\\n        int n=special.size();\\n        if(pos>=n){\\n            int sum=0;\\n            for(int i=0;i<needs.size();i++){\\n                sum+=needs[i]*price[i];\\n            }\\n            return sum;\\n        }\\n        if(dp.find({pos,needs})!=dp.end())return dp[{pos,needs}];\\n        int take=0,nontake=0;\\n        nontake=solve(pos+1,price,needs,special);\\n        int sz=special[pos].size();\\n        bool ok=true;\\n        for(int i=0;i<sz-1;i++){\\n            needs[i]-=special[pos][i];\\n            if(needs[i]<0){\\n                ok=false;\\n            }\\n        }\\n        if(!ok){\\n            for(int i=0;i<sz-1;i++){\\n                needs[i]+=special[pos][i];\\n            } \\n            return dp[{pos,needs}]=nontake;\\n        }\\n        take=special[pos][sz-1]+solve(pos,price,needs,special);\\n        for(int i=0;i<sz-1;i++){\\n            needs[i]+=special[pos][i];\\n        }\\n        return dp[{pos,needs}]=min(take,nontake);\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return solve(0,price,needs,special);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,vector<int>>,int>dp;\\n    int solve(int pos,vector<int>&price,vector<int>&needs,vector<vector<int>>& special){\\n        int n=special.size();\\n        if(pos>=n){\\n            int sum=0;\\n            for(int i=0;i<needs.size();i++){\\n                sum+=needs[i]*price[i];\\n            }\\n            return sum;\\n        }\\n        if(dp.find({pos,needs})!=dp.end())return dp[{pos,needs}];\\n        int take=0,nontake=0;\\n        nontake=solve(pos+1,price,needs,special);\\n        int sz=special[pos].size();\\n        bool ok=true;\\n        for(int i=0;i<sz-1;i++){\\n            needs[i]-=special[pos][i];\\n            if(needs[i]<0){\\n                ok=false;\\n            }\\n        }\\n        if(!ok){\\n            for(int i=0;i<sz-1;i++){\\n                needs[i]+=special[pos][i];\\n            } \\n            return dp[{pos,needs}]=nontake;\\n        }\\n        take=special[pos][sz-1]+solve(pos,price,needs,special);\\n        for(int i=0;i<sz-1;i++){\\n            needs[i]+=special[pos][i];\\n        }\\n        return dp[{pos,needs}]=min(take,nontake);\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        return solve(0,price,needs,special);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799536,
                "title": "638-shopping-offers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n    return dfs(price, special, needs, 0);\\n  }\\n\\n  private int dfs(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int s) {\\n    int ans = 0;\\n    for (int i = 0; i < needs.size(); ++i)\\n      ans += needs.get(i) * price.get(i);\\n\\n    for (int i = s; i < special.size(); ++i) {\\n      List<Integer> offer = special.get(i);\\n      if (isValid(offer, needs)) {\\n        // Use special[i]\\n        for (int j = 0; j < needs.size(); ++j)\\n          needs.set(j, needs.get(j) - offer.get(j));\\n        ans = Math.min(ans, offer.get(offer.size() - 1) + dfs(price, special, needs, i));\\n        // Backtracking - unuse special[i]\\n        for (int j = 0; j < needs.size(); ++j)\\n          needs.set(j, needs.get(j) + offer.get(j));\\n      }\\n    }\\n\\n    return ans;\\n  }\\n\\n  // Check if this special offer is a valid one\\n  private boolean isValid(List<Integer> offer, List<Integer> needs) {\\n    for (int i = 0; i < needs.size(); ++i)\\n      if (offer.get(i) > needs.get(i))\\n        return false;\\n    return true;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n    return dfs(price, special, needs, 0);\\n  }\\n\\n  private int dfs(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int s) {\\n    int ans = 0;\\n    for (int i = 0; i < needs.size(); ++i)\\n      ans += needs.get(i) * price.get(i);\\n\\n    for (int i = s; i < special.size(); ++i) {\\n      List<Integer> offer = special.get(i);\\n      if (isValid(offer, needs)) {\\n        // Use special[i]\\n        for (int j = 0; j < needs.size(); ++j)\\n          needs.set(j, needs.get(j) - offer.get(j));\\n        ans = Math.min(ans, offer.get(offer.size() - 1) + dfs(price, special, needs, i));\\n        // Backtracking - unuse special[i]\\n        for (int j = 0; j < needs.size(); ++j)\\n          needs.set(j, needs.get(j) + offer.get(j));\\n      }\\n    }\\n\\n    return ans;\\n  }\\n\\n  // Check if this special offer is a valid one\\n  private boolean isValid(List<Integer> offer, List<Integer> needs) {\\n    for (int i = 0; i < needs.size(); ++i)\\n      if (offer.get(i) > needs.get(i))\\n        return false;\\n    return true;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790990,
                "title": "python-knapsack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        calculate_cost = lambda state: sum(price * item_quantity for price, item_quantity in zip(price, state))\\n\\n        def isSpecialValid(special_idx: int, state=None) -> bool:\\n            if state is None: state = needs\\n\\n            for i in range(len(special[special_idx]) - 1):\\n                if state[i] < special[special_idx][i]:\\n                    return False\\n            return True\\n        \\n        def use_special(special_idx: int, state) -> int:\\n            for i in range(len(special[special_idx]) - 1):\\n                special_amount = special[special_idx][i]\\n                state[i] -= special_amount\\n            \\n            special_price = special[special_idx][-1]\\n            return special_price, state\\n\\n        specials_map = defaultdict(lambda: float(\\'inf\\'))\\n\\n        # Filter out specials we can\\'t use and identical specials \\n        # If two specials are the same we only keep the one with the lower price\\n        for i in range(len(special)):\\n            if not isSpecialValid(i): continue\\n        \\n            special_id = tuple(special[i][:-1])\\n            special_cost = special[i][-1]\\n            specials_map[special_id] = min(specials_map[special_id], special_cost)\\n        \\n        special = [key + (val,) for key, val in specials_map.items()]\\n        \\n        # Go through each state with a stack\\n        # We build upwards by creating new states if their potential price is less \\n        # Than the current min\\n        \\n        state = [0] * len(special)\\n        stack = [[0, needs[:]]]\\n        min_cost = float(\\'inf\\')\\n\\n        while stack:\\n            curr_price, curr_state = stack.pop()\\n\\n            if curr_price >= min_cost:\\n                continue\\n            \\n            min_cost = min(min_cost, calculate_cost(curr_state) + curr_price)\\n\\n            for i in range(len(special)):\\n                if isSpecialValid(i, curr_state):\\n                    next_price, next_state = use_special(i, curr_state[:])\\n                    next_price += curr_price\\n\\n                    if next_price < min_cost:\\n                        stack.append((next_price, next_state))\\n            \\n\\n\\n        return min_cost\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        calculate_cost = lambda state: sum(price * item_quantity for price, item_quantity in zip(price, state))\\n\\n        def isSpecialValid(special_idx: int, state=None) -> bool:\\n            if state is None: state = needs\\n\\n            for i in range(len(special[special_idx]) - 1):\\n                if state[i] < special[special_idx][i]:\\n                    return False\\n            return True\\n        \\n        def use_special(special_idx: int, state) -> int:\\n            for i in range(len(special[special_idx]) - 1):\\n                special_amount = special[special_idx][i]\\n                state[i] -= special_amount\\n            \\n            special_price = special[special_idx][-1]\\n            return special_price, state\\n\\n        specials_map = defaultdict(lambda: float(\\'inf\\'))\\n\\n        # Filter out specials we can\\'t use and identical specials \\n        # If two specials are the same we only keep the one with the lower price\\n        for i in range(len(special)):\\n            if not isSpecialValid(i): continue\\n        \\n            special_id = tuple(special[i][:-1])\\n            special_cost = special[i][-1]\\n            specials_map[special_id] = min(specials_map[special_id], special_cost)\\n        \\n        special = [key + (val,) for key, val in specials_map.items()]\\n        \\n        # Go through each state with a stack\\n        # We build upwards by creating new states if their potential price is less \\n        # Than the current min\\n        \\n        state = [0] * len(special)\\n        stack = [[0, needs[:]]]\\n        min_cost = float(\\'inf\\')\\n\\n        while stack:\\n            curr_price, curr_state = stack.pop()\\n\\n            if curr_price >= min_cost:\\n                continue\\n            \\n            min_cost = min(min_cost, calculate_cost(curr_state) + curr_price)\\n\\n            for i in range(len(special)):\\n                if isSpecialValid(i, curr_state):\\n                    next_price, next_state = use_special(i, curr_state[:])\\n                    next_price += curr_price\\n\\n                    if next_price < min_cost:\\n                        stack.append((next_price, next_state))\\n            \\n\\n\\n        return min_cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776520,
                "title": "brute-force-cpp-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    map<vector<int>,int> m;\\n\\n    int DFS(vector<int>& curr,vector<vector<int>>& special,vector<int>& price){\\n        int n = curr.size();\\n        if(m.find(curr)!=m.end()) return m[curr];\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=(curr[i]*price[i]);\\n        }\\n        for(auto x : special){\\n            int canbuy=1;\\n            for(int i=0;i<n;i++){\\n                if(x[i] > curr[i]){\\n                    canbuy = 0;\\n                    break;\\n                }\\n            }\\n            // cout<<\"canbuy is \"<<canbuy<<endl;\\n            if(canbuy > 0){\\n                for(int i=0;i<n;i++){\\n                    curr[i]-=canbuy*x[i];\\n                }\\n                ans = min(ans,DFS(curr,special,price) + x[n]*canbuy);\\n                for(int i=0;i<n;i++){\\n                    curr[i]+=canbuy*x[i];\\n                }\\n            }\\n        }\\n        m[curr] = ans;\\n        return ans;\\n    }\\n\\n\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int n = price.size();\\n        vector<int> nnn(n,0);\\n        m[nnn]=0;\\n        return DFS(needs,special,price);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    map<vector<int>,int> m;\\n\\n    int DFS(vector<int>& curr,vector<vector<int>>& special,vector<int>& price){\\n        int n = curr.size();\\n        if(m.find(curr)!=m.end()) return m[curr];\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=(curr[i]*price[i]);\\n        }\\n        for(auto x : special){\\n            int canbuy=1;\\n            for(int i=0;i<n;i++){\\n                if(x[i] > curr[i]){\\n                    canbuy = 0;\\n                    break;\\n                }\\n            }\\n            // cout<<\"canbuy is \"<<canbuy<<endl;\\n            if(canbuy > 0){\\n                for(int i=0;i<n;i++){\\n                    curr[i]-=canbuy*x[i];\\n                }\\n                ans = min(ans,DFS(curr,special,price) + x[n]*canbuy);\\n                for(int i=0;i<n;i++){\\n                    curr[i]+=canbuy*x[i];\\n                }\\n            }\\n        }\\n        m[curr] = ans;\\n        return ans;\\n    }\\n\\n\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int n = price.size();\\n        vector<int> nnn(n,0);\\n        m[nnn]=0;\\n        return DFS(needs,special,price);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3761188,
                "title": "55-96-easy-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nComapre normal price with special price each dfs unless special price item is more than needs to purchase remaining items\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndfs solution, using memorization. Remember to parse dfs(tuple(items)), or it would be unhashable for @cache.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        @cache\\n        def dfs(items) -> int:\\n            res = sum(items[i] * price[i] for i in range(len(items)))\\n            for s in special:\\n                remains = [items[i] - s[i] for i in range(len(items))]\\n                if min(remains) >= 0:\\n                    res = min(res,s[-1]+dfs(tuple(remains)))\\n            return res\\n        return dfs(tuple(needs))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        @cache\\n        def dfs(items) -> int:\\n            res = sum(items[i] * price[i] for i in range(len(items)))\\n            for s in special:\\n                remains = [items[i] - s[i] for i in range(len(items))]\\n                if min(remains) >= 0:\\n                    res = min(res,s[-1]+dfs(tuple(remains)))\\n            return res\\n        return dfs(tuple(needs))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742630,
                "title": "10-line-code-python-dfs-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStandard dfs recursion function and have a clear understanding for how to use memoization. \\n**Key: for the same remaining items list, it will cost the same minimum amount. (explained later in detail)**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf we define:\\n```items = [x, y, z...]```: the remaining items list\\n```res```: the minimum cost to purchase ```items```\\n```def dfs(items) -> int:```: returns the minimum cost to purchase ```items```, which is```res```\\n\\nAt each step, for the remaining items we have to purchase, we have two scenarios:\\n1. Don\\'t use special offers at all, and just buy the remaining items with each item\\'s origional cost (ie: cost in ```price``` list). The code would look like:\\n```\\nres = sum(items[i] * price[i] for i in range(len(items)))\\n```\\n2. Consider using speical offers, we will loop through all usable special offers. To check whether a special offer is usable, the remaining item count for each item has to be greater than the item count in special offer. We check with the following code:\\n```\\nif all(items[i] - s[i] >= 0 for i in range(len(items)):\\n``` \\nThen, to explore each usable special offer:\\n```\\n# loop through special offers\\nfor s in special:\\n    # check if special offer is usable\\n    if all(items[i] - s[i] >= 0 for i in range(len(items))):\\n        # apply this special offer\\n        items = [items[i] - s[i] for i in range(len(items))]\\n        # find the cost of remaining items, and update minimum cost\\n        res = min(res, s[-1] + dfs(tuple(items)))\\n        # un-apply this special offer\\n        items = [items[i] + s[i] for i in range(len(items))]\\n```\\n\\n3. Lastly, we can cache the result. For the same ```items``` list, we will have to spend the same amount of money to purchase all the remaining items in ```items```. Yet, we cannot cache type list, so remember to modify the input variable for ```dfs(items)``` as tuple (see ```dfs(tuple(items))``` in 2.).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nPretty complicated, see other posts\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPretty complicated, see other posts\\n\\n# Code\\n```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        @cache\\n        def dfs(items) -> int:\\n            res = sum(items[i] * price[i] for i in range(len(items)))\\n            for s in special:\\n                if all(items[i] - s[i] >= 0 for i in range(len(items))):\\n                    items = [items[i] - s[i] for i in range(len(items))]\\n                    res = min(res, s[-1] + dfs(tuple(items)))\\n                    items = [items[i] + s[i] for i in range(len(items))]\\n            return res\\n        return dfs(tuple(needs))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```items = [x, y, z...]```\n```res```\n```items```\n```def dfs(items) -> int:```\n```items```\n```res```\n```price```\n```\\nres = sum(items[i] * price[i] for i in range(len(items)))\\n```\n```\\nif all(items[i] - s[i] >= 0 for i in range(len(items)):\\n```\n```\\n# loop through special offers\\nfor s in special:\\n    # check if special offer is usable\\n    if all(items[i] - s[i] >= 0 for i in range(len(items))):\\n        # apply this special offer\\n        items = [items[i] - s[i] for i in range(len(items))]\\n        # find the cost of remaining items, and update minimum cost\\n        res = min(res, s[-1] + dfs(tuple(items)))\\n        # un-apply this special offer\\n        items = [items[i] + s[i] for i in range(len(items))]\\n```\n```items```\n```items```\n```dfs(items)```\n```dfs(tuple(items))```\n```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        @cache\\n        def dfs(items) -> int:\\n            res = sum(items[i] * price[i] for i in range(len(items)))\\n            for s in special:\\n                if all(items[i] - s[i] >= 0 for i in range(len(items))):\\n                    items = [items[i] - s[i] for i in range(len(items))]\\n                    res = min(res, s[-1] + dfs(tuple(items)))\\n                    items = [items[i] + s[i] for i in range(len(items))]\\n            return res\\n        return dfs(tuple(needs))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742629,
                "title": "python-3-10-line-code-dfs-memoization-easy-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStandard dfs recursion function and have a clear understanding for how to use memoization. \\n**Key: for the same remaining items list, it will cost the same minimum amount. (explained later in detail)**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf we define:\\n```items = [x, y, z...]```: the remaining items list\\n```res```: the minimum cost to purchase ```items```\\n```def dfs(items) -> int:```: returns the minimum cost to purchase ```items```, which is```res```\\n\\nAt each step, for the remaining items we have to purchase, we have two scenarios:\\n1. Don\\'t use special offers at all, and just buy the remaining items with each item\\'s origional cost (ie: cost in ```price``` list). The code would look like:\\n```\\nres = sum(items[i] * price[i] for i in range(len(items)))\\n```\\n2. Consider using speical offers, we will loop through all usable special offers. To check whether a special offer is usable, the remaining item count for each item has to be greater than the item count in special offer. We check with the following code:\\n```\\nif all(items[i] - s[i] >= 0 for i in range(len(items)):\\n``` \\nThen, to explore each usable special offer:\\n```\\n# loop through special offers\\nfor s in special:\\n    # check if special offer is usable\\n    if all(items[i] - s[i] >= 0 for i in range(len(items))):\\n        # apply this special offer\\n        items = [items[i] - s[i] for i in range(len(items))]\\n        # find the cost of remaining items, and update minimum cost\\n        res = min(res, s[-1] + dfs(tuple(items)))\\n        # un-apply this special offer\\n        items = [items[i] + s[i] for i in range(len(items))]\\n```\\n\\n3. Lastly, we can cache the result. For the same ```items``` list, we will have to spend the same amount of money to purchase all the remaining items in ```items```. Yet, we cannot cache type list, so remember to modify the input variable for ```dfs(items)``` as tuple (see ```dfs(tuple(items))``` in 2.).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nPretty complicated, see other posts\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPretty complicated, see other posts\\n\\n# Code\\n```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        @cache\\n        def dfs(items) -> int:\\n            res = sum(items[i] * price[i] for i in range(len(items)))\\n            for s in special:\\n                if all(items[i] - s[i] >= 0 for i in range(len(items))):\\n                    items = [items[i] - s[i] for i in range(len(items))]\\n                    res = min(res, s[-1] + dfs(tuple(items)))\\n                    items = [items[i] + s[i] for i in range(len(items))]\\n            return res\\n        return dfs(tuple(needs))",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```items = [x, y, z...]```\n```res```\n```items```\n```def dfs(items) -> int:```\n```items```\n```res```\n```price```\n```\\nres = sum(items[i] * price[i] for i in range(len(items)))\\n```\n```\\nif all(items[i] - s[i] >= 0 for i in range(len(items)):\\n```\n```\\n# loop through special offers\\nfor s in special:\\n    # check if special offer is usable\\n    if all(items[i] - s[i] >= 0 for i in range(len(items))):\\n        # apply this special offer\\n        items = [items[i] - s[i] for i in range(len(items))]\\n        # find the cost of remaining items, and update minimum cost\\n        res = min(res, s[-1] + dfs(tuple(items)))\\n        # un-apply this special offer\\n        items = [items[i] + s[i] for i in range(len(items))]\\n```\n```items```\n```items```\n```dfs(items)```\n```dfs(tuple(items))```",
                "codeTag": "Python3"
            },
            {
                "id": 3742390,
                "title": "js-solution",
                "content": "# Approach\\nWe have to check for each of the offer , if the offer has less than or equal to the no. of elements in the needs array then we can say it is a valid offer otherwise discard that offer as it has more items than our requirement , and then take minimum of all the costs we got from each of the offers. At the start we have to consider the costs from price array and check if the cost due to actual price array without offers is less if so then take it as minimum. To do this we iterate for each of the offer and check for validity if valid offer then take into account that offer and initiate a recursive call. without memoisation it would give time limit error, this can be avoided using memoisation we can\\'t directly pass array as parameter in case we did for integers like ans[i][j] and so on . So to handle this a string is created from array elements of needs as the needs array keeps on changing, now this string is used as key and passed in a map. so we achieve memoisation using this process. \\n# Code\\n```\\nconst f = (price , needs , offers , ans) => {\\n    let key = \\'\\' \\n    for(let need of needs) key += `_${need}`;\\n    if(ans.has(key)) return ans.get(key);\\n    // console.log({key});\\n    let cost = 0 ; \\n    for(let i=0;i<price.length;i++) cost+= (price[i]*needs[i] ); // in case of no better offers \\n    // looking for better offers than original price \\n    for(let offer of offers) {\\n        let temp = Array.from(needs) , valid = true ;// doing temp = needs create only reference to needs\\n        for(let i=0;i<temp.length;i++){\\n            temp[i]-=offer[i];\\n            if(temp[i]<0) valid = false ; \\n        }\\n        if(valid) cost = Math.min(cost , offer[offer.length-1] + f(price , temp , offers , ans));\\n    }\\n    ans.set(key,cost); \\n    return cost ; \\n}\\nvar shoppingOffers = function(price, offers, needs) {\\n    let ans = new Map() ; \\n    return f(price , needs , offers , ans) ;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst f = (price , needs , offers , ans) => {\\n    let key = \\'\\' \\n    for(let need of needs) key += `_${need}`;\\n    if(ans.has(key)) return ans.get(key);\\n    // console.log({key});\\n    let cost = 0 ; \\n    for(let i=0;i<price.length;i++) cost+= (price[i]*needs[i] ); // in case of no better offers \\n    // looking for better offers than original price \\n    for(let offer of offers) {\\n        let temp = Array.from(needs) , valid = true ;// doing temp = needs create only reference to needs\\n        for(let i=0;i<temp.length;i++){\\n            temp[i]-=offer[i];\\n            if(temp[i]<0) valid = false ; \\n        }\\n        if(valid) cost = Math.min(cost , offer[offer.length-1] + f(price , temp , offers , ans));\\n    }\\n    ans.set(key,cost); \\n    return cost ; \\n}\\nvar shoppingOffers = function(price, offers, needs) {\\n    let ans = new Map() ; \\n    return f(price , needs , offers , ans) ;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3712625,
                "title": "c-solution-using-dp-easy-to-understand-nice-storage-idea",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int ShoppingOffers(IList<int> price, IList<IList<int>> special, IList<int> needs) {\\n        int n = price.Count;\\n        Dictionary<int,int> dp = new Dictionary<int,int>();\\n        int getHash(int[] arr){\\n            int hash = 7;\\n            for(int i = 0;i < arr.Length;i++)\\n                hash = hash * 11 + arr[i];\\n            return hash;\\n        }\\n        int solve(int[] need){\\n            int hash = getHash(need);\\n            if(dp.ContainsKey(hash)) return dp[hash];\\n            int res = 0;\\n            for(int i = 0; i < n;i++) res+= (need[i] * price[i]);\\n            // try offers\\n            foreach(var offer in special){\\n                int[] newNeeds = new int[n];\\n                bool canUse = true;\\n                for(int i = 0; i < n ;i++){\\n                    if(need[i] >= offer[i])\\n                        newNeeds[i] = need[i] - offer[i];\\n                    else {\\n                        canUse = false;\\n                        break;\\n                    }\\n                }\\n                if(canUse)\\n                    res = Math.Min(res, offer[n] + solve(newNeeds));\\n            }\\n            dp.Add(hash,res);\\n            return res;\\n        }\\n        return solve(needs.ToArray());\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int ShoppingOffers(IList<int> price, IList<IList<int>> special, IList<int> needs) {\\n        int n = price.Count;\\n        Dictionary<int,int> dp = new Dictionary<int,int>();\\n        int getHash(int[] arr){\\n            int hash = 7;\\n            for(int i = 0;i < arr.Length;i++)\\n                hash = hash * 11 + arr[i];\\n            return hash;\\n        }\\n        int solve(int[] need){\\n            int hash = getHash(need);\\n            if(dp.ContainsKey(hash)) return dp[hash];\\n            int res = 0;\\n            for(int i = 0; i < n;i++) res+= (need[i] * price[i]);\\n            // try offers\\n            foreach(var offer in special){\\n                int[] newNeeds = new int[n];\\n                bool canUse = true;\\n                for(int i = 0; i < n ;i++){\\n                    if(need[i] >= offer[i])\\n                        newNeeds[i] = need[i] - offer[i];\\n                    else {\\n                        canUse = false;\\n                        break;\\n                    }\\n                }\\n                if(canUse)\\n                    res = Math.Min(res, offer[n] + solve(newNeeds));\\n            }\\n            dp.Add(hash,res);\\n            return res;\\n        }\\n        return solve(needs.ToArray());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704604,
                "title": "very-easy-cpp-solution-using-memoization-similar-to-knapsack-solution",
                "content": "# Approach\\nSimilar to unbounded knapsack problem just few changes\\n1) In unbouded knapsack problem we can take same weight again similarly here we can take same offer again after using it once\\n2) In unbouded knapsack we used to check whether we can pick weight or not similarly here we have to check whether offer is valid or not if valid then pick it else not pick\\n\\nAs for each offer we have two options either take offer or reject check for next offer then take minimun pick and notPick offer\\n\\n# Complexity\\n- Time complexity: O(n*m) where \"n\" is the number of items and \"m\" is the number of offers.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m) + recursion stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int ind, vector<int>& prices, vector<vector<int>>& special, vector<int>& needs,unordered_map<string, int>& dp) {\\n        if (ind >= special.size()) {\\n            int cost = 0;\\n            for (int j = 0; j < needs.size(); j++) {\\n                cost += needs[j] * prices[j];\\n            }\\n            return cost;\\n        }\\n\\n        string state = getKey(ind, needs);\\n        if (dp.count(state)) {\\n            return dp[state];\\n        }\\n\\n        int minPrice = INT_MAX;\\n\\n        bool validoffer = true;\\n\\n        for (int j = 0; j < needs.size(); j++) {\\n            if (special[ind][j] > needs[j]) {\\n                validoffer = false;\\n                break;\\n            }\\n        }\\n\\n        if (validoffer) {\\n            for(int j = 0; j < needs.size(); j++) {\\n                 needs[j] -= special[ind][j];\\n            }\\n\\n            minPrice = min(minPrice, special[ind][needs.size()] + solve(ind,prices, special, needs,dp));//check if same offer can be used again\\n\\n            for(int k = 0; k < needs.size(); k++) {\\n                needs[k] += special[ind][k];\\n            }\\n        }\\n\\n        int notPickprice = solve(ind + 1, prices, special, needs,dp);//not taking current offer\\n\\n        minPrice = min(minPrice, notPickprice);\\n\\n        return dp[state] = minPrice;\\n    }\\n\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        unordered_map<string, int> dp;\\n        int ans = solve(0,price, special, needs,dp);\\n        return ans;\\n    }\\n    \\n    private:\\n    string getKey(int ind, vector<int>& needs) {\\n        string key = to_string(ind) + \"-\";\\n        for (int i = 0; i < needs.size(); i++) {\\n            key += to_string(needs[i]) + \"-\";\\n        }\\n        return key;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int ind, vector<int>& prices, vector<vector<int>>& special, vector<int>& needs,unordered_map<string, int>& dp) {\\n        if (ind >= special.size()) {\\n            int cost = 0;\\n            for (int j = 0; j < needs.size(); j++) {\\n                cost += needs[j] * prices[j];\\n            }\\n            return cost;\\n        }\\n\\n        string state = getKey(ind, needs);\\n        if (dp.count(state)) {\\n            return dp[state];\\n        }\\n\\n        int minPrice = INT_MAX;\\n\\n        bool validoffer = true;\\n\\n        for (int j = 0; j < needs.size(); j++) {\\n            if (special[ind][j] > needs[j]) {\\n                validoffer = false;\\n                break;\\n            }\\n        }\\n\\n        if (validoffer) {\\n            for(int j = 0; j < needs.size(); j++) {\\n                 needs[j] -= special[ind][j];\\n            }\\n\\n            minPrice = min(minPrice, special[ind][needs.size()] + solve(ind,prices, special, needs,dp));//check if same offer can be used again\\n\\n            for(int k = 0; k < needs.size(); k++) {\\n                needs[k] += special[ind][k];\\n            }\\n        }\\n\\n        int notPickprice = solve(ind + 1, prices, special, needs,dp);//not taking current offer\\n\\n        minPrice = min(minPrice, notPickprice);\\n\\n        return dp[state] = minPrice;\\n    }\\n\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        unordered_map<string, int> dp;\\n        int ans = solve(0,price, special, needs,dp);\\n        return ans;\\n    }\\n    \\n    private:\\n    string getKey(int ind, vector<int>& needs) {\\n        string key = to_string(ind) + \"-\";\\n        for (int i = 0; i < needs.size(); i++) {\\n            key += to_string(needs[i]) + \"-\";\\n        }\\n        return key;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692452,
                "title": "runtime-3ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// class Solution {\\n// public:\\n//     // int rec(vector<int>& price, vector<vector<int>>& special, vector<int> needs, int ind, vector<int> &dp){\\n//     //     if(ind== special.size()){\\n//     //         int res = 0;\\n//     //         for(int i= 0; i< price.size(); i++){\\n//     //             res += needs[i] * price[i];\\n//     //         }\\n//     //         return res;\\n//     //     }\\n\\n//     //     // if(dp[ind]!= -1)    return dp[ind];\\n//     //     int no= 0+ rec(price, special, needs, ind+ 1, dp);\\n//     //     int yes= INT_MAX;\\n//     //     for(int i=0; i<needs.size(); i++){\\n//     //         needs[i] = needs[i] - special[ind][i];\\n//     //         if(needs[i] < 0) return no;\\n//     //     }\\n//     //     yes= special[ind][needs.size()]+ rec(price, special, needs, ind, dp);\\n//     //     // return dp[ind]= min(no, yes);\\n//     //     return min(no, yes);\\n//     // }\\n//     // int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n//     //     vector<int> dp(special.size()+ 1, -1);\\n//     //     return rec(price, special, needs, 0, dp);\\n//     // }\\n\\n     \\n// };\\n\\nclass Solution {\\nprivate:\\n    map<vector<int>, int> mpp;\\n    int solve(int mn, vector<int>& price, vector<int>& needs, vector<vector<int>>& special, int n, int wihoutOfferPrice){\\n         if(mpp.find(needs) != mpp.end())\\n            return mpp[needs];\\n        for(int i=0; i<special.size(); i++){\\n            int fl = 1;\\n            for(int j=0; j<n; j++){\\n                if(special[i][j] > needs[j]){\\n                    fl = 0;\\n                    break;\\n                }\\n            }\\n            if(fl){\\n                vector<int> newNeeds(n);\\n                for(int k=0; k<n; k++)\\n                    newNeeds[k] = needs[k] - special[i][k];\\n                int money = special[i][n] + shoppingOffers(price, special, newNeeds);\\n                if(money < wihoutOfferPrice)\\n                    wihoutOfferPrice = money;\\n            }\\n        }\\n        return mpp[needs] = wihoutOfferPrice;\\n    }\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int n = price.size();\\n        int wihoutOfferPrice = 0;\\n        for(int i=0; i<n; i++)\\n            wihoutOfferPrice += price[i]*needs[i];\\n        int mn = wihoutOfferPrice;\\n        return solve(mn, price, needs, special, n, wihoutOfferPrice);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// class Solution {\\n// public:\\n//     // int rec(vector<int>& price, vector<vector<int>>& special, vector<int> needs, int ind, vector<int> &dp){\\n//     //     if(ind== special.size()){\\n//     //         int res = 0;\\n//     //         for(int i= 0; i< price.size(); i++){\\n//     //             res += needs[i] * price[i];\\n//     //         }\\n//     //         return res;\\n//     //     }\\n\\n//     //     // if(dp[ind]!= -1)    return dp[ind];\\n//     //     int no= 0+ rec(price, special, needs, ind+ 1, dp);\\n//     //     int yes= INT_MAX;\\n//     //     for(int i=0; i<needs.size(); i++){\\n//     //         needs[i] = needs[i] - special[ind][i];\\n//     //         if(needs[i] < 0) return no;\\n//     //     }\\n//     //     yes= special[ind][needs.size()]+ rec(price, special, needs, ind, dp);\\n//     //     // return dp[ind]= min(no, yes);\\n//     //     return min(no, yes);\\n//     // }\\n//     // int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n//     //     vector<int> dp(special.size()+ 1, -1);\\n//     //     return rec(price, special, needs, 0, dp);\\n//     // }\\n\\n     \\n// };\\n\\nclass Solution {\\nprivate:\\n    map<vector<int>, int> mpp;\\n    int solve(int mn, vector<int>& price, vector<int>& needs, vector<vector<int>>& special, int n, int wihoutOfferPrice){\\n         if(mpp.find(needs) != mpp.end())\\n            return mpp[needs];\\n        for(int i=0; i<special.size(); i++){\\n            int fl = 1;\\n            for(int j=0; j<n; j++){\\n                if(special[i][j] > needs[j]){\\n                    fl = 0;\\n                    break;\\n                }\\n            }\\n            if(fl){\\n                vector<int> newNeeds(n);\\n                for(int k=0; k<n; k++)\\n                    newNeeds[k] = needs[k] - special[i][k];\\n                int money = special[i][n] + shoppingOffers(price, special, newNeeds);\\n                if(money < wihoutOfferPrice)\\n                    wihoutOfferPrice = money;\\n            }\\n        }\\n        return mpp[needs] = wihoutOfferPrice;\\n    }\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int n = price.size();\\n        int wihoutOfferPrice = 0;\\n        for(int i=0; i<n; i++)\\n            wihoutOfferPrice += price[i]*needs[i];\\n        int mn = wihoutOfferPrice;\\n        return solve(mn, price, needs, special, n, wihoutOfferPrice);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689765,
                "title": "c-recursion-take-not-take-memoization-easy-to-understand",
                "content": "# Intuition\\nAt each offer we have 2 choices, we can take that offer or we can not take that offer,and return the minimum cost, so we use recursion to get all posibilities\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int i,vector<int> temp,vector<int>& price, vector<vector<int>>& special, vector<int>& needs,map<int,map<vector<int>,int>> &dp){\\n    //base case: when i==special size means all offer ended\\n    if(i==special.size()){\\n        //finding is there any item still pending to buy if yes then find\\n        //its total cost and return\\n        int cost=0;\\n        //traversing need array and checking that is there any item remain\\n        for(int i=0;i<needs.size();i++){\\n            cost=cost+(needs[i]-temp[i])*price[i];\\n        }\\n        return cost;\\n    }\\n    //checking current i and temp already in dp?\\n    if(dp.find(i)!=dp.end() && dp[i].find(temp)!=dp[i].end()){\\n        return dp[i][temp];\\n    }\\n    //not taking the current offer\\n    int ntake=solve(i+1,temp,price,special,needs,dp);\\n    //for taking the current offer, the quantity of item in special must be\\n    //less than or equal to the item need present in needs array\\n    int take=INT_MAX;\\n    //copying the current value temp so that if we not able to take this\\n    //at any point of checking the offer so we can pass the temp\\n    vector<int> copy=temp;\\n    //checking we can take this offer?\\n    for(int j=0;j<needs.size();j++){\\n        if(copy[j]+special[i][j]<=needs[j]){\\n            copy[j]=copy[j]+special[i][j];\\n        }\\n        //at any point the above condition not satisfy cant ake this offer\\n        else{\\n            return dp[i][temp]=min(ntake,take);\\n        }\\n    }\\n    //taking the offer add the price to of items and we can take \\n    //this offer any number of time so we can stay at this offer only\\n    take=special[i][needs.size()]+solve(i,copy,price,special,needs,dp);\\n\\n    return dp[i][temp]=min(take,ntake);\\n}\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        //INTUTION: At each offer we have 2 choices, we can take that offer\\n        //or we can not take that offer,and return the minimum cost, so\\n        //we use recursion to get all posibilities\\n\\n        \\n\\n        //taking an array that help to keep current  count of need of each \\n        //item, its intialize with 0 means we did not take any item yet\\n        vector<int> temp(needs.size(),0);\\n\\n        //if draw recursion gree so we find that there is overlapping sub\\n        //problem so we can do memoization\\n\\n        //here there is 2 changing parameter i and temp, so we take a map\\n        map<int,map<vector<int>,int>> dp;\\n\\n        //mtaking a recursive call that return required min cost\\n        int ans=solve(0,temp,price,special,needs,dp);\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(int i,vector<int> temp,vector<int>& price, vector<vector<int>>& special, vector<int>& needs,map<int,map<vector<int>,int>> &dp){\\n    //base case: when i==special size means all offer ended\\n    if(i==special.size()){\\n        //finding is there any item still pending to buy if yes then find\\n        //its total cost and return\\n        int cost=0;\\n        //traversing need array and checking that is there any item remain\\n        for(int i=0;i<needs.size();i++){\\n            cost=cost+(needs[i]-temp[i])*price[i];\\n        }\\n        return cost;\\n    }\\n    //checking current i and temp already in dp?\\n    if(dp.find(i)!=dp.end() && dp[i].find(temp)!=dp[i].end()){\\n        return dp[i][temp];\\n    }\\n    //not taking the current offer\\n    int ntake=solve(i+1,temp,price,special,needs,dp);\\n    //for taking the current offer, the quantity of item in special must be\\n    //less than or equal to the item need present in needs array\\n    int take=INT_MAX;\\n    //copying the current value temp so that if we not able to take this\\n    //at any point of checking the offer so we can pass the temp\\n    vector<int> copy=temp;\\n    //checking we can take this offer?\\n    for(int j=0;j<needs.size();j++){\\n        if(copy[j]+special[i][j]<=needs[j]){\\n            copy[j]=copy[j]+special[i][j];\\n        }\\n        //at any point the above condition not satisfy cant ake this offer\\n        else{\\n            return dp[i][temp]=min(ntake,take);\\n        }\\n    }\\n    //taking the offer add the price to of items and we can take \\n    //this offer any number of time so we can stay at this offer only\\n    take=special[i][needs.size()]+solve(i,copy,price,special,needs,dp);\\n\\n    return dp[i][temp]=min(take,ntake);\\n}\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        //INTUTION: At each offer we have 2 choices, we can take that offer\\n        //or we can not take that offer,and return the minimum cost, so\\n        //we use recursion to get all posibilities\\n\\n        \\n\\n        //taking an array that help to keep current  count of need of each \\n        //item, its intialize with 0 means we did not take any item yet\\n        vector<int> temp(needs.size(),0);\\n\\n        //if draw recursion gree so we find that there is overlapping sub\\n        //problem so we can do memoization\\n\\n        //here there is 2 changing parameter i and temp, so we take a map\\n        map<int,map<vector<int>,int>> dp;\\n\\n        //mtaking a recursive call that return required min cost\\n        int ans=solve(0,temp,price,special,needs,dp);\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688483,
                "title": "recursive-knapsack-memoisation-very-clean-code",
                "content": "```\\nint operator* (const vector<int>&a, const vector<int>&b) {\\n        int sum =0;\\n        for(int i =0; i<a.size(); i++) {\\n            sum+=a[i]*b[i];\\n        }\\n        return sum;\\n    }\\n    \\n    bool operator > (vector<int>&a, vector<int>& b) {\\n\\n        for(int i=0; i<a.size(); i++) {\\n            if(a[i]<b[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    void operator -=(vector<int>&a, vector<int>& b) {\\n\\n        for(int i=0; i<a.size(); i++) {\\n            a[i]-=b[i];\\n        }\\n    }\\n    void operator +=(vector<int>&a, vector<int>& b) {\\n\\n        for(int i=0; i<a.size(); i++) {\\n            a[i]+=b[i];\\n        }\\n    }\\n\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    int go(vector<int>&needs, vector<int>&price, vector<vector<int>>& special, map<vector<int>,int>&dp) {\\n        \\n        int cost = price*needs;\\n        \\n        if(dp.find(needs)!=dp.end()) {\\n            return dp[needs];\\n        }\\n        for(auto sp : special) {\\n            if(sp.back() >= cost)\\n                continue;\\n            if(needs>sp){\\n                //if no. of each item in need is greater than offer\\'s freq \\n                needs-=sp;\\n                cost = min(cost,sp.back()+go(needs,price,special,dp));\\n                needs+=sp;\\n                \\n            }\\n        }\\n        return dp[needs]=cost;\\n        \\n        \\n    }\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        map<vector<int>,int>dp;\\n        return go(needs,price,special,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint operator* (const vector<int>&a, const vector<int>&b) {\\n        int sum =0;\\n        for(int i =0; i<a.size(); i++) {\\n            sum+=a[i]*b[i];\\n        }\\n        return sum;\\n    }\\n    \\n    bool operator > (vector<int>&a, vector<int>& b) {\\n\\n        for(int i=0; i<a.size(); i++) {\\n            if(a[i]<b[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    void operator -=(vector<int>&a, vector<int>& b) {\\n\\n        for(int i=0; i<a.size(); i++) {\\n            a[i]-=b[i];\\n        }\\n    }\\n    void operator +=(vector<int>&a, vector<int>& b) {\\n\\n        for(int i=0; i<a.size(); i++) {\\n            a[i]+=b[i];\\n        }\\n    }\\n\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    int go(vector<int>&needs, vector<int>&price, vector<vector<int>>& special, map<vector<int>,int>&dp) {\\n        \\n        int cost = price*needs;\\n        \\n        if(dp.find(needs)!=dp.end()) {\\n            return dp[needs];\\n        }\\n        for(auto sp : special) {\\n            if(sp.back() >= cost)\\n                continue;\\n            if(needs>sp){\\n                //if no. of each item in need is greater than offer\\'s freq \\n                needs-=sp;\\n                cost = min(cost,sp.back()+go(needs,price,special,dp));\\n                needs+=sp;\\n                \\n            }\\n        }\\n        return dp[needs]=cost;\\n        \\n        \\n    }\\n    \\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        map<vector<int>,int>dp;\\n        return go(needs,price,special,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661871,
                "title": "c-knapsack-dp-memoization-using-hashmap-easy-to-understand",
                "content": "# Approach : Dynamic Programming\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n- Time complexity: $$O(n*m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- Here,\\nm=size of special array \\nn=size of price array (as given in constraint, n<=6 so, It will not increase time complexity much)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,map<vector<int>,int>>mp;\\n    int func(int ind,vector<int>&p,vector<int>need,vector<vector<int>>&spec){\\n        if(ind>=p.size()) return 0;\\n        if(mp[ind][need]) return mp[ind][need];\\n        vector<int>temp1(need);\\n        temp1[ind]=0;\\n        int t1=p[ind]*need[ind]+func(ind+1,p,temp1,spec);\\n        int t2=INT_MAX;\\n        for(int i=0;i<spec.size();i++){\\n            int f=0;\\n            for(int j=0;j<spec[i].size()-1;j++){\\n                if(spec[i][j]>need[j]){\\n                    f=1;break;\\n                }\\n            }\\n            if(f==0){\\n                vector<int>temp2(need);\\n                for(int j=0;j<spec[i].size()-1;j++){\\n                    temp2[j]=temp2[j]-spec[i][j];\\n                }\\n                int x=spec[i][spec[i].size()-1]+func(ind,p,temp2,spec);\\n                t2=min(t2,x);\\n            }\\n        }\\n        return mp[ind][need]= min(t1,t2);\\n    }\\n    int shoppingOffers(vector<int>& p, vector<vector<int>>& spec, vector<int>& need) {\\n        return func(0,p,need,spec);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,map<vector<int>,int>>mp;\\n    int func(int ind,vector<int>&p,vector<int>need,vector<vector<int>>&spec){\\n        if(ind>=p.size()) return 0;\\n        if(mp[ind][need]) return mp[ind][need];\\n        vector<int>temp1(need);\\n        temp1[ind]=0;\\n        int t1=p[ind]*need[ind]+func(ind+1,p,temp1,spec);\\n        int t2=INT_MAX;\\n        for(int i=0;i<spec.size();i++){\\n            int f=0;\\n            for(int j=0;j<spec[i].size()-1;j++){\\n                if(spec[i][j]>need[j]){\\n                    f=1;break;\\n                }\\n            }\\n            if(f==0){\\n                vector<int>temp2(need);\\n                for(int j=0;j<spec[i].size()-1;j++){\\n                    temp2[j]=temp2[j]-spec[i][j];\\n                }\\n                int x=spec[i][spec[i].size()-1]+func(ind,p,temp2,spec);\\n                t2=min(t2,x);\\n            }\\n        }\\n        return mp[ind][need]= min(t1,t2);\\n    }\\n    int shoppingOffers(vector<int>& p, vector<vector<int>>& spec, vector<int>& need) {\\n        return func(0,p,need,spec);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658550,
                "title": "recursive-solution-two-approaches-for-caching",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        vector<unordered_map<int, int>> cache(special.size());\\n        // vector<map<vector<int>, int>> cache(special.size());\\n        int res = calc(price, special, needs, cache, 0);\\n        return res;\\n    }\\n\\n    int calc(const vector<int>& price, const vector<vector<int>>& special, vector<int>& needs, vector<unordered_map<int, int>>& cache/*vector<map<vector<int>, int>>& cache*/, int st) {\\n        int key = 0;\\n        // for each of the 6 \\'need\\' values, 0<=need<=10; it can be stored in 4 bits\\n        for (int need: needs) {\\n            key = (key | need) << 4;\\n        }\\n        unordered_map<int, int>::iterator it = cache[st].find(key);\\n        // map<vector<int>, int>::iterator it = cache[st].find(needs);\\n        if (it != cache[st].end()) return it -> second;\\n\\n        // tot amt without taking any spl offers\\n        int no_offer = 0;\\n        for (int j = 0; j < needs.size(); j++) {\\n            no_offer += price[j] * needs[j];\\n        }\\n\\n        // \\'st\\' is for pruning/optimization; if we have reached offer #2 after processing offer #1 (multiple or one time), no need to process offer #1 again as order of processing doesn\\'t matter, i.e. we have processed offer #1 as many times as needed before processing offer #2 so no need to process again\\n        int res = no_offer;\\n        for (int i = st; i < special.size(); i++) {\\n            if (no_offer < special[i][price.size()]) continue;\\n\\n            vector<int> new_needs;\\n            bool neg = false;\\n            for (int j = 0; j < needs.size(); j++) {\\n                int rem = needs[j] - special[i][j];\\n                if (rem < 0) {\\n                    neg = true;\\n                    break;\\n                }\\n                new_needs.push_back(rem);\\n            }\\n\\n            int take_offer = neg ? INT_MAX : special[i][price.size()] + calc(price, special, new_needs, cache, i);\\n            res = min(res, take_offer);\\n        }\\n        return cache[st][key] = res;\\n        // return cache[st][needs] = res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        vector<unordered_map<int, int>> cache(special.size());\\n        // vector<map<vector<int>, int>> cache(special.size());\\n        int res = calc(price, special, needs, cache, 0);\\n        return res;\\n    }\\n\\n    int calc(const vector<int>& price, const vector<vector<int>>& special, vector<int>& needs, vector<unordered_map<int, int>>& cache/*vector<map<vector<int>, int>>& cache*/, int st) {\\n        int key = 0;\\n        // for each of the 6 \\'need\\' values, 0<=need<=10; it can be stored in 4 bits\\n        for (int need: needs) {\\n            key = (key | need) << 4;\\n        }\\n        unordered_map<int, int>::iterator it = cache[st].find(key);\\n        // map<vector<int>, int>::iterator it = cache[st].find(needs);\\n        if (it != cache[st].end()) return it -> second;\\n\\n        // tot amt without taking any spl offers\\n        int no_offer = 0;\\n        for (int j = 0; j < needs.size(); j++) {\\n            no_offer += price[j] * needs[j];\\n        }\\n\\n        // \\'st\\' is for pruning/optimization; if we have reached offer #2 after processing offer #1 (multiple or one time), no need to process offer #1 again as order of processing doesn\\'t matter, i.e. we have processed offer #1 as many times as needed before processing offer #2 so no need to process again\\n        int res = no_offer;\\n        for (int i = st; i < special.size(); i++) {\\n            if (no_offer < special[i][price.size()]) continue;\\n\\n            vector<int> new_needs;\\n            bool neg = false;\\n            for (int j = 0; j < needs.size(); j++) {\\n                int rem = needs[j] - special[i][j];\\n                if (rem < 0) {\\n                    neg = true;\\n                    break;\\n                }\\n                new_needs.push_back(rem);\\n            }\\n\\n            int take_offer = neg ? INT_MAX : special[i][price.size()] + calc(price, special, new_needs, cache, i);\\n            res = min(res, take_offer);\\n        }\\n        return cache[st][key] = res;\\n        // return cache[st][needs] = res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646397,
                "title": "ugly-cpp-code",
                "content": "# Intuition\\nAditya verma ka unbounded knapsack dekh lo apne aap samajh aayega\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBola na dekh ke aao\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nstruct data {\\n    int index;\\n    vector<int> data1;  // First and last names\\n \\n    data(int i, vector<int> d)\\n    {   \\n        index = i; \\n        data1 = d;\\n         \\n    }\\n \\n    // Match both first and last names in case\\n    // of collisions.\\n    bool operator==(const struct data& d) const\\n    {\\n        return index== d.index and data1==d.data1;\\n    }\\n};\\n\\nstruct hash_pair{\\n\\n    size_t operator()(const struct data& d) const\\n    {\\n        return d.index;\\n    }\\n\\n\\n};\\n\\nclass Solution {\\npublic:\\n\\n    unordered_map<struct data,int,hash_pair> dp;\\n    int solve(vector<vector<int>>& special,vector<int>& price,vector<int>  needs,int n,int x)\\n    {   \\n        vector<int> temp;\\n        for(int i=0;i<x;i++)\\n        {\\n            temp.push_back(needs[i]);\\n        }\\n\\n        struct data p1(n,temp);\\n      \\n\\n\\n\\n\\n        if(n==0)\\n        {\\n            int cost=0;\\n            for(int i=0;i<x;i++)\\n            {\\n                cost+=price[i]*needs[i];\\n            }\\n\\n\\n\\n            return dp[p1] = cost;\\n        }\\n\\n        if(dp.find(p1)!=dp.end())\\n        {\\n            return dp[p1];\\n        }\\n\\n        int flag=1;\\n        int cost=0;\\n        for(int i=0;i<x;i++)\\n        {\\n            if(special[n-1][i]>needs[i])\\n            {\\n                flag=0;\\n            }\\n        }\\n\\n        vector<int> needs1=needs;\\n\\n        if(flag==1)\\n        {\\n            for(int i=0;i<x;i++)\\n            {\\n                needs[i]=needs[i] - special[n-1][i];\\n            }\\n\\n            return dp[p1] = min(special[n-1][x]+solve(special,price,needs,n,x),solve(special,price,needs1,n-1,x));            \\n        }\\n        else\\n        {\\n            return dp[p1] = solve(special,price,needs1,n-1,x);  \\n        }\\n\\n\\n    }\\n\\n\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n        int n=special.size();\\n\\n        int x=price.size();\\n       // memset(dp,-1,sizeof(dp));\\n        return solve(special,price,needs,n,x);\\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nstruct data {\\n    int index;\\n    vector<int> data1;  // First and last names\\n \\n    data(int i, vector<int> d)\\n    {   \\n        index = i; \\n        data1 = d;\\n         \\n    }\\n \\n    // Match both first and last names in case\\n    // of collisions.\\n    bool operator==(const struct data& d) const\\n    {\\n        return index== d.index and data1==d.data1;\\n    }\\n};\\n\\nstruct hash_pair{\\n\\n    size_t operator()(const struct data& d) const\\n    {\\n        return d.index;\\n    }\\n\\n\\n};\\n\\nclass Solution {\\npublic:\\n\\n    unordered_map<struct data,int,hash_pair> dp;\\n    int solve(vector<vector<int>>& special,vector<int>& price,vector<int>  needs,int n,int x)\\n    {   \\n        vector<int> temp;\\n        for(int i=0;i<x;i++)\\n        {\\n            temp.push_back(needs[i]);\\n        }\\n\\n        struct data p1(n,temp);\\n      \\n\\n\\n\\n\\n        if(n==0)\\n        {\\n            int cost=0;\\n            for(int i=0;i<x;i++)\\n            {\\n                cost+=price[i]*needs[i];\\n            }\\n\\n\\n\\n            return dp[p1] = cost;\\n        }\\n\\n        if(dp.find(p1)!=dp.end())\\n        {\\n            return dp[p1];\\n        }\\n\\n        int flag=1;\\n        int cost=0;\\n        for(int i=0;i<x;i++)\\n        {\\n            if(special[n-1][i]>needs[i])\\n            {\\n                flag=0;\\n            }\\n        }\\n\\n        vector<int> needs1=needs;\\n\\n        if(flag==1)\\n        {\\n            for(int i=0;i<x;i++)\\n            {\\n                needs[i]=needs[i] - special[n-1][i];\\n            }\\n\\n            return dp[p1] = min(special[n-1][x]+solve(special,price,needs,n,x),solve(special,price,needs1,n-1,x));            \\n        }\\n        else\\n        {\\n            return dp[p1] = solve(special,price,needs1,n-1,x);  \\n        }\\n\\n\\n    }\\n\\n\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n        int n=special.size();\\n\\n        int x=price.size();\\n       // memset(dp,-1,sizeof(dp));\\n        return solve(special,price,needs,n,x);\\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638269,
                "title": "python-super-easy-dp-top-down",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n\\n        @functools.lru_cache(None)\\n        def total(need):\\n            t = 0\\n            for n, p in zip(need, price):\\n                t += n * p\\n            return t\\n        @functools.lru_cache(None)\\n        def dp(i, n):\\n            ans = total(n)\\n            for j in range(i, len(special)):\\n                t = list(n)\\n                for k in  range(len(t)):\\n                    if special[j][k] > t[k] :\\n                        break\\n                    else:\\n                        t[k] -= special[j][k]\\n                else:\\n                    ans  = min(ans, special[j][-1] + dp(j, tuple(t)))\\n            return ans\\n        \\n\\n        return dp(0, tuple(needs))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n\\n        @functools.lru_cache(None)\\n        def total(need):\\n            t = 0\\n            for n, p in zip(need, price):\\n                t += n * p\\n            return t\\n        @functools.lru_cache(None)\\n        def dp(i, n):\\n            ans = total(n)\\n            for j in range(i, len(special)):\\n                t = list(n)\\n                for k in  range(len(t)):\\n                    if special[j][k] > t[k] :\\n                        break\\n                    else:\\n                        t[k] -= special[j][k]\\n                else:\\n                    ans  = min(ans, special[j][-1] + dp(j, tuple(t)))\\n            return ans\\n        \\n\\n        return dp(0, tuple(needs))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624889,
                "title": "java-solution-beats-90-runtime-and-100-mem",
                "content": "# Intuition\\nRecurtion + memoization\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(MLN) , M- size of needs, N - size price, L - size of special\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Map<List<Integer>, Integer> map = new HashMap<>();\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int ans = base(price, needs);\\n        if(map.get(needs) != null) return map.get(needs);\\n        for(int i = 0; i < special.size(); i++){\\n            int j = 0;\\n            for(j = 0; j < needs.size(); j++){\\n                if(needs.get(j) - special.get(i).get(j) < 0)\\n                    break;\\n            }\\n            if(j != needs.size()) continue;\\n            List<Integer> clone = new ArrayList<>(needs.size());\\n            for(j = 0; j < needs.size(); j++) {\\n                clone.add(needs.get(j) - special.get(i).get(j));\\n            }\\n            ans = Math.min(ans, special.get(i).get(j) + \\n                    shoppingOffers(price, special, clone));\\n        }\\n        map.put(needs, ans);\\n        return ans; \\n    }\\n\\n    int base(List<Integer> price, List<Integer> needs){\\n        int ans = 0;\\n        for(int i = 0; i < price.size(); i++){\\n            ans += price.get(i) * needs.get(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<List<Integer>, Integer> map = new HashMap<>();\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int ans = base(price, needs);\\n        if(map.get(needs) != null) return map.get(needs);\\n        for(int i = 0; i < special.size(); i++){\\n            int j = 0;\\n            for(j = 0; j < needs.size(); j++){\\n                if(needs.get(j) - special.get(i).get(j) < 0)\\n                    break;\\n            }\\n            if(j != needs.size()) continue;\\n            List<Integer> clone = new ArrayList<>(needs.size());\\n            for(j = 0; j < needs.size(); j++) {\\n                clone.add(needs.get(j) - special.get(i).get(j));\\n            }\\n            ans = Math.min(ans, special.get(i).get(j) + \\n                    shoppingOffers(price, special, clone));\\n        }\\n        map.put(needs, ans);\\n        return ans; \\n    }\\n\\n    int base(List<Integer> price, List<Integer> needs){\\n        int ans = 0;\\n        for(int i = 0; i < price.size(); i++){\\n            ans += price.get(i) * needs.get(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617753,
                "title": "90-beats-memoization-easy-explanation-map-dp-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt every step we can either search through the special offers or sell all the items at given price. We find all the possibilities required and return minimim of it. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAny special offer which has more number of any specific item is rejected(if confition in for loop).The base case is when all the required items needed becomes zero. The DP used in memoization will be a map as the result depends upon the needs array.\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n\\n    int func(vector<int>&total,vector<vector<int>>&specials,vector<int>&price,vector<int>&needs,map<vector<int>,int>&dp)\\n    {\\n\\n        if(total==needs) return 0;\\n        if(dp[needs]) return dp[needs]; \\n\\n \\n        int op1=0;\\n        for(int i=0;i<needs.size();i++)\\n        {\\n            op1+=price[i]*needs[i];\\n        }\\n\\n        int op2=INT_MAX;\\n        for(auto it:specials)\\n        {\\n           bool flag=true;\\n           vector<int> temp_need=needs;\\n           for(int i=0;i<it.size()-1;i++)\\n           {\\n               if(needs[i]<it[i])\\n               {\\n                   flag=false;\\n                   break;\\n               }\\n               temp_need[i]-=it[i];\\n           }\\n           if(flag)\\n           {\\n               op2=min(func(total,specials,price,temp_need,dp)+it[it.size()-1],op2);\\n           }\\n        }\\n\\n        return dp[needs]=min(op2,op1);\\n    }\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n        map<vector<int>,int> dp;\\n        vector<int> total(needs.size(),0);\\n        return func(total,special,price,needs,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n\\n    int func(vector<int>&total,vector<vector<int>>&specials,vector<int>&price,vector<int>&needs,map<vector<int>,int>&dp)\\n    {\\n\\n        if(total==needs) return 0;\\n        if(dp[needs]) return dp[needs]; \\n\\n \\n        int op1=0;\\n        for(int i=0;i<needs.size();i++)\\n        {\\n            op1+=price[i]*needs[i];\\n        }\\n\\n        int op2=INT_MAX;\\n        for(auto it:specials)\\n        {\\n           bool flag=true;\\n           vector<int> temp_need=needs;\\n           for(int i=0;i<it.size()-1;i++)\\n           {\\n               if(needs[i]<it[i])\\n               {\\n                   flag=false;\\n                   break;\\n               }\\n               temp_need[i]-=it[i];\\n           }\\n           if(flag)\\n           {\\n               op2=min(func(total,specials,price,temp_need,dp)+it[it.size()-1],op2);\\n           }\\n        }\\n\\n        return dp[needs]=min(op2,op1);\\n    }\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        \\n        map<vector<int>,int> dp;\\n        vector<int> total(needs.size(),0);\\n        return func(total,special,price,needs,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588366,
                "title": "c-easy-fast-backtrack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<vector<int>>& special, vector<int>& needs,int idx)\\n    {\\n        for(int i=0;i<needs.size();i++)\\n        {\\n            if(needs[i]-special[idx][i]<0)\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n   \\n\\n    int solve(vector<int>& price, vector<vector<int>>& special, vector<int>& needs,int idx,int n)\\n    {\\n        if(idx==special.size())\\n        {\\n            int total=0;\\n            for(int i=0;i<needs.size();i++)\\n            {\\n                total=total+needs[i]*price[i];\\n            }\\n            return total;\\n        }\\n\\n        int notpick=1e9,pick=1e9;\\n\\n        notpick=solve(price,special,needs,idx+1,n);\\n\\n        if(isValid(special,needs,idx))\\n        {\\n            for(int i=0;i<needs.size();i++)\\n        {\\n            needs[i]=needs[i]-special[idx][i];\\n        }\\n            pick=special[idx][n]+solve(price,special,needs,idx,n);\\n\\n            for(int i=0;i<needs.size();i++)\\n        {\\n            needs[i]=needs[i]+special[idx][i];\\n        }\\n        }\\n\\n        return min(pick,notpick);\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int n=needs.size();\\n        return solve(price,special,needs,0,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<vector<int>>& special, vector<int>& needs,int idx)\\n    {\\n        for(int i=0;i<needs.size();i++)\\n        {\\n            if(needs[i]-special[idx][i]<0)\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n   \\n\\n    int solve(vector<int>& price, vector<vector<int>>& special, vector<int>& needs,int idx,int n)\\n    {\\n        if(idx==special.size())\\n        {\\n            int total=0;\\n            for(int i=0;i<needs.size();i++)\\n            {\\n                total=total+needs[i]*price[i];\\n            }\\n            return total;\\n        }\\n\\n        int notpick=1e9,pick=1e9;\\n\\n        notpick=solve(price,special,needs,idx+1,n);\\n\\n        if(isValid(special,needs,idx))\\n        {\\n            for(int i=0;i<needs.size();i++)\\n        {\\n            needs[i]=needs[i]-special[idx][i];\\n        }\\n            pick=special[idx][n]+solve(price,special,needs,idx,n);\\n\\n            for(int i=0;i<needs.size();i++)\\n        {\\n            needs[i]=needs[i]+special[idx][i];\\n        }\\n        }\\n\\n        return min(pick,notpick);\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        int n=needs.size();\\n        return solve(price,special,needs,0,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535299,
                "title": "optimized-backtracking-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOur shopping list is not very long, and so a backtracking approach makes sense in this case. However, our offers are potentially huge, so we want to limit going over those as soon as possible. Due to this, we can approach this by limiting ourselves to only the best valid unique specials, and then determining still valid sub uses under those. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSet up a best specials dictionary \\nLoop over our special options \\n- if tuple cast of s_i up to but not including cost in best specials \\n    - get current cost, set new cost of min as current and cost here \\n    - then update best specials here appropriately \\n- otherwise, set up entry \\n\\nUse keys and values in best special items to build special list again. This elminates duplicates on not only offers but duplicates also in the form of matching options but different costs.   \\n\\nSet up a valid specials list \\nLoop over each s_ith special \\n- set is valid to True \\n- enumerate needs \\n    - if s_ith[index] > need : is valid is false, break \\n- if is valid is true, append s_i to valid specials \\n\\nThis eliminates immediately invalid specials \\nSet up a shopping trip options as a dictionary of our shopping trip costs\\nSet up backtracking using a needs sublist where some purchases using some specials have already been made. Inside which \\n- if the needs sublist as a tuple is in our shopping trip options, return it\\n- otherwise, get length of the needs sublist and the sub cost using price\\n- then, loop over valid specials\\n    - checking for validity of each \\n    - if not valid, skip it \\n- otherwise, remaining is needs sublist at i - valid special at i for i in range length of needs sublist \\n- sub cost likewise is min of self and vs[-1] plus backtracking using remaining \\n\\nWhen done, memoize sub cost to shopping trip options using needs sublist \\nThen, return the sub cost \\n\\nTo kick off the process, start backtracking with a tuple cast of needs     \\n\\n# Complexity\\n- Time complexity : O(V_s^n)\\n    - The function has V_s valid specials \\n    - It may at worst call itself V_s times \\n    - This occurs over the n sized list of max size 6 \\n    - This is at worst 100^6... which is pretty big but not too bad \\n    - However, this is only true if all specials are unique and valid\\n    - Based on testing, uniquely valid specials are about a 10th the size\\n    - So we get closer to log(V_s)^n costs \\n\\n- Space complexity : O(V_s^n)\\n    - Due to backtracking process, we store at worst O(V_s^n) for the stack \\n\\n# Code\\n```\\nclass Solution:\\n    def shoppingOffers(self, price, special: List[List[int]], needs) :\\n        # cannot buy more to lower costs \\n            # cannot take an offer if we would end with more of needs\\n            # first need to look at needs and use to eliminate specials \\n            # can be done while backtracking to limit subspaces \\n\\n        best_specials = dict()\\n        for s_i in special : \\n            if tuple(s_i[:-1]) in best_specials : \\n                current = best_specials[tuple(s_i[:-1])][0]\\n                new_cost = min(current, s_i[-1])\\n                best_specials[tuple(s_i[:-1])] = [new_cost]\\n            else : \\n                best_specials[tuple(s_i[:-1])] = [s_i[-1]]\\n        \\n        special = [list(key)+value for key, value in best_specials.items()]\\n\\n        # eliminate initially invalid specials \\n        valid_specials = []\\n        # loop over special \\n        for s_i in special :\\n            # treat each as valid to start \\n            is_valid = True  \\n            # get index and need \\n            for index, need in enumerate(needs) :\\n                # if too much, skip it  \\n                if s_i[index] > need : \\n                    is_valid = False\\n                    break\\n            # otherwise, if all lte, append it \\n            if is_valid : \\n                valid_specials.append(s_i)\\n        # memo for use in backtracking \\n        shopping_trip_options = dict()\\n        # backtrack results \\n        def backtracking(needs_sublist) : \\n            # if we already got it, ship it \\n            if needs_sublist in shopping_trip_options : \\n                return shopping_trip_options[needs_sublist]\\n            # otherwise, get size and sub cost \\n            nsL = len(needs_sublist)\\n            sub_cost = sum(price[i] * needs_sublist[i] for i in range(nsL))\\n\\n            # update valid specials locally, do not change globally \\n            for vs in valid_specials : \\n                # validate \\n                is_valid = True\\n                # by checking if all lte appropriately  \\n                for index, need in enumerate(needs_sublist) : \\n                    if vs[index] > need : \\n                        is_valid = False \\n                        break\\n                # if not valid, continue \\n                if not is_valid : \\n                    continue \\n                # otherwise, calculate remaining and sub cost appropriately \\n                remaining = [needs_sublist[i] - vs[i] for i in range(nsL)]\\n                sub_cost = min(sub_cost, vs[-1] + backtracking(tuple(remaining)))\\n            # memoize and return \\n            shopping_trip_options[needs_sublist] = sub_cost\\n            return sub_cost\\n        # conduct backtracking \\n        return backtracking(tuple(needs))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shoppingOffers(self, price, special: List[List[int]], needs) :\\n        # cannot buy more to lower costs \\n            # cannot take an offer if we would end with more of needs\\n            # first need to look at needs and use to eliminate specials \\n            # can be done while backtracking to limit subspaces \\n\\n        best_specials = dict()\\n        for s_i in special : \\n            if tuple(s_i[:-1]) in best_specials : \\n                current = best_specials[tuple(s_i[:-1])][0]\\n                new_cost = min(current, s_i[-1])\\n                best_specials[tuple(s_i[:-1])] = [new_cost]\\n            else : \\n                best_specials[tuple(s_i[:-1])] = [s_i[-1]]\\n        \\n        special = [list(key)+value for key, value in best_specials.items()]\\n\\n        # eliminate initially invalid specials \\n        valid_specials = []\\n        # loop over special \\n        for s_i in special :\\n            # treat each as valid to start \\n            is_valid = True  \\n            # get index and need \\n            for index, need in enumerate(needs) :\\n                # if too much, skip it  \\n                if s_i[index] > need : \\n                    is_valid = False\\n                    break\\n            # otherwise, if all lte, append it \\n            if is_valid : \\n                valid_specials.append(s_i)\\n        # memo for use in backtracking \\n        shopping_trip_options = dict()\\n        # backtrack results \\n        def backtracking(needs_sublist) : \\n            # if we already got it, ship it \\n            if needs_sublist in shopping_trip_options : \\n                return shopping_trip_options[needs_sublist]\\n            # otherwise, get size and sub cost \\n            nsL = len(needs_sublist)\\n            sub_cost = sum(price[i] * needs_sublist[i] for i in range(nsL))\\n\\n            # update valid specials locally, do not change globally \\n            for vs in valid_specials : \\n                # validate \\n                is_valid = True\\n                # by checking if all lte appropriately  \\n                for index, need in enumerate(needs_sublist) : \\n                    if vs[index] > need : \\n                        is_valid = False \\n                        break\\n                # if not valid, continue \\n                if not is_valid : \\n                    continue \\n                # otherwise, calculate remaining and sub cost appropriately \\n                remaining = [needs_sublist[i] - vs[i] for i in range(nsL)]\\n                sub_cost = min(sub_cost, vs[-1] + backtracking(tuple(remaining)))\\n            # memoize and return \\n            shopping_trip_options[needs_sublist] = sub_cost\\n            return sub_cost\\n        # conduct backtracking \\n        return backtracking(tuple(needs))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502516,
                "title": "java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int totalNeed=0 ;\\n        for (Integer need:needs) totalNeed+=need;\\n        return shoppingOffers(price,special,needs,totalNeed,new HashMap());\\n    }\\n\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int totalNeed,HashMap<Integer,Integer> mamo) {\\n        if (totalNeed==0) return 0;\\n        int n=price.size() , best=Integer.MAX_VALUE , mamoKey = getMamoKey(needs);\\n        if (mamo.containsKey(mamoKey)) return mamo.get(mamoKey);\\n        for (int i=0;i<n;i++){\\n            if (needs.get(i)>0) {\\n                needs.set(i,needs.get(i)-1);\\n                best = Math.min(best, price.get(i)+shoppingOffers(price,special,needs,totalNeed-1,mamo));\\n                needs.set(i,needs.get(i)+1);\\n            }\\n        }\\n        for (List<Integer> s:special){\\n            if (offerPossible(s,needs)){\\n                for (int i=0;i<n;i++){\\n                    needs.set(i,needs.get(i)-s.get(i));\\n                    totalNeed-=s.get(i);\\n                }\\n                best = Math.min(best, s.get(n) + shoppingOffers(price,special,needs,totalNeed,mamo));\\n                for (int i=0;i<n;i++){\\n                    needs.set(i,needs.get(i)+s.get(i));\\n                    totalNeed+=s.get(i);\\n                }\\n            }\\n        }\\n        mamo.put(mamoKey,best);\\n        return mamo.get(mamoKey);\\n    }\\n\\n    public int getMamoKey( List<Integer> needs){\\n        int key=0, radix=1;\\n        for (int i=0;i<needs.size();i++) {\\n            key+=needs.get(i)*radix;\\n            radix*=11;\\n        }\\n        return key;\\n    }\\n    public boolean offerPossible(List<Integer> s, List<Integer> needs){\\n        for (int i=0;i<needs.size();i++) if (s.get(i)>needs.get(i)) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int totalNeed=0 ;\\n        for (Integer need:needs) totalNeed+=need;\\n        return shoppingOffers(price,special,needs,totalNeed,new HashMap());\\n    }\\n\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int totalNeed,HashMap<Integer,Integer> mamo) {\\n        if (totalNeed==0) return 0;\\n        int n=price.size() , best=Integer.MAX_VALUE , mamoKey = getMamoKey(needs);\\n        if (mamo.containsKey(mamoKey)) return mamo.get(mamoKey);\\n        for (int i=0;i<n;i++){\\n            if (needs.get(i)>0) {\\n                needs.set(i,needs.get(i)-1);\\n                best = Math.min(best, price.get(i)+shoppingOffers(price,special,needs,totalNeed-1,mamo));\\n                needs.set(i,needs.get(i)+1);\\n            }\\n        }\\n        for (List<Integer> s:special){\\n            if (offerPossible(s,needs)){\\n                for (int i=0;i<n;i++){\\n                    needs.set(i,needs.get(i)-s.get(i));\\n                    totalNeed-=s.get(i);\\n                }\\n                best = Math.min(best, s.get(n) + shoppingOffers(price,special,needs,totalNeed,mamo));\\n                for (int i=0;i<n;i++){\\n                    needs.set(i,needs.get(i)+s.get(i));\\n                    totalNeed+=s.get(i);\\n                }\\n            }\\n        }\\n        mamo.put(mamoKey,best);\\n        return mamo.get(mamoKey);\\n    }\\n\\n    public int getMamoKey( List<Integer> needs){\\n        int key=0, radix=1;\\n        for (int i=0;i<needs.size();i++) {\\n            key+=needs.get(i)*radix;\\n            radix*=11;\\n        }\\n        return key;\\n    }\\n    public boolean offerPossible(List<Integer> s, List<Integer> needs){\\n        for (int i=0;i<needs.size();i++) if (s.get(i)>needs.get(i)) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473798,
                "title": "js-short-solution",
                "content": "```\\n/**\\n * @param {number[]} price\\n * @param {number[][]} special\\n * @param {number[]} needs\\n * @return {number}\\n */\\nvar shoppingOffers = function (price, special, needs) {\\n\\n  const betterSpecials = special.filter((s) =>\\n    !special.some(s2 => s.at(-1) > s2.at(-1) && s.slice(0, -1).every((y,j) => y === s2[j]))\\n  )\\n\\n  const check = (price, special, needs) => {\\n    let offer = needs.reduce((sum, n, i) => sum + n * price[i], 0)\\n    for (const s of special) {\\n      if (s.some((x, i) => x > needs[i])) continue\\n      offer = Math.min(offer, s.at(-1) + check(price, special, needs.map((n, i) => n - s[i])))\\n    }\\n    return offer\\n  }\\n\\n  return check(price, betterSpecials, needs)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} price\\n * @param {number[][]} special\\n * @param {number[]} needs\\n * @return {number}\\n */\\nvar shoppingOffers = function (price, special, needs) {\\n\\n  const betterSpecials = special.filter((s) =>\\n    !special.some(s2 => s.at(-1) > s2.at(-1) && s.slice(0, -1).every((y,j) => y === s2[j]))\\n  )\\n\\n  const check = (price, special, needs) => {\\n    let offer = needs.reduce((sum, n, i) => sum + n * price[i], 0)\\n    for (const s of special) {\\n      if (s.some((x, i) => x > needs[i])) continue\\n      offer = Math.min(offer, s.at(-1) + check(price, special, needs.map((n, i) => n - s[i])))\\n    }\\n    return offer\\n  }\\n\\n  return check(price, betterSpecials, needs)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3430654,
                "title": "unbounded-knapsack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApproach at each step is to either take \\nno offer\\noffer1 or offer2 or offer 3\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO()\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>&price,vector<vector<int> > & special,vector<int>needs,map<vector<int>, int >&dp)\\n    {\\n        if(dp.find(needs)!=dp.end())\\n        {\\n            return dp[needs];\\n        }\\n        else\\n        {\\n            //go on exploring all offers from current\\n            int mini=INT_MAX;\\n            for(auto x:special)\\n            {\\n                vector<int>newneed;\\n                bool can=true;\\n                for(int i=0;i<needs.size();i++) // calculate that the current offer can be applied or not\\n                {\\n                    if(needs[i]>=x[i])\\n                    {\\n                       newneed.push_back(needs[i]-x[i]);\\n                    }\\n                    else\\n                    {\\n                       can=false;\\n                       break;\\n                    }\\n                }\\n            \\n            if(can) // if this offers could be applied....\\n            {\\n               int current=x[needs.size()]+f(price,special,newneed,dp);\\n               mini=min(mini,current);\\n            }\\n            else // if this offer cant be applied.....\\n            {\\n                int current=0; // find the raw cost of remaining items\\n               for(int i=0;i<needs.size();i++) \\n               {\\n                  current+=needs[i]*price[i];\\n               }\\n               mini=min(mini,current);\\n            }\\n\\n            }\\n            // for the case when no offers are taken by choice....\\n            int current=0;\\n            for(int i=0;i<needs.size();i++)\\n            {\\n               current+=price[i]*needs[i];\\n            }\\n            mini=min(current,mini);\\n            return dp[needs]=mini;\\n        }\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n    map<vector<int>, int > dp;\\n        int ans=f(price,special,needs,dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<int>&price,vector<vector<int> > & special,vector<int>needs,map<vector<int>, int >&dp)\\n    {\\n        if(dp.find(needs)!=dp.end())\\n        {\\n            return dp[needs];\\n        }\\n        else\\n        {\\n            //go on exploring all offers from current\\n            int mini=INT_MAX;\\n            for(auto x:special)\\n            {\\n                vector<int>newneed;\\n                bool can=true;\\n                for(int i=0;i<needs.size();i++) // calculate that the current offer can be applied or not\\n                {\\n                    if(needs[i]>=x[i])\\n                    {\\n                       newneed.push_back(needs[i]-x[i]);\\n                    }\\n                    else\\n                    {\\n                       can=false;\\n                       break;\\n                    }\\n                }\\n            \\n            if(can) // if this offers could be applied....\\n            {\\n               int current=x[needs.size()]+f(price,special,newneed,dp);\\n               mini=min(mini,current);\\n            }\\n            else // if this offer cant be applied.....\\n            {\\n                int current=0; // find the raw cost of remaining items\\n               for(int i=0;i<needs.size();i++) \\n               {\\n                  current+=needs[i]*price[i];\\n               }\\n               mini=min(mini,current);\\n            }\\n\\n            }\\n            // for the case when no offers are taken by choice....\\n            int current=0;\\n            for(int i=0;i<needs.size();i++)\\n            {\\n               current+=price[i]*needs[i];\\n            }\\n            mini=min(current,mini);\\n            return dp[needs]=mini;\\n        }\\n    }\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n    map<vector<int>, int > dp;\\n        int ans=f(price,special,needs,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390332,
                "title": "python-time-limit-exceeded",
                "content": "```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        \\n        n = len(price)\\n        \\n        for i,p in enumerate(price):\\n            temp = [0]*(n+1)\\n            temp[i] = 1\\n            temp[-1] = p\\n            special.append(temp)\\n            \\n        \\n        @cache\\n        def backtrack(needs):\\n            if not any(needs):\\n                return 0\\n            \\n            ans = inf\\n            for offer in special:\\n                if not any(item > need for item,need in zip(offer, needs)):\\n                    ans = min(ans, backtrack(tuple(need-item for item,need in zip(offer, needs))) + offer[-1])\\n            return ans\\n        \\n        return backtrack(tuple(needs))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\\n        \\n        n = len(price)\\n        \\n        for i,p in enumerate(price):\\n            temp = [0]*(n+1)\\n            temp[i] = 1\\n            temp[-1] = p\\n            special.append(temp)\\n            \\n        \\n        @cache\\n        def backtrack(needs):\\n            if not any(needs):\\n                return 0\\n            \\n            ans = inf\\n            for offer in special:\\n                if not any(item > need for item,need in zip(offer, needs)):\\n                    ans = min(ans, backtrack(tuple(need-item for item,need in zip(offer, needs))) + offer[-1])\\n            return ans\\n        \\n        return backtrack(tuple(needs))\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1572885,
                "content": [
                    {
                        "username": "sin1080",
                        "content": "The constraints of this problem is too strong that if you construct a worst case test set everyone will TLE. Let me show you why.\\n\\nIt is stated that you can have at most 6 types of items and you need to buy at most 6 for each one of them. Which mean that there are 7^6=117649 states. It is further stated that there will be at most 100 \"special offers\". That results in 11764900 transitions. Each transition needs 6 multiplications to calculate the index, or comparable work for a hashmap / treemap find. Which basically means a TLE-for-all for the worst case.\\n\\nThe reason that there are lots of 4ms solutions is that the largest test cases are too weak, in a specific way. The special offers in these test cases are too large, containing too many items, so that if you use a DFS or DFS-memo based DP you will only visit a small portion of the 117649 states and you will be fine. In fact, you don\\'t even need DP, because the test sets are really TOO weak. However, if you use an array based DP approach you will get a TLE. A TLE also if you want a uniform and elegent solution and constructs \"offers\" that contains 1 items per type. Of course, if proper strong test cases are provided, all of us will TLE also.\\n\\nThis really doesn\\'t feel right to me, because it is in fact selecting specific implementation technics based on the special traits of the present test sets (prefers DFS to proper DP!), instead of selecting the best algorithms that generally work best.\\n\\nThe constraint of the problem should be lowered to somewhat 5 items and at most 5 each type, and strong test sets should be provided. Such test sets can be constructed by providing all kinds of small special offers, containing 2 or even only 1 items. Or, update the constraint to explicitly state that each special offer will contain at least say 3 or 5 items, so you know that a DFS-based approach will triumph and you should avoid creating 1-item pseudo-offers."
                    },
                    {
                        "username": "Nakanu",
                        "content": "I have looked around my fellow's posts. There are mainly 3 solutions.\\n1. Just use DFS, recursive call the function. \\n2. Try to use some memorization like map. \\n3. DP. I just see one solution using a 6D matrix to implement DP. Well, brilliant!. \\n\\nAll of them works for this small scenario, what if the problem is bigger? Which one do you think is the best? Or some other methods? Why?"
                    },
                    {
                        "username": "WeatherSetting",
                        "content": "I think I have a quite reasonable 80-line answer to this question in Scala, but it was rejected because the compile time limit is exceeded... Either this limit should be raised, or Scala should not be accepted as a language option. It's otherwise a waste of time."
                    },
                    {
                        "username": "recker2903",
                        "content": "why is this question marked bitmasking DP ?"
                    },
                    {
                        "username": "dribvurhd",
                        "content": "My initial solution `timed out`, because I combined `price` and `specials` into the `specials` array with a price for a single object being a special with just 1 item. This caused one of the test cases to take `~1300ms` to run. However, if I use the technique in the sample solution to greedily take all the single items once as the first candidate to the solution for a specific set of `needs`, then the same test case runs in `~9ms`. This indicates that the input (`specials`) doesn't contain test data that would break the recursive+memoized solutions. I think that with the given input constraints, there are input for which most (if not all) solutions will time out, irrespective of whether or not they use memoization."
                    },
                    {
                        "username": "nitissssh",
                        "content": "Either I am dumb or I think this should be a hard one !\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Backtracking + Memoization(Because there is overlapping sub-problem)\n\n```\nclass Solution {\npublic:\n    int memo[15][15][15][15][15][15] = {0};\n\n    int shoppingOffers(vector<int> &price, vector<vector<int>> &special, vector<int> &needs) {\n        int n = price.size();\n        vector<vector<int>> specials;\n\n        for (int i = 0; i < special.size(); i++) {\n            int sum = 0;\n            for (int j = 0; j < n; j++) sum += special[i][j] * price[j];\n            if (sum > special[i].back()) specials.push_back(special[i]);\n        }\n\n        vector<int> needs2(6, 0);\n        for (int i = 0; i < n; i++) needs2[i] = needs[i];\n\n        // do dfs + memoization\n        return dfs(price, specials, needs2);\n    }\n\n    int dfs(vector<int> &price, vector<vector<int>> &specials, vector<int> &needs) {\n        int n = price.size();\n\n        if (memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]] != 0) return memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\n\n        int &x = memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\n        int res = 0;\n\n        for (int z = 0; z < n; z++) res += price[z] * needs[z];\n\n        for (const auto combo: specials) {\n            int choose = 1;\n            for (int k = 0; k < n; k++) {\n                if (combo[k] > needs[k]) {\n                    choose = 0;\n                    break;\n                }\n            }\n\n            if (choose) {\n                for (int p = 0; p < n; p++) {\n                    needs[p] -= combo[p];\n                }\n\n                res = min(res, dfs(price, specials, needs) + combo.back());\n                for (int q = 0; q < n; q++) {\n                    needs[q] += combo[q];\n                }\n            }\n        }\n\n        return x = res;\n    }\n};\n```\n\nIf that is too scary to you. We can use map to store status:\n\n```\nclass Solution {\npublic:\n    map<vector<int>, int> memo;\n\n    int shoppingOffers(vector<int> &price, vector<vector<int>> &special, vector<int> &needs) {\n        int n = price.size();\n        vector<vector<int>> specials;\n\n        for (int i = 0; i < special.size(); i++) {\n            int sum = 0;\n            for (int j = 0; j < n; j++) sum += special[i][j] * price[j];\n\n            if (sum > special[i].back()) specials.push_back(special[i]);\n        }\n\n        // vector<int> needs2(6, 0);\n        // for (int i = 0; i < n; i++) needs2[i] = needs[i];\n\n        // do dfs + memoization\n        return dfs(price, specials, needs);\n    }\n\n    int dfs(vector<int> &price, vector<vector<int>> &specials, vector<int> &needs) {\n        int n = price.size();\n\n        if (memo[needs]) return memo[needs];\n\n        int &x = memo[needs];\n        int res = 0;\n\n        for (int z = 0; z < n; z++) res += price[z] * needs[z];\n\n        for (const auto combo: specials) {\n            int choose = 1;\n            for (int k = 0; k < n; k++) {\n                if (combo[k] > needs[k]) {\n                    choose = 0;\n                    break;\n                }\n            }\n\n            if (choose) {\n                for (int p = 0; p < n; p++) {\n                    needs[p] -= combo[p];\n                }\n\n                res = min(res, dfs(price, specials, needs) + combo.back());\n                for (int q = 0; q < n; q++) {\n                    needs[q] += combo[q];\n                }\n            }\n        }\n\n        return x = res;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 1571791,
                "content": [
                    {
                        "username": "sin1080",
                        "content": "The constraints of this problem is too strong that if you construct a worst case test set everyone will TLE. Let me show you why.\\n\\nIt is stated that you can have at most 6 types of items and you need to buy at most 6 for each one of them. Which mean that there are 7^6=117649 states. It is further stated that there will be at most 100 \"special offers\". That results in 11764900 transitions. Each transition needs 6 multiplications to calculate the index, or comparable work for a hashmap / treemap find. Which basically means a TLE-for-all for the worst case.\\n\\nThe reason that there are lots of 4ms solutions is that the largest test cases are too weak, in a specific way. The special offers in these test cases are too large, containing too many items, so that if you use a DFS or DFS-memo based DP you will only visit a small portion of the 117649 states and you will be fine. In fact, you don\\'t even need DP, because the test sets are really TOO weak. However, if you use an array based DP approach you will get a TLE. A TLE also if you want a uniform and elegent solution and constructs \"offers\" that contains 1 items per type. Of course, if proper strong test cases are provided, all of us will TLE also.\\n\\nThis really doesn\\'t feel right to me, because it is in fact selecting specific implementation technics based on the special traits of the present test sets (prefers DFS to proper DP!), instead of selecting the best algorithms that generally work best.\\n\\nThe constraint of the problem should be lowered to somewhat 5 items and at most 5 each type, and strong test sets should be provided. Such test sets can be constructed by providing all kinds of small special offers, containing 2 or even only 1 items. Or, update the constraint to explicitly state that each special offer will contain at least say 3 or 5 items, so you know that a DFS-based approach will triumph and you should avoid creating 1-item pseudo-offers."
                    },
                    {
                        "username": "Nakanu",
                        "content": "I have looked around my fellow's posts. There are mainly 3 solutions.\\n1. Just use DFS, recursive call the function. \\n2. Try to use some memorization like map. \\n3. DP. I just see one solution using a 6D matrix to implement DP. Well, brilliant!. \\n\\nAll of them works for this small scenario, what if the problem is bigger? Which one do you think is the best? Or some other methods? Why?"
                    },
                    {
                        "username": "WeatherSetting",
                        "content": "I think I have a quite reasonable 80-line answer to this question in Scala, but it was rejected because the compile time limit is exceeded... Either this limit should be raised, or Scala should not be accepted as a language option. It's otherwise a waste of time."
                    },
                    {
                        "username": "recker2903",
                        "content": "why is this question marked bitmasking DP ?"
                    },
                    {
                        "username": "dribvurhd",
                        "content": "My initial solution `timed out`, because I combined `price` and `specials` into the `specials` array with a price for a single object being a special with just 1 item. This caused one of the test cases to take `~1300ms` to run. However, if I use the technique in the sample solution to greedily take all the single items once as the first candidate to the solution for a specific set of `needs`, then the same test case runs in `~9ms`. This indicates that the input (`specials`) doesn't contain test data that would break the recursive+memoized solutions. I think that with the given input constraints, there are input for which most (if not all) solutions will time out, irrespective of whether or not they use memoization."
                    },
                    {
                        "username": "nitissssh",
                        "content": "Either I am dumb or I think this should be a hard one !\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Backtracking + Memoization(Because there is overlapping sub-problem)\n\n```\nclass Solution {\npublic:\n    int memo[15][15][15][15][15][15] = {0};\n\n    int shoppingOffers(vector<int> &price, vector<vector<int>> &special, vector<int> &needs) {\n        int n = price.size();\n        vector<vector<int>> specials;\n\n        for (int i = 0; i < special.size(); i++) {\n            int sum = 0;\n            for (int j = 0; j < n; j++) sum += special[i][j] * price[j];\n            if (sum > special[i].back()) specials.push_back(special[i]);\n        }\n\n        vector<int> needs2(6, 0);\n        for (int i = 0; i < n; i++) needs2[i] = needs[i];\n\n        // do dfs + memoization\n        return dfs(price, specials, needs2);\n    }\n\n    int dfs(vector<int> &price, vector<vector<int>> &specials, vector<int> &needs) {\n        int n = price.size();\n\n        if (memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]] != 0) return memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\n\n        int &x = memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\n        int res = 0;\n\n        for (int z = 0; z < n; z++) res += price[z] * needs[z];\n\n        for (const auto combo: specials) {\n            int choose = 1;\n            for (int k = 0; k < n; k++) {\n                if (combo[k] > needs[k]) {\n                    choose = 0;\n                    break;\n                }\n            }\n\n            if (choose) {\n                for (int p = 0; p < n; p++) {\n                    needs[p] -= combo[p];\n                }\n\n                res = min(res, dfs(price, specials, needs) + combo.back());\n                for (int q = 0; q < n; q++) {\n                    needs[q] += combo[q];\n                }\n            }\n        }\n\n        return x = res;\n    }\n};\n```\n\nIf that is too scary to you. We can use map to store status:\n\n```\nclass Solution {\npublic:\n    map<vector<int>, int> memo;\n\n    int shoppingOffers(vector<int> &price, vector<vector<int>> &special, vector<int> &needs) {\n        int n = price.size();\n        vector<vector<int>> specials;\n\n        for (int i = 0; i < special.size(); i++) {\n            int sum = 0;\n            for (int j = 0; j < n; j++) sum += special[i][j] * price[j];\n\n            if (sum > special[i].back()) specials.push_back(special[i]);\n        }\n\n        // vector<int> needs2(6, 0);\n        // for (int i = 0; i < n; i++) needs2[i] = needs[i];\n\n        // do dfs + memoization\n        return dfs(price, specials, needs);\n    }\n\n    int dfs(vector<int> &price, vector<vector<int>> &specials, vector<int> &needs) {\n        int n = price.size();\n\n        if (memo[needs]) return memo[needs];\n\n        int &x = memo[needs];\n        int res = 0;\n\n        for (int z = 0; z < n; z++) res += price[z] * needs[z];\n\n        for (const auto combo: specials) {\n            int choose = 1;\n            for (int k = 0; k < n; k++) {\n                if (combo[k] > needs[k]) {\n                    choose = 0;\n                    break;\n                }\n            }\n\n            if (choose) {\n                for (int p = 0; p < n; p++) {\n                    needs[p] -= combo[p];\n                }\n\n                res = min(res, dfs(price, specials, needs) + combo.back());\n                for (int q = 0; q < n; q++) {\n                    needs[q] += combo[q];\n                }\n            }\n        }\n\n        return x = res;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 1567991,
                "content": [
                    {
                        "username": "sin1080",
                        "content": "The constraints of this problem is too strong that if you construct a worst case test set everyone will TLE. Let me show you why.\\n\\nIt is stated that you can have at most 6 types of items and you need to buy at most 6 for each one of them. Which mean that there are 7^6=117649 states. It is further stated that there will be at most 100 \"special offers\". That results in 11764900 transitions. Each transition needs 6 multiplications to calculate the index, or comparable work for a hashmap / treemap find. Which basically means a TLE-for-all for the worst case.\\n\\nThe reason that there are lots of 4ms solutions is that the largest test cases are too weak, in a specific way. The special offers in these test cases are too large, containing too many items, so that if you use a DFS or DFS-memo based DP you will only visit a small portion of the 117649 states and you will be fine. In fact, you don\\'t even need DP, because the test sets are really TOO weak. However, if you use an array based DP approach you will get a TLE. A TLE also if you want a uniform and elegent solution and constructs \"offers\" that contains 1 items per type. Of course, if proper strong test cases are provided, all of us will TLE also.\\n\\nThis really doesn\\'t feel right to me, because it is in fact selecting specific implementation technics based on the special traits of the present test sets (prefers DFS to proper DP!), instead of selecting the best algorithms that generally work best.\\n\\nThe constraint of the problem should be lowered to somewhat 5 items and at most 5 each type, and strong test sets should be provided. Such test sets can be constructed by providing all kinds of small special offers, containing 2 or even only 1 items. Or, update the constraint to explicitly state that each special offer will contain at least say 3 or 5 items, so you know that a DFS-based approach will triumph and you should avoid creating 1-item pseudo-offers."
                    },
                    {
                        "username": "Nakanu",
                        "content": "I have looked around my fellow's posts. There are mainly 3 solutions.\\n1. Just use DFS, recursive call the function. \\n2. Try to use some memorization like map. \\n3. DP. I just see one solution using a 6D matrix to implement DP. Well, brilliant!. \\n\\nAll of them works for this small scenario, what if the problem is bigger? Which one do you think is the best? Or some other methods? Why?"
                    },
                    {
                        "username": "WeatherSetting",
                        "content": "I think I have a quite reasonable 80-line answer to this question in Scala, but it was rejected because the compile time limit is exceeded... Either this limit should be raised, or Scala should not be accepted as a language option. It's otherwise a waste of time."
                    },
                    {
                        "username": "recker2903",
                        "content": "why is this question marked bitmasking DP ?"
                    },
                    {
                        "username": "dribvurhd",
                        "content": "My initial solution `timed out`, because I combined `price` and `specials` into the `specials` array with a price for a single object being a special with just 1 item. This caused one of the test cases to take `~1300ms` to run. However, if I use the technique in the sample solution to greedily take all the single items once as the first candidate to the solution for a specific set of `needs`, then the same test case runs in `~9ms`. This indicates that the input (`specials`) doesn't contain test data that would break the recursive+memoized solutions. I think that with the given input constraints, there are input for which most (if not all) solutions will time out, irrespective of whether or not they use memoization."
                    },
                    {
                        "username": "nitissssh",
                        "content": "Either I am dumb or I think this should be a hard one !\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Backtracking + Memoization(Because there is overlapping sub-problem)\n\n```\nclass Solution {\npublic:\n    int memo[15][15][15][15][15][15] = {0};\n\n    int shoppingOffers(vector<int> &price, vector<vector<int>> &special, vector<int> &needs) {\n        int n = price.size();\n        vector<vector<int>> specials;\n\n        for (int i = 0; i < special.size(); i++) {\n            int sum = 0;\n            for (int j = 0; j < n; j++) sum += special[i][j] * price[j];\n            if (sum > special[i].back()) specials.push_back(special[i]);\n        }\n\n        vector<int> needs2(6, 0);\n        for (int i = 0; i < n; i++) needs2[i] = needs[i];\n\n        // do dfs + memoization\n        return dfs(price, specials, needs2);\n    }\n\n    int dfs(vector<int> &price, vector<vector<int>> &specials, vector<int> &needs) {\n        int n = price.size();\n\n        if (memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]] != 0) return memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\n\n        int &x = memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\n        int res = 0;\n\n        for (int z = 0; z < n; z++) res += price[z] * needs[z];\n\n        for (const auto combo: specials) {\n            int choose = 1;\n            for (int k = 0; k < n; k++) {\n                if (combo[k] > needs[k]) {\n                    choose = 0;\n                    break;\n                }\n            }\n\n            if (choose) {\n                for (int p = 0; p < n; p++) {\n                    needs[p] -= combo[p];\n                }\n\n                res = min(res, dfs(price, specials, needs) + combo.back());\n                for (int q = 0; q < n; q++) {\n                    needs[q] += combo[q];\n                }\n            }\n        }\n\n        return x = res;\n    }\n};\n```\n\nIf that is too scary to you. We can use map to store status:\n\n```\nclass Solution {\npublic:\n    map<vector<int>, int> memo;\n\n    int shoppingOffers(vector<int> &price, vector<vector<int>> &special, vector<int> &needs) {\n        int n = price.size();\n        vector<vector<int>> specials;\n\n        for (int i = 0; i < special.size(); i++) {\n            int sum = 0;\n            for (int j = 0; j < n; j++) sum += special[i][j] * price[j];\n\n            if (sum > special[i].back()) specials.push_back(special[i]);\n        }\n\n        // vector<int> needs2(6, 0);\n        // for (int i = 0; i < n; i++) needs2[i] = needs[i];\n\n        // do dfs + memoization\n        return dfs(price, specials, needs);\n    }\n\n    int dfs(vector<int> &price, vector<vector<int>> &specials, vector<int> &needs) {\n        int n = price.size();\n\n        if (memo[needs]) return memo[needs];\n\n        int &x = memo[needs];\n        int res = 0;\n\n        for (int z = 0; z < n; z++) res += price[z] * needs[z];\n\n        for (const auto combo: specials) {\n            int choose = 1;\n            for (int k = 0; k < n; k++) {\n                if (combo[k] > needs[k]) {\n                    choose = 0;\n                    break;\n                }\n            }\n\n            if (choose) {\n                for (int p = 0; p < n; p++) {\n                    needs[p] -= combo[p];\n                }\n\n                res = min(res, dfs(price, specials, needs) + combo.back());\n                for (int q = 0; q < n; q++) {\n                    needs[q] += combo[q];\n                }\n            }\n        }\n\n        return x = res;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 1730644,
                "content": [
                    {
                        "username": "sin1080",
                        "content": "The constraints of this problem is too strong that if you construct a worst case test set everyone will TLE. Let me show you why.\\n\\nIt is stated that you can have at most 6 types of items and you need to buy at most 6 for each one of them. Which mean that there are 7^6=117649 states. It is further stated that there will be at most 100 \"special offers\". That results in 11764900 transitions. Each transition needs 6 multiplications to calculate the index, or comparable work for a hashmap / treemap find. Which basically means a TLE-for-all for the worst case.\\n\\nThe reason that there are lots of 4ms solutions is that the largest test cases are too weak, in a specific way. The special offers in these test cases are too large, containing too many items, so that if you use a DFS or DFS-memo based DP you will only visit a small portion of the 117649 states and you will be fine. In fact, you don\\'t even need DP, because the test sets are really TOO weak. However, if you use an array based DP approach you will get a TLE. A TLE also if you want a uniform and elegent solution and constructs \"offers\" that contains 1 items per type. Of course, if proper strong test cases are provided, all of us will TLE also.\\n\\nThis really doesn\\'t feel right to me, because it is in fact selecting specific implementation technics based on the special traits of the present test sets (prefers DFS to proper DP!), instead of selecting the best algorithms that generally work best.\\n\\nThe constraint of the problem should be lowered to somewhat 5 items and at most 5 each type, and strong test sets should be provided. Such test sets can be constructed by providing all kinds of small special offers, containing 2 or even only 1 items. Or, update the constraint to explicitly state that each special offer will contain at least say 3 or 5 items, so you know that a DFS-based approach will triumph and you should avoid creating 1-item pseudo-offers."
                    },
                    {
                        "username": "Nakanu",
                        "content": "I have looked around my fellow's posts. There are mainly 3 solutions.\\n1. Just use DFS, recursive call the function. \\n2. Try to use some memorization like map. \\n3. DP. I just see one solution using a 6D matrix to implement DP. Well, brilliant!. \\n\\nAll of them works for this small scenario, what if the problem is bigger? Which one do you think is the best? Or some other methods? Why?"
                    },
                    {
                        "username": "WeatherSetting",
                        "content": "I think I have a quite reasonable 80-line answer to this question in Scala, but it was rejected because the compile time limit is exceeded... Either this limit should be raised, or Scala should not be accepted as a language option. It's otherwise a waste of time."
                    },
                    {
                        "username": "recker2903",
                        "content": "why is this question marked bitmasking DP ?"
                    },
                    {
                        "username": "dribvurhd",
                        "content": "My initial solution `timed out`, because I combined `price` and `specials` into the `specials` array with a price for a single object being a special with just 1 item. This caused one of the test cases to take `~1300ms` to run. However, if I use the technique in the sample solution to greedily take all the single items once as the first candidate to the solution for a specific set of `needs`, then the same test case runs in `~9ms`. This indicates that the input (`specials`) doesn't contain test data that would break the recursive+memoized solutions. I think that with the given input constraints, there are input for which most (if not all) solutions will time out, irrespective of whether or not they use memoization."
                    },
                    {
                        "username": "nitissssh",
                        "content": "Either I am dumb or I think this should be a hard one !\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Backtracking + Memoization(Because there is overlapping sub-problem)\n\n```\nclass Solution {\npublic:\n    int memo[15][15][15][15][15][15] = {0};\n\n    int shoppingOffers(vector<int> &price, vector<vector<int>> &special, vector<int> &needs) {\n        int n = price.size();\n        vector<vector<int>> specials;\n\n        for (int i = 0; i < special.size(); i++) {\n            int sum = 0;\n            for (int j = 0; j < n; j++) sum += special[i][j] * price[j];\n            if (sum > special[i].back()) specials.push_back(special[i]);\n        }\n\n        vector<int> needs2(6, 0);\n        for (int i = 0; i < n; i++) needs2[i] = needs[i];\n\n        // do dfs + memoization\n        return dfs(price, specials, needs2);\n    }\n\n    int dfs(vector<int> &price, vector<vector<int>> &specials, vector<int> &needs) {\n        int n = price.size();\n\n        if (memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]] != 0) return memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\n\n        int &x = memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\n        int res = 0;\n\n        for (int z = 0; z < n; z++) res += price[z] * needs[z];\n\n        for (const auto combo: specials) {\n            int choose = 1;\n            for (int k = 0; k < n; k++) {\n                if (combo[k] > needs[k]) {\n                    choose = 0;\n                    break;\n                }\n            }\n\n            if (choose) {\n                for (int p = 0; p < n; p++) {\n                    needs[p] -= combo[p];\n                }\n\n                res = min(res, dfs(price, specials, needs) + combo.back());\n                for (int q = 0; q < n; q++) {\n                    needs[q] += combo[q];\n                }\n            }\n        }\n\n        return x = res;\n    }\n};\n```\n\nIf that is too scary to you. We can use map to store status:\n\n```\nclass Solution {\npublic:\n    map<vector<int>, int> memo;\n\n    int shoppingOffers(vector<int> &price, vector<vector<int>> &special, vector<int> &needs) {\n        int n = price.size();\n        vector<vector<int>> specials;\n\n        for (int i = 0; i < special.size(); i++) {\n            int sum = 0;\n            for (int j = 0; j < n; j++) sum += special[i][j] * price[j];\n\n            if (sum > special[i].back()) specials.push_back(special[i]);\n        }\n\n        // vector<int> needs2(6, 0);\n        // for (int i = 0; i < n; i++) needs2[i] = needs[i];\n\n        // do dfs + memoization\n        return dfs(price, specials, needs);\n    }\n\n    int dfs(vector<int> &price, vector<vector<int>> &specials, vector<int> &needs) {\n        int n = price.size();\n\n        if (memo[needs]) return memo[needs];\n\n        int &x = memo[needs];\n        int res = 0;\n\n        for (int z = 0; z < n; z++) res += price[z] * needs[z];\n\n        for (const auto combo: specials) {\n            int choose = 1;\n            for (int k = 0; k < n; k++) {\n                if (combo[k] > needs[k]) {\n                    choose = 0;\n                    break;\n                }\n            }\n\n            if (choose) {\n                for (int p = 0; p < n; p++) {\n                    needs[p] -= combo[p];\n                }\n\n                res = min(res, dfs(price, specials, needs) + combo.back());\n                for (int q = 0; q < n; q++) {\n                    needs[q] += combo[q];\n                }\n            }\n        }\n\n        return x = res;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 1571843,
                "content": [
                    {
                        "username": "sin1080",
                        "content": "The constraints of this problem is too strong that if you construct a worst case test set everyone will TLE. Let me show you why.\\n\\nIt is stated that you can have at most 6 types of items and you need to buy at most 6 for each one of them. Which mean that there are 7^6=117649 states. It is further stated that there will be at most 100 \"special offers\". That results in 11764900 transitions. Each transition needs 6 multiplications to calculate the index, or comparable work for a hashmap / treemap find. Which basically means a TLE-for-all for the worst case.\\n\\nThe reason that there are lots of 4ms solutions is that the largest test cases are too weak, in a specific way. The special offers in these test cases are too large, containing too many items, so that if you use a DFS or DFS-memo based DP you will only visit a small portion of the 117649 states and you will be fine. In fact, you don\\'t even need DP, because the test sets are really TOO weak. However, if you use an array based DP approach you will get a TLE. A TLE also if you want a uniform and elegent solution and constructs \"offers\" that contains 1 items per type. Of course, if proper strong test cases are provided, all of us will TLE also.\\n\\nThis really doesn\\'t feel right to me, because it is in fact selecting specific implementation technics based on the special traits of the present test sets (prefers DFS to proper DP!), instead of selecting the best algorithms that generally work best.\\n\\nThe constraint of the problem should be lowered to somewhat 5 items and at most 5 each type, and strong test sets should be provided. Such test sets can be constructed by providing all kinds of small special offers, containing 2 or even only 1 items. Or, update the constraint to explicitly state that each special offer will contain at least say 3 or 5 items, so you know that a DFS-based approach will triumph and you should avoid creating 1-item pseudo-offers."
                    },
                    {
                        "username": "Nakanu",
                        "content": "I have looked around my fellow's posts. There are mainly 3 solutions.\\n1. Just use DFS, recursive call the function. \\n2. Try to use some memorization like map. \\n3. DP. I just see one solution using a 6D matrix to implement DP. Well, brilliant!. \\n\\nAll of them works for this small scenario, what if the problem is bigger? Which one do you think is the best? Or some other methods? Why?"
                    },
                    {
                        "username": "WeatherSetting",
                        "content": "I think I have a quite reasonable 80-line answer to this question in Scala, but it was rejected because the compile time limit is exceeded... Either this limit should be raised, or Scala should not be accepted as a language option. It's otherwise a waste of time."
                    },
                    {
                        "username": "recker2903",
                        "content": "why is this question marked bitmasking DP ?"
                    },
                    {
                        "username": "dribvurhd",
                        "content": "My initial solution `timed out`, because I combined `price` and `specials` into the `specials` array with a price for a single object being a special with just 1 item. This caused one of the test cases to take `~1300ms` to run. However, if I use the technique in the sample solution to greedily take all the single items once as the first candidate to the solution for a specific set of `needs`, then the same test case runs in `~9ms`. This indicates that the input (`specials`) doesn't contain test data that would break the recursive+memoized solutions. I think that with the given input constraints, there are input for which most (if not all) solutions will time out, irrespective of whether or not they use memoization."
                    },
                    {
                        "username": "nitissssh",
                        "content": "Either I am dumb or I think this should be a hard one !\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Backtracking + Memoization(Because there is overlapping sub-problem)\n\n```\nclass Solution {\npublic:\n    int memo[15][15][15][15][15][15] = {0};\n\n    int shoppingOffers(vector<int> &price, vector<vector<int>> &special, vector<int> &needs) {\n        int n = price.size();\n        vector<vector<int>> specials;\n\n        for (int i = 0; i < special.size(); i++) {\n            int sum = 0;\n            for (int j = 0; j < n; j++) sum += special[i][j] * price[j];\n            if (sum > special[i].back()) specials.push_back(special[i]);\n        }\n\n        vector<int> needs2(6, 0);\n        for (int i = 0; i < n; i++) needs2[i] = needs[i];\n\n        // do dfs + memoization\n        return dfs(price, specials, needs2);\n    }\n\n    int dfs(vector<int> &price, vector<vector<int>> &specials, vector<int> &needs) {\n        int n = price.size();\n\n        if (memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]] != 0) return memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\n\n        int &x = memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\n        int res = 0;\n\n        for (int z = 0; z < n; z++) res += price[z] * needs[z];\n\n        for (const auto combo: specials) {\n            int choose = 1;\n            for (int k = 0; k < n; k++) {\n                if (combo[k] > needs[k]) {\n                    choose = 0;\n                    break;\n                }\n            }\n\n            if (choose) {\n                for (int p = 0; p < n; p++) {\n                    needs[p] -= combo[p];\n                }\n\n                res = min(res, dfs(price, specials, needs) + combo.back());\n                for (int q = 0; q < n; q++) {\n                    needs[q] += combo[q];\n                }\n            }\n        }\n\n        return x = res;\n    }\n};\n```\n\nIf that is too scary to you. We can use map to store status:\n\n```\nclass Solution {\npublic:\n    map<vector<int>, int> memo;\n\n    int shoppingOffers(vector<int> &price, vector<vector<int>> &special, vector<int> &needs) {\n        int n = price.size();\n        vector<vector<int>> specials;\n\n        for (int i = 0; i < special.size(); i++) {\n            int sum = 0;\n            for (int j = 0; j < n; j++) sum += special[i][j] * price[j];\n\n            if (sum > special[i].back()) specials.push_back(special[i]);\n        }\n\n        // vector<int> needs2(6, 0);\n        // for (int i = 0; i < n; i++) needs2[i] = needs[i];\n\n        // do dfs + memoization\n        return dfs(price, specials, needs);\n    }\n\n    int dfs(vector<int> &price, vector<vector<int>> &specials, vector<int> &needs) {\n        int n = price.size();\n\n        if (memo[needs]) return memo[needs];\n\n        int &x = memo[needs];\n        int res = 0;\n\n        for (int z = 0; z < n; z++) res += price[z] * needs[z];\n\n        for (const auto combo: specials) {\n            int choose = 1;\n            for (int k = 0; k < n; k++) {\n                if (combo[k] > needs[k]) {\n                    choose = 0;\n                    break;\n                }\n            }\n\n            if (choose) {\n                for (int p = 0; p < n; p++) {\n                    needs[p] -= combo[p];\n                }\n\n                res = min(res, dfs(price, specials, needs) + combo.back());\n                for (int q = 0; q < n; q++) {\n                    needs[q] += combo[q];\n                }\n            }\n        }\n\n        return x = res;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 2061025,
                "content": [
                    {
                        "username": "sin1080",
                        "content": "The constraints of this problem is too strong that if you construct a worst case test set everyone will TLE. Let me show you why.\\n\\nIt is stated that you can have at most 6 types of items and you need to buy at most 6 for each one of them. Which mean that there are 7^6=117649 states. It is further stated that there will be at most 100 \"special offers\". That results in 11764900 transitions. Each transition needs 6 multiplications to calculate the index, or comparable work for a hashmap / treemap find. Which basically means a TLE-for-all for the worst case.\\n\\nThe reason that there are lots of 4ms solutions is that the largest test cases are too weak, in a specific way. The special offers in these test cases are too large, containing too many items, so that if you use a DFS or DFS-memo based DP you will only visit a small portion of the 117649 states and you will be fine. In fact, you don\\'t even need DP, because the test sets are really TOO weak. However, if you use an array based DP approach you will get a TLE. A TLE also if you want a uniform and elegent solution and constructs \"offers\" that contains 1 items per type. Of course, if proper strong test cases are provided, all of us will TLE also.\\n\\nThis really doesn\\'t feel right to me, because it is in fact selecting specific implementation technics based on the special traits of the present test sets (prefers DFS to proper DP!), instead of selecting the best algorithms that generally work best.\\n\\nThe constraint of the problem should be lowered to somewhat 5 items and at most 5 each type, and strong test sets should be provided. Such test sets can be constructed by providing all kinds of small special offers, containing 2 or even only 1 items. Or, update the constraint to explicitly state that each special offer will contain at least say 3 or 5 items, so you know that a DFS-based approach will triumph and you should avoid creating 1-item pseudo-offers."
                    },
                    {
                        "username": "Nakanu",
                        "content": "I have looked around my fellow's posts. There are mainly 3 solutions.\\n1. Just use DFS, recursive call the function. \\n2. Try to use some memorization like map. \\n3. DP. I just see one solution using a 6D matrix to implement DP. Well, brilliant!. \\n\\nAll of them works for this small scenario, what if the problem is bigger? Which one do you think is the best? Or some other methods? Why?"
                    },
                    {
                        "username": "WeatherSetting",
                        "content": "I think I have a quite reasonable 80-line answer to this question in Scala, but it was rejected because the compile time limit is exceeded... Either this limit should be raised, or Scala should not be accepted as a language option. It's otherwise a waste of time."
                    },
                    {
                        "username": "recker2903",
                        "content": "why is this question marked bitmasking DP ?"
                    },
                    {
                        "username": "dribvurhd",
                        "content": "My initial solution `timed out`, because I combined `price` and `specials` into the `specials` array with a price for a single object being a special with just 1 item. This caused one of the test cases to take `~1300ms` to run. However, if I use the technique in the sample solution to greedily take all the single items once as the first candidate to the solution for a specific set of `needs`, then the same test case runs in `~9ms`. This indicates that the input (`specials`) doesn't contain test data that would break the recursive+memoized solutions. I think that with the given input constraints, there are input for which most (if not all) solutions will time out, irrespective of whether or not they use memoization."
                    },
                    {
                        "username": "nitissssh",
                        "content": "Either I am dumb or I think this should be a hard one !\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Backtracking + Memoization(Because there is overlapping sub-problem)\n\n```\nclass Solution {\npublic:\n    int memo[15][15][15][15][15][15] = {0};\n\n    int shoppingOffers(vector<int> &price, vector<vector<int>> &special, vector<int> &needs) {\n        int n = price.size();\n        vector<vector<int>> specials;\n\n        for (int i = 0; i < special.size(); i++) {\n            int sum = 0;\n            for (int j = 0; j < n; j++) sum += special[i][j] * price[j];\n            if (sum > special[i].back()) specials.push_back(special[i]);\n        }\n\n        vector<int> needs2(6, 0);\n        for (int i = 0; i < n; i++) needs2[i] = needs[i];\n\n        // do dfs + memoization\n        return dfs(price, specials, needs2);\n    }\n\n    int dfs(vector<int> &price, vector<vector<int>> &specials, vector<int> &needs) {\n        int n = price.size();\n\n        if (memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]] != 0) return memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\n\n        int &x = memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\n        int res = 0;\n\n        for (int z = 0; z < n; z++) res += price[z] * needs[z];\n\n        for (const auto combo: specials) {\n            int choose = 1;\n            for (int k = 0; k < n; k++) {\n                if (combo[k] > needs[k]) {\n                    choose = 0;\n                    break;\n                }\n            }\n\n            if (choose) {\n                for (int p = 0; p < n; p++) {\n                    needs[p] -= combo[p];\n                }\n\n                res = min(res, dfs(price, specials, needs) + combo.back());\n                for (int q = 0; q < n; q++) {\n                    needs[q] += combo[q];\n                }\n            }\n        }\n\n        return x = res;\n    }\n};\n```\n\nIf that is too scary to you. We can use map to store status:\n\n```\nclass Solution {\npublic:\n    map<vector<int>, int> memo;\n\n    int shoppingOffers(vector<int> &price, vector<vector<int>> &special, vector<int> &needs) {\n        int n = price.size();\n        vector<vector<int>> specials;\n\n        for (int i = 0; i < special.size(); i++) {\n            int sum = 0;\n            for (int j = 0; j < n; j++) sum += special[i][j] * price[j];\n\n            if (sum > special[i].back()) specials.push_back(special[i]);\n        }\n\n        // vector<int> needs2(6, 0);\n        // for (int i = 0; i < n; i++) needs2[i] = needs[i];\n\n        // do dfs + memoization\n        return dfs(price, specials, needs);\n    }\n\n    int dfs(vector<int> &price, vector<vector<int>> &specials, vector<int> &needs) {\n        int n = price.size();\n\n        if (memo[needs]) return memo[needs];\n\n        int &x = memo[needs];\n        int res = 0;\n\n        for (int z = 0; z < n; z++) res += price[z] * needs[z];\n\n        for (const auto combo: specials) {\n            int choose = 1;\n            for (int k = 0; k < n; k++) {\n                if (combo[k] > needs[k]) {\n                    choose = 0;\n                    break;\n                }\n            }\n\n            if (choose) {\n                for (int p = 0; p < n; p++) {\n                    needs[p] -= combo[p];\n                }\n\n                res = min(res, dfs(price, specials, needs) + combo.back());\n                for (int q = 0; q < n; q++) {\n                    needs[q] += combo[q];\n                }\n            }\n        }\n\n        return x = res;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 1970662,
                "content": [
                    {
                        "username": "sin1080",
                        "content": "The constraints of this problem is too strong that if you construct a worst case test set everyone will TLE. Let me show you why.\\n\\nIt is stated that you can have at most 6 types of items and you need to buy at most 6 for each one of them. Which mean that there are 7^6=117649 states. It is further stated that there will be at most 100 \"special offers\". That results in 11764900 transitions. Each transition needs 6 multiplications to calculate the index, or comparable work for a hashmap / treemap find. Which basically means a TLE-for-all for the worst case.\\n\\nThe reason that there are lots of 4ms solutions is that the largest test cases are too weak, in a specific way. The special offers in these test cases are too large, containing too many items, so that if you use a DFS or DFS-memo based DP you will only visit a small portion of the 117649 states and you will be fine. In fact, you don\\'t even need DP, because the test sets are really TOO weak. However, if you use an array based DP approach you will get a TLE. A TLE also if you want a uniform and elegent solution and constructs \"offers\" that contains 1 items per type. Of course, if proper strong test cases are provided, all of us will TLE also.\\n\\nThis really doesn\\'t feel right to me, because it is in fact selecting specific implementation technics based on the special traits of the present test sets (prefers DFS to proper DP!), instead of selecting the best algorithms that generally work best.\\n\\nThe constraint of the problem should be lowered to somewhat 5 items and at most 5 each type, and strong test sets should be provided. Such test sets can be constructed by providing all kinds of small special offers, containing 2 or even only 1 items. Or, update the constraint to explicitly state that each special offer will contain at least say 3 or 5 items, so you know that a DFS-based approach will triumph and you should avoid creating 1-item pseudo-offers."
                    },
                    {
                        "username": "Nakanu",
                        "content": "I have looked around my fellow's posts. There are mainly 3 solutions.\\n1. Just use DFS, recursive call the function. \\n2. Try to use some memorization like map. \\n3. DP. I just see one solution using a 6D matrix to implement DP. Well, brilliant!. \\n\\nAll of them works for this small scenario, what if the problem is bigger? Which one do you think is the best? Or some other methods? Why?"
                    },
                    {
                        "username": "WeatherSetting",
                        "content": "I think I have a quite reasonable 80-line answer to this question in Scala, but it was rejected because the compile time limit is exceeded... Either this limit should be raised, or Scala should not be accepted as a language option. It's otherwise a waste of time."
                    },
                    {
                        "username": "recker2903",
                        "content": "why is this question marked bitmasking DP ?"
                    },
                    {
                        "username": "dribvurhd",
                        "content": "My initial solution `timed out`, because I combined `price` and `specials` into the `specials` array with a price for a single object being a special with just 1 item. This caused one of the test cases to take `~1300ms` to run. However, if I use the technique in the sample solution to greedily take all the single items once as the first candidate to the solution for a specific set of `needs`, then the same test case runs in `~9ms`. This indicates that the input (`specials`) doesn't contain test data that would break the recursive+memoized solutions. I think that with the given input constraints, there are input for which most (if not all) solutions will time out, irrespective of whether or not they use memoization."
                    },
                    {
                        "username": "nitissssh",
                        "content": "Either I am dumb or I think this should be a hard one !\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Backtracking + Memoization(Because there is overlapping sub-problem)\n\n```\nclass Solution {\npublic:\n    int memo[15][15][15][15][15][15] = {0};\n\n    int shoppingOffers(vector<int> &price, vector<vector<int>> &special, vector<int> &needs) {\n        int n = price.size();\n        vector<vector<int>> specials;\n\n        for (int i = 0; i < special.size(); i++) {\n            int sum = 0;\n            for (int j = 0; j < n; j++) sum += special[i][j] * price[j];\n            if (sum > special[i].back()) specials.push_back(special[i]);\n        }\n\n        vector<int> needs2(6, 0);\n        for (int i = 0; i < n; i++) needs2[i] = needs[i];\n\n        // do dfs + memoization\n        return dfs(price, specials, needs2);\n    }\n\n    int dfs(vector<int> &price, vector<vector<int>> &specials, vector<int> &needs) {\n        int n = price.size();\n\n        if (memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]] != 0) return memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\n\n        int &x = memo[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\n        int res = 0;\n\n        for (int z = 0; z < n; z++) res += price[z] * needs[z];\n\n        for (const auto combo: specials) {\n            int choose = 1;\n            for (int k = 0; k < n; k++) {\n                if (combo[k] > needs[k]) {\n                    choose = 0;\n                    break;\n                }\n            }\n\n            if (choose) {\n                for (int p = 0; p < n; p++) {\n                    needs[p] -= combo[p];\n                }\n\n                res = min(res, dfs(price, specials, needs) + combo.back());\n                for (int q = 0; q < n; q++) {\n                    needs[q] += combo[q];\n                }\n            }\n        }\n\n        return x = res;\n    }\n};\n```\n\nIf that is too scary to you. We can use map to store status:\n\n```\nclass Solution {\npublic:\n    map<vector<int>, int> memo;\n\n    int shoppingOffers(vector<int> &price, vector<vector<int>> &special, vector<int> &needs) {\n        int n = price.size();\n        vector<vector<int>> specials;\n\n        for (int i = 0; i < special.size(); i++) {\n            int sum = 0;\n            for (int j = 0; j < n; j++) sum += special[i][j] * price[j];\n\n            if (sum > special[i].back()) specials.push_back(special[i]);\n        }\n\n        // vector<int> needs2(6, 0);\n        // for (int i = 0; i < n; i++) needs2[i] = needs[i];\n\n        // do dfs + memoization\n        return dfs(price, specials, needs);\n    }\n\n    int dfs(vector<int> &price, vector<vector<int>> &specials, vector<int> &needs) {\n        int n = price.size();\n\n        if (memo[needs]) return memo[needs];\n\n        int &x = memo[needs];\n        int res = 0;\n\n        for (int z = 0; z < n; z++) res += price[z] * needs[z];\n\n        for (const auto combo: specials) {\n            int choose = 1;\n            for (int k = 0; k < n; k++) {\n                if (combo[k] > needs[k]) {\n                    choose = 0;\n                    break;\n                }\n            }\n\n            if (choose) {\n                for (int p = 0; p < n; p++) {\n                    needs[p] -= combo[p];\n                }\n\n                res = min(res, dfs(price, specials, needs) + combo.back());\n                for (int q = 0; q < n; q++) {\n                    needs[q] += combo[q];\n                }\n            }\n        }\n\n        return x = res;\n    }\n};\n```"
                    }
                ]
            }
        ]
    }
]