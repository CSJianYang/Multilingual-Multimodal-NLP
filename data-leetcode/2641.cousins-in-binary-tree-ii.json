[
    {
        "title": "Cousins in Binary Tree II",
        "question_content": "Given the root of a binary tree, replace the value of each node in the tree with the sum of all its cousins' values.\nTwo nodes of a binary tree are cousins if they have the same depth with different parents.\nReturn the root of the modified tree.\nNote that the depth of a node is the number of edges in the path from the root node to it.\n&nbsp;\nExample 1:\n\nInput: root = [5,4,9,1,10,null,7]\nOutput: [0,0,0,7,7,null,11]\nExplanation: The diagram above shows the initial binary tree and the binary tree after changing the value of each node.\n- Node with value 5 does not have any cousins so its sum is 0.\n- Node with value 4 does not have any cousins so its sum is 0.\n- Node with value 9 does not have any cousins so its sum is 0.\n- Node with value 1 has a cousin with value 7 so its sum is 7.\n- Node with value 10 has a cousin with value 7 so its sum is 7.\n- Node with value 7 has cousins with values 1 and 10 so its sum is 11.\n\nExample 2:\n\nInput: root = [3,1,2]\nOutput: [0,0,0]\nExplanation: The diagram above shows the initial binary tree and the binary tree after changing the value of each node.\n- Node with value 3 does not have any cousins so its sum is 0.\n- Node with value 1 does not have any cousins so its sum is 0.\n- Node with value 2 does not have any cousins so its sum is 0.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 105].\n\t1 <= Node.val <= 104",
        "solutions": [
            {
                "id": 3420099,
                "title": "simple-bfs-tracking-sum-of-child-very-simple-easy-to-understand",
                "content": "<b>Please Up Vote if you like the solution\\n```\\n/*\\n1. Run BFS \\n2. While traversing take the sum of the child nodes & also keep storing the node in a buffer\\n3. After each stage of the BFS, traverse the buf & update the node with value sum - (child\\'s sum)\\n*/\\n\\nTreeNode* replaceValueInTree(TreeNode* root) {\\n    root->val = 0;\\n    queue<TreeNode*> q;  q.push(root);\\n    while(!q.empty()){\\n        int n = q.size(), sum = 0;\\n        vector<TreeNode*> buf;\\n        while(n--){\\n            TreeNode* node = q.front(); q.pop();\\n            buf.push_back(node);\\n            if(node->left) { q.push(node->left); sum += node->left->val; }\\n            if(node->right){ q.push(node->right); sum += node->right->val; }\\n        }\\n        for(auto node: buf){\\n            int  t = sum;\\n            if(node->left)  t -= node->left->val;\\n            if(node->right) t -= node->right->val;\\n            if(node->left)  node->left->val = t;\\n            if(node->right) node->right->val = t;\\n        }\\n    }\\n    return root;\\n}\\n```\\n\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n1. Run BFS \\n2. While traversing take the sum of the child nodes & also keep storing the node in a buffer\\n3. After each stage of the BFS, traverse the buf & update the node with value sum - (child\\'s sum)\\n*/\\n\\nTreeNode* replaceValueInTree(TreeNode* root) {\\n    root->val = 0;\\n    queue<TreeNode*> q;  q.push(root);\\n    while(!q.empty()){\\n        int n = q.size(), sum = 0;\\n        vector<TreeNode*> buf;\\n        while(n--){\\n            TreeNode* node = q.front(); q.pop();\\n            buf.push_back(node);\\n            if(node->left) { q.push(node->left); sum += node->left->val; }\\n            if(node->right){ q.push(node->right); sum += node->right->val; }\\n        }\\n        for(auto node: buf){\\n            int  t = sum;\\n            if(node->left)  t -= node->left->val;\\n            if(node->right) t -= node->right->val;\\n            if(node->left)  node->left->val = t;\\n            if(node->right) node->right->val = t;\\n        }\\n    }\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420081,
                "title": "level-sum",
                "content": "> My account (votrubac) was banned due to the contest rules violation... I sometimes re-use bits of my previous solutions, like standard algorithms. Not sure if it spooked the plagiarism checker or something.\\n\\nWe traverse the tree two times, tracking the current depth `d`.\\n\\nFirst time, we sum values for each level using `l_sum`.\\n\\nSecond time, we update the node value to the level sum, minus value of the current node and its sibling `sib`.\\n\\nFor that, we pass the value of a sibling from the parent node.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> l_sum;\\n    void level_sum(TreeNode* n, int d = 0) {\\n        if (n == nullptr)\\n            return;\\n        l_sum.resize(max((int)l_sum.size(), d + 1));\\n        l_sum[d] += n->val;\\n        level_sum(n->left, d + 1);\\n        level_sum(n->right, d + 1);\\n    }\\n    void update_sum(TreeNode* n, int sib_sum, int d = 0) {\\n        if (n == nullptr)\\n            return;\\n        n->val = l_sum[d] - sib_sum;\\n        sib_sum = (n->left == nullptr ? 0 : n->left->val)\\n            + (n->right == nullptr ? 0 : n->right->val);\\n        update_sum(n->left, sib_sum, d + 1);\\n        update_sum(n->right, sib_sum, d + 1);\\n    }    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        level_sum(root);\\n        update_sum(root, root->val);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> l_sum;\\n    void level_sum(TreeNode* n, int d = 0) {\\n        if (n == nullptr)\\n            return;\\n        l_sum.resize(max((int)l_sum.size(), d + 1));\\n        l_sum[d] += n->val;\\n        level_sum(n->left, d + 1);\\n        level_sum(n->right, d + 1);\\n    }\\n    void update_sum(TreeNode* n, int sib_sum, int d = 0) {\\n        if (n == nullptr)\\n            return;\\n        n->val = l_sum[d] - sib_sum;\\n        sib_sum = (n->left == nullptr ? 0 : n->left->val)\\n            + (n->right == nullptr ? 0 : n->right->val);\\n        update_sum(n->left, sib_sum, d + 1);\\n        update_sum(n->right, sib_sum, d + 1);\\n    }    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        level_sum(root);\\n        update_sum(root, root->val);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419991,
                "title": "c-java-python3-double-dfs",
                "content": "\\n# Intuition\\nFirst find sum of all nodes on each level. Then to find sum of cousin, just need to subtract the value of child and its direct siblings to find sum of cousins.\\n\\n# Approach\\nThe first dfs finds the sum of nodes on each level\\nThe second dfs finds the sum of cousins and creates new binary tree\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n**Python3**:\\n```\\ndef replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n    m = Counter()\\n    def dfs(r, l):\\n        if not r: return\\n        m[l] += r.val\\n        dfs(r.left, l + 1)\\n        dfs(r.right, l + 1)\\n    dfs(root, 0)\\n    \\n    def dfs1(r, l, curr):\\n        sum_of_cousins = m[l + 1] - (r.left.val if r.left else 0) - (r.right.val if r.right else 0)\\n        if r.left:\\n            curr.left = TreeNode(sum_of_cousins)\\n            dfs1(r.left, l + 1, curr.left)\\n        if r.right:\\n            curr.right = TreeNode(sum_of_cousins)\\n            dfs1(r.right, l + 1, curr.right)\\n        return curr\\n    return dfs1(root, 0, TreeNode(0))\\n```\\n\\n**C++**:\\n```\\nTreeNode* replaceValueInTree(TreeNode* root) {\\n    unordered_map<int, int> m;\\n    dfs(root, 0, m);\\n    return dfs1(root, 0, new TreeNode(0), m);\\n}\\nvoid dfs(TreeNode* r, int l, unordered_map<int, int>& m) {\\n    if (!r) return;\\n    m[l] += r->val;\\n    dfs(r->left, l + 1, m);\\n    dfs(r->right, l + 1, m);\\n}\\nTreeNode* dfs1(TreeNode* r, int l, TreeNode* curr, unordered_map<int, int>& m) {\\n    int sum_of_cousins = m[l + 1] - (r->left ? r->left->val : 0) - (r->right ? r->right->val : 0);\\n    if (r->left) {\\n        curr->left = new TreeNode(sum_of_cousins);\\n        dfs1(r->left, l + 1, curr->left, m);\\n    }\\n    if (r->right) {\\n        curr->right = new TreeNode(sum_of_cousins);\\n        dfs1(r->right, l + 1, curr->right, m);\\n    }\\n    return curr;\\n}\\n```\\n\\n**Java**:\\n```\\npublic TreeNode replaceValueInTree(TreeNode root) {\\n    Map<Integer, Integer> m = new HashMap<>();\\n    dfs(root, 0, m);\\n    return dfs1(root, 0, new TreeNode(0), m);\\n}\\nprivate void dfs(TreeNode r, int l, Map<Integer, Integer> m) {\\n    if (r == null) return;\\n    m.put(l, m.getOrDefault(l, 0) + r.val);\\n    dfs(r.left, l + 1, m);\\n    dfs(r.right, l + 1, m);\\n}\\nprivate TreeNode dfs1(TreeNode r, int l, TreeNode curr, Map<Integer, Integer> m) {\\n    int sum_of_cousins = m.getOrDefault(l + 1, 0) - ((r.left != null) ? r.left.val : 0) - ((r.right != null) ? r.right.val : 0);\\n    if (r.left != null) {\\n        curr.left = new TreeNode(sum_of_cousins);\\n        dfs1(r.left, l + 1, curr.left, m);\\n    }\\n    if (r.right != null) {\\n        curr.right = new TreeNode(sum_of_cousins);\\n        dfs1(r.right, l + 1, curr.right, m);\\n    }\\n    return curr;\\n}\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n    m = Counter()\\n    def dfs(r, l):\\n        if not r: return\\n        m[l] += r.val\\n        dfs(r.left, l + 1)\\n        dfs(r.right, l + 1)\\n    dfs(root, 0)\\n    \\n    def dfs1(r, l, curr):\\n        sum_of_cousins = m[l + 1] - (r.left.val if r.left else 0) - (r.right.val if r.right else 0)\\n        if r.left:\\n            curr.left = TreeNode(sum_of_cousins)\\n            dfs1(r.left, l + 1, curr.left)\\n        if r.right:\\n            curr.right = TreeNode(sum_of_cousins)\\n            dfs1(r.right, l + 1, curr.right)\\n        return curr\\n    return dfs1(root, 0, TreeNode(0))\\n```\n```\\nTreeNode* replaceValueInTree(TreeNode* root) {\\n    unordered_map<int, int> m;\\n    dfs(root, 0, m);\\n    return dfs1(root, 0, new TreeNode(0), m);\\n}\\nvoid dfs(TreeNode* r, int l, unordered_map<int, int>& m) {\\n    if (!r) return;\\n    m[l] += r->val;\\n    dfs(r->left, l + 1, m);\\n    dfs(r->right, l + 1, m);\\n}\\nTreeNode* dfs1(TreeNode* r, int l, TreeNode* curr, unordered_map<int, int>& m) {\\n    int sum_of_cousins = m[l + 1] - (r->left ? r->left->val : 0) - (r->right ? r->right->val : 0);\\n    if (r->left) {\\n        curr->left = new TreeNode(sum_of_cousins);\\n        dfs1(r->left, l + 1, curr->left, m);\\n    }\\n    if (r->right) {\\n        curr->right = new TreeNode(sum_of_cousins);\\n        dfs1(r->right, l + 1, curr->right, m);\\n    }\\n    return curr;\\n}\\n```\n```\\npublic TreeNode replaceValueInTree(TreeNode root) {\\n    Map<Integer, Integer> m = new HashMap<>();\\n    dfs(root, 0, m);\\n    return dfs1(root, 0, new TreeNode(0), m);\\n}\\nprivate void dfs(TreeNode r, int l, Map<Integer, Integer> m) {\\n    if (r == null) return;\\n    m.put(l, m.getOrDefault(l, 0) + r.val);\\n    dfs(r.left, l + 1, m);\\n    dfs(r.right, l + 1, m);\\n}\\nprivate TreeNode dfs1(TreeNode r, int l, TreeNode curr, Map<Integer, Integer> m) {\\n    int sum_of_cousins = m.getOrDefault(l + 1, 0) - ((r.left != null) ? r.left.val : 0) - ((r.right != null) ? r.right.val : 0);\\n    if (r.left != null) {\\n        curr.left = new TreeNode(sum_of_cousins);\\n        dfs1(r.left, l + 1, curr.left, m);\\n    }\\n    if (r.right != null) {\\n        curr.right = new TreeNode(sum_of_cousins);\\n        dfs1(r.right, l + 1, curr.right, m);\\n    }\\n    return curr;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420337,
                "title": "c-simplest-and-easy-to-understand-superfast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we are going to find the level-wise sum of binary tree and store it in a vector `depthsum`. Thus, `depth[i]` will contain the sum of nodes at depth `i`. So, we can assign the node the value `depth[i]` and deduction the value of it\\'s own and it parental childer(sibling).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRead the comments you we will be able to get the solution easily.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> depthsum;\\n\\n    // Function to find the depth of each element.\\n    void solve(TreeNode* root, int d){\\n        if(root==NULL) return;\\n\\n        if(d>=depthsum.size()) depthsum.push_back(root->val);\\n        else depthsum[d] += root->val;\\n\\n        solve(root->left, d+1);\\n        solve(root->right, d+1);\\n    }\\n    \\n    // Function to recreate the tree \\n    void fill(TreeNode* root, int d){  \\n        if(root==NULL) return;\\n        int ded = 0;\\n\\n        // storing the value of children of current node in ded which to be deducted.\\n        if(root->left) ded += root->left->val;\\n        if(root->right) ded += root->right->val;\\n\\n        // then assigning the sum of all nodes at that depth and subtracting it\\'s own value and the value of its siblings which are stored in ded\\n        if(root->left) root->left->val = depthsum[d+1] -ded;\\n        if(root->right) root->right->val = depthsum[d+1] -ded;\\n        \\n        // then recursively do the same for all the nodes.\\n        fill(root->left, d+1);\\n        fill(root->right, d+1);\\n        \\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==NULL) return NULL;\\n        root->val=0;\\n        solve(root, 0); // Function to find the depth of each element.\\n        fill(root, 0); // Function to recreate the tree \\n        return root;    \\n    }\\n};\\n\\n// PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Backtracking",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> depthsum;\\n\\n    // Function to find the depth of each element.\\n    void solve(TreeNode* root, int d){\\n        if(root==NULL) return;\\n\\n        if(d>=depthsum.size()) depthsum.push_back(root->val);\\n        else depthsum[d] += root->val;\\n\\n        solve(root->left, d+1);\\n        solve(root->right, d+1);\\n    }\\n    \\n    // Function to recreate the tree \\n    void fill(TreeNode* root, int d){  \\n        if(root==NULL) return;\\n        int ded = 0;\\n\\n        // storing the value of children of current node in ded which to be deducted.\\n        if(root->left) ded += root->left->val;\\n        if(root->right) ded += root->right->val;\\n\\n        // then assigning the sum of all nodes at that depth and subtracting it\\'s own value and the value of its siblings which are stored in ded\\n        if(root->left) root->left->val = depthsum[d+1] -ded;\\n        if(root->right) root->right->val = depthsum[d+1] -ded;\\n        \\n        // then recursively do the same for all the nodes.\\n        fill(root->left, d+1);\\n        fill(root->right, d+1);\\n        \\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==NULL) return NULL;\\n        root->val=0;\\n        solve(root, 0); // Function to find the depth of each element.\\n        fill(root, 0); // Function to recreate the tree \\n        return root;    \\n    }\\n};\\n\\n// PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419993,
                "title": "java-python-3-dfs-and-bfs-w-brief-explanation-and-analysis",
                "content": "**DFS**\\n\\n\\n1. First `dfs` get the sum of each level;\\n2. In Second `dfs`, we first locate the nodes with `2` kids, then update the value of each kid to the sum of the `2`kids; then for each node use level sum to minus its updated value to get final value.\\n\\n```java\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        List<Integer> levelSum = new ArrayList<>();\\n        dfs(root, 0, levelSum);\\n        dfs2(root, 0, levelSum);\\n        return root;\\n    }\\n    private void dfs(TreeNode n, int depth, List<Integer> levelSum) {\\n        if (n != null) {\\n            if (depth == levelSum.size()) {\\n                levelSum.add(0);\\n            }\\n            levelSum.set(depth, levelSum.get(depth) + n.val);\\n            dfs(n.left, depth + 1, levelSum);    \\n            dfs(n.right, depth + 1, levelSum);    \\n        }\\n    }\\n    private void dfs2(TreeNode n, int depth, List<Integer> levelSum) {\\n        if (n != null) {\\n            n.val = levelSum.get(depth) - n.val;\\n            if (n.left != null && n.right != null) {\\n                int siblingsSum = n.left.val + n.right.val;\\n                n.left.val = n.right.val = siblingsSum;\\n            }\\n            dfs2(n.left, depth + 1, levelSum);\\n            dfs2(n.right, depth + 1, levelSum);\\n        }\\n    }\\n```\\n\\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n\\n        def dfs(node: TreeNode, depth: int) -> None:\\n            if node:\\n                if len(level_sum) == depth:\\n                    level_sum.append(0)\\n                level_sum[depth] += node.val\\n                dfs(node.left, depth + 1)\\n                dfs(node.right, depth + 1)\\n\\n        def dfs2(node: TreeNode, depth: int) -> None:\\n            if node:\\n                node.val = level_sum[depth] - node.val\\n                if node.left and node.right:\\n                    siblings_sum = node.left.val + node.right.val\\n                    node.left.val = node.right.val = siblings_sum\\n                dfs2(node.left, depth + 1)\\n                dfs2(node.right, depth + 1)\\n\\n        level_sum = []\\n        dfs(root, 0)        \\n        dfs2(root, 0)        \\n        return root\\n```\\n**Analysis:**\\nTime: `O(n)`, space: `O(h)`, where `n = # of nodes, h = height of the tree`.\\n\\n----\\n\\n**BFS**\\n\\nThe following idea and the corresponding 2 codes inspired by **@pbmessi**:\\n\\n1. BFS traversal to get next level sum, get the sum of each level;\\n2. During traversal, locate the nodes with `2` kids, then update the value of each kid to the sum of the `2`kids; then for each node use level sum to minus its updated value to get final value.\\n\\n\\n```java\\n    public TreeNode replaceValueInTree2(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int currentLevelSum = root.val;\\n        while (!q.isEmpty()) {\\n            int nextLevelSum = 0;\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                TreeNode n = q.poll();\\n                n.val = currentLevelSum - n.val;\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        q.offer(kid);\\n                        nextLevelSum += kid.val;\\n                    }\\n                }\\n                if (n.left != null && n.right != null) {\\n                    int sum = n.left.val + n.right.val;\\n                    n.left.val = n.right.val = sum;\\n                }\\n            }\\n            currentLevelSum = nextLevelSum;\\n        }\\n        return root;        \\n    }\\n```\\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        current_level_sum = root.val\\n        q = [root]\\n        while q:\\n            next_level, next_level_sum = [], 0\\n            for node in q:\\n                node.val = current_level_sum - node.val\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        next_level.append(kid)\\n                        next_level_sum += kid.val        \\n                if node.left and node.right:\\n                    sm = node.left.val + node.right.val\\n                    node.left.val = node.right.val = sm\\n            q, current_level_sum = next_level, next_level_sum\\n        return root\\n```\\n\\nAnother variant of **BFS**:\\n\\n1. BFS traversal to get next level sum, and keep a copy of current level of nodes;\\n2. For each node, use next level sum minus its kids\\' value sum to get the required value.\\n\\n```java\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        root.val = 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        while (!q.isEmpty()) {\\n            List<TreeNode> parents = new ArrayList<>(q);\\n            int nextLevelSum = 0;\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                TreeNode n = q.poll();\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        q.offer(kid);\\n                        nextLevelSum += kid.val;\\n                    }\\n                }\\n            }\\n            for (TreeNode n : parents) {\\n                int replacedVal = nextLevelSum;\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        replacedVal -= kid.val;\\n                    }\\n                }\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        kid.val = replacedVal;\\n                    }\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n```\\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        q = [root]\\n        while q:\\n            next_level, parents = [], q[:]\\n            next_level_sum = 0\\n            for node in q:\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        next_level.append(kid)\\n                        next_level_sum += kid.val        \\n            for node in parents:                \\n                replaced_val = next_level_sum\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        replaced_val -= kid.val\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        kid.val = replaced_val\\n            q = next_level        \\n        return root\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`,  space: `O(w)`, where `n = # of nodes, w = the max # of the nodes among all levels of the tree`.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```java\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        List<Integer> levelSum = new ArrayList<>();\\n        dfs(root, 0, levelSum);\\n        dfs2(root, 0, levelSum);\\n        return root;\\n    }\\n    private void dfs(TreeNode n, int depth, List<Integer> levelSum) {\\n        if (n != null) {\\n            if (depth == levelSum.size()) {\\n                levelSum.add(0);\\n            }\\n            levelSum.set(depth, levelSum.get(depth) + n.val);\\n            dfs(n.left, depth + 1, levelSum);    \\n            dfs(n.right, depth + 1, levelSum);    \\n        }\\n    }\\n    private void dfs2(TreeNode n, int depth, List<Integer> levelSum) {\\n        if (n != null) {\\n            n.val = levelSum.get(depth) - n.val;\\n            if (n.left != null && n.right != null) {\\n                int siblingsSum = n.left.val + n.right.val;\\n                n.left.val = n.right.val = siblingsSum;\\n            }\\n            dfs2(n.left, depth + 1, levelSum);\\n            dfs2(n.right, depth + 1, levelSum);\\n        }\\n    }\\n```\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n\\n        def dfs(node: TreeNode, depth: int) -> None:\\n            if node:\\n                if len(level_sum) == depth:\\n                    level_sum.append(0)\\n                level_sum[depth] += node.val\\n                dfs(node.left, depth + 1)\\n                dfs(node.right, depth + 1)\\n\\n        def dfs2(node: TreeNode, depth: int) -> None:\\n            if node:\\n                node.val = level_sum[depth] - node.val\\n                if node.left and node.right:\\n                    siblings_sum = node.left.val + node.right.val\\n                    node.left.val = node.right.val = siblings_sum\\n                dfs2(node.left, depth + 1)\\n                dfs2(node.right, depth + 1)\\n\\n        level_sum = []\\n        dfs(root, 0)        \\n        dfs2(root, 0)        \\n        return root\\n```\n```java\\n    public TreeNode replaceValueInTree2(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int currentLevelSum = root.val;\\n        while (!q.isEmpty()) {\\n            int nextLevelSum = 0;\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                TreeNode n = q.poll();\\n                n.val = currentLevelSum - n.val;\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        q.offer(kid);\\n                        nextLevelSum += kid.val;\\n                    }\\n                }\\n                if (n.left != null && n.right != null) {\\n                    int sum = n.left.val + n.right.val;\\n                    n.left.val = n.right.val = sum;\\n                }\\n            }\\n            currentLevelSum = nextLevelSum;\\n        }\\n        return root;        \\n    }\\n```\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        current_level_sum = root.val\\n        q = [root]\\n        while q:\\n            next_level, next_level_sum = [], 0\\n            for node in q:\\n                node.val = current_level_sum - node.val\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        next_level.append(kid)\\n                        next_level_sum += kid.val        \\n                if node.left and node.right:\\n                    sm = node.left.val + node.right.val\\n                    node.left.val = node.right.val = sm\\n            q, current_level_sum = next_level, next_level_sum\\n        return root\\n```\n```java\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        root.val = 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        while (!q.isEmpty()) {\\n            List<TreeNode> parents = new ArrayList<>(q);\\n            int nextLevelSum = 0;\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                TreeNode n = q.poll();\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        q.offer(kid);\\n                        nextLevelSum += kid.val;\\n                    }\\n                }\\n            }\\n            for (TreeNode n : parents) {\\n                int replacedVal = nextLevelSum;\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        replacedVal -= kid.val;\\n                    }\\n                }\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        kid.val = replacedVal;\\n                    }\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n```\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        q = [root]\\n        while q:\\n            next_level, parents = [], q[:]\\n            next_level_sum = 0\\n            for node in q:\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        next_level.append(kid)\\n                        next_level_sum += kid.val        \\n            for node in parents:                \\n                replaced_val = next_level_sum\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        replaced_val -= kid.val\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        kid.val = replaced_val\\n            q = next_level        \\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420073,
                "title": "c-easy-beginner-friendly-level-order-traversal",
                "content": "# Intuition\\nOverall, this solution calculates the sum of values of nodes at each level in the first pass and uses that information to update the values of nodes in the second pass, effectively replacing the values in the tree as required.\\n\\n# Approach\\nThe approach used in this solution is a two-pass level-order traversal of the tree. In the first pass, the sum of values of nodes at each level is calculated and stored in an unordered map with the level as the key. In the second pass, the values of nodes are updated using the sum of values of its children nodes and its own original value, retrieved from the map.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        int lev=0;\\n        unordered_map<int, int> mp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        mp[0]=root->val;\\n        while(!q.empty()) \\n        {\\n            lev++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++) \\n            {\\n                auto n=q.front();\\n                q.pop();\\n                if(n->left) \\n                {\\n                    q.push(n->left);\\n                    mp[lev]+=(n->left->val);\\n                }\\n                if(n->right)\\n                {\\n                    q.push(n->right);\\n                    mp[lev]+=(n->right->val);\\n                }\\n            }\\n        }\\n\\n        q.push(root);\\n        lev=0;\\n        root->val=0;\\n        while(!q.empty()) \\n        {\\n            lev++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++) \\n            {\\n                auto n=q.front();\\n                q.pop();\\n                int lef=(n->left)?n->left->val:0;\\n                int ri=(n->right)?n->right->val:0;\\n                if(n->left) \\n                {\\n                    q.push(n->left);\\n                    n->left->val=mp[lev]-lef-ri;\\n                }\\n                if(n->right) \\n                {\\n                    q.push(n->right);\\n                    n->right->val=mp[lev]-lef-ri;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        int lev=0;\\n        unordered_map<int, int> mp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        mp[0]=root->val;\\n        while(!q.empty()) \\n        {\\n            lev++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++) \\n            {\\n                auto n=q.front();\\n                q.pop();\\n                if(n->left) \\n                {\\n                    q.push(n->left);\\n                    mp[lev]+=(n->left->val);\\n                }\\n                if(n->right)\\n                {\\n                    q.push(n->right);\\n                    mp[lev]+=(n->right->val);\\n                }\\n            }\\n        }\\n\\n        q.push(root);\\n        lev=0;\\n        root->val=0;\\n        while(!q.empty()) \\n        {\\n            lev++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++) \\n            {\\n                auto n=q.front();\\n                q.pop();\\n                int lef=(n->left)?n->left->val:0;\\n                int ri=(n->right)?n->right->val:0;\\n                if(n->left) \\n                {\\n                    q.push(n->left);\\n                    n->left->val=mp[lev]-lef-ri;\\n                }\\n                if(n->right) \\n                {\\n                    q.push(n->right);\\n                    n->right->val=mp[lev]-lef-ri;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419973,
                "title": "c-full-explanation-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    //same depth means node at same level\\n    //for this we will use queue\\n    //As we need parent information of each node so queue will have curr_node and its parent as pair \\n    // The main point here is ans of node at particular level is =(Total_Sum at that level) - (sum of node having same parent)\\n    // now for calculating sum of node having same parent i am using map\\n    //The key point here is i am not using int as my key in map because two different node can have same value so i am using TreeNode* as key\\n    // I am modifying same tree so i have used temp arr to store node in a way they are coming in queue at each level\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*,TreeNode*>>q;       \\n        q.push({NULL,root});\\n        \\n        while(q.size())\\n        {\\n            int size=q.size();\\n            unordered_map<TreeNode*,int>mp;\\n            vector<pair<TreeNode*,TreeNode*>>temp;\\n            int total_sum=0;\\n            while(size--)\\n            {\\n                auto node=q.front(); //node.first=parent , node.second=curr_node\\n                q.pop();\\n                 \\n                total_sum+=node.second->val;  //calculating total sum at particular level\\n                mp[node.first]+=node.second->val;  //storing sum of node having same parent\\n                temp.push_back({node.first,node.second}); //this is used so that we can modify current tree\\n                \\n                if(node.second->left)\\n                    q.push({node.second,node.second->left});\\n                \\n                if(node.second->right)\\n                    q.push({node.second,node.second->right});\\n            }\\n            \\n            for(auto it:temp)\\n            {\\n                int val=total_sum-mp[it.first]; //formula\\n                it.second->val=val;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //same depth means node at same level\\n    //for this we will use queue\\n    //As we need parent information of each node so queue will have curr_node and its parent as pair \\n    // The main point here is ans of node at particular level is =(Total_Sum at that level) - (sum of node having same parent)\\n    // now for calculating sum of node having same parent i am using map\\n    //The key point here is i am not using int as my key in map because two different node can have same value so i am using TreeNode* as key\\n    // I am modifying same tree so i have used temp arr to store node in a way they are coming in queue at each level\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*,TreeNode*>>q;       \\n        q.push({NULL,root});\\n        \\n        while(q.size())\\n        {\\n            int size=q.size();\\n            unordered_map<TreeNode*,int>mp;\\n            vector<pair<TreeNode*,TreeNode*>>temp;\\n            int total_sum=0;\\n            while(size--)\\n            {\\n                auto node=q.front(); //node.first=parent , node.second=curr_node\\n                q.pop();\\n                 \\n                total_sum+=node.second->val;  //calculating total sum at particular level\\n                mp[node.first]+=node.second->val;  //storing sum of node having same parent\\n                temp.push_back({node.first,node.second}); //this is used so that we can modify current tree\\n                \\n                if(node.second->left)\\n                    q.push({node.second,node.second->left});\\n                \\n                if(node.second->right)\\n                    q.push({node.second,node.second->right});\\n            }\\n            \\n            for(auto it:temp)\\n            {\\n                int val=total_sum-mp[it.first]; //formula\\n                it.second->val=val;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420009,
                "title": "using-bfs-to-precompute-lvl-sum",
                "content": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        List<Integer> l=new ArrayList<>();\\n        l.add(root.val);\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            int sum1=0;\\n            while(size-->0){\\n                TreeNode curr=q.poll();\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n            }\\n            l.add(sum1);\\n            \\n        }\\n       \\n        q.clear();\\n        q.add(root);\\n        int lvl=-1;\\n        while(!q.isEmpty()){\\n            lvl++;\\n            int size=q.size();\\n            \\n            while(size-->0){\\n                int sum1=0;\\n                TreeNode curr=q.poll();\\n                if(lvl==0 || lvl==1){\\n                    curr.val=0;\\n                }\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n               \\n                if(lvl>=1){\\n                  //   System.out.print(lvl+\" \");\\n                     if(curr.left!=null){\\n                          \\n                        curr.left.val=l.get(lvl+1)-sum1;\\n                     }\\n                    if(curr.right!=null){\\n                        curr.right.val=l.get(lvl+1)-sum1;\\n                     }\\n                }\\n            }\\n            \\n            \\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        List<Integer> l=new ArrayList<>();\\n        l.add(root.val);\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            int sum1=0;\\n            while(size-->0){\\n                TreeNode curr=q.poll();\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n            }\\n            l.add(sum1);\\n            \\n        }\\n       \\n        q.clear();\\n        q.add(root);\\n        int lvl=-1;\\n        while(!q.isEmpty()){\\n            lvl++;\\n            int size=q.size();\\n            \\n            while(size-->0){\\n                int sum1=0;\\n                TreeNode curr=q.poll();\\n                if(lvl==0 || lvl==1){\\n                    curr.val=0;\\n                }\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n               \\n                if(lvl>=1){\\n                  //   System.out.print(lvl+\" \");\\n                     if(curr.left!=null){\\n                          \\n                        curr.left.val=l.get(lvl+1)-sum1;\\n                     }\\n                    if(curr.right!=null){\\n                        curr.right.val=l.get(lvl+1)-sum1;\\n                     }\\n                }\\n            }\\n            \\n            \\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420230,
                "title": "explained-simple-and-clear-python-code",
                "content": "# Intuition\\nTo replace the value of each node in the tree with the sum of all its cousins\\' values, we first need to find the sum of each level of the tree. We can then use a DFS approach to traverse the tree and replace the value of each node with the sum of its cousins\\' values.\\n\\n\\n# Approach\\nWe will start by defining a function level_sum to calculate the sum of each level of the tree. This function will use BFS to traverse the tree level by level and store the sum of each level in a list.\\n\\nNext, we will create a copy of the original tree using the copy_tree function. This is because we don\\'t want to modify the original tree.\\n\\nFinally, we will use a DFS approach to traverse the tree and replace the value of each node with the sum of its cousins\\' values. We will pass the parent node and the level of the current node to the DFS function so that we can identify the cousins of the current node. We will also pass a copy of the copied tree to the DFS function, which we will modify as we traverse the tree.\\n\\nIn the DFS function, we will calculate the sum of the current level using the levels_sum list that we calculated earlier. We will then calculate the value of the current node based on the value of its parent and its cousins. We will then recursively call the DFS function on the left and right child of the current node.\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm is O(N), where N is the number of nodes in the tree. This is because we need to traverse the entire tree once to calculate the sum of each level and once again to replace the value of each node.\\n- Space complexity:\\nThe space complexity of this algorithm is O(N), where N is the number of nodes in the tree. This is because we need to store the sum of each level in a list, which can take up to N/2 space in the worst case (when the tree is a complete binary tree). Additionally, the recursive call stack can also take up to N space in the worst case.\\n# Code\\n```\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        def level_sum(root):\\n            if not root:\\n                return []\\n\\n            result = []\\n            queue = [root]\\n\\n            while queue:\\n                current_level_sum = 0\\n                level_size = len(queue)\\n\\n                for _ in range(level_size):\\n                    node = queue.pop(0)\\n                    current_level_sum += node.val\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n\\n                result.append(current_level_sum)\\n\\n            return result\\n\\n        levels_sum = level_sum(root)\\n        print(levels_sum)\\n\\n        def copy_tree(node):\\n            if node is None:\\n                return None\\n            new_node = TreeNode(node.val)\\n            new_node.left = copy_tree(node.left)\\n            new_node.right = copy_tree(node.right)\\n            return new_node\\n\\n        ans_tree = copy_tree(root)\\n\\n        def dfs(node, parent, level, ans):\\n            if node is None:\\n                return\\n            level_sum = levels_sum[level]\\n            if level < 2:\\n                ans.val = 0\\n            else:\\n                left_val = 0 if not parent.left else parent.left.val\\n                right_val = 0 if not parent.right else parent.right.val\\n                new_val = level_sum - left_val - right_val\\n                ans.val = new_val\\n            dfs(node.left, node, level+1, ans.left)\\n            dfs(node.right, node, level+1, ans.right)\\n\\n        dfs(root, None, 0, ans_tree)\\n        return ans_tree\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        def level_sum(root):\\n            if not root:\\n                return []\\n\\n            result = []\\n            queue = [root]\\n\\n            while queue:\\n                current_level_sum = 0\\n                level_size = len(queue)\\n\\n                for _ in range(level_size):\\n                    node = queue.pop(0)\\n                    current_level_sum += node.val\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n\\n                result.append(current_level_sum)\\n\\n            return result\\n\\n        levels_sum = level_sum(root)\\n        print(levels_sum)\\n\\n        def copy_tree(node):\\n            if node is None:\\n                return None\\n            new_node = TreeNode(node.val)\\n            new_node.left = copy_tree(node.left)\\n            new_node.right = copy_tree(node.right)\\n            return new_node\\n\\n        ans_tree = copy_tree(root)\\n\\n        def dfs(node, parent, level, ans):\\n            if node is None:\\n                return\\n            level_sum = levels_sum[level]\\n            if level < 2:\\n                ans.val = 0\\n            else:\\n                left_val = 0 if not parent.left else parent.left.val\\n                right_val = 0 if not parent.right else parent.right.val\\n                new_val = level_sum - left_val - right_val\\n                ans.val = new_val\\n            dfs(node.left, node, level+1, ans.left)\\n            dfs(node.right, node, level+1, ans.right)\\n\\n        dfs(root, None, 0, ans_tree)\\n        return ans_tree\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419999,
                "title": "explanation-inplace-simple-bfs-queue-time-o-n",
                "content": "# Approach\\nTop 3 nodes have no cousins, they will be 0. Use queue for BFS level order traversal. For a queue $\\\\{a_1,a_2,a_3\\\\}$, calculate the total sum of their next level. Then again traverse on **same** nodes ($\\\\{a_1,a_2,a_3\\\\}$) and change their children\\'s values, and push children to queue for next level order traversal.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        int total, currSum;\\n        TreeNode* curr;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val = 0;\\n        while (!q.empty()) {\\n            total = 0;\\n            for (int i = q.size(); i > 0; i--) {\\n                curr = q.front(); q.pop();\\n                total += (curr->left ? curr->left->val : 0) + (curr->right ? curr->right->val : 0);\\n                q.push(curr);\\n            }\\n            for (int i = q.size(); i > 0; i--) {\\n                curr = q.front(); q.pop();\\n                currSum = (curr->left ? curr->left->val : 0) + (curr->right ? curr->right->val : 0);\\n                if (curr->left) {\\n                    curr->left->val = total - currSum;\\n                    q.push(curr->left);\\n                }\\n                if (curr->right) {\\n                    curr->right->val = total - currSum;\\n                    q.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        int total, currSum;\\n        TreeNode* curr;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val = 0;\\n        while (!q.empty()) {\\n            total = 0;\\n            for (int i = q.size(); i > 0; i--) {\\n                curr = q.front(); q.pop();\\n                total += (curr->left ? curr->left->val : 0) + (curr->right ? curr->right->val : 0);\\n                q.push(curr);\\n            }\\n            for (int i = q.size(); i > 0; i--) {\\n                curr = q.front(); q.pop();\\n                currSum = (curr->left ? curr->left->val : 0) + (curr->right ? curr->right->val : 0);\\n                if (curr->left) {\\n                    curr->left->val = total - currSum;\\n                    q.push(curr->left);\\n                }\\n                if (curr->right) {\\n                    curr->right->val = total - currSum;\\n                    q.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421153,
                "title": "c-bfs-map",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    #define ll long long\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<ll,ll>m;\\n        map<pair<ll,TreeNode*>,ll>p;\\n        queue<pair<TreeNode*,TreeNode*>>q,z;\\n        q.push({root,NULL});\\n        int d=0;\\n        while(q.size()){\\n            int k=q.size();\\n            for(int i=0;i<k;i++){\\n                auto x=q.front();\\n                TreeNode* par=x.second;\\n                TreeNode* act=x.first;\\n                q.pop();\\n                int t=0;\\n                if(par!=NULL)t=par->val;\\n                p[{d,par}]+=act->val;\\n                m[d]+=act->val;\\n                if(act->right!=NULL)q.push({act->right,act});\\n                 if(act->left!=NULL)q.push({act->left,act});\\n            }\\n            d++;\\n        }\\n        d=0;\\n\\n        z.push({root,NULL});\\n        while(z.size()){\\n        int k=z.size();\\n        for(int i=0;i<k;i++)\\n        {\\n            auto x=z.front().first;\\n            auto par=z.front().second;\\n            z.pop();\\n            x->val=m[d]-p[{d,par}];\\n             if(x->right!=NULL)z.push({x->right,x});\\n                 if(x->left!=NULL)z.push({x->left,x});\\n        }\\n            d++;\\n        }\\n        return root;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/c9199d51-858a-4e57-84bc-fa74dc1282e2_1681590164.240952.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    #define ll long long\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<ll,ll>m;\\n        map<pair<ll,TreeNode*>,ll>p;\\n        queue<pair<TreeNode*,TreeNode*>>q,z;\\n        q.push({root,NULL});\\n        int d=0;\\n        while(q.size()){\\n            int k=q.size();\\n            for(int i=0;i<k;i++){\\n                auto x=q.front();\\n                TreeNode* par=x.second;\\n                TreeNode* act=x.first;\\n                q.pop();\\n                int t=0;\\n                if(par!=NULL)t=par->val;\\n                p[{d,par}]+=act->val;\\n                m[d]+=act->val;\\n                if(act->right!=NULL)q.push({act->right,act});\\n                 if(act->left!=NULL)q.push({act->left,act});\\n            }\\n            d++;\\n        }\\n        d=0;\\n\\n        z.push({root,NULL});\\n        while(z.size()){\\n        int k=z.size();\\n        for(int i=0;i<k;i++)\\n        {\\n            auto x=z.front().first;\\n            auto par=z.front().second;\\n            z.pop();\\n            x->val=m[d]-p[{d,par}];\\n             if(x->right!=NULL)z.push({x->right,x});\\n                 if(x->left!=NULL)z.push({x->left,x});\\n        }\\n            d++;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422435,
                "title": "simple-approach-by-using-bfs-and-taking-sum-of-child-explanation-with-visualization",
                "content": "#### **Cousins in Binary Tree II**\\n\\n**Topic:** Binary Tree, DFS/BFS\\n**Hints1:** Find sum of values level wise\\n**Hints2:** Store the child sum of each node\\n\\nEssentially, this question can be divided into two distinct parts.\\n\\n##### **First Part:** Construct Required Things (level_wise_sum+child_sum)\\nIn this part, we need to store the level wise sum as well as child sum of each node. Here we can maintain the Map for storing the data that we need in future. \\n\\nThis code performs a BFS traversal of a binary tree and calculates the level wise sum of node values and the sum of child node values for each node. The code uses a queue to store nodes in the order they need to be processed, and a map to store the sums. During the traversal, for each node, the code adds the node value to the level wise sum and calculates the sum of child node values. The sum of child node values is stored in a map with the node pointer as the key.\\n\\n##### **Example:** \\n<img src=\"https://assets.leetcode.com/users/images/ea37b32e-7907-449d-abdc-c1bdb8bf8c66_1681625217.5710294.jpeg\" width=\"30%\"> <img src=\"https://assets.leetcode.com/users/images/a95d08c7-32a6-440d-92ee-e23074b9cccf_1681625269.7894928.jpeg\" width=\"30%\"> <img src=\"https://assets.leetcode.com/users/images/9093dfe5-4d53-4871-b714-e5b2554ab102_1681625306.391535.jpeg\" width=\"30%\">\\n\\n\\n##### **Second Part:** Final Answer prepare, modify the given Tree\\nTo determine if there are cousins of a given node in the binary tree, we can traverse the tree using either BFS or DFS. If the level_wise_sum value for a level is greater than the child_sum value stored in the parent node, then there must be at least one cousin node present in that level. In this case, we can remove the child_sum value from the level_wise_sum to calculate the sum of the cousin nodes. If the level_wise_sum value for a level is not greater than the child_sum value, then there are no cousin nodes in that level, and we store 0 as the sum of cousin nodes.\\n\\nThis code uses a queue to perform a BFS traversal of a binary tree and determine the sum of cousin nodes for each node. The pen queue stores pairs of nodes along with their level for processing. For each node, the code calculates whether the level wise sum of the node is greater than the sum of its child nodes. If so, the code calculates the difference and assigns it to the current node value. If not, the code assigns 0 to the current node value. Finally, the code sets the value of the root node to 0 and returns the root.\\n\\n#### **Code:**\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //First Part (Construct Required things)\\n        \\n        //store the each level sum\\n        map<int,long long> level_wise_sum;\\n        //store the parent-> child sum\\n        map<TreeNode*,long long> child_sum;\\n        //create a queue for BFS\\n        queue<pair<TreeNode*,int>> pending;\\n        pending.push({root,0});\\n        \\n        while(pending.size()!=0){\\n            TreeNode* temp = pending.front().first; \\n            int lvl = pending.front().second;\\n            pending.pop();\\n            \\n            //Store the level wise sum\\n            level_wise_sum[lvl]+=temp->val;\\n            //Take a variable sum that stores the child sum\\n            long long sum = 0;\\n            if(temp->left!=NULL){\\n                sum+=temp->left->val;\\n                pending.push({temp->left,lvl+1});\\n            }\\n            if(temp->right!=NULL){\\n                sum+=temp->right->val;\\n                pending.push({temp->right,lvl+1});\\n            }\\n            //store the each node-> child sum\\n            child_sum[temp]=sum;\\n        }\\n        \\n        \\n        \\n        // Second Part (Final ans prepare)\\n        \\n        //Create a queue for BFS <parent-child> and store level\\n        queue<pair<pair<TreeNode*,TreeNode*>,int>> pen;\\n        pen.push({{root,root},0});\\n        while(pen.size()!=0){\\n            TreeNode* parent = pen.front().first.first; \\n            TreeNode* curr = pen.front().first.second;\\n            int lvl = pen.front().second;\\n            pen.pop();\\n            \\n            //Calculate greater or not, if yes then store the substraction \\n            if(level_wise_sum[lvl]>=child_sum[parent]){\\n                curr->val = level_wise_sum[lvl]-child_sum[parent];\\n            }else{\\n                curr->val = 0;\\n            }\\n            \\n            if(curr->left!=NULL) pen.push({{curr,curr->left},lvl+1});\\n            if(curr->right!=NULL) pen.push({{curr,curr->right},lvl+1});\\n            \\n            \\n        }\\n        \\n        // Parent root will be always 0\\n        root->val=0;\\n        return root;\\n        \\n        \\n    }\\n};\\n```\\n\\n<br>\\n\\n##### **If you like this explanation, feel free to upvote this discussion ^^**",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //First Part (Construct Required things)\\n        \\n        //store the each level sum\\n        map<int,long long> level_wise_sum;\\n        //store the parent-> child sum\\n        map<TreeNode*,long long> child_sum;\\n        //create a queue for BFS\\n        queue<pair<TreeNode*,int>> pending;\\n        pending.push({root,0});\\n        \\n        while(pending.size()!=0){\\n            TreeNode* temp = pending.front().first; \\n            int lvl = pending.front().second;\\n            pending.pop();\\n            \\n            //Store the level wise sum\\n            level_wise_sum[lvl]+=temp->val;\\n            //Take a variable sum that stores the child sum\\n            long long sum = 0;\\n            if(temp->left!=NULL){\\n                sum+=temp->left->val;\\n                pending.push({temp->left,lvl+1});\\n            }\\n            if(temp->right!=NULL){\\n                sum+=temp->right->val;\\n                pending.push({temp->right,lvl+1});\\n            }\\n            //store the each node-> child sum\\n            child_sum[temp]=sum;\\n        }\\n        \\n        \\n        \\n        // Second Part (Final ans prepare)\\n        \\n        //Create a queue for BFS <parent-child> and store level\\n        queue<pair<pair<TreeNode*,TreeNode*>,int>> pen;\\n        pen.push({{root,root},0});\\n        while(pen.size()!=0){\\n            TreeNode* parent = pen.front().first.first; \\n            TreeNode* curr = pen.front().first.second;\\n            int lvl = pen.front().second;\\n            pen.pop();\\n            \\n            //Calculate greater or not, if yes then store the substraction \\n            if(level_wise_sum[lvl]>=child_sum[parent]){\\n                curr->val = level_wise_sum[lvl]-child_sum[parent];\\n            }else{\\n                curr->val = 0;\\n            }\\n            \\n            if(curr->left!=NULL) pen.push({{curr,curr->left},lvl+1});\\n            if(curr->right!=NULL) pen.push({{curr,curr->right},lvl+1});\\n            \\n            \\n        }\\n        \\n        // Parent root will be always 0\\n        root->val=0;\\n        return root;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420410,
                "title": "simply-the-bfs-way",
                "content": "**Time** O(n)\\n**Space** O(n+n)\\n\\n**Explanation**\\nEach node we need:\\ntotal childsum of the level\\nparent\\'s child sum\\nso putting in map with parent and childsum of parent\\nnode.val = (totalchildsum of prevlevel - parent\\'s child sum)\\n\\nPlease do dry run on test case\\n```\\nclass Solution {\\n    class Pair{\\n        TreeNode node;\\n        TreeNode parent;\\n        public Pair(TreeNode n, TreeNode p){\\n            node = n;\\n            parent = p;\\n        }\\n    }\\n    \\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        // same depth diff parent\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(root, null));\\n        \\n        int curLevelChildSum = 0;\\n        Map<TreeNode, Integer> map = new HashMap<>();       // storing parent : childsum   \\n        \\n        while(!q.isEmpty()){\\n           \\n            \\n            int lastLevelChildSum = curLevelChildSum;    // prevsum = cursum\\n            curLevelChildSum = 0;   // reset cursum\\n            \\n            int size = q.size();\\n            \\n            while(size-- > 0){\\n                Pair front = q.poll();\\n                \\n                TreeNode node = front.node;\\n                TreeNode par = front.parent;\\n\\n                int childsum = 0; \\n                // left\\n                if(node.left != null){\\n                    q.add(new Pair(node.left, node));\\n                    childsum += node.left.val;\\n                }\\n                // right\\n                if(node.right != null){\\n                    q.add(new Pair(node.right, node));\\n                    childsum += node.right.val;\\n                }\\n                \\n                // put value in map\\n                map.put(node, childsum);\\n                \\n                curLevelChildSum += childsum;\\n                \\n                node.val = lastLevelChildSum - map.getOrDefault(par, 0);  // get(par) gives me childsum of this node\\'s parent\\n            }\\n            \\n        }\\n        \\n        return root;\\n    }\\n}\\n```\\n\\nUpvote Kardo Yr !",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        TreeNode node;\\n        TreeNode parent;\\n        public Pair(TreeNode n, TreeNode p){\\n            node = n;\\n            parent = p;\\n        }\\n    }\\n    \\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        // same depth diff parent\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(root, null));\\n        \\n        int curLevelChildSum = 0;\\n        Map<TreeNode, Integer> map = new HashMap<>();       // storing parent : childsum   \\n        \\n        while(!q.isEmpty()){\\n           \\n            \\n            int lastLevelChildSum = curLevelChildSum;    // prevsum = cursum\\n            curLevelChildSum = 0;   // reset cursum\\n            \\n            int size = q.size();\\n            \\n            while(size-- > 0){\\n                Pair front = q.poll();\\n                \\n                TreeNode node = front.node;\\n                TreeNode par = front.parent;\\n\\n                int childsum = 0; \\n                // left\\n                if(node.left != null){\\n                    q.add(new Pair(node.left, node));\\n                    childsum += node.left.val;\\n                }\\n                // right\\n                if(node.right != null){\\n                    q.add(new Pair(node.right, node));\\n                    childsum += node.right.val;\\n                }\\n                \\n                // put value in map\\n                map.put(node, childsum);\\n                \\n                curLevelChildSum += childsum;\\n                \\n                node.val = lastLevelChildSum - map.getOrDefault(par, 0);  // get(par) gives me childsum of this node\\'s parent\\n            }\\n            \\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427535,
                "title": "simple-solution-bfs-o-n-time-o-n-space-comment-explained-cousins-in-binary-tree-ii",
                "content": "# Intuition\\n1. Initialize a queue and enqueue the root node with level -1.\\n2. Set the values of the root and its children to 0.\\n3. While the queue is not empty:\\na. Dequeue a node and its level from the front of the queue.\\nb. If the level is greater than 0 (i.e., the node is not at the root level):\\ni. Update the node value to the difference between the sum at the current level and the sum of its children.\\nc. Enqueue the node\\'s children along with their sum.\\nd. Update the sum at the current level.\\nReturn the root node.\\n\\n# Approach\\nWe can use a level-order traversal (BFS) to traverse the binary tree and update the node values.\\n\\nFor each node that we visit, we need to compute the sum of the values of its cousins. We can keep track of the sum of the values of the nodes at the current level by maintaining a sum variable. For each node at the current level, we add the values of its children to the sum and enqueue the children along with their sum. When we encounter a node at the next level, we update its value to the difference between the sum and the sum of its children.\\n\\nTo keep track of the level of each node, we can enqueue a pair containing the node and its level instead of just the node.\\n\\nWe also need to initialize the values of the root node and its children to 0.\\n\\n# Complexity\\n- **Time complexity:** We traverse each node of the tree once, so the time complexity is O(n), where n is the number of nodes in the tree.\\n\\n\\n- **Space complexity:**  Since we are using a queue data structure so space complexity is: O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n    \\n        queue<pair<TreeNode*, int>> q; // make a queue which will store the node and will also store node\\'s children sum;\\n        int temp,k=0;\\n        q.push({root, -1}); //Since first node so will push -1 for sum\\n        root->val=0;\\n\\n        // Considering tree starts form level 1\\n        // for 2nd level since only 2 roots and have same parent so we will always push 0 for both the childs\\n        if(root->left)\\n            root->left->val=0;\\n        if(root->right)\\n            root->right->val=0;\\n\\n        while(!q.empty())\\n        {\\n            int s=q.size(); //current queue size\\n            int sum=0;\\n            k++;\\n\\n            //iterating through the current size of queue\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode* t=q.front().first;\\n                int psum=q.front().second;\\n                q.pop();\\n                int cs=0;\\n\\n                if(k>1)  // since we have already pushed 0,0 for 2nd level so we are ignoring for 2nd level\\n                    t->val=temp-psum;\\n                if(t->left)\\n                    cs=cs+t->left->val;\\n                if(t->right)\\n                    cs=cs+t->right->val;\\n\\n                sum+=cs;       // sum is carrying the total sum a level node\\'s value\\n                if(t->left)\\n                    q.push({t->left, cs});\\n                if(t->right)\\n                    q.push({t->right, cs});\\n            }\\n            temp=sum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n    \\n        queue<pair<TreeNode*, int>> q; // make a queue which will store the node and will also store node\\'s children sum;\\n        int temp,k=0;\\n        q.push({root, -1}); //Since first node so will push -1 for sum\\n        root->val=0;\\n\\n        // Considering tree starts form level 1\\n        // for 2nd level since only 2 roots and have same parent so we will always push 0 for both the childs\\n        if(root->left)\\n            root->left->val=0;\\n        if(root->right)\\n            root->right->val=0;\\n\\n        while(!q.empty())\\n        {\\n            int s=q.size(); //current queue size\\n            int sum=0;\\n            k++;\\n\\n            //iterating through the current size of queue\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode* t=q.front().first;\\n                int psum=q.front().second;\\n                q.pop();\\n                int cs=0;\\n\\n                if(k>1)  // since we have already pushed 0,0 for 2nd level so we are ignoring for 2nd level\\n                    t->val=temp-psum;\\n                if(t->left)\\n                    cs=cs+t->left->val;\\n                if(t->right)\\n                    cs=cs+t->right->val;\\n\\n                sum+=cs;       // sum is carrying the total sum a level node\\'s value\\n                if(t->left)\\n                    q.push({t->left, cs});\\n                if(t->right)\\n                    q.push({t->right, cs});\\n            }\\n            temp=sum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420260,
                "title": "c-single-bfs-no-extra-space",
                "content": "Time complexity- O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n         q.push(root);\\n        vector<int> v;\\n        int ans=root->val;\\n        while(!q.empty()){\\n            int sz=q.size(); int sum=0;\\n            for(int i=0;i<sz;i++){\\n                auto p=q.front(); q.pop();\\n                p->val=ans-p->val;\\n                if(p->left){  q.push(p->left); sum+=p->left->val; }\\n                if(p->right) { q.push(p->right); sum+=p->right->val; }\\n                if(p->left&&p->right){\\n                    int x=p->right->val+p->left->val;\\n                    p->left->val=x;\\n                    p->right->val=x;\\n                }\\n            }\\n            ans=sum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n         q.push(root);\\n        vector<int> v;\\n        int ans=root->val;\\n        while(!q.empty()){\\n            int sz=q.size(); int sum=0;\\n            for(int i=0;i<sz;i++){\\n                auto p=q.front(); q.pop();\\n                p->val=ans-p->val;\\n                if(p->left){  q.push(p->left); sum+=p->left->val; }\\n                if(p->right) { q.push(p->right); sum+=p->right->val; }\\n                if(p->left&&p->right){\\n                    int x=p->right->val+p->left->val;\\n                    p->left->val=x;\\n                    p->right->val=x;\\n                }\\n            }\\n            ans=sum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420221,
                "title": "level-order-traversal-and-then-dfs-hashmap",
                "content": "# Intuition\\nConsider a node, $$node$$. Another node, $$cousin$$ is that node which is on the same level/depth as $$node$$ but has a different (immediate) parent than $$node$$ does.\\n \\nWe need to find the sum of values of all the cousins for a given node, a simpler problem would be to first calculate the sum of all nodes at a given level(**Level Order Traversal**), and then subtract something to this value. That value is nothing but the sum of the value of current Node, and it\\'s sibling. \\nConsider the tree: \\n![image.png](https://assets.leetcode.com/users/images/e232ce90-dd2f-4bbe-8c8b-d8af60a63676_1681574863.7901134.png) \\n\\nFor $$1$$, the value is:\\n```\\nRequired value for node with value 1:\\n Sum of the values of every node at that level - (1+10)\\n-\\n```\\nOr simply, take the node with value **4**, keep track of the sum of it\\'s children, $$(1+10)$$, and use that to calculate their modified value. This can be done using a dfs\\n\\n# Approach\\nWe create two Hash Tables, one for:\\n# Level Sum = Sum of all the node values at a given level\\n# Parent Sum= For a given node, the sum of values of all its children(only **root.left and root.right**, or upto 1 level lower. )\\n\\n\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        HashMap<TreeNode,Integer> map = new HashMap<>();\\n        ArrayDeque<TreeNode> q= new ArrayDeque<>();\\n        q.add(root);\\n        HashMap<Integer,Integer> level = new HashMap<>(); \\n        int l=0; //variable for level.\\n        \\n        while(!q.isEmpty()){\\n            int tsize=q.size();\\n            l++;\\n            int levelsum=0;\\n            while(tsize-- >0 ){\\n                TreeNode node = q.removeFirst(); \\n                //maintaining level sum:\\n                levelsum+=node.val;\\n\\n                //Computing sum of children:\\n                int lsum=node.left==null?0:node.left.val;\\n                int rsum=node.right==null?0:node.right.val;\\n                map.put(node,lsum+rsum);\\n\\n\\n                if(node.left!=null) q.addLast(node.left);\\n                if(node.right!=null) q.addLast(node.right);\\n            }\\n            level.put(l,levelsum); //set the sum value for current level\\n            \\n        }\\n        //update node values in a pre-order traversal\\n        //keeping track of the parent for every node.\\n        f(root,null,1,map,level);\\n        root.val=0;\\n        return root;\\n        \\n    }\\n    public void f(TreeNode root,TreeNode parent,int lev, HashMap<TreeNode,Integer> map,HashMap<Integer,Integer> level ){\\n        if(root==null) return;\\n        int psum= map.getOrDefault(parent,0);\\n        int lsum=level.get(lev);\\n        root.val=lsum-psum;\\n        f(root.left,root,lev+1,map,level);\\n        f(root.right,root,lev+1,map,level);\\n\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nRequired value for node with value 1:\\n Sum of the values of every node at that level - (1+10)\\n-\\n```\n```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        HashMap<TreeNode,Integer> map = new HashMap<>();\\n        ArrayDeque<TreeNode> q= new ArrayDeque<>();\\n        q.add(root);\\n        HashMap<Integer,Integer> level = new HashMap<>(); \\n        int l=0; //variable for level.\\n        \\n        while(!q.isEmpty()){\\n            int tsize=q.size();\\n            l++;\\n            int levelsum=0;\\n            while(tsize-- >0 ){\\n                TreeNode node = q.removeFirst(); \\n                //maintaining level sum:\\n                levelsum+=node.val;\\n\\n                //Computing sum of children:\\n                int lsum=node.left==null?0:node.left.val;\\n                int rsum=node.right==null?0:node.right.val;\\n                map.put(node,lsum+rsum);\\n\\n\\n                if(node.left!=null) q.addLast(node.left);\\n                if(node.right!=null) q.addLast(node.right);\\n            }\\n            level.put(l,levelsum); //set the sum value for current level\\n            \\n        }\\n        //update node values in a pre-order traversal\\n        //keeping track of the parent for every node.\\n        f(root,null,1,map,level);\\n        root.val=0;\\n        return root;\\n        \\n    }\\n    public void f(TreeNode root,TreeNode parent,int lev, HashMap<TreeNode,Integer> map,HashMap<Integer,Integer> level ){\\n        if(root==null) return;\\n        int psum= map.getOrDefault(parent,0);\\n        int lsum=level.get(lev);\\n        root.val=lsum-psum;\\n        f(root.left,root,lev+1,map,level);\\n        f(root.right,root,lev+1,map,level);\\n\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420085,
                "title": "simple-level-order-traversal-dfs",
                "content": "# Approach\\n- Used two hash table to store sum of each level and child sum to it\\'s parent respectively.\\n- then update current node value with the entire sum of that level minus parentSum of current node.\\n\\n# Complexity\\nWhere N is number of Nodes\\n- Time O(N)\\n- Space O(N)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def replaceValueInTree(self, root):\\n        def dfs(root, parent, lvl):\\n            if not root: return\\n            parentSum[parent] += root.val\\n            levelSum[lvl] += root.val\\n            dfs(root.left, root, lvl + 1)\\n            dfs(root.right, root, lvl + 1)\\n\\n        levelSum = defaultdict(int)\\n        parentSum = defaultdict(int)\\n        dfs(root, None, 0)\\n        queue = [[root, None, 0]]\\n        while queue:\\n            for _ in range(len(queue)):\\n                node, parent, lvl = queue.pop(0)\\n                sum_ = levelSum[lvl] - parentSum[parent]\\n                node.val = sum_\\n                if node.left: queue.append([node.left, node, lvl + 1])\\n                if node.right: queue.append([node.right, node, lvl + 1])\\n        return root\\n```\\nUpVote, if you like it **:)**",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def replaceValueInTree(self, root):\\n        def dfs(root, parent, lvl):\\n            if not root: return\\n            parentSum[parent] += root.val\\n            levelSum[lvl] += root.val\\n            dfs(root.left, root, lvl + 1)\\n            dfs(root.right, root, lvl + 1)\\n\\n        levelSum = defaultdict(int)\\n        parentSum = defaultdict(int)\\n        dfs(root, None, 0)\\n        queue = [[root, None, 0]]\\n        while queue:\\n            for _ in range(len(queue)):\\n                node, parent, lvl = queue.pop(0)\\n                sum_ = levelSum[lvl] - parentSum[parent]\\n                node.val = sum_\\n                if node.left: queue.append([node.left, node, lvl + 1])\\n                if node.right: queue.append([node.right, node, lvl + 1])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444565,
                "title": "level-order-c-easy-explanation",
                "content": "# Approach\\n   1. Find the sum at each level and store it in the map with depth as key and sum as pair\\n   2. Then to  a current Node the cousin sum for its each child Nodes will be (level sum of its children) - (sum of it\\'s childrent)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n         // Initialize a map to store the sum of nodes at each level\\n         map<int, int> mp;\\n       \\n         queue<TreeNode*>q;\\n       \\n         q.push(root);\\n       \\n         int depth = 0;\\n      \\n         while(!q.empty()){\\n             int l = q.size();\\n             int ans = 0;\\n      \\n             for(int i = 0;i<l;i++){\\n                 // Get the current node from the front of the queue\\n                 TreeNode* curr = q.front();\\n                 q.pop();\\n                 \\n                 ans+= curr->val;\\n                \\n                 if(curr->left) q.push(curr->left);\\n                 if(curr->right) q.push(curr->right);\\n             }\\n           \\n             mp[depth++] = ans;\\n         }\\n\\n         // Reset the depth to 0 and push the root node onto the queue again\\n         depth = 0;\\n         root->val = 0;\\n         q.push(root);\\n\\n         // Traverse the tree level by level again\\n         while(!q.empty()){\\n             int l = q.size();\\n             // Iterate through each node at the current level\\n             for(int i = 0;i<l;i++){\\n                // Get the current node from the front of the queue\\n                TreeNode* currNode = q.front();\\n                q.pop();\\n                // Get the sum of nodes at the next level\\n                int SumOfNextLevel = mp[depth+1];\\n                // Subtract the sum of the current node\\'s children from the sum of nodes at the next level\\n                if(currNode->left) SumOfNextLevel-= currNode->left->val;\\n                if(currNode->right) SumOfNextLevel-= currNode->right->val;\\n                // Set the current node\\'s value to the sum of its cousins\\n               \\n                if(currNode->left) {\\n                currNode->left->val = SumOfNextLevel;\\n                q.push(currNode->left);\\n                }\\n\\n                if(currNode->right) {\\n                currNode->right->val = SumOfNextLevel;\\n                q.push(currNode->right);\\n               }\\n             }\\n            \\n             depth++;\\n         }\\n         \\n         \\n         return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n         // Initialize a map to store the sum of nodes at each level\\n         map<int, int> mp;\\n       \\n         queue<TreeNode*>q;\\n       \\n         q.push(root);\\n       \\n         int depth = 0;\\n      \\n         while(!q.empty()){\\n             int l = q.size();\\n             int ans = 0;\\n      \\n             for(int i = 0;i<l;i++){\\n                 // Get the current node from the front of the queue\\n                 TreeNode* curr = q.front();\\n                 q.pop();\\n                 \\n                 ans+= curr->val;\\n                \\n                 if(curr->left) q.push(curr->left);\\n                 if(curr->right) q.push(curr->right);\\n             }\\n           \\n             mp[depth++] = ans;\\n         }\\n\\n         // Reset the depth to 0 and push the root node onto the queue again\\n         depth = 0;\\n         root->val = 0;\\n         q.push(root);\\n\\n         // Traverse the tree level by level again\\n         while(!q.empty()){\\n             int l = q.size();\\n             // Iterate through each node at the current level\\n             for(int i = 0;i<l;i++){\\n                // Get the current node from the front of the queue\\n                TreeNode* currNode = q.front();\\n                q.pop();\\n                // Get the sum of nodes at the next level\\n                int SumOfNextLevel = mp[depth+1];\\n                // Subtract the sum of the current node\\'s children from the sum of nodes at the next level\\n                if(currNode->left) SumOfNextLevel-= currNode->left->val;\\n                if(currNode->right) SumOfNextLevel-= currNode->right->val;\\n                // Set the current node\\'s value to the sum of its cousins\\n               \\n                if(currNode->left) {\\n                currNode->left->val = SumOfNextLevel;\\n                q.push(currNode->left);\\n                }\\n\\n                if(currNode->right) {\\n                currNode->right->val = SumOfNextLevel;\\n                q.push(currNode->right);\\n               }\\n             }\\n            \\n             depth++;\\n         }\\n         \\n         \\n         return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423474,
                "title": "bfs-and-dfs-java-solution",
                "content": "# Intuition\\nBFS , DFS\\n\\n# Approach\\n- First of All , traverse to every level and store the sum of every element of that level in a list.\\n- To store the level sum , we have created a method levelsum.\\n- Now traverse to every node again and if it has both child then put them in a map first child node as a key and its brother\\'s val as a value and vice-versa.\\n- For this, process there is a method called getRealBrothers.\\n- Now , do simple DFS to modify the values of every node.\\n- For this, just traverse to every node and if there exists it\\'s real brother then just substract it\\'s value and also it\\'s real brother\\'s value from the current level sum and modify the value of that node to the value you have got in the end after the substraction.\\n- Now you have the required modified tree.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void levelsum(TreeNode root,List<Integer>list){\\n        if(root==null) return;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        q.add(null);\\n        while(!q.isEmpty()){\\n            int sum = 0;\\n            while(q.peek()!=null){\\n               sum += q.peek().val;\\n               if(q.peek().left!=null) q.add(q.peek().left);\\n               if(q.peek().right!=null) q.add(q.peek().right);\\n               q.poll();\\n            }\\n            q.poll();\\n            list.add(sum);\\n            if(q.size()>0)  q.add(null);\\n        }\\n    }\\n    public void getRealBrothers(TreeNode root,HashMap<TreeNode,Integer> map){\\n        if(root==null) return;\\n        if(root.left != null && root.right != null){\\n            map.putIfAbsent(root.left,root.right.val);\\n            map.putIfAbsent(root.right,root.left.val);\\n        }\\n        getRealBrothers(root.left,map);\\n        getRealBrothers(root.right,map);\\n    }\\n    public void dfs(TreeNode root,HashMap<TreeNode,Integer> map,List<Integer>list,int level){\\n        if(root==null) return;\\n        int sum = map.containsKey(root)?map.get(root):0;\\n        root.val = list.get(level)-sum-root.val;\\n        dfs(root.left,map,list,level+1);\\n        dfs(root.right,map,list,level+1);\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        HashMap<TreeNode,Integer> map = new HashMap<>();\\n        levelsum(root,list);\\n        getRealBrothers(root,map);\\n        dfs(root,map,list,0);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void levelsum(TreeNode root,List<Integer>list){\\n        if(root==null) return;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        q.add(null);\\n        while(!q.isEmpty()){\\n            int sum = 0;\\n            while(q.peek()!=null){\\n               sum += q.peek().val;\\n               if(q.peek().left!=null) q.add(q.peek().left);\\n               if(q.peek().right!=null) q.add(q.peek().right);\\n               q.poll();\\n            }\\n            q.poll();\\n            list.add(sum);\\n            if(q.size()>0)  q.add(null);\\n        }\\n    }\\n    public void getRealBrothers(TreeNode root,HashMap<TreeNode,Integer> map){\\n        if(root==null) return;\\n        if(root.left != null && root.right != null){\\n            map.putIfAbsent(root.left,root.right.val);\\n            map.putIfAbsent(root.right,root.left.val);\\n        }\\n        getRealBrothers(root.left,map);\\n        getRealBrothers(root.right,map);\\n    }\\n    public void dfs(TreeNode root,HashMap<TreeNode,Integer> map,List<Integer>list,int level){\\n        if(root==null) return;\\n        int sum = map.containsKey(root)?map.get(root):0;\\n        root.val = list.get(level)-sum-root.val;\\n        dfs(root.left,map,list,level+1);\\n        dfs(root.right,map,list,level+1);\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        HashMap<TreeNode,Integer> map = new HashMap<>();\\n        levelsum(root,list);\\n        getRealBrothers(root,map);\\n        dfs(root,map,list,0);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422515,
                "title": "bsf-traversal-java-using-map-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        Map<TreeNode, List<Integer>> map = new HashMap<>();\\n        root.val = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int sum = 0;\\n            map = new HashMap<>();\\n            for(int i = 0; i < size; i++) {\\n                TreeNode cur = q.poll();\\n                map.put(cur, new ArrayList<>());\\n                if(cur.left != null) {\\n                    sum += cur.left.val;\\n                    q.add(cur.left);\\n                    map.get(cur).add(cur.left.val);\\n                }\\n                if(cur.right != null) {\\n                    sum += cur.right.val;\\n                    q.add(cur.right);\\n                    map.get(cur).add(cur.right.val);\\n                }\\n            }\\n            for(Map.Entry<TreeNode,List<Integer>> entry : map.entrySet()) {\\n                if(entry.getValue().size() == 2) {\\n                    int num = entry.getValue().get(0)+entry.getValue().get(1);\\n                    entry.getKey().left.val = sum - num;\\n                    entry.getKey().right.val = sum - num;\\n                } else if(entry.getValue().size() == 1) {\\n                    if(entry.getKey().left != null) entry.getKey().left.val = sum - entry.getValue().get(0);\\n                    else if(entry.getKey().right != null) entry.getKey().right.val = sum - entry.getValue().get(0);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        Map<TreeNode, List<Integer>> map = new HashMap<>();\\n        root.val = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int sum = 0;\\n            map = new HashMap<>();\\n            for(int i = 0; i < size; i++) {\\n                TreeNode cur = q.poll();\\n                map.put(cur, new ArrayList<>());\\n                if(cur.left != null) {\\n                    sum += cur.left.val;\\n                    q.add(cur.left);\\n                    map.get(cur).add(cur.left.val);\\n                }\\n                if(cur.right != null) {\\n                    sum += cur.right.val;\\n                    q.add(cur.right);\\n                    map.get(cur).add(cur.right.val);\\n                }\\n            }\\n            for(Map.Entry<TreeNode,List<Integer>> entry : map.entrySet()) {\\n                if(entry.getValue().size() == 2) {\\n                    int num = entry.getValue().get(0)+entry.getValue().get(1);\\n                    entry.getKey().left.val = sum - num;\\n                    entry.getKey().right.val = sum - num;\\n                } else if(entry.getValue().size() == 1) {\\n                    if(entry.getKey().left != null) entry.getKey().left.val = sum - entry.getValue().get(0);\\n                    else if(entry.getKey().right != null) entry.getKey().right.val = sum - entry.getValue().get(0);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420207,
                "title": "python3-simple-bfs",
                "content": "lets consider some node -> node X , \\nif node X has sibling then new value = (sum of level) - nodeX.val - (sibling of nodeX) , else new value =  (sum of level ) - nodeX.val . when storing child node in queue, check if it has sibling and if yes then store map[childnode] = (sibling node value)in hmap.\\n```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        dq = deque([root])\\n        hmap = {}\\n        total = 0\\n        while dq:\\n            size = len(dq)\\n            temp = 0\\n            for i in range(size):\\n                curr = dq.popleft()\\n                curr.val = max(0,total - curr.val - (hmap[curr] if curr in hmap else 0))\\n                if curr.left and curr.right:   \\n                    hmap[curr.left] = curr.right.val\\n                    hmap[curr.right] = curr.left.val\\n                    temp += curr.left.val + curr.right.val\\n                    dq.append(curr.left)\\n                    dq.append(curr.right)\\n                elif curr.right:\\n                    temp += curr.right.val\\n                    dq.append(curr.right)\\n                elif curr.left:\\n                    temp += curr.left.val\\n                    dq.append(curr.left)\\n            total = temp\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        dq = deque([root])\\n        hmap = {}\\n        total = 0\\n        while dq:\\n            size = len(dq)\\n            temp = 0\\n            for i in range(size):\\n                curr = dq.popleft()\\n                curr.val = max(0,total - curr.val - (hmap[curr] if curr in hmap else 0))\\n                if curr.left and curr.right:   \\n                    hmap[curr.left] = curr.right.val\\n                    hmap[curr.right] = curr.left.val\\n                    temp += curr.left.val + curr.right.val\\n                    dq.append(curr.left)\\n                    dq.append(curr.right)\\n                elif curr.right:\\n                    temp += curr.right.val\\n                    dq.append(curr.right)\\n                elif curr.left:\\n                    temp += curr.left.val\\n                    dq.append(curr.left)\\n            total = temp\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420196,
                "title": "c-level-order-traversal-easy-to-understand-code",
                "content": "````\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q1,q2;\\n        int n,d;\\n        TreeNode* node;\\n        q1.push(root);\\n        unordered_map<int,int> mp;\\n        int sum = 0;\\n        while(!q1.empty()){\\n            n = q1.size();\\n            sum = 0;\\n            q2 = q1;\\n            d = 0;\\n            mp.clear();\\n            while(n--){\\n                node = q1.front();\\n                q1.pop();\\n                if(node->left){\\n                    q1.push(node->left);\\n                    sum += node->left->val;\\n                    mp[d] += node->left->val;\\n                }\\n                if(node->right){\\n                    q1.push(node->right);\\n                    sum += node->right->val;\\n                    mp[d] += node->right->val;\\n                }\\n                d++;\\n            }\\n            \\n            n = q2.size();\\n            d = 0;\\n            while(n--){\\n                node = q2.front();\\n                q2.pop();\\n                if(node->left){\\n                    node->left->val = sum-mp[d];\\n                }\\n                if(node->right){\\n                    node->right->val = sum-mp[d];\\n                }\\n                d++;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q1,q2;\\n        int n,d;\\n        TreeNode* node;\\n        q1.push(root);\\n        unordered_map<int,int> mp;\\n        int sum = 0;\\n        while(!q1.empty()){\\n            n = q1.size();\\n            sum = 0;\\n            q2 = q1;\\n            d = 0;\\n            mp.clear();\\n            while(n--){\\n                node = q1.front();\\n                q1.pop();\\n                if(node->left){\\n                    q1.push(node->left);\\n                    sum += node->left->val;\\n                    mp[d] += node->left->val;\\n                }\\n                if(node->right){\\n                    q1.push(node->right);\\n                    sum += node->right->val;\\n                    mp[d] += node->right->val;\\n                }\\n                d++;\\n            }\\n            \\n            n = q2.size();\\n            d = 0;\\n            while(n--){\\n                node = q2.front();\\n                q2.pop();\\n                if(node->left){\\n                    node->left->val = sum-mp[d];\\n                }\\n                if(node->right){\\n                    node->right->val = sum-mp[d];\\n                }\\n                d++;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420195,
                "title": "simple-solution-maps-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, long long int> m; // To store the sum of the children \\n    vector<vector<TreeNode*>> depth; // to store the nodes at the given depth\\n    \\n    void dfs(TreeNode* root, int d){\\n        if(!root) return; \\n        if(depth.size()<d){\\n            depth.push_back({});\\n        }\\n        depth[d-1].push_back(root);\\n        long long int x = 0; \\n        \\n        if(root->right){\\n            x+=root->right->val; \\n            dfs(root->right, d+1); \\n        }\\n        if(root->left){ \\n            x+=root->left->val; \\n            dfs(root->left, d+1);\\n        } \\n        m[root] = x; \\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        dfs(root, 1); \\n        \\n        for(int i = depth.size()-1; i>=0; i--){\\n            long long int sum = 0; // sum is used to store the sum of all the nodes that are at depth same as that of child of j  \\n            for(auto &j:depth[i]){\\n                j->val =0; \\n                if(m[j]) sum+=m[j]; \\n            }\\n            // If there are children, then we can change their values. \\n            if(sum){\\n                for(auto &j:depth[i]){\\n                    // (sum-m[j]) gives us the sum value of the other nodes that are at the same depth as that of the children of j \\n                    \\n                    if(j->left){\\n                        j->left->val = sum - m[j]; \\n                    }\\n                    if(j->right){\\n                        j->right->val = sum - m[j]; \\n                    }\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, long long int> m; // To store the sum of the children \\n    vector<vector<TreeNode*>> depth; // to store the nodes at the given depth\\n    \\n    void dfs(TreeNode* root, int d){\\n        if(!root) return; \\n        if(depth.size()<d){\\n            depth.push_back({});\\n        }\\n        depth[d-1].push_back(root);\\n        long long int x = 0; \\n        \\n        if(root->right){\\n            x+=root->right->val; \\n            dfs(root->right, d+1); \\n        }\\n        if(root->left){ \\n            x+=root->left->val; \\n            dfs(root->left, d+1);\\n        } \\n        m[root] = x; \\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        dfs(root, 1); \\n        \\n        for(int i = depth.size()-1; i>=0; i--){\\n            long long int sum = 0; // sum is used to store the sum of all the nodes that are at depth same as that of child of j  \\n            for(auto &j:depth[i]){\\n                j->val =0; \\n                if(m[j]) sum+=m[j]; \\n            }\\n            // If there are children, then we can change their values. \\n            if(sum){\\n                for(auto &j:depth[i]){\\n                    // (sum-m[j]) gives us the sum value of the other nodes that are at the same depth as that of the children of j \\n                    \\n                    if(j->left){\\n                        j->left->val = sum - m[j]; \\n                    }\\n                    if(j->right){\\n                        j->right->val = sum - m[j]; \\n                    }\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420168,
                "title": "2-dfs-solution",
                "content": "# Intuition\\nUse DFS\\n\\n# Approach\\nDuring first DFS calculate sum of nodes on each level and store initial node value for every node.\\nDuring second DFS for every node:\\n1. Get node parent\\n2. Get both children of the current node parent.\\n3. Get total sum for node level\\n4. Extract sum of parent both child from total level sum.\\n5. Set this value as new value for the node.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\n\\nlet levelSums\\nlet nodeValues\\nlet parents\\nvar replaceValueInTree = function(root) {\\n    levelSums = new Map()\\n    nodeValues = new Map()\\n    parents = new Map()\\n    \\n    dfs1(root, 0, null)\\n    console.log(levelSums)\\n    dfs2(root, 0, null)\\n    \\n    return root\\n    \\n};\\n\\nfunction dfs1(node, level, parent){\\n    if(node == null){\\n        return\\n    }\\n    nodeValues.set(node, node.val)\\n    \\n    if(!levelSums.has(level)){\\n        levelSums.set(level, 0)\\n    }\\n    \\n    levelSums.set(level, node.val + levelSums.get(level))\\n    dfs1(node.left, level + 1, node)\\n    \\n    dfs1(node.right, level + 1, node)\\n    \\n    \\n}\\n\\nfunction dfs2(node, level, parent){\\n    if(node == null){\\n        return\\n    }\\n    if(parent == null){\\n        node.val = 0;\\n       \\n    } else{\\n\\n        let sum = levelSums.get(level);\\n        let left = parent.left\\n        let right = parent.right\\n\\n        if(left){\\n\\n            sum -= nodeValues.get(left)\\n        }\\n        if(right){\\n            sum -= nodeValues.get(right)\\n        }\\n\\n        node.val = sum;\\n    }\\n    \\n    dfs2(node.left, level+1, node)\\n    dfs2(node.right, level+1, node)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\n\\nlet levelSums\\nlet nodeValues\\nlet parents\\nvar replaceValueInTree = function(root) {\\n    levelSums = new Map()\\n    nodeValues = new Map()\\n    parents = new Map()\\n    \\n    dfs1(root, 0, null)\\n    console.log(levelSums)\\n    dfs2(root, 0, null)\\n    \\n    return root\\n    \\n};\\n\\nfunction dfs1(node, level, parent){\\n    if(node == null){\\n        return\\n    }\\n    nodeValues.set(node, node.val)\\n    \\n    if(!levelSums.has(level)){\\n        levelSums.set(level, 0)\\n    }\\n    \\n    levelSums.set(level, node.val + levelSums.get(level))\\n    dfs1(node.left, level + 1, node)\\n    \\n    dfs1(node.right, level + 1, node)\\n    \\n    \\n}\\n\\nfunction dfs2(node, level, parent){\\n    if(node == null){\\n        return\\n    }\\n    if(parent == null){\\n        node.val = 0;\\n       \\n    } else{\\n\\n        let sum = levelSums.get(level);\\n        let left = parent.left\\n        let right = parent.right\\n\\n        if(left){\\n\\n            sum -= nodeValues.get(left)\\n        }\\n        if(right){\\n            sum -= nodeValues.get(right)\\n        }\\n\\n        node.val = sum;\\n    }\\n    \\n    dfs2(node.left, level+1, node)\\n    dfs2(node.right, level+1, node)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420151,
                "title": "c-bfs-easy",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        int n=1;\\n        vector<TreeNode*> a1;\\n        unordered_map<TreeNode*, TreeNode*> par;\\n        unordered_map<TreeNode*,int> childSum;\\n        a1.push_back(root);\\n        root->val = 0;\\n        \\n        while(n){\\n            int sum=0,sChild=0;\\n            vector<TreeNode*> a2;\\n            \\n            for(int i=0;i<n;i++){\\n                sChild=0;\\n                auto fr = a1[i];\\n                sum += fr->val;\\n                if(fr->left){\\n                    a2.push_back(fr->left);\\n                    sChild+=fr->left->val;\\n                    par[fr->left] = fr;\\n                }\\n                if(fr->right){\\n                    a2.push_back(fr->right);\\n                    sChild += fr->right->val;\\n                    par[fr->right] = fr;\\n                }\\n                childSum[fr] = sChild;\\n            }\\n            for(int i=0;i<n;i++){\\n                auto fr = a1[i];\\n                fr->val = sum - childSum[par[fr]];\\n            }\\n            a1=a2;\\n            n=a1.size();\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        int n=1;\\n        vector<TreeNode*> a1;\\n        unordered_map<TreeNode*, TreeNode*> par;\\n        unordered_map<TreeNode*,int> childSum;\\n        a1.push_back(root);\\n        root->val = 0;\\n        \\n        while(n){\\n            int sum=0,sChild=0;\\n            vector<TreeNode*> a2;\\n            \\n            for(int i=0;i<n;i++){\\n                sChild=0;\\n                auto fr = a1[i];\\n                sum += fr->val;\\n                if(fr->left){\\n                    a2.push_back(fr->left);\\n                    sChild+=fr->left->val;\\n                    par[fr->left] = fr;\\n                }\\n                if(fr->right){\\n                    a2.push_back(fr->right);\\n                    sChild += fr->right->val;\\n                    par[fr->right] = fr;\\n                }\\n                childSum[fr] = sChild;\\n            }\\n            for(int i=0;i<n;i++){\\n                auto fr = a1[i];\\n                fr->val = sum - childSum[par[fr]];\\n            }\\n            a1=a2;\\n            n=a1.size();\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420138,
                "title": "level-order-traversal-c-easy-to-understnad",
                "content": "````\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q1,q2;\\n        for(int i = 0; i < 1000; i++){}\\n        int n,d;\\n        TreeNode* node;\\n        q1.push(root);\\n        unordered_map<int,int> mp;\\n        int sum = 0;\\n        while(!q1.empty()){\\n            n = q1.size();\\n            sum = 0;\\n            q2 = q1;\\n            d = 0;\\n            mp.clear();\\n            while(n--){\\n                node = q1.front();\\n                q1.pop();\\n                if(node->left){\\n                    q1.push(node->left);\\n                    sum += node->left->val;\\n                    mp[d] += node->left->val;\\n                }\\n                if(node->right){\\n                    q1.push(node->right);\\n                    sum += node->right->val;\\n                    mp[d] += node->right->val;\\n                }\\n                d++;\\n            }\\n            \\n            n = q2.size();\\n            d = 0;\\n            while(n--){\\n                node = q2.front();\\n                q2.pop();\\n                if(node->left){\\n                    node->left->val = sum-mp[d];\\n                }\\n                if(node->right){\\n                    node->right->val = sum-mp[d];\\n                }\\n                d++;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "````\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q1,q2;\\n        for(int i = 0; i < 1000; i++){}\\n        int n,d;\\n        TreeNode* node;\\n        q1.push(root);\\n        unordered_map<int,int> mp;\\n        int sum = 0;\\n        while(!q1.empty()){\\n            n = q1.size();\\n            sum = 0;\\n            q2 = q1;\\n            d = 0;\\n            mp.clear();\\n            while(n--){\\n                node = q1.front();\\n                q1.pop();\\n                if(node->left){\\n                    q1.push(node->left);\\n                    sum += node->left->val;\\n                    mp[d] += node->left->val;\\n                }\\n                if(node->right){\\n                    q1.push(node->right);\\n                    sum += node->right->val;\\n                    mp[d] += node->right->val;\\n                }\\n                d++;\\n            }\\n            \\n            n = q2.size();\\n            d = 0;\\n            while(n--){\\n                node = q2.front();\\n                q2.pop();\\n                if(node->left){\\n                    node->left->val = sum-mp[d];\\n                }\\n                if(node->right){\\n                    node->right->val = sum-mp[d];\\n                }\\n                d++;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420105,
                "title": "c-solution-using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void fill(unordered_map<int,int>&m,int level,TreeNode* root){\\n        if(root==NULL)return;\\n        m[level]+=root->val;\\n        fill(m,level+1,root->left);\\n        fill(m,level+1,root->right);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int>m;\\n        fill(m,0,root);\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int level=0;\\n        root->val=0;\\n        // for(auto i:m)cout<<i.first<<\" \"<<i.second<<endl;\\n        while(q.size()){\\n            int n=q.size();\\n            int sum=m[level+1];\\n            while(n--)\\n            {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                if(front->left)sum-=front->left->val;\\n                if(front->right)sum-=front->right->val;\\n                // cout<<sum<<\" \"<<front->val<<endl;\\n                if(front->left)\\n                front->left->val=sum;\\n                if(front->right)\\n                front->right->val=sum;\\n                sum=m[level+1];\\n                \\n                \\n                \\n                if(front->left)q.push(front->left);\\n                if(front->right)q.push(front->right);\\n            }\\n            level++;\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void fill(unordered_map<int,int>&m,int level,TreeNode* root){\\n        if(root==NULL)return;\\n        m[level]+=root->val;\\n        fill(m,level+1,root->left);\\n        fill(m,level+1,root->right);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int>m;\\n        fill(m,0,root);\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int level=0;\\n        root->val=0;\\n        // for(auto i:m)cout<<i.first<<\" \"<<i.second<<endl;\\n        while(q.size()){\\n            int n=q.size();\\n            int sum=m[level+1];\\n            while(n--)\\n            {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                if(front->left)sum-=front->left->val;\\n                if(front->right)sum-=front->right->val;\\n                // cout<<sum<<\" \"<<front->val<<endl;\\n                if(front->left)\\n                front->left->val=sum;\\n                if(front->right)\\n                front->right->val=sum;\\n                sum=m[level+1];\\n                \\n                \\n                \\n                if(front->left)q.push(front->left);\\n                if(front->right)q.push(front->right);\\n            }\\n            level++;\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3938051,
                "title": "c-one-level-order-traversal-without-storing-level-pointer",
                "content": "# Intuition\\nthe idea is to push the value of sibling along with the pointer into the queue and you will be having level sum in advance, replace node value with level sum - sibling - self\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\nn= total number of nodes\\n\\n- Space complexity:\\nO(k) where k is number of nodes in a single level\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n\\n        queue< pair<TreeNode*,int> > q;\\n        q.push({root,0});\\n\\n        //curr_sum stores value of total level sum and for next level\\'s sum calc next_sum is updated on every push to the queue\\n        //in the end curr_sum equals to next_sum \\n        int curr_sum=root->val;\\n        \\n        while(!q.empty()){\\n            int sz=q.size();\\n\\n            int next_sum = 0;\\n\\n            for(int i=0;i<sz;i++){\\n                auto it=q.front();\\n\\n                TreeNode* node= it.first;\\n                int sibling= it.second;\\n\\n                q.pop();\\n\\n                //total level sum - sum of sibling(left or right  we don\\'t know at this moment)\\n                int newVal= curr_sum-sibling- node->val;\\n                //assign new value\\n                node->val=newVal;\\n\\n                //get value of left and right child, send value of left to right child to the left child and vice versa\\n                int left=0, right=0;\\n                if(node->left){\\n                    left=node->left->val;\\n                }\\n                if(node->right){\\n                    right=node->right->val;\\n                }\\n\\n                if(node->left){\\n                    q.push({node->left, right});\\n                    next_sum+=node->left->val;\\n                }\\n                if(node->right){\\n                    q.push({node->right, left});\\n                    next_sum+=node->right->val;\\n\\n                }\\n            }\\n\\n            curr_sum=next_sum;\\n\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n\\n        queue< pair<TreeNode*,int> > q;\\n        q.push({root,0});\\n\\n        //curr_sum stores value of total level sum and for next level\\'s sum calc next_sum is updated on every push to the queue\\n        //in the end curr_sum equals to next_sum \\n        int curr_sum=root->val;\\n        \\n        while(!q.empty()){\\n            int sz=q.size();\\n\\n            int next_sum = 0;\\n\\n            for(int i=0;i<sz;i++){\\n                auto it=q.front();\\n\\n                TreeNode* node= it.first;\\n                int sibling= it.second;\\n\\n                q.pop();\\n\\n                //total level sum - sum of sibling(left or right  we don\\'t know at this moment)\\n                int newVal= curr_sum-sibling- node->val;\\n                //assign new value\\n                node->val=newVal;\\n\\n                //get value of left and right child, send value of left to right child to the left child and vice versa\\n                int left=0, right=0;\\n                if(node->left){\\n                    left=node->left->val;\\n                }\\n                if(node->right){\\n                    right=node->right->val;\\n                }\\n\\n                if(node->left){\\n                    q.push({node->left, right});\\n                    next_sum+=node->left->val;\\n                }\\n                if(node->right){\\n                    q.push({node->right, left});\\n                    next_sum+=node->right->val;\\n\\n                }\\n            }\\n\\n            curr_sum=next_sum;\\n\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430980,
                "title": "easy-c-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->BFS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->we will calculate the sum of value of all the node at particular level using bfs then we can simply calculate value of that node by subtracting the value of that node and if it has real sibling then we will minus value of sibling also. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       map<TreeNode*,int>mp;//for storing the value of real sibling of a node\\n       \\n       while(!q.empty()){\\n           int sz =q.size();\\n           queue<TreeNode*>temp;//for storing all the node of current level\\n           int sum =0;          //sum of values of all the node at curent level\\n           for(int i=0;i<sz;i++){\\n               auto it =q.front();\\n               q.pop();\\n               \\n               sum+=it->val;  //calculating sum \\n               temp.push(it);\\n            if(it->left!=NULL){\\n                q.push(it->left);\\n                if(it->right!=NULL){\\n                mp[it->left]=it->right->val;//as at particular node we know parent we can check for real sibling of that node\\n                }\\n            }\\n            if(it->right!=NULL){\\n                q.push(it->right);\\n                if(it->left!=NULL){\\n                mp[it->right]=it->left->val;//as at particular node we know parent we can check for real sibling of that node\\n                }\\n            }\\n\\n           }\\n           while(!temp.empty()){\\n               auto it =temp.front();\\n               temp.pop();\\n               it->val=sum-it->val;\\n               if(mp.find(it)!=mp.end()){\\n                   it->val=it->val-mp[it];\\n               }\\n       } \\n    }\\n       return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       map<TreeNode*,int>mp;//for storing the value of real sibling of a node\\n       \\n       while(!q.empty()){\\n           int sz =q.size();\\n           queue<TreeNode*>temp;//for storing all the node of current level\\n           int sum =0;          //sum of values of all the node at curent level\\n           for(int i=0;i<sz;i++){\\n               auto it =q.front();\\n               q.pop();\\n               \\n               sum+=it->val;  //calculating sum \\n               temp.push(it);\\n            if(it->left!=NULL){\\n                q.push(it->left);\\n                if(it->right!=NULL){\\n                mp[it->left]=it->right->val;//as at particular node we know parent we can check for real sibling of that node\\n                }\\n            }\\n            if(it->right!=NULL){\\n                q.push(it->right);\\n                if(it->left!=NULL){\\n                mp[it->right]=it->left->val;//as at particular node we know parent we can check for real sibling of that node\\n                }\\n            }\\n\\n           }\\n           while(!temp.empty()){\\n               auto it =temp.front();\\n               temp.pop();\\n               it->val=sum-it->val;\\n               if(mp.find(it)!=mp.end()){\\n                   it->val=it->val-mp[it];\\n               }\\n       } \\n    }\\n       return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420809,
                "title": "simple-bfs-java-intuitive",
                "content": "# Code\\n```\\nclass Pair {\\n    public TreeNode node;\\n    public int p;\\n    public Pair(TreeNode node, int p) {\\n        this.node = node;\\n        this.p = p;\\n    }\\n}\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<Pair> q = new LinkedList<Pair>();\\n        int sum=0;\\n        int prevSum=0;\\n        q.add(new Pair(root,0));\\n        while(!q.isEmpty()) {\\n            int n = q.size();\\n            for(int i=0;i<n;i++) {\\n                int s = 0;\\n                Pair nn = q.poll();\\n                nn.node.val = prevSum - nn.p;\\n                if(nn.node.left!=null) s+=nn.node.left.val;\\n                if(nn.node.right!=null) {\\n                    s+=nn.node.right.val;\\n                    q.add(new Pair(nn.node.right,s));\\n                }\\n                if(nn.node.left!=null) q.add(new Pair(nn.node.left,s));\\n                sum+=s;\\n            }\\n            prevSum = sum;\\n            sum=0;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Pair {\\n    public TreeNode node;\\n    public int p;\\n    public Pair(TreeNode node, int p) {\\n        this.node = node;\\n        this.p = p;\\n    }\\n}\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<Pair> q = new LinkedList<Pair>();\\n        int sum=0;\\n        int prevSum=0;\\n        q.add(new Pair(root,0));\\n        while(!q.isEmpty()) {\\n            int n = q.size();\\n            for(int i=0;i<n;i++) {\\n                int s = 0;\\n                Pair nn = q.poll();\\n                nn.node.val = prevSum - nn.p;\\n                if(nn.node.left!=null) s+=nn.node.left.val;\\n                if(nn.node.right!=null) {\\n                    s+=nn.node.right.val;\\n                    q.add(new Pair(nn.node.right,s));\\n                }\\n                if(nn.node.left!=null) q.add(new Pair(nn.node.left,s));\\n                sum+=s;\\n            }\\n            prevSum = sum;\\n            sum=0;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420523,
                "title": "easy-to-understand-straightforward-solution-with-explanation-and-comments",
                "content": "# Intuition\\nThe solution is based on the follwing observations.\\n- Sum of cousins equals the difference between the sum of entire level AND the sum of siblings. \\n- We can use BFS to traverse the tree level-wise.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSteps :-\\n- Store the sum_of_children in a hashmap`hmap`, with the node refernece as the key.\\n- Maintain a running sum of the entire next level simultaneously.\\n- Now for each element in the current level do this:\\n    - pop out the node.\\n    - Use the hashmap to modify the children of the node : sum_of_next_level - sum_of_children\\n    - push the modified node into the queue for next level of operations.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        if not root.left and not root.right: return root\\n        q = deque()\\n        q.append(root)\\n        \\n        while q:\\n            hmap = {}       #store the sum of children of each node in the following fashion -> {node: node.left.val + node.right.val}\\n            size = len(q)\\n            runsum = 0      #store the running sum of next level.\\n            for i in range(size):\\n                childsum = 0      #sum of children of each node\\n                if q[i].left:\\n                    childsum+=q[i].left.val\\n                    runsum+=q[i].left.val\\n                if q[i].right:\\n                    childsum+=q[i].right.val\\n                    runsum+=q[i].right.val\\n                hmap[q[i]] = childsum       #add sum of children to hashmap\\n\\n            while size:\\n                node = q.popleft()\\n                if node.left:\\n                    node.left.val = runsum-hmap[node] #modify child\\n                    q.append(node.left) #push child in queue for next iteration       \\n                if node.right:\\n                    node.right.val =  runsum-hmap[node]\\n                    q.append(node.right)\\n                size-=1\\n                \\n        return root        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        if not root.left and not root.right: return root\\n        q = deque()\\n        q.append(root)\\n        \\n        while q:\\n            hmap = {}       #store the sum of children of each node in the following fashion -> {node: node.left.val + node.right.val}\\n            size = len(q)\\n            runsum = 0      #store the running sum of next level.\\n            for i in range(size):\\n                childsum = 0      #sum of children of each node\\n                if q[i].left:\\n                    childsum+=q[i].left.val\\n                    runsum+=q[i].left.val\\n                if q[i].right:\\n                    childsum+=q[i].right.val\\n                    runsum+=q[i].right.val\\n                hmap[q[i]] = childsum       #add sum of children to hashmap\\n\\n            while size:\\n                node = q.popleft()\\n                if node.left:\\n                    node.left.val = runsum-hmap[node] #modify child\\n                    q.append(node.left) #push child in queue for next iteration       \\n                if node.right:\\n                    node.right.val =  runsum-hmap[node]\\n                    q.append(node.right)\\n                size-=1\\n                \\n        return root        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420227,
                "title": "c-simple-bfs-level-order-traversal-clean-code-well-explained-beginner-friendly",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> levelOrder(TreeNode* root) {\\n        vector<vector<int>> ans; \\n        //base case\\n        if(root == NULL) \\n            return ans; \\n            \\n        queue<TreeNode*> q; \\n        q.push(root); \\n        \\n        //taking the level order or BFS traversal\\n        while(!q.empty()) {\\n            int size = q.size();\\n            vector<int> level;\\n            //this takes care of the whole level present\\n            while(size--){\\n                auto node = q.front();\\n                q.pop();\\n                if(node){\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                    level.push_back(node->val);\\n                }\\n//null nodes are assigned with 0 so that the total sum is not affected when we take level sum below\\n                else level.push_back(0);\\n                \\n            }\\n            ans.push_back(level);\\n        }\\n        return ans; \\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<vector<int>> lvl = levelOrder(root);\\n        if(root == NULL) \\n            return root; \\n            \\n        queue<TreeNode*> q; \\n        q.push(root);\\n        \\n        int n=0; //level number\\n        int l =lvl.size()-1;\\n        while(!q.empty() and n<l) {\\n            int size = q.size();\\n            long long sum = 0;\\n            int s = lvl[n].size();\\n            //taking the total sum present in the level\\n            for(int it=0;it<s;++it){\\n                sum+=lvl[n][it];\\n            }\\n            int j=0;\\n            while(size--){\\n                auto node = q.front();\\n                q.pop();\\n                if(node){\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                //node->val = 0 bcz they lie with the same parent\\n                    if(n<2)node->val=0;\\n                    else{\\n                        int temp = sum;\\n                        //only two adjacent nodes can be from the same parent\\n                        //so we are subracting it\\n                        if(j%2==0){\\n                            temp-=(lvl[n][j]+lvl[n][j+1]);\\n                        }\\n                        else{\\n                            temp-=(lvl[n][j]+lvl[n][j-1]);\\n                        }\\n                        node->val = temp;\\n                    }\\n                }\\n                ++j;\\n            }\\n            ++n;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> levelOrder(TreeNode* root) {\\n        vector<vector<int>> ans; \\n        //base case\\n        if(root == NULL) \\n            return ans; \\n            \\n        queue<TreeNode*> q; \\n        q.push(root); \\n        \\n        //taking the level order or BFS traversal\\n        while(!q.empty()) {\\n            int size = q.size();\\n            vector<int> level;\\n            //this takes care of the whole level present\\n            while(size--){\\n                auto node = q.front();\\n                q.pop();\\n                if(node){\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                    level.push_back(node->val);\\n                }\\n//null nodes are assigned with 0 so that the total sum is not affected when we take level sum below\\n                else level.push_back(0);\\n                \\n            }\\n            ans.push_back(level);\\n        }\\n        return ans; \\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<vector<int>> lvl = levelOrder(root);\\n        if(root == NULL) \\n            return root; \\n            \\n        queue<TreeNode*> q; \\n        q.push(root);\\n        \\n        int n=0; //level number\\n        int l =lvl.size()-1;\\n        while(!q.empty() and n<l) {\\n            int size = q.size();\\n            long long sum = 0;\\n            int s = lvl[n].size();\\n            //taking the total sum present in the level\\n            for(int it=0;it<s;++it){\\n                sum+=lvl[n][it];\\n            }\\n            int j=0;\\n            while(size--){\\n                auto node = q.front();\\n                q.pop();\\n                if(node){\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                //node->val = 0 bcz they lie with the same parent\\n                    if(n<2)node->val=0;\\n                    else{\\n                        int temp = sum;\\n                        //only two adjacent nodes can be from the same parent\\n                        //so we are subracting it\\n                        if(j%2==0){\\n                            temp-=(lvl[n][j]+lvl[n][j+1]);\\n                        }\\n                        else{\\n                            temp-=(lvl[n][j]+lvl[n][j-1]);\\n                        }\\n                        node->val = temp;\\n                    }\\n                }\\n                ++j;\\n            }\\n            ++n;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420088,
                "title": "just-dfs",
                "content": "# Intuition\\nJust DFS.\\n\\n# Approach\\nJust DFS. Save:\\n(1) The depth of each node.\\n(2) The parent of each node.\\n(3) The sum of values of all descants of each node.\\n(4) The sum of values of all nodes on for each depth.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void dfs(int d, TreeNode* root, TreeNode* parent, unordered_map<TreeNode*, int>& dep, unordered_map<TreeNode*, int>& sons, unordered_map<int, int>& s, unordered_map<TreeNode*, TreeNode*> &f) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        dep[root] = d;\\n        sons[parent] += root->val;\\n        s[d] += root->val;\\n        f[root] = parent;\\n        dfs(d + 1, root->left, root, dep, sons, s, f);\\n        dfs(d + 1, root->right, root, dep, sons, s, f);\\n    }\\n    \\n    void dfs(TreeNode* root, unordered_map<TreeNode*, int>& dep, unordered_map<TreeNode*, int>& sons,\\n          unordered_map<int, int>& s, unordered_map<TreeNode*, TreeNode*> &f) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        root->val = s[dep[root]] - sons[f[root]];\\n        dfs(root->left, dep, sons, s, f);\\n        dfs(root->right, dep, sons, s, f);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<TreeNode*, int> dep, sons;\\n        unordered_map<int, int> s;\\n        unordered_map<TreeNode*, TreeNode*> f;\\n        dfs(0, root, nullptr, dep, sons, s, f);\\n        dfs(root, dep, sons, s, f);\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void dfs(int d, TreeNode* root, TreeNode* parent, unordered_map<TreeNode*, int>& dep, unordered_map<TreeNode*, int>& sons, unordered_map<int, int>& s, unordered_map<TreeNode*, TreeNode*> &f) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        dep[root] = d;\\n        sons[parent] += root->val;\\n        s[d] += root->val;\\n        f[root] = parent;\\n        dfs(d + 1, root->left, root, dep, sons, s, f);\\n        dfs(d + 1, root->right, root, dep, sons, s, f);\\n    }\\n    \\n    void dfs(TreeNode* root, unordered_map<TreeNode*, int>& dep, unordered_map<TreeNode*, int>& sons,\\n          unordered_map<int, int>& s, unordered_map<TreeNode*, TreeNode*> &f) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        root->val = s[dep[root]] - sons[f[root]];\\n        dfs(root->left, dep, sons, s, f);\\n        dfs(root->right, dep, sons, s, f);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<TreeNode*, int> dep, sons;\\n        unordered_map<int, int> s;\\n        unordered_map<TreeNode*, TreeNode*> f;\\n        dfs(0, root, nullptr, dep, sons, s, f);\\n        dfs(root, dep, sons, s, f);\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419971,
                "title": "bfs-twice-to-find-sum-of-each-level",
                "content": "```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        sums = defaultdict(int)\\n        sumparents = defaultdict(lambda: defaultdict(int))\\n        q = deque([(root, 0)])\\n        while len(q) > 0:\\n            curr, d = q.pop()\\n            if curr:\\n                sums[d] += curr.val\\n                q.appendleft((curr.left, d + 1))\\n                q.appendleft((curr.right, d + 1))\\n        q = deque([(root, root.val if root else 0, 0, 0)])\\n        while len(q) > 0:\\n            curr, currval, other, d = q.pop()\\n            curr.val = sums[d] - currval - other\\n            if curr.left:\\n                q.appendleft((curr.left, curr.left.val, curr.right.val if curr.right else 0, d + 1))\\n            if curr.right:\\n                q.appendleft((curr.right, curr.right.val, curr.left.val if curr.left else 0, d + 1))\\n        return root\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        sums = defaultdict(int)\\n        sumparents = defaultdict(lambda: defaultdict(int))\\n        q = deque([(root, 0)])\\n        while len(q) > 0:\\n            curr, d = q.pop()\\n            if curr:\\n                sums[d] += curr.val\\n                q.appendleft((curr.left, d + 1))\\n                q.appendleft((curr.right, d + 1))\\n        q = deque([(root, root.val if root else 0, 0, 0)])\\n        while len(q) > 0:\\n            curr, currval, other, d = q.pop()\\n            curr.val = sums[d] - currval - other\\n            if curr.left:\\n                q.appendleft((curr.left, curr.left.val, curr.right.val if curr.right else 0, d + 1))\\n            if curr.right:\\n                q.appendleft((curr.right, curr.right.val, curr.left.val if curr.left else 0, d + 1))\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920356,
                "title": "optimal-approach-with-full-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**- dfs1 Function:**\\nThis function performs a depth-first search (DFS) traversal of the binary tree while calculating the sum of node values at each depth. It uses a hash map mp to store the sum of values for each depth.\\n\\n**- dfs2 Function:**\\nThis function is another DFS traversal of the binary tree. It calculates the new value for each node based on the sum of values at its depth and the value of its sibling node. It first calculates the values of the left and right children of the current node and then updates the current node\\'s value according to the formula: new_value = sum_at_depth - current_value - sibling_value.\\n\\n**- replaceValueInTree Function:**\\nThis is the main function that orchestrates the entire process. It first creates an unordered map mp to store the sum of values at each depth. Then, it initiates the first DFS (dfs1) to populate the mp map. After that, it initiates the second DFS (dfs2) to update the values of the nodes.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1O)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs1(TreeNode* node,int depth,unordered_map<int,int>& mp) {\\n        if(node == NULL)\\n            return;\\n        \\n        mp[depth] += node->val;\\n        \\n        dfs1(node->left,depth+1,mp);\\n        dfs1(node->right,depth+1,mp);\\n    }\\n    \\n    void dfs2(TreeNode* node,int sibling,int depth,unordered_map<int,int>& mp) {\\n        if(node == NULL)\\n            return;\\n        \\n        node->val = mp[depth] - node->val - sibling;\\n        \\n        int lVal;\\n        if(node->left) {\\n            lVal = node->left->val;\\n        }\\n        else {\\n            lVal = 0;\\n        }\\n        \\n        int rVal;\\n        if(node->right) {\\n            rVal = node->right->val;\\n        }\\n        else {\\n            rVal = 0;\\n        }\\n        \\n        \\n        dfs2(node->left,rVal,depth+1,mp);\\n        dfs2(node->right,lVal,depth+1,mp);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n        \\n        \\n        \\n        TreeNode* dummy =  root;\\n        \\n        dfs1(root,0,mp);\\n        dfs2(root,0,0,mp);\\n            \\n            return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs1(TreeNode* node,int depth,unordered_map<int,int>& mp) {\\n        if(node == NULL)\\n            return;\\n        \\n        mp[depth] += node->val;\\n        \\n        dfs1(node->left,depth+1,mp);\\n        dfs1(node->right,depth+1,mp);\\n    }\\n    \\n    void dfs2(TreeNode* node,int sibling,int depth,unordered_map<int,int>& mp) {\\n        if(node == NULL)\\n            return;\\n        \\n        node->val = mp[depth] - node->val - sibling;\\n        \\n        int lVal;\\n        if(node->left) {\\n            lVal = node->left->val;\\n        }\\n        else {\\n            lVal = 0;\\n        }\\n        \\n        int rVal;\\n        if(node->right) {\\n            rVal = node->right->val;\\n        }\\n        else {\\n            rVal = 0;\\n        }\\n        \\n        \\n        dfs2(node->left,rVal,depth+1,mp);\\n        dfs2(node->right,lVal,depth+1,mp);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n        \\n        \\n        \\n        TreeNode* dummy =  root;\\n        \\n        dfs1(root,0,mp);\\n        dfs2(root,0,0,mp);\\n            \\n            return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843279,
                "title": "c-level-order-traversal-mapping-easy-solution-with-comments-and-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen i first read the question, it was clearly mentioned that we need to replace the value of nodes in tree with the sum of its cousins(nodes at the same level).Since, cousins are the nodes which are at the same level so i thought of traversing the tree level wise and while traversing i\\'ll keep a track of the sum of all nodes at that level.\\nAfter, mapping the level of tree with its respective sum i\\'ll again traverse the tree level wise and this time i\\'ll see if the node has left, right children, then i\\'ll subtract the sum which is mapped with that level and assign that value with the left and right children. \\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n    2*O(n) --> Two times level wise traversal\\n    O(1)--> insertion and retrieval in unordered_map\\n      **O(N)**\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->  \\n    O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        //map to store the sum at each level \\n        unordered_map<int,int> mp;\\n        queue<TreeNode*> q;\\n        //queue for level order traversal\\n        q.push(root);\\n        mp[0]=root->val;\\n        //we are doing first time level wise traversal to map each level to the sum of the value of nodes at that level\\n        int level=0;\\n        while(q.empty()!=1){\\n            int n=q.size();\\n            level++;\\n            for(int i=0;i<n;i++){\\n                auto r=q.front();\\n                q.pop();\\n                if(r->left){\\n                    mp[level]+=r->left->val;\\n                    q.push(r->left);\\n                }\\n                if(r->right){\\n                    q.push(r->right);\\n                    mp[level]+=r->right->val;\\n                }\\n            }\\n        }\\n        //second time level order traversal to alter the value of nodes according to the question\\n        q.push(root);   \\n        root->val=0;\\n        level=0;\\n        while(q.empty()!=1){\\n            int n=q.size();\\n            level++;\\n            for(int i=0;i<n;i++){\\n                auto it=q.front();\\n                q.pop();\\n                int l=it->left!=NULL?it->left->val:0;\\n                int r=it->right!=NULL?it->right->val:0;\\n                if(it->left){\\n                    q.push(it->left);\\n                    it->left->val=mp[level]-l-r;\\n                }\\n                if(it->right){\\n                    q.push(it->right);\\n                    it->right->val=mp[level]-l-r;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        //map to store the sum at each level \\n        unordered_map<int,int> mp;\\n        queue<TreeNode*> q;\\n        //queue for level order traversal\\n        q.push(root);\\n        mp[0]=root->val;\\n        //we are doing first time level wise traversal to map each level to the sum of the value of nodes at that level\\n        int level=0;\\n        while(q.empty()!=1){\\n            int n=q.size();\\n            level++;\\n            for(int i=0;i<n;i++){\\n                auto r=q.front();\\n                q.pop();\\n                if(r->left){\\n                    mp[level]+=r->left->val;\\n                    q.push(r->left);\\n                }\\n                if(r->right){\\n                    q.push(r->right);\\n                    mp[level]+=r->right->val;\\n                }\\n            }\\n        }\\n        //second time level order traversal to alter the value of nodes according to the question\\n        q.push(root);   \\n        root->val=0;\\n        level=0;\\n        while(q.empty()!=1){\\n            int n=q.size();\\n            level++;\\n            for(int i=0;i<n;i++){\\n                auto it=q.front();\\n                q.pop();\\n                int l=it->left!=NULL?it->left->val:0;\\n                int r=it->right!=NULL?it->right->val:0;\\n                if(it->left){\\n                    q.push(it->left);\\n                    it->left->val=mp[level]-l-r;\\n                }\\n                if(it->right){\\n                    q.push(it->right);\\n                    it->right->val=mp[level]-l-r;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641061,
                "title": "c-2-times-bfs-simple",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> levelSum;\\n        getSum(root, levelSum);\\n        return updateTree(root, levelSum);\\n    }\\n\\nprivate:\\n    void getSum(TreeNode* root, vector<int>& levelSum) {\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n    \\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            int sum = 0;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = Q.front();\\n                Q.pop();\\n                sum += curr->val;\\n                if (curr->left) Q.push(curr->left);\\n                if (curr->right) Q.push(curr->right);\\n            }\\n            levelSum.emplace_back(sum);\\n        }\\n    }\\n\\n    TreeNode* updateTree(TreeNode* root, vector<int>& levelSum) {\\n        int level = 0;\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n    \\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = Q.front();\\n                Q.pop();\\n                int siblingSum = (curr->left ? curr->left->val : 0) + \\n                                   (curr->right ? curr->right->val : 0);\\n                if (level == 0) curr->val = 0;\\n                if (curr->left) {\\n                    Q.push(curr->left);\\n                    curr->left->val = levelSum[level+1] - siblingSum;\\n                }\\n                if (curr->right) {\\n                    Q.push(curr->right);\\n                    curr->right->val = levelSum[level+1] - siblingSum;\\n                }\\n            }\\n            level++;\\n        }\\n\\n        return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> levelSum;\\n        getSum(root, levelSum);\\n        return updateTree(root, levelSum);\\n    }\\n\\nprivate:\\n    void getSum(TreeNode* root, vector<int>& levelSum) {\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n    \\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            int sum = 0;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = Q.front();\\n                Q.pop();\\n                sum += curr->val;\\n                if (curr->left) Q.push(curr->left);\\n                if (curr->right) Q.push(curr->right);\\n            }\\n            levelSum.emplace_back(sum);\\n        }\\n    }\\n\\n    TreeNode* updateTree(TreeNode* root, vector<int>& levelSum) {\\n        int level = 0;\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n    \\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = Q.front();\\n                Q.pop();\\n                int siblingSum = (curr->left ? curr->left->val : 0) + \\n                                   (curr->right ? curr->right->val : 0);\\n                if (level == 0) curr->val = 0;\\n                if (curr->left) {\\n                    Q.push(curr->left);\\n                    curr->left->val = levelSum[level+1] - siblingSum;\\n                }\\n                if (curr->right) {\\n                    Q.push(curr->right);\\n                    curr->right->val = levelSum[level+1] - siblingSum;\\n                }\\n            }\\n            level++;\\n        }\\n\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640932,
                "title": "python-simple-and-clean-beats-99-89",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n# Intuition\\nThe problem asks us to replace the value of each node in a binary tree with the sum of all its cousins\\' values. Two nodes are cousins if they have the same depth with different parents. One way to approach this problem is to use a breadth-first search (BFS) algorithm to traverse the tree level by level and keep track of the sum of values of nodes at each level and the sum of values of siblings at each level.\\n\\n# Approach\\n1. Initialize a queue with a tuple containing the root node and its value. This queue will be used to perform BFS on the tree.\\n2. Initialize a variable `level_sum` with the value of the root node. This variable will be used to keep track of the sum of values of nodes at each level.\\n3. While the queue is not empty:\\n    1. Initialize a list `level_q` to store the nodes in the next level.\\n    2. Initialize a variable `curr` to store the sum of values of siblings in the next level.\\n    3. For each tuple `(node, sib)` in `queue`:\\n        1. Update the value of `node` to `level_sum - sib`, where `level_sum` is the sum of values of nodes at the current level and `sib` is the sum of values of `node`\\'s siblings.\\n        2. Initialize a variable `next_sib` to store the sum of values of `node`\\'s left and right children (or 0 if they don\\'t exist).\\n        3. Add `next_sib` to `curr`.\\n        4. If `node` has a left child, append a tuple containing its left child and `next_sib` to `level_q`.\\n        5. If `node` has a right child, append a tuple containing its right child and `next_sib` to `level_q`.\\n    4. Update `queue` with `level_q`.\\n    5. Update `level_sum` with `curr`.\\n4. Return the root of the modified tree.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the number of nodes in the tree.\\n- Space complexity: $$O(n)$$ where n is the number of nodes in the tree.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [(root,root.val)] # [node,siblings_sum]\\n        level_sum = root.val # sum of nodes at a level\\n        \\n        #BFS\\n        while queue:\\n            curr = 0\\n            level_q = []\\n            for node, sib in queue:\\n                node.val = level_sum - sib # replace node value with sum of siblings\\n                next_sib = 0\\n                if node.left:\\n                    next_sib += node.left.val\\n                if node.right:\\n                    next_sib += node.right.val\\n                curr += next_sib\\n                if node.left:\\n                    level_q.append((node.left,next_sib))\\n                if node.right:\\n                    level_q.append((node.right,next_sib))\\n            queue = level_q\\n            level_sum = curr # update sum of nodes at current level\\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [(root,root.val)] # [node,siblings_sum]\\n        level_sum = root.val # sum of nodes at a level\\n        \\n        #BFS\\n        while queue:\\n            curr = 0\\n            level_q = []\\n            for node, sib in queue:\\n                node.val = level_sum - sib # replace node value with sum of siblings\\n                next_sib = 0\\n                if node.left:\\n                    next_sib += node.left.val\\n                if node.right:\\n                    next_sib += node.right.val\\n                curr += next_sib\\n                if node.left:\\n                    level_q.append((node.left,next_sib))\\n                if node.right:\\n                    level_q.append((node.right,next_sib))\\n            queue = level_q\\n            level_sum = curr # update sum of nodes at current level\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516197,
                "title": "2641-cousins-in-binary-tree-ii-java",
                "content": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        List<Integer> sum=new ArrayList<>();\\n        sum.add(root.val);\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            int sum1=0;\\n            while(size-->0){\\n                TreeNode curr=q.poll();\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n            }\\n            sum.add(sum1);\\n        }\\n        q.clear();\\n        q.add(root);\\n        int lev=-1;\\n        while(!q.isEmpty())\\n        {\\n            lev++;\\n            int size=q.size();\\n            while(size--!=0)\\n            {\\n                int civiling_sum=0;\\n                TreeNode cur=q.poll();\\n                if(lev==1||lev==0)\\n                    cur.val=0;\\n                if(cur.left!=null)\\n                {\\n                    civiling_sum+=cur.left.val;\\n                    q.add(cur.left);\\n                }\\n                \\n                if(cur.right!=null)\\n                {\\n                    civiling_sum+=cur.right.val;\\n                    q.add(cur.right);\\n                }\\n                if(lev>=1){\\n                     if(cur.left!=null){\\n                          \\n                        cur.left.val=sum.get(lev+1)-civiling_sum;\\n                     }\\n                    if(cur.right!=null){\\n                        cur.right.val=sum.get(lev+1)-civiling_sum;\\n                     }\\n                }\\n            }\\n        }\\n        return root;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        List<Integer> sum=new ArrayList<>();\\n        sum.add(root.val);\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            int sum1=0;\\n            while(size-->0){\\n                TreeNode curr=q.poll();\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n            }\\n            sum.add(sum1);\\n        }\\n        q.clear();\\n        q.add(root);\\n        int lev=-1;\\n        while(!q.isEmpty())\\n        {\\n            lev++;\\n            int size=q.size();\\n            while(size--!=0)\\n            {\\n                int civiling_sum=0;\\n                TreeNode cur=q.poll();\\n                if(lev==1||lev==0)\\n                    cur.val=0;\\n                if(cur.left!=null)\\n                {\\n                    civiling_sum+=cur.left.val;\\n                    q.add(cur.left);\\n                }\\n                \\n                if(cur.right!=null)\\n                {\\n                    civiling_sum+=cur.right.val;\\n                    q.add(cur.right);\\n                }\\n                if(lev>=1){\\n                     if(cur.left!=null){\\n                          \\n                        cur.left.val=sum.get(lev+1)-civiling_sum;\\n                     }\\n                    if(cur.right!=null){\\n                        cur.right.val=sum.get(lev+1)-civiling_sum;\\n                     }\\n                }\\n            }\\n        }\\n        return root;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441647,
                "title": "hash-map-approach",
                "content": "class Solution {\\n    \\n    HashMap<Integer,Integer>map;\\n    HashMap<TreeNode,Integer>originalvalue;\\n    \\n    public void dfs(TreeNode root,int level){\\n        if(root==null)\\n            return;\\n        \\n        originalvalue.put(root,root.val);\\n        if(map.containsKey(level)){\\n            map.put(level,map.get(level)+root.val);\\n        }\\n        else\\n            map.put(level,root.val);\\n        \\n        dfs(root.left,level+1);\\n        dfs(root.right,level+1);\\n        \\n    }\\n    \\n    public void dfs2(TreeNode root,TreeNode par,int level){\\n        if(root==null){\\n            return;\\n        }\\n        \\n        if(par==null){\\n            root.val=0;\\n        }\\n        else{\\n            int total=map.get(level);\\n            if(par.left!=null)\\n                total-=originalvalue.get(par.left);\\n            if(par.right!=null)\\n                total-=originalvalue.get(par.right);\\n            root.val=total;\\n        }\\n        \\n        dfs2(root.left,root,level+1);\\n        dfs2(root.right,root,level+1);\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        map=new HashMap<Integer,Integer>();\\n        originalvalue=new HashMap<>();\\n        dfs(root,1);\\n        \\n        for(int i=1;i<=3;i++)\\n            System.out.println(i+\" \"+map.get(i));\\n        \\n        dfs2(root,null,1);\\n        \\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    HashMap<Integer,Integer>map;\\n    HashMap<TreeNode,Integer>originalvalue;\\n    \\n    public void dfs(TreeNode root,int level){\\n        if(root==null)\\n            return;\\n        \\n        originalvalue.put(root,root.val);\\n        if(map.containsKey(level)){\\n            map.put(level,map.get(level)+root.val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3437493,
                "title": "java-6ms-100-bfs-speed-optimized-explanation-fastest",
                "content": "The following code uses a Breadth-First-Search (BFS) to descend through the levels of the tree to modify the tree to contain cousin sums.  \\n\\nThis code is optimized for execution speed.  It could be simpler and more general case, and therefore more readable, but those simplifications are slower.  Unless execution speed is needed, the simpler and more generalized coding techniques are usually thought of as better coding practices, because they are easier to modify, handle changes of requirements better, and are easier to maintain over time.  If at a job interview, using speed optimized code such as this takes more time to create, and is more difficult for the interviewer to read.  Using the simpler more general case code is usually thought of as better coding practices.  When creating code at an interview, I feel it is good to ask the interviewer what their priorities are, such as time to complete the coding, readability, commenting and documenting, execition time, error and bad input handling, etc.  This lets me create code to better meet the interviewer\\'s expectations, lets the interviewer know that I consider these priorities before coding, and gives the impression that I can write the code for any of these priorities.\\n\\nTo get faster execution speed, the code below uses a single `TreeNode[]` array to contain breadth first search\\'s list of tree nodes on a single level.  Using an array has faster execution time than a `Queue` or an `ArrayList` class.  The array actually contains two lists of TreeNode\\'s.  One list is the current level for the BFS, while the other is the list being built for the next BFS level.  Within the array, these lists alternate between being built from the start of the array going forward, and from the end of the array going backward.  As the list for the current BFS level is processed, it is shrinking, while the list that is being built for the next BFS level is growing, making for less needed space in the array, because the array will never have to hold complete lists for both current and next level at the same time.  One list is shrinking as the other list is growing.  The array has to be big enough for the worst case storage requirements, which will be (max_number_of_nodes+1)/2 = 100_001/2 = 50_000.\\n\\nIn April 2023, this code ran as fast as 6ms.  The next fastest code on the runtime graph was 12ms, which used two `Queue` for its BFS lists.\\n\\nIf useful, please upvote.\\n```\\nclass Solution {\\n    // The nodes[] array contains the list of nodes for a breadth \\n    // first search (BFS) of a level of the tree, while building \\n    // the list of nodes for the BFS for the next level.  These \\n    // two lists are stored in the nodes[] array at the same time.  \\n    // One list, the \"left\" list, is built from the start of \\n    // nodes[] going upward in the array.  The other list, the \\n    // \"right\" list, is built from the end of nodes[] going \\n    // downward.  Because the tree has a maximum of 100_000 (10^5) \\n    // nodes, we will need an array of size 100_000/2 == 50_000 \\n    // to simultaneously hold both lists in the same array.  \\n    // But for this leetcode problem\\'s test cases in April 2023, \\n    // an array length of 9000 is long enough.  By making this \\n    // array a static, the array will only be allocated once for \\n    // all the leetcode problem\\'s test cases, instead of allocating \\n    // the array again for each test case, which would require \\n    // slower runtime.\\n    static final TreeNode[] nodes = new TreeNode[50_000];\\n    \\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        nodes[0] = root;\\n        int sumL = root.val;\\n        int sumR = 0;\\n        final int startL = 0;\\n        final int startR = nodes.length - 1;\\n        int lastL = startL + 1;\\n        int lastR = startR;\\n        TreeNode node = null;\\n        \\n        // Loop through the levels of the tree in a breadth first \\n        // search (BFS) of the tree nodes.  Each time through this \\n        // loop processes the next two levels of the tree.  First \\n        // processing the list of nodes on the left side of nodes[] \\n        // while building the list of the next level\\'s nodes on \\n        // the right side of nodes[].  Then secondly, processing \\n        // the list of nodes on the right side of nodes[] while \\n        // building the list of the next level\\'s nodes on the left \\n        // side of nodes[].\\n        while (lastL != 0) {\\n            // Process the list of nodes on the left side of nodes[] \\n            // while building the list of the next level\\'s nodes on \\n            // the right side of nodes[].\\n            sumR = 0;\\n            while (lastL > 0) {\\n                node = nodes[--lastL];\\n                node.val = sumL - node.val;\\n                if (node.left != null) {\\n                    if (node.right != null) {    // If two children.\\n                        sumR += node.left.val = node.right.val = \\n                                    node.left.val + node.right.val;\\n                        nodes[lastR--] = node.left;\\n                        nodes[lastR--] = node.right;\\n                    } else {                     // If left child only.\\n                        sumR += node.left.val;\\n                        nodes[lastR--] = node.left;\\n                    }\\n                } else if (node.right != null) { // If right child only.\\n                    sumR += node.right.val;\\n                    nodes[lastR--] = node.right;\\n                }\\n            }\\n            if (lastR == startR)  break;    // If no more levels.\\n            // Process the list of nodes on the right side of \\n            // nodes[] while building the list of the next level\\'s \\n            // nodes on the left side of nodes[].\\n            sumL = 0;\\n            while (lastR < startR) {\\n                node = nodes[++lastR];\\n                node.val = sumR - node.val;\\n                if (node.left != null) {\\n                    if (node.right != null) {    // If two children.\\n                        sumL += node.left.val = node.right.val = \\n                                    node.left.val + node.right.val;\\n                        nodes[lastL++] = node.left;\\n                        nodes[lastL++] = node.right;\\n                    } else {                     // If left child only.\\n                        sumL += node.left.val;\\n                        nodes[lastL++] = node.left;\\n                    }\\n                } else if (node.right != null) { // If right child only.\\n                    sumL += node.right.val;\\n                    nodes[lastL++] = node.right;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    // The nodes[] array contains the list of nodes for a breadth \\n    // first search (BFS) of a level of the tree, while building \\n    // the list of nodes for the BFS for the next level.  These \\n    // two lists are stored in the nodes[] array at the same time.  \\n    // One list, the \"left\" list, is built from the start of \\n    // nodes[] going upward in the array.  The other list, the \\n    // \"right\" list, is built from the end of nodes[] going \\n    // downward.  Because the tree has a maximum of 100_000 (10^5) \\n    // nodes, we will need an array of size 100_000/2 == 50_000 \\n    // to simultaneously hold both lists in the same array.  \\n    // But for this leetcode problem\\'s test cases in April 2023, \\n    // an array length of 9000 is long enough.  By making this \\n    // array a static, the array will only be allocated once for \\n    // all the leetcode problem\\'s test cases, instead of allocating \\n    // the array again for each test case, which would require \\n    // slower runtime.\\n    static final TreeNode[] nodes = new TreeNode[50_000];\\n    \\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        nodes[0] = root;\\n        int sumL = root.val;\\n        int sumR = 0;\\n        final int startL = 0;\\n        final int startR = nodes.length - 1;\\n        int lastL = startL + 1;\\n        int lastR = startR;\\n        TreeNode node = null;\\n        \\n        // Loop through the levels of the tree in a breadth first \\n        // search (BFS) of the tree nodes.  Each time through this \\n        // loop processes the next two levels of the tree.  First \\n        // processing the list of nodes on the left side of nodes[] \\n        // while building the list of the next level\\'s nodes on \\n        // the right side of nodes[].  Then secondly, processing \\n        // the list of nodes on the right side of nodes[] while \\n        // building the list of the next level\\'s nodes on the left \\n        // side of nodes[].\\n        while (lastL != 0) {\\n            // Process the list of nodes on the left side of nodes[] \\n            // while building the list of the next level\\'s nodes on \\n            // the right side of nodes[].\\n            sumR = 0;\\n            while (lastL > 0) {\\n                node = nodes[--lastL];\\n                node.val = sumL - node.val;\\n                if (node.left != null) {\\n                    if (node.right != null) {    // If two children.\\n                        sumR += node.left.val = node.right.val = \\n                                    node.left.val + node.right.val;\\n                        nodes[lastR--] = node.left;\\n                        nodes[lastR--] = node.right;\\n                    } else {                     // If left child only.\\n                        sumR += node.left.val;\\n                        nodes[lastR--] = node.left;\\n                    }\\n                } else if (node.right != null) { // If right child only.\\n                    sumR += node.right.val;\\n                    nodes[lastR--] = node.right;\\n                }\\n            }\\n            if (lastR == startR)  break;    // If no more levels.\\n            // Process the list of nodes on the right side of \\n            // nodes[] while building the list of the next level\\'s \\n            // nodes on the left side of nodes[].\\n            sumL = 0;\\n            while (lastR < startR) {\\n                node = nodes[++lastR];\\n                node.val = sumR - node.val;\\n                if (node.left != null) {\\n                    if (node.right != null) {    // If two children.\\n                        sumL += node.left.val = node.right.val = \\n                                    node.left.val + node.right.val;\\n                        nodes[lastL++] = node.left;\\n                        nodes[lastL++] = node.right;\\n                    } else {                     // If left child only.\\n                        sumL += node.left.val;\\n                        nodes[lastL++] = node.left;\\n                    }\\n                } else if (node.right != null) { // If right child only.\\n                    sumL += node.right.val;\\n                    nodes[lastL++] = node.right;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431529,
                "title": "c-bfs-sum-at-each-level-dfs-calculate-for-each-child",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n        void dfs2(TreeNode* root,vector<int>&dep,int d){\\n        if(root==NULL || d+1==dep.size())\\n        return ;\\n\\n        int l=(root->left)?root->left->val:0;\\n        int r=(root->right)?root->right->val:0;\\n\\n        if((l+r<=dep[d+1])){\\n            if(l!=0)\\n            root->left->val=(dep[d+1]-(l+r));\\n\\n            if(r!=0)\\n            root->right->val=(dep[d+1]-(l+r));\\n        }\\n        dfs2(root->left,dep,d+1);\\n        dfs2(root->right,dep,d+1);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int>dep;\\n\\n         int level=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        dep.push_back(0);  \\n            \\n        while(q.empty()==false){\\n           int size=q.size();\\n           int sum=0;\\n        \\n            for(int i=0;i<size;i++){\\n                TreeNode* node = q.front();\\n                 q.pop();\\n                 if(node->left){\\n                      q.push(node->left);\\n                      sum+=node->left->val;\\n                 }  \\n               if (node->right){\\n                  q.push(node->right);\\n                  sum+=node->right->val;\\n               }\\n                 \\n            }\\n            if(!q.empty())\\n            dep.push_back(sum);    \\n        }\\n\\n        dfs2(root,dep,0);\\n        root->val=0;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n        void dfs2(TreeNode* root,vector<int>&dep,int d){\\n        if(root==NULL || d+1==dep.size())\\n        return ;\\n\\n        int l=(root->left)?root->left->val:0;\\n        int r=(root->right)?root->right->val:0;\\n\\n        if((l+r<=dep[d+1])){\\n            if(l!=0)\\n            root->left->val=(dep[d+1]-(l+r));\\n\\n            if(r!=0)\\n            root->right->val=(dep[d+1]-(l+r));\\n        }\\n        dfs2(root->left,dep,d+1);\\n        dfs2(root->right,dep,d+1);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int>dep;\\n\\n         int level=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        dep.push_back(0);  \\n            \\n        while(q.empty()==false){\\n           int size=q.size();\\n           int sum=0;\\n        \\n            for(int i=0;i<size;i++){\\n                TreeNode* node = q.front();\\n                 q.pop();\\n                 if(node->left){\\n                      q.push(node->left);\\n                      sum+=node->left->val;\\n                 }  \\n               if (node->right){\\n                  q.push(node->right);\\n                  sum+=node->right->val;\\n               }\\n                 \\n            }\\n            if(!q.empty())\\n            dep.push_back(sum);    \\n        }\\n\\n        dfs2(root,dep,0);\\n        root->val=0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427575,
                "title": "bfs-and-childsum-easy-to-understand",
                "content": "Please UpVote if you  like the solution !\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea here is store every node\\'s child value for future reference i.e **futureSum** and a temporary sum which stores the sum for the siblings sum and then assign those siblings node their sibling sum i.e **tempsum** , after one level we have our **totalSum** in the form of **futureSum**. And the node for which we doing these calculations just assign totalSum-siblingsSum.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        unordered_map<TreeNode*,int>mp;\\n        TreeNode* r = root;\\n        if(root == NULL)\\n            return r;\\n        q.push(root);\\n        int totalSum = root->val;\\n        mp[root] = root->val;\\n        while(!q.empty())\\n        {\\n            int size = q.size(), futureSum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n                int tempsum = 0;\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left){ \\n                    q.push(node->left);\\n                    futureSum += node->left->val; \\n                    tempsum += node->left->val;\\n                }\\n                    \\n                if(node->right){\\n                    q.push(node->right);\\n                    futureSum += node->right->val;\\n                    tempsum += node->right->val;\\n                }\\n                \\n                if(node->left)\\n                    mp[node->left] = tempsum;\\n                if(node->right)\\n                    mp[node->right] = tempsum;\\n\\n                node->val = totalSum-mp[node];\\n                mp.erase(node);\\n            }\\n            totalSum = futureSum;\\n         }\\n        return r;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        unordered_map<TreeNode*,int>mp;\\n        TreeNode* r = root;\\n        if(root == NULL)\\n            return r;\\n        q.push(root);\\n        int totalSum = root->val;\\n        mp[root] = root->val;\\n        while(!q.empty())\\n        {\\n            int size = q.size(), futureSum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n                int tempsum = 0;\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left){ \\n                    q.push(node->left);\\n                    futureSum += node->left->val; \\n                    tempsum += node->left->val;\\n                }\\n                    \\n                if(node->right){\\n                    q.push(node->right);\\n                    futureSum += node->right->val;\\n                    tempsum += node->right->val;\\n                }\\n                \\n                if(node->left)\\n                    mp[node->left] = tempsum;\\n                if(node->right)\\n                    mp[node->right] = tempsum;\\n\\n                node->val = totalSum-mp[node];\\n                mp.erase(node);\\n            }\\n            totalSum = futureSum;\\n         }\\n        return r;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426376,
                "title": "a-simple-bfs-with-one-time-traversal",
                "content": "```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        \\n        Queue<Pair<TreeNode,Integer>> q = new LinkedList<>();\\n        \\n        q.offer(new Pair(root,0));\\n        \\n        int totalSumAtSameHeight = 0;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int k=q.size();\\n            \\n            int prev = totalSumAtSameHeight;\\n            totalSumAtSameHeight = 0;\\n            \\n            while(k-->0){\\n                \\n                Pair<TreeNode,Integer> p=q.poll();\\n                \\n                int siblingSum = 0;\\n                \\n                TreeNode curr = p.getKey();\\n                \\n                if(curr.left!=null){\\n                    siblingSum += curr.left.val;\\n                    totalSumAtSameHeight += curr.left.val;\\n                }\\n                \\n                if(curr.right!=null){\\n                    siblingSum += curr.right.val;\\n                    totalSumAtSameHeight += curr.right.val;\\n\\n                }\\n                \\n                if(p.getKey().left!=null){\\n                    q.offer(new Pair(curr.left, siblingSum));\\n                }\\n                \\n                if(p.getKey().right!=null){\\n                    q.offer(new Pair(curr.right, siblingSum));\\n                }\\n                \\n                curr.val = prev - p.getValue();\\n            }\\n            \\n        }\\n        \\n        \\n        return root;\\n        \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        \\n        Queue<Pair<TreeNode,Integer>> q = new LinkedList<>();\\n        \\n        q.offer(new Pair(root,0));\\n        \\n        int totalSumAtSameHeight = 0;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int k=q.size();\\n            \\n            int prev = totalSumAtSameHeight;\\n            totalSumAtSameHeight = 0;\\n            \\n            while(k-->0){\\n                \\n                Pair<TreeNode,Integer> p=q.poll();\\n                \\n                int siblingSum = 0;\\n                \\n                TreeNode curr = p.getKey();\\n                \\n                if(curr.left!=null){\\n                    siblingSum += curr.left.val;\\n                    totalSumAtSameHeight += curr.left.val;\\n                }\\n                \\n                if(curr.right!=null){\\n                    siblingSum += curr.right.val;\\n                    totalSumAtSameHeight += curr.right.val;\\n\\n                }\\n                \\n                if(p.getKey().left!=null){\\n                    q.offer(new Pair(curr.left, siblingSum));\\n                }\\n                \\n                if(p.getKey().right!=null){\\n                    q.offer(new Pair(curr.right, siblingSum));\\n                }\\n                \\n                curr.val = prev - p.getValue();\\n            }\\n            \\n        }\\n        \\n        \\n        return root;\\n        \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425996,
                "title": "100-beats-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    class Pair{\\n        TreeNode node;\\n        TreeNode parent;\\n        Pair(TreeNode node, TreeNode parent){\\n            this.node = node;\\n            this.parent = parent;\\n        }\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<Pair> que = new LinkedList<>();\\n        que.add(new Pair(root,null));\\n        while(que.size() > 0){\\n            int sz = que.size();\\n            HashMap<TreeNode, Integer> map = new HashMap<>();\\n            ArrayList<Pair> kids = new ArrayList<>();\\n            int totalsum = 0;\\n            while(sz-- > 0){\\n                Pair rem = que.remove();\\n                totalsum += rem.node.val;\\n                kids.add(rem);\\n                if(map.containsKey(rem.parent) == false){\\n                    map.put(rem.parent,rem.node.val);\\n                }else{\\n                    map.put(rem.parent, map.get(rem.parent) + rem.node.val);\\n                }\\n                if(rem.node.left != null){\\n                    que.add(new Pair(rem.node.left,rem.node));\\n                }\\n                if(rem.node.right != null){\\n                    que.add(new Pair(rem.node.right,rem.node));\\n                }\\n            }\\n            for(Pair kid: kids){\\n                kid.node.val = totalsum - map.get(kid.parent);\\n            }            \\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    class Pair{\\n        TreeNode node;\\n        TreeNode parent;\\n        Pair(TreeNode node, TreeNode parent){\\n            this.node = node;\\n            this.parent = parent;\\n        }\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<Pair> que = new LinkedList<>();\\n        que.add(new Pair(root,null));\\n        while(que.size() > 0){\\n            int sz = que.size();\\n            HashMap<TreeNode, Integer> map = new HashMap<>();\\n            ArrayList<Pair> kids = new ArrayList<>();\\n            int totalsum = 0;\\n            while(sz-- > 0){\\n                Pair rem = que.remove();\\n                totalsum += rem.node.val;\\n                kids.add(rem);\\n                if(map.containsKey(rem.parent) == false){\\n                    map.put(rem.parent,rem.node.val);\\n                }else{\\n                    map.put(rem.parent, map.get(rem.parent) + rem.node.val);\\n                }\\n                if(rem.node.left != null){\\n                    que.add(new Pair(rem.node.left,rem.node));\\n                }\\n                if(rem.node.right != null){\\n                    que.add(new Pair(rem.node.right,rem.node));\\n                }\\n            }\\n            for(Pair kid: kids){\\n                kid.node.val = totalsum - map.get(kid.parent);\\n            }            \\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425973,
                "title": "parent-tracking-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n{\\n    unordered_map<TreeNode*,TreeNode*>mp;\\n\\tfillmap(root,mp);         \\n\\t\\n\\tint level=0;\\n    unordered_map<int,int>level_sum;\\n    dfs(root,level_sum,level);\\n    \\n    //now preforming the bfs stuff\\n    queue<TreeNode*>q;\\n    q.push(root);\\n    level = 0;\\n    \\n    unordered_map<int,vector<int>>result;  //temporory map to store the result\\n    while(!q.empty())\\n    {\\n    \\tint size = q.size();\\n    \\tfor(int i=0;i<size;i++)\\n    \\t{\\n    \\t\\tTreeNode* temp = q.front();\\n    \\t\\tq.pop();\\n    \\t\\t\\n    \\t\\tif(temp == root)\\n    \\t\\t{\\n    \\t\\t\\tresult[level].push_back(0);\\n\\t\\t\\t}\\n\\t\\t\\telse \\n\\t\\t\\t{\\n\\t\\t\\t\\tint levelsum  = level_sum[level];\\n\\t\\t\\t\\tTreeNode* par = mp[temp];\\n                //7 9\\n                //10 4\\n                //1 4\\n                //9 5\\n                //4 5\\n                if(par->left != NULL)\\n                levelsum = levelsum - (par->left->val);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(par->right != NULL)\\n\\t\\t\\t\\tlevelsum = levelsum - (par->right->val);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tresult[level].push_back(levelsum); \\n\\t\\t\\t}\\n\\t\\t\\tif(temp->left != NULL)\\n\\t\\t\\tq.push(temp->left);\\n\\t\\t\\t\\n\\t\\t\\tif(temp->right != NULL)\\n\\t\\t\\tq.push(temp->right);\\n\\t\\t}\\n\\t\\tlevel++;\\n    }\\n\\t\\n\\t//making the queue empty\\n\\twhile(!q.empty())\\n\\tq.pop();\\n\\t\\n    //again doing the bsf to fill the valus in the tree\\n\\tq.push(root);\\n\\tlevel = 0;\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tint idx = 0;\\n\\t\\tint size = q.size();\\n\\t\\tfor(int i=0;i<size;i++)\\n\\t\\t{\\n\\t\\t\\tTreeNode* temp = q.front();\\n\\t\\t\\ttemp->val = result[level][idx];\\n\\t\\t\\tidx++;\\n\\t\\t\\tq.pop();\\n\\t\\t\\t\\n\\t\\t\\tif(temp->left != NULL)\\n\\t\\t\\tq.push(temp->left);\\n\\t\\t\\t\\n\\t\\t\\tif(temp->right != NULL)\\n\\t\\t\\tq.push(temp->right);\\n\\t\\t}\\n\\t\\tlevel++;\\n\\t}\\n\\treturn root;\\n}\\nvoid dfs(TreeNode* root,unordered_map<int,int>&level_sum,int level)\\n{\\n\\tif(root == NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\tlevel_sum[level]+=root->val;\\n\\tdfs(root->left,level_sum,level+1);\\n\\tdfs(root->right,level_sum,level+1);\\n}\\nvoid fillmap(TreeNode* root,unordered_map<TreeNode*,TreeNode*>&mp)\\n{\\n\\tif(root == NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t//if the left child exist\\n\\tif(root->left != NULL)\\n\\t{\\n\\t\\tmp[root->left] = root;\\n\\t}\\n\\t//if the right child exist\\n\\tif(root->right != NULL)\\n\\t{\\n\\t\\tmp[root->right] = root;\\n\\t}\\n\\tfillmap(root->left,mp);\\n\\tfillmap(root->right,mp);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n{\\n    unordered_map<TreeNode*,TreeNode*>mp;\\n\\tfillmap(root,mp);         \\n\\t\\n\\tint level=0;\\n    unordered_map<int,int>level_sum;\\n    dfs(root,level_sum,level);\\n    \\n    //now preforming the bfs stuff\\n    queue<TreeNode*>q;\\n    q.push(root);\\n    level = 0;\\n    \\n    unordered_map<int,vector<int>>result;  //temporory map to store the result\\n    while(!q.empty())\\n    {\\n    \\tint size = q.size();\\n    \\tfor(int i=0;i<size;i++)\\n    \\t{\\n    \\t\\tTreeNode* temp = q.front();\\n    \\t\\tq.pop();\\n    \\t\\t\\n    \\t\\tif(temp == root)\\n    \\t\\t{\\n    \\t\\t\\tresult[level].push_back(0);\\n\\t\\t\\t}\\n\\t\\t\\telse \\n\\t\\t\\t{\\n\\t\\t\\t\\tint levelsum  = level_sum[level];\\n\\t\\t\\t\\tTreeNode* par = mp[temp];\\n                //7 9\\n                //10 4\\n                //1 4\\n                //9 5\\n                //4 5\\n                if(par->left != NULL)\\n                levelsum = levelsum - (par->left->val);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(par->right != NULL)\\n\\t\\t\\t\\tlevelsum = levelsum - (par->right->val);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tresult[level].push_back(levelsum); \\n\\t\\t\\t}\\n\\t\\t\\tif(temp->left != NULL)\\n\\t\\t\\tq.push(temp->left);\\n\\t\\t\\t\\n\\t\\t\\tif(temp->right != NULL)\\n\\t\\t\\tq.push(temp->right);\\n\\t\\t}\\n\\t\\tlevel++;\\n    }\\n\\t\\n\\t//making the queue empty\\n\\twhile(!q.empty())\\n\\tq.pop();\\n\\t\\n    //again doing the bsf to fill the valus in the tree\\n\\tq.push(root);\\n\\tlevel = 0;\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tint idx = 0;\\n\\t\\tint size = q.size();\\n\\t\\tfor(int i=0;i<size;i++)\\n\\t\\t{\\n\\t\\t\\tTreeNode* temp = q.front();\\n\\t\\t\\ttemp->val = result[level][idx];\\n\\t\\t\\tidx++;\\n\\t\\t\\tq.pop();\\n\\t\\t\\t\\n\\t\\t\\tif(temp->left != NULL)\\n\\t\\t\\tq.push(temp->left);\\n\\t\\t\\t\\n\\t\\t\\tif(temp->right != NULL)\\n\\t\\t\\tq.push(temp->right);\\n\\t\\t}\\n\\t\\tlevel++;\\n\\t}\\n\\treturn root;\\n}\\nvoid dfs(TreeNode* root,unordered_map<int,int>&level_sum,int level)\\n{\\n\\tif(root == NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\tlevel_sum[level]+=root->val;\\n\\tdfs(root->left,level_sum,level+1);\\n\\tdfs(root->right,level_sum,level+1);\\n}\\nvoid fillmap(TreeNode* root,unordered_map<TreeNode*,TreeNode*>&mp)\\n{\\n\\tif(root == NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t//if the left child exist\\n\\tif(root->left != NULL)\\n\\t{\\n\\t\\tmp[root->left] = root;\\n\\t}\\n\\t//if the right child exist\\n\\tif(root->right != NULL)\\n\\t{\\n\\t\\tmp[root->right] = root;\\n\\t}\\n\\tfillmap(root->left,mp);\\n\\tfillmap(root->right,mp);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424785,
                "title": "c-single-bfs-faster-92",
                "content": "**Intiution**\\n- To store metadata for each node in a data structure, we incorporate a wrapper node that holds the sum of the values of two siblings.\\n- This strategy is crucial in allowing us to perform subtraction of the `sum of values of two siblings` from the `total value sum` at every level.\\n- Then we sinply run `BFS` fro level order traversal.\\n\\n**Code**\\n```c++\\nstruct NodeWrapper {\\n    TreeNode* inner = NULL;\\n    int sibling_val_sum = 0;\\n    NodeWrapper(TreeNode* inner, int sibling_val_sum): inner(inner), sibling_val_sum(sibling_val_sum) {}\\n};\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<NodeWrapper*> q{ new NodeWrapper(root, root->val) };\\n        \\n        while (q.size()) {\\n            int sum = 0;\\n            for (auto w: q) sum += w->inner->val;\\n            \\n            vector<NodeWrapper*> t;\\n            for (auto w: q) {\\n                auto n = w->inner; int total = w->sibling_val_sum;\\n                n->val = sum - total;\\n                \\n                auto sum = (n->left ? n->left->val: 0) + (n->right ? n->right->val: 0);\\n                \\n                if (n->left) t.push_back(new NodeWrapper(n->left, sum));\\n                if (n->right) t.push_back(new NodeWrapper(n->right, sum));\\n            }\\n            q = t;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nstruct NodeWrapper {\\n    TreeNode* inner = NULL;\\n    int sibling_val_sum = 0;\\n    NodeWrapper(TreeNode* inner, int sibling_val_sum): inner(inner), sibling_val_sum(sibling_val_sum) {}\\n};\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<NodeWrapper*> q{ new NodeWrapper(root, root->val) };\\n        \\n        while (q.size()) {\\n            int sum = 0;\\n            for (auto w: q) sum += w->inner->val;\\n            \\n            vector<NodeWrapper*> t;\\n            for (auto w: q) {\\n                auto n = w->inner; int total = w->sibling_val_sum;\\n                n->val = sum - total;\\n                \\n                auto sum = (n->left ? n->left->val: 0) + (n->right ? n->right->val: 0);\\n                \\n                if (n->left) t.push_back(new NodeWrapper(n->left, sum));\\n                if (n->right) t.push_back(new NodeWrapper(n->right, sum));\\n            }\\n            q = t;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424011,
                "title": "c-code-for-this-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsolve this problem by storing the parent of each node and \\nvalue corresponding to each node\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void solve(TreeNode *root,map<TreeNode*,TreeNode*> &mp){\\n        if(root == NULL){\\n            return;\\n        }\\n        if(root->left)mp[root->left] = root;\\n        if(root->right)mp[root->right] = root;\\n        \\n        solve(root->left,mp);\\n        solve(root->right,mp);\\n    }\\n    void accvalue(TreeNode *root,unordered_map<TreeNode*,int> &mp){\\n        if(root == NULL)return;\\n        mp[root] = root->val;\\n        accvalue(root->left,mp);\\n        accvalue(root->right,mp);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        if(root == NULL)return NULL;\\n        map<TreeNode*,TreeNode*> mp;\\n        solve(root,mp);\\n        mp[root] = NULL;\\n        unordered_map<TreeNode*,int> m;\\n        accvalue(root,m);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        vector<int> ans;\\n        while(q.empty() == false){\\n            int n = q.size();\\n            int sum = 0;\\n            for(int i=0;i<n;i++){\\n                TreeNode *currnode = q.front();\\n                q.pop();\\n                sum+=currnode->val;\\n                if(currnode->left)q.push(currnode->left);\\n                if(currnode->right)q.push(currnode->right);\\n            }\\n            ans.push_back(sum);\\n        }\\n        \\n        queue<TreeNode*> pq;\\n        pq.push(root);\\n        int ptr = 0;\\n        while(pq.empty() == false){\\n            int n = pq.size();\\n            int levelsum = ans[ptr++];\\n            for(int i=0;i<n;i++){\\n                TreeNode *currnode= pq.front();\\n                pq.pop();\\n                TreeNode *par = mp[currnode];\\n                if(par == NULL){\\n                    currnode->val = 0;\\n                }\\n                else if(par->left == currnode){\\n                   // if(par->right)cout<<m[par->right]<<endl;\\n                    if(par->right)currnode->val = levelsum - currnode->val - m[par->right];\\n                    else currnode->val = levelsum - currnode->val;\\n                }\\n                else if(par->right == currnode){\\n                    if(par->left)cout<<m[par->left]<<endl;\\n                    if(par->left)currnode->val = levelsum - currnode->val - m[par->left];\\n                    else currnode->val = levelsum - currnode->val;\\n                }\\n                if(currnode->left)pq.push(currnode->left);\\n                if(currnode->right)pq.push(currnode->right);\\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void solve(TreeNode *root,map<TreeNode*,TreeNode*> &mp){\\n        if(root == NULL){\\n            return;\\n        }\\n        if(root->left)mp[root->left] = root;\\n        if(root->right)mp[root->right] = root;\\n        \\n        solve(root->left,mp);\\n        solve(root->right,mp);\\n    }\\n    void accvalue(TreeNode *root,unordered_map<TreeNode*,int> &mp){\\n        if(root == NULL)return;\\n        mp[root] = root->val;\\n        accvalue(root->left,mp);\\n        accvalue(root->right,mp);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        if(root == NULL)return NULL;\\n        map<TreeNode*,TreeNode*> mp;\\n        solve(root,mp);\\n        mp[root] = NULL;\\n        unordered_map<TreeNode*,int> m;\\n        accvalue(root,m);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        vector<int> ans;\\n        while(q.empty() == false){\\n            int n = q.size();\\n            int sum = 0;\\n            for(int i=0;i<n;i++){\\n                TreeNode *currnode = q.front();\\n                q.pop();\\n                sum+=currnode->val;\\n                if(currnode->left)q.push(currnode->left);\\n                if(currnode->right)q.push(currnode->right);\\n            }\\n            ans.push_back(sum);\\n        }\\n        \\n        queue<TreeNode*> pq;\\n        pq.push(root);\\n        int ptr = 0;\\n        while(pq.empty() == false){\\n            int n = pq.size();\\n            int levelsum = ans[ptr++];\\n            for(int i=0;i<n;i++){\\n                TreeNode *currnode= pq.front();\\n                pq.pop();\\n                TreeNode *par = mp[currnode];\\n                if(par == NULL){\\n                    currnode->val = 0;\\n                }\\n                else if(par->left == currnode){\\n                   // if(par->right)cout<<m[par->right]<<endl;\\n                    if(par->right)currnode->val = levelsum - currnode->val - m[par->right];\\n                    else currnode->val = levelsum - currnode->val;\\n                }\\n                else if(par->right == currnode){\\n                    if(par->left)cout<<m[par->left]<<endl;\\n                    if(par->left)currnode->val = levelsum - currnode->val - m[par->left];\\n                    else currnode->val = levelsum - currnode->val;\\n                }\\n                if(currnode->left)pq.push(currnode->left);\\n                if(currnode->right)pq.push(currnode->right);\\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3423874,
                "title": "bfs-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n        \\n        while(q.size()) {\\n            int n = q.size(), levelSum = 0;\\n            vector<pair<TreeNode*, int>> v;\\n            \\n            for(int i=0; i<n; i++) {\\n                TreeNode* temp = q.front().first;\\n                int value = q.front().second; q.pop();\\n                v.push_back({temp, value});\\n\\n                if(temp -> left) levelSum += temp -> left -> val;\\n                if(temp -> right)  levelSum += temp -> right -> val;\\n            }\\n            for(int i=0; i<n; i++) {\\n                TreeNode* temp = v[i].first;\\n                int value = v[i].second;\\n                \\n                if(temp -> left) {\\n                    q.push({temp -> left, levelSum - temp -> left -> val - (temp -> right ? temp -> right -> val : 0)});\\n                }\\n                if(temp -> right) {\\n                    q.push({temp -> right, levelSum - temp -> right -> val - (temp -> left ? temp -> left -> val : 0)});\\n                }\\n                temp -> val = value;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n        \\n        while(q.size()) {\\n            int n = q.size(), levelSum = 0;\\n            vector<pair<TreeNode*, int>> v;\\n            \\n            for(int i=0; i<n; i++) {\\n                TreeNode* temp = q.front().first;\\n                int value = q.front().second; q.pop();\\n                v.push_back({temp, value});\\n\\n                if(temp -> left) levelSum += temp -> left -> val;\\n                if(temp -> right)  levelSum += temp -> right -> val;\\n            }\\n            for(int i=0; i<n; i++) {\\n                TreeNode* temp = v[i].first;\\n                int value = v[i].second;\\n                \\n                if(temp -> left) {\\n                    q.push({temp -> left, levelSum - temp -> left -> val - (temp -> right ? temp -> right -> val : 0)});\\n                }\\n                if(temp -> right) {\\n                    q.push({temp -> right, levelSum - temp -> right -> val - (temp -> left ? temp -> left -> val : 0)});\\n                }\\n                temp -> val = value;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423709,
                "title": "java-beats-100-bfs",
                "content": "My idea was simple. \\n\\nTraverse every node in Tree with BFS. In every level traverse twice.\\nHashMap map is used to find the parent\\'s value\\nHashMap nodes is used to find the parent node of the node\\n\\n- First is to find the total of the all values.\\n- Second is to find the value of the node ( total - parent\\'s value). And the node is added to`nodes` map as parent with its children if they exist. And the total of left and right children are added to `map` \\n\\nRoot.val is never changed. So,` root.val=0` then we can return root safely. \\n```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        HashMap<TreeNode, Integer> map = new HashMap<>();\\n        HashMap<TreeNode, TreeNode> nodes = new HashMap<>();    \\n        q.add(root);\\n        \\n        while(!q.isEmpty()){\\n            int size= q.size();\\n            int total= 0;\\n            for(TreeNode t: q) total+= t.val;\\n            for(int i=0; i<size; i++){\\n                TreeNode curr = q.poll();        \\n                if(curr != root){  // to avoid null pointer exception\\n                    TreeNode parent = nodes.get(curr);\\n                    curr.val = total - map.get(parent);\\n                }\\n                int left = 0;\\n                int right= 0;\\n                if(curr.left != null){ \\n                    left = curr.left.val;\\n                    q.add(curr.left);\\n                    nodes.put(curr.left, curr);\\n                }\\n                if(curr.right != null){\\n                    right = curr.right.val;\\n                    q.add(curr.right);\\n                    nodes.put(curr.right, curr);\\n                }\\n                map.put(curr, left+right);\\n            }\\n        }\\n        root.val = 0;\\n        return root;\\n    }\\n}\\n```\\nIf the data is correct, it is pretty efficient. \\n![image](https://assets.leetcode.com/users/images/249c1a0f-d481-419e-8129-c1b2fd29f415_1681652315.6029444.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        HashMap<TreeNode, Integer> map = new HashMap<>();\\n        HashMap<TreeNode, TreeNode> nodes = new HashMap<>();    \\n        q.add(root);\\n        \\n        while(!q.isEmpty()){\\n            int size= q.size();\\n            int total= 0;\\n            for(TreeNode t: q) total+= t.val;\\n            for(int i=0; i<size; i++){\\n                TreeNode curr = q.poll();        \\n                if(curr != root){  // to avoid null pointer exception\\n                    TreeNode parent = nodes.get(curr);\\n                    curr.val = total - map.get(parent);\\n                }\\n                int left = 0;\\n                int right= 0;\\n                if(curr.left != null){ \\n                    left = curr.left.val;\\n                    q.add(curr.left);\\n                    nodes.put(curr.left, curr);\\n                }\\n                if(curr.right != null){\\n                    right = curr.right.val;\\n                    q.add(curr.right);\\n                    nodes.put(curr.right, curr);\\n                }\\n                map.put(curr, left+right);\\n            }\\n        }\\n        root.val = 0;\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423095,
                "title": "easy-to-understand-c-solution-binary-tree-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int height(TreeNode* root)\\n    {\\n        if(root==nullptr)return 0;\\n        int l = height(root->left);\\n        int r = height(root->right);\\n        return max(l,r)+1;\\n    }\\n    void f(TreeNode* root,int x)\\n    {\\n        if(root==nullptr)return ;\\n        ans[x]+= root->val;\\n        f(root->left,x+1);\\n        f(root->right,x+1);\\n    }\\n    \\n    TreeNode* dfs(TreeNode* par,TreeNode* root,int x)\\n    {\\n        if(root==NULL)return NULL;\\n        TreeNode* node;\\n        if(x==1 || x==2)\\n        {\\n            node = new TreeNode(0);\\n            node->left = dfs(root,root->left,x+1);\\n            node->right = dfs(root,root->right,x+1);\\n        }\\n        else\\n        {\\n            int sum = ans[x];\\n               if(par->left) sum-=par->left->val;\\n            if(par->right) sum-=par->right->val;\\n            node = new TreeNode(sum);\\n            node->left = dfs(root,root->left,x+1);\\n            node->right = dfs(root,root->right,x+1);\\n\\n        }\\n        return node;\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==nullptr)return nullptr;\\n        ans.resize(height(root)+1,0);\\n        f(root,1);\\n        return dfs(nullptr,root,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int height(TreeNode* root)\\n    {\\n        if(root==nullptr)return 0;\\n        int l = height(root->left);\\n        int r = height(root->right);\\n        return max(l,r)+1;\\n    }\\n    void f(TreeNode* root,int x)\\n    {\\n        if(root==nullptr)return ;\\n        ans[x]+= root->val;\\n        f(root->left,x+1);\\n        f(root->right,x+1);\\n    }\\n    \\n    TreeNode* dfs(TreeNode* par,TreeNode* root,int x)\\n    {\\n        if(root==NULL)return NULL;\\n        TreeNode* node;\\n        if(x==1 || x==2)\\n        {\\n            node = new TreeNode(0);\\n            node->left = dfs(root,root->left,x+1);\\n            node->right = dfs(root,root->right,x+1);\\n        }\\n        else\\n        {\\n            int sum = ans[x];\\n               if(par->left) sum-=par->left->val;\\n            if(par->right) sum-=par->right->val;\\n            node = new TreeNode(sum);\\n            node->left = dfs(root,root->left,x+1);\\n            node->right = dfs(root,root->right,x+1);\\n\\n        }\\n        return node;\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==nullptr)return nullptr;\\n        ans.resize(height(root)+1,0);\\n        f(root,1);\\n        return dfs(nullptr,root,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422551,
                "title": "2-dfs-c-readable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int, int>m;// To store sum of all Node val at each level\\n    void dfs(TreeNode *root,int k)\\n    {\\n        if(!root) return ;\\n        m[k]=m[k]+root->val;\\n        dfs(root->left,k+1);\\n        dfs(root->right,k+1);\\n\\n    }\\n    void Dfs(TreeNode *root,int k)\\n    {\\n         if(!root) return ;\\n         Dfs(root->left,k+1);\\n         Dfs(root->right,k+1);\\n         if(root->left && root->right)\\n         {\\n        \\n          root->left->val=m[k+1]-(root->left->val+root->right->val);\\n          root->right->val=root->left->val;\\n         }\\n         else if(root->left)\\n         {\\n             root->left->val=m[k+1]-(root->left->val);\\n         }\\n          else if(root->right)\\n         {\\n             root->right->val=m[k+1]-(root->right->val);\\n         }\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n          dfs(root,0);//update our map that will store sum at every level\\n          Dfs(root,0);// update node val\\n          root->val=0;// updating root to 0\\n          return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int, int>m;// To store sum of all Node val at each level\\n    void dfs(TreeNode *root,int k)\\n    {\\n        if(!root) return ;\\n        m[k]=m[k]+root->val;\\n        dfs(root->left,k+1);\\n        dfs(root->right,k+1);\\n\\n    }\\n    void Dfs(TreeNode *root,int k)\\n    {\\n         if(!root) return ;\\n         Dfs(root->left,k+1);\\n         Dfs(root->right,k+1);\\n         if(root->left && root->right)\\n         {\\n        \\n          root->left->val=m[k+1]-(root->left->val+root->right->val);\\n          root->right->val=root->left->val;\\n         }\\n         else if(root->left)\\n         {\\n             root->left->val=m[k+1]-(root->left->val);\\n         }\\n          else if(root->right)\\n         {\\n             root->right->val=m[k+1]-(root->right->val);\\n         }\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n          dfs(root,0);//update our map that will store sum at every level\\n          Dfs(root,0);// update node val\\n          root->val=0;// updating root to 0\\n          return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422255,
                "title": "dfs-with-diagram-o-n",
                "content": "\\n![BinaryTree_Cousins.jpg](https://assets.leetcode.com/users/images/88b12fae-0e7a-4d94-b9a1-cd0675a938db_1681622795.4665618.jpeg)\\n# Complexity-Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIf you have any suggestion to improve it then please tell. \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n        public TreeNode replaceValueInTree(TreeNode root) {\\n            root.val=0;\\n            Queue<TreeNode>que=new LinkedList<>();\\n            que.add(root);\\n            while(!que.isEmpty()){\\n                int size=que.size();\\n                LinkedList<TreeNode>parentnode=new LinkedList<>(que);\\n                int sum=0;\\n                while(size>0){\\n                    TreeNode tr=que.remove();\\n                    if(tr.left!=null){sum+=tr.left.val;que.add(tr.left);}\\n                    if(tr.right!=null){sum+=tr.right.val;que.add(tr.right);}\\n                    size--;\\n                }\\n                for(TreeNode n:parentnode){int tempsum=sum;\\n                    if(n.left!=null){tempsum-=n.left.val;}\\n                    if(n.right!=null){tempsum-=n.right.val;}\\n                    if(n.left!=null) n.left.val=tempsum;\\n                   if(n.right!=null) n.right.val=tempsum;\\n                }\\n            }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n        public TreeNode replaceValueInTree(TreeNode root) {\\n            root.val=0;\\n            Queue<TreeNode>que=new LinkedList<>();\\n            que.add(root);\\n            while(!que.isEmpty()){\\n                int size=que.size();\\n                LinkedList<TreeNode>parentnode=new LinkedList<>(que);\\n                int sum=0;\\n                while(size>0){\\n                    TreeNode tr=que.remove();\\n                    if(tr.left!=null){sum+=tr.left.val;que.add(tr.left);}\\n                    if(tr.right!=null){sum+=tr.right.val;que.add(tr.right);}\\n                    size--;\\n                }\\n                for(TreeNode n:parentnode){int tempsum=sum;\\n                    if(n.left!=null){tempsum-=n.left.val;}\\n                    if(n.right!=null){tempsum-=n.right.val;}\\n                    if(n.left!=null) n.left.val=tempsum;\\n                   if(n.right!=null) n.right.val=tempsum;\\n                }\\n            }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421399,
                "title": "i-kotlin-bfs-with-illustrated-explanation",
                "content": "# Intuition\\nThe first approach that may come to one\\u2019s mind is pretty straightforward: calculate the sum of all cousines and then replace each cousin\\'s value with the difference if this sum and a sum of thise node siblings values.\\n\\n# Approach\\nLet\\u2019s take a look at a tree. \\n\\n![A Tree](https://assets.leetcode.com/users/images/bd390a75-a75f-40c5-b21b-55e13b252653_1681603051.9156284.png)\\n\\n\\nTraversing the tree level by level we can calculate a sum of all values at each level. This sum is the sum of all cousines. The next step would be assigning the sum minus values of all node siblings.\\n\\n![](https://assets.leetcode.com/users/images/491435a6-6e97-4fa9-8efd-4d39f6aed356_1681603084.5572708.png)\\n\\n\\nUnfortunately, this approach won\\'t work, because we don\\'t possess the information about siblings. As one of possible options we can operate with nodes children, instead of nodes itself.\\n\\n**Step 1.** Sum all children values and put it to sum\\n\\n![](https://assets.leetcode.com/users/images/95f66493-bab0-459c-89af-47b0c755ecae_1681603075.0084324.png)\\n\\n\\n**Step 2.** For each node, calculate the value of sum - value of the left child if it exists - value of the right child, if it exists.\\n**Step 3.** Assign the values to all node children\\n\\n![](https://assets.leetcode.com/users/images/7d08671a-5659-43d9-a70c-3da594946a86_1681603170.5213504.png)\\n\\n\\n**Step 4.** Repeat all previous steps for the children.\\n\\n\\n# Complexity\\n- Time complexity: $O(nlog(n))$\\n\\n- Space complexity: $O(log(n))$\\n\\n# Code\\n```\\nclass Solution {\\n    fun replaceValueInTree(root: TreeNode): TreeNode {\\n        \\n        fun TreeNode.sumOfChildrenValues() = \\n            (left?.`val` ?: 0) + (right?.`val` ?: 0)\\n\\n        var nodes = mutableListOf(root.apply { `val` = 0 })\\n        while (nodes.isNotEmpty()) {\\n            val sumOfAllCousins = nodes\\n                .map(TreeNode::sumOfChildrenValues).sum()\\n            \\n            nodes = mutableListOf<TreeNode>().apply {\\n                for (node in nodes) {\\n                    val sumOfOtherCousines = \\n                        sumOfAllCousins - node.sumOfChildrenValues()\\n                    node.left?.also { child ->\\n                        child.`val` = sumOfOtherCousines\\n                        add(child) \\n                    }\\n                    node.right?.also { child ->\\n                        child.`val` = sumOfOtherCousines\\n                        add(child) \\n                    }\\n                }\\n            }\\n        }\\n\\n        return root\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    fun replaceValueInTree(root: TreeNode): TreeNode {\\n        \\n        fun TreeNode.sumOfChildrenValues() = \\n            (left?.`val` ?: 0) + (right?.`val` ?: 0)\\n\\n        var nodes = mutableListOf(root.apply { `val` = 0 })\\n        while (nodes.isNotEmpty()) {\\n            val sumOfAllCousins = nodes\\n                .map(TreeNode::sumOfChildrenValues).sum()\\n            \\n            nodes = mutableListOf<TreeNode>().apply {\\n                for (node in nodes) {\\n                    val sumOfOtherCousines = \\n                        sumOfAllCousins - node.sumOfChildrenValues()\\n                    node.left?.also { child ->\\n                        child.`val` = sumOfOtherCousines\\n                        add(child) \\n                    }\\n                    node.right?.also { child ->\\n                        child.`val` = sumOfOtherCousines\\n                        add(child) \\n                    }\\n                }\\n            }\\n        }\\n\\n        return root\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420939,
                "title": "pretty-hard-to-understand-but-works-flawless-not-a-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == nullptr) return root;\\n        \\n        root->val = 0;\\n        \\n        if(!root->left && !root->right) return root;\\n    \\n        if(root->left) {\\n            root->left->val = 0;    \\n        }\\n        \\n        if(root->right) {\\n            root->right->val = 0; \\n        }\\n        \\n        vector<vector<pair<int,int>>> values;\\n        \\n        TreeNode* root_node = root;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root_node);\\n        \\n        while(!q.empty()) {\\n            int n = q.size();\\n            vector<pair<int,int>> vec;\\n            \\n            for(int i = 0 ; i<n ; i++) {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                pair<int,int> vals = {0, 0};\\n\\n                if(node->left) {\\n                    vals.first = node->left->val;\\n                    q.push(node->left);\\n                }\\n\\n                if(node->right) {\\n                    vals.second = node->right->val;\\n                    q.push(node->right);\\n                }\\n                \\n                vec.push_back(vals);\\n            }\\n            \\n            values.push_back(vec);\\n        }\\n                \\n        root_node = root;\\n        \\n        if(root_node->left) {\\n            q.push(root_node->left);        \\n        }\\n        \\n        if(root_node->right) {\\n            q.push(root_node->right);        \\n        }\\n        \\n        int index = 1;\\n        int m = values.size();\\n        \\n        while(!q.empty() && index < m) {\\n            int n = q.size();\\n            \\n            int sum = 0;\\n            \\n            for(pair<int,int>& p : values[index]) {\\n                sum += p.first + p.second;\\n            }\\n            \\n            index++;\\n            \\n            for(int i = 0 ; i<n ; i++) {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                if(node->left && node->right) {\\n                    int val = sum - (node->left->val + node->right->val);\\n                    \\n                    node->left->val = val;\\n                    node->right->val = val;\\n                                        \\n                    q.push(node->left);\\n                    q.push(node->right);\\n                } else if(node->left) {\\n                    int val = sum - node->left->val;\\n                    \\n                    node->left->val = val;\\n                    \\n                    q.push(node->left);\\n                } else if(node->right) {\\n                    int val = sum - node->right->val;\\n                    \\n                    node->right->val = val;\\n                    \\n                    q.push(node->right);\\n                }\\n            }\\n            \\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == nullptr) return root;\\n        \\n        root->val = 0;\\n        \\n        if(!root->left && !root->right) return root;\\n    \\n        if(root->left) {\\n            root->left->val = 0;    \\n        }\\n        \\n        if(root->right) {\\n            root->right->val = 0; \\n        }\\n        \\n        vector<vector<pair<int,int>>> values;\\n        \\n        TreeNode* root_node = root;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root_node);\\n        \\n        while(!q.empty()) {\\n            int n = q.size();\\n            vector<pair<int,int>> vec;\\n            \\n            for(int i = 0 ; i<n ; i++) {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                pair<int,int> vals = {0, 0};\\n\\n                if(node->left) {\\n                    vals.first = node->left->val;\\n                    q.push(node->left);\\n                }\\n\\n                if(node->right) {\\n                    vals.second = node->right->val;\\n                    q.push(node->right);\\n                }\\n                \\n                vec.push_back(vals);\\n            }\\n            \\n            values.push_back(vec);\\n        }\\n                \\n        root_node = root;\\n        \\n        if(root_node->left) {\\n            q.push(root_node->left);        \\n        }\\n        \\n        if(root_node->right) {\\n            q.push(root_node->right);        \\n        }\\n        \\n        int index = 1;\\n        int m = values.size();\\n        \\n        while(!q.empty() && index < m) {\\n            int n = q.size();\\n            \\n            int sum = 0;\\n            \\n            for(pair<int,int>& p : values[index]) {\\n                sum += p.first + p.second;\\n            }\\n            \\n            index++;\\n            \\n            for(int i = 0 ; i<n ; i++) {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                if(node->left && node->right) {\\n                    int val = sum - (node->left->val + node->right->val);\\n                    \\n                    node->left->val = val;\\n                    node->right->val = val;\\n                                        \\n                    q.push(node->left);\\n                    q.push(node->right);\\n                } else if(node->left) {\\n                    int val = sum - node->left->val;\\n                    \\n                    node->left->val = val;\\n                    \\n                    q.push(node->left);\\n                } else if(node->right) {\\n                    int val = sum - node->right->val;\\n                    \\n                    node->right->val = val;\\n                    \\n                    q.push(node->right);\\n                }\\n            }\\n            \\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420930,
                "title": "100-fast-easiest-java-solution-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        Queue<TreeNode> q2 = new LinkedList<>();\\n        q.offer(root);\\n        q2.offer(root);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int s = 0;\\n            System.out.println(size);\\n            while(size-- > 0) {\\n                TreeNode p = q.poll();\\n                int sum = 0;\\n                if(p.left != null) {\\n                    sum = sum + p.left.val;\\n                    q.offer(p.left);\\n                }\\n                if(p.right != null) {\\n                    sum = sum + p.right.val;\\n                    q.offer(p.right);\\n                }\\n                s += sum;\\n            }\\n            size = q2.size();\\n            while(size-- > 0) {\\n                TreeNode p = q2.poll();\\n                int sum = 0;\\n                if(p.left != null) {\\n                    sum = sum + p.left.val;\\n                    q2.offer(p.left);\\n                }\\n                if(p.right != null) {\\n                    sum = sum + p.right.val;\\n                    q2.offer(p.right);\\n                }\\n                if(p.left != null) {\\n                    p.left.val = s - sum;\\n                }\\n                if(p.right != null) {\\n                    p.right.val = s - sum;\\n                }\\n            }\\n        }\\n        root.val = 0;\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        Queue<TreeNode> q2 = new LinkedList<>();\\n        q.offer(root);\\n        q2.offer(root);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int s = 0;\\n            System.out.println(size);\\n            while(size-- > 0) {\\n                TreeNode p = q.poll();\\n                int sum = 0;\\n                if(p.left != null) {\\n                    sum = sum + p.left.val;\\n                    q.offer(p.left);\\n                }\\n                if(p.right != null) {\\n                    sum = sum + p.right.val;\\n                    q.offer(p.right);\\n                }\\n                s += sum;\\n            }\\n            size = q2.size();\\n            while(size-- > 0) {\\n                TreeNode p = q2.poll();\\n                int sum = 0;\\n                if(p.left != null) {\\n                    sum = sum + p.left.val;\\n                    q2.offer(p.left);\\n                }\\n                if(p.right != null) {\\n                    sum = sum + p.right.val;\\n                    q2.offer(p.right);\\n                }\\n                if(p.left != null) {\\n                    p.left.val = s - sum;\\n                }\\n                if(p.right != null) {\\n                    p.right.val = s - sum;\\n                }\\n            }\\n        }\\n        root.val = 0;\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420892,
                "title": "simple-bfs-codes-gives-explanation-tracking-previous-value",
                "content": "# Intuition\\n***Summing up All the TreeNode values within a particular level and\\nSubstracting the value of particular node and sibling node value.***\\n# Approach\\n***Simple BFS to track the child along with parent\\nComputed sum of all the nodes of the previous level used in the particular level for summing up other than sibling nodes.***\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# please upvote if it helped\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> qu;\\n        \\n        qu.push(root);\\n        int prev_sum=root->val;\\n        root->val=-root->val;\\n\\n        while(!qu.empty())\\n        {\\n            queue<TreeNode*> qu2;\\n            int sum_=0;\\n            int size = qu.size();\\n            for(int i=0;i<size;i++)\\n            {    \\n                TreeNode *cur= qu.front();\\n                int a=0,b=0;\\n                if(cur->left)\\n                {\\n                    qu.push(cur->left);  \\n                    if(cur->right)\\n                    {\\n                       a=cur->right->val;           \\n                    }       \\n                }\\n                if(cur->right)\\n                {\\n                    qu.push(cur->right);\\n                    if(cur->left)\\n                    {\\n                        b=cur->left->val;\\n                    }\\n                }\\n                if(cur->right)\\n                {\\n                    sum_+=cur->right->val;\\n                    cur->right->val+=b;\\n                    cur->right->val=-cur->right->val;\\n                }\\n                if(cur->left)\\n                {\\n                    sum_+=cur->left->val;\\n                    cur->left->val+=a;\\n                    cur->left->val=-cur->left->val;\\n                }\\n\\n                qu2.push(qu.front());\\n                qu.pop();\\n            }\\n            while(!qu2.empty())\\n            {\\n                TreeNode *cur=qu2.front();\\n                qu2.pop();\\n                cur->val+=prev_sum;\\n            } \\n            prev_sum=sum_; \\n        }\\n\\n        return root;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> qu;\\n        \\n        qu.push(root);\\n        int prev_sum=root->val;\\n        root->val=-root->val;\\n\\n        while(!qu.empty())\\n        {\\n            queue<TreeNode*> qu2;\\n            int sum_=0;\\n            int size = qu.size();\\n            for(int i=0;i<size;i++)\\n            {    \\n                TreeNode *cur= qu.front();\\n                int a=0,b=0;\\n                if(cur->left)\\n                {\\n                    qu.push(cur->left);  \\n                    if(cur->right)\\n                    {\\n                       a=cur->right->val;           \\n                    }       \\n                }\\n                if(cur->right)\\n                {\\n                    qu.push(cur->right);\\n                    if(cur->left)\\n                    {\\n                        b=cur->left->val;\\n                    }\\n                }\\n                if(cur->right)\\n                {\\n                    sum_+=cur->right->val;\\n                    cur->right->val+=b;\\n                    cur->right->val=-cur->right->val;\\n                }\\n                if(cur->left)\\n                {\\n                    sum_+=cur->left->val;\\n                    cur->left->val+=a;\\n                    cur->left->val=-cur->left->val;\\n                }\\n\\n                qu2.push(qu.front());\\n                qu.pop();\\n            }\\n            while(!qu2.empty())\\n            {\\n                TreeNode *cur=qu2.front();\\n                qu2.pop();\\n                cur->val+=prev_sum;\\n            } \\n            prev_sum=sum_; \\n        }\\n\\n        return root;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420849,
                "title": "python-two-dfs",
                "content": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        def dfs(node, p, d):\\n            if not node:\\n                return\\n\\n            vals[d] += node.val\\n            pars[d][hash(p)] += node.val\\n            dfs(node.left, node, d + 1)\\n            dfs(node.right, node, d + 1)\\n\\n        vals = defaultdict(int)\\n        pars = defaultdict(lambda: defaultdict(int))\\n        dfs(root, 0, 0)\\n\\n        def modify(node, p, d):\\n            if not node:\\n                return\\n\\n            s = vals[d] - pars[d][p]\\n            orig = hash(node)\\n            node.val = s\\n\\n            modify(node.left, orig, d + 1)\\n            modify(node.right, orig, d + 1)\\n\\n        modify(root, 0, 0)\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        def dfs(node, p, d):\\n            if not node:\\n                return\\n\\n            vals[d] += node.val\\n            pars[d][hash(p)] += node.val\\n            dfs(node.left, node, d + 1)\\n            dfs(node.right, node, d + 1)\\n\\n        vals = defaultdict(int)\\n        pars = defaultdict(lambda: defaultdict(int))\\n        dfs(root, 0, 0)\\n\\n        def modify(node, p, d):\\n            if not node:\\n                return\\n\\n            s = vals[d] - pars[d][p]\\n            orig = hash(node)\\n            node.val = s\\n\\n            modify(node.left, orig, d + 1)\\n            modify(node.right, orig, d + 1)\\n\\n        modify(root, 0, 0)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420656,
                "title": "golang-simple-bfs",
                "content": "# Approach\\n```\\n           5\\n         /   \\\\\\n       4       9\\n     /   \\\\       \\\\\\n   1       10      7\\n```\\n\\n```\\n                        parents=[]\\n\\n          5-5           children=[5], sum=5\\n         /   \\\\\\n       4       9\\n     /   \\\\       \\\\\\n   1       10      7\\n```\\n\\n```    \\n           0            parents=[x]\\n         /   \\\\\\n    sum-4-9  sum-4-9    children=[4, 9], sum=13\\n     /   \\\\       \\\\\\n   1       10      7\\n```\\n\\n```   \\n           0           \\n         /   \\\\\\n       0       0        parents=[x, x]\\n     /   \\\\       \\\\\\nsum-1-10 sum-1-10 sum-7 children=[1, 10, 7], sum=18\\n```\\n\\n```     \\n           0           \\n         /   \\\\\\n       0       0        \\n     /   \\\\       \\\\\\n   7       7      11    parents=[x, x, x]\\n\\n                        children=[]\\n```\\n\\n# Code\\n```\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n    children := []*TreeNode{root}\\n    root.Val = 0\\n\\n    // Each iteration children list contains all elements with the same depth\\n    for len(children) > 0 {\\n        parents := children\\n        children = []*TreeNode{}\\n\\n        // Find sum of all children in this depth\\n        sum := 0\\n        for _, parent := range parents {\\n            if parent.Left != nil { sum += parent.Left.Val }\\n            if parent.Right != nil { sum += parent.Right.Val } \\n        }\\n\\n        // Update children values:\\n        // Calculated sum minus the current childer values (if they exist)\\n        // Also add all children to the list for the next iteration (depth+1)\\n        for _, parent := range parents {\\n            reduce := 0\\n            if parent.Left != nil { reduce += parent.Left.Val }\\n            if parent.Right != nil { reduce += parent.Right.Val }\\n            \\n            if parent.Left != nil {\\n                parent.Left.Val = sum - reduce\\n                children = append(children, parent.Left)\\n            }\\n            if parent.Right != nil {\\n                parent.Right.Val = sum - reduce\\n                children = append(children, parent.Right)\\n            }\\n        }\\n    }\\n    \\n    return root\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n           5\\n         /   \\\\\\n       4       9\\n     /   \\\\       \\\\\\n   1       10      7\\n```\n```\\n                        parents=[]\\n\\n          5-5           children=[5], sum=5\\n         /   \\\\\\n       4       9\\n     /   \\\\       \\\\\\n   1       10      7\\n```\n```    \\n           0            parents=[x]\\n         /   \\\\\\n    sum-4-9  sum-4-9    children=[4, 9], sum=13\\n     /   \\\\       \\\\\\n   1       10      7\\n```\n```   \\n           0           \\n         /   \\\\\\n       0       0        parents=[x, x]\\n     /   \\\\       \\\\\\nsum-1-10 sum-1-10 sum-7 children=[1, 10, 7], sum=18\\n```\n```     \\n           0           \\n         /   \\\\\\n       0       0        \\n     /   \\\\       \\\\\\n   7       7      11    parents=[x, x, x]\\n\\n                        children=[]\\n```\n```\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n    children := []*TreeNode{root}\\n    root.Val = 0\\n\\n    // Each iteration children list contains all elements with the same depth\\n    for len(children) > 0 {\\n        parents := children\\n        children = []*TreeNode{}\\n\\n        // Find sum of all children in this depth\\n        sum := 0\\n        for _, parent := range parents {\\n            if parent.Left != nil { sum += parent.Left.Val }\\n            if parent.Right != nil { sum += parent.Right.Val } \\n        }\\n\\n        // Update children values:\\n        // Calculated sum minus the current childer values (if they exist)\\n        // Also add all children to the list for the next iteration (depth+1)\\n        for _, parent := range parents {\\n            reduce := 0\\n            if parent.Left != nil { reduce += parent.Left.Val }\\n            if parent.Right != nil { reduce += parent.Right.Val }\\n            \\n            if parent.Left != nil {\\n                parent.Left.Val = sum - reduce\\n                children = append(children, parent.Left)\\n            }\\n            if parent.Right != nil {\\n                parent.Right.Val = sum - reduce\\n                children = append(children, parent.Right)\\n            }\\n        }\\n    }\\n    \\n    return root\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420594,
                "title": "python3-easy-and-clean-bfs-solution",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        \\n        \\n        queue = deque([(root,None)])\\n        \\n        while queue:\\n            \\n            child_sum = defaultdict(int)\\n            p = {}\\n            curr = 0\\n            \\n            for _ in range(len(queue)):\\n\\n                node, parent = queue.popleft()\\n                child_sum[parent] += node.val\\n                p[node] = parent\\n                curr += node.val\\n\\n                if node.left:\\n                    queue.append((node.left, node))\\n                if node.right:\\n                    queue.append((node.right, node))\\n            \\n            for node in p:\\n                node.val = curr - child_sum[p[node]]\\n            \\n            \\n        \\n        return root\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        \\n        \\n        queue = deque([(root,None)])\\n        \\n        while queue:\\n            \\n            child_sum = defaultdict(int)\\n            p = {}\\n            curr = 0\\n            \\n            for _ in range(len(queue)):\\n\\n                node, parent = queue.popleft()\\n                child_sum[parent] += node.val\\n                p[node] = parent\\n                curr += node.val\\n\\n                if node.left:\\n                    queue.append((node.left, node))\\n                if node.right:\\n                    queue.append((node.right, node))\\n            \\n            for node in p:\\n                node.val = curr - child_sum[p[node]]\\n            \\n            \\n        \\n        return root\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420521,
                "title": "c-well-explained-level-order-traversal-o-n-time",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlevel order traversal of binary tree\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root)   return root;\\n        map<int, int> mp;   // this map stores the total sum of every level\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int lvl = 0;\\n\\n        // level order traversing : storing the sum every level in the map\\n        while(!q.empty())   {\\n            int n = q.size();\\n            for(int i=0; i<n; i++)  {\\n                TreeNode* frNode = q.front();\\n                q.pop();\\n                mp[lvl] += frNode -> val;\\n                if(frNode -> left)  q.push(frNode -> left);\\n                if(frNode -> right) q.push(frNode -> right);\\n            }\\n            lvl++;\\n        }\\n\\n        q.push(root);   lvl = 0;\\n\\n        // modifing the value of every node\\n        // node value = (total level sum) - node->parent -> (left & right)\\n        while(!q.empty())   {\\n            int n = q.size();\\n            for(int i=0; i<n; i++)  {\\n                TreeNode* frNode = q.front();\\n                q.pop();\\n                int l = frNode->left ? frNode->left->val : 0;\\n                int r = frNode->right ? frNode->right->val : 0;\\n                if(frNode -> left)  {\\n                    q.push(frNode->left);\\n                    frNode->left->val = mp[lvl + 1] - (l+r);\\n                }\\n                if(frNode->right)   {\\n                    q.push(frNode->right);\\n                    frNode->right->val = mp[lvl + 1] - (l+r);   \\n                }\\n            }\\n            lvl++;\\n        }\\n\\n        root -> val = 0;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root)   return root;\\n        map<int, int> mp;   // this map stores the total sum of every level\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int lvl = 0;\\n\\n        // level order traversing : storing the sum every level in the map\\n        while(!q.empty())   {\\n            int n = q.size();\\n            for(int i=0; i<n; i++)  {\\n                TreeNode* frNode = q.front();\\n                q.pop();\\n                mp[lvl] += frNode -> val;\\n                if(frNode -> left)  q.push(frNode -> left);\\n                if(frNode -> right) q.push(frNode -> right);\\n            }\\n            lvl++;\\n        }\\n\\n        q.push(root);   lvl = 0;\\n\\n        // modifing the value of every node\\n        // node value = (total level sum) - node->parent -> (left & right)\\n        while(!q.empty())   {\\n            int n = q.size();\\n            for(int i=0; i<n; i++)  {\\n                TreeNode* frNode = q.front();\\n                q.pop();\\n                int l = frNode->left ? frNode->left->val : 0;\\n                int r = frNode->right ? frNode->right->val : 0;\\n                if(frNode -> left)  {\\n                    q.push(frNode->left);\\n                    frNode->left->val = mp[lvl + 1] - (l+r);\\n                }\\n                if(frNode->right)   {\\n                    q.push(frNode->right);\\n                    frNode->right->val = mp[lvl + 1] - (l+r);   \\n                }\\n            }\\n            lvl++;\\n        }\\n\\n        root -> val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420368,
                "title": "scala-two-dfs-tle",
                "content": "# Intuition\\nFirst find sum of all nodes on each level. Then, subtract cousins sum from the level sums. Value is replaced in the tree nodes to save memory allocations. Nevertheless, the solution doesn\\'t pass the tests.\\n\\n# Code\\n```\\ndef replaceValueInTree(root: TreeNode): TreeNode = {\\n    val levels = scala.collection.mutable.Map.empty[Int, Long].withDefaultValue(0)\\n    def goSums(node: TreeNode, level: Int): Unit =\\n      if (node != null) {\\n        levels(level) += node.value\\n        goSums(node.left, level + 1)\\n        goSums(node.right, level + 1)\\n      }\\n\\n    goSums(root, 0)\\n\\n    def go(node: TreeNode, level: Int, parentSum: Long): Unit = {\\n      if(node != null) {\\n        val nodeSum = computeParentSum(node)\\n        node.value = (levels(level) - parentSum).toInt\\n        go(node.left, level + 1, nodeSum)\\n        go(node.right, level + 1, nodeSum)\\n      }\\n    }\\n\\n    val rootSum = computeParentSum(root)\\n    go(root.left, 1, rootSum)\\n    go(root.right, 1, rootSum)\\n    root.value = 0\\n    root\\n  }\\n\\n  def computeParentSum(node: TreeNode) = {\\n    val left = if(node.left == null) 0 else node.left.value\\n    val right = if(node.right == null) 0 else node.right.value\\n    left.toLong + right\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\ndef replaceValueInTree(root: TreeNode): TreeNode = {\\n    val levels = scala.collection.mutable.Map.empty[Int, Long].withDefaultValue(0)\\n    def goSums(node: TreeNode, level: Int): Unit =\\n      if (node != null) {\\n        levels(level) += node.value\\n        goSums(node.left, level + 1)\\n        goSums(node.right, level + 1)\\n      }\\n\\n    goSums(root, 0)\\n\\n    def go(node: TreeNode, level: Int, parentSum: Long): Unit = {\\n      if(node != null) {\\n        val nodeSum = computeParentSum(node)\\n        node.value = (levels(level) - parentSum).toInt\\n        go(node.left, level + 1, nodeSum)\\n        go(node.right, level + 1, nodeSum)\\n      }\\n    }\\n\\n    val rootSum = computeParentSum(root)\\n    go(root.left, 1, rootSum)\\n    go(root.right, 1, rootSum)\\n    root.value = 0\\n    root\\n  }\\n\\n  def computeParentSum(node: TreeNode) = {\\n    val left = if(node.left == null) 0 else node.left.value\\n    val right = if(node.right == null) 0 else node.right.value\\n    left.toLong + right\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420359,
                "title": "simple-dfs-level-ordering-find-sum-at-depth-o-n",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    void dfs(TreeNode* root,ll depth, map<ll,ll>&mp){\\n        if(root == NULL) return;\\n        mp[depth] += root->val;\\n        dfs(root->left,depth+1,mp);\\n        dfs(root->right,depth+1,mp);\\n    }\\n    \\n    void dfs2(TreeNode* root,ll depth, map<ll,ll>&mp){\\n        if(root == NULL) return ;\\n        ll l = 0, r = 0;\\n        if(root->left) l = root->left->val;\\n        if(root->right) r = root->right->val;\\n        \\n        ll k = mp[depth+1] - l - r;\\n        // cout<<root->val<<\" \"<<l<<\" \"<<r<<\" \"<<k<<\" \"<<mp[depth+1]<<endl;\\n        if(root->left) root->left->val = k;\\n        if(root->right) root->right->val = k;\\n        \\n        \\n        dfs2(root->left,depth+1,mp);\\n        dfs2(root->right,depth+1,mp);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        map<ll,ll>mp;\\n        dfs(root,0,mp);\\n        dfs2(root,0,mp);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```\\n# upvote if it\\'s help you HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    void dfs(TreeNode* root,ll depth, map<ll,ll>&mp){\\n        if(root == NULL) return;\\n        mp[depth] += root->val;\\n        dfs(root->left,depth+1,mp);\\n        dfs(root->right,depth+1,mp);\\n    }\\n    \\n    void dfs2(TreeNode* root,ll depth, map<ll,ll>&mp){\\n        if(root == NULL) return ;\\n        ll l = 0, r = 0;\\n        if(root->left) l = root->left->val;\\n        if(root->right) r = root->right->val;\\n        \\n        ll k = mp[depth+1] - l - r;\\n        // cout<<root->val<<\" \"<<l<<\" \"<<r<<\" \"<<k<<\" \"<<mp[depth+1]<<endl;\\n        if(root->left) root->left->val = k;\\n        if(root->right) root->right->val = k;\\n        \\n        \\n        dfs2(root->left,depth+1,mp);\\n        dfs2(root->right,depth+1,mp);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        map<ll,ll>mp;\\n        dfs(root,0,mp);\\n        dfs2(root,0,mp);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3420240,
                "title": "c-level-order-traversal",
                "content": "## Explanation\\nPerform level order traversal. Use hashmap to store the parent and its children at each level. Accumulate the sum of all node values in the level too using a variable. \\n\\nFor each node, assign value as `sumOfValues - currentNodeVal - siblingNodeVal`. Finally make the root value as 0 too.\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root) return root;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int s = q.size();\\n            long long sum = 0;\\n            unordered_map <TreeNode*,pair<TreeNode*,TreeNode*>> mp;\\n            for(int i = 0 ; i < s ; i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                if(node->left){\\n                    mp[node].first = node->left;\\n                    sum += node->left->val;\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    mp[node].second = node->right;\\n                    sum += node->right->val;\\n                    q.push(node->right);\\n                }\\n            }\\n\\n            for(auto &[k,v] : mp){\\n                int f = (v.first == nullptr) ? 0 : v.first->val , s = ( v.second == nullptr ) ? 0 : v.second->val;\\n                if(v.first) v.first->val = sum-f-s;\\n                if(v.second) v.second->val = sum-f-s;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n\\n```\\n\\n## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root) return root;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int s = q.size();\\n            long long sum = 0;\\n            unordered_map <TreeNode*,pair<TreeNode*,TreeNode*>> mp;\\n            for(int i = 0 ; i < s ; i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                if(node->left){\\n                    mp[node].first = node->left;\\n                    sum += node->left->val;\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    mp[node].second = node->right;\\n                    sum += node->right->val;\\n                    q.push(node->right);\\n                }\\n            }\\n\\n            for(auto &[k,v] : mp){\\n                int f = (v.first == nullptr) ? 0 : v.first->val , s = ( v.second == nullptr ) ? 0 : v.second->val;\\n                if(v.first) v.first->val = sum-f-s;\\n                if(v.second) v.second->val = sum-f-s;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420192,
                "title": "level-order-traversing",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector< pair<TreeNode*, int > > arr;\\n        arr.push_back({root, 0});\\n        root->val = 0;\\n        while(arr.size() != 0) {\\n            vector< pair<TreeNode*, int > > x;\\n            int sum = 0;\\n            for(auto i : arr) {\\n                int left = 0, right = 0;\\n                if(i.first -> left != NULL) {\\n                    left = i.first ->left -> val;\\n                    sum += left;\\n                }\\n                if(i.first -> right != NULL) {\\n                    right = i.first ->right -> val;\\n                    sum += right;\\n                }\\n                if(i.first -> left != NULL) {\\n                    x.push_back({i.first ->left, right});\\n                }\\n                if(i.first -> right != NULL) {\\n                    x.push_back({i.first ->right, left});\\n                }\\n            }\\n            for(auto i : x) {\\n                i.first->val = sum - i.second - i.first->val;\\n            }\\n            arr = x;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector< pair<TreeNode*, int > > arr;\\n        arr.push_back({root, 0});\\n        root->val = 0;\\n        while(arr.size() != 0) {\\n            vector< pair<TreeNode*, int > > x;\\n            int sum = 0;\\n            for(auto i : arr) {\\n                int left = 0, right = 0;\\n                if(i.first -> left != NULL) {\\n                    left = i.first ->left -> val;\\n                    sum += left;\\n                }\\n                if(i.first -> right != NULL) {\\n                    right = i.first ->right -> val;\\n                    sum += right;\\n                }\\n                if(i.first -> left != NULL) {\\n                    x.push_back({i.first ->left, right});\\n                }\\n                if(i.first -> right != NULL) {\\n                    x.push_back({i.first ->right, left});\\n                }\\n            }\\n            for(auto i : x) {\\n                i.first->val = sum - i.second - i.first->val;\\n            }\\n            arr = x;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420191,
                "title": "python3-solution",
                "content": "\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        sumLevels = list()\\n        sumLevels.append(dict())\\n        sumLevels[-1][None] = 0\\n        totalLevels = list()\\n        totalLevels.append(0)\\n        \\n        def calculateLevelSum(root, level, parent):\\n            if not root:\\n                return\\n            \\n            if parent in sumLevels[level-1]:\\n                sumLevels[level-1][parent] += root.val\\n            \\n            if len(totalLevels) < level + 1:\\n                totalLevels.append(0)\\n            \\n            totalLevels[level] += root.val\\n            \\n            if len(sumLevels) < level + 1:\\n                sumLevels.append(dict())\\n            \\n            sumLevels[level][root] = 0\\n            \\n            calculateLevelSum(root.left, level+1, root)\\n            calculateLevelSum(root.right, level+1, root)\\n        \\n        calculateLevelSum(root, 1, None)\\n        \\n        def reassignValues(root, level, parent):\\n            if not root:\\n                return\\n            \\n            curValue = totalLevels[level] - sumLevels[level-1][parent]\\n\\n            root.val = curValue\\n            reassignValues(root.left, level+1, root)\\n            reassignValues(root.right, level+1, root)\\n            \\n        reassignValues(root, 1, None)\\n        return root\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        sumLevels = list()\\n        sumLevels.append(dict())\\n        sumLevels[-1][None] = 0\\n        totalLevels = list()\\n        totalLevels.append(0)\\n        \\n        def calculateLevelSum(root, level, parent):\\n            if not root:\\n                return\\n            \\n            if parent in sumLevels[level-1]:\\n                sumLevels[level-1][parent] += root.val\\n            \\n            if len(totalLevels) < level + 1:\\n                totalLevels.append(0)\\n            \\n            totalLevels[level] += root.val\\n            \\n            if len(sumLevels) < level + 1:\\n                sumLevels.append(dict())\\n            \\n            sumLevels[level][root] = 0\\n            \\n            calculateLevelSum(root.left, level+1, root)\\n            calculateLevelSum(root.right, level+1, root)\\n        \\n        calculateLevelSum(root, 1, None)\\n        \\n        def reassignValues(root, level, parent):\\n            if not root:\\n                return\\n            \\n            curValue = totalLevels[level] - sumLevels[level-1][parent]\\n\\n            root.val = curValue\\n            reassignValues(root.left, level+1, root)\\n            reassignValues(root.right, level+1, root)\\n            \\n        reassignValues(root, 1, None)\\n        return root\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420179,
                "title": "easy-c-solution-using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        //pushing NULL after every siblings\\n        q.push(root);\\n        q.push(NULL);\\n        \\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            vector<int> v;\\n            //made copy queue for changing values\\n            queue<TreeNode*> q1(q);\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                //if NULL then we push 0 to separate the cousins\\n                if(temp == NULL)\\n                {\\n                    v.push_back(0);\\n                }\\n                else\\n                {\\n                    if(temp->left)\\n                    {\\n                        q.push(temp->left);\\n                    }\\n                    if(temp->right)\\n                    {\\n                        q.push(temp->right);\\n                    }\\n                    //pushing NULL after every siblings ( NOT COUSINS )\\n                    q.push(NULL);\\n                    v.push_back(temp->val);\\n                }\\n            }\\n            \\n            int sum = 0;\\n            int count = 0;\\n            // summing whole one level of tree and counting number of 0\\'s\\n            for(int i = 0; i < v.size(); i++)\\n            {\\n                sum = sum + v[i];\\n                if(v[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            // if count is 0 then it means it is level 1 and 2 so make all nodes 0 using temp queue we kept\\n            if(count == 1)\\n            {\\n                while(!q1.empty())\\n                {\\n                    TreeNode* temp = q1.front();\\n                    if(temp)\\n                    {\\n                        temp->val = 0;\\n                    }\\n                    q1.pop();\\n                }\\n            }\\n            //if count > 1 means other levels then\\n            else if(count > 1)\\n            {\\n                for(int i = 0; i < v.size();)\\n                {\\n                    // we remove siblings from sum and make them equal to that new sum ( sum of all cousins )\\n                    if(v[i] == 0)\\n                    {\\n                        i++;\\n                    }\\n                    else if(i+1 < v.size() && v[i] && v[i+1])\\n                    {\\n                        v[i] = sum-v[i]-v[i+1];\\n                        v[i+1] = v[i];\\n                        i = i + 2;\\n                    }\\n                    else if(i+1 < v.size() && v[i] && !v[i+1])\\n                    {\\n                        v[i] = sum-v[i];\\n                        i++;\\n                    }\\n                }\\n                int i = 0;\\n                while(!q1.empty())\\n                {\\n                    // assigning sum to all nodes\\n                    TreeNode* temp = q1.front();\\n                    if(temp)\\n                    {\\n                        temp->val = v[i];\\n                    }\\n                    i++;\\n                    q1.pop();\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        //pushing NULL after every siblings\\n        q.push(root);\\n        q.push(NULL);\\n        \\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            vector<int> v;\\n            //made copy queue for changing values\\n            queue<TreeNode*> q1(q);\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                //if NULL then we push 0 to separate the cousins\\n                if(temp == NULL)\\n                {\\n                    v.push_back(0);\\n                }\\n                else\\n                {\\n                    if(temp->left)\\n                    {\\n                        q.push(temp->left);\\n                    }\\n                    if(temp->right)\\n                    {\\n                        q.push(temp->right);\\n                    }\\n                    //pushing NULL after every siblings ( NOT COUSINS )\\n                    q.push(NULL);\\n                    v.push_back(temp->val);\\n                }\\n            }\\n            \\n            int sum = 0;\\n            int count = 0;\\n            // summing whole one level of tree and counting number of 0\\'s\\n            for(int i = 0; i < v.size(); i++)\\n            {\\n                sum = sum + v[i];\\n                if(v[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            // if count is 0 then it means it is level 1 and 2 so make all nodes 0 using temp queue we kept\\n            if(count == 1)\\n            {\\n                while(!q1.empty())\\n                {\\n                    TreeNode* temp = q1.front();\\n                    if(temp)\\n                    {\\n                        temp->val = 0;\\n                    }\\n                    q1.pop();\\n                }\\n            }\\n            //if count > 1 means other levels then\\n            else if(count > 1)\\n            {\\n                for(int i = 0; i < v.size();)\\n                {\\n                    // we remove siblings from sum and make them equal to that new sum ( sum of all cousins )\\n                    if(v[i] == 0)\\n                    {\\n                        i++;\\n                    }\\n                    else if(i+1 < v.size() && v[i] && v[i+1])\\n                    {\\n                        v[i] = sum-v[i]-v[i+1];\\n                        v[i+1] = v[i];\\n                        i = i + 2;\\n                    }\\n                    else if(i+1 < v.size() && v[i] && !v[i+1])\\n                    {\\n                        v[i] = sum-v[i];\\n                        i++;\\n                    }\\n                }\\n                int i = 0;\\n                while(!q1.empty())\\n                {\\n                    // assigning sum to all nodes\\n                    TreeNode* temp = q1.front();\\n                    if(temp)\\n                    {\\n                        temp->val = v[i];\\n                    }\\n                    i++;\\n                    q1.pop();\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420086,
                "title": "easy-bfs-java-solution-using-2-queue",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root == null) return root;\\n        TreeNode res = new TreeNode(0);\\n        Queue<TreeNode> resq = new LinkedList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        resq.offer(res);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            TreeNode[] t = new TreeNode[size];\\n            int sum = 0;\\n            for(int i = 0; i<size; i++){\\n                t[i] = q.poll();\\n                if(t[i].left != null){\\n                    q.offer(t[i].left);\\n                    sum += t[i].left.val;\\n                }\\n                if(t[i].right != null){\\n                    q.offer(t[i].right);\\n                    sum += t[i].right.val;\\n                }\\n            }\\n            for(int i = 0; i<size; i++){\\n                TreeNode curr = resq.poll();\\n                int cusins = sum - (t[i].left != null ? t[i].left.val : 0) - (t[i].right != null ? t[i].right.val : 0);\\n                if(t[i].left != null){\\n                    curr.left = new TreeNode(cusins);\\n                    resq.offer(curr.left);\\n                }\\n                if(t[i].right != null){\\n                    curr.right = new TreeNode(cusins);\\n                    resq.offer(curr.right);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root == null) return root;\\n        TreeNode res = new TreeNode(0);\\n        Queue<TreeNode> resq = new LinkedList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        resq.offer(res);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            TreeNode[] t = new TreeNode[size];\\n            int sum = 0;\\n            for(int i = 0; i<size; i++){\\n                t[i] = q.poll();\\n                if(t[i].left != null){\\n                    q.offer(t[i].left);\\n                    sum += t[i].left.val;\\n                }\\n                if(t[i].right != null){\\n                    q.offer(t[i].right);\\n                    sum += t[i].right.val;\\n                }\\n            }\\n            for(int i = 0; i<size; i++){\\n                TreeNode curr = resq.poll();\\n                int cusins = sum - (t[i].left != null ? t[i].left.val : 0) - (t[i].right != null ? t[i].right.val : 0);\\n                if(t[i].left != null){\\n                    curr.left = new TreeNode(cusins);\\n                    resq.offer(curr.left);\\n                }\\n                if(t[i].right != null){\\n                    curr.right = new TreeNode(cusins);\\n                    resq.offer(curr.right);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420019,
                "title": "c-bfs-using-mapping-of-parent",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*,TreeNode*>> q;\\n        q.push({root,nullptr});\\n        while(q.size()){\\n            long long sz = q.size();\\n            vector<pair<TreeNode*,TreeNode*>> arr;\\n            unordered_map<TreeNode*,long long> mp;\\n            long long sum = 0; \\n            for(int i=0;i<sz;i++){\\n                auto xx = q.front();\\n                auto x = xx.first;\\n                if(xx.second!=nullptr)\\n                    mp[xx.second] += x->val;\\n                sum += x->val;\\n                arr.push_back(xx);\\n                q.pop();\\n                if(x->left) q.push({x->left,x});\\n                if(x->right) q.push({x->right,x});\\n            }\\n            for(int i=0;i<arr.size();i++){\\n                arr[i].first->val = (sum - mp[arr[i].second]);\\n            }\\n            if(sz == 1) arr[0].first->val = 0;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*,TreeNode*>> q;\\n        q.push({root,nullptr});\\n        while(q.size()){\\n            long long sz = q.size();\\n            vector<pair<TreeNode*,TreeNode*>> arr;\\n            unordered_map<TreeNode*,long long> mp;\\n            long long sum = 0; \\n            for(int i=0;i<sz;i++){\\n                auto xx = q.front();\\n                auto x = xx.first;\\n                if(xx.second!=nullptr)\\n                    mp[xx.second] += x->val;\\n                sum += x->val;\\n                arr.push_back(xx);\\n                q.pop();\\n                if(x->left) q.push({x->left,x});\\n                if(x->right) q.push({x->right,x});\\n            }\\n            for(int i=0;i<arr.size();i++){\\n                arr[i].first->val = (sum - mp[arr[i].second]);\\n            }\\n            if(sz == 1) arr[0].first->val = 0;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420010,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution{\\n    typedef TreeNode tn;\\npublic:\\n    void bfs(tn*rt){\\n        rt->val=0;\\n        list<tn*>l={rt}; // transformed parents\\n        while(!l.empty()){\\n            int sum=0; // sum of the values of all the nodes at the next depth level\\n            for(tn* par : l){\\n                if(par->left){\\n                    sum+=par->left->val;\\n                }\\n                if(par->right){\\n                    sum+=par->right->val;\\n                }\\n            }\\n            int sz=l.size();\\n            while(sz--){\\n                tn* par = l.front();\\n                l.pop_front();\\n                int lc = (par->left ? par->left->val : 0),\\n                    rc = (par->right ? par->right->val : 0);\\n                if(par->left){\\n                    par->left->val=sum-lc-rc;\\n                    l.push_back(par->left);\\n                }\\n                if(par->right){\\n                    par->right->val=sum-lc-rc;\\n                    l.push_back(par->right);\\n                }\\n            }\\n        }\\n    }\\n    tn* replaceValueInTree(tn* root) {\\n        bfs(root);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution{\\n    typedef TreeNode tn;\\npublic:\\n    void bfs(tn*rt){\\n        rt->val=0;\\n        list<tn*>l={rt}; // transformed parents\\n        while(!l.empty()){\\n            int sum=0; // sum of the values of all the nodes at the next depth level\\n            for(tn* par : l){\\n                if(par->left){\\n                    sum+=par->left->val;\\n                }\\n                if(par->right){\\n                    sum+=par->right->val;\\n                }\\n            }\\n            int sz=l.size();\\n            while(sz--){\\n                tn* par = l.front();\\n                l.pop_front();\\n                int lc = (par->left ? par->left->val : 0),\\n                    rc = (par->right ? par->right->val : 0);\\n                if(par->left){\\n                    par->left->val=sum-lc-rc;\\n                    l.push_back(par->left);\\n                }\\n                if(par->right){\\n                    par->right->val=sum-lc-rc;\\n                    l.push_back(par->right);\\n                }\\n            }\\n        }\\n    }\\n    tn* replaceValueInTree(tn* root) {\\n        bfs(root);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419989,
                "title": "java-c-simple-solution-dfs-hashmap",
                "content": "\\n``` java []\\nclass Solution {\\n    Map<Integer,Integer> map;\\n    Map<TreeNode,Integer> map2;\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        map = new HashMap<>();\\n        map2 = new HashMap<>();\\n        dfs(root, null, 0);\\n        fillSum(root, null, 0);\\n        return root;\\n    }\\n    \\n    private void dfs(TreeNode root,TreeNode parent,int c){\\n        if(root==null){\\n            return;\\n        }\\n        if(parent!=null){\\n           map2.put(parent,map2.getOrDefault(parent,0)+root.val);\\n           map.put(c,map.getOrDefault(c,0)+root.val);\\n        }\\n        dfs(root.left,root,c+1);\\n        dfs(root.right,root,c+1);\\n    }\\n\\n    private void fillSum(TreeNode root,TreeNode parent,int c){\\n        if(root==null){\\n            return;\\n        }\\n        root.val = parent==null? 0: (map.get(c)-map2.get(parent));\\n        fillSum(root.left,root,c+1);\\n        fillSum(root.right,root,c+1);\\n    }\\n}\\n```\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    unordered_map<int,int> depthSumMap;\\n    unordered_map<TreeNode*,int> cousinSumMap;\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       dfs(root,NULL, 0);\\n       fillSum(root,NULL,0);\\n       return root;\\n    }\\n    \\n    void dfs(TreeNode* root, TreeNode* parent, int depth){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(parent!=NULL){\\n            cousinSumMap[parent] += root->val;\\n            depthSumMap[depth] += root->val;\\n        }\\n        dfs(root->left,root,depth+1);\\n        dfs(root->right,root,depth+1);\\n    }\\n    \\n    void fillSum(TreeNode* root, TreeNode* parent, int depth){\\n        if(root==NULL){\\n            return;\\n        }\\n        root->val = parent==NULL? 0 :(depthSumMap[depth] - cousinSumMap[parent]);\\n        fillSum(root->left,root,depth+1);\\n        fillSum(root->right,root,depth+1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search"
                ],
                "code": "``` java []\\nclass Solution {\\n    Map<Integer,Integer> map;\\n    Map<TreeNode,Integer> map2;\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        map = new HashMap<>();\\n        map2 = new HashMap<>();\\n        dfs(root, null, 0);\\n        fillSum(root, null, 0);\\n        return root;\\n    }\\n    \\n    private void dfs(TreeNode root,TreeNode parent,int c){\\n        if(root==null){\\n            return;\\n        }\\n        if(parent!=null){\\n           map2.put(parent,map2.getOrDefault(parent,0)+root.val);\\n           map.put(c,map.getOrDefault(c,0)+root.val);\\n        }\\n        dfs(root.left,root,c+1);\\n        dfs(root.right,root,c+1);\\n    }\\n\\n    private void fillSum(TreeNode root,TreeNode parent,int c){\\n        if(root==null){\\n            return;\\n        }\\n        root.val = parent==null? 0: (map.get(c)-map2.get(parent));\\n        fillSum(root.left,root,c+1);\\n        fillSum(root.right,root,c+1);\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    unordered_map<int,int> depthSumMap;\\n    unordered_map<TreeNode*,int> cousinSumMap;\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       dfs(root,NULL, 0);\\n       fillSum(root,NULL,0);\\n       return root;\\n    }\\n    \\n    void dfs(TreeNode* root, TreeNode* parent, int depth){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(parent!=NULL){\\n            cousinSumMap[parent] += root->val;\\n            depthSumMap[depth] += root->val;\\n        }\\n        dfs(root->left,root,depth+1);\\n        dfs(root->right,root,depth+1);\\n    }\\n    \\n    void fillSum(TreeNode* root, TreeNode* parent, int depth){\\n        if(root==NULL){\\n            return;\\n        }\\n        root->val = parent==NULL? 0 :(depthSumMap[depth] - cousinSumMap[parent]);\\n        fillSum(root->left,root,depth+1);\\n        fillSum(root->right,root,depth+1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419981,
                "title": "c-explained",
                "content": "\\t// Firstly find and store the level wise sum of all nodes in the sum array (use level order traversal for this).\\n\\n\\t// Secondly do preorder traversal and subtract the left and right sibling value (which are from same parent) from the sum of that current level values \\n\\t// and replace the values of these two nodes with these levelSum - leftChild - rightChild.\\n\\n\\t// Finally for 0th level and 1st level value of nodes will always remain zero.\\n\\n\\tclass Solution {\\n\\t\\n\\t\\tpublic:\\n\\n\\t\\tvoid levelorder(TreeNode* root,vector<int> &sum)\\n\\t\\t{\\n\\t\\t\\tqueue<TreeNode*> q;\\n\\t\\t\\tq.push(root);\\n\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint levelSum=0;\\n\\t\\t\\t\\tint size=q.size();\\n\\n\\t\\t\\t\\tfor(int i=0;i<size;i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tauto node = q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\t\\tlevelSum += node->val;\\n\\n\\t\\t\\t\\t\\tif(node->left)\\n\\t\\t\\t\\t\\t\\tq.push(node->left);\\n\\t\\t\\t\\t\\tif(node->right)\\n\\t\\t\\t\\t\\t\\tq.push(node->right);\\n\\t\\t\\t\\t}            \\n\\t\\t\\t\\tsum.push_back(levelSum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid preorder(TreeNode* root,int level,vector<int> &sum)\\n\\t\\t{\\n\\t\\t\\tif(!root)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint leftVal=-1,rightVal=-1;\\n\\n\\t\\t\\tif(level!=0 && root->left)\\n\\t\\t\\t\\tleftVal = root->left->val;\\n\\n\\t\\t\\tif(level!=0 && root->right)\\n\\t\\t\\t\\trightVal = root->right->val;    \\n\\n\\t\\t\\tif(level+1<sum.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint val = sum[level+1];\\n\\t\\t\\t\\tif(leftVal!=-1)\\n\\t\\t\\t\\t\\tval -= leftVal;\\n\\t\\t\\t\\tif(rightVal!=-1)\\n\\t\\t\\t\\t\\tval -= rightVal;\\n\\n\\t\\t\\t\\tif(root->left)\\n\\t\\t\\t\\t\\troot->left->val = val;\\n\\n\\t\\t\\t\\tif(root->right)\\n\\t\\t\\t\\t\\troot->right->val = val;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpreorder(root->left,level+1,sum);\\n\\t\\t\\tpreorder(root->right,level+1,sum);\\n\\t\\t}\\n\\n\\t\\tTreeNode* replaceValueInTree(TreeNode* root) {\\n\\n\\t\\t\\tvector<int> sum;\\n\\n\\t\\t\\tlevelorder(root,sum);\\n\\t\\t\\tpreorder(root,0,sum);\\n\\n\\t\\t\\troot->val = 0;                          // Root node and its child Nodes will always remain zero\\n\\t\\t\\tif(root->left)\\n\\t\\t\\t\\troot->left->val=0;\\n\\n\\t\\t\\tif(root->right)\\n\\t\\t\\t\\troot->right->val=0;\\n\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t \\n\\t };",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\n\\t\\tpublic:\\n\\n\\t\\tvoid levelorder(TreeNode* root,vector<int> &sum)\\n\\t\\t{\\n\\t\\t\\tqueue<TreeNode*> q;\\n\\t\\t\\tq.push(root);\\n\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint levelSum=0;\\n\\t\\t\\t\\tint size=q.size();\\n\\n\\t\\t\\t\\tfor(int i=0;i<size;i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tauto node = q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\t\\tlevelSum += node->val;\\n\\n\\t\\t\\t\\t\\tif(node->left)\\n\\t\\t\\t\\t\\t\\tq.push(node->left);\\n\\t\\t\\t\\t\\tif(node->right)\\n\\t\\t\\t\\t\\t\\tq.push(node->right);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3419968,
                "title": "depth-sum-minus-parent-sum",
                "content": "A cousin by definition has the same depth of the node and also a different parent. So we can calculate the sum of each level of the tree, as well as the sum of each parent\\'s children. Then the sum of all non-cousins is the sum of the entire level of the tree minus the sum of the node\\'s parent\\'s children. We can do this easily in two traversals, one to calculate depth and parent sums, and one to set the values to the correct answer.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    long long v[100001] = {};\\n    map<TreeNode*, long long> par;\\n    void trav(TreeNode* root, int h, int& id, TreeNode* last){\\n        if(root == nullptr) return;\\n        v[h] += root->val;\\n        if(last != nullptr) par[last] += root->val;\\n        trav(root->left, h+1, id, root);\\n        trav(root->right, h+1, id, root);\\n    }\\n    void fix(TreeNode* root, int h, int& id, TreeNode* last){\\n        if(root == nullptr) return;\\n        if(last == nullptr) root->val = 0;\\n        else root->val = v[h]-par[last];\\n        fix(root->left, h+1, root);\\n        fix(root->right, h+1, root);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        trav(root, 1, nullptr);\\n        fix(root, 1, nullptr);\\n        return root;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long v[100001] = {}",
                "codeTag": "Java"
            },
            {
                "id": 4080973,
                "title": "simple-bfs-simple-solution",
                "content": "# Intuition\\nSolved it using BFS. Calculated the sum of all all node keys at each individual level and then subtracted from the sum of the node keys of a particular parent and assigned that value to its children nodes. Easy and Simple to understand.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int sum=0;\\n            queue<TreeNode*>parent;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                parent.push(temp);\\n                if(temp->left!=NULL)\\n                {\\n                    q.push(temp->left);\\n                    sum+=temp->left->val;\\n                }\\n                if(temp->right!=NULL)\\n                {\\n                    q.push(temp->right);\\n                    sum+=temp->right->val;\\n                }\\n            }\\n                while(!parent.empty())\\n                {\\n                    TreeNode* lul=parent.front();\\n                    parent.pop();\\n                    int nv=0;\\n                    if(lul->left!=NULL)\\n                    {\\n                        nv+=lul->left->val;\\n                    }\\n                    if(lul->right!=NULL)\\n                    {\\n                        nv+=lul->right->val;\\n                    }\\n                    if(lul->left!=NULL)\\n                        lul->left->val=sum-nv;\\n                    if(lul->right!=NULL)\\n                        lul->right->val=sum-nv;\\n                }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int sum=0;\\n            queue<TreeNode*>parent;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                parent.push(temp);\\n                if(temp->left!=NULL)\\n                {\\n                    q.push(temp->left);\\n                    sum+=temp->left->val;\\n                }\\n                if(temp->right!=NULL)\\n                {\\n                    q.push(temp->right);\\n                    sum+=temp->right->val;\\n                }\\n            }\\n                while(!parent.empty())\\n                {\\n                    TreeNode* lul=parent.front();\\n                    parent.pop();\\n                    int nv=0;\\n                    if(lul->left!=NULL)\\n                    {\\n                        nv+=lul->left->val;\\n                    }\\n                    if(lul->right!=NULL)\\n                    {\\n                        nv+=lul->right->val;\\n                    }\\n                    if(lul->left!=NULL)\\n                        lul->left->val=sum-nv;\\n                    if(lul->right!=NULL)\\n                        lul->right->val=sum-nv;\\n                }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067854,
                "title": "using-2-dfs-with-o-n-run-time-and-space-complexity",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_somme=defaultdict(int)\\n        def levelSomme(root,depth):\\n            if not root:\\n                return\\n            level_somme[depth]+=root.val\\n            levelSomme(root.left,depth+1)\\n            levelSomme(root.right,depth+1)\\n\\n        def dfs(root,depth,sib):\\n            if not root:\\n                return\\n            root.val=level_somme[depth]-root.val-sib\\n            left_val=root.left.val if root.left else 0\\n            right_val=root.right.val if root.right else 0\\n\\n            dfs(root.left,depth+1,right_val)\\n            dfs(root.right,depth+1,left_val)\\n\\n        levelSomme(root,0)\\n        dfs(root,0,0)\\n        return root\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_somme=defaultdict(int)\\n        def levelSomme(root,depth):\\n            if not root:\\n                return\\n            level_somme[depth]+=root.val\\n            levelSomme(root.left,depth+1)\\n            levelSomme(root.right,depth+1)\\n\\n        def dfs(root,depth,sib):\\n            if not root:\\n                return\\n            root.val=level_somme[depth]-root.val-sib\\n            left_val=root.left.val if root.left else 0\\n            right_val=root.right.val if root.right else 0\\n\\n            dfs(root.left,depth+1,right_val)\\n            dfs(root.right,depth+1,left_val)\\n\\n        levelSomme(root,0)\\n        dfs(root,0,0)\\n        return root\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061254,
                "title": "c-solution-using-map",
                "content": "class Solution {\\npublic:\\n    void levelSum(TreeNode* root,int level,map<int,int>&mp){\\n        if(!root)return;\\n        mp[level]+=root->val;\\n        levelSum(root->left,level+1,mp);\\n        levelSum(root->right,level+1,mp);\\n    }\\n    void solve(TreeNode* root,int level,map<int,int>&mp){\\n        if(!root)return;\\n        if(root->left and root->right){\\n        root->left->val=mp[level+1]-root->left->val-root->right->val;\\n        root->right->val=root->left->val;\\n        }\\n         if(root->left and !root->right)\\n        root->left->val=mp[level+1]-root->left->val;\\n         if(!root->left and root->right)\\n        root->right->val=mp[level+1]-root->right->val;\\n        solve(root->left,level+1,mp);\\n        solve(root->right,level+1,mp);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root)return NULL;\\n        map<int,int>mp;\\n        levelSum(root,0,mp);\\n        solve(root,0,mp);\\n        root->val=0;\\n        return root;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void levelSum(TreeNode* root,int level,map<int,int>&mp){\\n        if(!root)return;\\n        mp[level]+=root->val;\\n        levelSum(root->left,level+1,mp);\\n        levelSum(root->right,level+1,mp);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4032291,
                "title": "o-n-level-order-traversal-optimized-solution-by-anurag",
                "content": "# Intuition\\nThe goal is to replace the value of each node in the binary tree with the sum of its cousins\\' values. Cousins are nodes at the same depth but with different parents. We can use a level-order traversal (BFS) to compute the sum of cousins for each node in the tree and update their values accordingly.\\n\\n# Approach\\n1.Initialize a queue for level-order traversal, a map to store the sum of cousins for each node at the current level, and a variable to keep track of the sum of cousins.\\n\\n2.Start with the root node and push it into the queue.\\n\\n3.While the queue is not empty, process each level:\\n\\na. For each node at the current level, calculate the sum of its left and right children\\'s values and update the map.\\n\\nb. Update the value of the current node with the sum of its cousins.\\n\\nc. If the current node has left and right children, adjust their values accordingly.\\n\\nd. Push the left and right children of the current node into the queue for the next level.\\n\\n4.Continue this process until all levels have been processed.\\n\\n5.Return the modified root node.\\n\\n# Complexity\\n- Time complexity:O(N),Visiting each node in BFS.\\n\\n- Space complexity:O(M),Where M is the maximum number of nodes at any level (Worse case space complexity).\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  TreeNode* replaceValueInTree(TreeNode* root) {\\n    queue<TreeNode*>q;\\n    TreeNode*dummy=root;\\n    root->val=0;\\n    q.push(dummy);\\n    while(q.size()){\\n        queue<TreeNode*>temp;\\n        map<TreeNode*,int>m;\\n        while(q.size()){\\n            if(q.front()->left){\\n                temp.push(q.front()->left);\\n                m[q.front()]+=q.front()->left->val;\\n            }\\n             if(q.front()->right){\\n                temp.push(q.front()->right);\\n                m[q.front()]+=q.front()->right->val;\\n            }\\n            q.pop();\\n        }\\n        int sum=0;\\n        map<TreeNode*,int> ::iterator i;\\n        for(i=m.begin();i!=m.end();i++){\\n            sum+=(*i).second;\\n        }\\n       \\n        for(i=m.begin();i!=m.end();i++){\\n            int temp2=0;\\n            if((*i).first->left){\\n                temp2+=(*i).first->left->val;\\n            }\\n            if((*i).first->right){\\n                temp2+=(*i).first->right->val;\\n            }\\n            temp2=sum-temp2;\\n            if((*i).first->left){\\n                (*i).first->left->val=temp2;\\n            }\\n            if((*i).first->right){\\n                (*i).first->right->val=temp2;\\n            }\\n            q=temp;\\n        }\\n    }\\n    return root;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  TreeNode* replaceValueInTree(TreeNode* root) {\\n    queue<TreeNode*>q;\\n    TreeNode*dummy=root;\\n    root->val=0;\\n    q.push(dummy);\\n    while(q.size()){\\n        queue<TreeNode*>temp;\\n        map<TreeNode*,int>m;\\n        while(q.size()){\\n            if(q.front()->left){\\n                temp.push(q.front()->left);\\n                m[q.front()]+=q.front()->left->val;\\n            }\\n             if(q.front()->right){\\n                temp.push(q.front()->right);\\n                m[q.front()]+=q.front()->right->val;\\n            }\\n            q.pop();\\n        }\\n        int sum=0;\\n        map<TreeNode*,int> ::iterator i;\\n        for(i=m.begin();i!=m.end();i++){\\n            sum+=(*i).second;\\n        }\\n       \\n        for(i=m.begin();i!=m.end();i++){\\n            int temp2=0;\\n            if((*i).first->left){\\n                temp2+=(*i).first->left->val;\\n            }\\n            if((*i).first->right){\\n                temp2+=(*i).first->right->val;\\n            }\\n            temp2=sum-temp2;\\n            if((*i).first->left){\\n                (*i).first->left->val=temp2;\\n            }\\n            if((*i).first->right){\\n                (*i).first->right->val=temp2;\\n            }\\n            q=temp;\\n        }\\n    }\\n    return root;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998816,
                "title": "two-solutions-bfs-and-dfs",
                "content": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [root]\\n        root.val = 0\\n        while queue:\\n            dic_sum_children, new_queue, sum_level = {}, [], 0\\n            for node in queue:\\n                old_sum_level = sum_level\\n                if node.left:\\n                    sum_level += node.left.val\\n                if node.right:\\n                    sum_level += node.right.val        \\n                dic_sum_children[node] = sum_level - old_sum_level\\n            for node in queue:\\n                sum_chidren = dic_sum_children[node]  \\n                if node.left:\\n                    node.left.val = sum_level - sum_chidren\\n                    new_queue.append(node.left)\\n                if node.right:\\n                    node.right.val = sum_level - sum_chidren\\n                    new_queue.append(node.right)\\n            queue = new_queue\\n        return root\\n```\\n```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        return self.replase_val(root, TreeNode(left= root), 0, self.sum_level(root, 0 ,[]))\\n\\n    def sum_level(self, root, depth, list_sum):\\n        if not root:\\n            return list_sum\\n        if depth == len(list_sum):\\n            list_sum.append(root.val)\\n        else:\\n            list_sum[depth] += root.val\\n        self.sum_level(root.left, depth+1, list_sum)\\n        self.sum_level(root.right, depth+1, list_sum)\\n        return list_sum\\n\\n    def replase_val(self, root, parent, depth, list_sum):\\n        if not root:\\n            return None\\n        if parent.left and parent.left is root:  \\n            if parent.right:     \\n                root.val = parent.right.val = list_sum[depth]-root.val-parent.right.val  \\n            else: \\n                root.val = list_sum[depth]-root.val\\n        elif not parent.left:\\n            root.val = list_sum[depth]-root.val\\n        self.replase_val(root.left, root, depth+1, list_sum)\\n        self.replase_val(root.right, root, depth+1, list_sum)\\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Recursion",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [root]\\n        root.val = 0\\n        while queue:\\n            dic_sum_children, new_queue, sum_level = {}, [], 0\\n            for node in queue:\\n                old_sum_level = sum_level\\n                if node.left:\\n                    sum_level += node.left.val\\n                if node.right:\\n                    sum_level += node.right.val        \\n                dic_sum_children[node] = sum_level - old_sum_level\\n            for node in queue:\\n                sum_chidren = dic_sum_children[node]  \\n                if node.left:\\n                    node.left.val = sum_level - sum_chidren\\n                    new_queue.append(node.left)\\n                if node.right:\\n                    node.right.val = sum_level - sum_chidren\\n                    new_queue.append(node.right)\\n            queue = new_queue\\n        return root\\n```\n```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        return self.replase_val(root, TreeNode(left= root), 0, self.sum_level(root, 0 ,[]))\\n\\n    def sum_level(self, root, depth, list_sum):\\n        if not root:\\n            return list_sum\\n        if depth == len(list_sum):\\n            list_sum.append(root.val)\\n        else:\\n            list_sum[depth] += root.val\\n        self.sum_level(root.left, depth+1, list_sum)\\n        self.sum_level(root.right, depth+1, list_sum)\\n        return list_sum\\n\\n    def replase_val(self, root, parent, depth, list_sum):\\n        if not root:\\n            return None\\n        if parent.left and parent.left is root:  \\n            if parent.right:     \\n                root.val = parent.right.val = list_sum[depth]-root.val-parent.right.val  \\n            else: \\n                root.val = list_sum[depth]-root.val\\n        elif not parent.left:\\n            root.val = list_sum[depth]-root.val\\n        self.replase_val(root.left, root, depth+1, list_sum)\\n        self.replase_val(root.right, root, depth+1, list_sum)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979218,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStore sum of node values of all heights in dictionary.\\nthen substract dictionary[height] - left-right.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(height)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        total, root.val = {}, 0\\n        def getSumOfHeights(node, height):\\n            if height not in total:\\n                total[height] = 0\\n            total[height] += node.val\\n            if node.left:\\n                getSumOfHeights(node.left, height+1)\\n            if node.right:\\n                getSumOfHeights(node.right, height+1)\\n        getSumOfHeights(root, 0)\\n        \\n        def helper(node,height):\\n            left,right = 0,0\\n            if node.left:\\n                helper(node.left,height+1)\\n                left = node.left.val\\n\\n            if node.right:\\n                helper(node.right,height+1)\\n                right = node.right.val\\n            if left+right != 0:\\n                if node.left:\\n                    node.left.val = total[height+1]-(left+right)\\n                if node.right:\\n                    node.right.val = total[height+1]-(left+right)\\n        helper(root,0)\\n        return root\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        total, root.val = {}, 0\\n        def getSumOfHeights(node, height):\\n            if height not in total:\\n                total[height] = 0\\n            total[height] += node.val\\n            if node.left:\\n                getSumOfHeights(node.left, height+1)\\n            if node.right:\\n                getSumOfHeights(node.right, height+1)\\n        getSumOfHeights(root, 0)\\n        \\n        def helper(node,height):\\n            left,right = 0,0\\n            if node.left:\\n                helper(node.left,height+1)\\n                left = node.left.val\\n\\n            if node.right:\\n                helper(node.right,height+1)\\n                right = node.right.val\\n            if left+right != 0:\\n                if node.left:\\n                    node.left.val = total[height+1]-(left+right)\\n                if node.right:\\n                    node.right.val = total[height+1]-(left+right)\\n        helper(root,0)\\n        return root\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976447,
                "title": "bfs-dfs",
                "content": "**bfs**\\n```\\nclass Solution \\n{\\n    void transform_tree(TreeNode* r)\\n    {\\n        vector<TreeNode*> v{r}, vv;\\n        for( ; !empty(v); )\\n        {\\n            int sum{};\\n            for(auto & v : v)\\n            {\\n                auto t = (v->left ? v->left->val : 0)+(v->right ? v->right->val : 0);\\n                if(v->left)  \\n                {\\n                    vv.push_back(v->left);\\n                    v->left->val = -t;\\n                }\\n                if(v->right) \\n                {\\n                    vv.push_back(v->right);\\n                    v->right->val = -t;\\n                }\\n                sum += t;\\n            }\\n            for(auto & v : v)\\n            {\\n                if(v->left)  v->left->val  += sum;\\n                if(v->right) v->right->val += sum;\\n            }\\n            v.clear();\\n            swap(v,vv);\\n        }\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* r)\\n    {\\n        r->val=0;\\n        transform_tree(r);\\n        return r;\\n    }\\n};\\n```\\n**dfs**\\n```\\nclass Solution \\n{\\n    unordered_map<int,int> m;\\n\\n    void make_sum(TreeNode* r, int d=0)\\n    {\\n        if(!r) return ;\\n        m[d]+=r->val;\\n        make_sum(r->left, d+1);\\n        make_sum(r->right, d+1);\\n    }\\n    void transform_tree(TreeNode* r, int d=0)\\n    {\\n        if(!r) return ;\\n        int t = (r->left ? r->left->val : 0)+(r->right ? r->right->val : 0);\\n        if(r->left)    \\n              r->left->val = m[d+1]-t;\\n        if(r->right)    \\n              r->right->val = m[d+1]-t;\\n        transform_tree(r->left, d+1);\\n        transform_tree(r->right, d+1);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* r)\\n    {\\n        make_sum(r);\\n        r->val=0;\\n        transform_tree(r);\\n        return r;\\n    }\\n```\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    void transform_tree(TreeNode* r)\\n    {\\n        vector<TreeNode*> v{r}, vv;\\n        for( ; !empty(v); )\\n        {\\n            int sum{};\\n            for(auto & v : v)\\n            {\\n                auto t = (v->left ? v->left->val : 0)+(v->right ? v->right->val : 0);\\n                if(v->left)  \\n                {\\n                    vv.push_back(v->left);\\n                    v->left->val = -t;\\n                }\\n                if(v->right) \\n                {\\n                    vv.push_back(v->right);\\n                    v->right->val = -t;\\n                }\\n                sum += t;\\n            }\\n            for(auto & v : v)\\n            {\\n                if(v->left)  v->left->val  += sum;\\n                if(v->right) v->right->val += sum;\\n            }\\n            v.clear();\\n            swap(v,vv);\\n        }\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* r)\\n    {\\n        r->val=0;\\n        transform_tree(r);\\n        return r;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\n    unordered_map<int,int> m;\\n\\n    void make_sum(TreeNode* r, int d=0)\\n    {\\n        if(!r) return ;\\n        m[d]+=r->val;\\n        make_sum(r->left, d+1);\\n        make_sum(r->right, d+1);\\n    }\\n    void transform_tree(TreeNode* r, int d=0)\\n    {\\n        if(!r) return ;\\n        int t = (r->left ? r->left->val : 0)+(r->right ? r->right->val : 0);\\n        if(r->left)    \\n              r->left->val = m[d+1]-t;\\n        if(r->right)    \\n              r->right->val = m[d+1]-t;\\n        transform_tree(r->left, d+1);\\n        transform_tree(r->right, d+1);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* r)\\n    {\\n        make_sum(r);\\n        r->val=0;\\n        transform_tree(r);\\n        return r;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953288,
                "title": "simple-bfs",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> temp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            int sum =0;\\n            for(int i=0;i<size;i++){\\n                sum+=(q.front()->val);\\n                TreeNode* node = q.front();\\n                if(node->left){\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n                q.pop();\\n            }\\n            temp.push_back(sum);\\n        }\\n         q.push(root);\\n        int level =0;\\n        root->val =0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(level==0){\\n                      if(node->left){\\n                    q.push(node->left);\\n                          node->left->val=0;\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                    node->right->val=0;\\n                }\\n                }\\n                else{\\n                    int sum =0;\\n                     if(node->left){\\n                    q.push(node->left);\\n                         sum+=(node->left->val);\\n                         \\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                   sum+=(node->right->val);\\n                }\\n                    if(node->left){\\n                        node->left->val = temp[level+1]-sum;\\n                    }\\n                    if(node->right){\\n                        node->right->val = temp[level+1]-sum;\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> temp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            int sum =0;\\n            for(int i=0;i<size;i++){\\n                sum+=(q.front()->val);\\n                TreeNode* node = q.front();\\n                if(node->left){\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n                q.pop();\\n            }\\n            temp.push_back(sum);\\n        }\\n         q.push(root);\\n        int level =0;\\n        root->val =0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(level==0){\\n                      if(node->left){\\n                    q.push(node->left);\\n                          node->left->val=0;\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                    node->right->val=0;\\n                }\\n                }\\n                else{\\n                    int sum =0;\\n                     if(node->left){\\n                    q.push(node->left);\\n                         sum+=(node->left->val);\\n                         \\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                   sum+=(node->right->val);\\n                }\\n                    if(node->left){\\n                        node->left->val = temp[level+1]-sum;\\n                    }\\n                    if(node->right){\\n                        node->right->val = temp[level+1]-sum;\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909119,
                "title": "level-order-bfs-traversal-hashmap",
                "content": "# Intuition\\n- Finding the level sum excluding those under the same parent will give sum of cousins\\n\\n# Approach\\n- Iterate through in level order\\n- At each level, create a hashmap of `parent -> total child sum`\\n- Also calculate the total sum at each level\\n- In each iteration, update current node values, subtracting as mentioned above (i.e. `total_sum - parent_sum[par]`)\\n\\n# Complexity\\n- Time complexity: O(N), as we visit each nodes twice so 2N times\\n\\n- Space complexity: O(N), at most (N+1)/2 nodes in the queue\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n      queue = deque([(root, None)])\\n      while queue:\\n        level = []\\n        parent_sum = defaultdict(int)\\n        total_sum = 0\\n        for _ in range(len(queue)):\\n          node, par = queue.popleft()\\n          level.append((node, par))\\n          parent_sum[par] += node.val\\n          total_sum += node.val\\n          if node.left:\\n            queue.append((node.left, node))\\n          if node.right:\\n            queue.append((node.right, node))\\n        for node, par in level:\\n          node.val = total_sum - parent_sum[par]\\n      return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n      queue = deque([(root, None)])\\n      while queue:\\n        level = []\\n        parent_sum = defaultdict(int)\\n        total_sum = 0\\n        for _ in range(len(queue)):\\n          node, par = queue.popleft()\\n          level.append((node, par))\\n          parent_sum[par] += node.val\\n          total_sum += node.val\\n          if node.left:\\n            queue.append((node.left, node))\\n          if node.right:\\n            queue.append((node.right, node))\\n        for node, par in level:\\n          node.val = total_sum - parent_sum[par]\\n      return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899815,
                "title": "simple-fast-easy-c",
                "content": "# Intuition\\nFirst thought: To use level sum wisely\\nSecond thought: Intoduce BFS\\n\\n# Complexit\\n- Time complexity:\\n  O(n)\\n  where n is the number of nodes in the tree\\n- Space complexity:\\n- O(h)\\n- where h is the height of the tree\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private: \\n    void getLevelSum(TreeNode* root,int depth,vector<int>& levelSum)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        if(levelSum.size()==depth)\\n        {\\n            levelSum.push_back(root->val);\\n        }\\n        else{\\n            levelSum[depth]+=root->val;\\n        }\\n        getLevelSum(root->left,depth+1,levelSum);\\n        getLevelSum(root->right,depth+1,levelSum);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> levelSum;\\n        getLevelSum(root,0,levelSum);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val=0;\\n        int depth=1;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                int nodeChildSum=0;\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left!=NULL)\\n                {\\n                    nodeChildSum+=node->left->val;\\n                }\\n                if(node->right!=NULL)\\n                {\\n                    nodeChildSum+=node->right->val;\\n                }\\n                if(node->left)\\n                {\\n                    node->left->val=levelSum[depth]-nodeChildSum;\\n                    q.push(node->left);\\n                }\\n                if(node->right)\\n                {\\n                    node->right->val=levelSum[depth]-nodeChildSum;\\n                    q.push(node->right);\\n                }\\n            }\\n            depth++;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private: \\n    void getLevelSum(TreeNode* root,int depth,vector<int>& levelSum)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        if(levelSum.size()==depth)\\n        {\\n            levelSum.push_back(root->val);\\n        }\\n        else{\\n            levelSum[depth]+=root->val;\\n        }\\n        getLevelSum(root->left,depth+1,levelSum);\\n        getLevelSum(root->right,depth+1,levelSum);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> levelSum;\\n        getLevelSum(root,0,levelSum);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val=0;\\n        int depth=1;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                int nodeChildSum=0;\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left!=NULL)\\n                {\\n                    nodeChildSum+=node->left->val;\\n                }\\n                if(node->right!=NULL)\\n                {\\n                    nodeChildSum+=node->right->val;\\n                }\\n                if(node->left)\\n                {\\n                    node->left->val=levelSum[depth]-nodeChildSum;\\n                    q.push(node->left);\\n                }\\n                if(node->right)\\n                {\\n                    node->right->val=levelSum[depth]-nodeChildSum;\\n                    q.push(node->right);\\n                }\\n            }\\n            depth++;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892360,
                "title": "simple-java-recursion-2-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    HashMap<Integer,Integer>hm = new HashMap<>();\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        fill(root, 0);\\n        modify(root,0);\\n        root.val = 0;\\n        return root;\\n    }\\n\\n    public void modify(TreeNode root, int depth){\\n        if(root == null || (root.left == null && root.right == null))return;\\n        if(root.right == null)root.left.val = hm.get(depth+1)-root.left.val;\\n        else if(root.left == null)root.right.val = hm.get(depth+1)-root.right.val;\\n        else{\\n            int temp = hm.get(depth+1)-root.left.val-root.right.val;\\n            root.left.val = temp;\\n            root.right.val = temp;\\n        }\\n        modify(root.left, depth+1);\\n        modify(root.right, depth+1);\\n    }\\n\\n    public void fill(TreeNode root, int depth){\\n        if(root == null)return;\\n        int val = hm.getOrDefault(depth,0);\\n        hm.put(depth,val+root.val);\\n        fill(root.left, depth+1);\\n        fill(root.right, depth+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    HashMap<Integer,Integer>hm = new HashMap<>();\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        fill(root, 0);\\n        modify(root,0);\\n        root.val = 0;\\n        return root;\\n    }\\n\\n    public void modify(TreeNode root, int depth){\\n        if(root == null || (root.left == null && root.right == null))return;\\n        if(root.right == null)root.left.val = hm.get(depth+1)-root.left.val;\\n        else if(root.left == null)root.right.val = hm.get(depth+1)-root.right.val;\\n        else{\\n            int temp = hm.get(depth+1)-root.left.val-root.right.val;\\n            root.left.val = temp;\\n            root.right.val = temp;\\n        }\\n        modify(root.left, depth+1);\\n        modify(root.right, depth+1);\\n    }\\n\\n    public void fill(TreeNode root, int depth){\\n        if(root == null)return;\\n        int val = hm.getOrDefault(depth,0);\\n        hm.put(depth,val+root.val);\\n        fill(root.left, depth+1);\\n        fill(root.right, depth+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883029,
                "title": "well-commented-c-code-dfs",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Good very good question classical dfs question\\n\\n    // Stores sum at every depth\\n    unordered_map<int,int> depthSum;\\\\\\n\\n    // Stores child ---> parent \\n    unordered_map<TreeNode* , TreeNode*> parentChild;\\n\\n    // stores sum of both the child of a parent\\n    unordered_map<TreeNode* , int> parentSum;\\n\\n    // This dfs call will actually replace the values of all the nodes with the cousins sum\\n    void dfs2(TreeNode* root , int depth){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        if(root->left != NULL){\\n            dfs2(root->left , depth+1);\\n        }\\n\\n        if(root->right != NULL){\\n            dfs2(root->right , depth+1);\\n        }\\n\\n        int sum = depthSum[depth];\\n        int parentsum = 0;\\n        \\n        TreeNode* parent = parentChild[root];\\n        parentsum = parentSum[parent];\\n        \\n\\n        root->val = sum - parentsum;\\n    }\\n\\n    // Here in first dfs call we will try to fill all the three maps\\n    void dfs(TreeNode* root , int depth){\\n        if(root == NULL){\\n            return;\\n        }   \\n\\n        if(root->right != NULL){\\n            depthSum[depth+1] += root->right->val;\\n            parentSum[root] += root->right->val;\\n            parentChild[root->right] = root;\\n            dfs(root->right , depth+1);\\n        }\\n\\n        if(root->left != NULL){\\n            depthSum[depth+1] += root->left->val;\\n            parentSum[root] += root->left->val;\\n            parentChild[root->left] = root;\\n            dfs(root->left , depth+1);\\n        }\\n        return;\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == NULL){\\n            return root;\\n        }\\n\\n        \\n        // We are passing root and depth\\n        parentChild[root] = NULL;\\n        depthSum[0] = root->val;\\n        parentSum[NULL] = 0;\\n        dfs(root,0);\\n        dfs2(root,0);\\n        \\n        // At final to check if root->val != 0 we replace it with zero\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Good very good question classical dfs question\\n\\n    // Stores sum at every depth\\n    unordered_map<int,int> depthSum;\\\\\\n\\n    // Stores child ---> parent \\n    unordered_map<TreeNode* , TreeNode*> parentChild;\\n\\n    // stores sum of both the child of a parent\\n    unordered_map<TreeNode* , int> parentSum;\\n\\n    // This dfs call will actually replace the values of all the nodes with the cousins sum\\n    void dfs2(TreeNode* root , int depth){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        if(root->left != NULL){\\n            dfs2(root->left , depth+1);\\n        }\\n\\n        if(root->right != NULL){\\n            dfs2(root->right , depth+1);\\n        }\\n\\n        int sum = depthSum[depth];\\n        int parentsum = 0;\\n        \\n        TreeNode* parent = parentChild[root];\\n        parentsum = parentSum[parent];\\n        \\n\\n        root->val = sum - parentsum;\\n    }\\n\\n    // Here in first dfs call we will try to fill all the three maps\\n    void dfs(TreeNode* root , int depth){\\n        if(root == NULL){\\n            return;\\n        }   \\n\\n        if(root->right != NULL){\\n            depthSum[depth+1] += root->right->val;\\n            parentSum[root] += root->right->val;\\n            parentChild[root->right] = root;\\n            dfs(root->right , depth+1);\\n        }\\n\\n        if(root->left != NULL){\\n            depthSum[depth+1] += root->left->val;\\n            parentSum[root] += root->left->val;\\n            parentChild[root->left] = root;\\n            dfs(root->left , depth+1);\\n        }\\n        return;\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == NULL){\\n            return root;\\n        }\\n\\n        \\n        // We are passing root and depth\\n        parentChild[root] = NULL;\\n        depthSum[0] = root->val;\\n        parentSum[NULL] = 0;\\n        dfs(root,0);\\n        dfs2(root,0);\\n        \\n        // At final to check if root->val != 0 we replace it with zero\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878642,
                "title": "readable-one-pass-solution-in-c",
                "content": "This is an attempt to make [this (original)](https://leetcode.com/problems/cousins-in-binary-tree-ii/discuss/3420010/easy-short-efficient-clean-code) solution more readable.\\n```\\nclass Solution {\\npublic:\\n    int getChildrenSum(const TreeNode* node) {\\n        return ((node->left) ? node->left->val : 0) + ((node->right) ? node->right->val : 0);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        list <TreeNode*> q;\\n        q.push_back(root);\\n        \\n        root->val = 0;\\n        \\n        while(!q.empty()) {\\n            int nextLevelSum = 0;\\n            for(const TreeNode* node : q) {\\n                nextLevelSum += getChildrenSum(node);\\n            }\\n            \\n            int len = q.size();\\n            for(int i = 1; i <= len; i++) {\\n                TreeNode* curr = q.front();\\n                q.pop_front();\\n                \\n                int currNodeChildrenSum = getChildrenSum(curr);\\n                \\n                if(curr->left) {\\n                    curr->left->val = nextLevelSum - currNodeChildrenSum;\\n                    q.push_back(curr->left);\\n                }\\n                if(curr->right) {\\n                    curr->right->val = nextLevelSum - currNodeChildrenSum;\\n                    q.push_back(curr->right);\\n                }\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getChildrenSum(const TreeNode* node) {\\n        return ((node->left) ? node->left->val : 0) + ((node->right) ? node->right->val : 0);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        list <TreeNode*> q;\\n        q.push_back(root);\\n        \\n        root->val = 0;\\n        \\n        while(!q.empty()) {\\n            int nextLevelSum = 0;\\n            for(const TreeNode* node : q) {\\n                nextLevelSum += getChildrenSum(node);\\n            }\\n            \\n            int len = q.size();\\n            for(int i = 1; i <= len; i++) {\\n                TreeNode* curr = q.front();\\n                q.pop_front();\\n                \\n                int currNodeChildrenSum = getChildrenSum(curr);\\n                \\n                if(curr->left) {\\n                    curr->left->val = nextLevelSum - currNodeChildrenSum;\\n                    q.push_back(curr->left);\\n                }\\n                if(curr->right) {\\n                    curr->right->val = nextLevelSum - currNodeChildrenSum;\\n                    q.push_back(curr->right);\\n                }\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876864,
                "title": "c-2-pass-dfs",
                "content": "# Intuition\\n- DFS 1 : store sum of all levels.\\n- DFS 2 : $$root -> left$$, $$root -> right$$ = `(sum of level of [root]) - sum(root->left, root->right)`\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> l;\\n    void dfs1(TreeNode* root, int h) {\\n        if(!root) return;\\n        l[h] += root->val;\\n        dfs1(root->left, h + 1);\\n        dfs1(root->right, h + 1);\\n    }\\n\\n    void dfs2(TreeNode* root, int h = 0) {\\n        if(!root) return;\\n        int s = 0, lvl = l[h + 1];\\n        if(root->left) s += root->left->val;\\n        if(root->right) s += root->right->val;\\n        if(root->left) root->left->val = lvl - s;\\n        if(root->right) root->right->val = lvl - s;\\n        dfs2(root->left, h + 1);\\n        dfs2(root->right, h + 1);\\n    } \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        l.resize(100005, 0);\\n        dfs1(root, 0);\\n        dfs2(root);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> l;\\n    void dfs1(TreeNode* root, int h) {\\n        if(!root) return;\\n        l[h] += root->val;\\n        dfs1(root->left, h + 1);\\n        dfs1(root->right, h + 1);\\n    }\\n\\n    void dfs2(TreeNode* root, int h = 0) {\\n        if(!root) return;\\n        int s = 0, lvl = l[h + 1];\\n        if(root->left) s += root->left->val;\\n        if(root->right) s += root->right->val;\\n        if(root->left) root->left->val = lvl - s;\\n        if(root->right) root->right->val = lvl - s;\\n        dfs2(root->left, h + 1);\\n        dfs2(root->right, h + 1);\\n    } \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        l.resize(100005, 0);\\n        dfs1(root, 0);\\n        dfs2(root);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860491,
                "title": "easy-cpp-solution-using-recursion-and-mapping-brute-force-solution-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void getmp(TreeNode* root, map<TreeNode*, TreeNode*> &mp, map<TreeNode*, int> &smp, vector<int> &lsum, int level){\\n        if(root == NULL) return;\\n        if(level < lsum.size())\\n                lsum[level] += root->val;\\n            else\\n                lsum.push_back(root->val);\\n        if(root->left){\\n            mp[root->left] = root;\\n            smp[root] = root->left->val;\\n            getmp(root->left, mp, smp, lsum, level+1);\\n        }\\n        if(root->right){\\n            mp[root->right] = root;\\n            smp[root] += root->right->val;\\n            getmp(root->right, mp, smp, lsum, level+1);\\n        }\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == NULL) return root;\\n        else root->val = 0;\\n        if(root->left == NULL && root->right == NULL) return root;\\n        // For storing mappping of child with parent node\\n        map<TreeNode*, TreeNode*> mp;\\n        // For storing mapping of prent node with child nodes\\' sum\\n        map<TreeNode*, int> smp;\\n        // For storing level wise sum\\n        vector<int> lsum;\\n        // Getting all the values inserted into map\\n        getmp(root, mp, smp, lsum, 0);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        int level = 0;\\n        while(!q.empty()){\\n            TreeNode* front = q.front();\\n            q.pop();\\n            if(front == NULL){\\n                if(!q.empty()){\\n                    front = q.front();\\n                    q.pop();\\n                    q.push(NULL);\\n                    level++;\\n                }\\n                else break;\\n            }\\n            front->val = lsum[level] - smp[mp[front]];\\n            if(front->left)\\n                q.push(front->left);\\n            if(front->right)\\n                q.push(front->right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void getmp(TreeNode* root, map<TreeNode*, TreeNode*> &mp, map<TreeNode*, int> &smp, vector<int> &lsum, int level){\\n        if(root == NULL) return;\\n        if(level < lsum.size())\\n                lsum[level] += root->val;\\n            else\\n                lsum.push_back(root->val);\\n        if(root->left){\\n            mp[root->left] = root;\\n            smp[root] = root->left->val;\\n            getmp(root->left, mp, smp, lsum, level+1);\\n        }\\n        if(root->right){\\n            mp[root->right] = root;\\n            smp[root] += root->right->val;\\n            getmp(root->right, mp, smp, lsum, level+1);\\n        }\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == NULL) return root;\\n        else root->val = 0;\\n        if(root->left == NULL && root->right == NULL) return root;\\n        // For storing mappping of child with parent node\\n        map<TreeNode*, TreeNode*> mp;\\n        // For storing mapping of prent node with child nodes\\' sum\\n        map<TreeNode*, int> smp;\\n        // For storing level wise sum\\n        vector<int> lsum;\\n        // Getting all the values inserted into map\\n        getmp(root, mp, smp, lsum, 0);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        int level = 0;\\n        while(!q.empty()){\\n            TreeNode* front = q.front();\\n            q.pop();\\n            if(front == NULL){\\n                if(!q.empty()){\\n                    front = q.front();\\n                    q.pop();\\n                    q.push(NULL);\\n                    level++;\\n                }\\n                else break;\\n            }\\n            front->val = lsum[level] - smp[mp[front]];\\n            if(front->left)\\n                q.push(front->left);\\n            if(front->right)\\n                q.push(front->right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853893,
                "title": "golang-dfs-solution-beat-90",
                "content": "# Code\\n```go\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n\\tlevelSummation := make(map[int]int)\\n\\twalk(root, 0, levelSummation)\\n\\ttree := &TreeNode{\\n\\t\\tVal: 0,\\n\\t\\tLeft: nil,\\n\\t\\tRight: nil,\\n\\t}\\n\\tcalc(root, tree, 0, levelSummation)\\n\\treturn tree\\n}\\n\\nfunc walk(node *TreeNode, level int, levelSummation map[int]int) {\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\tlevelSummation[level] += node.Val\\n\\twalk(node.Left, level+1, levelSummation)\\n\\twalk(node.Right, level+1, levelSummation)\\n}\\n\\nfunc calc(node *TreeNode, resultTree *TreeNode, level int, levelSummation map[int]int) {\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\tlevel++\\n\\tval := 0\\n\\tif node.Left != nil {\\n\\t\\tval += node.Left.Val\\n\\t}\\n\\tif node.Right != nil {\\n\\t\\tval += node.Right.Val\\n\\t}\\n\\tif node.Left != nil {\\n\\t\\tresultTree.Left = &TreeNode{\\n\\t\\t\\tVal: levelSummation[level] - val,\\n\\t\\t\\tLeft: nil,\\n\\t\\t\\tRight: nil,\\n\\t\\t}\\n\\t\\tcalc(node.Left, resultTree.Left, level, levelSummation)\\n\\t}\\n\\tif node.Right != nil {\\n\\t\\tresultTree.Right = &TreeNode{\\n\\t\\t\\tVal: levelSummation[level] - val,\\n\\t\\t\\tLeft: nil,\\n\\t\\t\\tRight: nil,\\n\\t\\t}\\n\\t\\tcalc(node.Right, resultTree.Right, level, levelSummation)\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```go\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n\\tlevelSummation := make(map[int]int)\\n\\twalk(root, 0, levelSummation)\\n\\ttree := &TreeNode{\\n\\t\\tVal: 0,\\n\\t\\tLeft: nil,\\n\\t\\tRight: nil,\\n\\t}\\n\\tcalc(root, tree, 0, levelSummation)\\n\\treturn tree\\n}\\n\\nfunc walk(node *TreeNode, level int, levelSummation map[int]int) {\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\tlevelSummation[level] += node.Val\\n\\twalk(node.Left, level+1, levelSummation)\\n\\twalk(node.Right, level+1, levelSummation)\\n}\\n\\nfunc calc(node *TreeNode, resultTree *TreeNode, level int, levelSummation map[int]int) {\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\tlevel++\\n\\tval := 0\\n\\tif node.Left != nil {\\n\\t\\tval += node.Left.Val\\n\\t}\\n\\tif node.Right != nil {\\n\\t\\tval += node.Right.Val\\n\\t}\\n\\tif node.Left != nil {\\n\\t\\tresultTree.Left = &TreeNode{\\n\\t\\t\\tVal: levelSummation[level] - val,\\n\\t\\t\\tLeft: nil,\\n\\t\\t\\tRight: nil,\\n\\t\\t}\\n\\t\\tcalc(node.Left, resultTree.Left, level, levelSummation)\\n\\t}\\n\\tif node.Right != nil {\\n\\t\\tresultTree.Right = &TreeNode{\\n\\t\\t\\tVal: levelSummation[level] - val,\\n\\t\\t\\tLeft: nil,\\n\\t\\t\\tRight: nil,\\n\\t\\t}\\n\\t\\tcalc(node.Right, resultTree.Right, level, levelSummation)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3848282,
                "title": "bfs-with-hashmap-node-siblings-sums",
                "content": "```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        List<TreeNode> bfsQueue = new ArrayList<>();\\n        root.val = 0;\\n        bfsQueue.add(root);\\n        Map<TreeNode, Integer> parentChildrenSum = new HashMap<>();\\n\\n        while (!bfsQueue.isEmpty()) {\\n            List<TreeNode> nodesToProcessNext = new ArrayList<>();\\n            int sum = 0;\\n            for (TreeNode node : bfsQueue) {\\n                int childSum = 0;\\n                if (node.left != null) {\\n                    nodesToProcessNext.add(node.left);\\n                    childSum += node.left.val;\\n                }\\n                if (node.right != null) {\\n                    nodesToProcessNext.add(node.right);\\n                    childSum += node.right.val;\\n                }\\n\\n                if (node.left != null) {\\n                    parentChildrenSum.put(node.left, childSum);\\n                }\\n                if (node.right != null) {\\n                    parentChildrenSum.put(node.right, childSum);\\n                }\\n                sum += node.val;\\n            }\\n\\n            for (TreeNode node : bfsQueue) {\\n                node.val = sum - parentChildrenSum.getOrDefault(node, 0);\\n            }\\n\\n            bfsQueue = nodesToProcessNext;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        List<TreeNode> bfsQueue = new ArrayList<>();\\n        root.val = 0;\\n        bfsQueue.add(root);\\n        Map<TreeNode, Integer> parentChildrenSum = new HashMap<>();\\n\\n        while (!bfsQueue.isEmpty()) {\\n            List<TreeNode> nodesToProcessNext = new ArrayList<>();\\n            int sum = 0;\\n            for (TreeNode node : bfsQueue) {\\n                int childSum = 0;\\n                if (node.left != null) {\\n                    nodesToProcessNext.add(node.left);\\n                    childSum += node.left.val;\\n                }\\n                if (node.right != null) {\\n                    nodesToProcessNext.add(node.right);\\n                    childSum += node.right.val;\\n                }\\n\\n                if (node.left != null) {\\n                    parentChildrenSum.put(node.left, childSum);\\n                }\\n                if (node.right != null) {\\n                    parentChildrenSum.put(node.right, childSum);\\n                }\\n                sum += node.val;\\n            }\\n\\n            for (TreeNode node : bfsQueue) {\\n                node.val = sum - parentChildrenSum.getOrDefault(node, 0);\\n            }\\n\\n            bfsQueue = nodesToProcessNext;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844010,
                "title": "python-clean-bfs-solution",
                "content": "```python\\nfrom itertools import chain\\nfrom operator import attrgetter\\nfrom typing import Optional\\n\\nflatten = chain.from_iterable\\n\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        siblings = [[root]]\\n\\n        while siblings:\\n            self.update_siblings(siblings)\\n\\n            _siblings = []  # solution structure requires do-while loop\\n\\n            for parent in flatten(siblings):\\n                _siblings.append(children := [])\\n\\n                if parent.left:\\n                    children.append(parent.left)\\n\\n                if parent.right:\\n                    children.append(parent.right)\\n\\n            siblings = _siblings\\n\\n        return root\\n\\n    @staticmethod\\n    def update_siblings(siblings: list[list[TreeNode]]):\\n        \"\"\"\\n        if i and j be two value index in \"siblings\" and i != j then nodes in siblings[i]\\n        are sibling to nodes in siblings[j]\\n        :param siblings:\\n        \"\"\"\\n        values = [Solution.total_sum_of_node_values(children) for children in siblings]\\n        total = sum(values)\\n\\n        for children, child_val_sum in zip(siblings, values):\\n            sibling_val_sum = total - child_val_sum\\n\\n            for child in children:\\n                child.val = sibling_val_sum\\n\\n    @staticmethod\\n    def total_sum_of_node_values(nodes: list[TreeNode]) -> int:\\n        return sum(map(attrgetter(\\'val\\'), nodes))\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nfrom itertools import chain\\nfrom operator import attrgetter\\nfrom typing import Optional\\n\\nflatten = chain.from_iterable\\n\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        siblings = [[root]]\\n\\n        while siblings:\\n            self.update_siblings(siblings)\\n\\n            _siblings = []  # solution structure requires do-while loop\\n\\n            for parent in flatten(siblings):\\n                _siblings.append(children := [])\\n\\n                if parent.left:\\n                    children.append(parent.left)\\n\\n                if parent.right:\\n                    children.append(parent.right)\\n\\n            siblings = _siblings\\n\\n        return root\\n\\n    @staticmethod\\n    def update_siblings(siblings: list[list[TreeNode]]):\\n        \"\"\"\\n        if i and j be two value index in \"siblings\" and i != j then nodes in siblings[i]\\n        are sibling to nodes in siblings[j]\\n        :param siblings:\\n        \"\"\"\\n        values = [Solution.total_sum_of_node_values(children) for children in siblings]\\n        total = sum(values)\\n\\n        for children, child_val_sum in zip(siblings, values):\\n            sibling_val_sum = total - child_val_sum\\n\\n            for child in children:\\n                child.val = sibling_val_sum\\n\\n    @staticmethod\\n    def total_sum_of_node_values(nodes: list[TreeNode]) -> int:\\n        return sum(map(attrgetter(\\'val\\'), nodes))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841705,
                "title": "c-easy-to-understand-simple-traversal-to-store-sum-on-level-basis",
                "content": "First I am storing sum of nodes on level basis and keeping track of parent and its child. We can avoi storing parents too. And in the I am subtracting all sblings from sum so that we can get sum of cousins.\\n\\n```\\nvoid solve(TreeNode* root, TreeNode* parent, unordered_map<int,int> &mpLevel,unordered_map<TreeNode*,TreeNode*> &mpParent, int l){\\n        if(!root){\\n            return;\\n        }\\n        mpLevel[l] += root->val;\\n        mpParent[root] = parent;\\n        solve(root->left,root,mpLevel,mpParent,l+1);\\n        solve(root->right,root,mpLevel,mpParent,l+1);\\n    }\\n    void traverse(TreeNode* root, unordered_map<int,int> &mpLevel,unordered_map<TreeNode*,TreeNode*> &mpParent,unordered_map<TreeNode*,int> &cousinValue, int l){\\n        if(!root){\\n            return;\\n        }\\n        int s=0;\\n        s = mpLevel[l];\\n        TreeNode* parent = mpParent[root];\\n        if(!parent){\\n            s = s - root->val;\\n        }else{\\n            if(parent->left){\\n                s = s - parent->left->val;\\n            }\\n            if(parent->right){\\n                s = s - parent->right->val;\\n            }\\n        }\\n        cousinValue[root] = s;\\n        \\n        traverse(root->left,mpLevel,mpParent,cousinValue,l+1);\\n        traverse(root->right,mpLevel,mpParent,cousinValue,l+1);\\n    }\\n    void fillCousinValue(TreeNode* root, unordered_map<TreeNode*,int> &cousinValue){\\n        if(!root){\\n            return;\\n        }\\n        \\n        root->val = cousinValue[root];\\n        fillCousinValue(root->left,cousinValue);\\n        fillCousinValue(root->right,cousinValue);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mpLevel;\\n        unordered_map<TreeNode*,TreeNode*> mpParent;\\n        unordered_map<TreeNode*,int> cousinValue;\\n\\n        solve(root,nullptr,mpLevel,mpParent,1);\\n        traverse(root,mpLevel,mpParent,cousinValue,1);\\n        fillCousinValue(root,cousinValue);\\n        return root;\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nvoid solve(TreeNode* root, TreeNode* parent, unordered_map<int,int> &mpLevel,unordered_map<TreeNode*,TreeNode*> &mpParent, int l){\\n        if(!root){\\n            return;\\n        }\\n        mpLevel[l] += root->val;\\n        mpParent[root] = parent;\\n        solve(root->left,root,mpLevel,mpParent,l+1);\\n        solve(root->right,root,mpLevel,mpParent,l+1);\\n    }\\n    void traverse(TreeNode* root, unordered_map<int,int> &mpLevel,unordered_map<TreeNode*,TreeNode*> &mpParent,unordered_map<TreeNode*,int> &cousinValue, int l){\\n        if(!root){\\n            return;\\n        }\\n        int s=0;\\n        s = mpLevel[l];\\n        TreeNode* parent = mpParent[root];\\n        if(!parent){\\n            s = s - root->val;\\n        }else{\\n            if(parent->left){\\n                s = s - parent->left->val;\\n            }\\n            if(parent->right){\\n                s = s - parent->right->val;\\n            }\\n        }\\n        cousinValue[root] = s;\\n        \\n        traverse(root->left,mpLevel,mpParent,cousinValue,l+1);\\n        traverse(root->right,mpLevel,mpParent,cousinValue,l+1);\\n    }\\n    void fillCousinValue(TreeNode* root, unordered_map<TreeNode*,int> &cousinValue){\\n        if(!root){\\n            return;\\n        }\\n        \\n        root->val = cousinValue[root];\\n        fillCousinValue(root->left,cousinValue);\\n        fillCousinValue(root->right,cousinValue);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mpLevel;\\n        unordered_map<TreeNode*,TreeNode*> mpParent;\\n        unordered_map<TreeNode*,int> cousinValue;\\n\\n        solve(root,nullptr,mpLevel,mpParent,1);\\n        traverse(root,mpLevel,mpParent,cousinValue,1);\\n        fillCousinValue(root,cousinValue);\\n        return root;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3829849,
                "title": "easy-to-read-bfs-solution",
                "content": "bfs\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\'\\'\\'\\nGiven the root of a binary tree, replace the value of each node in the tree with the sum of all its cousins\\' values.\\nSo if you are given a tree with 3 pairs of cousins\\nIt will be the sum of the other two \\n\\nIDEA:\\n\\n    Level_sum - children_sum = sum_of_cousins\\n\\n    level_sum = sum of all the children in that level \\n    children_sum = given parent and its children: sum the children\\n\\n\\nBFS:\\n    Maintain level sum\\n    When working with current level : Maintain / build up sum for the next level\\n    That way, when working with that next level, we have that sum to begin with \\n\\n    CAVEAT:\\n        When encountering parents with left and right children:\\n            We need to update their values to be the sum \\n\\n            why?\\n            Those values will be the same to begin with \\n            solves many gaps of this problem\\n                level 1 == 0 \\n\\'\\'\\'\\n\\nfrom collections import deque\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        que = deque()\\n        que.append(root)\\n        level_sum = root.val \\n        while que:\\n            length = len(que)\\n            next_level_sum = 0\\n            for i in range(length):\\n                node = que.popleft()\\n                #update node value with cousins sum \\n                node.val = level_sum - node.val\\n\\n                #get next level sum to work with \\n                if node.left:\\n                    next_level_sum += node.left.val\\n                    que.append(node.left)\\n                \\n                if node.right:\\n                    next_level_sum += node.right.val\\n                    que.append(node.right)\\n                \\n                #CAVEAT updating values for parents with two kids \\n                if node.left and node.right:\\n                    children_sum = node.left.val + node.right.val\\n                    node.left.val = children_sum\\n                    node.right.val = children_sum\\n            \\n            level_sum = next_level_sum\\n        \\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\'\\'\\'\\nGiven the root of a binary tree, replace the value of each node in the tree with the sum of all its cousins\\' values.\\nSo if you are given a tree with 3 pairs of cousins\\nIt will be the sum of the other two \\n\\nIDEA:\\n\\n    Level_sum - children_sum = sum_of_cousins\\n\\n    level_sum = sum of all the children in that level \\n    children_sum = given parent and its children: sum the children\\n\\n\\nBFS:\\n    Maintain level sum\\n    When working with current level : Maintain / build up sum for the next level\\n    That way, when working with that next level, we have that sum to begin with \\n\\n    CAVEAT:\\n        When encountering parents with left and right children:\\n            We need to update their values to be the sum \\n\\n            why?\\n            Those values will be the same to begin with \\n            solves many gaps of this problem\\n                level 1 == 0 \\n\\'\\'\\'\\n\\nfrom collections import deque\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        que = deque()\\n        que.append(root)\\n        level_sum = root.val \\n        while que:\\n            length = len(que)\\n            next_level_sum = 0\\n            for i in range(length):\\n                node = que.popleft()\\n                #update node value with cousins sum \\n                node.val = level_sum - node.val\\n\\n                #get next level sum to work with \\n                if node.left:\\n                    next_level_sum += node.left.val\\n                    que.append(node.left)\\n                \\n                if node.right:\\n                    next_level_sum += node.right.val\\n                    que.append(node.right)\\n                \\n                #CAVEAT updating values for parents with two kids \\n                if node.left and node.right:\\n                    children_sum = node.left.val + node.right.val\\n                    node.left.val = children_sum\\n                    node.right.val = children_sum\\n            \\n            level_sum = next_level_sum\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825495,
                "title": "python3-level-order-traversal-beats-100",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        prev,curr = [],[root]\\n\\n        while curr:\\n            sums = []\\n            for node in curr:\\n                s = 0\\n                if node.left: s += node.left.val\\n                if node.right: s += node.right.val\\n                sums.append(s)\\n\\n            total = sum(sums)\\n            for i,node in enumerate(curr):\\n                if node.left: node.left.val = total - sums[i]\\n                if node.right: node.right.val = total - sums[i]\\n\\n            prev,curr = curr, [child for node in curr for child in [node.left,node.right] if child]\\n\\n        root.val = 0\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        prev,curr = [],[root]\\n\\n        while curr:\\n            sums = []\\n            for node in curr:\\n                s = 0\\n                if node.left: s += node.left.val\\n                if node.right: s += node.right.val\\n                sums.append(s)\\n\\n            total = sum(sums)\\n            for i,node in enumerate(curr):\\n                if node.left: node.left.val = total - sums[i]\\n                if node.right: node.right.val = total - sums[i]\\n\\n            prev,curr = curr, [child for node in curr for child in [node.left,node.right] if child]\\n\\n        root.val = 0\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820213,
                "title": "easy-bfs-solution-c-just-addition-and-subtraction-from-sum-of-levels",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// #include <queue>\\n// #include <vector>\\n// #include <cmath>\\n\\n// struct TreeNode {\\n//     int val;\\n//     TreeNode *left;\\n//     TreeNode *right;\\n//     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n//     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n//     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n// };\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if (root == nullptr) \\n        {\\n            return nullptr;\\n        }\\n\\n        queue<TreeNode*> q;\\n        vector<int> sumL;\\n        int sum = 0;\\n\\n        q.push(root);\\n        while (!q.empty()) \\n        {\\n            int size = q.size();\\n            while (size--) \\n            {\\n                TreeNode* t = q.front();\\n                sum += t->val;\\n                q.pop();\\n                if (t->left) \\n                {\\n                    q.push(t->left);\\n                }\\n                if (t->right) \\n                {\\n                    q.push(t->right);\\n                }\\n            }\\n            sumL.push_back(sum);\\n            sum = 0;\\n        }\\n\\n\\n        queue<TreeNode*> q1; \\n        q1.push(root);\\n        int i = 0;\\n        while (!q1.empty()) \\n        {\\n            int size = q1.size();\\n            while (size--) \\n            {\\n                TreeNode* t = q1.front();\\n                q1.pop();\\n                 t->val = abs(t->val - sumL[i]);\\n                if (t->left && t->right) \\n                {\\n                    int l=t->left->val;\\n                    int r=t->right->val;\\n                    t->left->val = l + r;\\n                    t->right->val = r + l;\\n                }\\n                if (t->left) \\n                {\\n                    q1.push(t->left);\\n                }\\n                if (t->right) \\n                {\\n                    q1.push(t->right);\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// #include <queue>\\n// #include <vector>\\n// #include <cmath>\\n\\n// struct TreeNode {\\n//     int val;\\n//     TreeNode *left;\\n//     TreeNode *right;\\n//     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n//     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n//     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n// };\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if (root == nullptr) \\n        {\\n            return nullptr;\\n        }\\n\\n        queue<TreeNode*> q;\\n        vector<int> sumL;\\n        int sum = 0;\\n\\n        q.push(root);\\n        while (!q.empty()) \\n        {\\n            int size = q.size();\\n            while (size--) \\n            {\\n                TreeNode* t = q.front();\\n                sum += t->val;\\n                q.pop();\\n                if (t->left) \\n                {\\n                    q.push(t->left);\\n                }\\n                if (t->right) \\n                {\\n                    q.push(t->right);\\n                }\\n            }\\n            sumL.push_back(sum);\\n            sum = 0;\\n        }\\n\\n\\n        queue<TreeNode*> q1; \\n        q1.push(root);\\n        int i = 0;\\n        while (!q1.empty()) \\n        {\\n            int size = q1.size();\\n            while (size--) \\n            {\\n                TreeNode* t = q1.front();\\n                q1.pop();\\n                 t->val = abs(t->val - sumL[i]);\\n                if (t->left && t->right) \\n                {\\n                    int l=t->left->val;\\n                    int r=t->right->val;\\n                    t->left->val = l + r;\\n                    t->right->val = r + l;\\n                }\\n                if (t->left) \\n                {\\n                    q1.push(t->left);\\n                }\\n                if (t->right) \\n                {\\n                    q1.push(t->right);\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3818772,
                "title": "c-simple-solution-using-level-order-and-parent-mapping",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void ParentMapping(TreeNode* root, unordered_map<TreeNode*, TreeNode*> &parent){\\n    if(root==NULL)\\n    return;\\n    if(root->left==NULL && root->right==NULL)\\n    return;\\n\\n    if(root->left){\\n        TreeNode* child = root->left;\\n        parent[child] = root;\\n        ParentMapping(root->left, parent);\\n    }\\n    if(root->right){\\n        TreeNode* child = root->right;\\n        parent[child] = root;\\n        ParentMapping(root->right, parent);\\n    }\\n}\\n\\nvoid levelOrder(TreeNode* &root, unordered_map<TreeNode*, TreeNode*> &parent){\\n    queue<TreeNode*> q;\\n    q.push(root);\\n\\n    while(!q.empty()){\\n        \\n        unordered_map<TreeNode*, int> mp;\\n        int sum = 0;\\n        queue<TreeNode*> temp;\\n        int n = q.size();\\n\\n        for(int i=0 ;i<n ;i++){\\n            TreeNode* frt = q.front();\\n            q.pop();\\n\\n            temp.push(frt);\\n            sum += frt->val;\\n\\n            if(mp.find(parent[frt]) == mp.end())\\n            mp[parent[frt]] = frt->val;\\n            else\\n            mp[parent[frt]] = mp[parent[frt]]+frt->val;\\n\\n            if(frt->left)\\n            q.push(frt->left);\\n            if(frt->right)\\n            q.push(frt->right);\\n        }\\n        \\n        while(!temp.empty()){\\n            TreeNode* frt = temp.front();\\n            temp.pop();\\n\\n            frt->val = sum-mp[parent[frt]];\\n        }\\n    }\\n    return;\\n}\\n\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<TreeNode*, TreeNode*> parent;\\n        parent[root] = new TreeNode(-1);\\n        ParentMapping(root, parent);\\n\\n        int depthX = -1, depthY = -1;\\n        levelOrder(root, parent);\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void ParentMapping(TreeNode* root, unordered_map<TreeNode*, TreeNode*> &parent){\\n    if(root==NULL)\\n    return;\\n    if(root->left==NULL && root->right==NULL)\\n    return;\\n\\n    if(root->left){\\n        TreeNode* child = root->left;\\n        parent[child] = root;\\n        ParentMapping(root->left, parent);\\n    }\\n    if(root->right){\\n        TreeNode* child = root->right;\\n        parent[child] = root;\\n        ParentMapping(root->right, parent);\\n    }\\n}\\n\\nvoid levelOrder(TreeNode* &root, unordered_map<TreeNode*, TreeNode*> &parent){\\n    queue<TreeNode*> q;\\n    q.push(root);\\n\\n    while(!q.empty()){\\n        \\n        unordered_map<TreeNode*, int> mp;\\n        int sum = 0;\\n        queue<TreeNode*> temp;\\n        int n = q.size();\\n\\n        for(int i=0 ;i<n ;i++){\\n            TreeNode* frt = q.front();\\n            q.pop();\\n\\n            temp.push(frt);\\n            sum += frt->val;\\n\\n            if(mp.find(parent[frt]) == mp.end())\\n            mp[parent[frt]] = frt->val;\\n            else\\n            mp[parent[frt]] = mp[parent[frt]]+frt->val;\\n\\n            if(frt->left)\\n            q.push(frt->left);\\n            if(frt->right)\\n            q.push(frt->right);\\n        }\\n        \\n        while(!temp.empty()){\\n            TreeNode* frt = temp.front();\\n            temp.pop();\\n\\n            frt->val = sum-mp[parent[frt]];\\n        }\\n    }\\n    return;\\n}\\n\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<TreeNode*, TreeNode*> parent;\\n        parent[root] = new TreeNode(-1);\\n        ParentMapping(root, parent);\\n\\n        int depthX = -1, depthY = -1;\\n        levelOrder(root, parent);\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813889,
                "title": "using-hashmap-and-level-order",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root==null)return root;\\n       HashMap<Integer,Integer> map=new HashMap<>();\\n       int lvl=0;\\n       Queue <TreeNode> q=new ArrayDeque<>();\\n        if(root!=null)\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int s=q.size();\\n            int max=0;\\n\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode curr=q.remove();\\n                max+=curr.val;\\n                if(curr.left!=null)\\n                {\\n                    q.offer(curr.left);\\n                }\\n                if(curr.right!=null)\\n                {\\n                    q.offer(curr.right);\\n                }\\n            }map.put(lvl,max);  \\n            lvl++;\\n        }\\n        lvl=0;\\n        root.val=0;\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int s=q.size();\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode curr=q.remove();\\n                int sum=0;\\n                if(curr.left!=null)\\n                {\\n                    sum+=curr.left.val;\\n                }\\n                if(curr.right!=null)\\n                {\\n                    sum+=curr.right.val;\\n                }\\n                 if(curr.left!=null)\\n                {\\n                    curr.left.val=map.get(lvl+1)-sum;\\n                    q.offer(curr.left);\\n                }\\n                if(curr.right!=null)\\n                {\\n                    curr.right.val=map.get(lvl+1)-sum;\\n                    q.offer(curr.right);\\n                }\\n            } \\n            lvl++;\\n        }\\n      \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root==null)return root;\\n       HashMap<Integer,Integer> map=new HashMap<>();\\n       int lvl=0;\\n       Queue <TreeNode> q=new ArrayDeque<>();\\n        if(root!=null)\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int s=q.size();\\n            int max=0;\\n\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode curr=q.remove();\\n                max+=curr.val;\\n                if(curr.left!=null)\\n                {\\n                    q.offer(curr.left);\\n                }\\n                if(curr.right!=null)\\n                {\\n                    q.offer(curr.right);\\n                }\\n            }map.put(lvl,max);  \\n            lvl++;\\n        }\\n        lvl=0;\\n        root.val=0;\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int s=q.size();\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode curr=q.remove();\\n                int sum=0;\\n                if(curr.left!=null)\\n                {\\n                    sum+=curr.left.val;\\n                }\\n                if(curr.right!=null)\\n                {\\n                    sum+=curr.right.val;\\n                }\\n                 if(curr.left!=null)\\n                {\\n                    curr.left.val=map.get(lvl+1)-sum;\\n                    q.offer(curr.left);\\n                }\\n                if(curr.right!=null)\\n                {\\n                    curr.right.val=map.get(lvl+1)-sum;\\n                    q.offer(curr.right);\\n                }\\n            } \\n            lvl++;\\n        }\\n      \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813678,
                "title": "c-solution-using-inorder-and-level-order-traversal-beats-89-15",
                "content": "# Complexity\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root, vector<long long> &v, int level){\\n        if(root == nullptr){\\n            return;\\n        }\\n        int sum = 0;\\n        if(root->left){\\n            sum += root->left->val;\\n        }\\n        if(root->right){\\n            sum += root->right->val;\\n        }\\n        if(root->left){\\n            root->left->val = v[level] - sum;\\n        }\\n        if(root->right){\\n            root->right->val = v[level] - sum;\\n        }\\n        solve(root->left, v, level+1);\\n        solve(root->right, v, level+1);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<long long> v;\\n        int level = 1;\\n        kthLargestLevelSum(root, v);\\n        if(root){\\n            root->val = 0;\\n        }\\n        solve(root, v, level);\\n        return root;\\n    }\\n    void kthLargestLevelSum(TreeNode* root, vector<long long> &v) {\\n        queue<TreeNode*> q;\\n        long long sum = 0;\\n        q.push(root);\\n        q.push(nullptr);\\n        \\n        while(!q.empty()){\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node == nullptr){\\n                v.push_back(sum);\\n                sum = 0;\\n                if(!q.empty()){\\n                    q.push(nullptr);\\n                }\\n            }else{\\n                sum += node->val;\\n                if(node->left){\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root, vector<long long> &v, int level){\\n        if(root == nullptr){\\n            return;\\n        }\\n        int sum = 0;\\n        if(root->left){\\n            sum += root->left->val;\\n        }\\n        if(root->right){\\n            sum += root->right->val;\\n        }\\n        if(root->left){\\n            root->left->val = v[level] - sum;\\n        }\\n        if(root->right){\\n            root->right->val = v[level] - sum;\\n        }\\n        solve(root->left, v, level+1);\\n        solve(root->right, v, level+1);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<long long> v;\\n        int level = 1;\\n        kthLargestLevelSum(root, v);\\n        if(root){\\n            root->val = 0;\\n        }\\n        solve(root, v, level);\\n        return root;\\n    }\\n    void kthLargestLevelSum(TreeNode* root, vector<long long> &v) {\\n        queue<TreeNode*> q;\\n        long long sum = 0;\\n        q.push(root);\\n        q.push(nullptr);\\n        \\n        while(!q.empty()){\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node == nullptr){\\n                v.push_back(sum);\\n                sum = 0;\\n                if(!q.empty()){\\n                    q.push(nullptr);\\n                }\\n            }else{\\n                sum += node->val;\\n                if(node->left){\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806098,
                "title": "c-bfs-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val=0;\\n        \\n        \\n        while(q.empty()==false){\\n            int n=q.size();\\n            int sum=0;\\n            vector<TreeNode*> childs;\\n            for(int i=0;i<n;i++){\\n                auto node=q.front();\\n                q.pop();\\n                childs.push_back(node);\\n                if(node->left){\\n                    q.push(node->left);\\n                    sum+=node->left->val;\\n                    // childs.push_back(node->left);\\n                }\\n                \\n                if(node->right){\\n                    q.push(node->right);\\n                    sum+=node->right->val;\\n                    // childs.push_back(node->right);\\n                }\\n                \\n            }\\n            \\n            for(auto child:childs){\\n                int dummySum=sum;\\n                // cout<<sum<<\"\\\\n\";\\n                if(child->left){\\n                    dummySum-=child->left->val;\\n                }\\n                \\n                if(child->right){\\n                    dummySum-=child->right->val;\\n                }\\n                if(child->left){\\n                    child->left->val=dummySum;\\n                }\\n                if(child->right){\\n                    child->right->val=dummySum;\\n                }\\n            }\\n            \\n            \\n            \\n        }\\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val=0;\\n        \\n        \\n        while(q.empty()==false){\\n            int n=q.size();\\n            int sum=0;\\n            vector<TreeNode*> childs;\\n            for(int i=0;i<n;i++){\\n                auto node=q.front();\\n                q.pop();\\n                childs.push_back(node);\\n                if(node->left){\\n                    q.push(node->left);\\n                    sum+=node->left->val;\\n                    // childs.push_back(node->left);\\n                }\\n                \\n                if(node->right){\\n                    q.push(node->right);\\n                    sum+=node->right->val;\\n                    // childs.push_back(node->right);\\n                }\\n                \\n            }\\n            \\n            for(auto child:childs){\\n                int dummySum=sum;\\n                // cout<<sum<<\"\\\\n\";\\n                if(child->left){\\n                    dummySum-=child->left->val;\\n                }\\n                \\n                if(child->right){\\n                    dummySum-=child->right->val;\\n                }\\n                if(child->left){\\n                    child->left->val=dummySum;\\n                }\\n                if(child->right){\\n                    child->right->val=dummySum;\\n                }\\n            }\\n            \\n            \\n            \\n        }\\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3800491,
                "title": "c-bfs-o-n-one-traversal-super-easy-solution-using-child-sum-and-current-and-last-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(2^H)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==NULL) return root;\\n        queue<pair<TreeNode*,long long int>> q;\\n        q.push({root,root->val});\\n        int long long lastSum=root->val;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            long long int currSum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n                auto it=q.front();\\n                TreeNode* currNode=it.first;\\n                q.pop();\\n                long long int childSum=0;\\n                if(currNode->left) childSum+=currNode->left->val;\\n                if(currNode->right) childSum+=currNode->right->val;\\n                currSum+=childSum;\\n                if(currNode->left) q.push({currNode->left,childSum});\\n                if(currNode->right)q.push({currNode->right,childSum});\\n                currNode->val=abs(lastSum-it.second);\\n            }\\n            lastSum=currSum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==NULL) return root;\\n        queue<pair<TreeNode*,long long int>> q;\\n        q.push({root,root->val});\\n        int long long lastSum=root->val;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            long long int currSum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n                auto it=q.front();\\n                TreeNode* currNode=it.first;\\n                q.pop();\\n                long long int childSum=0;\\n                if(currNode->left) childSum+=currNode->left->val;\\n                if(currNode->right) childSum+=currNode->right->val;\\n                currSum+=childSum;\\n                if(currNode->left) q.push({currNode->left,childSum});\\n                if(currNode->right)q.push({currNode->right,childSum});\\n                currNode->val=abs(lastSum-it.second);\\n            }\\n            lastSum=currSum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789552,
                "title": "easy-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity:\\nO(h) , h=height of the binary tree\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   void rec(TreeNode* node,int sum,vector<int>&v,int level)\\n   {\\n       if (!node) return;\\n       node->val=v[level]-sum;\\n       int cur=0;\\n       if (node->left) cur+=node->left->val;\\n       if (node->right) cur+=node->right->val;\\n       rec(node->left,cur,v,level+1);\\n       rec(node->right,cur,v,level+1);\\n\\n   }\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       vector<int>v;\\n       while(!q.empty())\\n       {\\n           int sz=q.size();\\n           int sum=0;\\n           while(sz--)\\n           {\\n               TreeNode* node=q.front();\\n               q.pop();\\n               sum+=node->val;\\n               if (node->left)\\n               {\\n                   q.push(node->left);\\n               }\\n               if (node->right)\\n               {\\n                   q.push(node->right);\\n               }\\n           }\\n           v.push_back(sum);\\n       }\\n       rec(root,root->val,v,0);\\n       return root;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   void rec(TreeNode* node,int sum,vector<int>&v,int level)\\n   {\\n       if (!node) return;\\n       node->val=v[level]-sum;\\n       int cur=0;\\n       if (node->left) cur+=node->left->val;\\n       if (node->right) cur+=node->right->val;\\n       rec(node->left,cur,v,level+1);\\n       rec(node->right,cur,v,level+1);\\n\\n   }\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       vector<int>v;\\n       while(!q.empty())\\n       {\\n           int sz=q.size();\\n           int sum=0;\\n           while(sz--)\\n           {\\n               TreeNode* node=q.front();\\n               q.pop();\\n               sum+=node->val;\\n               if (node->left)\\n               {\\n                   q.push(node->left);\\n               }\\n               if (node->right)\\n               {\\n                   q.push(node->right);\\n               }\\n           }\\n           v.push_back(sum);\\n       }\\n       rec(root,root->val,v,0);\\n       return root;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785332,
                "title": "python-medium",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        alias = root\\n        \\n        q = deque()\\n        q.append((root, None, 0))\\n        \\n        level = 0\\n        \\n        \\n        while q:\\n            \\n            nxt = deque()\\n            \\n            \\n            total = 0\\n            \\n            for n, par, other in q:\\n                total += n.val\\n                \\n                \\n            \\n            while q:\\n                node, par, otherVal = q.popleft()\\n                \\n                \\n                        \\n                node.val = total - node.val - otherVal\\n                \\n                \\n                if node.left and node.right:\\n                    nxt.append((node.left, node, node.right.val))\\n                    nxt.append((node.right, node, node.left.val))\\n                    \\n                elif node.left:\\n                    nxt.append((node.left, node, 0))\\n                    \\n                elif node.right:\\n                    nxt.append((node.right, node, 0))\\n                    \\n                \\n                \\n                \\n        \\n        \\n            \\n            q = nxt\\n            level += 1\\n            \\n        \\n        return alias\\n            \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        alias = root\\n        \\n        q = deque()\\n        q.append((root, None, 0))\\n        \\n        level = 0\\n        \\n        \\n        while q:\\n            \\n            nxt = deque()\\n            \\n            \\n            total = 0\\n            \\n            for n, par, other in q:\\n                total += n.val\\n                \\n                \\n            \\n            while q:\\n                node, par, otherVal = q.popleft()\\n                \\n                \\n                        \\n                node.val = total - node.val - otherVal\\n                \\n                \\n                if node.left and node.right:\\n                    nxt.append((node.left, node, node.right.val))\\n                    nxt.append((node.right, node, node.left.val))\\n                    \\n                elif node.left:\\n                    nxt.append((node.left, node, 0))\\n                    \\n                elif node.right:\\n                    nxt.append((node.right, node, 0))\\n                    \\n                \\n                \\n                \\n        \\n        \\n            \\n            q = nxt\\n            level += 1\\n            \\n        \\n        return alias\\n            \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784425,
                "title": "2-times-bfs-level-order-traversal-clean-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst calulcate level order sum and store in map then replace values by calculating children sum and substracting it from children\\'s level sum\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe use one map to store sum of all nodes at a level and one queue for doing level order traversal/BFS.\\nfirst calulcate level order sum and store in map,set root\\'s value to zero, then replace values by calculating children sum and substracting it from children\\'s level sum\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void CalculateLevelSum(unordered_map<int,int> &mp,queue<TreeNode*> &q); \\n    void changeValues(unordered_map<int,int> &mp,queue<TreeNode*> &q);\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        CalculateLevelSum(mp,q);\\n        root->val=0;\\n        q.push(root);\\n        changeValues(mp,q);\\n        return root;\\n    }\\n};\\nvoid Solution::CalculateLevelSum(unordered_map<int,int> &mp,queue<TreeNode*> &q)\\n{\\n    int level=1;\\n    while(!q.empty())\\n    {\\n        int n=q.size(),sum=0;\\n        while(n--)\\n        {\\n            TreeNode *f=q.front();\\n            q.pop();\\n            sum+=f->val;\\n            if(f->left)\\n                q.push(f->left);\\n            if(f->right)\\n                q.push(f->right);\\n        }\\n        mp[level]=sum;\\n        level++;\\n    }\\n}\\nvoid Solution::changeValues(unordered_map<int,int> &mp,queue<TreeNode*> &q)\\n{\\n    int level=1;\\n    while(!q.empty())\\n    {\\n        int n=q.size();\\n        while(n--)\\n        {\\n            int sum=0;\\n            TreeNode *f=q.front();\\n            q.pop();\\n            if(f->left) sum+=f->left->val;\\n            if(f->right) sum+=f->right->val;\\n            if(f->left)\\n            {\\n                f->left->val=mp[level+1]-sum;\\n                q.push(f->left);\\n            }\\n            if(f->right)\\n            {\\n                f->right->val=mp[level+1]-sum;\\n                q.push(f->right);\\n            } \\n        }\\n        level++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void CalculateLevelSum(unordered_map<int,int> &mp,queue<TreeNode*> &q); \\n    void changeValues(unordered_map<int,int> &mp,queue<TreeNode*> &q);\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        CalculateLevelSum(mp,q);\\n        root->val=0;\\n        q.push(root);\\n        changeValues(mp,q);\\n        return root;\\n    }\\n};\\nvoid Solution::CalculateLevelSum(unordered_map<int,int> &mp,queue<TreeNode*> &q)\\n{\\n    int level=1;\\n    while(!q.empty())\\n    {\\n        int n=q.size(),sum=0;\\n        while(n--)\\n        {\\n            TreeNode *f=q.front();\\n            q.pop();\\n            sum+=f->val;\\n            if(f->left)\\n                q.push(f->left);\\n            if(f->right)\\n                q.push(f->right);\\n        }\\n        mp[level]=sum;\\n        level++;\\n    }\\n}\\nvoid Solution::changeValues(unordered_map<int,int> &mp,queue<TreeNode*> &q)\\n{\\n    int level=1;\\n    while(!q.empty())\\n    {\\n        int n=q.size();\\n        while(n--)\\n        {\\n            int sum=0;\\n            TreeNode *f=q.front();\\n            q.pop();\\n            if(f->left) sum+=f->left->val;\\n            if(f->right) sum+=f->right->val;\\n            if(f->left)\\n            {\\n                f->left->val=mp[level+1]-sum;\\n                q.push(f->left);\\n            }\\n            if(f->right)\\n            {\\n                f->right->val=mp[level+1]-sum;\\n                q.push(f->right);\\n            } \\n        }\\n        level++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780429,
                "title": "python-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nfrom queue import Queue\\nclass Solution:\\n    def dfs(self, root, parent, level_sum, depth, clone):\\n        if root is None:\\n            return\\n        if parent is None:\\n            clone.val = 0\\n            self.dfs(root.left, root, level_sum, depth+1, clone.left)\\n            self.dfs(root.right, root, level_sum, depth+1, clone.right)\\n        else:\\n            siblings_sum = 0\\n            if parent.left:\\n                siblings_sum+=parent.left.val\\n            if parent.right:\\n                siblings_sum+=parent.right.val\\n            cousins_sum = level_sum[depth] - siblings_sum\\n            clone.val = cousins_sum\\n            self.dfs(root.left, root, level_sum, depth+1, clone.left)\\n            self.dfs(root.right, root, level_sum, depth+1, clone.right)\\n            \\n    def copy_tree(self, root):\\n        if root is None:\\n            return None\\n        new_node = TreeNode(root.val)\\n        new_node.left = self.copy_tree(root.left)\\n        new_node.right = self.copy_tree(root.right)\\n        return new_node\\n    \\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_sum = {}\\n        q = Queue(maxsize=0)\\n        q.put(root)\\n        depth = 0\\n        while q.empty() is False:\\n            curr_nodes = []\\n            while q.empty() is False:\\n                crr = q.get()\\n                curr_nodes.append(crr)\\n            sum = 0\\n            for x in curr_nodes:\\n                sum = sum + x.val\\n            level_sum[depth] = sum\\n            for x in curr_nodes:\\n                if x.left is not None:\\n                    q.put(x.left)\\n                if x.right is not None:\\n                    q.put(x.right)\\n            depth+=1\\n        #print(level_sum)\\n        clone = self.copy_tree(root)\\n        self.dfs(root, None, level_sum, 0, clone)\\n        return clone\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nfrom queue import Queue\\nclass Solution:\\n    def dfs(self, root, parent, level_sum, depth, clone):\\n        if root is None:\\n            return\\n        if parent is None:\\n            clone.val = 0\\n            self.dfs(root.left, root, level_sum, depth+1, clone.left)\\n            self.dfs(root.right, root, level_sum, depth+1, clone.right)\\n        else:\\n            siblings_sum = 0\\n            if parent.left:\\n                siblings_sum+=parent.left.val\\n            if parent.right:\\n                siblings_sum+=parent.right.val\\n            cousins_sum = level_sum[depth] - siblings_sum\\n            clone.val = cousins_sum\\n            self.dfs(root.left, root, level_sum, depth+1, clone.left)\\n            self.dfs(root.right, root, level_sum, depth+1, clone.right)\\n            \\n    def copy_tree(self, root):\\n        if root is None:\\n            return None\\n        new_node = TreeNode(root.val)\\n        new_node.left = self.copy_tree(root.left)\\n        new_node.right = self.copy_tree(root.right)\\n        return new_node\\n    \\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_sum = {}\\n        q = Queue(maxsize=0)\\n        q.put(root)\\n        depth = 0\\n        while q.empty() is False:\\n            curr_nodes = []\\n            while q.empty() is False:\\n                crr = q.get()\\n                curr_nodes.append(crr)\\n            sum = 0\\n            for x in curr_nodes:\\n                sum = sum + x.val\\n            level_sum[depth] = sum\\n            for x in curr_nodes:\\n                if x.left is not None:\\n                    q.put(x.left)\\n                if x.right is not None:\\n                    q.put(x.right)\\n            depth+=1\\n        #print(level_sum)\\n        clone = self.copy_tree(root)\\n        self.dfs(root, None, level_sum, 0, clone)\\n        return clone\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776780,
                "title": "c-solution-using-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,vector<pair<TreeNode*,int>>> m;\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        traverse(root, 0, NULL);\\n        cousinSum(root, 0, NULL);\\n        return root;\\n    }\\n\\n    void traverse(TreeNode* r, int d, TreeNode* prev){\\n        if(r==NULL) return;\\n        \\n        m[d].push_back(make_pair(prev, r->val));\\n        \\n        traverse(r->left, d+1, r);\\n        traverse(r->right, d+1, r);\\n    }\\n\\n    void cousinSum(TreeNode* r, int d, TreeNode* prev){\\n        if(r==NULL) return;\\n        int sum = 0;\\n        for(auto it : m[d]){\\n            if(it.first != prev && prev != NULL) sum += it.second;\\n        }\\n        r->val = sum;\\n        cousinSum(r->left, d + 1, r);\\n        cousinSum(r->right, d + 1, r);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,vector<pair<TreeNode*,int>>> m;\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        traverse(root, 0, NULL);\\n        cousinSum(root, 0, NULL);\\n        return root;\\n    }\\n\\n    void traverse(TreeNode* r, int d, TreeNode* prev){\\n        if(r==NULL) return;\\n        \\n        m[d].push_back(make_pair(prev, r->val));\\n        \\n        traverse(r->left, d+1, r);\\n        traverse(r->right, d+1, r);\\n    }\\n\\n    void cousinSum(TreeNode* r, int d, TreeNode* prev){\\n        if(r==NULL) return;\\n        int sum = 0;\\n        for(auto it : m[d]){\\n            if(it.first != prev && prev != NULL) sum += it.second;\\n        }\\n        r->val = sum;\\n        cousinSum(r->left, d + 1, r);\\n        cousinSum(r->right, d + 1, r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770660,
                "title": "level-ordertraversal-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void func(TreeNode *root,int sum,int h,vector<int>&presum)\\n    {\\n        if(root==NULL)\\n            return;\\n        int tmp=0;\\n        if(root->right!=NULL)\\n            tmp+=root->right->val;\\n        if(root->left!=NULL)\\n            tmp+=root->left->val;\\n        root->val=presum[h]-sum;\\n        func(root->left,tmp,h+1,presum);\\n        func(root->right,tmp,h+1,presum);\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int>presum;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            int sum=0;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* node=q.front();\\n                q.pop();\\n                sum+=node->val;\\n\\n                if(node->left!=NULL)\\n                    q.push(node->left);\\n\\n                if(node->right!=NULL)\\n                    q.push(node->right);\\n            }\\n            presum.push_back(sum);\\n        }\\n     \\n        func(root,root->val,0,presum);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void func(TreeNode *root,int sum,int h,vector<int>&presum)\\n    {\\n        if(root==NULL)\\n            return;\\n        int tmp=0;\\n        if(root->right!=NULL)\\n            tmp+=root->right->val;\\n        if(root->left!=NULL)\\n            tmp+=root->left->val;\\n        root->val=presum[h]-sum;\\n        func(root->left,tmp,h+1,presum);\\n        func(root->right,tmp,h+1,presum);\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int>presum;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            int sum=0;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* node=q.front();\\n                q.pop();\\n                sum+=node->val;\\n\\n                if(node->left!=NULL)\\n                    q.push(node->left);\\n\\n                if(node->right!=NULL)\\n                    q.push(node->right);\\n            }\\n            presum.push_back(sum);\\n        }\\n     \\n        func(root,root->val,0,presum);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765298,
                "title": "python-bfs-o-n-no-deque",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing BFS to access nodes level by level. Calculate the sum of each level in first iteration, and subtract the value of `currrent node and its brother` to get the `cousin sum` in second iteration.\\n\\nInstead of using a deque, I use two variables, `cur_level` and `next_level`. This is also a queue because we append children to `next_level` while iterating `cur_level`, and disregard the original `cur_level` and reassign `next_level` to `cur_level` when iteration is done.\\n\\n**First For-Loop:**\\nCalculate the sum of current level, and append the children along with sum of its left child\\'s value and right child\\'s value. If a child is missing, we treat its value as 0. The reason we push the sum of children is `cousin_sum = level_sum - brother_sum`.\\n\\n**Second For-Loop:**\\nUse the formula `cousin_sum = level_sum - brother_sum` to get the cousin sum for each node and update the value of each node.\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        # find cur level sum\\n        # when pushing the node, push the sum of its brother also, so we can get the sum of cousins by substracting it\\n        \\n        cur_level, next_level = [[root, root.val]], []\\n        while cur_level:\\n            level_sum = 0\\n            # calculate current level sum and push the next level to queue\\n            for [node, brother_sum] in cur_level:\\n                level_sum += node.val\\n\\n                left_val = node.left.val if node.left else 0\\n                right_val = node.right.val if node.right else 0\\n                brother_sum = left_val + right_val\\n                if node.left:\\n                    next_level.append([node.left, brother_sum])\\n                if node.right:\\n                    next_level.append([node.right, brother_sum])\\n\\n            # replace the value of current level nodes\\n            for [node, brother_sum] in cur_level:\\n                node.val = level_sum - brother_sum\\n            \\n            cur_level, next_level = next_level, []\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        # find cur level sum\\n        # when pushing the node, push the sum of its brother also, so we can get the sum of cousins by substracting it\\n        \\n        cur_level, next_level = [[root, root.val]], []\\n        while cur_level:\\n            level_sum = 0\\n            # calculate current level sum and push the next level to queue\\n            for [node, brother_sum] in cur_level:\\n                level_sum += node.val\\n\\n                left_val = node.left.val if node.left else 0\\n                right_val = node.right.val if node.right else 0\\n                brother_sum = left_val + right_val\\n                if node.left:\\n                    next_level.append([node.left, brother_sum])\\n                if node.right:\\n                    next_level.append([node.right, brother_sum])\\n\\n            # replace the value of current level nodes\\n            for [node, brother_sum] in cur_level:\\n                node.val = level_sum - brother_sum\\n            \\n            cur_level, next_level = next_level, []\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747073,
                "title": "level-order-traversal-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(N)*log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log(N))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<pair<TreeNode*,int>> curr,temp,empty;\\n        \\n        curr.push_back({root,0});\\n        int sum=0;\\n        int a,b;\\n        while(curr.size()){\\n            temp=empty;\\n            sum=0;\\n            for(int i=0;i<curr.size();i++){\\n                sum+=curr[i].first->val;\\n                if(curr[i].first->left){\\n                    if(curr[i].first->right)\\n                       temp.push_back({curr[i].first->left,curr[i].first->right->val}); \\n                    else \\n                       temp.push_back({curr[i].first->left,0}); \\n                }\\n                if(curr[i].first->right){\\n                    if(curr[i].first->left)\\n                       temp.push_back({curr[i].first->right,curr[i].first->left->val});\\n                    else\\n                       temp.push_back({curr[i].first->right,0}); \\n                }\\n            }\\n\\n            for(int i=0;i<curr.size();i++){\\n                a=curr[i].first->val;\\n                b=curr[i].second;\\n                curr[i].first->val=sum-a-b;\\n            }\\n\\n            curr=temp;\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<pair<TreeNode*,int>> curr,temp,empty;\\n        \\n        curr.push_back({root,0});\\n        int sum=0;\\n        int a,b;\\n        while(curr.size()){\\n            temp=empty;\\n            sum=0;\\n            for(int i=0;i<curr.size();i++){\\n                sum+=curr[i].first->val;\\n                if(curr[i].first->left){\\n                    if(curr[i].first->right)\\n                       temp.push_back({curr[i].first->left,curr[i].first->right->val}); \\n                    else \\n                       temp.push_back({curr[i].first->left,0}); \\n                }\\n                if(curr[i].first->right){\\n                    if(curr[i].first->left)\\n                       temp.push_back({curr[i].first->right,curr[i].first->left->val});\\n                    else\\n                       temp.push_back({curr[i].first->right,0}); \\n                }\\n            }\\n\\n            for(int i=0;i<curr.size();i++){\\n                a=curr[i].first->val;\\n                b=curr[i].second;\\n                curr[i].first->val=sum-a-b;\\n            }\\n\\n            curr=temp;\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742685,
                "title": "2dfs-refined",
                "content": "# Intuition\\ngot the approach from the solution 2DFS, but refined the code and tried to make it more reable\\n\\n# Approach\\ncreate sums of each level\\ncreate node and node value has hashmap\\nand in second DFS, just used the recursion call stack to get the parent left and right, to substract their values\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\nvar replaceValueInTree = function(root) {\\n    const levelSums = new Map();\\n    const nodeValues = new Map();\\n    const createLevelSums = (node, level) => {\\n        if(!node) return;\\n        nodeValues.set(node,node.val);\\n        if(!levelSums.has(level)) levelSums.set(level,0);\\n        levelSums.set(level,node.val + levelSums.get(level));\\n        createLevelSums(node.left,level+1);\\n        createLevelSums(node.right, level+1);\\n    }\\n\\n    const refineBinaryTree = (node,level,parent) => {\\n        if(!node) return;\\n        if(!parent) node.val = 0;\\n        else {\\n            let sum = levelSums.get(level);\\n            let left = parent.left;\\n            let right = parent.right;\\n            if(left) sum-=nodeValues.get(left);\\n            if(right) sum-=nodeValues.get(right);\\n            node.val = sum;\\n        }\\n        refineBinaryTree(node.left,level+1,node);\\n        refineBinaryTree(node.right,level+1,node);\\n    }\\n\\n    createLevelSums(root,0);\\n    refineBinaryTree(root,0,null);\\n    return root;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\nvar replaceValueInTree = function(root) {\\n    const levelSums = new Map();\\n    const nodeValues = new Map();\\n    const createLevelSums = (node, level) => {\\n        if(!node) return;\\n        nodeValues.set(node,node.val);\\n        if(!levelSums.has(level)) levelSums.set(level,0);\\n        levelSums.set(level,node.val + levelSums.get(level));\\n        createLevelSums(node.left,level+1);\\n        createLevelSums(node.right, level+1);\\n    }\\n\\n    const refineBinaryTree = (node,level,parent) => {\\n        if(!node) return;\\n        if(!parent) node.val = 0;\\n        else {\\n            let sum = levelSums.get(level);\\n            let left = parent.left;\\n            let right = parent.right;\\n            if(left) sum-=nodeValues.get(left);\\n            if(right) sum-=nodeValues.get(right);\\n            node.val = sum;\\n        }\\n        refineBinaryTree(node.left,level+1,node);\\n        refineBinaryTree(node.right,level+1,node);\\n    }\\n\\n    createLevelSums(root,0);\\n    refineBinaryTree(root,0,null);\\n    return root;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3724125,
                "title": "python-linear-time-in-place-modification-with-explanation",
                "content": "# Intuition\\nLet\\'s take a look at some level of this binary tree and their parents. \\n\\n```\\n   4      5      6      7          - parents of that level\\n  / \\\\    / \\\\    / \\\\    / \\\\\\n 8   9  10 11  12 13  14  15       - our level\\n```\\n\\nWe can have this information by traversing the tree level by level in BFS fashion. When we cover this level, we store two additional pieces of information:\\n - total sum in the level `(8 + 9 + 10 + ... + 15)`\\n - dictionary which maps parent to a sum of children `4 -> (8 + 9), ..., 6 -> (12 + 13)`\\n\\nThen using this information we can find the updated value of the node is `node.val = total_sum - parent_to_sum[parent]`\\n\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\n# Code\\n```\\nclass Solution:\\n  def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n    frontier = [(root, -1)]\\n\\n    while frontier:\\n      new_frontier, total_sum, parent_to_sum = [], 0, {}\\n      for (node, parent) in frontier:\\n        total_sum += node.val\\n        parent_to_sum[parent] = parent_to_sum.get(parent, 0) + node.val\\n\\n        if node.left:\\n          new_frontier.append((node.left, node))\\n        if node.right:\\n          new_frontier.append((node.right, node))\\n      \\n      for (node, parent) in frontier:\\n        node.val = total_sum - parent_to_sum[parent]\\n\\n      frontier = new_frontier\\n    \\n    return root\\n      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n   4      5      6      7          - parents of that level\\n  / \\\\    / \\\\    / \\\\    / \\\\\\n 8   9  10 11  12 13  14  15       - our level\\n```\n```\\nclass Solution:\\n  def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n    frontier = [(root, -1)]\\n\\n    while frontier:\\n      new_frontier, total_sum, parent_to_sum = [], 0, {}\\n      for (node, parent) in frontier:\\n        total_sum += node.val\\n        parent_to_sum[parent] = parent_to_sum.get(parent, 0) + node.val\\n\\n        if node.left:\\n          new_frontier.append((node.left, node))\\n        if node.right:\\n          new_frontier.append((node.right, node))\\n      \\n      for (node, parent) in frontier:\\n        node.val = total_sum - parent_to_sum[parent]\\n\\n      frontier = new_frontier\\n    \\n    return root\\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709342,
                "title": "go-level-order-traversal-then-dfs",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc calculateCousinsSum(node *TreeNode, depth int, m map[int]int) {\\n\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\tif depth > 1 {\\n\\t\\tm[depth] += node.Val\\n\\t}\\n\\n\\tcalculateCousinsSum(node.Left, depth+1, m)\\n\\tcalculateCousinsSum(node.Right, depth+1, m)\\n}\\n\\nfunc replaceValueInTreeUtil(node *TreeNode, depth int, m map[int]int) {\\n\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\tif depth == 0 {\\n\\t\\tnode.Val = 0\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tnode.Left.Val = 0\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tnode.Right.Val = 0\\n\\t\\t}\\n\\t} else {\\n\\n\\t\\tsiblingsSum := 0\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tsiblingsSum += node.Left.Val\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tsiblingsSum += node.Right.Val\\n\\t\\t}\\n\\n\\t\\tcousinsSum := m[depth+1] - siblingsSum\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tnode.Left.Val = cousinsSum\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tnode.Right.Val = cousinsSum\\n\\t\\t}\\n\\t}\\n\\n\\tdepth++\\n\\n\\treplaceValueInTreeUtil(node.Left, depth, m)\\n\\treplaceValueInTreeUtil(node.Right, depth, m)\\n}\\n\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n\\tm := make(map[int]int)\\n\\n\\tcalculateCousinsSum(root, 0, m)\\n\\treplaceValueInTreeUtil(root, 0, m)\\n\\n\\treturn root\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc calculateCousinsSum(node *TreeNode, depth int, m map[int]int) {\\n\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\tif depth > 1 {\\n\\t\\tm[depth] += node.Val\\n\\t}\\n\\n\\tcalculateCousinsSum(node.Left, depth+1, m)\\n\\tcalculateCousinsSum(node.Right, depth+1, m)\\n}\\n\\nfunc replaceValueInTreeUtil(node *TreeNode, depth int, m map[int]int) {\\n\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\tif depth == 0 {\\n\\t\\tnode.Val = 0\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tnode.Left.Val = 0\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tnode.Right.Val = 0\\n\\t\\t}\\n\\t} else {\\n\\n\\t\\tsiblingsSum := 0\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tsiblingsSum += node.Left.Val\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tsiblingsSum += node.Right.Val\\n\\t\\t}\\n\\n\\t\\tcousinsSum := m[depth+1] - siblingsSum\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tnode.Left.Val = cousinsSum\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tnode.Right.Val = cousinsSum\\n\\t\\t}\\n\\t}\\n\\n\\tdepth++\\n\\n\\treplaceValueInTreeUtil(node.Left, depth, m)\\n\\treplaceValueInTreeUtil(node.Right, depth, m)\\n}\\n\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n\\tm := make(map[int]int)\\n\\n\\tcalculateCousinsSum(root, 0, m)\\n\\treplaceValueInTreeUtil(root, 0, m)\\n\\n\\treturn root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683893,
                "title": "simple-bfs-solution-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTraverse the tree by bfs approach and replace each roots value with the sum of its sibling value .Also maintain a currS variable which calculates the sum of all the nodes at a particular level .Finally just substract the replaced value with the currS for each node.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int preS = root->val;\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            int currS = 0;\\n            while(s-- >0)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                temp->val = preS - temp->val;\\n                int sibS = temp->left ? temp->left->val:0;\\n                sibS += temp->right ? temp->right->val:0;\\n                if(temp->left!=NULL)\\n                {\\n                currS = currS + temp->left->val;\\n                temp->left->val=sibS;\\n                q.push(temp->left);\\n                }\\n                if(temp->right!=NULL)\\n                {\\n                currS = currS + temp->right->val;\\n                temp->right->val=sibS;\\n                q.push(temp->right);\\n                }\\n            }\\n            preS = currS;\\n            \\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int preS = root->val;\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            int currS = 0;\\n            while(s-- >0)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                temp->val = preS - temp->val;\\n                int sibS = temp->left ? temp->left->val:0;\\n                sibS += temp->right ? temp->right->val:0;\\n                if(temp->left!=NULL)\\n                {\\n                currS = currS + temp->left->val;\\n                temp->left->val=sibS;\\n                q.push(temp->left);\\n                }\\n                if(temp->right!=NULL)\\n                {\\n                currS = currS + temp->right->val;\\n                temp->right->val=sibS;\\n                q.push(temp->right);\\n                }\\n            }\\n            preS = currS;\\n            \\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678189,
                "title": "c-level-order-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void UpdateTree(TreeNode* root, int level, vector<long long>& levelSum)\\n    {\\n        if(root==NULL)    return;\\n        int sum = 0;\\n        if(root->left)    sum += root->left->val;\\n        if(root->right)   sum += root->right->val;\\n        if(root->left)    root->left->val = levelSum[level+1] - sum;\\n        if(root->right)   root->right->val = levelSum[level+1] - sum;\\n\\n        UpdateTree(root->left, level+1, levelSum);\\n        UpdateTree(root->right, level+1, levelSum);  \\n    }\\n\\n    vector<long long> CalculateLevelSum(TreeNode* root)\\n    {\\n        vector<long long> levelSum;\\n        queue<TreeNode *> q; \\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            int sum = 0;\\n            for(int i=0; i<n; i++)\\n            {\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                sum += curr->val;\\n                if(curr->left)    q.push(curr->left);\\n                if(curr->right)   q.push(curr->right);\\n            }\\n\\n            levelSum.push_back(sum);\\n        }\\n\\n        return levelSum;\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<long long> levelSum = CalculateLevelSum(root);\\n        int level = 0;\\n        UpdateTree(root, level, levelSum);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void UpdateTree(TreeNode* root, int level, vector<long long>& levelSum)\\n    {\\n        if(root==NULL)    return;\\n        int sum = 0;\\n        if(root->left)    sum += root->left->val;\\n        if(root->right)   sum += root->right->val;\\n        if(root->left)    root->left->val = levelSum[level+1] - sum;\\n        if(root->right)   root->right->val = levelSum[level+1] - sum;\\n\\n        UpdateTree(root->left, level+1, levelSum);\\n        UpdateTree(root->right, level+1, levelSum);  \\n    }\\n\\n    vector<long long> CalculateLevelSum(TreeNode* root)\\n    {\\n        vector<long long> levelSum;\\n        queue<TreeNode *> q; \\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            int sum = 0;\\n            for(int i=0; i<n; i++)\\n            {\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                sum += curr->val;\\n                if(curr->left)    q.push(curr->left);\\n                if(curr->right)   q.push(curr->right);\\n            }\\n\\n            levelSum.push_back(sum);\\n        }\\n\\n        return levelSum;\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<long long> levelSum = CalculateLevelSum(root);\\n        int level = 0;\\n        UpdateTree(root, level, levelSum);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675313,
                "title": "shortest-code-using-level-order-traversal",
                "content": "# Intuition\\nlevel order traversal \\n\\n# Approach\\nnode\\'s value = sum of all the nodes in that level - (sum of node\\' value and its siblings value i.e. they both are the left and right child of the same node\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^l) ; l = max depth of binary tree.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {     \\n\\n        queue<pair<TreeNode*,int>>q;\\n      \\n        q.push({root,0});\\n        int prev=0;\\n        while(!q.empty()){\\n            \\n            int n = q.size();\\n            \\n            int Tsum=0;\\n            for(int i=0; i<n; i++){\\n                int sum=0;\\n                auto [node,rootSum] = q.front();\\n                q.pop();\\n                \\n                if(!node) continue;\\n                \\n                node->val= prev - rootSum; // total sum of level - sibling sum.\\n                \\n                if(node->left)\\n                    sum+= node->left->val;\\n                \\n                if(node->right)\\n                    sum+= node->right->val;\\n                Tsum+= sum;\\n                \\n                q.push({node->left,sum}); // sibling sum\\n                q.push({node->right, sum});\\n            }\\n            prev = Tsum; // storing the total sum of a level so that we can use in the next iteration.\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {     \\n\\n        queue<pair<TreeNode*,int>>q;\\n      \\n        q.push({root,0});\\n        int prev=0;\\n        while(!q.empty()){\\n            \\n            int n = q.size();\\n            \\n            int Tsum=0;\\n            for(int i=0; i<n; i++){\\n                int sum=0;\\n                auto [node,rootSum] = q.front();\\n                q.pop();\\n                \\n                if(!node) continue;\\n                \\n                node->val= prev - rootSum; // total sum of level - sibling sum.\\n                \\n                if(node->left)\\n                    sum+= node->left->val;\\n                \\n                if(node->right)\\n                    sum+= node->right->val;\\n                Tsum+= sum;\\n                \\n                q.push({node->left,sum}); // sibling sum\\n                q.push({node->right, sum});\\n            }\\n            prev = Tsum; // storing the total sum of a level so that we can use in the next iteration.\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671958,
                "title": "simple-bfs",
                "content": "# Intuition\\nBreadth first search\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if root == None:\\n            return root\\n        root.val = 0\\n        parents = collections.deque()\\n        parents.append(root)\\n        while parents:\\n            children = []\\n            total = 0\\n            for parent in parents:\\n                if parent.left:\\n                    children.append(parent.left)\\n                    total += parent.left.val\\n                if parent.right:\\n                    children.append(parent.right)\\n                    total += parent.right.val\\n            while parents:\\n                parent = parents.popleft()\\n                subtotal = 0\\n                if parent.left:\\n                    subtotal += parent.left.val\\n                if parent.right:\\n                    subtotal += parent.right.val\\n                    parent.right.val = total - subtotal\\n                if parent.left:\\n                    parent.left.val = total - subtotal\\n            parents.extend(children)\\n        return root\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if root == None:\\n            return root\\n        root.val = 0\\n        parents = collections.deque()\\n        parents.append(root)\\n        while parents:\\n            children = []\\n            total = 0\\n            for parent in parents:\\n                if parent.left:\\n                    children.append(parent.left)\\n                    total += parent.left.val\\n                if parent.right:\\n                    children.append(parent.right)\\n                    total += parent.right.val\\n            while parents:\\n                parent = parents.popleft()\\n                subtotal = 0\\n                if parent.left:\\n                    subtotal += parent.left.val\\n                if parent.right:\\n                    subtotal += parent.right.val\\n                    parent.right.val = total - subtotal\\n                if parent.left:\\n                    parent.left.val = total - subtotal\\n            parents.extend(children)\\n        return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668081,
                "title": "bfs-w-level-sums",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst replaceValueInTree = (root) => {\\n  let queue = [[root, root.val]];\\n  let currentSum = root.val;\\n  while (queue.length) {\\n    let nextSum = 0;\\n    const nextLevel = [];\\n    for (let [node, sum] of queue) {\\n      const leftVal = node.left ? node.left.val : 0;\\n      const rightVal = node.right ? node.right.val : 0;\\n      node.val = currentSum - sum;\\n      if (node.left) {\\n        nextSum += node.left.val;\\n        nextLevel.push([node.left, leftVal + rightVal]);\\n      }\\n      if (node.right) {\\n        nextSum += node.right.val;\\n        nextLevel.push([node.right, leftVal + rightVal]);\\n      }\\n    }\\n    currentSum = nextSum;\\n    queue = nextLevel;\\n  }\\n  return root;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst replaceValueInTree = (root) => {\\n  let queue = [[root, root.val]];\\n  let currentSum = root.val;\\n  while (queue.length) {\\n    let nextSum = 0;\\n    const nextLevel = [];\\n    for (let [node, sum] of queue) {\\n      const leftVal = node.left ? node.left.val : 0;\\n      const rightVal = node.right ? node.right.val : 0;\\n      node.val = currentSum - sum;\\n      if (node.left) {\\n        nextSum += node.left.val;\\n        nextLevel.push([node.left, leftVal + rightVal]);\\n      }\\n      if (node.right) {\\n        nextSum += node.right.val;\\n        nextLevel.push([node.right, leftVal + rightVal]);\\n      }\\n    }\\n    currentSum = nextSum;\\n    queue = nextLevel;\\n  }\\n  return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3667230,
                "title": "simple-level-sum-double-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOverwriting values as you do a single traversal can be difficult to wrap your head around, and is prone to coding errors. Once you understand that the final value of a node is\\n\\n```\\nnode_val = sum_of_level - original_self_val - sibling_val\\n```\\n\\nthings get much simpler.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI separated out level sum code and overwrite into separate methods for clarity. A single method with a long parameter list, and lots of ifs may have been feasible, but would be messy.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) - traverses all nodes twice\\n\\n- Space complexity:\\nO(Log(n)) additional space for level sums\\n**Additional stack space for recursion\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    level_sum = None\\n\\n    def lvl_sum_helper(self, node: Optional[TreeNode], level: int):\\n        if node is None:\\n            return\\n\\n        Solution.level_sum[level] += node.val\\n\\n        self.lvl_sum_helper(node.left, level+1)\\n        self.lvl_sum_helper(node.right, level+1)\\n\\n    def write_trav_helper(self, node: Optional[TreeNode], level: int, sub: int) -> None:\\n        if node is None:\\n            return\\n\\n        node.val = Solution.level_sum[level] - sub\\n\\n        left_val = node.left.val if node.left else 0\\n        right_val = node.right.val if node.right else 0\\n\\n        self.write_trav_helper(node.left, level+1, left_val+right_val)\\n        self.write_trav_helper(node.right, level+1, left_val+right_val)\\n\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        Solution.level_sum = [0]*(10**5)\\n        \\n        # First pass, we iterate through and find original level sums\\n        self.lvl_sum_helper(root, 0)\\n\\n        # Second pass we overwrite, value should be level_sum-self-sibs\\n        self.write_trav_helper(root, 0, root.val)\\n\\n        return root\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nnode_val = sum_of_level - original_self_val - sibling_val\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    level_sum = None\\n\\n    def lvl_sum_helper(self, node: Optional[TreeNode], level: int):\\n        if node is None:\\n            return\\n\\n        Solution.level_sum[level] += node.val\\n\\n        self.lvl_sum_helper(node.left, level+1)\\n        self.lvl_sum_helper(node.right, level+1)\\n\\n    def write_trav_helper(self, node: Optional[TreeNode], level: int, sub: int) -> None:\\n        if node is None:\\n            return\\n\\n        node.val = Solution.level_sum[level] - sub\\n\\n        left_val = node.left.val if node.left else 0\\n        right_val = node.right.val if node.right else 0\\n\\n        self.write_trav_helper(node.left, level+1, left_val+right_val)\\n        self.write_trav_helper(node.right, level+1, left_val+right_val)\\n\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        Solution.level_sum = [0]*(10**5)\\n        \\n        # First pass, we iterate through and find original level sums\\n        self.lvl_sum_helper(root, 0)\\n\\n        # Second pass we overwrite, value should be level_sum-self-sibs\\n        self.write_trav_helper(root, 0, root.val)\\n\\n        return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666968,
                "title": "beats-100-java-clean-solution-2-dfs-with-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root.left == null && root.right == null)\\n            return new TreeNode(0);\\n        TreeNode nroot = null;\\n        dfs1(root, 0);\\n        dfs2(root, 0, root.val);\\n        return root;\\n    }\\n    private void dfs1(TreeNode root, int depth){\\n        if(root == null)\\n            return;\\n        map.put(depth, map.getOrDefault(depth, 0) + root.val);\\n        dfs1(root.left, depth+1);\\n        dfs1(root.right, depth+1);    \\n    }\\n    private void dfs2(TreeNode root, int depth, int sibling){\\n        if(root == null)\\n            return;\\n        \\n        root.val = map.get(depth) - sibling;\\n        sibling = (root.left == null ? 0 : root.left.val) + (root.right == null ? 0 : root.right.val);\\n        dfs2(root.left, depth+1, sibling);\\n        dfs2(root.right, depth+1, sibling);                    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root.left == null && root.right == null)\\n            return new TreeNode(0);\\n        TreeNode nroot = null;\\n        dfs1(root, 0);\\n        dfs2(root, 0, root.val);\\n        return root;\\n    }\\n    private void dfs1(TreeNode root, int depth){\\n        if(root == null)\\n            return;\\n        map.put(depth, map.getOrDefault(depth, 0) + root.val);\\n        dfs1(root.left, depth+1);\\n        dfs1(root.right, depth+1);    \\n    }\\n    private void dfs2(TreeNode root, int depth, int sibling){\\n        if(root == null)\\n            return;\\n        \\n        root.val = map.get(depth) - sibling;\\n        sibling = (root.left == null ? 0 : root.left.val) + (root.right == null ? 0 : root.right.val);\\n        dfs2(root.left, depth+1, sibling);\\n        dfs2(root.right, depth+1, sibling);                    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664398,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>pq;\\n\\n        if(!root){\\n            return root;\\n        }\\n        pq.push(root);\\n\\n        while(pq.size()){\\n            int size = pq.size();\\n            int sum = 0;\\n            vector<pair<TreeNode*,int>>M;\\n            while(size--){\\n                TreeNode* temp = pq.front();\\n                pq.pop();\\n                int curr_sum = 0;\\n                if(temp -> left){\\n                    sum += temp -> left->val;\\n                    curr_sum += temp -> left->val; \\n                    pq.push(temp->left);\\n                }\\n                if(temp -> right){\\n                    sum += temp -> right->val;\\n                    curr_sum += temp -> right->val; \\n                    pq.push(temp->right);\\n                }\\n                M.push_back({temp,curr_sum});\\n            }\\n            for(int i=0;i<M.size();i++){\\n                TreeNode* curr = M[i].first;\\n                int total = M[i].second;\\n                if(curr -> left){\\n                    curr->left->val = sum-total;\\n                }\\n                if(curr -> right){\\n                    curr->right->val = sum-total;\\n                }\\n            }\\n        }\\n        root->val =  0;\\n        return root;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>pq;\\n\\n        if(!root){\\n            return root;\\n        }\\n        pq.push(root);\\n\\n        while(pq.size()){\\n            int size = pq.size();\\n            int sum = 0;\\n            vector<pair<TreeNode*,int>>M;\\n            while(size--){\\n                TreeNode* temp = pq.front();\\n                pq.pop();\\n                int curr_sum = 0;\\n                if(temp -> left){\\n                    sum += temp -> left->val;\\n                    curr_sum += temp -> left->val; \\n                    pq.push(temp->left);\\n                }\\n                if(temp -> right){\\n                    sum += temp -> right->val;\\n                    curr_sum += temp -> right->val; \\n                    pq.push(temp->right);\\n                }\\n                M.push_back({temp,curr_sum});\\n            }\\n            for(int i=0;i<M.size();i++){\\n                TreeNode* curr = M[i].first;\\n                int total = M[i].second;\\n                if(curr -> left){\\n                    curr->left->val = sum-total;\\n                }\\n                if(curr -> right){\\n                    curr->right->val = sum-total;\\n                }\\n            }\\n        }\\n        root->val =  0;\\n        return root;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651926,
                "title": "java-horizontal-level-sum",
                "content": "# Intuition\\nUse horizontal level sum\\n\\n# Approach\\nFind horizontal level sum, once you are ready with this then for each parent you need to get their children sum and update children with with new value which is horizontalLevelSum[depth+1]-childrenSum;\\nHere I used horizontalLevelSum[depth+1] instead of horizontalLevelSum[depth] because it\\'s easy to get both child from parent and since you\\'re at the parent level so to get children\\'s level sum the you have to increase depth by 1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> horizontalSum;\\n    public void traverse(TreeNode root, int depth) {\\n        if(root == null) {\\n            return;\\n        }\\n        if(depth<horizontalSum.size()) {\\n            horizontalSum.set(depth, horizontalSum.get(depth)+root.val);\\n        } else {\\n            horizontalSum.add(root.val);\\n        }\\n        traverse(root.left, depth+1);\\n        traverse(root.right, depth+1);\\n    }\\n    public void traverse1(TreeNode root, int depth) {\\n        if(root == null) {\\n            return;\\n        }\\n        if(depth>0) {\\n            int sum=0;\\n            if(root.left!=null) {\\n                sum+=root.left.val;\\n            }\\n            if(root.right!=null) {\\n                sum+=root.right.val;\\n            }\\n            if(root.left!=null) {\\n                root.left.val=horizontalSum.get(depth+1)-sum;\\n            }\\n            if(root.right!=null) {\\n                root.right.val=horizontalSum.get(depth+1)-sum;\\n            }\\n        }\\n        traverse1(root.left, depth+1);\\n        traverse1(root.right, depth+1);\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        horizontalSum = new ArrayList();\\n        root.val = 0;\\n        if(root.left!=null) {\\n            root.left.val = 0;\\n        }\\n        if(root.right!=null) {\\n            root.right.val = 0;\\n        }\\n        traverse(root, 0);\\n        traverse1(root,0);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> horizontalSum;\\n    public void traverse(TreeNode root, int depth) {\\n        if(root == null) {\\n            return;\\n        }\\n        if(depth<horizontalSum.size()) {\\n            horizontalSum.set(depth, horizontalSum.get(depth)+root.val);\\n        } else {\\n            horizontalSum.add(root.val);\\n        }\\n        traverse(root.left, depth+1);\\n        traverse(root.right, depth+1);\\n    }\\n    public void traverse1(TreeNode root, int depth) {\\n        if(root == null) {\\n            return;\\n        }\\n        if(depth>0) {\\n            int sum=0;\\n            if(root.left!=null) {\\n                sum+=root.left.val;\\n            }\\n            if(root.right!=null) {\\n                sum+=root.right.val;\\n            }\\n            if(root.left!=null) {\\n                root.left.val=horizontalSum.get(depth+1)-sum;\\n            }\\n            if(root.right!=null) {\\n                root.right.val=horizontalSum.get(depth+1)-sum;\\n            }\\n        }\\n        traverse1(root.left, depth+1);\\n        traverse1(root.right, depth+1);\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        horizontalSum = new ArrayList();\\n        root.val = 0;\\n        if(root.left!=null) {\\n            root.left.val = 0;\\n        }\\n        if(root.right!=null) {\\n            root.right.val = 0;\\n        }\\n        traverse(root, 0);\\n        traverse1(root,0);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646700,
                "title": "python3-w-detailed-explanation",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        from collections import deque\\n        \\n        q = deque([root])\\n        l_sum = []\\n        \\n\\t\\t# Use BFS to collect the sum of each level\\n        while q:\\n            _sum = 0\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                _sum += node.val\\n                \\n                if node.left:\\n                    q.append(node.left)\\n                    \\n                if node.right:\\n                    q.append(node.right)\\n                    \\n            l_sum.append(_sum)\\n            \\n        def helper(node, sib_sum, level):\\n            if not node:\\n                return\\n            \\n\\t\\t\\t# `sib_sum` here consists of the values of every nodes under one parent\\n\\t\\t\\t# i.e. value of the node itself and its sibling nodes.\\n            node.val = l_sum[level] - sib_sum\\n            \\n            sib_sum = 0\\n            \\n            if node.left:\\n                sib_sum += node.left.val\\n                \\n            if node.right:\\n                sib_sum += node.right.val\\n            \\n            helper(node.left, sib_sum, level+1)\\n            helper(node.right, sib_sum, level+1)\\n            \\n\\t\\t# Use DFS to go through every node to update its value\\n\\t\\t# The key point is that - \\n\\t\\t# Sum of one level consists of \\n\\t\\t# 1. value of the node itself\\n\\t\\t# 2. values of the node\\'s sibilings (same parent) \\n\\t\\t# 3. and values of the node\\'s cousins (different parent)\\n        helper(root, root.val, 0)\\n        \\n        return root\\n```\\t\\t\\n\\nTime complexity: O(2n) = O(n) - we traverse the tree twice to count the sum of each level and update the values\\nSpace complexity: O(n) - we used queue to store nodes and list to store sum of each level",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        from collections import deque\\n        \\n        q = deque([root])\\n        l_sum = []\\n        \\n\\t\\t# Use BFS to collect the sum of each level\\n        while q:\\n            _sum = 0\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                _sum += node.val\\n                \\n                if node.left:\\n                    q.append(node.left)\\n                    \\n                if node.right:\\n                    q.append(node.right)\\n                    \\n            l_sum.append(_sum)\\n            \\n        def helper(node, sib_sum, level):\\n            if not node:\\n                return\\n            \\n\\t\\t\\t# `sib_sum` here consists of the values of every nodes under one parent\\n\\t\\t\\t# i.e. value of the node itself and its sibling nodes.\\n            node.val = l_sum[level] - sib_sum\\n            \\n            sib_sum = 0\\n            \\n            if node.left:\\n                sib_sum += node.left.val\\n                \\n            if node.right:\\n                sib_sum += node.right.val\\n            \\n            helper(node.left, sib_sum, level+1)\\n            helper(node.right, sib_sum, level+1)\\n            \\n\\t\\t# Use DFS to go through every node to update its value\\n\\t\\t# The key point is that - \\n\\t\\t# Sum of one level consists of \\n\\t\\t# 1. value of the node itself\\n\\t\\t# 2. values of the node\\'s sibilings (same parent) \\n\\t\\t# 3. and values of the node\\'s cousins (different parent)\\n        helper(root, root.val, 0)\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644460,
                "title": "if-you-still-didn-t-get-it-see-this",
                "content": "# Intuition\\nIf you get the sum of all values of nodes in a level and for any node you subtract the value of itself and its siblings from the total sum of nodes of it level, you get the sum of its cousins. You update the node value with that answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all you need to get the sum of values of all nodes in a level and for that purpose we use a map to store the sum level wise by calling the sum fn(dfs).\\n\\nAfter the first function call(dfs), we run another dfs call(solve fn), where we update the node values with the sum of their cousin nodes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe Sum function will run max O(n) times, as it will visit each node.\\nThe solve function shall run for another O(n) times as we traverse each node once.\\n\\nOverall T.C. = O(n)\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe hashmap shall store max n nodes if the tree is skewed i.e. n different levels so,\\n\\nS.C. = O(n)\\n(Ignoring the stack space used due to the function calls)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n\\n        sum(root, 0, mp);\\n        solve(root, 0,mp);\\n        return root;\\n        \\n    }\\n\\n\\n    void solve(TreeNode* root, int level, unordered_map<int,int>& mp){\\n        if(!root) return;\\n\\n        level += 1;\\n\\n        if(level == 1){\\n            root->val = 0;\\n        }\\n        int right_val = 0,left_val= 0 ;\\n\\n        if(root->left){\\n            left_val = root->left->val;\\n            if(root->right){\\n                right_val = root->right->val;\\n            }\\n            root->left->val = mp[level+1] - (root->left->val + right_val);\\n        }\\n\\n        if(root->right){\\n           \\n           \\n            \\n            root->right->val = mp[level+1] - (root->right->val + left_val);\\n        }\\n\\n        solve(root->left,level,mp);\\n        solve(root->right,level,mp);\\n\\n        return;\\n\\n\\n    }\\n\\n    void sum(TreeNode* root, int level,  unordered_map<int,int>& mp){\\n        if(!root) return;\\n\\n        level += 1;\\n\\n        sum(root -> left, level, mp);\\n        sum(root->right,level,mp);\\n\\n        if(mp.find(level) != mp.end()){\\n            mp[level] += root->val;\\n        }else{\\n            mp[level]=root->val;\\n        }\\n\\n        return;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n\\n        sum(root, 0, mp);\\n        solve(root, 0,mp);\\n        return root;\\n        \\n    }\\n\\n\\n    void solve(TreeNode* root, int level, unordered_map<int,int>& mp){\\n        if(!root) return;\\n\\n        level += 1;\\n\\n        if(level == 1){\\n            root->val = 0;\\n        }\\n        int right_val = 0,left_val= 0 ;\\n\\n        if(root->left){\\n            left_val = root->left->val;\\n            if(root->right){\\n                right_val = root->right->val;\\n            }\\n            root->left->val = mp[level+1] - (root->left->val + right_val);\\n        }\\n\\n        if(root->right){\\n           \\n           \\n            \\n            root->right->val = mp[level+1] - (root->right->val + left_val);\\n        }\\n\\n        solve(root->left,level,mp);\\n        solve(root->right,level,mp);\\n\\n        return;\\n\\n\\n    }\\n\\n    void sum(TreeNode* root, int level,  unordered_map<int,int>& mp){\\n        if(!root) return;\\n\\n        level += 1;\\n\\n        sum(root -> left, level, mp);\\n        sum(root->right,level,mp);\\n\\n        if(mp.find(level) != mp.end()){\\n            mp[level] += root->val;\\n        }else{\\n            mp[level]=root->val;\\n        }\\n\\n        return;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642738,
                "title": "2-bfs",
                "content": "\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root->left && !root->right){\\n            root->val=0;\\n            return root;\\n        }\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int lvll=1;\\n        \\n        vector<long long>lvlsum;\\n        queue<TreeNode*>lvl;\\n        lvl.push(root);\\n        while(lvl.size()){\\n            int size=lvl.size();\\n            long long sum=0;\\n            while(size--){\\n                TreeNode*f=lvl.front();\\n                lvl.pop();\\n                sum+=f->val;\\n                if(f->left)lvl.push(f->left);\\n                if(f->right)lvl.push(f->right);\\n            }\\n            lvlsum.push_back(sum);\\n        }\\n        while(q.size()){\\n            int size=q.size();\\n            while(size--){\\n                TreeNode*f=q.front();\\n                q.pop();\\n                long long x=0;\\n                if(!f->left && !f->right)continue;\\n                if(f->left){\\n                    x+=f->left->val;\\n                    q.push(f->left);\\n                }\\n                if(f->right){\\n                    x+=f->right->val;\\n                    q.push(f->right);\\n                }\\n                // cout<<x<<endl;\\n                if(f->left)f->left->val=lvlsum[lvll]-x;\\n                if(f->right)f->right->val=lvlsum[lvll]-x;\\n            }\\n            lvll++;\\n        }\\n        root->val=0;\\n        return root;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root->left && !root->right){\\n            root->val=0;\\n            return root;\\n        }\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int lvll=1;\\n        \\n        vector<long long>lvlsum;\\n        queue<TreeNode*>lvl;\\n        lvl.push(root);\\n        while(lvl.size()){\\n            int size=lvl.size();\\n            long long sum=0;\\n            while(size--){\\n                TreeNode*f=lvl.front();\\n                lvl.pop();\\n                sum+=f->val;\\n                if(f->left)lvl.push(f->left);\\n                if(f->right)lvl.push(f->right);\\n            }\\n            lvlsum.push_back(sum);\\n        }\\n        while(q.size()){\\n            int size=q.size();\\n            while(size--){\\n                TreeNode*f=q.front();\\n                q.pop();\\n                long long x=0;\\n                if(!f->left && !f->right)continue;\\n                if(f->left){\\n                    x+=f->left->val;\\n                    q.push(f->left);\\n                }\\n                if(f->right){\\n                    x+=f->right->val;\\n                    q.push(f->right);\\n                }\\n                // cout<<x<<endl;\\n                if(f->left)f->left->val=lvlsum[lvll]-x;\\n                if(f->right)f->right->val=lvlsum[lvll]-x;\\n            }\\n            lvll++;\\n        }\\n        root->val=0;\\n        return root;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 3642198,
                "title": "bfs-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<vector<int>>arr;\\n        vector<int>tarr;\\n        vector<int>sumarr;\\n        int nnode=10001;\\n        int childSum=0,totsum=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        q.push(new TreeNode(nnode));\\n        q.push(NULL);\\n        arr.push_back({root->val});\\n        sumarr.push_back(root->val);\\n        while(!q.empty()){\\n            TreeNode* n=q.front();\\n            q.pop();\\n            if(n!=NULL && n->val!=nnode){\\n                childSum=0;\\n                if(n->left){\\n                    q.push(n->left);\\n                    childSum+=n->left->val;\\n                }\\n                if(n->right){\\n                    q.push(n->right);\\n                    childSum+=n->right->val;\\n                }\\n                totsum+= childSum;\\n                tarr.push_back(childSum); \\n                q.push(new TreeNode(nnode));       \\n            }\\n            else if(n!=NULL && n->val==nnode){\\n                childSum=0;\\n            }\\n            else if(!q.empty()){\\n                arr.push_back(tarr);\\n                sumarr.push_back(totsum);\\n                tarr.clear();\\n                totsum=0;\\n                childSum=0;\\n                q.push(NULL);\\n            }\\n        }\\n\\n        root->val=0;\\n        q.push(root);\\n        q.push(NULL);\\n        int lvl=1,indx=0;\\n        while(!q.empty()){\\n            TreeNode* n=q.front();\\n            q.pop();\\n            if(n!=NULL){\\n                //cout<<lvl<<\" \"<<sumarr[lvl]<<\" \"<<arr[lvl][indx]<<\"\\\\n\";\\n                if(n->left){\\n                    n->left->val=sumarr[lvl]-arr[lvl][indx];\\n                    q.push(n->left);\\n                }\\n                if(n->right)\\n                 {\\n                     n->right->val=sumarr[lvl]-arr[lvl][indx];\\n                     q.push(n->right);\\n                 }\\n                indx++;\\n            }\\n            else if(!q.empty()){\\n                q.push(NULL);\\n                indx=0;\\n                lvl++;\\n            }          \\n        }\\n        return root;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<vector<int>>arr;\\n        vector<int>tarr;\\n        vector<int>sumarr;\\n        int nnode=10001;\\n        int childSum=0,totsum=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        q.push(new TreeNode(nnode));\\n        q.push(NULL);\\n        arr.push_back({root->val});\\n        sumarr.push_back(root->val);\\n        while(!q.empty()){\\n            TreeNode* n=q.front();\\n            q.pop();\\n            if(n!=NULL && n->val!=nnode){\\n                childSum=0;\\n                if(n->left){\\n                    q.push(n->left);\\n                    childSum+=n->left->val;\\n                }\\n                if(n->right){\\n                    q.push(n->right);\\n                    childSum+=n->right->val;\\n                }\\n                totsum+= childSum;\\n                tarr.push_back(childSum); \\n                q.push(new TreeNode(nnode));       \\n            }\\n            else if(n!=NULL && n->val==nnode){\\n                childSum=0;\\n            }\\n            else if(!q.empty()){\\n                arr.push_back(tarr);\\n                sumarr.push_back(totsum);\\n                tarr.clear();\\n                totsum=0;\\n                childSum=0;\\n                q.push(NULL);\\n            }\\n        }\\n\\n        root->val=0;\\n        q.push(root);\\n        q.push(NULL);\\n        int lvl=1,indx=0;\\n        while(!q.empty()){\\n            TreeNode* n=q.front();\\n            q.pop();\\n            if(n!=NULL){\\n                //cout<<lvl<<\" \"<<sumarr[lvl]<<\" \"<<arr[lvl][indx]<<\"\\\\n\";\\n                if(n->left){\\n                    n->left->val=sumarr[lvl]-arr[lvl][indx];\\n                    q.push(n->left);\\n                }\\n                if(n->right)\\n                 {\\n                     n->right->val=sumarr[lvl]-arr[lvl][indx];\\n                     q.push(n->right);\\n                 }\\n                indx++;\\n            }\\n            else if(!q.empty()){\\n                q.push(NULL);\\n                indx=0;\\n                lvl++;\\n            }          \\n        }\\n        return root;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3642036,
                "title": "python-faster-than-98-bfs-precalculate-level-sum",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        if root.left:\\n            root.left.val = 0\\n        if root.right:\\n            root.right.val = 0\\n        cur_level = [(root.left, root.right)]\\n        while cur_level:\\n            next_level = []\\n            s = 0\\n            for node_info in cur_level:\\n                l, r = node_info\\n                if l:\\n                    s += l.val\\n                    next_level.append((l.left, l.right))\\n                if r:\\n                    s += r.val\\n                    next_level.append((r.left, r.right))\\n            \\n            for node_info in cur_level:\\n                l, r = node_info\\n                val = s - (l.val if l else 0) - (r.val if r else 0)\\n                if l:\\n                    l.val = val\\n                if r:\\n                    r.val = val\\n\\n            cur_level = next_level\\n\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        if root.left:\\n            root.left.val = 0\\n        if root.right:\\n            root.right.val = 0\\n        cur_level = [(root.left, root.right)]\\n        while cur_level:\\n            next_level = []\\n            s = 0\\n            for node_info in cur_level:\\n                l, r = node_info\\n                if l:\\n                    s += l.val\\n                    next_level.append((l.left, l.right))\\n                if r:\\n                    s += r.val\\n                    next_level.append((r.left, r.right))\\n            \\n            for node_info in cur_level:\\n                l, r = node_info\\n                val = s - (l.val if l else 0) - (r.val if r else 0)\\n                if l:\\n                    l.val = val\\n                if r:\\n                    r.val = val\\n\\n            cur_level = next_level\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641975,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n  public:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n      queue<TreeNode*> q;\\n      q.push(root);\\n      TreeNode* guard = root;\\n      vector<int> diff, level;\\n      diff.push_back(root->val);\\n      level.push_back(root->val);\\n      int i = 0, sum = 0, l = 0;\\n      while (!q.empty()) {\\n        TreeNode* c = q.front();\\n        q.pop();\\n        c->val = level[l] - diff[i++];\\n        int v = 0;\\n        if (c->left) {\\n          v += c->left->val;\\n          q.push(c->left);\\n        }\\n        if (c->right) {\\n          v += c->right->val;\\n          q.push(c->right);\\n        }\\n        if (c->left)\\n          diff.push_back(v);\\n        if (c->right)\\n          diff.push_back(v);\\n        sum += v;\\n        if (c == guard) {\\n          guard = !q.empty() ? q.back() : nullptr;\\n          level.push_back(sum);\\n          sum = 0;\\n          l++;\\n        }\\n      }\\n      return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n  public:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n      queue<TreeNode*> q;\\n      q.push(root);\\n      TreeNode* guard = root;\\n      vector<int> diff, level;\\n      diff.push_back(root->val);\\n      level.push_back(root->val);\\n      int i = 0, sum = 0, l = 0;\\n      while (!q.empty()) {\\n        TreeNode* c = q.front();\\n        q.pop();\\n        c->val = level[l] - diff[i++];\\n        int v = 0;\\n        if (c->left) {\\n          v += c->left->val;\\n          q.push(c->left);\\n        }\\n        if (c->right) {\\n          v += c->right->val;\\n          q.push(c->right);\\n        }\\n        if (c->left)\\n          diff.push_back(v);\\n        if (c->right)\\n          diff.push_back(v);\\n        sum += v;\\n        if (c == guard) {\\n          guard = !q.empty() ? q.back() : nullptr;\\n          level.push_back(sum);\\n          sum = 0;\\n          l++;\\n        }\\n      }\\n      return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641728,
                "title": "c-solution-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution \\n{\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n        int i,n,sum,prevsum;\\n\\n        vector<int> v,prev;\\n        queue<TreeNode *> q;\\n        TreeNode *temp;\\n\\n        prevsum=0;\\n        prev.push_back(0);\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            n=q.size();\\n            sum=0;\\n\\n            for(i=0;i<n;i++)\\n            {\\n                temp=q.front();\\n                q.pop();\\n                temp->val=prevsum-prev[i];\\n\\n                if(temp->left)\\n                {\\n                    q.push(temp->left);\\n                }\\n\\n                if(temp->right)\\n                {\\n                    q.push(temp->right);\\n                }\\n\\n                if(temp->left && temp->right)\\n                {\\n                    v.push_back(temp->left->val+temp->right->val);\\n                    v.push_back(temp->left->val+temp->right->val);\\n                    sum+=v.back();\\n                }\\n\\n                else if(!temp->left && temp->right)\\n                {\\n                    v.push_back(temp->right->val);\\n                    sum+=v.back();\\n                }\\n\\n                else if(temp->left && !temp->right)\\n                {\\n                    v.push_back(temp->left->val);\\n                    sum+=v.back();\\n                }\\n            }\\n\\n            prevsum=sum;\\n            prev=v;\\n            v.clear();\\n        }        \\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution \\n{\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n        int i,n,sum,prevsum;\\n\\n        vector<int> v,prev;\\n        queue<TreeNode *> q;\\n        TreeNode *temp;\\n\\n        prevsum=0;\\n        prev.push_back(0);\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            n=q.size();\\n            sum=0;\\n\\n            for(i=0;i<n;i++)\\n            {\\n                temp=q.front();\\n                q.pop();\\n                temp->val=prevsum-prev[i];\\n\\n                if(temp->left)\\n                {\\n                    q.push(temp->left);\\n                }\\n\\n                if(temp->right)\\n                {\\n                    q.push(temp->right);\\n                }\\n\\n                if(temp->left && temp->right)\\n                {\\n                    v.push_back(temp->left->val+temp->right->val);\\n                    v.push_back(temp->left->val+temp->right->val);\\n                    sum+=v.back();\\n                }\\n\\n                else if(!temp->left && temp->right)\\n                {\\n                    v.push_back(temp->right->val);\\n                    sum+=v.back();\\n                }\\n\\n                else if(temp->left && !temp->right)\\n                {\\n                    v.push_back(temp->left->val);\\n                    sum+=v.back();\\n                }\\n            }\\n\\n            prevsum=sum;\\n            prev=v;\\n            v.clear();\\n        }        \\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641620,
                "title": "simple-java-o-n-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSum of all cousins at level i = (Sum of all nodes at level i) - (val of sibling) - (val of self)\\n\\nWe can precompute sum of each level in one traversal of tree in O(n). Then in second traversal we can update values. Small catch is to get value of sibling, which can be passed by parent node.\\n\\nIf going to left subtree, then siblingValue will be of right node.\\nIf going to right subtree, then siblingValue will be of left node.\\n\\nBFS traversal is not necessarily required to solve this problem. Any traversal would work(in-order, pre-order, postorder, BFS). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSteps:\\n1. Calculate depth of tree(This can be avoided if using List instead of array): depth = 1 + max(leftDepth, rightDepth);\\n2. Compute level sum. You can use any traversal, I used pre-order. \\n3. Update node values. You can choose to create new tree instead of updating existing one if asked by interviewer.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O (n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        int levels = depth(root);\\n        int[] arr = new int[levels]; // Stores sum of level\\n        computeLevelSum(root, 0, arr);\\n        updateNodes(root, 0, 0, arr);\\n        return root;\\n    }\\n\\n    private void updateNodes(TreeNode root, int siblingVal, int i, int[] arr) {\\n        if (root == null) return;\\n        \\n        int leftValue = root.left != null ? root.left.val : 0;\\n        int rightValue = root.right != null ? root.right.val : 0;\\n        updateNodes(root.left, rightValue, i+1, arr);\\n        updateNodes(root.right, leftValue, i+1, arr);\\n\\n        root.val = arr[i] - root.val - siblingVal;\\n    }\\n\\n    private void computeLevelSum(TreeNode root, int i, int[] arr) {\\n        if (root == null) return;\\n\\n        arr[i] += root.val;\\n        computeLevelSum(root.left, i+1, arr);\\n        computeLevelSum(root.right, i+1, arr);\\n    }\\n\\n    private int depth(TreeNode root) {\\n        if (root == null) return 0;\\n        return Math.max(depth(root.left), depth(root.right)) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        int levels = depth(root);\\n        int[] arr = new int[levels]; // Stores sum of level\\n        computeLevelSum(root, 0, arr);\\n        updateNodes(root, 0, 0, arr);\\n        return root;\\n    }\\n\\n    private void updateNodes(TreeNode root, int siblingVal, int i, int[] arr) {\\n        if (root == null) return;\\n        \\n        int leftValue = root.left != null ? root.left.val : 0;\\n        int rightValue = root.right != null ? root.right.val : 0;\\n        updateNodes(root.left, rightValue, i+1, arr);\\n        updateNodes(root.right, leftValue, i+1, arr);\\n\\n        root.val = arr[i] - root.val - siblingVal;\\n    }\\n\\n    private void computeLevelSum(TreeNode root, int i, int[] arr) {\\n        if (root == null) return;\\n\\n        arr[i] += root.val;\\n        computeLevelSum(root.left, i+1, arr);\\n        computeLevelSum(root.right, i+1, arr);\\n    }\\n\\n    private int depth(TreeNode root) {\\n        if (root == null) return 0;\\n        return Math.max(depth(root.left), depth(root.right)) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641423,
                "title": "simple-bfs-pysthon",
                "content": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        node = root\\n        st = [node]\\n        while st:\\n            k = []\\n            s = 0\\n            for i in st:\\n                if i.left:\\n                    s += i.left.val\\n                if i.right:\\n                    s += i.right.val\\n            for i in st:\\n                node_sum = 0\\n                if i.left:\\n                    node_sum += i.left.val\\n                if i.right:\\n                    node_sum += i.right.val\\n                if i.left:\\n                    i.left.val = s-node_sum\\n                    k.append(i.left)\\n                if i.right:\\n                    i.right.val = s-node_sum\\n                    k.append(i.right)\\n            st = k\\n        root.val = 0\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        node = root\\n        st = [node]\\n        while st:\\n            k = []\\n            s = 0\\n            for i in st:\\n                if i.left:\\n                    s += i.left.val\\n                if i.right:\\n                    s += i.right.val\\n            for i in st:\\n                node_sum = 0\\n                if i.left:\\n                    node_sum += i.left.val\\n                if i.right:\\n                    node_sum += i.right.val\\n                if i.left:\\n                    i.left.val = s-node_sum\\n                    k.append(i.left)\\n                if i.right:\\n                    i.right.val = s-node_sum\\n                    k.append(i.right)\\n            st = k\\n        root.val = 0\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641378,
                "title": "dfs-bfs-easy-to-understand",
                "content": "# Intuition\\nreplaced_value = (sum of all nodes at a level) - (node itself + its siblings)\\nuse a standard bfs level order approach to store the sum of all nodes at a level in a level array(vector)\\nthen recursively(dfs) go for every node and first store both the left and right child values(only 2 sibling for every node as it is a binary tree that has the property of max 2 child per node) in a sibling variable.\\nif left child is not null then replace its value with totalsumatthatlevel-sibling, do the same with right child\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define ll long long\\nclass Solution {\\npublic:\\n    void dfs(TreeNode*root, vector<ll>&level, int i){\\n        if(!root) return;\\n        ll sibling=0;\\n        if(root->left) sibling+=root->left->val;\\n        if(root->right) sibling+=root->right->val;\\n        if(root->left) root->left->val=level[i+1]-sibling;\\n        if(root->right) root->right->val=level[i+1]-sibling;\\n        dfs(root->left,level,i+1);\\n        dfs(root->right,level,i+1);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<ll> level;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            ll sum=0;\\n            int s=q.size();\\n            while(s--){\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                sum+=temp->val;\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            level.push_back(sum);\\n        }\\n        if(root) root->val=0;\\n        dfs(root,level,0);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define ll long long\\nclass Solution {\\npublic:\\n    void dfs(TreeNode*root, vector<ll>&level, int i){\\n        if(!root) return;\\n        ll sibling=0;\\n        if(root->left) sibling+=root->left->val;\\n        if(root->right) sibling+=root->right->val;\\n        if(root->left) root->left->val=level[i+1]-sibling;\\n        if(root->right) root->right->val=level[i+1]-sibling;\\n        dfs(root->left,level,i+1);\\n        dfs(root->right,level,i+1);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<ll> level;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            ll sum=0;\\n            int s=q.size();\\n            while(s--){\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                sum+=temp->val;\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            level.push_back(sum);\\n        }\\n        if(root) root->val=0;\\n        dfs(root,level,0);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640324,
                "title": "cpp-solution-using-hashmap",
                "content": "Level order traversal\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nusing map & queue\\n<!-- Describe your approach to solving the problem. -->\\n\\nO(N)\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       root->val = 0;\\n\\n       while(!q.empty()){\\n           int n = q.size();\\n           unordered_map<TreeNode* , int>m;\\n           for(int i=0;i<n;i++){\\n               TreeNode* topNode = q.front();\\n               if(topNode->left){\\n                   q.push(topNode->left);\\n                   m[topNode] += topNode->left->val;\\n               }\\n               if(topNode->right){\\n                   q.push(topNode->right);\\n                   m[topNode] += topNode->right->val;\\n               }\\n               q.pop();\\n           }\\n           int sum = 0;\\n           for(auto it:m){\\n               sum += it.second;\\n           }\\n           for(auto it : m){\\n            if(it.first->left)\\n            it.first->left->val = sum-it.second;\\n            if(it.first->right)\\n            it.first->right->val = sum-it.second;\\n           }\\n       } \\n       return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       root->val = 0;\\n\\n       while(!q.empty()){\\n           int n = q.size();\\n           unordered_map<TreeNode* , int>m;\\n           for(int i=0;i<n;i++){\\n               TreeNode* topNode = q.front();\\n               if(topNode->left){\\n                   q.push(topNode->left);\\n                   m[topNode] += topNode->left->val;\\n               }\\n               if(topNode->right){\\n                   q.push(topNode->right);\\n                   m[topNode] += topNode->right->val;\\n               }\\n               q.pop();\\n           }\\n           int sum = 0;\\n           for(auto it:m){\\n               sum += it.second;\\n           }\\n           for(auto it : m){\\n            if(it.first->left)\\n            it.first->left->val = sum-it.second;\\n            if(it.first->right)\\n            it.first->right->val = sum-it.second;\\n           }\\n       } \\n       return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639609,
                "title": "level-sum-then-preorder-dfs-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> level_sum;\\n    void find_sum(TreeNode* root,int level){\\n        if(!root) return;\\n        if(level>=level_sum.size()) level_sum.push_back(0);\\n        level_sum[level]+=root->val;\\n        find_sum(root->left,level+1);\\n        find_sum(root->right,level+1);\\n    }\\n\\n    void preorder(TreeNode* root, int brothersum,int level){\\n        if(!root) return;\\n        int cousin_sum=level_sum[level]-brothersum;\\n        root->val=cousin_sum;\\n\\n        int childsum=0;\\n        childsum+=(root->left)? root->left->val : 0;\\n        childsum+=(root->right)? root->right->val : 0;\\n\\n        preorder(root->left,childsum,level+1);\\n        preorder(root->right,childsum,level+1);\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        find_sum(root,0);\\n        preorder(root,root->val,0);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> level_sum;\\n    void find_sum(TreeNode* root,int level){\\n        if(!root) return;\\n        if(level>=level_sum.size()) level_sum.push_back(0);\\n        level_sum[level]+=root->val;\\n        find_sum(root->left,level+1);\\n        find_sum(root->right,level+1);\\n    }\\n\\n    void preorder(TreeNode* root, int brothersum,int level){\\n        if(!root) return;\\n        int cousin_sum=level_sum[level]-brothersum;\\n        root->val=cousin_sum;\\n\\n        int childsum=0;\\n        childsum+=(root->left)? root->left->val : 0;\\n        childsum+=(root->right)? root->right->val : 0;\\n\\n        preorder(root->left,childsum,level+1);\\n        preorder(root->right,childsum,level+1);\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        find_sum(root,0);\\n        preorder(root,root->val,0);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639510,
                "title": "python-queue",
                "content": "Key here is to record in each node, the value of it\\'s sibling, in the queue.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [[root, 0]]\\n        tot_sum = 0\\n\\n        while queue:\\n            nextQ = []\\n            cur_sum = 0\\n\\n            for [node, sib_val] in queue:\\n                cur_sum += node.val\\n\\n                if node.left and node.right:\\n                    nextQ.append([node.left, node.right.val])\\n                    nextQ.append([node.right, node.left.val])\\n                elif node.left:\\n                    nextQ.append([node.left, 0])\\n                elif node.right:\\n                    nextQ.append([node.right, 0])\\n\\n            for [node, sib_val] in queue:\\n                node.val = cur_sum - sib_val - node.val\\n\\n            queue = nextQ\\n\\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [[root, 0]]\\n        tot_sum = 0\\n\\n        while queue:\\n            nextQ = []\\n            cur_sum = 0\\n\\n            for [node, sib_val] in queue:\\n                cur_sum += node.val\\n\\n                if node.left and node.right:\\n                    nextQ.append([node.left, node.right.val])\\n                    nextQ.append([node.right, node.left.val])\\n                elif node.left:\\n                    nextQ.append([node.left, 0])\\n                elif node.right:\\n                    nextQ.append([node.right, 0])\\n\\n            for [node, sib_val] in queue:\\n                node.val = cur_sum - sib_val - node.val\\n\\n            queue = nextQ\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639437,
                "title": "python-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_sum=defaultdict(int)\\n        def dfs(root,height):\\n            if not root:return\\n            level_sum[height]+=root.val\\n            if root.left:dfs(root.left,height+1)\\n            if root.right:dfs(root.right,height+1)\\n        dfs(root,0)\\n        def dfs_sum(sib_val,own,height):\\n            if not own:\\n                return \\n            own.val=level_sum[height]-own.val-sib_val\\n            if own.left:\\n                left=own.left.val\\n            else:\\n                left=0\\n            right=own.right.val if own.right else 0\\n            dfs_sum(left,own.right,height+1)\\n            dfs_sum(right,own.left,height+1)\\n        dfs_sum(0,root,0)\\n        return root     \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_sum=defaultdict(int)\\n        def dfs(root,height):\\n            if not root:return\\n            level_sum[height]+=root.val\\n            if root.left:dfs(root.left,height+1)\\n            if root.right:dfs(root.right,height+1)\\n        dfs(root,0)\\n        def dfs_sum(sib_val,own,height):\\n            if not own:\\n                return \\n            own.val=level_sum[height]-own.val-sib_val\\n            if own.left:\\n                left=own.left.val\\n            else:\\n                left=0\\n            right=own.right.val if own.right else 0\\n            dfs_sum(left,own.right,height+1)\\n            dfs_sum(right,own.left,height+1)\\n        dfs_sum(0,root,0)\\n        return root     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639381,
                "title": "level-order-traversal-and-hashing",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     TreeNode *replaceValueInTree(TreeNode *root)\\n    {\\n        queue<pair<TreeNode *, TreeNode *>> q;\\n        q.push({nullptr, root});\\n\\n        while (!q.empty())\\n        {\\n            unordered_map<TreeNode *, int> mp;\\n            vector<pair<TreeNode *, TreeNode *>> dummy;\\n            int tot = 0;\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++)\\n            {\\n                TreeNode *par = q.front().first;\\n                TreeNode *node = q.front().second;\\n                q.pop();\\n                if (node->left)\\n                {\\n                    q.push({node, node->left});\\n                }\\n                if (node->right)\\n                {\\n                    q.push({node, node->right});\\n                }\\n\\n                if (par == nullptr)\\n                {\\n                    node->val = 0;\\n                    continue;\\n                }\\n                dummy.push_back({node, par});\\n\\n                mp[par] += node->val;\\n                tot += node->val;\\n            }\\n\\n            for (auto it : dummy)\\n            {\\n                TreeNode *node = it.first;\\n                TreeNode *par = it.second;\\n\\n                node->val = tot - mp[par];\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     TreeNode *replaceValueInTree(TreeNode *root)\\n    {\\n        queue<pair<TreeNode *, TreeNode *>> q;\\n        q.push({nullptr, root});\\n\\n        while (!q.empty())\\n        {\\n            unordered_map<TreeNode *, int> mp;\\n            vector<pair<TreeNode *, TreeNode *>> dummy;\\n            int tot = 0;\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++)\\n            {\\n                TreeNode *par = q.front().first;\\n                TreeNode *node = q.front().second;\\n                q.pop();\\n                if (node->left)\\n                {\\n                    q.push({node, node->left});\\n                }\\n                if (node->right)\\n                {\\n                    q.push({node, node->right});\\n                }\\n\\n                if (par == nullptr)\\n                {\\n                    node->val = 0;\\n                    continue;\\n                }\\n                dummy.push_back({node, par});\\n\\n                mp[par] += node->val;\\n                tot += node->val;\\n            }\\n\\n            for (auto it : dummy)\\n            {\\n                TreeNode *node = it.first;\\n                TreeNode *par = it.second;\\n\\n                node->val = tot - mp[par];\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639184,
                "title": "easy-java-soluation-freshser",
                "content": "\\n  \\n  \\n  \\n\\n  \\n  class Pair{\\n    TreeNode node,par;\\n    public Pair(TreeNode a,TreeNode b){\\n        node =a;\\n        par =b;\\n    }\\n}\\n\\nclass Demo {\\n \\n public TreeNode replaceValueInTree(TreeNode root) {\\n \\n        Queue<Pair>q = new LinkedList<>();\\n        \\n        q.add(new Pair(root,root));\\n        \\n        while(!q.isEmpty()){\\n            int n=q.size();\\n            Queue<Pair>tq = new LinkedList<>();\\n             long sum=0;\\n            for(int i=0;i<n;i++){\\n                Pair p=q.remove();\\n                tq.add(p);\\n                sum+=p.node.val;\\n                if(p.node.left!=null){\\n                    q.add(new Pair(p.node.left,p.node));\\n                }\\n                 if(p.node.right!=null){\\n                    q.add(new Pair(p.node.right,p.node));\\n                }\\n            }\\n            //updating the value\\n            \\n            while(!tq.isEmpty()){\\n                Pair p=tq.remove();\\n               //node ans par are same example: parent node\\n                if(p.node==p.par)\\n                    p.node.val=0;\\n                else{\\n                    //if current node siblings not exist ;\\n                    if(p.par.left==null||p.par.right==null){\\n                     long tempSum=0;\\n                     tempSum=((p.par.left!=null?p.par.left.val:0)+(p.par.right!=null?p.par.right.val:0));\\n                     p.node.val=(int) (sum-tempSum);\\n                    }else{\\n                        //if current node siblings exist \\n                    \\n                    long l=p.par.left.val;\\n                    long r=p.par.right.val; \\n                     p.par.left.val=(int) (sum-(l+r));\\n                     p.par.right.val=(int) (sum-(l+r));\\n                    //both node and its siblings update together so remove its sibling for queue\\n                        tq.remove();\\n                    }\\n                   \\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "\\n  \\n  \\n  \\n\\n  \\n  class Pair{\\n    TreeNode node,par;\\n    public Pair(TreeNode a,TreeNode b){\\n        node =a;\\n        par =b;\\n    }\\n}\\n\\nclass Demo {\\n \\n public TreeNode replaceValueInTree(TreeNode root) {\\n \\n        Queue<Pair>q = new LinkedList<>();\\n        \\n        q.add(new Pair(root,root));\\n        \\n        while(!q.isEmpty()){\\n            int n=q.size();\\n            Queue<Pair>tq = new LinkedList<>();\\n             long sum=0;\\n            for(int i=0;i<n;i++){\\n                Pair p=q.remove();\\n                tq.add(p);\\n                sum+=p.node.val;\\n                if(p.node.left!=null){\\n                    q.add(new Pair(p.node.left,p.node));\\n                }\\n                 if(p.node.right!=null){\\n                    q.add(new Pair(p.node.right,p.node));\\n                }\\n            }\\n            //updating the value\\n            \\n            while(!tq.isEmpty()){\\n                Pair p=tq.remove();\\n               //node ans par are same example: parent node\\n                if(p.node==p.par)\\n                    p.node.val=0;\\n                else{\\n                    //if current node siblings not exist ;\\n                    if(p.par.left==null||p.par.right==null){\\n                     long tempSum=0;\\n                     tempSum=((p.par.left!=null?p.par.left.val:0)+(p.par.right!=null?p.par.right.val:0));\\n                     p.node.val=(int) (sum-tempSum);\\n                    }else{\\n                        //if current node siblings exist \\n                    \\n                    long l=p.par.left.val;\\n                    long r=p.par.right.val; \\n                     p.par.left.val=(int) (sum-(l+r));\\n                     p.par.right.val=(int) (sum-(l+r));\\n                    //both node and its siblings update together so remove its sibling for queue\\n                        tq.remove();\\n                    }\\n                   \\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3639091,
                "title": "java-code-using-bfs-16-ms-beats-93-of-all-java-submissions",
                "content": "# Intuition\\nUse BFS to iterate level by level, getting the level sum and for each node get the parent sum.\\nThe new node value = levelSum - parentSum.\\n\\n# Approach\\nCreate an annotated tree node class to hold the tree node and its parent children sum.\\n\\nUse standard BFS search with initial level Sum = root.val.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private class AnnotatedTreeNode {\\n\\n        public int parentSum;\\n\\n        public TreeNode node;\\n\\n        public AnnotatedTreeNode(int parentSum, TreeNode node) {\\n\\n            this.parentSum = parentSum;\\n\\n            this.node = node;\\n\\n        } \\n\\n\\n    }\\n\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n\\n        Queue<AnnotatedTreeNode> current = new LinkedList<>();\\n\\n        int levelSum = root.val;\\n\\n        current.offer(new AnnotatedTreeNode(root.val, root));\\n\\n        while (!current.isEmpty()) {\\n\\n            int sum = 0;\\n\\n            int length = current.size();\\n\\n            for (int index = 0; index < length; ++index) {\\n\\n                AnnotatedTreeNode curr = current.poll();\\n\\n                curr.node.val = levelSum - curr.parentSum;\\n\\n                int parentSum = (curr.node.left == null ? 0 : curr.node.left.val) + (curr.node.right == null ? 0 : curr.node.right.val);\\n\\n                sum += parentSum;\\n\\n                if (curr.node.left != null)\\n                    current.offer(new AnnotatedTreeNode(parentSum, curr.node.left)) ;         \\n\\n                if (curr.node.right != null)\\n                    current.offer(new AnnotatedTreeNode(parentSum, curr.node.right)) ;         \\n\\n           }\\n\\n           levelSum = sum;\\n\\n        }\\n\\n        return root;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private class AnnotatedTreeNode {\\n\\n        public int parentSum;\\n\\n        public TreeNode node;\\n\\n        public AnnotatedTreeNode(int parentSum, TreeNode node) {\\n\\n            this.parentSum = parentSum;\\n\\n            this.node = node;\\n\\n        } \\n\\n\\n    }\\n\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n\\n        Queue<AnnotatedTreeNode> current = new LinkedList<>();\\n\\n        int levelSum = root.val;\\n\\n        current.offer(new AnnotatedTreeNode(root.val, root));\\n\\n        while (!current.isEmpty()) {\\n\\n            int sum = 0;\\n\\n            int length = current.size();\\n\\n            for (int index = 0; index < length; ++index) {\\n\\n                AnnotatedTreeNode curr = current.poll();\\n\\n                curr.node.val = levelSum - curr.parentSum;\\n\\n                int parentSum = (curr.node.left == null ? 0 : curr.node.left.val) + (curr.node.right == null ? 0 : curr.node.right.val);\\n\\n                sum += parentSum;\\n\\n                if (curr.node.left != null)\\n                    current.offer(new AnnotatedTreeNode(parentSum, curr.node.left)) ;         \\n\\n                if (curr.node.right != null)\\n                    current.offer(new AnnotatedTreeNode(parentSum, curr.node.right)) ;         \\n\\n           }\\n\\n           levelSum = sum;\\n\\n        }\\n\\n        return root;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639070,
                "title": "two-solutions-pre-order-traversal-easy-to-understand",
                "content": "# Solution 1\\n\\n1439 ms Beats 68.18%\\n\\n```swift\\nfunc replaceValueInTree(_ root: TreeNode?) -> TreeNode? {\\n    var sums: [Int] = []\\n    getSums(root, 0, &sums)\\n    assign(root, 0, sums)\\n    root?.val = 0\\n    return root\\n}\\n\\nprivate func getSums(_ node: TreeNode?, _ level: Int, _ sums: inout [Int]) {\\n    guard let node = node else { return }\\n    if level < sums.count {\\n        sums[level] += node.val\\n    } else {\\n        sums.append(node.val)\\n    }\\n    getSums(node.left, 1 + level, &sums)\\n    getSums(node.right, 1 + level, &sums)\\n}\\n\\nprivate func assign(_ node: TreeNode?, _ level: Int, _ sums: [Int]) {\\n    guard let node = node, (node.left != nil || node.right != nil) else { return }\\n    let value = sums[1 + level] - (node.left?.val ?? 0) - (node.right?.val ?? 0)\\n    node.left?.val = value\\n    node.right?.val = value\\n    assign(node.left, 1 + level, sums)\\n    assign(node.right, 1 + level, sums)\\n}\\n```\\n\\n# Solution 2\\n\\n1453 ms Beats 54.54%\\n\\n```swift\\nfunc replaceValueInTree(_ root: TreeNode?) -> TreeNode? {\\n    var sums: [Int] = []\\n    traverse(root, 0) { node, level in\\n        if level < sums.count {\\n            sums[level] += node.val\\n        } else {\\n            sums.append(node.val)\\n        }\\n        return true\\n    }\\n    traverse(root, 0) { node, level in\\n        guard node.left != nil || node.right != nil else { return false }\\n        let value = sums[1 + level] - (node.left?.val ?? 0) - (node.right?.val ?? 0)\\n        node.left?.val = value\\n        node.right?.val = value\\n        return true\\n    }\\n    root?.val = 0\\n    return root\\n}\\n\\nprivate func traverse(_ node: TreeNode?, _ level: Int, _ visitAndContinue: (TreeNode, Int) -> Bool) {\\n    guard let node = node, visitAndContinue(node, level) else { return }\\n    traverse(node.left, 1 + level, visitAndContinue)\\n    traverse(node.right, 1 + level, visitAndContinue)\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Recursion"
                ],
                "code": "```swift\\nfunc replaceValueInTree(_ root: TreeNode?) -> TreeNode? {\\n    var sums: [Int] = []\\n    getSums(root, 0, &sums)\\n    assign(root, 0, sums)\\n    root?.val = 0\\n    return root\\n}\\n\\nprivate func getSums(_ node: TreeNode?, _ level: Int, _ sums: inout [Int]) {\\n    guard let node = node else { return }\\n    if level < sums.count {\\n        sums[level] += node.val\\n    } else {\\n        sums.append(node.val)\\n    }\\n    getSums(node.left, 1 + level, &sums)\\n    getSums(node.right, 1 + level, &sums)\\n}\\n\\nprivate func assign(_ node: TreeNode?, _ level: Int, _ sums: [Int]) {\\n    guard let node = node, (node.left != nil || node.right != nil) else { return }\\n    let value = sums[1 + level] - (node.left?.val ?? 0) - (node.right?.val ?? 0)\\n    node.left?.val = value\\n    node.right?.val = value\\n    assign(node.left, 1 + level, sums)\\n    assign(node.right, 1 + level, sums)\\n}\\n```\n```swift\\nfunc replaceValueInTree(_ root: TreeNode?) -> TreeNode? {\\n    var sums: [Int] = []\\n    traverse(root, 0) { node, level in\\n        if level < sums.count {\\n            sums[level] += node.val\\n        } else {\\n            sums.append(node.val)\\n        }\\n        return true\\n    }\\n    traverse(root, 0) { node, level in\\n        guard node.left != nil || node.right != nil else { return false }\\n        let value = sums[1 + level] - (node.left?.val ?? 0) - (node.right?.val ?? 0)\\n        node.left?.val = value\\n        node.right?.val = value\\n        return true\\n    }\\n    root?.val = 0\\n    return root\\n}\\n\\nprivate func traverse(_ node: TreeNode?, _ level: Int, _ visitAndContinue: (TreeNode, Int) -> Bool) {\\n    guard let node = node, visitAndContinue(node, level) else { return }\\n    traverse(node.left, 1 + level, visitAndContinue)\\n    traverse(node.right, 1 + level, visitAndContinue)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3634434,
                "title": "java-bfs-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Queue<List<TreeNode>> queue = new LinkedList<>();\\n        \\n        List<TreeNode> listRoot = new ArrayList<>();\\n        listRoot.add(root);\\n        queue.add(listRoot);\\n        int sum = 0;\\n        for (TreeNode node : listRoot)\\n            sum += node.val;\\n        \\n        map.put(0, sum);\\n        int level = -1;\\n        \\n        while (!queue.isEmpty()) {\\n            int n = queue.size();\\n            level++;\\n            for (int i = 0; i < n; i++) {\\n                List<TreeNode> list = queue.poll();\\n                int  localSum = 0;\\n                \\n                for (TreeNode node : list) {\\n                    localSum += node.val;\\n                }\\n                for (TreeNode node : list) {\\n                    node.val = map.get(level) - localSum;\\n                    List<TreeNode> list1 = new ArrayList<>();\\n                    \\n                    if (node.left != null) {\\n                        map.put(level + 1, map.getOrDefault(level + 1, 0) + node.left.val);\\n                        list1.add(node.left);\\n                    }\\n                    if (node.right != null) {\\n                        map.put(level + 1, map.getOrDefault(level + 1, 0) + node.right.val);\\n                        list1.add(node.right);\\n                    }\\n                    if (list1.size() > 0)\\n                        queue.add(list1);\\n                }   \\n            }\\n        }\\n        return root;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Queue<List<TreeNode>> queue = new LinkedList<>();\\n        \\n        List<TreeNode> listRoot = new ArrayList<>();\\n        listRoot.add(root);\\n        queue.add(listRoot);\\n        int sum = 0;\\n        for (TreeNode node : listRoot)\\n            sum += node.val;\\n        \\n        map.put(0, sum);\\n        int level = -1;\\n        \\n        while (!queue.isEmpty()) {\\n            int n = queue.size();\\n            level++;\\n            for (int i = 0; i < n; i++) {\\n                List<TreeNode> list = queue.poll();\\n                int  localSum = 0;\\n                \\n                for (TreeNode node : list) {\\n                    localSum += node.val;\\n                }\\n                for (TreeNode node : list) {\\n                    node.val = map.get(level) - localSum;\\n                    List<TreeNode> list1 = new ArrayList<>();\\n                    \\n                    if (node.left != null) {\\n                        map.put(level + 1, map.getOrDefault(level + 1, 0) + node.left.val);\\n                        list1.add(node.left);\\n                    }\\n                    if (node.right != null) {\\n                        map.put(level + 1, map.getOrDefault(level + 1, 0) + node.right.val);\\n                        list1.add(node.right);\\n                    }\\n                    if (list1.size() > 0)\\n                        queue.add(list1);\\n                }   \\n            }\\n        }\\n        return root;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632507,
                "title": "java-easy-solution",
                "content": "\\n# Code\\n```\\n//RITIK PATEL\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> que = new LinkedList();\\n        HashMap<TreeNode,TreeNode> par = new HashMap();\\n        HashMap<Integer, Integer> levelSum = new HashMap();\\n        que.add(root);\\n        par.put(root, null);\\n        int level = 0;\\n        while(que.size()!=0){\\n            int size = que.size();\\n            int sum = 0;\\n            level+=1;\\n            while(size!=0){\\n                size--;\\n                TreeNode top = que.poll();\\n                sum+=top.val;\\n                if(top.left!=null){\\n                    que.add(top.left);\\n                    par.put(top.left,top);\\n                }\\n                if(top.right!=null){\\n                    que.add(top.right);\\n                    par.put(top.right,top);\\n                }\\n            }\\n            levelSum.put(level,sum);\\n        }\\n        TreeNode newNode = new TreeNode();\\n        DFS(root,newNode, par,levelSum,1);\\n        return newNode;   \\n    }\\n    void DFS(TreeNode root,TreeNode newNode, HashMap<TreeNode,TreeNode> par,HashMap<Integer, Integer> levelSum, int level){\\n        //check neighbour\\n        newNode.val = levelSum.get(level);\\n        TreeNode parent = par.get(root);\\n        if(parent!=null){\\n            int val = 0;\\n            if(parent.left!=null){\\n                val = parent.left.val;\\n            }\\n            if(parent.right!=null){\\n                val += parent.right.val;\\n            }\\n            newNode.val-=val;\\n        }\\n        else{\\n            newNode.val-=root.val;\\n        }\\n        if(root.left!=null){\\n            TreeNode node = new TreeNode();\\n            newNode.left = node;\\n            DFS(root.left, newNode.left, par, levelSum, level+1);\\n        }\\n        if(root.right!=null){\\n            TreeNode node = new TreeNode();\\n            newNode.right = node;\\n            DFS(root.right, newNode.right, par, levelSum, level+1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n//RITIK PATEL\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> que = new LinkedList();\\n        HashMap<TreeNode,TreeNode> par = new HashMap();\\n        HashMap<Integer, Integer> levelSum = new HashMap();\\n        que.add(root);\\n        par.put(root, null);\\n        int level = 0;\\n        while(que.size()!=0){\\n            int size = que.size();\\n            int sum = 0;\\n            level+=1;\\n            while(size!=0){\\n                size--;\\n                TreeNode top = que.poll();\\n                sum+=top.val;\\n                if(top.left!=null){\\n                    que.add(top.left);\\n                    par.put(top.left,top);\\n                }\\n                if(top.right!=null){\\n                    que.add(top.right);\\n                    par.put(top.right,top);\\n                }\\n            }\\n            levelSum.put(level,sum);\\n        }\\n        TreeNode newNode = new TreeNode();\\n        DFS(root,newNode, par,levelSum,1);\\n        return newNode;   \\n    }\\n    void DFS(TreeNode root,TreeNode newNode, HashMap<TreeNode,TreeNode> par,HashMap<Integer, Integer> levelSum, int level){\\n        //check neighbour\\n        newNode.val = levelSum.get(level);\\n        TreeNode parent = par.get(root);\\n        if(parent!=null){\\n            int val = 0;\\n            if(parent.left!=null){\\n                val = parent.left.val;\\n            }\\n            if(parent.right!=null){\\n                val += parent.right.val;\\n            }\\n            newNode.val-=val;\\n        }\\n        else{\\n            newNode.val-=root.val;\\n        }\\n        if(root.left!=null){\\n            TreeNode node = new TreeNode();\\n            newNode.left = node;\\n            DFS(root.left, newNode.left, par, levelSum, level+1);\\n        }\\n        if(root.right!=null){\\n            TreeNode node = new TreeNode();\\n            newNode.right = node;\\n            DFS(root.right, newNode.right, par, levelSum, level+1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620265,
                "title": "python-dfs-modify-tree-in-place",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTrack the layer sum and the sum of every node\\'s immediate children node. \\nSibling sum for any node becomes (layerSum - the children sum from parent).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![IMG_0007.jpg](https://assets.leetcode.com/users/images/5b293152-1994-4c3d-a704-910845a7f97c_1686371153.119484.jpeg)\\n\\n\\nDFS once to calculate layerSum. In the same DFS pass, calculate the sum of immediate children and store the sum in parent node.\\n\\nDFS a second time, for each node, we want to set its children to the (layerSum - the children sum this node is tracking), then reset the sibling sum of itself.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(L), where L is the number of layers.\\n\\n# Code\\n```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        layerSum = collections.defaultdict(int)\\n\\n        def dfs1(node, layer):\\n            if node is None:\\n                return\\n            layerSum[layer] += node.val\\n            leftSum = node.left.val if node.left else 0\\n            rightSum = node.right.val if node.right else 0\\n            node.val = leftSum + rightSum\\n            dfs1(node.left, layer+1)\\n            dfs1(node.right, layer+1)\\n        \\n        dfs1(root, 0)\\n\\n        def setSiblingSum(node, layer, ss):\\n            if node is None:\\n                return\\n            siblingSum = layerSum[layer+1] - node.val\\n            setSiblingSum(node.left, layer+1, siblingSum)\\n            setSiblingSum(node.right, layer+1, siblingSum)\\n            node.val = ss\\n\\n        setSiblingSum(root.left, 1, 0)\\n        setSiblingSum(root.right, 1, 0)\\n        root.val = 0\\n        return root\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        layerSum = collections.defaultdict(int)\\n\\n        def dfs1(node, layer):\\n            if node is None:\\n                return\\n            layerSum[layer] += node.val\\n            leftSum = node.left.val if node.left else 0\\n            rightSum = node.right.val if node.right else 0\\n            node.val = leftSum + rightSum\\n            dfs1(node.left, layer+1)\\n            dfs1(node.right, layer+1)\\n        \\n        dfs1(root, 0)\\n\\n        def setSiblingSum(node, layer, ss):\\n            if node is None:\\n                return\\n            siblingSum = layerSum[layer+1] - node.val\\n            setSiblingSum(node.left, layer+1, siblingSum)\\n            setSiblingSum(node.right, layer+1, siblingSum)\\n            node.val = ss\\n\\n        setSiblingSum(root.left, 1, 0)\\n        setSiblingSum(root.right, 1, 0)\\n        root.val = 0\\n        return root\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615361,
                "title": "bfs-96-time-99-space",
                "content": "```\\ndef replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        # 2023/06/08 13:30PM -> 13:55PM\\n        total, q = root.val, collections.deque([(root, root.val)])\\n        while q:\\n            new_total = 0\\n            for _ in range(len(q)):\\n                cur, vals = q.popleft()\\n                l = cur.left.val if cur.left else 0\\n                r = cur.right.val if cur.right else 0\\n                new_total += (l + r)\\n                if cur.left:\\n                    q.append((cur.left, l + r))\\n                if cur.right:\\n                    q.append((cur.right, l + r))\\n                cur.val = total - vals\\n            total = new_total\\n        return root\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\ndef replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        # 2023/06/08 13:30PM -> 13:55PM\\n        total, q = root.val, collections.deque([(root, root.val)])\\n        while q:\\n            new_total = 0\\n            for _ in range(len(q)):\\n                cur, vals = q.popleft()\\n                l = cur.left.val if cur.left else 0\\n                r = cur.right.val if cur.right else 0\\n                new_total += (l + r)\\n                if cur.left:\\n                    q.append((cur.left, l + r))\\n                if cur.right:\\n                    q.append((cur.right, l + r))\\n                cur.val = total - vals\\n            total = new_total\\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3589099,
                "title": "bfs-explained",
                "content": "# Intuition\\nWe need cousins how can we get it my first reaction was level order traversal. Now bfs offers same but efficiently.\\n\\n# Approach\\nSimply run bfs and have a vector or a set your call and on each level take the sum of the nodes at that level and keep inserting them in the vector. Once a level has been traversed for every child of the node in the vector subract the left and right value and voila what is left is the value of it\\'s cousin.\\nRemember you have subtracted the left and right values of each node so if any value is left it is definitely the cousin.\\n\\n# Complexity\\n- Time complexity:\\nO(v+e)\\n\\n- Space complexity:\\n- o(max number of nodes at any level) o(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        root->val=0;// initialising the root to be 0 as it has 0 cousin;\\n        queue<TreeNode*> q; q.push(root);\\n        while(!q.empty()){\\n            vector<TreeNode*> buffer;\\n            int szq=q.size();\\n            int sum=0;\\n            while(szq--){\\n                TreeNode* curr=q.front();\\n                buffer.push_back(curr);\\n                q.pop();\\n                if(curr->left){\\n                    q.push(curr->left);\\n                    sum+=curr->left->val;\\n                }if(curr->right){\\n                    q.push(curr->right);\\n                    sum+=curr->right->val;\\n                }\\n            }\\n            for(TreeNode* nodes:buffer){\\n                int temp=sum;\\n                if(nodes->left)temp-=nodes->left->val;\\n                if(nodes->right)temp-=nodes->right->val;\\n                if(nodes->left)nodes->left->val=temp;\\n                if(nodes->right)nodes->right->val=temp;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        root->val=0;// initialising the root to be 0 as it has 0 cousin;\\n        queue<TreeNode*> q; q.push(root);\\n        while(!q.empty()){\\n            vector<TreeNode*> buffer;\\n            int szq=q.size();\\n            int sum=0;\\n            while(szq--){\\n                TreeNode* curr=q.front();\\n                buffer.push_back(curr);\\n                q.pop();\\n                if(curr->left){\\n                    q.push(curr->left);\\n                    sum+=curr->left->val;\\n                }if(curr->right){\\n                    q.push(curr->right);\\n                    sum+=curr->right->val;\\n                }\\n            }\\n            for(TreeNode* nodes:buffer){\\n                int temp=sum;\\n                if(nodes->left)temp-=nodes->left->val;\\n                if(nodes->right)temp-=nodes->right->val;\\n                if(nodes->left)nodes->left->val=temp;\\n                if(nodes->right)nodes->right->val=temp;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588991,
                "title": "c-solution-level-order-traversal",
                "content": "# Intuition\\nWe will perform level-order traversal on the tree, ans calculate the sum of all the nodes on the levels, ans store the sum of all nodes for the respective parent nodes for each node on that level. Then change the node values by `(total sum of all the nodes in that level) - (sum of nodes of that parent).`\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*, TreeNode*>> q;\\n        q.push({NULL, root});\\n        while(q.size()){\\n           int s = q.size(), sum=0;\\n           unordered_map<TreeNode*, int> sumIn;\\n           vector<pair<TreeNode*, TreeNode*>> layer;\\n           while(s--){\\n                auto [parent, node] = q.front();\\n                sum+=node->val;\\n                layer.push_back({parent, node});\\n                q.pop();\\n                sumIn[parent]+=node->val;\\n                if(node->left) q.push({node, node->left});\\n                if(node->right) q.push({node, node->right});\\n           }\\n           for(auto &[parent, node]: layer)\\n                if(parent==nullptr)\\n                    node->val = 0;\\n                else\\n                    node->val = sum-sumIn[parent];\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*, TreeNode*>> q;\\n        q.push({NULL, root});\\n        while(q.size()){\\n           int s = q.size(), sum=0;\\n           unordered_map<TreeNode*, int> sumIn;\\n           vector<pair<TreeNode*, TreeNode*>> layer;\\n           while(s--){\\n                auto [parent, node] = q.front();\\n                sum+=node->val;\\n                layer.push_back({parent, node});\\n                q.pop();\\n                sumIn[parent]+=node->val;\\n                if(node->left) q.push({node, node->left});\\n                if(node->right) q.push({node, node->right});\\n           }\\n           for(auto &[parent, node]: layer)\\n                if(parent==nullptr)\\n                    node->val = 0;\\n                else\\n                    node->val = sum-sumIn[parent];\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587175,
                "title": "java-solution-92-runtime-62-memory-bfs-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we need to replace the value of each node in the tree with the sum of all its cousins\\' values, we shall use **Breadth First Traversal**. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhile traversing any level, we will be adding the next level node\\'s value to a int variable `nextLevelSum` and we will push the left and right child of the current level nodes by modifying it\\'s `val`. The modified value will be the sum of that node\\'s `val` and it\\'s cousin\\'s `val`.\\nThis modification is done so that in the next level traversal, we can use the `nextLevelSum` by assigning it to `curLevelSum` and the final `val` of the current level nodes will be `curLevelSum - node.val`.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root == null)return root;\\n\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int nextLevelSum = root.val;\\n        int curLevelSum = 0;\\n        while(!q.isEmpty()){\\n            curLevelSum = nextLevelSum;\\n            nextLevelSum = 0;\\n            Queue<TreeNode> temp = new LinkedList<>();\\n            while(!q.isEmpty()){\\n                TreeNode t = q.poll();\\n                t.val = curLevelSum-t.val;\\n                if(t.left!=null && t.right!=null){\\n                    nextLevelSum+=t.left.val;\\n                    nextLevelSum+=t.right.val;\\n\\n                    int val = t.left.val + t.right.val;\\n                    t.left.val = val;\\n                    t.right.val = val;\\n\\n                    temp.add(t.left);\\n                    temp.add(t.right);\\n                }else if(t.left!=null){\\n                    nextLevelSum+=t.left.val;\\n                    temp.add(t.left);\\n                }else if(t.right!=null){\\n                    nextLevelSum+=t.right.val;\\n                    temp.add(t.right);\\n                }\\n            }\\n            q = temp;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root == null)return root;\\n\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int nextLevelSum = root.val;\\n        int curLevelSum = 0;\\n        while(!q.isEmpty()){\\n            curLevelSum = nextLevelSum;\\n            nextLevelSum = 0;\\n            Queue<TreeNode> temp = new LinkedList<>();\\n            while(!q.isEmpty()){\\n                TreeNode t = q.poll();\\n                t.val = curLevelSum-t.val;\\n                if(t.left!=null && t.right!=null){\\n                    nextLevelSum+=t.left.val;\\n                    nextLevelSum+=t.right.val;\\n\\n                    int val = t.left.val + t.right.val;\\n                    t.left.val = val;\\n                    t.right.val = val;\\n\\n                    temp.add(t.left);\\n                    temp.add(t.right);\\n                }else if(t.left!=null){\\n                    nextLevelSum+=t.left.val;\\n                    temp.add(t.left);\\n                }else if(t.right!=null){\\n                    nextLevelSum+=t.right.val;\\n                    temp.add(t.right);\\n                }\\n            }\\n            q = temp;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581166,
                "title": "bfs-very-detailed-comments-so-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //Empty tree return NULL, no need of modification\\n        if(root == NULL)\\n            return root;\\n        \\n        //root will never have any cousin , hence it will always have value 0\\n        root->val = 0;\\n        \\n        //queue stores current node and parent node\\n        queue<pair<TreeNode*, TreeNode*>>q;\\n        \\n        //parent of root is NULL of course\\n        q.push({root,NULL});\\n        \\n        \\n        while(!q.empty())\\n        {\\n            //Size of the queue\\n            int n = q.size();\\n            \\n            //Sum stores the sum of a particular level\\n            int sum = 0;\\n            \\n            //sum of children of a parent\\n            unordered_map<TreeNode*, int>mp;\\n            \\n            //stores pair of parent and its child of a particular level\\n            vector<pair<TreeNode*,TreeNode*>>level;\\n            \\n            \\n             for(int i = 0; i<n; i++)\\n             {\\n                 //current node\\n                TreeNode* node = q.front().first;\\n                 \\n                 // parent of the current node\\n                 TreeNode* parent = q.front().second;\\n                 q.pop();\\n                 \\n                 //Adding value of the current node to the sum of a level\\n                 sum += node->val;\\n                 \\n                 //parent storing the sum of this childen\\n                 mp[parent] += node->val;\\n                 \\n                 //storing the parent and its child for ease of future modification\\n                 level.push_back({parent, node});\\n                 \\n                 //pushing left child of current node with parent as the current node\\n                 if(node->left)\\n                 {\\n                     q.push({node->left,node});\\n                 }\\n                 \\n                 //pushing right child of current node with parent as the current node\\n                 if(node->right)\\n                 {\\n                     q. push({node->right, node});                    \\n                 }\\n             }\\n        \\n            //one level is completed, now we are modifing the tree\\n            for(auto it: level)\\n            {\\n                //Substracting the sum of childen of a prent from the total sum of a level\\n                int val = sum - mp[it.first];\\n                                \\n                it.second->val = val;           \\n            }            \\n            \\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //Empty tree return NULL, no need of modification\\n        if(root == NULL)\\n            return root;\\n        \\n        //root will never have any cousin , hence it will always have value 0\\n        root->val = 0;\\n        \\n        //queue stores current node and parent node\\n        queue<pair<TreeNode*, TreeNode*>>q;\\n        \\n        //parent of root is NULL of course\\n        q.push({root,NULL});\\n        \\n        \\n        while(!q.empty())\\n        {\\n            //Size of the queue\\n            int n = q.size();\\n            \\n            //Sum stores the sum of a particular level\\n            int sum = 0;\\n            \\n            //sum of children of a parent\\n            unordered_map<TreeNode*, int>mp;\\n            \\n            //stores pair of parent and its child of a particular level\\n            vector<pair<TreeNode*,TreeNode*>>level;\\n            \\n            \\n             for(int i = 0; i<n; i++)\\n             {\\n                 //current node\\n                TreeNode* node = q.front().first;\\n                 \\n                 // parent of the current node\\n                 TreeNode* parent = q.front().second;\\n                 q.pop();\\n                 \\n                 //Adding value of the current node to the sum of a level\\n                 sum += node->val;\\n                 \\n                 //parent storing the sum of this childen\\n                 mp[parent] += node->val;\\n                 \\n                 //storing the parent and its child for ease of future modification\\n                 level.push_back({parent, node});\\n                 \\n                 //pushing left child of current node with parent as the current node\\n                 if(node->left)\\n                 {\\n                     q.push({node->left,node});\\n                 }\\n                 \\n                 //pushing right child of current node with parent as the current node\\n                 if(node->right)\\n                 {\\n                     q. push({node->right, node});                    \\n                 }\\n             }\\n        \\n            //one level is completed, now we are modifing the tree\\n            for(auto it: level)\\n            {\\n                //Substracting the sum of childen of a prent from the total sum of a level\\n                int val = sum - mp[it.first];\\n                                \\n                it.second->val = val;           \\n            }            \\n            \\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581163,
                "title": "bfs-very-detailed-comments-so-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //Empty tree return NULL, no need of modification\\n        if(root == NULL)\\n            return root;\\n        \\n        //root will never have any cousin , hence it will always have value 0\\n        root->val = 0;\\n        \\n        //queue stores current node and parent node\\n        queue<pair<TreeNode*, TreeNode*>>q;\\n        \\n        //parent of root is NULL of course\\n        q.push({root,NULL});\\n        \\n        \\n        while(!q.empty())\\n        {\\n            //Size of the queue\\n            int n = q.size();\\n            \\n            //Sum stores the sum of a particular level\\n            int sum = 0;\\n            \\n            //sum of children of a parent\\n            unordered_map<TreeNode*, int>mp;\\n            \\n            //stores pair of parent and its child of a particular level\\n            vector<pair<TreeNode*,TreeNode*>>level;\\n            \\n            \\n             for(int i = 0; i<n; i++)\\n             {\\n                 //current node\\n                TreeNode* node = q.front().first;\\n                 \\n                 // parent of the current node\\n                 TreeNode* parent = q.front().second;\\n                 q.pop();\\n                 \\n                 //Adding value of the current node to the sum of a level\\n                 sum += node->val;\\n                 \\n                 //parent storing the sum of this childen\\n                 mp[parent] += node->val;\\n                 \\n                 //storing the parent and its child for ease of future modification\\n                 level.push_back({parent, node});\\n                 \\n                 //pushing left child of current node with parent as the current node\\n                 if(node->left)\\n                 {\\n                     q.push({node->left,node});\\n                 }\\n                 \\n                 //pushing right child of current node with parent as the current node\\n                 if(node->right)\\n                 {\\n                     q. push({node->right, node});                    \\n                 }\\n             }\\n        \\n            //one level is completed, now we are modifing the tree\\n            for(auto it: level)\\n            {\\n                //Substracting the sum of childen of a prent from the total sum of a level\\n                int val = sum - mp[it.first];\\n                                \\n                it.second->val = val;           \\n            }            \\n            \\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //Empty tree return NULL, no need of modification\\n        if(root == NULL)\\n            return root;\\n        \\n        //root will never have any cousin , hence it will always have value 0\\n        root->val = 0;\\n        \\n        //queue stores current node and parent node\\n        queue<pair<TreeNode*, TreeNode*>>q;\\n        \\n        //parent of root is NULL of course\\n        q.push({root,NULL});\\n        \\n        \\n        while(!q.empty())\\n        {\\n            //Size of the queue\\n            int n = q.size();\\n            \\n            //Sum stores the sum of a particular level\\n            int sum = 0;\\n            \\n            //sum of children of a parent\\n            unordered_map<TreeNode*, int>mp;\\n            \\n            //stores pair of parent and its child of a particular level\\n            vector<pair<TreeNode*,TreeNode*>>level;\\n            \\n            \\n             for(int i = 0; i<n; i++)\\n             {\\n                 //current node\\n                TreeNode* node = q.front().first;\\n                 \\n                 // parent of the current node\\n                 TreeNode* parent = q.front().second;\\n                 q.pop();\\n                 \\n                 //Adding value of the current node to the sum of a level\\n                 sum += node->val;\\n                 \\n                 //parent storing the sum of this childen\\n                 mp[parent] += node->val;\\n                 \\n                 //storing the parent and its child for ease of future modification\\n                 level.push_back({parent, node});\\n                 \\n                 //pushing left child of current node with parent as the current node\\n                 if(node->left)\\n                 {\\n                     q.push({node->left,node});\\n                 }\\n                 \\n                 //pushing right child of current node with parent as the current node\\n                 if(node->right)\\n                 {\\n                     q. push({node->right, node});                    \\n                 }\\n             }\\n        \\n            //one level is completed, now we are modifing the tree\\n            for(auto it: level)\\n            {\\n                //Substracting the sum of childen of a prent from the total sum of a level\\n                int val = sum - mp[it.first];\\n                                \\n                it.second->val = val;           \\n            }            \\n            \\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571273,
                "title": "bfs-easy-java-solution-beats-90-online-submissions",
                "content": "# Code\\n```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n\\n        List<Integer> level_sum = new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int sum = 0;\\n\\n            while(n-- > 0){\\n                TreeNode res = q.poll();\\n                sum += res.val;\\n\\n                if(res.left != null){\\n                    q.offer(res.left);\\n                }\\n                if(res.right != null){\\n                    q.offer(res.right);\\n                }\\n            }\\n\\n            level_sum.add(sum);\\n        }\\n\\n        int i = 0;\\n        q.offer(root);\\n        root.val = 0;\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            i++;\\n\\n            while(n-- > 0){\\n                TreeNode res = q.poll();\\n                int sum = 0;\\n\\n                if(res.left != null){\\n                    q.add(res.left);\\n                    sum += res.left.val;\\n                }\\n\\n                if(res.right != null){\\n                    q.add(res.right);\\n                    sum += res.right.val;\\n                }\\n                if(res.left != null){\\n                    res.left.val = level_sum.get(i) - sum;\\n                }\\n\\n                if(res.right != null){\\n                    res.right.val = level_sum.get(i) - sum;\\n                }\\n\\n            }\\n        }\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n\\n        List<Integer> level_sum = new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int sum = 0;\\n\\n            while(n-- > 0){\\n                TreeNode res = q.poll();\\n                sum += res.val;\\n\\n                if(res.left != null){\\n                    q.offer(res.left);\\n                }\\n                if(res.right != null){\\n                    q.offer(res.right);\\n                }\\n            }\\n\\n            level_sum.add(sum);\\n        }\\n\\n        int i = 0;\\n        q.offer(root);\\n        root.val = 0;\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            i++;\\n\\n            while(n-- > 0){\\n                TreeNode res = q.poll();\\n                int sum = 0;\\n\\n                if(res.left != null){\\n                    q.add(res.left);\\n                    sum += res.left.val;\\n                }\\n\\n                if(res.right != null){\\n                    q.add(res.right);\\n                    sum += res.right.val;\\n                }\\n                if(res.left != null){\\n                    res.left.val = level_sum.get(i) - sum;\\n                }\\n\\n                if(res.right != null){\\n                    res.right.val = level_sum.get(i) - sum;\\n                }\\n\\n            }\\n        }\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568189,
                "title": "c-bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if (!root)\\n            return root;\\n        deque<pair<TreeNode*, TreeNode*>> deque;\\n        deque.push_back({root, nullptr});\\n        while (!deque.empty()) \\n        {\\n            int totalSum = 0;\\n            for (const auto& [node, _] : deque)\\n                totalSum += node -> val;\\n            int qSize = deque.size();\\n            while (qSize) \\n            {\\n                auto [firstChild, firstChildParent] = deque.front();\\n                deque.pop_front();\\n                --qSize;\\n                if (deque.empty())\\n                {\\n                    int newVal = totalSum - firstChild -> val;\\n                    firstChild -> val = newVal;\\n                    if (firstChild -> left)\\n                        deque.push_back({firstChild -> left, firstChild});\\n                    if (firstChild -> right)\\n                        deque.push_back({firstChild -> right, firstChild});\\n                    continue;\\n                }\\n                auto [secondChild, secondChildParent] = deque.front();\\n                if (firstChild -> left)\\n                    deque.push_back({firstChild -> left, firstChild});\\n                if (firstChild -> right)\\n                    deque.push_back({firstChild -> right, firstChild});\\n                if (firstChildParent == secondChildParent)\\n                {\\n                    deque.pop_front();\\n                    --qSize;\\n                    int newVal = totalSum - (firstChild -> val + secondChild -> val);\\n                    firstChild -> val = newVal;\\n                    secondChild -> val = newVal;\\n                    if (secondChild -> left)\\n                        deque.push_back({secondChild -> left, secondChild});\\n                    if (secondChild -> right)\\n                        deque.push_back({secondChild -> right, secondChild});\\n                }\\n                else\\n                {\\n                    int newVal = totalSum - firstChild -> val;\\n                    firstChild -> val = newVal;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if (!root)\\n            return root;\\n        deque<pair<TreeNode*, TreeNode*>> deque;\\n        deque.push_back({root, nullptr});\\n        while (!deque.empty()) \\n        {\\n            int totalSum = 0;\\n            for (const auto& [node, _] : deque)\\n                totalSum += node -> val;\\n            int qSize = deque.size();\\n            while (qSize) \\n            {\\n                auto [firstChild, firstChildParent] = deque.front();\\n                deque.pop_front();\\n                --qSize;\\n                if (deque.empty())\\n                {\\n                    int newVal = totalSum - firstChild -> val;\\n                    firstChild -> val = newVal;\\n                    if (firstChild -> left)\\n                        deque.push_back({firstChild -> left, firstChild});\\n                    if (firstChild -> right)\\n                        deque.push_back({firstChild -> right, firstChild});\\n                    continue;\\n                }\\n                auto [secondChild, secondChildParent] = deque.front();\\n                if (firstChild -> left)\\n                    deque.push_back({firstChild -> left, firstChild});\\n                if (firstChild -> right)\\n                    deque.push_back({firstChild -> right, firstChild});\\n                if (firstChildParent == secondChildParent)\\n                {\\n                    deque.pop_front();\\n                    --qSize;\\n                    int newVal = totalSum - (firstChild -> val + secondChild -> val);\\n                    firstChild -> val = newVal;\\n                    secondChild -> val = newVal;\\n                    if (secondChild -> left)\\n                        deque.push_back({secondChild -> left, secondChild});\\n                    if (secondChild -> right)\\n                        deque.push_back({secondChild -> right, secondChild});\\n                }\\n                else\\n                {\\n                    int newVal = totalSum - firstChild -> val;\\n                    firstChild -> val = newVal;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556994,
                "title": "c-single-method-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n    public class Solution\\n    {\\n        public TreeNode ReplaceValueInTree(TreeNode root)\\n        {\\n            var wave = new List<TreeNode>();\\n            var nextWave = new List<TreeNode>();\\n\\n            wave.Add(root);\\n\\n            while (wave.Count > 0)\\n            {\\n                var waveSum = 0;\\n\\n                foreach (var node in wave)\\n                {\\n                    if (node != null)\\n                    {\\n                        nextWave.Add(node?.left);\\n                        nextWave.Add(node?.right);\\n                        waveSum += node.val;\\n                    }\\n                }\\n\\n                var couple = 0;\\n\\n                for (int i = 0; i < wave.Count; i++)\\n                {\\n                    if (i % 2 == 0)\\n                    {\\n                        couple = 0;\\n                        if (wave[i] != null) couple += wave[i].val;\\n                        if (i + 1 < wave.Count && wave[i + 1] != null) couple += wave[i + 1].val;\\n                    }\\n                    if (wave[i] != null) wave[i].val = waveSum - couple;\\n                }\\n\\n                wave = nextWave;\\n                nextWave = new List<TreeNode>();\\n            }\\n            return root;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n    public class Solution\\n    {\\n        public TreeNode ReplaceValueInTree(TreeNode root)\\n        {\\n            var wave = new List<TreeNode>();\\n            var nextWave = new List<TreeNode>();\\n\\n            wave.Add(root);\\n\\n            while (wave.Count > 0)\\n            {\\n                var waveSum = 0;\\n\\n                foreach (var node in wave)\\n                {\\n                    if (node != null)\\n                    {\\n                        nextWave.Add(node?.left);\\n                        nextWave.Add(node?.right);\\n                        waveSum += node.val;\\n                    }\\n                }\\n\\n                var couple = 0;\\n\\n                for (int i = 0; i < wave.Count; i++)\\n                {\\n                    if (i % 2 == 0)\\n                    {\\n                        couple = 0;\\n                        if (wave[i] != null) couple += wave[i].val;\\n                        if (i + 1 < wave.Count && wave[i + 1] != null) couple += wave[i + 1].val;\\n                    }\\n                    if (wave[i] != null) wave[i].val = waveSum - couple;\\n                }\\n\\n                wave = nextWave;\\n                nextWave = new List<TreeNode>();\\n            }\\n            return root;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2040655,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            },
            {
                "id": 2010958,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            },
            {
                "id": 1931021,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            },
            {
                "id": 1930458,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            },
            {
                "id": 1864489,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            },
            {
                "id": 1864324,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            }
        ]
    }
]