[
    {
        "title": "Interleaving String",
        "question_content": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\nAn interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:\n\n\ts = s1 + s2 + ... + sn\n\tt = t1 + t2 + ... + tm\n\t|n - m| <= 1\n\tThe interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\n\nNote: a + b is the concatenation of strings a and b.\n&nbsp;\nExample 1:\n\nInput: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\nOutput: true\nExplanation: One way to obtain s3 is:\nSplit s1 into s1 = \"aa\" + \"bc\" + \"c\", and s2 into s2 = \"dbbc\" + \"a\".\nInterleaving the two splits, we get \"aa\" + \"dbbc\" + \"bc\" + \"a\" + \"c\" = \"aadbbcbcac\".\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n\nExample 2:\n\nInput: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\nOutput: false\nExplanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.\n\nExample 3:\n\nInput: s1 = \"\", s2 = \"\", s3 = \"\"\nOutput: true\n\n&nbsp;\nConstraints:\n\n\t0 <= s1.length, s2.length <= 100\n\t0 <= s3.length <= 200\n\ts1, s2, and s3 consist of lowercase English letters.\n\n&nbsp;\nFollow up: Could you solve it using only O(s2.length) additional memory space?",
        "solutions": [
            {
                "id": 31879,
                "title": "my-dp-solution-in-c",
                "content": " \\n\\n     bool isInterleave(string s1, string s2, string s3) {\\n        \\n        if(s3.length() != s1.length() + s2.length())\\n            return false;\\n        \\n        bool table[s1.length()+1][s2.length()+1];\\n        \\n        for(int i=0; i<s1.length()+1; i++)\\n            for(int j=0; j< s2.length()+1; j++){\\n                if(i==0 && j==0)\\n                    table[i][j] = true;\\n                else if(i == 0)\\n                    table[i][j] = ( table[i][j-1] && s2[j-1] == s3[i+j-1]);\\n                else if(j == 0)\\n                    table[i][j] = ( table[i-1][j] && s1[i-1] == s3[i+j-1]);\\n                else\\n                    table[i][j] = (table[i-1][j] && s1[i-1] == s3[i+j-1] ) || (table[i][j-1] && s2[j-1] == s3[i+j-1] );\\n            }\\n            \\n        return table[s1.length()][s2.length()];\\n    }\\n    \\n\\n\\nHere is some explanation:\\n\\nDP table represents if s3 is interleaving at (i+j)th position when s1 is at ith position, and s2 is at jth position. 0th position means empty string.\\n\\nSo if both s1 and s2 is currently empty, s3 is empty too, and it is considered interleaving. If only s1 is empty, then if previous s2 position is interleaving and current s2 position char is equal to s3 current position char, it is considered interleaving. similar idea applies to when s2 is empty. when both s1 and s2 is not empty, then if we arrive i, j from i-1, j, then if i-1,j is already interleaving and i and current s3 position equal, it s interleaving. If we arrive i,j from i, j-1, then if i, j-1 is already interleaving and j and current s3 position equal. it is interleaving.",
                "solutionTags": [],
                "code": " \\n\\n     bool isInterleave(string s1, string s2, string s3) {\\n        \\n        if(s3.length() != s1.length() + s2.length())\\n            return false;\\n        \\n        bool table[s1.length()+1][s2.length()+1];\\n        \\n        for(int i=0; i<s1.length()+1; i++)\\n            for(int j=0; j< s2.length()+1; j++){\\n                if(i==0 && j==0)\\n                    table[i][j] = true;\\n                else if(i == 0)\\n                    table[i][j] = ( table[i][j-1] && s2[j-1] == s3[i+j-1]);\\n                else if(j == 0)\\n                    table[i][j] = ( table[i-1][j] && s1[i-1] == s3[i+j-1]);\\n                else\\n                    table[i][j] = (table[i-1][j] && s1[i-1] == s3[i+j-1] ) || (table[i][j-1] && s2[j-1] == s3[i+j-1] );\\n            }\\n            \\n        return table[s1.length()][s2.length()];\\n    }\\n    \\n\\n\\nHere is some explanation:\\n\\nDP table represents if s3 is interleaving at (i+j)th position when s1 is at ith position, and s2 is at jth position. 0th position means empty string.\\n\\nSo if both s1 and s2 is currently empty, s3 is empty too, and it is considered interleaving. If only s1 is empty, then if previous s2 position is interleaving and current s2 position char is equal to s3 current position char, it is considered interleaving. similar idea applies to when s2 is empty. when both s1 and s2 is not empty, then if we arrive i, j from i-1, j, then if i-1,j is already interleaving and i and current s3 position equal, it s interleaving. If we arrive i,j from i, j-1, then if i, j-1 is already interleaving and j and current s3 position equal. it is interleaving.",
                "codeTag": "Unknown"
            },
            {
                "id": 31948,
                "title": "8ms-c-solution-using-bfs-with-explanation",
                "content": "If we expand the two strings s1 and s2 into a chessboard, then this problem can be transferred into a path seeking problem from the top-left corner to the bottom-right corner. The key is, each cell (y, x) in the board corresponds to an interval between y-th character in s1 and x-th character in s2. And adjacent cells are connected with like a grid. A BFS can then be efficiently performed to find the path.\\n\\nBetter to illustrate with an example here:\\n\\nSay s1 = \"aab\" and s2 = \"abc\". s3 = \"aaabcb\". Then the board looks like\\n\\n    o--a--o--b--o--c--o\\n    |     |     |     |\\n    a     a     a     a\\n    |     |     |     |\\n    o--a--o--b--o--c--o\\n    |     |     |     |\\n    a     a     a     a\\n    |     |     |     |\\n    o--a--o--b--o--c--o\\n    |     |     |     |\\n    b     b     b     b\\n    |     |     |     |\\n    o--a--o--b--o--c--o\\n\\nEach \"o\" is a cell in the board. We start from the top-left corner, and try to move right or down. If the next char in s3 matches the edge connecting the next cell, then we're able to move. When we hit the bottom-right corner, this means s3 can be represented by interleaving s1 and s2. One possible path for this example is indicated with \"x\"es below:\\n\\n    x--a--x--b--o--c--o\\n    |     |     |     |\\n    a     a     a     a\\n    |     |     |     |\\n    o--a--x--b--o--c--o\\n    |     |     |     |\\n    a     a     a     a\\n    |     |     |     |\\n    o--a--x--b--x--c--x\\n    |     |     |     |\\n    b     b     b     b\\n    |     |     |     |\\n    o--a--o--b--o--c--x\\n\\nNote if we concatenate the chars on the edges we went along, it's exactly s3. And we went through all the chars in s1 and s2, in order, exactly once.\\n\\nTherefore if we view this board as a graph, such path finding problem is trivial with BFS. I use an `unordered_map` to store the visited nodes, which makes the code look a bit complicated. But a `vector` should be enough to do the job. \\n\\nAlthough the worse case timeis also O(mn), typically it doesn't require us to go through every node to find a path. Therefore it's faster than regular DP than average.\\n\\n    struct MyPoint {\\n        int y, x; \\n        bool operator==(const MyPoint &p) const {\\n            return p.y == y && p.x == x;\\n        }\\n    };\\n    namespace std {\\n        template <>\\n        struct hash<MyPoint> {\\n            size_t operator () (const MyPoint &f) const {\\n                return (std::hash<int>()(f.x) << 1) ^ std::hash<int>()(f.y);\\n            }\\n        };\\n    }\\n    \\n    class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            if (s1.size() + s2.size() != s3.size()) return false;\\n\\n            queue<MyPoint> q;\\n            unordered_set<MyPoint> visited;\\n            bool isSuccessful = false;\\n            int i = 0;\\n    \\n            q.push(MyPoint { 0, 0 });\\n            q.push(MyPoint { -1, -1 });\\n            while (!(1 == q.size() && -1 == q.front().x)) {\\n                auto p = q.front();\\n                q.pop();\\n                if (p.y == s1.size() && p.x == s2.size()) {\\n                    return true;\\n                }\\n                if (-1 == p.y) {\\n                    q.push(p);\\n                    i++;\\n                    continue;\\n                }\\n                if (visited.find(p) != visited.end()) { continue; }\\n                visited.insert(p);\\n    \\n                if (p.y < s1.size()) { // down\\n                    if (s1[p.y] == s3[i]) { q.push(MyPoint { p.y + 1, p.x }); }\\n                }\\n                if (p.x < s2.size()) { // right \\n                    if (s2[p.x] == s3[i]) { q.push(MyPoint { p.y, p.x + 1 }); }\\n                }\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            if (s1.size() + s2.size() != s3.size()) return false;\\n\\n            queue<MyPoint> q;\\n            unordered_set<MyPoint> visited;\\n            bool isSuccessful = false;\\n            int i = 0;\\n    \\n            q.push(MyPoint { 0, 0 }",
                "codeTag": "Java"
            },
            {
                "id": 31885,
                "title": "python-dp-solutions-o-m-n-o-n-space-bfs-dfs",
                "content": "    \\n    # O(m*n) space\\n    def isInterleave1(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        dp = [[True for _ in xrange(c+1)] for _ in xrange(r+1)]\\n        for i in xrange(1, r+1):\\n            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\\n        for j in xrange(1, c+1):\\n            dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\\n        for i in xrange(1, r+1):\\n            for j in xrange(1, c+1):\\n                dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i-1+j]) or \\\\\\n                   (dp[i][j-1] and s2[j-1] == s3[i-1+j])\\n        return dp[-1][-1]\\n\\n    # O(2*n) space\\n    def isInterleave2(self, s1, s2, s3):\\n        l1, l2, l3 = len(s1)+1, len(s2)+1, len(s3)+1\\n        if l1+l2 != l3+1:\\n            return False\\n        pre = [True for _ in xrange(l2)]\\n        for j in xrange(1, l2):\\n            pre[j] = pre[j-1] and s2[j-1] == s3[j-1]\\n        for i in xrange(1, l1):\\n            cur = [pre[0] and s1[i-1] == s3[i-1]] * l2\\n            for j in xrange(1, l2):\\n                cur[j] = (cur[j-1] and s2[j-1] == s3[i+j-1]) or \\\\\\n                         (pre[j] and s1[i-1] == s3[i+j-1])\\n            pre = cur[:]\\n        return pre[-1]\\n    \\n    # O(n) space\\n    def isInterleave3(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        dp = [True for _ in xrange(c+1)] \\n        for j in xrange(1, c+1):\\n            dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\\n        for i in xrange(1, r+1):\\n            dp[0] = (dp[0] and s1[i-1] == s3[i-1])\\n            for j in xrange(1, c+1):\\n                dp[j] = (dp[j] and s1[i-1] == s3[i-1+j]) or (dp[j-1] and s2[j-1] == s3[i-1+j])\\n        return dp[-1]\\n        \\n    # DFS \\n    def isInterleave4(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        stack, visited = [(0, 0)], set((0, 0))\\n        while stack:\\n            x, y = stack.pop()\\n            if x+y == l:\\n                return True\\n            if x+1 <= r and s1[x] == s3[x+y] and (x+1, y) not in visited:\\n                stack.append((x+1, y)); visited.add((x+1, y))\\n            if y+1 <= c and s2[y] == s3[x+y] and (x, y+1) not in visited:\\n                stack.append((x, y+1)); visited.add((x, y+1))\\n        return False\\n                \\n    # BFS \\n    def isInterleave(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        queue, visited = [(0, 0)], set((0, 0))\\n        while queue:\\n            x, y = queue.pop(0)\\n            if x+y == l:\\n                return True\\n            if x+1 <= r and s1[x] == s3[x+y] and (x+1, y) not in visited:\\n                queue.append((x+1, y)); visited.add((x+1, y))\\n            if y+1 <= c and s2[y] == s3[x+y] and (x, y+1) not in visited:\\n                queue.append((x, y+1)); visited.add((x, y+1))\\n        return False",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    \\n    # O(m*n) space\\n    def isInterleave1(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        dp = [[True for _ in xrange(c+1)] for _ in xrange(r+1)]\\n        for i in xrange(1, r+1):\\n            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\\n        for j in xrange(1, c+1):\\n            dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\\n        for i in xrange(1, r+1):\\n            for j in xrange(1, c+1):\\n                dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i-1+j]) or \\\\\\n                   (dp[i][j-1] and s2[j-1] == s3[i-1+j])\\n        return dp[-1][-1]\\n\\n    # O(2*n) space\\n    def isInterleave2(self, s1, s2, s3):\\n        l1, l2, l3 = len(s1)+1, len(s2)+1, len(s3)+1\\n        if l1+l2 != l3+1:\\n            return False\\n        pre = [True for _ in xrange(l2)]\\n        for j in xrange(1, l2):\\n            pre[j] = pre[j-1] and s2[j-1] == s3[j-1]\\n        for i in xrange(1, l1):\\n            cur = [pre[0] and s1[i-1] == s3[i-1]] * l2\\n            for j in xrange(1, l2):\\n                cur[j] = (cur[j-1] and s2[j-1] == s3[i+j-1]) or \\\\\\n                         (pre[j] and s1[i-1] == s3[i+j-1])\\n            pre = cur[:]\\n        return pre[-1]\\n    \\n    # O(n) space\\n    def isInterleave3(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        dp = [True for _ in xrange(c+1)] \\n        for j in xrange(1, c+1):\\n            dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\\n        for i in xrange(1, r+1):\\n            dp[0] = (dp[0] and s1[i-1] == s3[i-1])\\n            for j in xrange(1, c+1):\\n                dp[j] = (dp[j] and s1[i-1] == s3[i-1+j]) or (dp[j-1] and s2[j-1] == s3[i-1+j])\\n        return dp[-1]\\n        \\n    # DFS \\n    def isInterleave4(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        stack, visited = [(0, 0)], set((0, 0))\\n        while stack:\\n            x, y = stack.pop()\\n            if x+y == l:\\n                return True\\n            if x+1 <= r and s1[x] == s3[x+y] and (x+1, y) not in visited:\\n                stack.append((x+1, y)); visited.add((x+1, y))\\n            if y+1 <= c and s2[y] == s3[x+y] and (x, y+1) not in visited:\\n                stack.append((x, y+1)); visited.add((x, y+1))\\n        return False\\n                \\n    # BFS \\n    def isInterleave(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        queue, visited = [(0, 0)], set((0, 0))\\n        while queue:\\n            x, y = queue.pop(0)\\n            if x+y == l:\\n                return True\\n            if x+1 <= r and s1[x] == s3[x+y] and (x+1, y) not in visited:\\n                queue.append((x+1, y)); visited.add((x+1, y))\\n            if y+1 <= c and s2[y] == s3[x+y] and (x, y+1) not in visited:\\n                queue.append((x, y+1)); visited.add((x, y+1))\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 31888,
                "title": "1ms-tiny-dfs-beats-94-57",
                "content": "To solve this problem, let's look at if `s1[0 ~ i]`  `s2[0 ~ j]` can be interleaved to `s3[0 ~ k]`.\\n\\n- Start from indices`0, 0, 0` and compare `s1[i] == s3[k]` or `s2[j] == s3[k]`\\n- Return valid only if either `i` or `j` match `k` and the remaining is also valid\\n- Caching is the key to performance. This is very similar to top down dp\\n- Only need to cache `invalid[i][j]` since most of the case `s1[0 ~ i]` and `s2[0 ~ j]` does not form `s3[0 ~ k]`. Also tested caching `valid[i][j]` the run time is also `1ms`\\n- Many guys use `substring` but it's duplicate code since `substring` itself is checking char by char. We are already doing so\\n\\n\\nHope it helps!\\n\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        char[] c1 = s1.toCharArray(), c2 = s2.toCharArray(), c3 = s3.toCharArray();\\n    \\tint m = s1.length(), n = s2.length();\\n    \\tif(m + n != s3.length()) return false;\\n    \\treturn dfs(c1, c2, c3, 0, 0, 0, new boolean[m + 1][n + 1]);\\n    }\\n    \\n    public boolean dfs(char[] c1, char[] c2, char[] c3, int i, int j, int k, boolean[][] invalid) {\\n    \\tif(invalid[i][j]) return false;\\n    \\tif(k == c3.length) return true;\\n    \\tboolean valid = \\n    \\t    i < c1.length && c1[i] == c3[k] && dfs(c1, c2, c3, i + 1, j, k + 1, invalid) || \\n            j < c2.length && c2[j] == c3[k] && dfs(c1, c2, c3, i, j + 1, k + 1, invalid);\\n    \\tif(!valid) invalid[i][j] = true;\\n        return valid;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "To solve this problem, let's look at if `s1[0 ~ i]`  `s2[0 ~ j]` can be interleaved to `s3[0 ~ k]`.\\n\\n- Start from indices`0, 0, 0` and compare `s1[i] == s3[k]` or `s2[j] == s3[k]`\\n- Return valid only if either `i` or `j` match `k` and the remaining is also valid\\n- Caching is the key to performance. This is very similar to top down dp\\n- Only need to cache `invalid[i][j]` since most of the case `s1[0 ~ i]` and `s2[0 ~ j]` does not form `s3[0 ~ k]`. Also tested caching `valid[i][j]` the run time is also `1ms`\\n- Many guys use `substring` but it's duplicate code since `substring` itself is checking char by char. We are already doing so\\n\\n\\nHope it helps!\\n\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        char[] c1 = s1.toCharArray(), c2 = s2.toCharArray(), c3 = s3.toCharArray();\\n    \\tint m = s1.length(), n = s2.length();\\n    \\tif(m + n != s3.length()) return false;\\n    \\treturn dfs(c1, c2, c3, 0, 0, 0, new boolean[m + 1][n + 1]);\\n    }\\n    \\n    public boolean dfs(char[] c1, char[] c2, char[] c3, int i, int j, int k, boolean[][] invalid) {\\n    \\tif(invalid[i][j]) return false;\\n    \\tif(k == c3.length) return true;\\n    \\tboolean valid = \\n    \\t    i < c1.length && c1[i] == c3[k] && dfs(c1, c2, c3, i + 1, j, k + 1, invalid) || \\n            j < c2.length && c2[j] == c3[k] && dfs(c1, c2, c3, i, j + 1, k + 1, invalid);\\n    \\tif(!valid) invalid[i][j] = true;\\n        return valid;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2249509,
                "title": "python-simple-solution-w-explanation-recursion-dp",
                "content": "Given three strings `s1`, `s2` and `s3`, we need to check if `s3` can be formed by an interleaving of `s1` and `s2`.\\n\\nAn **interleaving** of two strings, `s1` and `s2`, means that `s1` is divided into `x` and `s2` is divided into `y` contiguous substrings, respectively. Then those substrings are concatenated without changing the order of their occurrence in `s1` and `s2`.\\nNote that the condition `|x - y| <=1` always holds true.\\n<details>\\n<summary><strong>Proof:</strong></summary>\\n<br/>\\nLet\\'s say <code>s1 = \"abcde\"</code> and <code>s2 = \"fgh\"</code>. We divide <code>s1</code> into four parts and <code>s2</code> into two parts.\\nSo, <code>x - y = 2</code>.\\n<br/>\\n<code>s1 = \"ab\" + \"c\" + \"d\" + \"e\" and s2 = \"f\" + \"gh\"</code>.\\n<br/>\\n<code>s3 = \"ab\" + \"f\" + \"c\" + \"gh\" + \"d\" + \"e\"</code>.\\n<br/>\\nThe above can rewritten as <code>s3 = \"ab\" + \"f\" + \"c\" + \"gh\" + \"de\"</code>, which is basically\\ndividing <code>s1</code> into three parts and <code>s2</code> into two parts. And hence, the condition <code>|x - y| <=1</code> holds true.\\n\\nThere are stricter proofs, but I tried to provide an intuitive one.\\n</details>\\n\\n___\\n___\\n\\u274C **Solution I: Recursion [TLE]**\\n\\nWe don\\'t know the size of each substring or the number of substrings beforehand. So, we can take all possible substrings of `s1` and `s2` and check if `s3` can be formed by interleaving them. At each step, we have two options: choose a character from `s1` or `s2`. Let\\'s call our recursive function `dfs(i, j)`. Then the two choices can be represented as:\\n\\n1. `dfs(i + 1, j)`: Choose a character at `i`th index from `s1`\\n2. `dfs(i, j + 1)`: Choose a character at `j`th index from `s2`\\n\\nActually, we can make this choice more smartly. Instead of considering all possibilities, we can make either/both choice(s) only when it matches the character at the `i + j`th index of `s3`.\\n\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n\\n        def dfs(i, j):\\n            if i == len(s1) and j == len(s2):\\n                return True\\n            choose_s1, choose_s2 = False, False\\n            if i < len(s1) and s1[i] == s3[i + j]:\\n                choose_s1 = dfs(i + 1, j)\\n            if j < len(s2) and s2[j] == s3[i + j]:\\n                choose_s2 = dfs(i, j + 1)\\n\\n            return choose_s1 or choose_s2\\n\\n        return dfs(0, 0)\\n```\\n\\nWhy have I named the inside function as `dfs`? Because if we trace our actions, we can observe that it forms a binary tree. **Don\\'t worry** if you are not familiar with this term. The following visualization will help you to understand what I mean.\\n\\n```text\\n                                        \\u250F\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n                  \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 0, 0 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E\\n                  \\u2502                     \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B                      \\u2502\\n              \\u250F\\u2501\\u2501\\u2501\\u2537\\u2501\\u2501\\u2513                                             \\u250F\\u2501\\u2501\\u2537\\u2501\\u2501\\u2501\\u2513     \\n      \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 1, 0 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E                         \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 0, 1 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E                 \\n      \\u2502       \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B         \\u2502                         \\u2502         \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B         \\u2502 \\n  \\u250F\\u2501\\u2501\\u2501\\u2537\\u2501\\u2501\\u2513                  \\u250F\\u2501\\u2501\\u2537\\u2501\\u2501\\u2501\\u2513                 \\u250F\\u2501\\u2501\\u2501\\u2537\\u2501\\u2501\\u2513                    \\u250F\\u2501\\u2501\\u2537\\u2501\\u2501\\u2501\\u2513  \\n  \\u2503 2, 0 \\u2503                  \\u2503 1, 1 \\u2503                 \\u2503 1, 1 \\u2503                    \\u2503 0, 2 \\u2503 \\n  \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B                  \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B                 \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B                    \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B   \\n     .                         .                        .                           .\\n     .                         .                        .                           .\\n     .                         .                        .                           .\\n\\n```\\n\\nIn dfs, we traverse all the paths one by one. So, here our paths will be:\\n\\n1. (0, 0) -> (1, 0) -> (2, 0) -> ...\\n2. (0, 0) -> (1, 0) -> (1, 1) -> ...\\n3. (0, 0) -> (0, 1) -> (1, 1) -> ...\\n4. (0, 0) -> (0, 1) -> (0, 2) -> ...\\n.\\n.\\n.\\n\\n- **Time Complexity:** <code>O(2<sup>m + n</sup>)</code>\\n  > At each step, we have two choices, so 2 * 2 * 2 ... (m + n) times.\\n- **Space Complexity:** `O(m + n)`\\n  > Recursion stack space.\\n\\n___\\n\\u2705 **Solution II: Dynamic Programming - Memoization [Accepted]**\\n\\nWe are doing a lot of repetitive work in the above recursive solution. How?\\nHave a look at the above example. The subtree with the head `[1, 1]` is repeated twice. Instead of computing it again, we store the result of that state and directly use it.\\nWe can use the decorator `@cache` in Python to achieve this.\\n\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        @cache\\n        def dfs(i, j):\\n            if i == len(s1) and j == len(s2):\\n                return True\\n            choose_s1, choose_s2 = False, False\\n            if i < len(s1) and s1[i] == s3[i + j]:\\n                choose_s1 = dfs(i + 1, j)\\n            if j < len(s2) and s2[j] == s3[i + j]:\\n                choose_s2 = dfs(i, j + 1)\\n\\n            return choose_s1 or choose_s2\\n\\n        return dfs(0, 0)\\n```\\n\\n- **Time Complexity:** `O(m * n)`\\n- **Space Complexity:** `O(m * n)`\\n\\n___\\n\\u2705 **Solution III(a): Dynamic Programming - Tabulation [Accepted]**\\n\\nRecursion is generally slower than its iterative counterpart. So, we can further optimize the above solution by using tabulation. Coming up with this solution is a bit difficult, and it requires practice. Try to find similarities with the memoization approach. The value `dp[i][j]` gives the information if we can form `s3[0...(i+j-1)]` from interleaving `s1[0...(i-1)]` and `s2[0...(j-1)]`. The first column represents interleving of `s1` and an empty string, and similarly, the first row represents interleaving of `s2` and and an empty string.\\n\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3):\\n            return False\\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for i in range(1, m + 1):\\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\\n        for j in range(1, n + 1):\\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                choose_s1, choose_s2 = False, False\\n                if s1[i - 1] == s3[i + j - 1]:\\n                    choose_s1 = dp[i - 1][j]\\n                if s2[j - 1] == s3[i + j - 1]:\\n                    choose_s2 = dp[i][j - 1]\\n                dp[i][j] = choose_s1 or choose_s2\\n\\n        return dp[m][n]\\n\\n```\\n\\n- **Time Complexity:** `O(m * n)`\\n- **Space Complexity:** `O(m * n)`\\n\\n___\\n\\u2705 **Solution III(b): Dynamic Programming - Tabulation (Space Optimized) [Accepted]**\\n\\nNotice that we only require the information from the cells `dp[i - 1][j]` and `dp[i][j - 1]`, i.e. the cell above the current row and the cell to the left of the current column. So, no need to use a matrix. The code can be shortened, but for the sake of understandability, I decided to leave it as it is.\\n\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3):\\n            return False\\n        if n > m:\\n            m, n = n, m\\n            s1, s2 = s2, s1\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        for j in range(1, n + 1):\\n            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\\n        for i in range(1, m + 1):\\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\\n            for j in range(1, n + 1):\\n                choose_s1, choose_s2 = False, False\\n                if s1[i - 1] == s3[i + j - 1]:\\n                    choose_s1 = dp[j]\\n                if s2[j - 1] == s3[i + j - 1]:\\n                    choose_s2 = dp[j - 1]\\n                dp[j] = choose_s1 or choose_s2\\n\\n        return dp[-1]\\n```\\n\\n- **Time Complexity:** `O(m * n)`\\n- **Space Complexity:** `O(min(m, n))`\\n\\n___\\n___\\nIf you like the solution, please **upvote**! \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n\\n        def dfs(i, j):\\n            if i == len(s1) and j == len(s2):\\n                return True\\n            choose_s1, choose_s2 = False, False\\n            if i < len(s1) and s1[i] == s3[i + j]:\\n                choose_s1 = dfs(i + 1, j)\\n            if j < len(s2) and s2[j] == s3[i + j]:\\n                choose_s2 = dfs(i, j + 1)\\n\\n            return choose_s1 or choose_s2\\n\\n        return dfs(0, 0)\\n```\n```text\\n                                        \\u250F\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n                  \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 0, 0 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E\\n                  \\u2502                     \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B                      \\u2502\\n              \\u250F\\u2501\\u2501\\u2501\\u2537\\u2501\\u2501\\u2513                                             \\u250F\\u2501\\u2501\\u2537\\u2501\\u2501\\u2501\\u2513     \\n      \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 1, 0 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E                         \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 0, 1 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E                 \\n      \\u2502       \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B         \\u2502                         \\u2502         \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B         \\u2502 \\n  \\u250F\\u2501\\u2501\\u2501\\u2537\\u2501\\u2501\\u2513                  \\u250F\\u2501\\u2501\\u2537\\u2501\\u2501\\u2501\\u2513                 \\u250F\\u2501\\u2501\\u2501\\u2537\\u2501\\u2501\\u2513                    \\u250F\\u2501\\u2501\\u2537\\u2501\\u2501\\u2501\\u2513  \\n  \\u2503 2, 0 \\u2503                  \\u2503 1, 1 \\u2503                 \\u2503 1, 1 \\u2503                    \\u2503 0, 2 \\u2503 \\n  \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B                  \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B                 \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B                    \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B   \\n     .                         .                        .                           .\\n     .                         .                        .                           .\\n     .                         .                        .                           .\\n\\n```\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        @cache\\n        def dfs(i, j):\\n            if i == len(s1) and j == len(s2):\\n                return True\\n            choose_s1, choose_s2 = False, False\\n            if i < len(s1) and s1[i] == s3[i + j]:\\n                choose_s1 = dfs(i + 1, j)\\n            if j < len(s2) and s2[j] == s3[i + j]:\\n                choose_s2 = dfs(i, j + 1)\\n\\n            return choose_s1 or choose_s2\\n\\n        return dfs(0, 0)\\n```\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3):\\n            return False\\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for i in range(1, m + 1):\\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\\n        for j in range(1, n + 1):\\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                choose_s1, choose_s2 = False, False\\n                if s1[i - 1] == s3[i + j - 1]:\\n                    choose_s1 = dp[i - 1][j]\\n                if s2[j - 1] == s3[i + j - 1]:\\n                    choose_s2 = dp[i][j - 1]\\n                dp[i][j] = choose_s1 or choose_s2\\n\\n        return dp[m][n]\\n\\n```\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3):\\n            return False\\n        if n > m:\\n            m, n = n, m\\n            s1, s2 = s2, s1\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        for j in range(1, n + 1):\\n            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\\n        for i in range(1, m + 1):\\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\\n            for j in range(1, n + 1):\\n                choose_s1, choose_s2 = False, False\\n                if s1[i - 1] == s3[i + j - 1]:\\n                    choose_s1 = dp[j]\\n                if s2[j - 1] == s3[i + j - 1]:\\n                    choose_s2 = dp[j - 1]\\n                dp[j] = choose_s1 or choose_s2\\n\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956393,
                "title": "99-78-2-approaches-dp-recursion",
                "content": "# Interview Guide: \"Interleaving String\" Problem\\n\\n## Problem Understanding\\n\\nIn the \"Interleaving String\" problem, you are given three strings: `s1`, `s2`, and `s3`. Your task is to determine whether `s3` can be formed by interleaving `s1` and `s2`. For example, if `s1 = \"aabcc\"` and `s2 = \"dbbca\"`, then `s3 = \"aadbbcbcac\"` should return `true`, but `s3 = \"aadbbbaccc\"` should return `false`.\\n\\n## Key Points to Consider\\n\\n### 1. Understand the Constraints\\n\\nBefore diving into the solution, make sure you understand the problem\\'s constraints. The lengths of the strings will not be more than 100 for `s1` and `s2`, and not more than 200 for `s3`. This can help you gauge the time complexity you should aim for.\\n\\n### 2. Multiple Approaches\\n\\nThere are multiple ways to solve this problem, including:\\n\\n  - 2D Dynamic Programming\\n  - 1D Dynamic Programming\\n  - Recursion with Memoization\\n\\nEach method has its own time and space complexity, so choose based on the problem\\'s constraints.\\n\\n### 3. Space Optimization\\n\\nWhile 2D Dynamic Programming is the most intuitive approach, you can reduce the space complexity to \\\\(O(\\\\min(m, n))\\\\) by employing 1D Dynamic Programming. In an interview setting, discussing this optimization can impress your interviewer.\\n\\n### 4. Early Exit\\n\\nIf the sum of the lengths of `s1` and `s2` does not match the length of `s3`, you can immediately return `false`. This can save computation time and demonstrate that you\\'re mindful of edge cases.\\n\\n### 5. Explain Your Thought Process\\n\\nAlways explain your thought process and why you chose a particular approach. Discuss the trade-offs you\\'re making in terms of time and space complexity.\\n\\n## Conclusion\\n\\nThe \"Interleaving String\" problem is an excellent example of a problem that can be tackled through Dynamic Programming or Recursion. Knowing the trade-offs between different approaches and optimizing for space can give you an edge in interviews. By taking the time to understand the problem, choosing the appropriate data structures, and optimizing your approach, you\\'ll not only solve the problem but also demonstrate a well-rounded skill set.\\n\\n---\\n\\n# Live Coding & Explenation: 1D Dynamic Programming\\nhttps://youtu.be/iv_cTwwsRxs\\n\\n---\\n\\n# Approach: 2D Dynamic Programming \\n\\nTo solve the \"Interleaving String\" problem using 2D Dynamic Programming, we utilize a 2D array `dp[i][j]` to represent whether the substring `s3[:i+j]` can be formed by interleaving `s1[:i]` and `s2[:j]`.\\n\\n## Key Data Structures:\\n- **dp**: A 2D list to store the results of subproblems.\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - Calculate lengths of `s1`, `s2`, and `s3`.\\n   - If the sum of lengths of `s1` and `s2` is not equal to the length of `s3`, return false.\\n   - Initialize the `dp` array with dimensions `(m+1) x (n+1)`, setting `dp[0][0] = True`.\\n  \\n2. **Base Cases**:\\n   - Fill in the first row of `dp` array, considering only the characters from `s1`.\\n   - Fill in the first column of `dp` array, considering only the characters from `s2`.\\n   \\n3. **DP Loop**:\\n   - Loop through each possible `(i, j)` combination, starting from `(1, 1)`.\\n   - Update `dp[i][j]` based on the transition `dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])`.\\n\\n4. **Wrap-up**:\\n   - Return the value stored in `dp[m][n]`, which indicates whether `s3` can be formed by interleaving `s1` and `s2`.\\n\\n# Complexity:\\n\\n**Time Complexity:** \\n- The solution iterates over each possible $$ (i, j) $$ combination, leading to a time complexity of $$ O(m \\\\times n) $$.\\n\\n**Space Complexity:** \\n- The space complexity is $$ O(m \\\\times n) $$ due to the 2D $$ dp $$ array.\\n\\n---\\n\\n# Approach: 1D Dynamic Programming \\n\\nThe optimization from 2D to 1D DP is based on the observation that the state of `dp[i][j]` in the 2D DP array depends only on `dp[i-1][j]` and `dp[i][j-1]`. Therefore, while iterating through the strings, the current state only depends on the states in the previous row of the 2D DP array, which means we can optimize our space complexity by just keeping track of one row (1D DP).\\n\\n## Key Data Structures:\\n\\n- **dp**: A 1D list that stores whether the substring `s3[:i+j]` can be formed by interleaving `s1[:i]` and `s2[:j]`. Initially, all values are set to `False` except `dp[0]`, which is set to `True`.\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - First, calculate the lengths of `s1`, `s2`, and `s3`.\\n   - Check if the sum of the lengths of `s1` and `s2` equals the length of `s3`. If it doesn\\'t, return `False` as `s3` cannot be formed by interleaving `s1` and `s2`.\\n\\n2. **Optimization Check**:\\n   - If `m < n`, swap `s1` and `s2`. This is to ensure that `s1` is not longer than `s2`, which helps in optimizing the space complexity to `O(min(m, n))`.\\n\\n3. **Base Cases**:\\n   - Initialize a 1D array `dp` of length `n+1` with `False`.\\n   - Set `dp[0] = True` because an empty `s1` and `s2` can interleave to form an empty `s3`.\\n\\n4. **Single-Row DP Transition**:\\n   - Iterate through `s1` and `s2` to update the `dp` array.\\n   - For each character in `s1`, iterate through `s2` and update the `dp` array based on the transition rule: `dp[j] = (dp[j] and s1[i] == s3[i+j]) or (dp[j-1] and s2[j] == s3[i+j])`.\\n   - The transition rule checks if the current `s3[i+j]` can be matched by either `s1[i]` or `s2[j]`, relying solely on the previous values in the `dp` array.\\n\\n5. **Wrap-up**:\\n   - The final value in the `dp` array will indicate whether the entire `s3` can be formed by interleaving `s1` and `s2`.\\n   - Return `dp[n]`.\\n\\n\\n\\n# Complexity:\\n\\nThe primary advantage of this 1D DP approach is its space efficiency. While it maintains the same time complexity as the 2D DP approach $$O(m \\\\times n)$$, the space complexity is optimized to $$O(\\\\min(m, n))$$.\\n\\n**Time Complexity:** \\n- The solution iterates over each character of `s1` and `s2` once, leading to a complexity of $$O(m \\\\times n)$$.\\n\\n**Space Complexity:** \\n- The space complexity is optimized to $$O(\\\\min(m,n))$$ as we\\'re only using a single 1D array instead of a 2D matrix.\\n\\n---\\n\\n# Approach: Recursion with Memoization\\n\\nIn this approach, we recursively check whether the substring `s3[k:]` can be formed by interleaving `s1[i:]` and `s2[j:]`. We store the results of these sub-problems in a dictionary named `memo`.\\n\\n## Key Data Structures:\\n- **memo**: A dictionary to store the results of subproblems.\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - Calculate lengths of `s1`, `s2`, and `s3`.\\n   - If the sum of lengths of `s1` and `s2` is not equal to the length of `s3`, return false.\\n   \\n2. **Recursive Function**:\\n   - Define a recursive function `helper` which takes indices `i`, `j`, and `k` as inputs.\\n   - The function checks whether the substring `s3[k:]` can be formed by interleaving `s1[i:]` and `s2[j:]`.\\n   - Store the result of each subproblem in the `memo` dictionary.\\n\\n3. **Wrap-up**:\\n   - Return the result of the recursive function for the initial values `i=0, j=0, k=0`.\\n\\n# Complexity:\\n\\n**Time Complexity:** \\n- Each combination of (i, j) is computed once and stored in the memo, leading to a time complexity of $$O(m \\\\times n)$$.\\n\\n**Space Complexity:** \\n- The space complexity is $$O(m \\\\times n)$$ for storing the memoization results.\\n\\n---\\n\\n# Performance\\n\\n| Language  | Runtime (ms) | Memory (MB) |\\n|-----------|--------------|-------------|\\n| Rust      | 0            | 2.1         |\\n| C++       | 0            | 6.4         |\\n| Go        | 1            | 1.9         |\\n| Java      | 3            | 40.5        |\\n| Python3 (1D DP) | 31     | 16.4        |\\n| Python3 (2D DP) | 34     | 16.5        |\\n| Python3 (Recursion) | 45 | 17.4        |\\n| C#        | 54           | 38.4        |\\n| JavaScript| 61           | 43.1        |\\n\\n![ir.png](https://assets.leetcode.com/users/images/6a85642f-8740-4891-a310-591b172bcee8_1692924054.2926686.png)\\n\\n# Code 1D Dynamic Programming \\n``` Python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n, l = len(s1), len(s2), len(s3)\\n        if m + n != l:\\n            return False\\n        \\n        if m < n:\\n            return self.isInterleave(s2, s1, s3)\\n        \\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        \\n        for j in range(1, n + 1):\\n            dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\\n        \\n        for i in range(1, m + 1):\\n            dp[0] = dp[0] and s1[i-1] == s3[i-1]\\n            for j in range(1, n + 1):\\n                dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or (dp[j-1] and s2[j-1] == s3[i+j-1])\\n        \\n        return dp[n]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.length(), n = s2.length(), l = s3.length();\\n        if (m + n != l) return false;\\n        \\n        if (m < n) return isInterleave(s2, s1, s3);\\n\\n        vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n\\n        for (int j = 1; j <= n; ++j) {\\n            dp[j] = dp[j - 1] && s2[j - 1] == s3[j - 1];\\n        }\\n\\n        for (int i = 1; i <= m; ++i) {\\n            dp[0] = dp[0] && s1[i - 1] == s3[i - 1];\\n            for (int j = 1; j <= n; ++j) {\\n                dp[j] = (dp[j] && s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int m = s1.length(), n = s2.length(), l = s3.length();\\n        if (m + n != l) return false;\\n\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        for (int j = 1; j <= n; ++j) {\\n            dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);\\n        }\\n\\n        for (int i = 1; i <= m; ++i) {\\n            dp[0] = dp[0] && s1.charAt(i - 1) == s3.charAt(i - 1);\\n            for (int j = 1; j <= n; ++j) {\\n                dp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn is_interleave(s1: String, s2: String, s3: String) -> bool {\\n        let (m, n, l) = (s1.len(), s2.len(), s3.len());\\n        if m + n != l { return false; }\\n\\n        let (s1, s2, s3) = (s1.as_bytes(), s2.as_bytes(), s3.as_bytes());\\n        let mut dp = vec![false; n + 1];\\n        dp[0] = true;\\n\\n        for j in 1..=n {\\n            dp[j] = dp[j - 1] && s2[j - 1] == s3[j - 1];\\n        }\\n\\n        for i in 1..=m {\\n            dp[0] = dp[0] && s1[i - 1] == s3[i - 1];\\n            for j in 1..=n {\\n                dp[j] = (dp[j] && s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        \\n        dp[n]\\n    }\\n}\\n```\\n``` Go []\\nfunc isInterleave(s1 string, s2 string, s3 string) bool {\\n    m, n, l := len(s1), len(s2), len(s3)\\n    if m + n != l {\\n        return false\\n    }\\n\\n    dp := make([]bool, n+1)\\n    dp[0] = true\\n\\n    for j := 1; j <= n; j++ {\\n        dp[j] = dp[j-1] && s2[j-1] == s3[j-1]\\n    }\\n\\n    for i := 1; i <= m; i++ {\\n        dp[0] = dp[0] && s1[i-1] == s3[i-1]\\n        for j := 1; j <= n; j++ {\\n            dp[j] = (dp[j] && s1[i-1] == s3[i+j-1]) || (dp[j-1] && s2[j-1] == s3[i+j-1])\\n        }\\n    }\\n    \\n    return dp[n]\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public bool IsInterleave(string s1, string s2, string s3) {\\n        int m = s1.Length, n = s2.Length, l = s3.Length;\\n        if (m + n != l) return false;\\n\\n        bool[] dp = new bool[n + 1];\\n        dp[0] = true;\\n\\n        for (int j = 1; j <= n; ++j) {\\n            dp[j] = dp[j - 1] && s2[j - 1] == s3[j - 1];\\n        }\\n\\n        for (int i = 1; i <= m; ++i) {\\n            dp[0] = dp[0] && s1[i - 1] == s3[i - 1];\\n            for (int j = 1; j <= n; ++j) {\\n                dp[j] = (dp[j] && s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @param {string} s3\\n * @return {boolean}\\n */\\nvar isInterleave = function(s1, s2, s3) {\\n    let m = s1.length, n = s2.length, l = s3.length;\\n    if (m + n !== l) return false;\\n\\n    let dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n\\n    for (let j = 1; j <= n; ++j) {\\n        dp[j] = dp[j - 1] && s2[j - 1] === s3[j - 1];\\n    }\\n\\n    for (let i = 1; i <= m; ++i) {\\n        dp[0] = dp[0] && s1[i - 1] === s3[i - 1];\\n        for (let j = 1; j <= n; ++j) {\\n            dp[j] = (dp[j] && s1[i - 1] === s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] === s3[i + j - 1]);\\n        }\\n    }\\n    \\n    return dp[n];\\n};\\n```\\n\\n# Code 2D Dynamic Programming \\n``` Python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n, l = len(s1), len(s2), len(s3)\\n        if m + n != l:\\n            return False\\n        \\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[0][0] = True\\n        \\n        for i in range(1, m + 1):\\n            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\\n        \\n        for j in range(1, n + 1):\\n            dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\\n        \\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])\\n        \\n        return dp[m][n]\\n\\n```\\n# Code Recursion with Memoization\\n``` Python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n, l = len(s1), len(s2), len(s3)\\n        if m + n != l:\\n            return False\\n        \\n        memo = {} \\n        \\n        def helper(i: int, j: int, k: int) -> bool:\\n            if k == l:\\n                return True\\n            \\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            \\n            ans = False\\n            if i < m and s1[i] == s3[k]:\\n                ans = ans or helper(i + 1, j, k + 1)\\n                \\n            if j < n and s2[j] == s3[k]:\\n                ans = ans or helper(i, j + 1, k + 1)\\n            \\n            memo[(i, j)] = ans\\n            return ans\\n        \\n        return helper(0, 0, 0)\\n```\\n\\nBoth the given approaches provide efficient ways to solve the problem, with the first approach focusing on optimizing space and the second leveraging the power of memoization to save time. Choosing between them depends on the specific constraints and requirements of the application. \\uD83D\\uDCA1\\uD83C\\uDF20\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n, l = len(s1), len(s2), len(s3)\\n        if m + n != l:\\n            return False\\n        \\n        if m < n:\\n            return self.isInterleave(s2, s1, s3)\\n        \\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        \\n        for j in range(1, n + 1):\\n            dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\\n        \\n        for i in range(1, m + 1):\\n            dp[0] = dp[0] and s1[i-1] == s3[i-1]\\n            for j in range(1, n + 1):\\n                dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or (dp[j-1] and s2[j-1] == s3[i+j-1])\\n        \\n        return dp[n]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.length(), n = s2.length(), l = s3.length();\\n        if (m + n != l) return false;\\n        \\n        if (m < n) return isInterleave(s2, s1, s3);\\n\\n        vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n\\n        for (int j = 1; j <= n; ++j) {\\n            dp[j] = dp[j - 1] && s2[j - 1] == s3[j - 1];\\n        }\\n\\n        for (int i = 1; i <= m; ++i) {\\n            dp[0] = dp[0] && s1[i - 1] == s3[i - 1];\\n            for (int j = 1; j <= n; ++j) {\\n                dp[j] = (dp[j] && s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int m = s1.length(), n = s2.length(), l = s3.length();\\n        if (m + n != l) return false;\\n\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        for (int j = 1; j <= n; ++j) {\\n            dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);\\n        }\\n\\n        for (int i = 1; i <= m; ++i) {\\n            dp[0] = dp[0] && s1.charAt(i - 1) == s3.charAt(i - 1);\\n            for (int j = 1; j <= n; ++j) {\\n                dp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn is_interleave(s1: String, s2: String, s3: String) -> bool {\\n        let (m, n, l) = (s1.len(), s2.len(), s3.len());\\n        if m + n != l { return false; }\\n\\n        let (s1, s2, s3) = (s1.as_bytes(), s2.as_bytes(), s3.as_bytes());\\n        let mut dp = vec![false; n + 1];\\n        dp[0] = true;\\n\\n        for j in 1..=n {\\n            dp[j] = dp[j - 1] && s2[j - 1] == s3[j - 1];\\n        }\\n\\n        for i in 1..=m {\\n            dp[0] = dp[0] && s1[i - 1] == s3[i - 1];\\n            for j in 1..=n {\\n                dp[j] = (dp[j] && s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        \\n        dp[n]\\n    }\\n}\\n```\n``` Go []\\nfunc isInterleave(s1 string, s2 string, s3 string) bool {\\n    m, n, l := len(s1), len(s2), len(s3)\\n    if m + n != l {\\n        return false\\n    }\\n\\n    dp := make([]bool, n+1)\\n    dp[0] = true\\n\\n    for j := 1; j <= n; j++ {\\n        dp[j] = dp[j-1] && s2[j-1] == s3[j-1]\\n    }\\n\\n    for i := 1; i <= m; i++ {\\n        dp[0] = dp[0] && s1[i-1] == s3[i-1]\\n        for j := 1; j <= n; j++ {\\n            dp[j] = (dp[j] && s1[i-1] == s3[i+j-1]) || (dp[j-1] && s2[j-1] == s3[i+j-1])\\n        }\\n    }\\n    \\n    return dp[n]\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public bool IsInterleave(string s1, string s2, string s3) {\\n        int m = s1.Length, n = s2.Length, l = s3.Length;\\n        if (m + n != l) return false;\\n\\n        bool[] dp = new bool[n + 1];\\n        dp[0] = true;\\n\\n        for (int j = 1; j <= n; ++j) {\\n            dp[j] = dp[j - 1] && s2[j - 1] == s3[j - 1];\\n        }\\n\\n        for (int i = 1; i <= m; ++i) {\\n            dp[0] = dp[0] && s1[i - 1] == s3[i - 1];\\n            for (int j = 1; j <= n; ++j) {\\n                dp[j] = (dp[j] && s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @param {string} s3\\n * @return {boolean}\\n */\\nvar isInterleave = function(s1, s2, s3) {\\n    let m = s1.length, n = s2.length, l = s3.length;\\n    if (m + n !== l) return false;\\n\\n    let dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n\\n    for (let j = 1; j <= n; ++j) {\\n        dp[j] = dp[j - 1] && s2[j - 1] === s3[j - 1];\\n    }\\n\\n    for (let i = 1; i <= m; ++i) {\\n        dp[0] = dp[0] && s1[i - 1] === s3[i - 1];\\n        for (let j = 1; j <= n; ++j) {\\n            dp[j] = (dp[j] && s1[i - 1] === s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] === s3[i + j - 1]);\\n        }\\n    }\\n    \\n    return dp[n];\\n};\\n```\n``` Python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n, l = len(s1), len(s2), len(s3)\\n        if m + n != l:\\n            return False\\n        \\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[0][0] = True\\n        \\n        for i in range(1, m + 1):\\n            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\\n        \\n        for j in range(1, n + 1):\\n            dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\\n        \\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])\\n        \\n        return dp[m][n]\\n\\n```\n``` Python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n, l = len(s1), len(s2), len(s3)\\n        if m + n != l:\\n            return False\\n        \\n        memo = {} \\n        \\n        def helper(i: int, j: int, k: int) -> bool:\\n            if k == l:\\n                return True\\n            \\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            \\n            ans = False\\n            if i < m and s1[i] == s3[k]:\\n                ans = ans or helper(i + 1, j, k + 1)\\n                \\n            if j < n and s2[j] == s3[k]:\\n                ans = ans or helper(i, j + 1, k + 1)\\n            \\n            memo[(i, j)] = ans\\n            return ans\\n        \\n        return helper(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32078,
                "title": "dp-solution-in-java",
                "content": "    public boolean isInterleave(String s1, String s2, String s3) {\\n\\n        if ((s1.length()+s2.length())!=s3.length()) return false;\\n\\n        boolean[][] matrix = new boolean[s2.length()+1][s1.length()+1];\\n\\n        matrix[0][0] = true;\\n\\n        for (int i = 1; i < matrix[0].length; i++){\\n            matrix[0][i] = matrix[0][i-1]&&(s1.charAt(i-1)==s3.charAt(i-1));\\n        }\\n\\n        for (int i = 1; i < matrix.length; i++){\\n            matrix[i][0] = matrix[i-1][0]&&(s2.charAt(i-1)==s3.charAt(i-1));\\n        }\\n\\n        for (int i = 1; i < matrix.length; i++){\\n            for (int j = 1; j < matrix[0].length; j++){\\n                matrix[i][j] = (matrix[i-1][j]&&(s2.charAt(i-1)==s3.charAt(i+j-1)))\\n                        || (matrix[i][j-1]&&(s1.charAt(j-1)==s3.charAt(i+j-1)));\\n            }\\n        }\\n\\n        return matrix[s2.length()][s1.length()];\\n\\n    }",
                "solutionTags": [],
                "code": "    public boolean isInterleave(String s1, String s2, String s3) {\\n\\n        if ((s1.length()+s2.length())!=s3.length()) return false;\\n\\n        boolean[][] matrix = new boolean[s2.length()+1][s1.length()+1];\\n\\n        matrix[0][0] = true;\\n\\n        for (int i = 1; i < matrix[0].length; i++){\\n            matrix[0][i] = matrix[0][i-1]&&(s1.charAt(i-1)==s3.charAt(i-1));\\n        }\\n\\n        for (int i = 1; i < matrix.length; i++){\\n            matrix[i][0] = matrix[i-1][0]&&(s2.charAt(i-1)==s3.charAt(i-1));\\n        }\\n\\n        for (int i = 1; i < matrix.length; i++){\\n            for (int j = 1; j < matrix[0].length; j++){\\n                matrix[i][j] = (matrix[i-1][j]&&(s2.charAt(i-1)==s3.charAt(i+j-1)))\\n                        || (matrix[i][j-1]&&(s1.charAt(j-1)==s3.charAt(i+j-1)));\\n            }\\n        }\\n\\n        return matrix[s2.length()][s1.length()];\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2248553,
                "title": "c-recursive-memoization-code-with-explanation",
                "content": "### Recursive Solution:  (Gives TLE)\\nTraverse all the three strings from end.\\n**Base case**: When the lengths of all the strings become less than 0 (**Note**: Not less than or equal to 0, that will give a wrong answer in the case when s1=\"a\", s2=\" \", s3=\"c\" ) \\nThere are three cases:\\n- **Case 1**:  If both the last characters of s1 and s2 are equal to the last character of s3, then we have 2 choices, we can either pick last character of s1 or the last character of s2. \\n- **Case2**: If the last characters of s1 and s3 are equal, then We\\'ll simply reduce the length of s1 and s3 by 1(meaning, we\\'ll exclude both of the last characters and make the call for rest of the string)\\n- **Case3**:  If the last characters of s2 and s3 are equal, then We\\'ll simply reduce the length of s2 and s3 by 1(meaning, we\\'ll exclude both of the last characters and make the call for rest of the string).\\n\\nIf any of these cases does\\'t hold true, then return false (as none of the characters match).\\n\\n```\\nclass Solution {\\npublic:\\n    bool helper(string& s1, string& s2, string &s3, int l1, int l2, int l3) {\\n        if(l1<0 && l2<0 && l3<0) {\\n            return true;\\n        }\\n        if(l1>=0 && s1[l1]==s3[l3] && l2>=0 && s2[l2]==s3[l3] ) {\\n            return (helper(s1, s2, s3, l1-1, l2, l3-1) || helper(s1, s2, s3, l1, l2-1, l3-1));\\n        }\\n        else if(l1>=0 && s1[l1]==s3[l3])\\n            return helper(s1, s2, s3, l1-1, l2, l3-1);\\n        \\n        else if(l2>=0 &&s2[l2]==s3[l3])\\n            return helper(s1, s2, s3, l1, l2-1, l3-1);\\n        \\n        else return false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.size() != s1.size() + s2.size())\\n\\t\\t\\treturn false;\\n        return helper(s1, s2, s3,s1.size()-1, s2.size()-1, s3.size()-1);\\n    }\\n};\\n```\\n### Recusive solution to MEMOIZATION: (Accepted)\\n```\\nclass Solution {\\npublic:\\n    // int dp[102][102];\\n    bool helper(string& s1, string& s2, string &s3, int l1, int l2, int l3, vector<vector<int>>&dp) {\\n        if(l1<0 && l2<0 && l3<0) {\\n            return true;\\n        }\\n        if(l1>=0 && l2>=0 && dp[l1][l2]!=-1) {\\n            return dp[l1][l2];\\n        }\\n        if(l1>=0 && s1[l1]==s3[l3] && l2>=0 && s2[l2]==s3[l3] ) {\\n            return dp[l1][l2] = (helper(s1, s2, s3, l1-1, l2, l3-1, dp) || helper(s1, s2, s3, l1, l2-1, l3-1, dp));\\n        }\\n        else if(l1>=0 && s1[l1]==s3[l3])\\n            return helper(s1, s2, s3, l1-1, l2, l3-1, dp);\\n        \\n        else if(l2>=0 &&s2[l2]==s3[l3])\\n            return helper(s1, s2, s3, l1, l2-1, l3-1, dp);\\n        \\n        else return false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.size() != s1.size() + s2.size())\\n\\t\\t\\treturn false;\\n        vector<vector<int>>dp(s1.size()+1, (vector<int>(s2.size()+1, -1)));\\n        // memset(dp, -1, sizeof(dp));\\n        return helper(s1, s2, s3,s1.size()-1, s2.size()-1, s3.size()-1, dp);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(string& s1, string& s2, string &s3, int l1, int l2, int l3) {\\n        if(l1<0 && l2<0 && l3<0) {\\n            return true;\\n        }\\n        if(l1>=0 && s1[l1]==s3[l3] && l2>=0 && s2[l2]==s3[l3] ) {\\n            return (helper(s1, s2, s3, l1-1, l2, l3-1) || helper(s1, s2, s3, l1, l2-1, l3-1));\\n        }\\n        else if(l1>=0 && s1[l1]==s3[l3])\\n            return helper(s1, s2, s3, l1-1, l2, l3-1);\\n        \\n        else if(l2>=0 &&s2[l2]==s3[l3])\\n            return helper(s1, s2, s3, l1, l2-1, l3-1);\\n        \\n        else return false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.size() != s1.size() + s2.size())\\n\\t\\t\\treturn false;\\n        return helper(s1, s2, s3,s1.size()-1, s2.size()-1, s3.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // int dp[102][102];\\n    bool helper(string& s1, string& s2, string &s3, int l1, int l2, int l3, vector<vector<int>>&dp) {\\n        if(l1<0 && l2<0 && l3<0) {\\n            return true;\\n        }\\n        if(l1>=0 && l2>=0 && dp[l1][l2]!=-1) {\\n            return dp[l1][l2];\\n        }\\n        if(l1>=0 && s1[l1]==s3[l3] && l2>=0 && s2[l2]==s3[l3] ) {\\n            return dp[l1][l2] = (helper(s1, s2, s3, l1-1, l2, l3-1, dp) || helper(s1, s2, s3, l1, l2-1, l3-1, dp));\\n        }\\n        else if(l1>=0 && s1[l1]==s3[l3])\\n            return helper(s1, s2, s3, l1-1, l2, l3-1, dp);\\n        \\n        else if(l2>=0 &&s2[l2]==s3[l3])\\n            return helper(s1, s2, s3, l1, l2-1, l3-1, dp);\\n        \\n        else return false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.size() != s1.size() + s2.size())\\n\\t\\t\\treturn false;\\n        vector<vector<int>>dp(s1.size()+1, (vector<int>(s2.size()+1, -1)));\\n        // memset(dp, -1, sizeof(dp));\\n        return helper(s1, s2, s3,s1.size()-1, s2.size()-1, s3.size()-1, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247494,
                "title": "python-3-from-top-down-to-bottom-up-2d-to-1d-space",
                "content": "**\\u2714\\uFE0F Solution 1: Top-down DP**\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False\\n        m, n = len(s1), len(s2)\\n        \\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == m and j == n: return True  # Found a valid match\\n            ans = False\\n            if i < m and s1[i] == s3[i+j]:  # Case match s1[i] with s3[i+j]\\n                ans |= dp(i + 1, j)\\n            if j < n and s2[j] == s3[i+j]:  # Case match s2[j] with s3[i+j]\\n                ans |= dp(i, j + 1)\\n            return ans\\n\\n        return dp(0, 0)\\n```\\nComplexity:\\n- Time: `O(m*n)`, where `m` is length of string `s1`, `n` is length of string `s2`\\n- Space: `O(m*n)`\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Bottom-up DP**\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False\\n\\n        m, n = len(s1), len(s2)\\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[m][n] = True\\n        for i in range(m, -1, -1):\\n            for j in range(n, -1, -1):\\n                if i < m and s1[i] == s3[i + j]:\\n                    dp[i][j] |= dp[i + 1][j]\\n                if j < n and s2[j] == s3[i + j]:\\n                    dp[i][j] |= dp[i][j + 1]\\n        return dp[0][0]\\n```\\nComplexity:\\n- Time: `O(m*n)`, where `m` is length of string `s1`, `n` is length of string `s2`\\n- Space: `O(m*n)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Bottom-up DP (Space Optimized)**\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False\\n\\n        m, n = len(s1), len(s2)\\n        dp, dpPrev = [False] * (n + 1), [False] * (n + 1)\\n        for i in range(m, -1, -1):\\n            for j in range(n, -1, -1):\\n                dp[j] = False\\n                if i == m and j == n:\\n                    dp[n] = True\\n                if i < m and s1[i] == s3[i + j]:\\n                    dp[j] |= dpPrev[j]\\n                if j < n and s2[j] == s3[i + j]:\\n                    dp[j] |= dp[j + 1]\\n            dp, dpPrev = dpPrev, dp\\n        return dpPrev[0]\\n```\\nComplexity:\\n- Time: `O(m*n)`, where `m` is length of string `s1`, `n` is length of string `s2`\\n- Space: `O(n)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False\\n        m, n = len(s1), len(s2)\\n        \\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == m and j == n: return True  # Found a valid match\\n            ans = False\\n            if i < m and s1[i] == s3[i+j]:  # Case match s1[i] with s3[i+j]\\n                ans |= dp(i + 1, j)\\n            if j < n and s2[j] == s3[i+j]:  # Case match s2[j] with s3[i+j]\\n                ans |= dp(i, j + 1)\\n            return ans\\n\\n        return dp(0, 0)\\n```\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False\\n\\n        m, n = len(s1), len(s2)\\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[m][n] = True\\n        for i in range(m, -1, -1):\\n            for j in range(n, -1, -1):\\n                if i < m and s1[i] == s3[i + j]:\\n                    dp[i][j] |= dp[i + 1][j]\\n                if j < n and s2[j] == s3[i + j]:\\n                    dp[i][j] |= dp[i][j + 1]\\n        return dp[0][0]\\n```\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False\\n\\n        m, n = len(s1), len(s2)\\n        dp, dpPrev = [False] * (n + 1), [False] * (n + 1)\\n        for i in range(m, -1, -1):\\n            for j in range(n, -1, -1):\\n                dp[j] = False\\n                if i == m and j == n:\\n                    dp[n] = True\\n                if i < m and s1[i] == s3[i + j]:\\n                    dp[j] |= dpPrev[j]\\n                if j < n and s2[j] == s3[i + j]:\\n                    dp[j] |= dp[j + 1]\\n            dp, dpPrev = dpPrev, dp\\n        return dpPrev[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247165,
                "title": "c-memoizn-3-variables-memoizn-without-3rd-var-dp-m-n-dp-n",
                "content": "```\\n//Approach-1 (Recursion + Memoization (i, j, k))\\nclass Solution {\\npublic:\\n    int m, n, N;\\n    int t[101][101][201];\\n    bool check(string s1, string s2, string s3, int i, int j, int k) {\\n        if(i >= m && j >= n && k >= N) //solution\\n            return true;\\n        \\n        if(k >= N) //other string didn\\'t get consumed whole\\n            return false;\\n            \\n        if(t[i][j][k] != -1)\\n            return t[i][j][k];\\n        \\n        return t[i][j][k] = ((s1[i]==s3[k] && check(s1, s2, s3, i+1, j, k+1)) || (s2[j]==s3[k] && check(s1, s2, s3, i, j+1, k+1)));\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        memset(t, -1, sizeof(t));\\n        m = s1.length();\\n        n = s2.length();\\n        N = s3.length();\\n        \\n        return check(s1, s2, s3, 0, 0, 0);\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Recursion + Memoization (i, j))\\nclass Solution {\\npublic:\\n    int m, n, N;\\n    int t[101][101];\\n    \\n    bool check(string s1, string s2, string s3, int i, int j) {\\n        if(i >= m && j >= n && i+j >= N) //solution\\n            return true;\\n        \\n        if(i+j >= N) //other string didn\\'t get consumed whole\\n            return false;\\n            \\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        \\n        //Note that, k is same for both calls because it increases in both cases\\n        //Also, at any time k = i + j;\\n        return t[i][j] = ((s1[i]==s3[i+j] && check(s1, s2, s3, i+1, j)) || (s2[j]==s3[i+j] && check(s1, s2, s3, i, j+1)));\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        memset(t, -1, sizeof(t));\\n        m = s1.length();\\n        n = s2.length();\\n        N = s3.length();\\n        \\n        if(m + n != N)\\n            return false;\\n        \\n        return check(s1, s2, s3, 0, 0);\\n    }\\n};\\n```\\n\\n```\\n//Approach - 3 (Bottom Up : Time and Space : O(m*n))\\nclass Solution {\\npublic:   \\n    bool check(string& s1, string& s2, string& s3) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int N = s3.length();\\n        if(m + n != N)\\n            return false;\\n        \\n        int t[m+1][n+1];\\n        //t[i][j] = true; //means, s1[0..i] and s2[0...j] interleaves with s3 till (i+j)\\n        \\n        //length of s1 = 0, s2 = 0 and s3 = 0 + 0, i.e. 0 . So obviously it\\'s interleaved :-)\\n        t[0][0] = true;\\n        \\n        //When s1 is of 0 length, we can interleave only when s2 forms s3\\n        for(int j = 1; j<n+1; j++) {\\n            t[0][j] = t[0][j-1] && s2[j-1]==s3[j-1];\\n        }\\n        \\n        //When s2 is of 0 length, we can interleave only if s1 forms s3\\n        for(int i = 1; i<m+1; i++) {\\n            t[i][0] = t[i-1][0] && s1[i-1]==s3[i-1];\\n        }\\n        \\n        \\n        for(int i = 1; i<m+1; i++) {\\n            for(int j = 1; j<n+1; j++) {\\n                int k = i + j - 1;\\n                \\n                bool s1_equals_s3  = t[i-1][j] && s1[i-1] == s3[k]; //Try with s1\\n                \\n                bool s2_equals_s3  = t[i][j-1] && s2[j-1] == s3[k]; //Try with s2\\n                \\n                t[i][j] = s1_equals_s3 || s2_equals_s3 ;\\n            }\\n        }\\n        \\n        return t[m][n];\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        return check(s1, s2, s3);\\n    }\\n};\\n```\\n\\n```\\n//Approach - 4 (Bottom Up : Space O(n), Time O(m*n) : Converting Approach-3 to O(n) space approach)\\nclass Solution {\\npublic:   \\n    bool check(string& s1, string& s2, string& s3) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int N = s3.length();\\n        if(m + n != N)\\n            return false;\\n        \\n        bool t[n+1];\\n        \\n        \\n        for(int i = 0; i<m+1; i++) {\\n            for(int j = 0; j<n+1; j++) {\\n                if(i == 0 && j == 0) {\\n                    t[j] = true;\\n                } else if(i == 0) {\\n                    t[j] = t[j-1] && s2[j-1]==s3[i+j-1];\\n                } else if (j == 0) {\\n                    t[j] = t[j] && s1[i-1]==s3[i+j-1];\\n                } else {\\n                    t[j] = (t[j-1] && s2[j-1]==s3[i+j-1]) || (t[j] && s1[i-1]==s3[i+j-1]);\\n                }\\n            }\\n        }\\n        \\n        return t[n];\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        return check(s1, s2, s3);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Recursion + Memoization (i, j, k))\\nclass Solution {\\npublic:\\n    int m, n, N;\\n    int t[101][101][201];\\n    bool check(string s1, string s2, string s3, int i, int j, int k) {\\n        if(i >= m && j >= n && k >= N) //solution\\n            return true;\\n        \\n        if(k >= N) //other string didn\\'t get consumed whole\\n            return false;\\n            \\n        if(t[i][j][k] != -1)\\n            return t[i][j][k];\\n        \\n        return t[i][j][k] = ((s1[i]==s3[k] && check(s1, s2, s3, i+1, j, k+1)) || (s2[j]==s3[k] && check(s1, s2, s3, i, j+1, k+1)));\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        memset(t, -1, sizeof(t));\\n        m = s1.length();\\n        n = s2.length();\\n        N = s3.length();\\n        \\n        return check(s1, s2, s3, 0, 0, 0);\\n    }\\n};\\n```\n```\\n//Approach-2 (Recursion + Memoization (i, j))\\nclass Solution {\\npublic:\\n    int m, n, N;\\n    int t[101][101];\\n    \\n    bool check(string s1, string s2, string s3, int i, int j) {\\n        if(i >= m && j >= n && i+j >= N) //solution\\n            return true;\\n        \\n        if(i+j >= N) //other string didn\\'t get consumed whole\\n            return false;\\n            \\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        \\n        //Note that, k is same for both calls because it increases in both cases\\n        //Also, at any time k = i + j;\\n        return t[i][j] = ((s1[i]==s3[i+j] && check(s1, s2, s3, i+1, j)) || (s2[j]==s3[i+j] && check(s1, s2, s3, i, j+1)));\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        memset(t, -1, sizeof(t));\\n        m = s1.length();\\n        n = s2.length();\\n        N = s3.length();\\n        \\n        if(m + n != N)\\n            return false;\\n        \\n        return check(s1, s2, s3, 0, 0);\\n    }\\n};\\n```\n```\\n//Approach - 3 (Bottom Up : Time and Space : O(m*n))\\nclass Solution {\\npublic:   \\n    bool check(string& s1, string& s2, string& s3) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int N = s3.length();\\n        if(m + n != N)\\n            return false;\\n        \\n        int t[m+1][n+1];\\n        //t[i][j] = true; //means, s1[0..i] and s2[0...j] interleaves with s3 till (i+j)\\n        \\n        //length of s1 = 0, s2 = 0 and s3 = 0 + 0, i.e. 0 . So obviously it\\'s interleaved :-)\\n        t[0][0] = true;\\n        \\n        //When s1 is of 0 length, we can interleave only when s2 forms s3\\n        for(int j = 1; j<n+1; j++) {\\n            t[0][j] = t[0][j-1] && s2[j-1]==s3[j-1];\\n        }\\n        \\n        //When s2 is of 0 length, we can interleave only if s1 forms s3\\n        for(int i = 1; i<m+1; i++) {\\n            t[i][0] = t[i-1][0] && s1[i-1]==s3[i-1];\\n        }\\n        \\n        \\n        for(int i = 1; i<m+1; i++) {\\n            for(int j = 1; j<n+1; j++) {\\n                int k = i + j - 1;\\n                \\n                bool s1_equals_s3  = t[i-1][j] && s1[i-1] == s3[k]; //Try with s1\\n                \\n                bool s2_equals_s3  = t[i][j-1] && s2[j-1] == s3[k]; //Try with s2\\n                \\n                t[i][j] = s1_equals_s3 || s2_equals_s3 ;\\n            }\\n        }\\n        \\n        return t[m][n];\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        return check(s1, s2, s3);\\n    }\\n};\\n```\n```\\n//Approach - 4 (Bottom Up : Space O(n), Time O(m*n) : Converting Approach-3 to O(n) space approach)\\nclass Solution {\\npublic:   \\n    bool check(string& s1, string& s2, string& s3) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int N = s3.length();\\n        if(m + n != N)\\n            return false;\\n        \\n        bool t[n+1];\\n        \\n        \\n        for(int i = 0; i<m+1; i++) {\\n            for(int j = 0; j<n+1; j++) {\\n                if(i == 0 && j == 0) {\\n                    t[j] = true;\\n                } else if(i == 0) {\\n                    t[j] = t[j-1] && s2[j-1]==s3[i+j-1];\\n                } else if (j == 0) {\\n                    t[j] = t[j] && s1[i-1]==s3[i+j-1];\\n                } else {\\n                    t[j] = (t[j-1] && s2[j-1]==s3[i+j-1]) || (t[j] && s1[i-1]==s3[i+j-1]);\\n                }\\n            }\\n        }\\n        \\n        return t[n];\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        return check(s1, s2, s3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246649,
                "title": "python-3-lines-dp-explained",
                "content": "In `dp(i, j)` we keep `1` if it is possible to form string `s3` upto `i+j` symbol from first `i` elements of `s1` and first `j` elements of `s2`. Every moment we need to check two at most two neighbors: `dp(i, j - 1)` and `dp(i - 1, j)`: we need to check if symbol `s[i+j+1]` is equal to `s2[j]` and answer is true for `dp(i, j-1)` and `j >= 0`, or similar condition for another string.\\n\\n#### Complexity\\nTime complexity is `O(mn)`, because we have `mn` states and two transactions from one state to others. Space complexity is `O(mn)` as well, which can be reduced to `O(m + n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def isInterleave(self, s1, s2, s3):\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == -1 and j == -1: return True\\n            return (j >= 0 and s2[j] == s3[i+j+1] and dp(i, j-1)) or (i >= 0 and s1[i] == s3[i+j+1] and dp(i-1,j))\\n        \\n        return len(s1) + len(s2) == len(s3) and dp(len(s1) - 1, len(s2) - 1)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def isInterleave(self, s1, s2, s3):\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == -1 and j == -1: return True\\n            return (j >= 0 and s2[j] == s3[i+j+1] and dp(i, j-1)) or (i >= 0 and s1[i] == s3[i+j+1] and dp(i-1,j))\\n        \\n        return len(s1) + len(s2) == len(s3) and dp(len(s1) - 1, len(s2) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31901,
                "title": "c-dp-solution-with-explanation",
                "content": "First tried brute force backtracking, it's obvious will not be accepted.\\n\\n    class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int n1 = s1.size(), n2 = s2.size(), n3 = s3.size();\\n            if(n1 + n2 != n3) return false;\\n            return isInterleaveHelper(s1, 0, n1, s2, 0, n2, s3, 0, n3);\\n        }\\n        \\n        bool isInterleaveHelper(string &s1, int i1, int n1, string &s2, int i2, int n2, string &s3, int i3, int n3){\\n            if(i1 == n1 && i2 == n2 && i3 == n3) return true; \\n            if(i1 < n1 && s1[i1] == s3[i3] && isInterleaveHelper(s1, i1 + 1, n1, s2, i2, n2, s3, i3 + 1, n3)) return true;\\n            if(i2 < n2 && s2[i2] == s3[i3] && isInterleaveHelper(s1, i1, n1, s2, i2 + 1, n2, s3, i3 + 1, n3)) return true;\\n            else return false;\\n        }\\n    };\\n\\n\\nThen it comes to dp solution. I first built a two dimension dp table, with drawing the path displayed below. Because it's interleaving, so certain order still needs to maintain, so that's why for a valid path, it can only go right or down, so that's why `dp[i1][i2]` is depending on `dp[i1 - 1][i2]` and `dp[i1][i2 - 1]`. After discovering the transition rule to get `dp[i1][i2]`, we just need to record true or false in the dp table. `dp[i1][i2]` means if `s3.substr(0, i1 + i2)` can be formed by `s1.substr(0, i1)` interleaving `s2.substr(0, i2)`;\\n\\n    s3 = \\u201caadbbcbcac\\u201d\\n                     a\\t    a\\t    b\\t    c\\t   c\\n    \\t\\t    0\\t 1\\t    2\\t    3\\t    4\\t   5\\n    \\n         \\t0\\t\\u201c\\u201d\\u2192\\t a  \\u2192   aa\\t\\n    \\t\\t\\t\\t        \\u2193\\n       d\\t1\\t\\t\\t    aad  \\u2192  aadb\\n    \\t\\t\\t\\t        \\u2193\\t    \\u2193\\n       b\\t2\\t\\t\\t    aadb \\u2192  aadbb \\u2192 aadbbc\\n    \\t\\t\\t\\t        \\u2193\\t\\t\\u2193\\n       b\\t3\\t\\t\\t    aadbb\\taadbbcb\\n    \\t\\t\\t\\t        \\u2193\\n       c\\t4\\t\\t\\t    aadbbc\\u2192 aadbbcb\\n    \\n       a\\t5\\n\\n\\ncode, O(n1n2) space, and O(n1n2)time, it's much better than the brute force now. \\n\\n    class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int n1 = (int)s1.size(), n2 = (int)s2.size(), n3 = (int)s3.size(); \\n            if(n1 + n2 != n3) return false;\\n            \\n            vector<vector<bool>> dp(n1 + 1, vector<bool>(n2 + 1, false));\\n            dp[0][0] = true;\\n            \\n            for(int i2 = 1; i2 <= n2; i2++) dp[0][i2] = dp[0][i2 - 1] && s2[i2 - 1] == s3[i2 - 1];\\n            for(int i1 = 1; i1 <= n1; i1++) dp[i1][0] = dp[i1 - 1][0] && s1[i1 - 1] == s3[i1 - 1];\\n    \\n            for(int i1 = 1; i1 <= n1; i1++){\\n                for(int i2 = 1; i2 <= n2; i2++){\\n                    dp[i1][i2] = (dp[i1 - 1][i2] && s1[i1 - 1] == s3[i1 + i2 - 1]) || (dp[i1][i2 - 1] && s2[i2 - 1] == s3[i1 + i2 - 1]);\\n                }\\n            }\\n            \\n            return dp[n1][n2];  \\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int n1 = s1.size(), n2 = s2.size(), n3 = s3.size();\\n            if(n1 + n2 != n3) return false;\\n            return isInterleaveHelper(s1, 0, n1, s2, 0, n2, s3, 0, n3);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 31904,
                "title": "summary-of-solutions-bfs-dfs-dp",
                "content": "## BFS solution (6ms)\\n\\nImagine a grid, which x-axis and y-axis are s1 and s2, matching s3 is the same as\\nfinding a path from (0,0) to (len1, len2). It actually becomes a\\nBFS on grid. Since we don't need exact paths, a HashSet of\\ncoordinates is used to eliminate duplicated paths.\\n\\n    public class Solution {\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            int len1 = s1.length(),\\n                len2 = s2.length(),\\n                len3 = s3.length();\\n            if (len1 + len2 != len3) return false;\\n            Deque<Integer> queue = new LinkedList<>();\\n            int matched = 0;\\n            queue.offer(0);\\n            Set<Integer> set = new HashSet<>();\\n            while (queue.size() > 0 && matched < len3) {\\n                int size = queue.size();\\n                for (int i = 0; i < size; i++) {\\n                    int p1 = queue.peek() / len3,\\n                        p2 = queue.peek() % len3;\\n                    queue.poll();\\n                    if (p1 < len1 && s1.charAt(p1) == s3.charAt(matched)) {\\n                        int key = (p1 + 1) * len3 + p2;\\n                        if (!set.contains(key)) {\\n                            set.add(key);\\n                            queue.offer(key);\\n                        }\\n                    }\\n                    if (p2 < len2 && s2.charAt(p2) == s3.charAt(matched)) {\\n                        int key = p1 * len3 + (p2 + 1);\\n                        if (!set.contains(key)) {\\n                            set.add(key);\\n                            queue.offer(key);\\n                        }\\n                    }\\n                }\\n                matched++;\\n            }\\n            return queue.size() > 0 && matched == len3;\\n        }\\n    }\\n\\n## DFS solution with memorization (2ms)\\n\\nThis looks slow but is actually faster than BFS! Think about it carefully, in this\\nparticular problem, search always ends at the same depth. DFS with memorization\\nsearches about the same amount of paths with the same length as BFS, if it is doesn't\\nterminate on the first path found. Without the queue operations, the overall cost\\nis only smaller if we don't count call stack. The most significant runtime reducer is\\nprobably the early termination\\n\\n    public class Solution {\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            if (s1.length() + s2.length() != s3.length()) return false;\\n            HashSet<Integer> cache = new HashSet<Integer>();\\n            return isInterleave0(s1, s2, s3, 0, 0, cache);\\n        }\\n\\n        private boolean isInterleave0(String s1, String s2, String s3, int p1, int p2, HashSet<Integer> cache) {\\n            if (p1 + p2 == s3.length())\\n                return true;\\n            if (cache.contains(p1 * s3.length() + p2))\\n                return false;\\n            // no need to store actual result.\\n            // if we found the path, we have already terminated.\\n            cache.add(p1 * s3.length() + p2);\\n            boolean match1 = p1 < s1.length() && s3.charAt(p1 + p2) == s1.charAt(p1);\\n            boolean match2 = p2 < s2.length() && s3.charAt(p1 + p2) == s2.charAt(p2);\\n            if (match1 && match2)\\n                return isInterleave0(s1, s2, s3, p1 + 1, p2, cache) ||\\n                       isInterleave0(s1, s2, s3, p1, p2 + 1, cache);\\n            else if (match1)\\n                return isInterleave0(s1, s2, s3, p1 + 1, p2, cache);\\n            else if (match2)\\n                return isInterleave0(s1, s2, s3, p1, p2 + 1, cache);\\n            else\\n                return false;\\n        }\\n    }\\n\\n## 2d DP solution (6ms)\\n\\nIt's an interesting practice. There are further optimization could be done to\\nreduce cache matrix to 1d. However doing DP for this problem is tedious and not\\nseem to worth the trouble.\\n\\n    public class Solution {\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            int len1 = s1.length(),\\n                len2 = s2.length(),\\n                len3 = s3.length();\\n            if (len1 + len2 != len3) return false;\\n            // cache[i][j] == true means first i + j chars are matched by\\n            // first j chars from s1 and first i chars from s2\\n            boolean[][] cache = new boolean[len2 + 1][len1 + 1];\\n            cache[0][0] = true; // empty and empty matches empty\\n            int m3 = 1; // matched length, m1 and m2 are similar\\n            while (m3 <= len3) {\\n                // this loop fill in cache matrix from left-top to right-bottom, diagonally.\\n                // note that loop conditions are pretty tricky here.\\n                for (int m1 = Math.max(m3 - len2, 0); m1 <= len1 && m1 <= m3; m1++) {\\n                    int m2 = m3 - m1;\\n                    cache[m2][m1] =\\n                        m1 > 0 && cache[m2][m1 - 1] && s3.charAt(m3 - 1) == s1.charAt(m1 - 1) ||\\n                        m2 > 0 && cache[m2 - 1][m1] && s3.charAt(m3 - 1) == s2.charAt(m2 - 1);\\n                }\\n                m3++;\\n            }\\n            return cache[len2][len1];\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            int len1 = s1.length(),\\n                len2 = s2.length(),\\n                len3 = s3.length();\\n            if (len1 + len2 != len3) return false;\\n            Deque<Integer> queue = new LinkedList<>();\\n            int matched = 0;\\n            queue.offer(0);\\n            Set<Integer> set = new HashSet<>();\\n            while (queue.size() > 0 && matched < len3) {\\n                int size = queue.size();\\n                for (int i = 0; i < size; i++) {\\n                    int p1 = queue.peek() / len3,\\n                        p2 = queue.peek() % len3;\\n                    queue.poll();\\n                    if (p1 < len1 && s1.charAt(p1) == s3.charAt(matched)) {\\n                        int key = (p1 + 1) * len3 + p2;\\n                        if (!set.contains(key)) {\\n                            set.add(key);\\n                            queue.offer(key);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 31907,
                "title": "my-accepted-java-recursive-solution-for-interleaving-string",
                "content": "    public class Solution {\\n      \\tprivate static Set<Integer> visited; // The combination of i1, i2 has been visited and return false\\n    \\tpublic static boolean isInterleave(String s1, String s2, String s3) {\\n    \\t\\tif(s3.length() != s1.length() + s2.length())\\n    \\t\\t\\treturn false;\\n    \\t\\tvisited = new HashSet<Integer>();\\n    \\t\\treturn isInterleave(s1, 0, s2, 0, s3, 0);\\n    \\t}\\n    \\t\\n    \\tprivate static boolean isInterleave(String s1, int i1, String s2, int i2, String s3, int i3)\\n    \\t{\\t\\n    \\t\\tint hash = i1 * s3.length() + i2;\\n    \\t\\tif(visited.contains(hash))\\n    \\t\\t\\treturn false;\\n    \\t\\t\\n    \\t\\tif(i1 == s1.length())\\n    \\t\\t\\treturn s2.substring(i2).equals(s3.substring(i3));\\n    \\t\\tif(i2 == s2.length())\\n    \\t\\t\\treturn s1.substring(i1).equals(s3.substring(i3));\\n    \\t\\t\\n    \\t\\tif(s3.charAt(i3) == s1.charAt(i1) && isInterleave(s1, i1+1, s2, i2, s3, i3+1) ||\\n    \\t\\t   s3.charAt(i3) == s2.charAt(i2) && isInterleave(s1, i1, s2, i2+1, s3, i3+1))\\n    \\t\\t\\treturn true;\\n    \\t\\t\\n    \\t\\tvisited.add(hash);\\n    \\t\\treturn false;\\n    \\t}\\n    }\\n\\nThe private method isInterleave is the recursive method. it takes additional i1, i2, i3 as the start indexes of s1, s2, s3, so it solves the substring of s1, s2, s3 with those start indexes. \\n\\nThe recursion starting condition is i1, i2, i3 are set to 0, means it solves the whole string. \\n\\nin each recursion, it will just check the first character in s3 with s2 and s1, if it equals s1, it will increase i3 and i1 to solve remain, if remain return true, this recursion will also return true. Same logic for s2.\\n\\nThe end condition is when remain of either s1 or s2 is empty, then just compare remain of s3 with remain of s1 or s2, if they are equal, it will return true.\\n\\nA pure recursive solution will cause time limit exceed. We can optimize it by caching the false visited solutions in the visited set. That will short circuit many repeated search path.",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n      \\tprivate static Set<Integer> visited; // The combination of i1, i2 has been visited and return false\\n    \\tpublic static boolean isInterleave(String s1, String s2, String s3) {\\n    \\t\\tif(s3.length() != s1.length() + s2.length())\\n    \\t\\t\\treturn false;\\n    \\t\\tvisited = new HashSet<Integer>();\\n    \\t\\treturn isInterleave(s1, 0, s2, 0, s3, 0);\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3956666,
                "title": "beats-100-dp-very-easy-code-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust explore all the option  -> take if current character is same with any of the string current character string 1 and string 2.\\n\\n[ Video in Hindi click here](https://youtube.com/@LetsCodeTogether72/videos)\\n\\nor link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The `solve` function is a recursive helper function that takes the current indices `ind1` and `ind2` for strings `s1` and `s2` respectively, along with a memoization table `dp`. The purpose of this function is to check if it\\'s possible to create the remaining part of `s3` (starting from `ind1+ind2` position) using the remaining parts of `s1` (starting from `ind1` position) and `s2` (starting from `ind2` position).\\n\\n2. The base case for the recursion is when the sum of `ind1` and `ind2` equals the length of `s3`, meaning all characters of `s3` have been matched successfully. In this case, the function returns `true`.\\n\\n3. Before proceeding with the actual computation, the function checks if the result for the current `ind1` and `ind2` indices has already been computed and stored in the memoization table `dp`. If so, it returns the precomputed result.\\n\\n4. The function initializes a boolean variable `ans` to `false`. It then checks two conditions:\\n   - If `ind1` is within bounds of `s1` and the character at `s1[ind1]` matches the character at `s3[ind1+ind2]`, it recursively calls `solve` by moving the index `ind1` of `s1` one step forward.\\n   - If `ind2` is within bounds of `s2` and the character at `s2[ind2]` matches the character at `s3[ind1+ind2]`, it recursively calls `solve` by moving the index `ind2` of `s2` one step forward.\\n   \\n   The `ans` is updated using the bitwise OR operation (`|`) to retain any previous `true` value and to combine the results of the two recursive calls.\\n\\n5. Finally, the function stores the computed `ans` in the memoization table `dp` for the current `ind1` and `ind2` indices and returns this result.\\n\\n6. The `isInterleave` function is the main function that\\'s called to determine whether `s3` can be formed by interleaving characters from `s1` and `s2`. It first checks if the total length of `s1` and `s2` matches the length of `s3`. If not, it returns `false` as it\\'s impossible to form `s3`.\\n\\n7. It initializes a 2D vector `dp` to store the memoization table. The dimensions of this table are `(s1.size() + 1)` rows and `(s2.size() + 1)` columns, with all values initialized to `-1`.\\n\\n8. It then calls the `solve` function with initial indices `ind1` and `ind2` set to `0`, along with the memoization table `dp`. The result of this call indicates whether it\\'s possible to form `s3` by interleaving `s1` and `s2`.\\n\\n9. The `isInterleave` function returns the result obtained from the `solve` function.\\n\\n# Complexity\\n- Time complexity:$$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![Screenshot (313).png](https://assets.leetcode.com/users/images/e026a7e6-6e21-4d8c-a989-f527ccd022fa_1692933422.857026.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool solve(string &s1, string &s2, string &s3,int ind1,int ind2,vector<vector<int>>&dp)\\n{\\n    if(ind1+ind2==s3.size()) return 1;\\n    if(dp[ind1][ind2]!=-1) return dp[ind1][ind2];\\n    bool ans=0;        \\n    if(ind1<s1.size() && s1[ind1]==s3[ind1+ind2]) \\n    ans=(ans | solve(s1,s2,s3,ind1+1,ind2,dp));\\n    if(ind2<s2.size() && s2[ind2]==s3[ind1+ind2])\\n    ans=(ans | solve(s1,s2,s3,ind1,ind2+1,dp));\\n    return dp[ind1][ind2]=ans;\\n}\\n    bool isInterleave(string s1, string s2, string s3) {\\n         if(s1.size()+s2.size()!=s3.size()) return false;\\n    vector<vector<int>>dp(s1.size()+1,vector<int>(s2.size()+1,-1));\\n    return solve(s1,s2,s3,0,0,dp);\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean solve(String s1, String s2, String s3, int ind1, int ind2, int[][] dp) {\\n        if (ind1 + ind2 == s3.length()) return true;\\n        if (dp[ind1][ind2] != -1) return dp[ind1][ind2] == 1;\\n        boolean ans = false;\\n        \\n        if (ind1 < s1.length() && s1.charAt(ind1) == s3.charAt(ind1 + ind2)) {\\n            ans |= solve(s1, s2, s3, ind1 + 1, ind2, dp);\\n        }\\n        \\n        if (ind2 < s2.length() && s2.charAt(ind2) == s3.charAt(ind1 + ind2)) {\\n            ans |= solve(s1, s2, s3, ind1, ind2 + 1, dp);\\n        }\\n        \\n        dp[ind1][ind2] = ans ? 1 : 0;\\n        return ans;\\n    }\\n    \\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n        for (int i = 0; i <= s1.length(); i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        \\n        return solve(s1, s2, s3, 0, 0, dp);\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def solve(self, s1: str, s2: str, s3: str, ind1: int, ind2: int, dp: List[List[int]]) -> bool:\\n        if ind1 + ind2 == len(s3):\\n            return True\\n        if dp[ind1][ind2] != -1:\\n            return dp[ind1][ind2] == 1\\n        ans = False\\n        \\n        if ind1 < len(s1) and s1[ind1] == s3[ind1 + ind2]:\\n            ans |= self.solve(s1, s2, s3, ind1 + 1, ind2, dp)\\n        \\n        if ind2 < len(s2) and s2[ind2] == s3[ind1 + ind2]:\\n            ans |= self.solve(s1, s2, s3, ind1, ind2 + 1, dp)\\n        \\n        dp[ind1][ind2] = 1 if ans else 0\\n        return ans\\n    \\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        \\n        dp = [[-1] * (len(s2) + 1) for _ in range(len(s1) + 1)]\\n        return self.solve(s1, s2, s3, 0, 0, dp)\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool solve(string &s1, string &s2, string &s3,int ind1,int ind2,vector<vector<int>>&dp)\\n{\\n    if(ind1+ind2==s3.size()) return 1;\\n    if(dp[ind1][ind2]!=-1) return dp[ind1][ind2];\\n    bool ans=0;        \\n    if(ind1<s1.size() && s1[ind1]==s3[ind1+ind2]) \\n    ans=(ans | solve(s1,s2,s3,ind1+1,ind2,dp));\\n    if(ind2<s2.size() && s2[ind2]==s3[ind1+ind2])\\n    ans=(ans | solve(s1,s2,s3,ind1,ind2+1,dp));\\n    return dp[ind1][ind2]=ans;\\n}\\n    bool isInterleave(string s1, string s2, string s3) {\\n         if(s1.size()+s2.size()!=s3.size()) return false;\\n    vector<vector<int>>dp(s1.size()+1,vector<int>(s2.size()+1,-1));\\n    return solve(s1,s2,s3,0,0,dp);\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public boolean solve(String s1, String s2, String s3, int ind1, int ind2, int[][] dp) {\\n        if (ind1 + ind2 == s3.length()) return true;\\n        if (dp[ind1][ind2] != -1) return dp[ind1][ind2] == 1;\\n        boolean ans = false;\\n        \\n        if (ind1 < s1.length() && s1.charAt(ind1) == s3.charAt(ind1 + ind2)) {\\n            ans |= solve(s1, s2, s3, ind1 + 1, ind2, dp);\\n        }\\n        \\n        if (ind2 < s2.length() && s2.charAt(ind2) == s3.charAt(ind1 + ind2)) {\\n            ans |= solve(s1, s2, s3, ind1, ind2 + 1, dp);\\n        }\\n        \\n        dp[ind1][ind2] = ans ? 1 : 0;\\n        return ans;\\n    }\\n    \\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n        for (int i = 0; i <= s1.length(); i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        \\n        return solve(s1, s2, s3, 0, 0, dp);\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def solve(self, s1: str, s2: str, s3: str, ind1: int, ind2: int, dp: List[List[int]]) -> bool:\\n        if ind1 + ind2 == len(s3):\\n            return True\\n        if dp[ind1][ind2] != -1:\\n            return dp[ind1][ind2] == 1\\n        ans = False\\n        \\n        if ind1 < len(s1) and s1[ind1] == s3[ind1 + ind2]:\\n            ans |= self.solve(s1, s2, s3, ind1 + 1, ind2, dp)\\n        \\n        if ind2 < len(s2) and s2[ind2] == s3[ind1 + ind2]:\\n            ans |= self.solve(s1, s2, s3, ind1, ind2 + 1, dp)\\n        \\n        dp[ind1][ind2] = 1 if ans else 0\\n        return ans\\n    \\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        \\n        dp = [[-1] * (len(s2) + 1) for _ in range(len(s1) + 1)]\\n        return self.solve(s1, s2, s3, 0, 0, dp)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247459,
                "title": "easy-understanding-recursion-and-memoization-iterative",
                "content": "**Recursive Solution that gives TLE**\\n```\\nclass Solution {\\npublic:\\n    bool solve(string s1,string s2,string s3,int l1,int l2,int n)\\n    {\\n        if(l1<0&&l2<0&&n<0)\\n        {\\n            return true;\\n        }\\n        if(l1>=0&&s1[l1]==s3[n]&&l2>=0&&s2[l2]==s3[n])\\n        {\\n            return (solve(s1,s2,s3,l1-1,l2,n-1) || solve(s1,s2,s3,l1,l2-1,n-1));\\n        }\\n        else if(l1>=0&&s1[l1]==s3[n])\\n        {\\n            return solve(s1,s2,s3,l1-1,l2,n-1);\\n        }\\n        else if(l2>=0&&s2[l2]==s3[n])\\n        {\\n           return solve(s1,s2,s3,l1,l2-1,n-1);\\n        }\\n        return false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.size()!=s1.size()+s2.size())return false;\\n        return solve(s1,s2,s3,s1.size()-1,s2.size()-1,s3.length()-1);\\n        \\n    }\\n};\\n```\\n\\n**Memoization of the recusive solution: ACCEPTED**\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    bool solve(string s1,string s2,string s3,int l1,int l2,int n)\\n    {\\n        if(l1>=0&&l2>=0 &&dp[l1][l2]!=-1)return dp[l1][l2];\\n        if(l1<0&&l2<0&&n<0)\\n        {\\n            return true;\\n        }\\n        \\n        if(l1>=0&&n>=0&&s1[l1]==s3[n]&&l2>=0&&s2[l2]==s3[n])\\n        {\\n            return dp[l1][l2]=(solve(s1,s2,s3,l1-1,l2,n-1) || solve(s1,s2,s3,l1,l2-1,n-1));\\n        }\\n        else if(l1>=0&&n>=0&&s1[l1]==s3[n])\\n        {\\n            return solve(s1,s2,s3,l1-1,l2,n-1);\\n        }\\n        else if(l2>=0&&n>=0&&s2[l2]==s3[n])\\n        {\\n           return solve(s1,s2,s3,l1,l2-1,n-1);\\n        }\\n        return false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s1,s2,s3,s1.size()-1,s2.size()-1,s3.length()-1);\\n        \\n    }\\n};\\n\\n```\\n**Iterative Using Dp:**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        if(n+m!=s3.length())\\n            return 0;\\n        bool dp[n+1][m+1];\\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0&&j==0)\\n                    dp[i][j]=true;\\n                else if(i==0)\\n                {\\n                    if(s2[j-1]==s3[j-1])\\n                        dp[i][j]=dp[i][j-1];\\n                }\\n                else if(j==0)\\n                {\\n                    if(s1[i-1]==s3[i-1])\\n                        dp[i][j]=dp[i-1][j];\\n                }\\n                else if(s1[i-1]==s3[i+j-1]&&s2[j-1]!=s3[i+j-1])\\n                    dp[i][j]=dp[i-1][j];\\n                \\n                else if(s1[i-1]!=s3[i+j-1]&&s2[j-1]==s3[i+j-1])\\n                    dp[i][j]=dp[i][j-1];\\n                \\n                else if(s1[i-1]==s3[i+j-1]&&s2[j-1]==s3[i+j-1])\\n                    dp[i][j]=(dp[i-1][j] || dp[i][j-1]);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(string s1,string s2,string s3,int l1,int l2,int n)\\n    {\\n        if(l1<0&&l2<0&&n<0)\\n        {\\n            return true;\\n        }\\n        if(l1>=0&&s1[l1]==s3[n]&&l2>=0&&s2[l2]==s3[n])\\n        {\\n            return (solve(s1,s2,s3,l1-1,l2,n-1) || solve(s1,s2,s3,l1,l2-1,n-1));\\n        }\\n        else if(l1>=0&&s1[l1]==s3[n])\\n        {\\n            return solve(s1,s2,s3,l1-1,l2,n-1);\\n        }\\n        else if(l2>=0&&s2[l2]==s3[n])\\n        {\\n           return solve(s1,s2,s3,l1,l2-1,n-1);\\n        }\\n        return false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.size()!=s1.size()+s2.size())return false;\\n        return solve(s1,s2,s3,s1.size()-1,s2.size()-1,s3.length()-1);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    bool solve(string s1,string s2,string s3,int l1,int l2,int n)\\n    {\\n        if(l1>=0&&l2>=0 &&dp[l1][l2]!=-1)return dp[l1][l2];\\n        if(l1<0&&l2<0&&n<0)\\n        {\\n            return true;\\n        }\\n        \\n        if(l1>=0&&n>=0&&s1[l1]==s3[n]&&l2>=0&&s2[l2]==s3[n])\\n        {\\n            return dp[l1][l2]=(solve(s1,s2,s3,l1-1,l2,n-1) || solve(s1,s2,s3,l1,l2-1,n-1));\\n        }\\n        else if(l1>=0&&n>=0&&s1[l1]==s3[n])\\n        {\\n            return solve(s1,s2,s3,l1-1,l2,n-1);\\n        }\\n        else if(l2>=0&&n>=0&&s2[l2]==s3[n])\\n        {\\n           return solve(s1,s2,s3,l1,l2-1,n-1);\\n        }\\n        return false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s1,s2,s3,s1.size()-1,s2.size()-1,s3.length()-1);\\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        if(n+m!=s3.length())\\n            return 0;\\n        bool dp[n+1][m+1];\\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0&&j==0)\\n                    dp[i][j]=true;\\n                else if(i==0)\\n                {\\n                    if(s2[j-1]==s3[j-1])\\n                        dp[i][j]=dp[i][j-1];\\n                }\\n                else if(j==0)\\n                {\\n                    if(s1[i-1]==s3[i-1])\\n                        dp[i][j]=dp[i-1][j];\\n                }\\n                else if(s1[i-1]==s3[i+j-1]&&s2[j-1]!=s3[i+j-1])\\n                    dp[i][j]=dp[i-1][j];\\n                \\n                else if(s1[i-1]!=s3[i+j-1]&&s2[j-1]==s3[i+j-1])\\n                    dp[i][j]=dp[i][j-1];\\n                \\n                else if(s1[i-1]==s3[i+j-1]&&s2[j-1]==s3[i+j-1])\\n                    dp[i][j]=(dp[i-1][j] || dp[i][j-1]);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247753,
                "title": "java-dfs-with-stack-and-memoization",
                "content": "**Here\\'s the overall gist:**\\n* The stack will be used in a similar fashion to a depth-first search. It\\'ll store a series of coordinates corresponding to the indexes of characters in `s1` and `s2`, and traversal will be based on comparison with `s3`.\\n* But wait. These searches often involve graphs, nodes, and edges. How does that apply here?\\n\\n**Here\\'s an illustration of the graph we\\'re traversing:**\\nI\\'ve used example 1 from the problem description here. The solution provided by the example is in bold.\\n![image](https://assets.leetcode.com/users/images/9c0f265e-7eab-44ad-b130-70e13cac1743_1622658517.0783722.png)\\nWith this graph, we can only traverse down and right. A traversal is essentially \"building\" `s3` from `s1` and `s2`: going right corresponds to adding a character from `s1`, and going down adds a character from `s2`. You can think of a coordinate (i, j) representing the ith character in `s1`, and the jth character in `s2`.\\n\\nHow do we know which way to go? We check the next character of `s3`. If it matches the current character at `s1`, we can go right. And if it matches the current character at `s2`, we can go down. We keep going until we can reach the end states for both `s1` and `s2`, or the bottom-rightmost node in our grid, or until we get stuck somewhere.\\n\\nNotice how there are multiple paths we can go in. This is because of the fact that it\\'s sometimes possible that we can pick a valid character from both `s1` and `s2`. This is why we need to perform a search on the entire graph, and this can be done by either using recursion (which is what a lot of the other solutions use), or a stack.\\n\\n**Our overall algorithm:**\\nHere\\'s a brief recap of our algorithm. At a worst case scenario, we end up visiting every node. This gives us a time complexity of **O(m * n)**, where m and n are the lengths of each string.\\n* Add (0, 0) to our stack.\\n* Perform a DFS on the graph. With a stack, this is what it looks like:\\n\\t* Pop the topmost coordinates (i, j) off the stack and record it in our `visited` boolean matrix.\\n\\t* Check if our coordinates are at the bottom right, and return `true` if so.\\n\\t* Otherwise, check if we can traverse further.\\n\\t\\t* If the ith character in `s1` matches the next character in `s3` and if (i + 1, j) hasn\\'t been visited, push that onto the stack.\\n\\t\\t* If the jth character in `s2` matches the next character in `s3` and if (i, j + 1) hasn\\'t been visited, push that onto the stack.\\n\\t* Rinse and repeat. If we empty out the stack, our search is unsuccessful so we return `false`.\\n\\nHere\\'s a commented version of my code in Java. I encourage you to give it a shot first :)\\n```\\nimport java.util.Stack;\\n\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length())\\n            return false;\\n        \\n        // coordinates are of the form [i, j], corresponding to the indexes in s1, s2\\n        Stack<int[]> stack = new Stack<int[]>();\\n        stack.push(new int[] {0, 0});\\n\\t\\t\\n        boolean[][] visited = new boolean[s1.length() + 1][s2.length() + 1];\\n        \\n        while (!stack.empty()) {\\n            int[] indexes = stack.pop();\\n            int i = indexes[0], j = indexes[1];\\n            visited[i][j] = true;\\n\\t\\t\\t\\n\\t\\t\\t// we\\'re at the bottom-rightmost coordinate; we\\'re done!\\n            if (i == s1.length() && j == s2.length())\\n                return true;\\n            \\n\\t\\t\\t// check if we can increment i (traveling right on the graph)\\n            if (i < s1.length() && !visited[i + 1][j] && s1.charAt(i) == s3.charAt(i + j))\\n                stack.push(new int[] {i + 1, j});\\n            \\n\\t\\t\\t// check if we can increment j (traveling down on the graph)\\n            if (j < s2.length() && !visited[i][j + 1] && s2.charAt(j) == s3.charAt(i + j))\\n                stack.push(new int[] {i, j + 1});\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nimport java.util.Stack;\\n\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length())\\n            return false;\\n        \\n        // coordinates are of the form [i, j], corresponding to the indexes in s1, s2\\n        Stack<int[]> stack = new Stack<int[]>();\\n        stack.push(new int[] {0, 0});\\n\\t\\t\\n        boolean[][] visited = new boolean[s1.length() + 1][s2.length() + 1];\\n        \\n        while (!stack.empty()) {\\n            int[] indexes = stack.pop();\\n            int i = indexes[0], j = indexes[1];\\n            visited[i][j] = true;\\n\\t\\t\\t\\n\\t\\t\\t// we\\'re at the bottom-rightmost coordinate; we\\'re done!\\n            if (i == s1.length() && j == s2.length())\\n                return true;\\n            \\n\\t\\t\\t// check if we can increment i (traveling right on the graph)\\n            if (i < s1.length() && !visited[i + 1][j] && s1.charAt(i) == s3.charAt(i + j))\\n                stack.push(new int[] {i + 1, j});\\n            \\n\\t\\t\\t// check if we can increment j (traveling down on the graph)\\n            if (j < s2.length() && !visited[i][j + 1] && s2.charAt(j) == s3.charAt(i + j))\\n                stack.push(new int[] {i, j + 1});\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250195,
                "title": "java-4-solutions-recursion-memoization-dp",
                "content": "\\n**Solution 1: Brute Force (Recursion) - Time Limit Exceeded**\\n\\n```\\n// Time complexity: O(2^(m+n))\\n// Space complexity: O(m+n)\\n\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\t\\n\\treturn helper(s1, s2, s3, 0, 0);\\n}\\n\\npublic boolean helper(String s1, String s2, String s3, int i, int j) {\\n\\tif(i+j == s3.length())\\n\\t\\treturn true;\\n\\t\\n\\tif(i < s1.length() && s3.charAt(i+j) == s1.charAt(i)) {\\n\\t\\tboolean flag = helper(s1, s2, s3, i+1, j);\\n\\t\\tif(flag)\\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\tif(j < s2.length() && s3.charAt(i+j) == s2.charAt(j)) {\\n\\t\\tboolean flag = helper(s1, s2, s3, i, j+1);\\n\\t\\tif(flag)\\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\treturn false;\\n}\\n```\\n\\n**Solution 2: Top Down DP (Recursion + Memoization)**\\n\\n```\\n// Time complexity: O(m*n)\\n// Space complexity: O(m*n)\\n\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tBoolean[][] memo = new Boolean[s1.length() + 1][s2.length() + 1];\\n\\n\\treturn helper(s1, s2, s3, 0, 0, memo);\\n}\\n\\npublic boolean helper(String s1, String s2, String s3, int i, int j, Boolean[][] memo) {\\n\\tif(i+j == s3.length())\\n\\t\\treturn true;\\n\\n\\tif(memo[i][j] != null)\\n\\t\\treturn memo[i][j];\\n\\n\\t if(i < s1.length() && s3.charAt(i+j) == s1.charAt(i)) {\\n\\t\\tboolean flag = helper(s1, s2, s3, i+1, j, memo);\\n\\t\\tmemo[i][j] = flag;\\n\\t\\tif(flag) \\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\tif(j < s2.length() && s3.charAt(i+j) == s2.charAt(j)) {\\n\\t\\tboolean flag = helper(s1, s2, s3, i, j+1, memo);\\n\\t\\tmemo[i][j] = flag;\\n\\t\\tif(flag) \\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\tmemo[i][j] = false;\\n\\treturn false;\\n}\\n```\\n\\n**Solution 3: Bottom UP DP (2D)**\\n\\n```\\n// Time complexity: O(m*n)\\n// Space complexity: O(m*n)\\n\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tboolean dp[][] = new boolean[s1.length() + 1][s2.length() + 1];\\n\\n\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\tif (i == 0 && j == 0) \\n\\t\\t\\t\\tdp[i][j] = true;\\n\\t\\t\\n\\t\\t\\telse if (i == 0) \\n\\t\\t\\t\\tdp[i][j] = dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse if (j == 0) \\n\\t\\t\\t\\tdp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) \\n\\t\\t\\t\\t\\t\\t\\t\\t|| (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[s1.length()][s2.length()];\\n}\\n```\\n\\n**Solution 4: Bottom UP DP (1D)**\\n\\n```\\n// Time complexity: O(m*n)\\n// Space complexity: O(n)\\n\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tboolean dp[] = new boolean[s2.length() + 1];\\n\\n\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\tif (i == 0 && j == 0) \\n\\t\\t\\t\\tdp[j] = true;\\n\\n\\t\\t\\telse if (i == 0) \\n\\t\\t\\t\\tdp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse if (j == 0) \\n\\t\\t\\t\\tdp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) \\n\\t\\t\\t\\t\\t\\t\\t|| (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[s2.length()];\\n}\\n```\\n\\nPlease upvote if you find it useful.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Time complexity: O(2^(m+n))\\n// Space complexity: O(m+n)\\n\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\t\\n\\treturn helper(s1, s2, s3, 0, 0);\\n}\\n\\npublic boolean helper(String s1, String s2, String s3, int i, int j) {\\n\\tif(i+j == s3.length())\\n\\t\\treturn true;\\n\\t\\n\\tif(i < s1.length() && s3.charAt(i+j) == s1.charAt(i)) {\\n\\t\\tboolean flag = helper(s1, s2, s3, i+1, j);\\n\\t\\tif(flag)\\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\tif(j < s2.length() && s3.charAt(i+j) == s2.charAt(j)) {\\n\\t\\tboolean flag = helper(s1, s2, s3, i, j+1);\\n\\t\\tif(flag)\\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\treturn false;\\n}\\n```\n```\\n// Time complexity: O(m*n)\\n// Space complexity: O(m*n)\\n\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tBoolean[][] memo = new Boolean[s1.length() + 1][s2.length() + 1];\\n\\n\\treturn helper(s1, s2, s3, 0, 0, memo);\\n}\\n\\npublic boolean helper(String s1, String s2, String s3, int i, int j, Boolean[][] memo) {\\n\\tif(i+j == s3.length())\\n\\t\\treturn true;\\n\\n\\tif(memo[i][j] != null)\\n\\t\\treturn memo[i][j];\\n\\n\\t if(i < s1.length() && s3.charAt(i+j) == s1.charAt(i)) {\\n\\t\\tboolean flag = helper(s1, s2, s3, i+1, j, memo);\\n\\t\\tmemo[i][j] = flag;\\n\\t\\tif(flag) \\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\tif(j < s2.length() && s3.charAt(i+j) == s2.charAt(j)) {\\n\\t\\tboolean flag = helper(s1, s2, s3, i, j+1, memo);\\n\\t\\tmemo[i][j] = flag;\\n\\t\\tif(flag) \\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\tmemo[i][j] = false;\\n\\treturn false;\\n}\\n```\n```\\n// Time complexity: O(m*n)\\n// Space complexity: O(m*n)\\n\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tboolean dp[][] = new boolean[s1.length() + 1][s2.length() + 1];\\n\\n\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\tif (i == 0 && j == 0) \\n\\t\\t\\t\\tdp[i][j] = true;\\n\\t\\t\\n\\t\\t\\telse if (i == 0) \\n\\t\\t\\t\\tdp[i][j] = dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse if (j == 0) \\n\\t\\t\\t\\tdp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) \\n\\t\\t\\t\\t\\t\\t\\t\\t|| (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[s1.length()][s2.length()];\\n}\\n```\n```\\n// Time complexity: O(m*n)\\n// Space complexity: O(n)\\n\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tboolean dp[] = new boolean[s2.length() + 1];\\n\\n\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\tif (i == 0 && j == 0) \\n\\t\\t\\t\\tdp[j] = true;\\n\\n\\t\\t\\telse if (i == 0) \\n\\t\\t\\t\\tdp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse if (j == 0) \\n\\t\\t\\t\\tdp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) \\n\\t\\t\\t\\t\\t\\t\\t|| (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[s2.length()];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32076,
                "title": "simple-python-dp-solution",
                "content": "Keep two points on `s1` and `s2` and traverse `s3`, the current char in `s3` is either from `s1` or `s2` or both. Use a **set** to record all possibility and dp on.\\n\\nThe key here is to use a set to record the pointers, because duplicates are possible, using a list cause TLE.\\n     \\n    def isInterleave(self, s1, s2, s3):\\n        l1, l2 = len(s1), len(s2)\\n        if l1 + l2 != len(s3):\\n            return False\\n        \\n        last = set([(0, 0)])\\n        for char in s3:\\n            current = set()\\n            for i, j in last:\\n                if i < l1 and s1[i] == char:\\n                    current.add((i + 1, j))\\n                if j < l2 and s2[j] == char:\\n                    current.add((i, j + 1))\\n            if not current:\\n                return False\\n            last = current\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "Keep two points on `s1` and `s2` and traverse `s3`, the current char in `s3` is either from `s1` or `s2` or both. Use a **set** to record all possibility and dp on.\\n\\nThe key here is to use a set to record the pointers, because duplicates are possible, using a list cause TLE.\\n     \\n    def isInterleave(self, s1, s2, s3):\\n        l1, l2 = len(s1), len(s2)\\n        if l1 + l2 != len(s3):\\n            return False\\n        \\n        last = set([(0, 0)])\\n        for char in s3:\\n            current = set()\\n            for i, j in last:\\n                if i < l1 and s1[i] == char:\\n                    current.add((i + 1, j))\\n                if j < l2 and s2[j] == char:\\n                    current.add((i, j + 1))\\n            if not current:\\n                return False\\n            last = current\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 31989,
                "title": "share-my-analysis-of-this-problem-from-recursion-to-dp-java",
                "content": "public class Solution {\\n\\nFor this problem, we are trying to see if we can obtain s3 by interleaving s1 and s2. In other words, we need to figure out where each char of s3 comes from, s1 or s2 or nowhere. If we can find a way that all of the chars of s3 comes from s1 or s2, then we can form s3 by interleaving s1 and s2, and thus return true; otherwise we return false. For example, if s1 = abc, s2 = bcd, s3 = abbccd, then s3 can be formed by \"001011\" or \"010101\". (0 represents char comes from s1, and 1 represents char comes from s2). \\n\\nIt is easy to come up with a solution using recursion.\\n\\npublic class Solution {\\n\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s1 == null || s1.length() == 0) {return s2.equals(s3);}\\n        if(s2 == null || s2.length() == 0) {return s1.equals(s3);}\\n        if(s3.charAt(0) == s1.charAt(0) && s3.charAt(0) == s2.charAt(0)){\\n            return isInterleave(s1.substring(1), s2, s3.substring(1)) || isInterleave(s1, s2.substring(1), s3.substring(1));\\n        }\\n        else if(s3.charAt(0) == s1.charAt(0)){\\n            return isInterleave(s1.substring(1), s2, s3.substring(1));\\n        }\\n        else if(s3.charAt(0) == s2.charAt(0)){\\n            return isInterleave(s1, s2.substring(1), s3.substring(1));\\n        }\\n        return false;\\n    }\\n\\n}\\n\\nBut this solution takes exponential time, because each position have two choices, a length of n of s3 would have 2^n choices need to check. Thus, we think of  DP, because it can reduce exponential time to polynomial time, and it applies to the problem that have many subproblems. \\n\\nWe create a boolean table called pathTable, and each cell of pathTable[i][j] represents whether we can form s3.substring(0, i+j) using the first s1.substring(0, i) and s2.substring(0, j). Thus, if pathTable[pathTable.length - 1][pathTable[0].length - 1] is true, it means there is a path from pathTable[0][0] to it. In other words, s3 can be formed by s1 and s2. \\n\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if((s1 == null || s1.length() == 0) && (s2 == null || s2.length() == 0)){ \\n            return s3 == null || s3.length() == 0;\\n        }\\n        if(s1 == null || s1.length() == 0){ return s2.equals(s3);}\\n        if(s2 == null || s2.length() == 0){ return s1.equals(s3);}\\n        if(s1.length() + s2.length() != s3.length()){ return false;}\\n        \\n        boolean pathTable[][] = new boolean[s1.length() + 1][s2.length() + 1];// would be false by default.\\n        pathTable[0][0] = true;\\n        \\n        for(int i = 1; i < pathTable.length; i++){\\n            if(pathTable[i-1][0] && s1.charAt(i-1) == s3.charAt(i-1)){\\n                pathTable[i][0] = true;\\n            }\\n        }\\n        for(int j = 1; j < pathTable[0].length; j++){\\n            if(pathTable[0][j-1] && s2.charAt(j-1) == s3.charAt(j-1)){\\n                pathTable[0][j] = true;\\n            }\\n        }\\n        for(int i = 1; i < pathTable.length; i++){\\n            for(int j = 1; j < pathTable[0].length; j++){\\n                if(pathTable[i-1][j] && s1.charAt(i-1) == s3.charAt(i+j-1)){\\n                    pathTable[i][j] = true;\\n                }\\n                else if(pathTable[i][j-1] && s2.charAt(j-1) == s3.charAt(i+j-1)){\\n                    pathTable[i][j] = true;\\n                }\\n            }\\n        }\\n        return pathTable[pathTable.length - 1][pathTable[0].length - 1];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\nFor this problem, we are trying to see if we can obtain s3 by interleaving s1 and s2. In other words, we need to figure out where each char of s3 comes from, s1 or s2 or nowhere. If we can find a way that all of the chars of s3 comes from s1 or s2, then we can form s3 by interleaving s1 and s2, and thus return true; otherwise we return false. For example, if s1 = abc, s2 = bcd, s3 = abbccd, then s3 can be formed by \"001011\" or \"010101\". (0 represents char comes from s1, and 1 represents char comes from s2). \\n\\nIt is easy to come up with a solution using recursion.\\n\\npublic class Solution {\\n\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s1 == null || s1.length() == 0) {return s2.equals(s3);}",
                "codeTag": "Java"
            },
            {
                "id": 2248599,
                "title": "memoization-tabulation-space-optimization-c-dp-all-three-approach",
                "content": "# **C++ DP All Three Approach**\\n# 1. **C++ Memoization Solution**\\n```\\nclass Solution {\\npublic:\\n    bool rec(string s1,string s2,string s3,int i,int j,int k,vector<vector<int>>&dp){\\n        if(k==s3.size()&&i==s1.size()&&j==s2.size())return true;\\n        if(i>s1.size()||j>s2.size())return false;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s3[k]==s2[j]&&s3[k]==s1[i]){\\n            return dp[i][j]= rec(s1,s2,s3,i+1,j,k+1,dp)||rec(s1,s2,s3,i,j+1,k+1,dp);\\n        }\\n        else if(s1[i]==s3[k]){\\n            return dp[i][j]= rec(s1,s2,s3,i+1,j,k+1,dp);\\n        }\\n        else if(s3[k]==s2[j]){\\n            return dp[i][j]= rec(s1,s2,s3,i,j+1,k+1,dp);\\n        }\\n        else{\\n            return dp[i][j]= false;\\n        }\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        vector<vector<int>>dp(s1.size()+1,(vector<int>(s2.size()+1,-1)));\\n        return rec(s1,s2,s3,0,0,0,dp);\\n    }\\n};\\n```\\n# 2. **C++ Solution of DP Tabulation**\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        vector<vector<int>>dp(s1.size()+1,(vector<int>(s2.size()+1,0)));\\n        if(s3.size()!=s1.size()+s2.size()){\\n            return false;\\n        }\\n        for(int i=s1.size();i>=0;i--){\\n            for(int j=s2.size();j>=0;j--){\\n                int k=i+j;\\n                if(i==s1.size()&&j==s2.size()){\\n                    dp[i][j]=1;\\n                }\\n                else if(s3[k]==s2[j]&&s3[k]==s1[i]){\\n                    dp[i][j]= dp[i+1][j]||dp[i][j+1];\\n                }\\n                else if(s1[i]==s3[k]){\\n                    dp[i][j]= dp[i+1][j];\\n                }\\n                else if(s3[k]==s2[j]){\\n                    dp[i][j]= dp[i][j+1];\\n                }\\n                else{\\n                    dp[i][j]= false;\\n                }  \\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n# 3. **C++ Solution of Space Optimization**\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        vector<int>cur(s2.size()+1,0),prev(s2.size()+1,0);\\n        if(s3.size()!=s1.size()+s2.size()){\\n            return false;\\n        }\\n        for(int i=s1.size();i>=0;i--){\\n            for(int j=s2.size();j>=0;j--){\\n                int k=i+j;\\n                if(i==s1.size()&&j==s2.size()){\\n                    cur[j]=1;\\n                }\\n                else if(s3[k]==s2[j]&&s3[k]==s1[i]){\\n                    cur[j]= prev[j]||cur[j+1];\\n                }\\n                else if(s1[i]==s3[k]){\\n                    cur[j]= prev[j];\\n                }\\n                else if(s3[k]==s2[j]){\\n                    cur[j]= cur[j+1];\\n                }\\n                else{\\n                    cur[j]= false;\\n                }  \\n            }\\n            prev=cur;\\n        }\\n        return cur[0];\\n    }\\n};\\n```\\n# **Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool rec(string s1,string s2,string s3,int i,int j,int k,vector<vector<int>>&dp){\\n        if(k==s3.size()&&i==s1.size()&&j==s2.size())return true;\\n        if(i>s1.size()||j>s2.size())return false;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s3[k]==s2[j]&&s3[k]==s1[i]){\\n            return dp[i][j]= rec(s1,s2,s3,i+1,j,k+1,dp)||rec(s1,s2,s3,i,j+1,k+1,dp);\\n        }\\n        else if(s1[i]==s3[k]){\\n            return dp[i][j]= rec(s1,s2,s3,i+1,j,k+1,dp);\\n        }\\n        else if(s3[k]==s2[j]){\\n            return dp[i][j]= rec(s1,s2,s3,i,j+1,k+1,dp);\\n        }\\n        else{\\n            return dp[i][j]= false;\\n        }\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        vector<vector<int>>dp(s1.size()+1,(vector<int>(s2.size()+1,-1)));\\n        return rec(s1,s2,s3,0,0,0,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        vector<vector<int>>dp(s1.size()+1,(vector<int>(s2.size()+1,0)));\\n        if(s3.size()!=s1.size()+s2.size()){\\n            return false;\\n        }\\n        for(int i=s1.size();i>=0;i--){\\n            for(int j=s2.size();j>=0;j--){\\n                int k=i+j;\\n                if(i==s1.size()&&j==s2.size()){\\n                    dp[i][j]=1;\\n                }\\n                else if(s3[k]==s2[j]&&s3[k]==s1[i]){\\n                    dp[i][j]= dp[i+1][j]||dp[i][j+1];\\n                }\\n                else if(s1[i]==s3[k]){\\n                    dp[i][j]= dp[i+1][j];\\n                }\\n                else if(s3[k]==s2[j]){\\n                    dp[i][j]= dp[i][j+1];\\n                }\\n                else{\\n                    dp[i][j]= false;\\n                }  \\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        vector<int>cur(s2.size()+1,0),prev(s2.size()+1,0);\\n        if(s3.size()!=s1.size()+s2.size()){\\n            return false;\\n        }\\n        for(int i=s1.size();i>=0;i--){\\n            for(int j=s2.size();j>=0;j--){\\n                int k=i+j;\\n                if(i==s1.size()&&j==s2.size()){\\n                    cur[j]=1;\\n                }\\n                else if(s3[k]==s2[j]&&s3[k]==s1[i]){\\n                    cur[j]= prev[j]||cur[j+1];\\n                }\\n                else if(s1[i]==s3[k]){\\n                    cur[j]= prev[j];\\n                }\\n                else if(s3[k]==s2[j]){\\n                    cur[j]= cur[j+1];\\n                }\\n                else{\\n                    cur[j]= false;\\n                }  \\n            }\\n            prev=cur;\\n        }\\n        return cur[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248268,
                "title": "js-python-java-c-easy-dp-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIf we consider a matrix with indices (**i**) for **s1** on one axis and indices (**j**) for **s2** on the other, then a successful **s3** can be considered a path moving from the top left to the bottom right. At each point, we either move downward (**i++**) by choosing the next letter from **s1** or rightward (**j++**) by choosing the next letter from **s2**.\\n\\nAll that remains, then, is to see which vertices are possible given **s3**, and which ones are not. To do that, we can use a **dynamic programming** (**DP**) approach. Normally, we would establish a matrix as described above, along with a buffer row/column at the start of the matrix to provide space for previous row/column validation checks for the leading edges of our iteration. An additional row/column at the end of the matrix is also needed, since our final checks will occur only _after_ the strings are completed.\\n\\nWe can reduce the **space complexity** of this solution from **O(N * M)** to just **O(M)**, however, if rather than building a full DP matrix, we instead only keep the current row of the matrix (**dp**) in memory, reiterating through it for each row. The **left** value (**dp[j-1]**) will already have been calculated, and the **up** value (**dp[j]**) will not yet have been overwritten in the current cell, so it will still represent the value of the cell from the previous row.\\n\\nWe should also remember to fill **dp[1]** with a **true** (or **1**) value, representing a valid vertex at the starting position of our iteration path.\\n\\nFrom there, we can iterate through the rows, building upon previously completed entries to check the validity of the current cell. If the cell \"above\" (the not-yet-overwritten **dp[i]** represents the same index from the row above) is valid (**true** or **1**) and the corresponding characters of **s1** and **s3** match, then the current cell is valid. Similarly, if the cell to the left is valid and the corresponding characters of **s2** and **s3** match, then the current cell is valid.\\n\\nOnce we\\'ve finished iterating through **i** and **j**, a valid value in the last cell of **dp** will indicate that a valid path exists that matches **s3**, so we can just **return** the contents of that cell.\\n\\n - _**Time Complexity: O(N * M)** where **N** is the length of **s1** and **M** is the length of **s2**_\\n - _**Space Complexity: O(M)** for **dp**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 38.7MB** (beats 99% / 93%).\\n```javascript\\nvar isInterleave = function(s1, s2, s3) {\\n    let n = s1.length + 2, m = s2.length + 2\\n    if (n + m - 4 !== s3.length) return false\\n    let dp = new Uint8Array(m)\\n    dp[1] = 1\\n    for (let i = 1; i < n; i++)\\n        for (let j = 1; j < m; j++) {\\n            let up = dp[j] && s1[i-2] === s3[j+i-3],\\n                left = dp[j-1] && s2[j-2] === s3[j+i-3]\\n            dp[j] = up || left\\n        }\\n    return dp[m-1]\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **36ms / 14.2MB** (beats 61% / 96%).\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        n, m = len(s1) + 2, len(s2) + 2\\n        if n + m - 4 != len(s3): return False\\n        dp = [0] * m\\n        dp[1] = 1\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                up = dp[j] and (i < 2 or s1[i-2] == s3[j+i-3])\\n                left = dp[j-1] and (j < 2 or s2[j-2] == s3[j+i-3])\\n                dp[j] = up or left\\n        return dp[-1]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **2ms / 36.7MB** (beats 80% / 98%).\\n```java\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int n = s1.length() + 2, m = s2.length() + 2;\\n        char[] sc1 = s1.toCharArray(), sc2 = s2.toCharArray(), sc3 = s3.toCharArray();\\n        if (n + m - 4 != s3.length()) return false;\\n        boolean[] dp = new boolean[m];\\n        dp[1] = true;\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++) {\\n                boolean up = dp[j] && (i < 2 || sc1[i-2] == sc3[j+i-3]),\\n                    left =dp[j-1] && (j < 2 || sc2[j-2] == sc3[j+i-3]);\\n                dp[j] = up || left;\\n            }\\n        return dp[m-1];\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 6.6MB** (beats 100% / 61%).\\n```c++\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.length() + 2, m = s2.length() + 2;\\n        if (n + m - 4 != s3.length()) return false;\\n        vector<bool> dp(m);\\n        dp[1] = true;\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++) {\\n                bool up = dp[j] && (i < 2 || s1[i-2] == s3[j+i-3]),\\n                    left = dp[j-1] && (j < 2 || s2[j-2] == s3[j+i-3]);\\n               dp[j] = up || left;\\n            }\\n        return dp[m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar isInterleave = function(s1, s2, s3) {\\n    let n = s1.length + 2, m = s2.length + 2\\n    if (n + m - 4 !== s3.length) return false\\n    let dp = new Uint8Array(m)\\n    dp[1] = 1\\n    for (let i = 1; i < n; i++)\\n        for (let j = 1; j < m; j++) {\\n            let up = dp[j] && s1[i-2] === s3[j+i-3],\\n                left = dp[j-1] && s2[j-2] === s3[j+i-3]\\n            dp[j] = up || left\\n        }\\n    return dp[m-1]\\n};\\n```\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        n, m = len(s1) + 2, len(s2) + 2\\n        if n + m - 4 != len(s3): return False\\n        dp = [0] * m\\n        dp[1] = 1\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                up = dp[j] and (i < 2 or s1[i-2] == s3[j+i-3])\\n                left = dp[j-1] and (j < 2 or s2[j-2] == s3[j+i-3])\\n                dp[j] = up or left\\n        return dp[-1]\\n```\n```java\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int n = s1.length() + 2, m = s2.length() + 2;\\n        char[] sc1 = s1.toCharArray(), sc2 = s2.toCharArray(), sc3 = s3.toCharArray();\\n        if (n + m - 4 != s3.length()) return false;\\n        boolean[] dp = new boolean[m];\\n        dp[1] = true;\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++) {\\n                boolean up = dp[j] && (i < 2 || sc1[i-2] == sc3[j+i-3]),\\n                    left =dp[j-1] && (j < 2 || sc2[j-2] == sc3[j+i-3]);\\n                dp[j] = up || left;\\n            }\\n        return dp[m-1];\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.length() + 2, m = s2.length() + 2;\\n        if (n + m - 4 != s3.length()) return false;\\n        vector<bool> dp(m);\\n        dp[1] = true;\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++) {\\n                bool up = dp[j] && (i < 2 || s1[i-2] == s3[j+i-3]),\\n                    left = dp[j-1] && (j < 2 || s2[j-2] == s3[j+i-3]);\\n               dp[j] = up || left;\\n            }\\n        return dp[m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249641,
                "title": "c-based-on-aditya-verma-concept-recursion-memoization",
                "content": "**Plz Upvote!**! You will loose nothing ):):\\n\\n```\\nclass Solution {\\n  public:\\n    int dp[102][102];\\n  bool solve(string s1, string s2, string s3, int x, int y, int z) {\\n    if (x < 0 and y < 0 and z < 0) return true;\\n    if (x >= 0 and y >= 0 and dp[x][y] != -1) return dp[x][y];\\n    if (x >= 0 and s1[x] == s3[z] and y >= 0 and s2[y] == s3[z])\\n      return dp[x][y] = solve(s1, s2, s3, x - 1, y, z - 1) or solve(s1, s2, s3, x, y - 1, z - 1);\\n    else if (x >= 0 and s1[x] == s3[z])\\n      return solve(s1, s2, s3, x - 1, y, z - 1);\\n    else if (y >= 0 and s2[y] == s3[z])\\n      return solve(s1, s2, s3, x, y - 1, z - 1);\\n    else\\n      return false;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n    memset(dp, -1, sizeof(dp));\\n    int x = s1.size(), y = s2.size(), z = s3.size();\\n    if (x + y != z) return false;\\n    return solve(s1, s2, s3, x - 1, y - 1, z - 1);\\n  }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n  public:\\n    int dp[102][102];\\n  bool solve(string s1, string s2, string s3, int x, int y, int z) {\\n    if (x < 0 and y < 0 and z < 0) return true;\\n    if (x >= 0 and y >= 0 and dp[x][y] != -1) return dp[x][y];\\n    if (x >= 0 and s1[x] == s3[z] and y >= 0 and s2[y] == s3[z])\\n      return dp[x][y] = solve(s1, s2, s3, x - 1, y, z - 1) or solve(s1, s2, s3, x, y - 1, z - 1);\\n    else if (x >= 0 and s1[x] == s3[z])\\n      return solve(s1, s2, s3, x - 1, y, z - 1);\\n    else if (y >= 0 and s2[y] == s3[z])\\n      return solve(s1, s2, s3, x, y - 1, z - 1);\\n    else\\n      return false;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1246668,
                "title": "c-super-short-and-easy-dp-clean-solutions-1d-2d",
                "content": "**Solution I - Using 2D Dynamic Programming Array**\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        #define S1 (dp[i-1][j] && s1[i-1] == s3[i+j-1])\\n        #define S2 (dp[i][j-1] && s2[j-1] == s3[i+j-1])\\n        \\n        int n = s1.size(), m = s2.size(), k = s3.size();\\n        if (n + m != k) return false;\\n        vector<vector<bool>> dp(n+1, vector<bool>(m+1, 0));\\n        \\n        for (int i = 0; i <= n; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                dp[i][j] = (i==0 && j==0) ? true : i==0 ? S2 : j==0 ? S1 : S1 || S2;\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```\\n****\\n**Solution II - Using 1D Array**\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        #define S1 (dp[j] && s1[i-1] == s3[i+j-1])\\n        #define S2 (dp[j-1] && s2[j-1] == s3[i+j-1])\\n        \\n        int n = s1.size(), m = s2.size(), k = s3.size();\\n        if (n + m != k) return false;\\n        vector<bool> dp(m+1, 0);\\n        \\n        for (int i = 0; i <= n; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                dp[j] = (i==0 && j==0) ? true : i==0 ? S2 : j==0 ? S1 : S1 || S2;\\n            }\\n        }\\n\\n        return dp[m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        #define S1 (dp[i-1][j] && s1[i-1] == s3[i+j-1])\\n        #define S2 (dp[i][j-1] && s2[j-1] == s3[i+j-1])\\n        \\n        int n = s1.size(), m = s2.size(), k = s3.size();\\n        if (n + m != k) return false;\\n        vector<vector<bool>> dp(n+1, vector<bool>(m+1, 0));\\n        \\n        for (int i = 0; i <= n; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                dp[i][j] = (i==0 && j==0) ? true : i==0 ? S2 : j==0 ? S1 : S1 || S2;\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        #define S1 (dp[j] && s1[i-1] == s3[i+j-1])\\n        #define S2 (dp[j-1] && s2[j-1] == s3[i+j-1])\\n        \\n        int n = s1.size(), m = s2.size(), k = s3.size();\\n        if (n + m != k) return false;\\n        vector<bool> dp(m+1, 0);\\n        \\n        for (int i = 0; i <= n; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                dp[j] = (i==0 && j==0) ? true : i==0 ? S2 : j==0 ? S1 : S1 || S2;\\n            }\\n        }\\n\\n        return dp[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249302,
                "title": "c-3-approaches-dynamic-programming-easy-explaination",
                "content": "**Interleaving String**\\n<img src=\"https://assets.leetcode.com/users/images/c226f83a-6580-4772-87e7-bda924c43e8e_1657173986.7404857.png?raw=true\" width=\"800px\" height=\"400px\" alt=\"R8_gcn_test\" align=center />\\n\\n\\n\\n\\nAs problem name suggest we need to check interleaving of strings in another string and if it\\'s not the case then return false. \\n\\nWe can try on 3 approaches : 1. Bruteforce 2. Iterative / Recursive 3. Dynamic programming\\n\\n**Bruteforce approach 1** :   TLE \\uD83D\\uDE36\\n\\nC++ || PYTHON\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size(), n = s2.size(), k = s3.size();\\n        if (m + n != k) return false;\\n            while(m > 0 && n > 0 && s1[m-1] == s2[n-1] && s1[m-1] == s3[k-1]) {\\n                m--;\\n                n--;\\n                k--;\\n            }\\n            while(m > 0 && s1[m-1] == s3[k-1]) {\\n                m--;\\n                k--;\\n            }\\n            while(n > 0 && s2[n-1] == s3[k-1]) {\\n                n--;\\n                k--;\\n            }\\n            if (m == 0 && n == 0) return true;\\n            if (m == 0) return s2.substr(0, n) == s3.substr(0, n);\\n            if (n == 0) return s1.substr(0, m) == s3.substr(0, m);\\n            return s1.substr(0, m) == s3.substr(0, m) && s2.substr(0, n) == s3.substr(m, n);     \\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3):\\n        f1 = list(s1)\\n        f2 = list(s2)\\n        f3 = list(s3)\\n\\n        if len(f1) + len(f2) != len(f3):\\n            return False\\n\\n        if len(f1) == 0:\\n            return f2 == f3\\n\\n        if len(f2) == 0:\\n            return f1 == f3\\n\\n        if len(f1) == 1:\\n            return f1[0] == f3[0] and f2 == f3[1:]\\n\\n        if len(f2) == 1:\\n            return f1 == f3[0:] and f2[0] == f3[-1]\\n\\n\\n        for i in range(len(f1)):\\n            if f1[i] not in f3:\\n                return False\\n\\n        for i in range(len(f2)):\\n            if f2[i] not in f3:\\n                return False\\n        \\n        i =0\\n\\n        while(i != len(s3)):\\n            if s1[i] == s3[i]:\\n                i += 1\\n            if s2[i] == s3[i]:\\n                i += 1\\n            \\n            if s1[i] != s3[i] or s2[i] != s3[i]:\\n                return False\\n        \\n        return True \\n```\\n\\n**Approach 2 Iterative** \\n\\nFor recursive approach we will use same manner as we did in bruteforce but here the stopping condition will work for us :\\n\\nWe will call the function by comparing between the string s1 and s2 whether they are folowing the order or not. \\n\\n**Time complexity** : O(2^m+n) where m & n are size of both strings \\n\\nexponential of 2 as each character in s3 has 2 option everytime it is moving. \\n\\n C++ || Python\\n \\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size(), n = s2.size(), k = s3.size();\\n        if (m + n != k) return false;\\n        while(m > 0 && n > 0 && s1[m-1] == s2[n-1] && s1[m-1] == s3[k-1]) {\\n            m--;\\n            n--;\\n            k--;\\n        }\\n        if (m == 0 && n == 0) return true;\\n        if (m == 0) return s2.substr(0, n) == s3.substr(0, n);\\n        if (n == 0) return s1.substr(0, m) == s3.substr(0, m);\\n        if (s1[m-1] == s3[k-1]) return isInterleave(s1.substr(0, m-1), s2, s3.substr(0, k-1));\\n\\n        if (s2[n-1] == s3[k-1]) return isInterleave(s1, s2.substr(0, n-1), s3.substr(0, k-1));\\n        return false;\\n    }\\n};\\n```\\n\\n \\n \\n```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3):\\n        if len(s1) + len(s2) !=len(s3):\\n            return False\\n\\n        if len(s1) == 0:\\n            return s2 == s3\\n        if len(s2) == 0:\\n            return s1 == s3\\n\\n        if s1[0] == s2[0] and s1[0] == s3[0]:\\n            return self.isInterleave(s1[1:], s2, s3[1:]) or self.isInterleave(s1, s2[1:], s3[1:])\\n        elif s1[0] == s3[0]:\\n            return self.isInterleave(s1[1:], s2, s3[1:])\\n        elif s2[0] == s3[0]:\\n            return self.isInterleave(s1, s2[1:], s3[1:])\\n        else:\\n            return False\\n```\\n\\n**Dynamic programming** \\n\\nThe DP approach(Momoisation) is easy here as we only need to store the order and if order change we will change the subsequence that we are following and move to next subsequence.\\n\\n**Time complexity** : O(m.n) \\n\\nThe image showing if we use to traverse all the branches in the tree and not storing the information from each levels in the worst case we might need to traverse all the paths when no element is matching or interleaving in the next string.\\n\\n**IF WE DO NOT STORE IN ANY COLLECTION** : Each level in tree showing the char positions in s3 and total number of level are equal to the length of the string s3. For example root level 1st char and 2nd level 2nd char and so on. When ever we have a match we start it as either in s1 or s2 if match in s1 we will start that path if match in s2 we will take that path and traverse untill mismatch occur. In this order we need to parse every path. \\n\\n\\n\\n<img src=\"https://assets.leetcode.com/users/images/d6aab695-2ad1-4810-b12b-1881f76dbf50_1657175724.992637.png \" width=\"800px\" height=\"800px\" alt=\"R8_gcn_test\" align=center />\\n\\nC++ || PYTHON \\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size(), n = s2.size(), k = s3.size();\\n        if (m + n != k) return false;\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                if (i == 0 && j == 0) dp[i][j] = true;\\n                else if (i == 0) dp[i][j] = dp[i][j - 1] && s2[j - 1] == s3[i + j - 1];\\n                else if (j == 0) dp[i][j] = dp[i - 1][j] && s1[i - 1] == s3[i + j - 1];\\n                else dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\n\\n\\n```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3):\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\\n        for i in range(len(s1) + 1):\\n            for j in range(len(s2) + 1):\\n                if i == 0 and j == 0:\\n                    dp[i][j] = True\\n                elif i == 0:\\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]\\n                elif j == 0:\\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]\\n                else:\\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\\n        return dp[len(s1)][len(s2)]\\n```\\n \\n**Consider upvote if you find it useful\\uD83D\\uDE03** \\n\\n**Thanks in advance \\u2764\\uFE0F\\u2764\\uFE0F\\u2764\\uFE0F**\\n\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size(), n = s2.size(), k = s3.size();\\n        if (m + n != k) return false;\\n            while(m > 0 && n > 0 && s1[m-1] == s2[n-1] && s1[m-1] == s3[k-1]) {\\n                m--;\\n                n--;\\n                k--;\\n            }\\n            while(m > 0 && s1[m-1] == s3[k-1]) {\\n                m--;\\n                k--;\\n            }\\n            while(n > 0 && s2[n-1] == s3[k-1]) {\\n                n--;\\n                k--;\\n            }\\n            if (m == 0 && n == 0) return true;\\n            if (m == 0) return s2.substr(0, n) == s3.substr(0, n);\\n            if (n == 0) return s1.substr(0, m) == s3.substr(0, m);\\n            return s1.substr(0, m) == s3.substr(0, m) && s2.substr(0, n) == s3.substr(m, n);     \\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3):\\n        f1 = list(s1)\\n        f2 = list(s2)\\n        f3 = list(s3)\\n\\n        if len(f1) + len(f2) != len(f3):\\n            return False\\n\\n        if len(f1) == 0:\\n            return f2 == f3\\n\\n        if len(f2) == 0:\\n            return f1 == f3\\n\\n        if len(f1) == 1:\\n            return f1[0] == f3[0] and f2 == f3[1:]\\n\\n        if len(f2) == 1:\\n            return f1 == f3[0:] and f2[0] == f3[-1]\\n\\n\\n        for i in range(len(f1)):\\n            if f1[i] not in f3:\\n                return False\\n\\n        for i in range(len(f2)):\\n            if f2[i] not in f3:\\n                return False\\n        \\n        i =0\\n\\n        while(i != len(s3)):\\n            if s1[i] == s3[i]:\\n                i += 1\\n            if s2[i] == s3[i]:\\n                i += 1\\n            \\n            if s1[i] != s3[i] or s2[i] != s3[i]:\\n                return False\\n        \\n        return True \\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size(), n = s2.size(), k = s3.size();\\n        if (m + n != k) return false;\\n        while(m > 0 && n > 0 && s1[m-1] == s2[n-1] && s1[m-1] == s3[k-1]) {\\n            m--;\\n            n--;\\n            k--;\\n        }\\n        if (m == 0 && n == 0) return true;\\n        if (m == 0) return s2.substr(0, n) == s3.substr(0, n);\\n        if (n == 0) return s1.substr(0, m) == s3.substr(0, m);\\n        if (s1[m-1] == s3[k-1]) return isInterleave(s1.substr(0, m-1), s2, s3.substr(0, k-1));\\n\\n        if (s2[n-1] == s3[k-1]) return isInterleave(s1, s2.substr(0, n-1), s3.substr(0, k-1));\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3):\\n        if len(s1) + len(s2) !=len(s3):\\n            return False\\n\\n        if len(s1) == 0:\\n            return s2 == s3\\n        if len(s2) == 0:\\n            return s1 == s3\\n\\n        if s1[0] == s2[0] and s1[0] == s3[0]:\\n            return self.isInterleave(s1[1:], s2, s3[1:]) or self.isInterleave(s1, s2[1:], s3[1:])\\n        elif s1[0] == s3[0]:\\n            return self.isInterleave(s1[1:], s2, s3[1:])\\n        elif s2[0] == s3[0]:\\n            return self.isInterleave(s1, s2[1:], s3[1:])\\n        else:\\n            return False\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size(), n = s2.size(), k = s3.size();\\n        if (m + n != k) return false;\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                if (i == 0 && j == 0) dp[i][j] = true;\\n                else if (i == 0) dp[i][j] = dp[i][j - 1] && s2[j - 1] == s3[i + j - 1];\\n                else if (j == 0) dp[i][j] = dp[i - 1][j] && s1[i - 1] == s3[i + j - 1];\\n                else dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3):\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\\n        for i in range(len(s1) + 1):\\n            for j in range(len(s2) + 1):\\n                if i == 0 and j == 0:\\n                    dp[i][j] = True\\n                elif i == 0:\\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]\\n                elif j == 0:\\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]\\n                else:\\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\\n        return dp[len(s1)][len(s2)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248648,
                "title": "o-mn-dp-using-one-array-of-size-s2-length-python-c",
                "content": "**Upvote** if you like efficient solution code!\\n\\n**Join our discord** to meet other people preparing for interviews!\\n**https://discord.gg/7wpQQFYC**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n\\t\\tif (s1.length() + s2.length() != s3.length()) return false;\\n\\t\\tif (s1.length() < s2.length()) swap(s1, s2);\\n\\t\\tint m = s1.length(), n = s2.length();\\n\\t\\t\\t\\n        vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n        for (int j = 1; j <= n; j++) {\\n            dp[j] = s3[j - 1] == s2[j - 1] && dp[j - 1];\\n        }\\n\\n        for (int i = 1; i <= m; i++) {\\n            dp[0] = s3[i - 1] == s1[i - 1] && dp[0];\\n            for (int j = 1; j <= n; j++) {\\n                dp[j] = (s3[i + j - 1] == s1[i - 1] && dp[j]);\\n                dp[j] = dp[j] || (s3[i + j - 1] == s2[j - 1] && dp[j - 1]);\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```\\n\\n**Python3**\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        if len(s1) < len(s2):\\n            s1, s2 = s2, s1\\n        m, n = len(s1), len(s2)\\n        \\n        dp = [True] + [False] * n\\n        for j in range(1, n + 1):\\n            dp[j] = s2[j - 1] == s3[j - 1] and dp[j - 1]\\n\\n        for i in range(1, m + 1):\\n            dp[0] = s1[i - 1] == s3[i - 1] and dp[0]\\n            for j in range(1, n + 1):\\n                dp[j] = (s1[i - 1] == s3[i + j - 1] and dp[j])\\n                dp[j] = dp[j] or (s2[j - 1] == s3[i + j - 1] and dp[j - 1])\\n        return dp[-1]\\n```\\n\\n**Time Complexity** O(mn) - A for-loop running `m` iterations with another for-loop running `n` iterations nested inside.\\n**Space Complexity** O(n) - A single array of size `n`.",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n\\t\\tif (s1.length() + s2.length() != s3.length()) return false;\\n\\t\\tif (s1.length() < s2.length()) swap(s1, s2);\\n\\t\\tint m = s1.length(), n = s2.length();\\n\\t\\t\\t\\n        vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n        for (int j = 1; j <= n; j++) {\\n            dp[j] = s3[j - 1] == s2[j - 1] && dp[j - 1];\\n        }\\n\\n        for (int i = 1; i <= m; i++) {\\n            dp[0] = s3[i - 1] == s1[i - 1] && dp[0];\\n            for (int j = 1; j <= n; j++) {\\n                dp[j] = (s3[i + j - 1] == s1[i - 1] && dp[j]);\\n                dp[j] = dp[j] || (s3[i + j - 1] == s2[j - 1] && dp[j - 1]);\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        if len(s1) < len(s2):\\n            s1, s2 = s2, s1\\n        m, n = len(s1), len(s2)\\n        \\n        dp = [True] + [False] * n\\n        for j in range(1, n + 1):\\n            dp[j] = s2[j - 1] == s3[j - 1] and dp[j - 1]\\n\\n        for i in range(1, m + 1):\\n            dp[0] = s1[i - 1] == s3[i - 1] and dp[0]\\n            for j in range(1, n + 1):\\n                dp[j] = (s1[i - 1] == s3[i + j - 1] and dp[j])\\n                dp[j] = dp[j] or (s2[j - 1] == s3[i + j - 1] and dp[j - 1])\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248511,
                "title": "java-dp-based-solution-w-video-explanation-1ms",
                "content": "*Please **upvote** if you find this helpful*\\n\\n**Video Explanation**\\n\\n[Interleaving String | YouTube](https://www.youtube.com/watch?v=kbuYSSW54tk&feature=youtu.be)\\n\\n**Java Solution**\\n\\n```\\n//1ms\\nclass Solution {\\n    private boolean[][] invalid;\\n    private char[] c1;\\n    private char[] c2;\\n    private char[] c3;\\n    \\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        c1 = s1.toCharArray();\\n        c2 = s2.toCharArray();\\n        c3 = s3.toCharArray();\\n        \\n        int m = s1.length(),n=s2.length();\\n        \\n        if(m+n != s3.length())\\n            return false;\\n        \\n        invalid = new boolean[m+1][n+1];\\n        \\n        return dfs(0,0,0);\\n    }\\n    \\n    public boolean dfs(int i, int j, int k){\\n        if(invalid[i][j])\\n            return false;\\n        \\n        if(k == c3.length)\\n            return true;\\n        \\n        boolean valid = \\n            i<c1.length && c1[i] == c3[k] && dfs(i+1,j,k+1) || \\n            j<c2.length && c2[j] == c3[k] && dfs(i,j+1,k+1);\\n        \\n        if(!valid)\\n            invalid[i][j] = true;\\n        \\n        return valid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//1ms\\nclass Solution {\\n    private boolean[][] invalid;\\n    private char[] c1;\\n    private char[] c2;\\n    private char[] c3;\\n    \\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        c1 = s1.toCharArray();\\n        c2 = s2.toCharArray();\\n        c3 = s3.toCharArray();\\n        \\n        int m = s1.length(),n=s2.length();\\n        \\n        if(m+n != s3.length())\\n            return false;\\n        \\n        invalid = new boolean[m+1][n+1];\\n        \\n        return dfs(0,0,0);\\n    }\\n    \\n    public boolean dfs(int i, int j, int k){\\n        if(invalid[i][j])\\n            return false;\\n        \\n        if(k == c3.length)\\n            return true;\\n        \\n        boolean valid = \\n            i<c1.length && c1[i] == c3[k] && dfs(i+1,j,k+1) || \\n            j<c2.length && c2[j] == c3[k] && dfs(i,j+1,k+1);\\n        \\n        if(!valid)\\n            invalid[i][j] = true;\\n        \\n        return valid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31910,
                "title": "4ms-recursive-java",
                "content": "    public class Solution {\\n        Set<String> mem = new HashSet<String>();\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            if(s1.length() == 0 && s2.length() == 0 && s3.length() == 0)\\n                return true;\\n            if(mem.contains(s1+\"#\"+s2)) \\n                return false;\\n            if(s3.length() > 0){\\n                if(s1.length() > 0 &&  s1.charAt(0) == s3.charAt(0))\\n                    if(isInterleave(s1.substring(1),s2,s3.substring(1))) return true;\\n                if(s2.length() > 0 && s2.charAt(0) == s3.charAt(0))\\n                    if(isInterleave(s1,s2.substring(1),s3.substring(1))) return true;\\n            }\\n            mem.add(s1+\"#\"+s2);\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        Set<String> mem = new HashSet<String>();\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            if(s1.length() == 0 && s2.length() == 0 && s3.length() == 0)\\n                return true;\\n            if(mem.contains(s1+\"#\"+s2)) \\n                return false;\\n            if(s3.length() > 0){\\n                if(s1.length() > 0 &&  s1.charAt(0) == s3.charAt(0))\\n                    if(isInterleave(s1.substring(1),s2,s3.substring(1))) return true;\\n                if(s2.length() > 0 && s2.charAt(0) == s3.charAt(0))\\n                    if(isInterleave(s1,s2.substring(1),s3.substring(1))) return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3956989,
                "title": "dp-easy-best-approach",
                "content": "# Intuition\\nEasy Best Approach!!!\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDynamic Programming Approach:\\n\\nThe key insight in this problem is to use dynamic programming to check if a certain interleaving of s1 and s2 can form s3. The DP array will be used to keep track of whether a certain prefix of s3 can be formed by interleaving a prefix of s1 and a prefix of s2.\\n\\nHere\\'s how the dynamic programming approach works:\\n\\nInitialization: Create a DP array dp of dimensions (len_s1 + 1) \\xD7 (len_s2 + 1). dp[i][j] will be True if the first i characters of s1 and the first j characters of s2 can interleave to form the first i + j characters of s3. Initialize dp[0][0] to True since two empty strings can form an empty string.\\n\\nBase Cases: Initialize the first row and the first column of the DP array. dp[0][j] is True if dp[0][j-1] is True and s2[j-1] matches s3[j-1]. Similarly, dp[i][0] is True if dp[i-1][0] is True and s1[i-1] matches s3[i-1].\\n\\nFilling the DP Array: Loop through the remaining cells of the DP array (starting from i = 1 and j = 1). The idea is to check if the current character in s3, which is s3[i+j-1], can be formed by either appending a character from s1 or a character from s2 to the previously formed interleaved strings.\\n\\nIf s1[i-1] matches s3[i+j-1] and dp[i-1][j] is True, then dp[i][j] is True.\\nIf s2[j-1] matches s3[i+j-1] and dp[i][j-1] is True, then dp[i][j] is True.\\nFinal Result: After filling the DP array, the value of dp[len_s1][len_s2] will indicate whether the entire strings s1 and s2 can interleave to form the entire string s3.\\n\\nThis approach ensures that you\\'re considering all possible interleavings and checking if each character in s3 can be formed by interweaving characters from s1 and s2 in a valid manner.\\n\\nRemember, this is just one way to approach the problem using dynamic programming. There might be other creative ways to solve this problem as well.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(len_s1 * len_s2)\\n- $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(len_s1 * len_s2)\\n- $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        len_s1, len_s2, len_s3 = len(s1), len(s2), len(s3)\\n        \\n        # If the total length of s1 and s2 is not equal to s3, it\\'s impossible\\n        if len_s1 + len_s2 != len_s3:\\n            return False\\n        \\n        # Create a 2D DP array to store intermediate results\\n        dp = [[False] * (len_s2 + 1) for _ in range(len_s1 + 1)]\\n        \\n        # Base case: empty strings can always interleave to form an empty string\\n        dp[0][0] = True\\n        \\n        # Fill the first row\\n        for j in range(1, len_s2 + 1):\\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\\n        \\n        # Fill the first column\\n        for i in range(1, len_s1 + 1):\\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\\n        \\n        # Fill the DP array\\n        for i in range(1, len_s1 + 1):\\n            for j in range(1, len_s2 + 1):\\n                # Check if the current position in s3 can be formed by interleaving\\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \\\\\\n                           (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\\n        \\n        return dp[len_s1][len_s2]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        len_s1, len_s2, len_s3 = len(s1), len(s2), len(s3)\\n        \\n        # If the total length of s1 and s2 is not equal to s3, it\\'s impossible\\n        if len_s1 + len_s2 != len_s3:\\n            return False\\n        \\n        # Create a 2D DP array to store intermediate results\\n        dp = [[False] * (len_s2 + 1) for _ in range(len_s1 + 1)]\\n        \\n        # Base case: empty strings can always interleave to form an empty string\\n        dp[0][0] = True\\n        \\n        # Fill the first row\\n        for j in range(1, len_s2 + 1):\\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\\n        \\n        # Fill the first column\\n        for i in range(1, len_s1 + 1):\\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\\n        \\n        # Fill the DP array\\n        for i in range(1, len_s1 + 1):\\n            for j in range(1, len_s2 + 1):\\n                # Check if the current position in s3 can be formed by interleaving\\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \\\\\\n                           (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\\n        \\n        return dp[len_s1][len_s2]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32083,
                "title": "my-solution-in-java-using-dp-time-o-n-m-and-space-o-m",
                "content": "Using dp to tracking select i-th seq and j-th seq in s1 and s2 could match i+j+2 th seq in s3\\n\\n 1. init optimal[0][*] by check no select from s1\\n 2. init optimal[*][0] by check no select from s2\\n 3. do search for every i-th and j-th, could match when meet one of the following two cases:\\n1. if i-th char in s2 equals to the (i+j+1)th char in s3, and previous j-th in s2 is matched without i-th char\\n2. if j-th char in s1 equals to the (i+j+1)th char in s3, and previous j-1th in s2 is matched with i-th char\\n 4. a straight-forward solution should be Time: O(n*m), and Space: O(n*m). And space could optimize since optimal[i+1][*] only depends on optimal[i][*], so could use Space O(m)\\n\\n\\n----------\\nJava code as following:\\n\\n    public static boolean isInterleaveOptz(String s1, String s2, String s3) {\\n        if (s3.length() != s1.length() + s2.length()) return false;\\n\\n        boolean[] optimal = new boolean[s2.length() + 1];    //dp optimal\\n        optimal[0] = true;\\n        for (int j = 0; j < s2.length(); j++) { //check no s1 char is selected, if s2 could equals to s3\\n            if (optimal[j] && s2.charAt(j) == s3.charAt(j)) optimal[j + 1] = true;\\n        }\\n\\n        for (int i = 0; i < s1.length(); i++) { //check select i-th char in s1\\n            if (optimal[0] && s1.charAt(i) == s3.charAt(i)) optimal[0] = true;    //no char in s2 is selected\\n            else optimal[0] = false;\\n            for (int j = 0; j < s2.length(); j++) {  //select j-th char\\n                if ((s1.charAt(i) == s3.charAt(i + j + 1) && optimal[j + 1]) ||\\n                        s2.charAt(j) == s3.charAt(i + j + 1) && optimal[j]) {\\n                    optimal[j + 1] = true;\\n                } else optimal[j + 1] = false;\\n            }\\n        }\\n        return optimal[s2.length()];\\n    }",
                "solutionTags": [],
                "code": "Using dp to tracking select i-th seq and j-th seq in s1 and s2 could match i+j+2 th seq in s3\\n\\n 1. init optimal[0][*] by check no select from s1\\n 2. init optimal[*][0] by check no select from s2\\n 3. do search for every i-th and j-th, could match when meet one of the following two cases:\\n1. if i-th char in s2 equals to the (i+j+1)th char in s3, and previous j-th in s2 is matched without i-th char\\n2. if j-th char in s1 equals to the (i+j+1)th char in s3, and previous j-1th in s2 is matched with i-th char\\n 4. a straight-forward solution should be Time: O(n*m), and Space: O(n*m). And space could optimize since optimal[i+1][*] only depends on optimal[i][*], so could use Space O(m)\\n\\n\\n----------\\nJava code as following:\\n\\n    public static boolean isInterleaveOptz(String s1, String s2, String s3) {\\n        if (s3.length() != s1.length() + s2.length()) return false;\\n\\n        boolean[] optimal = new boolean[s2.length() + 1];    //dp optimal\\n        optimal[0] = true;\\n        for (int j = 0; j < s2.length(); j++) { //check no s1 char is selected, if s2 could equals to s3\\n            if (optimal[j] && s2.charAt(j) == s3.charAt(j)) optimal[j + 1] = true;\\n        }\\n\\n        for (int i = 0; i < s1.length(); i++) { //check select i-th char in s1\\n            if (optimal[0] && s1.charAt(i) == s3.charAt(i)) optimal[0] = true;    //no char in s2 is selected\\n            else optimal[0] = false;\\n            for (int j = 0; j < s2.length(); j++) {  //select j-th char\\n                if ((s1.charAt(i) == s3.charAt(i + j + 1) && optimal[j + 1]) ||\\n                        s2.charAt(j) == s3.charAt(i + j + 1) && optimal[j]) {\\n                    optimal[j + 1] = true;\\n                } else optimal[j + 1] = false;\\n            }\\n        }\\n        return optimal[s2.length()];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3956731,
                "title": "easy-solution-python3-c-c-java-using-dfs-with-image",
                "content": "```Python3 []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n\\n        dp = [ [False] * (len(s2) + 1) for i in range(len(s1) + 1)]\\n        dp[len(s1)][len(s2)] = True\\n\\n        for i in range(len(s1), -1, -1):\\n            for j in range(len(s2), -1, -1):\\n                if i < len(s1) and s1[i] == s3[i +j] and dp[i + 1][j]:\\n                    dp[i][j] = True\\n                if j < len(s2) and s2[j] == s3[i + j] and dp[i][j + 1]:\\n                    dp[i][j] = True\\n        return dp[0][0]\\n\\n\\n\\n        dp = {}\\n        def dfs(i, j):\\n            if i == len(s1) and j == len(s2):\\n                return True\\n            if (i, j) in dp:\\n                return dp[(i, j)]\\n\\n            if i < len(s1) and s1[i] == s3[i+j] and dfs(i + 1, j):\\n                return True\\n            \\n            if j < len(s2) and s2[j] == s3[i + j] and dfs(i, j + 1):\\n                return True\\n            \\n            dp[(i, j)] = False\\n            return False\\n        return dfs(0, 0)\\n```\\n```python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n\\n        dp = [ [False] * (len(s2) + 1) for i in range(len(s1) + 1)]\\n        dp[len(s1)][len(s2)] = True\\n\\n        for i in range(len(s1), -1, -1):\\n            for j in range(len(s2), -1, -1):\\n                if i < len(s1) and s1[i] == s3[i +j] and dp[i + 1][j]:\\n                    dp[i][j] = True\\n                if j < len(s2) and s2[j] == s3[i + j] and dp[i][j + 1]:\\n                    dp[i][j] = True\\n        return dp[0][0]\\n\\n\\n\\n        dp = {}\\n        def dfs(i, j):\\n            if i == len(s1) and j == len(s2):\\n                return True\\n            if (i, j) in dp:\\n                return dp[(i, j)]\\n\\n            if i < len(s1) and s1[i] == s3[i+j] and dfs(i + 1, j):\\n                return True\\n            \\n            if j < len(s2) and s2[j] == s3[i + j] and dfs(i, j + 1):\\n                return True\\n            \\n            dp[(i, j)] = False\\n            return False\\n        return dfs(0, 0)\\n```\\n```C# []\\npublic class Solution {\\n    public bool IsInterleave(string s1, string s2, string s3) {\\n        if (s1.Length + s2.Length != s3.Length) {\\n            return false;\\n        }\\n\\n        bool[,] dp = new bool[s1.Length + 1, s2.Length + 1];\\n        dp[s1.Length, s2.Length] = true;\\n\\n        for (int i = s1.Length; i >= 0; i--) {\\n            for (int j = s2.Length; j >= 0; j--) {\\n                if (i < s1.Length && s1[i] == s3[i + j] && dp[i + 1, j]) {\\n                    dp[i, j] = true;\\n                }\\n                if (j < s2.Length && s2[j] == s3[i + j] && dp[i, j + 1]) {\\n                    dp[i, j] = true;\\n                }\\n            }\\n        }\\n        return dp[0, 0];\\n    }\\n\\n    private Dictionary<(int, int), bool> dp = new Dictionary<(int, int), bool>();\\n    private bool DFS(int i, int j, string s1, string s2, string s3) {\\n        if (i == s1.Length && j == s2.Length) {\\n            return true;\\n        }\\n        if (dp.ContainsKey((i, j))) {\\n            return dp[(i, j)];\\n        }\\n\\n        bool result = false;\\n        if (i < s1.Length && s1[i] == s3[i + j] && DFS(i + 1, j, s1, s2, s3)) {\\n            result = true;\\n        }\\n        if (j < s2.Length && s2[j] == s3[i + j] && DFS(i, j + 1, s1, s2, s3)) {\\n            result = true;\\n        }\\n\\n        dp[(i, j)] = result;\\n        return result;\\n    }\\n}\\n```\\n```C++ []\\n#include <unordered_map>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n\\n        vector<vector<bool>> dp(s1.length() + 1, vector<bool>(s2.length() + 1, false));\\n        dp[s1.length()][s2.length()] = true;\\n\\n        for (int i = s1.length(); i >= 0; i--) {\\n            for (int j = s2.length(); j >= 0; j--) {\\n                if (i < s1.length() && s1[i] == s3[i + j] && dp[i + 1][j]) {\\n                    dp[i][j] = true;\\n                }\\n                if (j < s2.length() && s2[j] == s3[i + j] && dp[i][j + 1]) {\\n                    dp[i][j] = true;\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\nprivate:\\n    struct PairHash {\\n        template <class T1, class T2>\\n        size_t operator() (const pair<T1, T2>& p) const {\\n            auto h1 = hash<T1>{}(p.first);\\n            auto h2 = hash<T2>{}(p.second);\\n            return h1 ^ (h2 << 1);\\n        }\\n    };\\n    \\n    unordered_map<pair<int, int>, bool, PairHash> dp;\\n    bool dfs(int i, int j, string& s1, string& s2, string& s3) {\\n        if (i == s1.length() && j == s2.length()) {\\n            return true;\\n        }\\n        if (dp.find({i, j}) != dp.end()) {\\n            return dp[{i, j}];\\n        }\\n\\n        bool result = false;\\n        if (i < s1.length() && s1[i] == s3[i + j] && dfs(i + 1, j, s1, s2, s3)) {\\n            result = true;\\n        }\\n        if (j < s2.length() && s2[j] == s3[i + j] && dfs(i, j + 1, s1, s2, s3)) {\\n            result = true;\\n        }\\n\\n        dp[{i, j}] = result;\\n        return result;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n\\n        boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];\\n        dp[s1.length()][s2.length()] = true;\\n\\n        for (int i = s1.length(); i >= 0; i--) {\\n            for (int j = s2.length(); j >= 0; j--) {\\n                if (i < s1.length() && s1.charAt(i) == s3.charAt(i + j) && dp[i + 1][j]) {\\n                    dp[i][j] = true;\\n                }\\n                if (j < s2.length() && s2.charAt(j) == s3.charAt(i + j) && dp[i][j + 1]) {\\n                    dp[i][j] = true;\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\n    private Map<Pair, Boolean> dp = new HashMap<>();\\n    private boolean dfs(int i, int j, String s1, String s2, String s3) {\\n        if (i == s1.length() && j == s2.length()) {\\n            return true;\\n        }\\n        Pair pair = new Pair(i, j);\\n        if (dp.containsKey(pair)) {\\n            return dp.get(pair);\\n        }\\n\\n        boolean result = false;\\n        if (i < s1.length() && s1.charAt(i) == s3.charAt(i + j) && dfs(i + 1, j, s1, s2, s3)) {\\n            result = true;\\n        }\\n        if (j < s2.length() && s2.charAt(j) == s3.charAt(i + j) && dfs(i, j + 1, s1, s2, s3)) {\\n            result = true;\\n        }\\n\\n        dp.put(pair, result);\\n        return result;\\n    }\\n\\n    private class Pair {\\n        int first;\\n        int second;\\n\\n        Pair(int first, int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return first * 31 + second;\\n        }\\n\\n        @Override\\n        public boolean equals(Object obj) {\\n            if (this == obj) return true;\\n            if (obj == null || getClass() != obj.getClass()) return false;\\n            Pair other = (Pair) obj;\\n            return first == other.first && second == other.second;\\n        }\\n    }\\n}\\n```\\n![Screenshot 2023-08-20 065922.png](https://assets.leetcode.com/users/images/87160051-906d-467d-bc82-cdf1b787371b_1692934261.5322077.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n\\n        dp = [ [False] * (len(s2) + 1) for i in range(len(s1) + 1)]\\n        dp[len(s1)][len(s2)] = True\\n\\n        for i in range(len(s1), -1, -1):\\n            for j in range(len(s2), -1, -1):\\n                if i < len(s1) and s1[i] == s3[i +j] and dp[i + 1][j]:\\n                    dp[i][j] = True\\n                if j < len(s2) and s2[j] == s3[i + j] and dp[i][j + 1]:\\n                    dp[i][j] = True\\n        return dp[0][0]\\n\\n\\n\\n        dp = {}\\n        def dfs(i, j):\\n            if i == len(s1) and j == len(s2):\\n                return True\\n            if (i, j) in dp:\\n                return dp[(i, j)]\\n\\n            if i < len(s1) and s1[i] == s3[i+j] and dfs(i + 1, j):\\n                return True\\n            \\n            if j < len(s2) and s2[j] == s3[i + j] and dfs(i, j + 1):\\n                return True\\n            \\n            dp[(i, j)] = False\\n            return False\\n        return dfs(0, 0)\\n```\n```python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n\\n        dp = [ [False] * (len(s2) + 1) for i in range(len(s1) + 1)]\\n        dp[len(s1)][len(s2)] = True\\n\\n        for i in range(len(s1), -1, -1):\\n            for j in range(len(s2), -1, -1):\\n                if i < len(s1) and s1[i] == s3[i +j] and dp[i + 1][j]:\\n                    dp[i][j] = True\\n                if j < len(s2) and s2[j] == s3[i + j] and dp[i][j + 1]:\\n                    dp[i][j] = True\\n        return dp[0][0]\\n\\n\\n\\n        dp = {}\\n        def dfs(i, j):\\n            if i == len(s1) and j == len(s2):\\n                return True\\n            if (i, j) in dp:\\n                return dp[(i, j)]\\n\\n            if i < len(s1) and s1[i] == s3[i+j] and dfs(i + 1, j):\\n                return True\\n            \\n            if j < len(s2) and s2[j] == s3[i + j] and dfs(i, j + 1):\\n                return True\\n            \\n            dp[(i, j)] = False\\n            return False\\n        return dfs(0, 0)\\n```\n```C# []\\npublic class Solution {\\n    public bool IsInterleave(string s1, string s2, string s3) {\\n        if (s1.Length + s2.Length != s3.Length) {\\n            return false;\\n        }\\n\\n        bool[,] dp = new bool[s1.Length + 1, s2.Length + 1];\\n        dp[s1.Length, s2.Length] = true;\\n\\n        for (int i = s1.Length; i >= 0; i--) {\\n            for (int j = s2.Length; j >= 0; j--) {\\n                if (i < s1.Length && s1[i] == s3[i + j] && dp[i + 1, j]) {\\n                    dp[i, j] = true;\\n                }\\n                if (j < s2.Length && s2[j] == s3[i + j] && dp[i, j + 1]) {\\n                    dp[i, j] = true;\\n                }\\n            }\\n        }\\n        return dp[0, 0];\\n    }\\n\\n    private Dictionary<(int, int), bool> dp = new Dictionary<(int, int), bool>();\\n    private bool DFS(int i, int j, string s1, string s2, string s3) {\\n        if (i == s1.Length && j == s2.Length) {\\n            return true;\\n        }\\n        if (dp.ContainsKey((i, j))) {\\n            return dp[(i, j)];\\n        }\\n\\n        bool result = false;\\n        if (i < s1.Length && s1[i] == s3[i + j] && DFS(i + 1, j, s1, s2, s3)) {\\n            result = true;\\n        }\\n        if (j < s2.Length && s2[j] == s3[i + j] && DFS(i, j + 1, s1, s2, s3)) {\\n            result = true;\\n        }\\n\\n        dp[(i, j)] = result;\\n        return result;\\n    }\\n}\\n```\n```C++ []\\n#include <unordered_map>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n\\n        vector<vector<bool>> dp(s1.length() + 1, vector<bool>(s2.length() + 1, false));\\n        dp[s1.length()][s2.length()] = true;\\n\\n        for (int i = s1.length(); i >= 0; i--) {\\n            for (int j = s2.length(); j >= 0; j--) {\\n                if (i < s1.length() && s1[i] == s3[i + j] && dp[i + 1][j]) {\\n                    dp[i][j] = true;\\n                }\\n                if (j < s2.length() && s2[j] == s3[i + j] && dp[i][j + 1]) {\\n                    dp[i][j] = true;\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\nprivate:\\n    struct PairHash {\\n        template <class T1, class T2>\\n        size_t operator() (const pair<T1, T2>& p) const {\\n            auto h1 = hash<T1>{}(p.first);\\n            auto h2 = hash<T2>{}(p.second);\\n            return h1 ^ (h2 << 1);\\n        }\\n    };\\n    \\n    unordered_map<pair<int, int>, bool, PairHash> dp;\\n    bool dfs(int i, int j, string& s1, string& s2, string& s3) {\\n        if (i == s1.length() && j == s2.length()) {\\n            return true;\\n        }\\n        if (dp.find({i, j}) != dp.end()) {\\n            return dp[{i, j}];\\n        }\\n\\n        bool result = false;\\n        if (i < s1.length() && s1[i] == s3[i + j] && dfs(i + 1, j, s1, s2, s3)) {\\n            result = true;\\n        }\\n        if (j < s2.length() && s2[j] == s3[i + j] && dfs(i, j + 1, s1, s2, s3)) {\\n            result = true;\\n        }\\n\\n        dp[{i, j}] = result;\\n        return result;\\n    }\\n};\\n```\n```Java []\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n\\n        boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];\\n        dp[s1.length()][s2.length()] = true;\\n\\n        for (int i = s1.length(); i >= 0; i--) {\\n            for (int j = s2.length(); j >= 0; j--) {\\n                if (i < s1.length() && s1.charAt(i) == s3.charAt(i + j) && dp[i + 1][j]) {\\n                    dp[i][j] = true;\\n                }\\n                if (j < s2.length() && s2.charAt(j) == s3.charAt(i + j) && dp[i][j + 1]) {\\n                    dp[i][j] = true;\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\n    private Map<Pair, Boolean> dp = new HashMap<>();\\n    private boolean dfs(int i, int j, String s1, String s2, String s3) {\\n        if (i == s1.length() && j == s2.length()) {\\n            return true;\\n        }\\n        Pair pair = new Pair(i, j);\\n        if (dp.containsKey(pair)) {\\n            return dp.get(pair);\\n        }\\n\\n        boolean result = false;\\n        if (i < s1.length() && s1.charAt(i) == s3.charAt(i + j) && dfs(i + 1, j, s1, s2, s3)) {\\n            result = true;\\n        }\\n        if (j < s2.length() && s2.charAt(j) == s3.charAt(i + j) && dfs(i, j + 1, s1, s2, s3)) {\\n            result = true;\\n        }\\n\\n        dp.put(pair, result);\\n        return result;\\n    }\\n\\n    private class Pair {\\n        int first;\\n        int second;\\n\\n        Pair(int first, int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return first * 31 + second;\\n        }\\n\\n        @Override\\n        public boolean equals(Object obj) {\\n            if (this == obj) return true;\\n            if (obj == null || getClass() != obj.getClass()) return false;\\n            Pair other = (Pair) obj;\\n            return first == other.first && second == other.second;\\n        }\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1347089,
                "title": "basic-recursion-in-java-for-understanding",
                "content": "*This solution will help you for the top down and bottom up approach and how the solution will be formed.\\nThis solution will not get accepted due to high time complexity. This is only to help beginners understand the recursive part as it is the most important part for dp.*\\n\\n```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s1.length()+s2.length()!=s3.length())\\n        {\\n            return false;\\n        }\\n        return check(s1,s2,s3,0,0,0);\\n    }\\n    \\n    public boolean check(String s1,String s2,String s3,int i,int j,int n)\\n    {\\n        if(n==s3.length() && i==s1.length() && j==s2.length())\\n        {\\n            return true;\\n        }\\n        boolean res=false;\\n        \\n        if(i<s1.length() && j<s2.length() && s1.charAt(i)==s3.charAt(n) && s2.charAt(j)==s3.charAt(n))\\n        {\\n            res = res ||  check(s1,s2,s3,i+1,j,n+1) || check(s1,s2,s3,i,j+1,n+1); \\n        }\\n        else if(i<s1.length() && s1.charAt(i)==s3.charAt(n))\\n        {\\n            res = res || check(s1,s2,s3,i+1,j,n+1);\\n        }\\n        else if(j<s2.length() && s2.charAt(j)==s3.charAt(n))\\n        {\\n            res = res || check(s1,s2,s3,i,j+1,n+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s1.length()+s2.length()!=s3.length())\\n        {\\n            return false;\\n        }\\n        return check(s1,s2,s3,0,0,0);\\n    }\\n    \\n    public boolean check(String s1,String s2,String s3,int i,int j,int n)\\n    {\\n        if(n==s3.length() && i==s1.length() && j==s2.length())\\n        {\\n            return true;\\n        }\\n        boolean res=false;\\n        \\n        if(i<s1.length() && j<s2.length() && s1.charAt(i)==s3.charAt(n) && s2.charAt(j)==s3.charAt(n))\\n        {\\n            res = res ||  check(s1,s2,s3,i+1,j,n+1) || check(s1,s2,s3,i,j+1,n+1); \\n        }\\n        else if(i<s1.length() && s1.charAt(i)==s3.charAt(n))\\n        {\\n            res = res || check(s1,s2,s3,i+1,j,n+1);\\n        }\\n        else if(j<s2.length() && s2.charAt(j)==s3.charAt(n))\\n        {\\n            res = res || check(s1,s2,s3,i,j+1,n+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772696,
                "title": "c-0ms-beats-100",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool check(string &s1,string &s2,string &s3,int i,int j,int k,vector<vector<int>>&dp){\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(i==s1.length() and j==s2.length() and k==s3.length())\\n            return true;\\n        bool res=false;\\n        \\n        if(i!=s1.length())\\n            if(s1[i]==s3[k])\\n            res|=check(s1,s2,s3,i+1,j,k+1,dp);\\n        if(j!=s2.length())\\n            if(s2[j]==s3[k])\\n            res|=check(s1,s2,s3,i,j+1,k+1,dp);\\n        return dp[i][j]=res;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n=s1.length(),m=s2.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        bool ans=check(s1,s2,s3,0,0,0,dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool check(string &s1,string &s2,string &s3,int i,int j,int k,vector<vector<int>>&dp){\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(i==s1.length() and j==s2.length() and k==s3.length())\\n            return true;\\n        bool res=false;\\n        \\n        if(i!=s1.length())\\n            if(s1[i]==s3[k])\\n            res|=check(s1,s2,s3,i+1,j,k+1,dp);\\n        if(j!=s2.length())\\n            if(s2[j]==s3[k])\\n            res|=check(s1,s2,s3,i,j+1,k+1,dp);\\n        return dp[i][j]=res;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n=s1.length(),m=s2.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        bool ans=check(s1,s2,s3,0,0,0,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250282,
                "title": "simple-top-down-memoization-with-explanation",
                "content": "3 pointers , p1 points character of s1, p2 points character of s2, p3 points character of s3\\nif all pointers reached end means we successfully formed s3 from s1 and s2..\\n**if char at p1 matches with char at p3.. that means subproblem becomes dfs(p1+1,p2,p3+1)\\nif char at p2 matches with char at p3.. that means subproblem becomes dfs(p1,p2+1,p3+1)**\\nif none of the case satisfies that means neither char at p1 matches with p3 nor p2 char matches with p1 char.. or none of the ways formed the s3 then return false\\n\\nRUNTIME : 90% faster than other python users\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False\\n        @lru_cache(maxsize = None)\\n        def dfs(p1,p2,p3):\\n            if p1 == len(s1) and p2 == len(s2) and p3 == len(s3): return True\\n            if p1 < len(s1) and s1[p1] == s3[p3] and dfs(p1+1,p2,p3+1): return True\\n            if p2 < len(s2) and s2[p2] == s3[p3] and dfs(p1,p2+1,p3+1): return True\\n            return False\\n        return dfs(0,0,0)\\n```\\n\\n**PLEASE UPVOTE IT**.. FEEL FREE TO ASK ANY QUERIES..",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False\\n        @lru_cache(maxsize = None)\\n        def dfs(p1,p2,p3):\\n            if p1 == len(s1) and p2 == len(s2) and p3 == len(s3): return True\\n            if p1 < len(s1) and s1[p1] == s3[p3] and dfs(p1+1,p2,p3+1): return True\\n            if p2 < len(s2) and s2[p2] == s3[p3] and dfs(p1,p2+1,p3+1): return True\\n            return False\\n        return dfs(0,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247101,
                "title": "dp-top-down-memoization-comments-added-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        \\n        if(n3 == 0) return true;\\n        \\n        if(n1+n2 != n3) return false; \\n        \\n        int dp[n1+1][n2+1];\\n        memset(dp, 0, sizeof(dp));\\n        \\n        for(int i=0; i<=n1; i++){\\n            for(int j=0; j<=n2; j++){\\n                if(i == 0 && j == 0) //both strings are empty so it is interleaving\\n                    dp[i][j] = 1;\\n                \\n                else if(i == 0){ //s1 is empty\\n                    if(s2[j-1] == s3[j-1])\\n                        dp[i][j] = dp[i][j-1];\\n                }\\n                \\n                else if(j == 0){ // s2 is empty\\n                    if(s1[i-1] == s3[i-1])\\n                        dp[i][j] = dp[i-1][j];\\n                }\\n                \\n                else if(s1[i-1] != s3[i+j-1] && s2[j-1] == s3[i+j-1]) //if not match with s1\\n                    dp[i][j] = dp[i][j-1];\\n                \\n                else if(s1[i-1] == s3[i+j-1] && s2[j-1] != s3[i+j-1])   //if not match with s2\\n                    dp[i][j] = dp[i-1][j];\\n                \\n                else if(s1[i-1] == s3[i+j-1] && s2[j-1] == s3[i+j-1])  // If match with both s1 and s2\\n                    dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n            }\\n        }      \\n        return dp[n1][n2];\\n    }\\n};\\n\\n**Please do upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        \\n        if(n3 == 0) return true;\\n        \\n        if(n1+n2 != n3) return false; \\n        \\n        int dp[n1+1][n2+1];\\n        memset(dp, 0, sizeof(dp));\\n        \\n        for(int i=0; i<=n1; i++){\\n            for(int j=0; j<=n2; j++){\\n                if(i == 0 && j == 0) //both strings are empty so it is interleaving\\n                    dp[i][j] = 1;\\n                \\n                else if(i == 0){ //s1 is empty\\n                    if(s2[j-1] == s3[j-1])\\n                        dp[i][j] = dp[i][j-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 31952,
                "title": "no-loops-quick-n-easy-5-liner-in-python-beats-99",
                "content": "Pure recursion without loops. Useful for interviews when we need to code things fast without much bullcrap. Shortest in Python I've seen so far for this problem, but may be wrong.\\n\\n```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3, memo={}):\\n        if len(s1) + len(s2) != len(s3): return False\\n        if not s1 and not s2 and not s3: return True\\n        if (s1, s2, s3) in memo:         return memo[s1, s2, s3]\\n        memo[s1,s2,s3] =\\\\\\n               (len(s1) > 0 and len(s3) > 0 and s1[0] == s3[0] and self.isInterleave(s1[1:], s2, s3[1:], memo)) or\\\\\\n               (len(s2) > 0 and len(s3) > 0 and s2[0] == s3[0] and self.isInterleave(s1, s2[1:], s3[1:], memo))\\n        return memo[s1,s2,s3]\\n                \\n\\n# 101 / 101 test cases passed.\\n# Status: Accepted\\n# Runtime: 44 ms\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3, memo={}):\\n        if len(s1) + len(s2) != len(s3): return False\\n        if not s1 and not s2 and not s3: return True\\n        if (s1, s2, s3) in memo:         return memo[s1, s2, s3]\\n        memo[s1,s2,s3] =\\\\\\n               (len(s1) > 0 and len(s3) > 0 and s1[0] == s3[0] and self.isInterleave(s1[1:], s2, s3[1:], memo)) or\\\\\\n               (len(s2) > 0 and len(s3) > 0 and s2[0] == s3[0] and self.isInterleave(s1, s2[1:], s3[1:], memo))\\n        return memo[s1,s2,s3]\\n                \\n\\n# 101 / 101 test cases passed.\\n# Status: Accepted\\n# Runtime: 44 ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247315,
                "title": "interleaving-string-easy-dp-solution-with-explanation",
                "content": "\\t\\n\\tConsider the given example:  s1= aabcc  s2 = dbbca  s3=  aa dbbc bc a c\\n\\t\\n\\tWe start with an empty s3, adding characters one by one and finding if we can use some substring of s1 and s2  to construct this s3.\\n\\tUsing a 2D vector to store the answers along the way.\\n\\tdp[i][j] = true if it is possible to construct the string s3[0....i+j-1] using substrings s1[0...i-1]  and s2[0...j-1]\\n\\n\\t\\n1.  Base case : dp[0][0] = true\\n\\t Since we can make an empty string s3  from 2 empty strings s1 and s2.\\n\\t\\n2.\\t When one of the strings is empty\\n\\t\\t\\n\\t\\tWhen s2 is empty\\n\\t\\tAdd characters one by one to s3 and s1 while keeping s2 empty.\\t\\t\\n\\t\\teg.             s1 = \"a\"  s2 = \" \"    s3 = \"a\".    We can make s3 using this s1 and s2. \\n\\t\\t   Therefore, dp[1][0] = true  since s3[0] = s2[0] \\n\\n\\t\\tTo find dp[i][0],\\n\\t\\twe just check whether the last charcter of s3 is same as last char of s1 , s3[i-1] == s1[i-1] and\\n\\t\\tif it is possible to construct the string, s3 minus current character\\n\\t\\ti.e.  dp[i-1][0] is true.\\n\\t\\t\\tThis way we have filled the first column of our dp. \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tdp[i][0] = dp[i-1][0]  and (s3[i-1] == s1[i-1])\\n\\t\\tSimilarly  we can fill the first row when s1 is empty and s2 is not.\\n\\t\\t\\t\\n\\t\\t\\tdp[0][j] = (s3[j-1] == s2[j-1] ) and dp[0][j-1]\\n\\n\\n3.\\tNow consider the case when both strings are not empty.\\n\\t \\n\\t eg. to find dp[1][1]\\n\\t\\t s1 = \"a\"  s2 = \"d\"    s3 = \"aa\"\\n  \\n\\t  \\n\\t  We need to check 2 conditions : \\n\\ta. whether the last character of s3 is same as last characters of either s1 or s2. \\n\\t\\tIf  not same then its not possible to make s3.\\n\\n\\tb. whether it\\'s possible to construct the string s3 minus current character.\\n\\t\\t\\ti.e  when s3 has a single character. Those are dp[0][1] and dp[1][0] .\\n\\n\\n\\tIf the last character of s3 comes from s1, \\n\\tthen check whether it is possible to construct the string s3 minus current character using   substring s2 and substring s1 minus last character.\\n`bool t1 = (s3[i+j-1] == s1[i-1] ) and dp[i-1][j];`\\n\\n\\tSimilarly if the last character of s3 comes from s2,\\n\\t\\t`bool t2 = (s3[i+j-1] == s2[j-1]) and dp[i][j-1];`\\n\\n\\n\\n If either of t1 or t2 is true then we can make s3 with current substrings s1 and s2.\\n\\t\\n\\n\\n\\n\\n```\\nbool isInterleave(string s1, string s2, string s3) {\\n        int m= s1.length(), n= s2.length();\\n        if(s3.length() != m+n) return false;\\n        vector<vector<bool>> dp(m+1,vector<bool>(n+1,false));\\n        \\n        dp[0][0]  = 1;\\n        \\n        for(int i=1; i<=m;i++)\\n            dp[i][0] = (s3[i-1] == s1[i-1]) and dp[i-1][0];\\n        \\n        for(int j=1;j<=n; j++)\\n            dp[0][j] = (s3[j-1] == s2[j-1]) and dp[0][j-1];\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                bool t1 = (s3[i+j-1] == s1[i-1] ) and dp[i-1][j];\\n                bool t2 = (s3[i+j-1] == s2[j-1]) and dp[i][j-1];\\n                dp[i][j] = t1 or t2;\\n            }\\n        }\\n        \\n        return dp[m][n];\\n        \\n        \\n    }\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nbool isInterleave(string s1, string s2, string s3) {\\n        int m= s1.length(), n= s2.length();\\n        if(s3.length() != m+n) return false;\\n        vector<vector<bool>> dp(m+1,vector<bool>(n+1,false));\\n        \\n        dp[0][0]  = 1;\\n        \\n        for(int i=1; i<=m;i++)\\n            dp[i][0] = (s3[i-1] == s1[i-1]) and dp[i-1][0];\\n        \\n        for(int j=1;j<=n; j++)\\n            dp[0][j] = (s3[j-1] == s2[j-1]) and dp[0][j-1];\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                bool t1 = (s3[i+j-1] == s1[i-1] ) and dp[i-1][j];\\n                bool t2 = (s3[i+j-1] == s2[j-1]) and dp[i][j-1];\\n                dp[i][j] = t1 or t2;\\n            }\\n        }\\n        \\n        return dp[m][n];\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957005,
                "title": "c-dp-recursion-memoization-day-25",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool c(int i1,int i2,int i3,string &s1,string &s2,string &s3,\\n    vector<vector<vector<int>>>&dp){\\n        if(i3==s3.size()){\\n            if(i2==s2.size() && i1==s1.size())return true;\\n            else return false;\\n        }\\n        char c1=\\'*\\',c2=\\'*\\';\\n        if(dp[i1][i2][i3]!=-1)return dp[i1][i2][i3];\\n        if(i1<s1.size())c1=s1[i1];\\n        if(i2<s2.size())c2=s2[i2];\\n        bool ans=false;\\n        if(c1==s3[i3])ans |= c(i1+1,i2,i3+1,s1,s2,s3,dp);\\n        if(c2==s3[i3])ans |= c(i1,i2+1,i3+1,s1,s2,s3,dp);\\n        return dp[i1][i2][i3]=ans;\\n        }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        vector<vector<vector<int>>>dp(s1.size()+1,vector<vector<int>>(s2.size()+1,vector<int>(s3.size(),-1)));\\n        return c(0,0,0,s1,s2,s3,dp);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/79429923-2114-4af9-9725-1f43b586a234_1692940270.5239363.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool c(int i1,int i2,int i3,string &s1,string &s2,string &s3,\\n    vector<vector<vector<int>>>&dp){\\n        if(i3==s3.size()){\\n            if(i2==s2.size() && i1==s1.size())return true;\\n            else return false;\\n        }\\n        char c1=\\'*\\',c2=\\'*\\';\\n        if(dp[i1][i2][i3]!=-1)return dp[i1][i2][i3];\\n        if(i1<s1.size())c1=s1[i1];\\n        if(i2<s2.size())c2=s2[i2];\\n        bool ans=false;\\n        if(c1==s3[i3])ans |= c(i1+1,i2,i3+1,s1,s2,s3,dp);\\n        if(c2==s3[i3])ans |= c(i1,i2+1,i3+1,s1,s2,s3,dp);\\n        return dp[i1][i2][i3]=ans;\\n        }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        vector<vector<vector<int>>>dp(s1.size()+1,vector<vector<int>>(s2.size()+1,vector<int>(s3.size(),-1)));\\n        return c(0,0,0,s1,s2,s3,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104260,
                "title": "java-dfs-faster-than-100-solution-pictorial-explanation",
                "content": "Consider the examples in the picture below to understand how we can DFS over the strings.\\n\\n![image](https://assets.leetcode.com/users/images/a3cb6432-f974-487b-b16c-b488f06f5596_1615451866.8777242.png)\\n![image](https://assets.leetcode.com/users/images/63847cfb-0c44-4271-8e55-2d6128edaa02_1615451906.4169378.png)\\n\\nCode : \\n```\\nclass Solution {\\n    \\n    private boolean dfs(String s1, String s2, String s3, int i, int j, int k, boolean[][] visited){\\n        if(i == s1.length() && j == s2.length()) return true;\\n        if(i > s1.length() || j > s2.length()) return false;\\n        if(visited[i][j]) return false;\\n        visited[i][j] = true;\\n        boolean a = false, b = false;\\n        if(i < s1.length() && s1.charAt(i) == s3.charAt(k)){\\n            a = dfs(s1, s2, s3, i+1, j, k+1, visited);\\n        }\\n        if(j < s2.length() && s2.charAt(j) == s3.charAt(k)){\\n            b = dfs(s1, s2, s3, i, j+1, k+1, visited); \\n        }   \\n        return a || b;\\n    }\\n    \\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s3.length() < (s1.length() + s2.length()) || s3.length() > (s1.length() + s2.length())) return false;\\n        boolean[][] visited = new boolean[s1.length()+1][s2.length()+1];\\n        return dfs(s1, s2, s3, 0, 0, 0, visited);\\n    }\\n}\\n```\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Interleaving String.\\nMemory Usage: 36.9 MB, less than 94.19% of Java online submissions for Interleaving String.\\n\\nHope this helps !\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private boolean dfs(String s1, String s2, String s3, int i, int j, int k, boolean[][] visited){\\n        if(i == s1.length() && j == s2.length()) return true;\\n        if(i > s1.length() || j > s2.length()) return false;\\n        if(visited[i][j]) return false;\\n        visited[i][j] = true;\\n        boolean a = false, b = false;\\n        if(i < s1.length() && s1.charAt(i) == s3.charAt(k)){\\n            a = dfs(s1, s2, s3, i+1, j, k+1, visited);\\n        }\\n        if(j < s2.length() && s2.charAt(j) == s3.charAt(k)){\\n            b = dfs(s1, s2, s3, i, j+1, k+1, visited); \\n        }   \\n        return a || b;\\n    }\\n    \\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s3.length() < (s1.length() + s2.length()) || s3.length() > (s1.length() + s2.length())) return false;\\n        boolean[][] visited = new boolean[s1.length()+1][s2.length()+1];\\n        return dfs(s1, s2, s3, 0, 0, 0, visited);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505067,
                "title": "7-line-20-ms-small-code-top-down-dp",
                "content": "```python\\nfrom functools import lru_cache\\nclass Solution:    \\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:        \\n        if len(s3) != len(s1) + len(s2): return False\\n        \\n        @lru_cache(None)\\n        def helper(s1,s2,s3):\\n            if not s1: return s2 == s3\\n            if not s2: return s1 == s3    \\n            return (s1[0] == s3[0] and helper(s1[1:],s2,s3[1:])) or (s2[0] == s3[0] and helper(s1, s2[1:],s3[1:]))                    \\n        return helper(s1,s2,s3)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nfrom functools import lru_cache\\nclass Solution:    \\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:        \\n        if len(s3) != len(s1) + len(s2): return False\\n        \\n        @lru_cache(None)\\n        def helper(s1,s2,s3):\\n            if not s1: return s2 == s3\\n            if not s2: return s1 == s3    \\n            return (s1[0] == s3[0] and helper(s1[1:],s2,s3[1:])) or (s2[0] == s3[0] and helper(s1, s2[1:],s3[1:]))                    \\n        return helper(s1,s2,s3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32051,
                "title": "my-dp-c-solution-is-only-10-lines-with-o-n-space",
                "content": "\\n\\n    class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int m = s1.size(), n = s2.size();\\n            if(m+n != s3.size())  return false;\\n            bool c[n+1] = {true};\\n            int i, j = 0;\\n            while(j < n && s2[j] == s3[j]) c[++j] = true;\\n            for(i = 0; i < m; ++i) {\\n                c[0] = c[0] & (s1[i] == s3[i]);\\n                for(j = 1; j <= n; ++j)\\n                    c[j] = ((s1[i] == s3[i+j]) & c[j]) | ((s2[j-1] == s3[i+j]) & c[j-1]);\\n            }\\n            return c[n];\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int m = s1.size(), n = s2.size();\\n            if(m+n != s3.size())  return false;\\n            bool c[n+1] = {true}",
                "codeTag": "Java"
            },
            {
                "id": 32082,
                "title": "c-sharing-my-recursive-tle-and-dp-solution-30ms-easy-to-understand",
                "content": "First, I'm a big recursion person. Here's my first attempt which is purely recursive. At an intermediate stage, we can either match one char from s1 to one char from s3 and advance one pointer at s1 and s3. Or we can do the same with s2 and s3. I'm open to suggestions to my recursive code. One improvement could come from not having to call the strcmp function?\\n\\n\\n    class Solution {\\n    public:\\n        bool isInterleave(char* s1, char* s2, char* s3) {\\n            \\n            if (*s1=='\\\\0' && *s2=='\\\\0')\\n                return *s3=='\\\\0'? true : false;\\n            else if (*s1=='\\\\0'){\\n                return strcmp(s2,s3)==0 ? true : false;\\n            } else if (*s2=='\\\\0'){\\n                return strcmp(s1,s3)==0 ? true : false;\\n            }\\n            \\n            return (*s1==*s3 && isInterleave(s1+1,s2,s3+1)) | (*s2==*s3 && isInterleave(s1,s2+1,s3+1));\\n        }\\n    };\\n\\n\\nHere's the DP version (30ms) as well. Unsurprisingly the DP solution passed the judge and it's pretty efficient. The logic straightforward if you understood the recursive version since there's 1:1 correspondence between the two code. I think it's elegant since it doesn't have any ugly if, else if shenanigans.\\n\\n    class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3){\\n            int n1 = s1.length(), n2 = s2.length(), n3 = s3.length();\\n            if (n1+n2 != n3) return false;\\n            \\n            vector<vector<bool>> V(n1+1, vector<bool>(n2+1, false));\\n            \\n            V[n1][n2] = (s3[n1+n2]=='\\\\0');\\n            \\n            // fill bottom\\n            for (int j=n2-1; j>=0; j--) V[n1][j]  = (s2[j]==s3[n1+j] && V[n1][j+1]);\\n            \\n            // fill right\\n            for (int i=n1-1; i>=0; i--) V[i][n2] = (s1[i]==s3[n2+i] && V[i+1][n2]);\\n            \\n            // fill DP table from bottom right\\n            for (int j=n2-1; j>=0; j--){\\n                for (int i=n1-1; i>=0; i--){\\n                    V[i][j] = (s1[i]==s3[i+j] && V[i+1][j]) | (s2[j]==s3[i+j] && V[i][j+1]);\\n                }\\n            }\\n            return V[0][0];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isInterleave(char* s1, char* s2, char* s3) {\\n            \\n            if (*s1=='\\\\0' && *s2=='\\\\0')\\n                return *s3=='\\\\0'? true : false;\\n            else if (*s1=='\\\\0'){\\n                return strcmp(s2,s3)==0 ? true : false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3187750,
                "title": "interleaving-string-python3-with-comments-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nOne way to form s3 from s1 and s2 is to take one character from s1 or s2 at a time and append it to s3. We can keep track of the index of the last character from s1 and s2 that was appended to s3. If at any point, we cannot append a character to s3, we backtrack and try a different path.\\n\\nTo optimize this approach, we can use dynamic programming. We can define a 2D boolean array dp, where dp[i][j] is true if s3[0:i+j] can be formed by an interleaving of s1[0:i] and s2[0:j].\\n\\nThe base case is when i = j = 0, and dp[0][0] is true. If either i or j is zero, then dp[i][j] is true if s3[0:i+j] is equal to either s1[0:i] or s2[0:j].\\n\\nFor the general case, if the last character of s1 matches the last character of s3, then we can append it to s3 and check if dp[i-1][j] is true. Similarly, if the last character of s2 matches the last character of s3, then we can append it to s3 and check if dp[i][j-1] is true.\\n\\nThe final answer is dp[m][n], where m is the length of s1 and n is the length of s2.\\n\\nTime complexity: O(mn), where m is the length of s1 and n is the length of s2.\\nSpace complexity: O(mn), where m is the length of s1 and n is the length of s2.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n    m, n = len(s1), len(s2)\\n    if m + n != len(s3):\\n        return False\\n    \\n    dp = [[False] * (n+1) for _ in range(m+1)]\\n    dp[0][0] = True\\n    \\n    for i in range(m+1):\\n        for j in range(n+1):\\n            if i > 0 and s1[i-1] == s3[i+j-1]:\\n                dp[i][j] = dp[i][j] or dp[i-1][j]\\n            if j > 0 and s2[j-1] == s3[i+j-1]:\\n                dp[i][j] = dp[i][j] or dp[i][j-1]\\n                \\n    return dp[m][n]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n    m, n = len(s1), len(s2)\\n    if m + n != len(s3):\\n        return False\\n    \\n    dp = [[False] * (n+1) for _ in range(m+1)]\\n    dp[0][0] = True\\n    \\n    for i in range(m+1):\\n        for j in range(n+1):\\n            if i > 0 and s1[i-1] == s3[i+j-1]:\\n                dp[i][j] = dp[i][j] or dp[i-1][j]\\n            if j > 0 and s2[j-1] == s3[i+j-1]:\\n                dp[i][j] = dp[i][j] or dp[i][j-1]\\n                \\n    return dp[m][n]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248271,
                "title": "interleaving-string-js-python-java-c-easy-dp-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIf we consider a matrix with indices (**i**) for **s1** on one axis and indices (**j**) for **s2** on the other, then a successful **s3** can be considered a path moving from the top left to the bottom right. At each point, we either move downward (**i++**) by choosing the next letter from **s1** or rightward (**j++**) by choosing the next letter from **s2**.\\n\\nAll that remains, then, is to see which vertices are possible given **s3**, and which ones are not. To do that, we can use a **dynamic programming** (**DP**) approach. Normally, we would establish a matrix as described above, along with a buffer row/column at the start of the matrix to provide space for previous row/column validation checks for the leading edges of our iteration. An additional row/column at the end of the matrix is also needed, since our final checks will occur only _after_ the strings are completed.\\n\\nWe can reduce the **space complexity** of this solution from **O(N * M)** to just **O(M)**, however, if rather than building a full DP matrix, we instead only keep the current row of the matrix (**dp**) in memory, reiterating through it for each row. The **left** value (**dp[j-1]**) will already have been calculated, and the **up** value (**dp[j]**) will not yet have been overwritten in the current cell, so it will still represent the value of the cell from the previous row.\\n\\nWe should also remember to fill **dp[1]** with a **true** (or **1**) value, representing a valid vertex at the starting position of our iteration path.\\n\\nFrom there, we can iterate through the rows, building upon previously completed entries to check the validity of the current cell. If the cell \"above\" (the not-yet-overwritten **dp[i]** represents the same index from the row above) is valid (**true** or **1**) and the corresponding characters of **s1** and **s3** match, then the current cell is valid. Similarly, if the cell to the left is valid and the corresponding characters of **s2** and **s3** match, then the current cell is valid.\\n\\nOnce we\\'ve finished iterating through **i** and **j**, a valid value in the last cell of **dp** will indicate that a valid path exists that matches **s3**, so we can just **return** the contents of that cell.\\n\\n - _**Time Complexity: O(N * M)** where **N** is the length of **s1** and **M** is the length of **s2**_\\n - _**Space Complexity: O(M)** for **dp**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 38.7MB** (beats 99% / 93%).\\n```javascript\\nvar isInterleave = function(s1, s2, s3) {\\n    let n = s1.length + 2, m = s2.length + 2\\n    if (n + m - 4 !== s3.length) return false\\n    let dp = new Uint8Array(m)\\n    dp[1] = 1\\n    for (let i = 1; i < n; i++)\\n        for (let j = 1; j < m; j++) {\\n            let up = dp[j] && s1[i-2] === s3[j+i-3],\\n                left = dp[j-1] && s2[j-2] === s3[j+i-3]\\n            dp[j] = up || left\\n        }\\n    return dp[m-1]\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **36ms / 14.2MB** (beats 61% / 96%).\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        n, m = len(s1) + 2, len(s2) + 2\\n        if n + m - 4 != len(s3): return False\\n        dp = [0] * m\\n        dp[1] = 1\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                up = dp[j] and (i < 2 or s1[i-2] == s3[j+i-3])\\n                left = dp[j-1] and (j < 2 or s2[j-2] == s3[j+i-3])\\n                dp[j] = up or left\\n        return dp[-1]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **2ms / 36.7MB** (beats 80% / 98%).\\n```java\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int n = s1.length() + 2, m = s2.length() + 2;\\n        char[] sc1 = s1.toCharArray(), sc2 = s2.toCharArray(), sc3 = s3.toCharArray();\\n        if (n + m - 4 != s3.length()) return false;\\n        boolean[] dp = new boolean[m];\\n        dp[1] = true;\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++) {\\n                boolean up = dp[j] && (i < 2 || sc1[i-2] == sc3[j+i-3]),\\n                    left =dp[j-1] && (j < 2 || sc2[j-2] == sc3[j+i-3]);\\n                dp[j] = up || left;\\n            }\\n        return dp[m-1];\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 6.6MB** (beats 100% / 61%).\\n```c++\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.length() + 2, m = s2.length() + 2;\\n        if (n + m - 4 != s3.length()) return false;\\n        vector<bool> dp(m);\\n        dp[1] = true;\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++) {\\n                bool up = dp[j] && (i < 2 || s1[i-2] == s3[j+i-3]),\\n                    left = dp[j-1] && (j < 2 || s2[j-2] == s3[j+i-3]);\\n               dp[j] = up || left;\\n            }\\n        return dp[m-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar isInterleave = function(s1, s2, s3) {\\n    let n = s1.length + 2, m = s2.length + 2\\n    if (n + m - 4 !== s3.length) return false\\n    let dp = new Uint8Array(m)\\n    dp[1] = 1\\n    for (let i = 1; i < n; i++)\\n        for (let j = 1; j < m; j++) {\\n            let up = dp[j] && s1[i-2] === s3[j+i-3],\\n                left = dp[j-1] && s2[j-2] === s3[j+i-3]\\n            dp[j] = up || left\\n        }\\n    return dp[m-1]\\n};\\n```\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        n, m = len(s1) + 2, len(s2) + 2\\n        if n + m - 4 != len(s3): return False\\n        dp = [0] * m\\n        dp[1] = 1\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                up = dp[j] and (i < 2 or s1[i-2] == s3[j+i-3])\\n                left = dp[j-1] and (j < 2 or s2[j-2] == s3[j+i-3])\\n                dp[j] = up or left\\n        return dp[-1]\\n```\n```java\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int n = s1.length() + 2, m = s2.length() + 2;\\n        char[] sc1 = s1.toCharArray(), sc2 = s2.toCharArray(), sc3 = s3.toCharArray();\\n        if (n + m - 4 != s3.length()) return false;\\n        boolean[] dp = new boolean[m];\\n        dp[1] = true;\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++) {\\n                boolean up = dp[j] && (i < 2 || sc1[i-2] == sc3[j+i-3]),\\n                    left =dp[j-1] && (j < 2 || sc2[j-2] == sc3[j+i-3]);\\n                dp[j] = up || left;\\n            }\\n        return dp[m-1];\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.length() + 2, m = s2.length() + 2;\\n        if (n + m - 4 != s3.length()) return false;\\n        vector<bool> dp(m);\\n        dp[1] = true;\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++) {\\n                bool up = dp[j] && (i < 2 || s1[i-2] == s3[j+i-3]),\\n                    left = dp[j-1] && (j < 2 || s2[j-2] == s3[j+i-3]);\\n               dp[j] = up || left;\\n            }\\n        return dp[m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247663,
                "title": "interleaving-string-dp-o-s2-length-java",
                "content": "```java\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length())\\n            return false;\\n        int m = s1.length(), n = s2.length();\\n        \\n        boolean[] dp = new boolean[n+1];\\n        dp[0] = true;\\n        for (int i = 1; i <= n; ++i) {\\n            dp[i] = dp[i-1] && s3.charAt(i-1) == s2.charAt(i-1);\\n        }\\n        \\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 0; j <= n; ++j) {\\n                if (j == 0)\\n                    dp[j] = dp[j] && s3.charAt(i-1) == s1.charAt(i-1);\\n                else\\n                    dp[j] = (dp[j] && s3.charAt(i+j-1) == s1.charAt(i-1)) || (dp[j-1] && s3.charAt(i+j-1) == s2.charAt(j-1));\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length())\\n            return false;\\n        int m = s1.length(), n = s2.length();\\n        \\n        boolean[] dp = new boolean[n+1];\\n        dp[0] = true;\\n        for (int i = 1; i <= n; ++i) {\\n            dp[i] = dp[i-1] && s3.charAt(i-1) == s2.charAt(i-1);\\n        }\\n        \\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 0; j <= n; ++j) {\\n                if (j == 0)\\n                    dp[j] = dp[j] && s3.charAt(i-1) == s1.charAt(i-1);\\n                else\\n                    dp[j] = (dp[j] && s3.charAt(i+j-1) == s1.charAt(i-1)) || (dp[j-1] && s3.charAt(i+j-1) == s2.charAt(j-1));\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 602726,
                "title": "python-recursive-solution-with-memoization-and-explanation",
                "content": "The recursive function takes in the 2 given strings and the target string, shortening either s1 or s2, and s3 by 1 character for each successful recursive stack.\\n\\nLet\\'s take a simple example where memoization will be useful:\\n* \\ts1: \\'abc\\'\\n* \\ts2: \\'ade\\'\\n* \\ts3: \\'aabdce\\'\\n\\nThe recursive stack tree visualization would look like this:\\n```\\n                          [\\'abc\\'][\\'ade\\'][\\'aabdce\\']\\n                       /                            \\\\\\n           a[\\'bc\\'][\\'ade\\'][\\'abdce\\']            a[\\'de\\'][\\'abc\\'][\\'abdce\\']\\n              /          \\\\                               \\\\\\n           aa[\\'bc\\'][\\'de\\'][\\'bdce\\']           aa[\\'de\\'][\\'abc\\'][\\'bdce\\'] (already seen, so prune here)\\n\\t         /             \\\\\\n\\taab[\\'c\\'][\\'de\\'][\\'dce\\']   aad[\\'bc\\'][\\'e\\'][\\'bdce\\'] (\\'d\\' does not match \\'b\\', so stop here)\\n\\t            \\\\\\n\\taabd[\\'c\\'][\\'e\\'][\\'ce\\']\\n\\t           /\\n\\taabdc[\\'\\'][\\'e\\'][\\'e\\']\\n\\t           \\\\\\n\\taabdce[\\'\\'][\\'\\'][\\'\\'] (return True)\\n```\\nWhere the first word is the current string, followed by s1, s2 and s3.\\nEach left branch indicates popping the first letter of s1 if it matches the first letter of s3.\\nRight branch for s2 under the same condition.\\n\\n**Base case**\\nWe return True if all s1, s2 and s3 are empty.\\nThis means that we have exhaustively used all s1 and s2 to generate s3.\\n\\n**Recursive call**\\nIn each recursive stack, we have 2 options, to check s1 or s2.\\nWe do this for either s1, s2 (or both) if their first letter matches the remaining first letter of s3.\\n\\n**Memoization**\\nWe keep track of the combinations we have seen so far by keeping a record of the remaining s1 + s2 or s2 + s1.\\nThe order does not matter since the recursion will perform the algorithm on both strings anyway.\\nSo after we have done each recursive call, we need to add this to the set, and only continue if we haven\\'t seen that combination in the set yet.\\n\\n**Return value**\\nWe return True if any of the branches returns True.\\nSo we use the \\'or\\' operation with False as the default answer.\\n```\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        \\n        seen = set()\\n        \\n        def recursive(s, t, remaining):\\n            if len(s) == len(t) == len(remaining) == 0:\\n                return True\\n            \\n            ans = False\\n            \\n            if len(s) > 0 and len(remaining) > 0 and s[0] == remaining[0] and (s[1:]+\\'.\\'+t not in seen or t[1:]+\\'.\\'+s not in seen):\\n                seen.add(s[1:]+\\'.\\'+t)\\n                ans = recursive(s[1:],t,remaining[1:])\\n            if len(t) > 0 and len(remaining) > 0 and t[0] == remaining[0] and (s[1:]+\\'.\\'+t not in seen or t[1:]+\\'.\\'+s not in seen):\\n\\t\\t\\t    seen.add(t[1:]+\\'.\\'+s)\\n                ans = ans or recursive(s, t[1:], remaining[1:])\\n\\n            return ans\\n        \\n        return recursive(s1, s2, s3)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n                          [\\'abc\\'][\\'ade\\'][\\'aabdce\\']\\n                       /                            \\\\\\n           a[\\'bc\\'][\\'ade\\'][\\'abdce\\']            a[\\'de\\'][\\'abc\\'][\\'abdce\\']\\n              /          \\\\                               \\\\\\n           aa[\\'bc\\'][\\'de\\'][\\'bdce\\']           aa[\\'de\\'][\\'abc\\'][\\'bdce\\'] (already seen, so prune here)\\n\\t         /             \\\\\\n\\taab[\\'c\\'][\\'de\\'][\\'dce\\']   aad[\\'bc\\'][\\'e\\'][\\'bdce\\'] (\\'d\\' does not match \\'b\\', so stop here)\\n\\t            \\\\\\n\\taabd[\\'c\\'][\\'e\\'][\\'ce\\']\\n\\t           /\\n\\taabdc[\\'\\'][\\'e\\'][\\'e\\']\\n\\t           \\\\\\n\\taabdce[\\'\\'][\\'\\'][\\'\\'] (return True)\\n```\n```\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        \\n        seen = set()\\n        \\n        def recursive(s, t, remaining):\\n            if len(s) == len(t) == len(remaining) == 0:\\n                return True\\n            \\n            ans = False\\n            \\n            if len(s) > 0 and len(remaining) > 0 and s[0] == remaining[0] and (s[1:]+\\'.\\'+t not in seen or t[1:]+\\'.\\'+s not in seen):\\n                seen.add(s[1:]+\\'.\\'+t)\\n                ans = recursive(s[1:],t,remaining[1:])\\n            if len(t) > 0 and len(remaining) > 0 and t[0] == remaining[0] and (s[1:]+\\'.\\'+t not in seen or t[1:]+\\'.\\'+s not in seen):\\n\\t\\t\\t    seen.add(t[1:]+\\'.\\'+s)\\n                ans = ans or recursive(s, t[1:], remaining[1:])\\n\\n            return ans\\n        \\n        return recursive(s1, s2, s3)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 200455,
                "title": "from-brute-force-to-dp",
                "content": "### Brute Force\\nTry matching s1 and s2 with s3 one letter at a time.\\n```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        return isInterleaveFrom(s1, s2, s3, 0, 0, 0);\\n    }\\n    \\n    private boolean isInterleaveFrom(\\n        String m, String n, String p,\\n        int mIndex, int nIndex, int pIndex) {\\n        if (pIndex == p.length())\\n            return mIndex == m.length() && nIndex == n.length();\\n        \\n        if (mIndex < m.length() && m.charAt(mIndex) == p.charAt(pIndex)) {\\n            if (isInterleaveFrom(m, n, p, mIndex + 1, nIndex, pIndex + 1))\\n                return true;\\n        }\\n        if (nIndex < n.length() && n.charAt(nIndex) == p.charAt(pIndex)) {\\n            if (isInterleaveFrom(m, n, p, mIndex, nIndex + 1, pIndex + 1))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n### Top-down DP\\n```\\nclass Solution {\\n    private Map<String, Boolean> dp;\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        dp = new HashMap<>();\\n        return isInterleaveFrom(s1, s2, s3, 0, 0, 0);\\n    }\\n    \\n    private boolean isInterleaveFrom(\\n        String m, String n, String p,\\n        int mIndex, int nIndex, int pIndex) {\\n        if (pIndex == p.length())\\n            return mIndex == m.length() && nIndex == n.length();\\n        \\n        String key = mIndex + \"|\" + nIndex + \"|\" + pIndex;\\n        if (dp.containsKey(key))\\n            return dp.get(key);\\n        \\n        if (mIndex < m.length() && m.charAt(mIndex) == p.charAt(pIndex)) {\\n            if (isInterleaveFrom(m, n, p, mIndex + 1, nIndex, pIndex + 1)) {\\n                dp.put(key, true);\\n                return true;\\n            }\\n        }\\n        if (nIndex < n.length() && n.charAt(nIndex) == p.charAt(pIndex)) {\\n            if (isInterleaveFrom(m, n, p, mIndex, nIndex + 1, pIndex + 1)) {\\n                dp.put(key, true);\\n                return true;\\n            }\\n        }\\n        dp.put(key, false);\\n        return false;\\n    }\\n}\\n```\\n### Bottom-up DP\\n\\n```\\nclass Solution {\\n    public boolean isInterleave(String m, String n, String p) {\\n        boolean[][] dp = new boolean[m.length() + 1][n.length() + 1];\\n\\n        if (m.length() + n.length() != p.length())\\n            return false;\\n\\n        for (int mIndex = 0; mIndex <= m.length(); mIndex++) {\\n            for (int nIndex = 0; nIndex <= n.length(); nIndex++) {\\n                if (mIndex == 0 && nIndex == 0) {\\n                    dp[mIndex][nIndex] = true;\\n                } else {\\n                    if (mIndex > 0 && m.charAt(mIndex - 1) == p.charAt(mIndex + nIndex - 1))\\n                        dp[mIndex][nIndex] = dp[mIndex - 1][nIndex];\\n                    \\n                    if (nIndex > 0 && n.charAt(nIndex - 1) == p.charAt(mIndex + nIndex - 1))\\n                        dp[mIndex][nIndex] |= dp[mIndex][nIndex - 1];\\n                }\\n            }\\n        }\\n        \\n        return dp[m.length()][n.length()];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        return isInterleaveFrom(s1, s2, s3, 0, 0, 0);\\n    }\\n    \\n    private boolean isInterleaveFrom(\\n        String m, String n, String p,\\n        int mIndex, int nIndex, int pIndex) {\\n        if (pIndex == p.length())\\n            return mIndex == m.length() && nIndex == n.length();\\n        \\n        if (mIndex < m.length() && m.charAt(mIndex) == p.charAt(pIndex)) {\\n            if (isInterleaveFrom(m, n, p, mIndex + 1, nIndex, pIndex + 1))\\n                return true;\\n        }\\n        if (nIndex < n.length() && n.charAt(nIndex) == p.charAt(pIndex)) {\\n            if (isInterleaveFrom(m, n, p, mIndex, nIndex + 1, pIndex + 1))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private Map<String, Boolean> dp;\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        dp = new HashMap<>();\\n        return isInterleaveFrom(s1, s2, s3, 0, 0, 0);\\n    }\\n    \\n    private boolean isInterleaveFrom(\\n        String m, String n, String p,\\n        int mIndex, int nIndex, int pIndex) {\\n        if (pIndex == p.length())\\n            return mIndex == m.length() && nIndex == n.length();\\n        \\n        String key = mIndex + \"|\" + nIndex + \"|\" + pIndex;\\n        if (dp.containsKey(key))\\n            return dp.get(key);\\n        \\n        if (mIndex < m.length() && m.charAt(mIndex) == p.charAt(pIndex)) {\\n            if (isInterleaveFrom(m, n, p, mIndex + 1, nIndex, pIndex + 1)) {\\n                dp.put(key, true);\\n                return true;\\n            }\\n        }\\n        if (nIndex < n.length() && n.charAt(nIndex) == p.charAt(pIndex)) {\\n            if (isInterleaveFrom(m, n, p, mIndex, nIndex + 1, pIndex + 1)) {\\n                dp.put(key, true);\\n                return true;\\n            }\\n        }\\n        dp.put(key, false);\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isInterleave(String m, String n, String p) {\\n        boolean[][] dp = new boolean[m.length() + 1][n.length() + 1];\\n\\n        if (m.length() + n.length() != p.length())\\n            return false;\\n\\n        for (int mIndex = 0; mIndex <= m.length(); mIndex++) {\\n            for (int nIndex = 0; nIndex <= n.length(); nIndex++) {\\n                if (mIndex == 0 && nIndex == 0) {\\n                    dp[mIndex][nIndex] = true;\\n                } else {\\n                    if (mIndex > 0 && m.charAt(mIndex - 1) == p.charAt(mIndex + nIndex - 1))\\n                        dp[mIndex][nIndex] = dp[mIndex - 1][nIndex];\\n                    \\n                    if (nIndex > 0 && n.charAt(nIndex - 1) == p.charAt(mIndex + nIndex - 1))\\n                        dp[mIndex][nIndex] |= dp[mIndex][nIndex - 1];\\n                }\\n            }\\n        }\\n        \\n        return dp[m.length()][n.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32041,
                "title": "share-my-dp-solution-in-java-o-mn-in-time-and-space",
                "content": "    public class Solution {\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            if(s1.length()+s2.length() != s3.length())\\n                return false;\\n            boolean[][] record = new boolean[s1.length()+1][s2.length()+1];\\n            for(int i = 0; i<=s1.length(); i++){\\n                if(s1.substring(0, i).equals(s3.substring(0, i))){\\n                    record[i][0] = true;\\n                }\\n            }\\n            for(int i = 0; i<=s2.length(); i++){\\n                if(s2.substring(0, i).equals(s3.substring(0, i))){\\n                    record[0][i] = true;\\n                }\\n            }\\n            for(int i = 1; i<=s1.length(); i++){\\n                for(int j = 1; j<=s2.length(); j++){\\n                    if(record[i][j-1]&&s2.charAt(j-1)==s3.charAt(i+j-1))\\n                        record[i][j]=true;\\n                    if(record[i-1][j]&&s1.charAt(i-1)==s3.charAt(i+j-1))\\n                        record[i][j]=true;\\n                }\\n            }\\n            return record[s1.length()][s2.length()];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            if(s1.length()+s2.length() != s3.length())\\n                return false;\\n            boolean[][] record = new boolean[s1.length()+1][s2.length()+1];\\n            for(int i = 0; i<=s1.length(); i++){\\n                if(s1.substring(0, i).equals(s3.substring(0, i))){\\n                    record[i][0] = true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3956432,
                "title": "c-2d-recursive-iterative-dp-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse 2D recursive DP(top-down) to solve.\\n2nd solution is just rewritting of the 1st one into iterative solution(Bottom-up).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n_1 n_2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n_1 n_2)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size(), n2=s2.size(), n3=s3.size();\\n        if (n1+n2!=n3) return 0;\\n        vector<vector<int>> dp(n1+1 , vector<int>(n2+1, -1));\\n        function<int(int, int)> dfs=[&](int i, int j)->int\\n        {\\n            if (i==n1 && j==n2) return dp[i][j]=1;\\n            if (dp[i][j]!=-1) return dp[i][j];\\n            int ch_s1, ch_s2;\\n            if (i<n1 && s1[i]==s3[i+j]) ch_s1=dfs(i+1,j);\\n            if (j<n2 && s2[j]==s3[i+j]) ch_s2=dfs(i,j+1);\\n            return dp[i][j]=ch_s1||ch_s2;\\n        };\\n        return dfs(0, 0)!=0;\\n    }\\n};\\n```\\n# Code for 2D iterative DP\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1 = s1.size(), n2 = s2.size(), n3 = s3.size();\\n        if (n1+n2!=n3) return 0;\\n        \\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1, 0));\\n        dp[n1][n2] = 1;\\n        \\n        for (int i=n1; i >= 0; i--) {\\n            for (int j=n2; j >= 0; j--) {\\n                if (i<n1 && s1[i]==s3[i+j]) \\n                    dp[i][j] = dp[i][j] || dp[i+1][j];\\n                if (j<n2 && s2[j]==s3[i+j]) \\n                    dp[i][j] = dp[i][j] || dp[i][j+1];\\n            }\\n        }  \\n        return dp[0][0] == 1;\\n    }\\n};\\n```\\n# Code with Explanation in comments\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size(), n2=s2.size(), n3=s3.size();\\n        \\n        //Check if the total length of s1 and s2 is equal to the length of s3\\n        if (n1+n2!=n3) return 0;\\n        \\n        // Initialize a 2D DP array\\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1, 0));\\n        \\n        // Set the base case: the last cell in the DP array is initialized as 1\\n        dp[n1][n2] = 1;\\n        \\n        //Iterate over the DP array from bottom-right to top-left\\n        for (int i=n1; i >= 0; i--) {\\n            for (int j=n2; j >= 0; j--) {\\n                //If there are characters left in s1 and the character matches s3\\n                if (i<n1 && s1[i]==s3[i+j]) \\n                    dp[i][j]=dp[i][j] || dp[i+1][j]; // Take value from the cell below\\n                \\n                //If there are characters left in s2 and the character matches s3\\n                if (j<n2 && s2[j]==s3[i+j]) \\n                    dp[i][j]=dp[i][j] || dp[i][j+1]; //Take value from the cell on the right\\n            }\\n        }  \\n\\n        // Return true if the top-left cell of the DP array is 1 \\n        return dp[0][0] == 1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size(), n2=s2.size(), n3=s3.size();\\n        if (n1+n2!=n3) return 0;\\n        vector<vector<int>> dp(n1+1 , vector<int>(n2+1, -1));\\n        function<int(int, int)> dfs=[&](int i, int j)->int\\n        {\\n            if (i==n1 && j==n2) return dp[i][j]=1;\\n            if (dp[i][j]!=-1) return dp[i][j];\\n            int ch_s1, ch_s2;\\n            if (i<n1 && s1[i]==s3[i+j]) ch_s1=dfs(i+1,j);\\n            if (j<n2 && s2[j]==s3[i+j]) ch_s2=dfs(i,j+1);\\n            return dp[i][j]=ch_s1||ch_s2;\\n        };\\n        return dfs(0, 0)!=0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1 = s1.size(), n2 = s2.size(), n3 = s3.size();\\n        if (n1+n2!=n3) return 0;\\n        \\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1, 0));\\n        dp[n1][n2] = 1;\\n        \\n        for (int i=n1; i >= 0; i--) {\\n            for (int j=n2; j >= 0; j--) {\\n                if (i<n1 && s1[i]==s3[i+j]) \\n                    dp[i][j] = dp[i][j] || dp[i+1][j];\\n                if (j<n2 && s2[j]==s3[i+j]) \\n                    dp[i][j] = dp[i][j] || dp[i][j+1];\\n            }\\n        }  \\n        return dp[0][0] == 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size(), n2=s2.size(), n3=s3.size();\\n        \\n        //Check if the total length of s1 and s2 is equal to the length of s3\\n        if (n1+n2!=n3) return 0;\\n        \\n        // Initialize a 2D DP array\\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1, 0));\\n        \\n        // Set the base case: the last cell in the DP array is initialized as 1\\n        dp[n1][n2] = 1;\\n        \\n        //Iterate over the DP array from bottom-right to top-left\\n        for (int i=n1; i >= 0; i--) {\\n            for (int j=n2; j >= 0; j--) {\\n                //If there are characters left in s1 and the character matches s3\\n                if (i<n1 && s1[i]==s3[i+j]) \\n                    dp[i][j]=dp[i][j] || dp[i+1][j]; // Take value from the cell below\\n                \\n                //If there are characters left in s2 and the character matches s3\\n                if (j<n2 && s2[j]==s3[i+j]) \\n                    dp[i][j]=dp[i][j] || dp[i][j+1]; //Take value from the cell on the right\\n            }\\n        }  \\n\\n        // Return true if the top-left cell of the DP array is 1 \\n        return dp[0][0] == 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252482,
                "title": "java-5-methods-explained",
                "content": "**Method 1:** Recursion. Gets TLE\\n* Follow binary tree approach in which we take a character from one string and check if it matches\\n* If yes, then repeat, else backtrack and try other possibilities\\n* Method 1 will have repeated sub-problems which can be optimized using memoization (method 2)\\n>**T/S:** O(2 ^ (m + n))/O(m + n), where m = size(s1), n = size(s2)\\n\\nExample:\\n![image](https://assets.leetcode.com/users/images/030aa1fc-934b-4124-824b-0bad2fe0ecee_1657227944.4161835.png)\\n\\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\treturn m + n == s3.length() && isInterleave(s1, s2, s3, m, n, 0, 0);\\n}\\n\\nprivate boolean isInterleave(String s1, String s2, String s3, int m, int n, int i, int j) {\\n\\treturn i == m && j == n // reached end of both strings, so interleaving\\n\\t\\t|| i < m && s1.charAt(i) == s3.charAt(i + j) && isInterleave(s1, s2, s3, m, n, i + 1, j) // recurse over s1\\n\\t\\t|| j < n && s2.charAt(j) == s3.charAt(i + j) && isInterleave(s1, s2, s3, m, n, i, j + 1); // recurse over s2\\n}\\n```\\n**Method 2:** Inject memoization in method 1. Top Down DP (Memoization)\\n>**T/S:** O(mn)/O(mn)\\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\treturn m + n == s3.length() \\n\\t\\t&& isInterleave(s1, s2, s3, m, n, 0, 0, new Boolean[m + 1][n + 1]);\\n}\\n\\nprivate boolean isInterleave(String s1, String s2, String s3, int m, int n, int i, int j, Boolean[][] memo) {\\n\\tif (i == m && j == n)\\n\\t\\treturn true;\\n\\tif (memo[i][j] != null)\\n\\t\\treturn memo[i][j];\\n\\t\\t\\n\\treturn memo[i][j] = i < m && s1.charAt(i) == s3.charAt(i + j) && isInterleave(s1, s2, s3, m, n, i + 1, j, memo) \\n\\t\\t\\t\\t\\t || j < n && s2.charAt(j) == s3.charAt(i + j) && isInterleave(s1, s2, s3, m, n, i, j + 1, memo);\\n}\\n```\\n**Method 3:** Top Down Tabulation version of method 2\\n* Same idea, just iterative\\n>**T/S:** O(mn)/O(mn)\\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\tif (m + n != s3.length())\\n\\t\\treturn false;\\n\\n\\tvar dp = new boolean[m + 1][n + 1];\\n\\tdp[m][n] = true;\\n\\n\\tfor (var i = m; i >= 0; i--)\\n\\t\\tfor (var j = n; j >= 0; j--)\\n\\t\\t\\tif (i < m && s1.charAt(i) == s3.charAt(i + j) && dp[i + 1][j] \\n\\t\\t\\t || j < n && s2.charAt(j) == s3.charAt(i + j) && dp[i][j + 1])\\t\\t\\t\\t\\n\\t\\t\\t\\tdp[i][j] = true;\\n\\n\\treturn dp[0][0];\\n}\\n```\\n**Method 4:** Bottom Up DP (Tabulation)\\n* For each cell consider only the strings upto that point\\n* For the top left corner, both strings are empty and interleave to empty portion of s2, so `isInterleave = true`\\n* For the first column s2 is considered empty and for first row s1 is considered empty. Now fill out if the corresponding letter of s1 and s3 match. Repeat for s2 and s3. E.g.\\n\\t* s1 = aabcc, s3 = aadbbcbcac, matches occur for first 2 letters so the value is true, rest are false\\n* For cell (2, 2), consider the strings s1 = aa, s2 = db, s3 = aadb\\n\\t* Check top neighbor (remove 1 char from s1), i.e. s1 = a, s2 = db. Its false, so do nothing. False is expected since a and db can\\'t be interleaved in any way to form the first 3 letters of s3 \\n\\t* Check left neighbot (remove 1 char from s2), i.e. s1 = aa, s2 = d. Its true, so check next condition. True is expected because `aa` and `d`  can be interleaved to form the first 3 letters of s3.\\n\\t\\t* Next condition is to check whether current char of s2 is the same as current char of s3, which is true since they both are b\\n\\t\\t* Since both the conditions are true, it means s1 and s2 can be interleaved to form s3, thus the value here would be true\\n* Continue doing this for complete strings s1 and s2. Value in bottom right corner will be the answer since that denotes the end of the interleaving of 2 strings\\n\\t\\t\\nExample: `s1 = aabcc, s2 = dbbca, s3 = aadbbcbcac`\\n\\n![image](https://assets.leetcode.com/users/images/ef2f6ce0-615f-4a6b-93e2-ce34fcfff488_1657228807.3073637.png)\\n\\n>**T/S:** O(mn)/O(mn)\\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\tif (m + n != s3.length())\\n\\t\\treturn false;\\n\\n\\tvar dp = new boolean[m + 1][n + 1];\\n\\tdp[0][0] = true;\\n\\n\\tfor (var i = 0; i < m && dp[i][0]; i++)\\n\\t\\tdp[i + 1][0] = s1.charAt(i) == s3.charAt(i) && dp[i][0];\\n\\n\\tfor (var j = 0; j < n && dp[0][j]; j++)\\n\\t\\tdp[0][j + 1] = s2.charAt(j) == s3.charAt(j) && dp[0][j];\\n\\n\\tfor (var i = 1; i <= m; i++)\\n\\t\\tfor (var j = 1; j <= n; j++)\\n\\t\\t\\tdp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)\\n\\t\\t\\t\\t\\t|| dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\treturn dp[m][n];\\n}\\n```\\n**Method 5:** Space optimized version of Method 3\\n* In any iteration only the current row and previous row of dp is being used, so we need only 2 rows, not m\\n>**T/S:** O(mn)/O(n)\\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\tif (m + n != s3.length())\\n\\t\\treturn false;\\n\\n\\tvar dp = new boolean[n + 1];\\n\\n\\tfor (var i = 0; i <= m; i++)\\n\\t\\tfor (var j = 0; j <= n; j++) {\\n\\t\\t\\tvar first = j != 0 && dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\t\\t\\tvar second = i != 0 && dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\tif (i == 0 && j == 0)\\n\\t\\t\\t\\tdp[j] = true;\\n\\t\\t\\telse if (i == 0)\\n\\t\\t\\t\\tdp[j] = first;\\n\\t\\t\\telse if (j == 0)\\n\\t\\t\\t\\tdp[j] = second;\\n\\t\\t\\telse\\n\\t\\t\\t\\tdp[j] = first || second;\\n\\t\\t}\\n\\treturn dp[n];\\n}\\n```\\n\\n***Please upvote if this helps***\\n",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\treturn m + n == s3.length() && isInterleave(s1, s2, s3, m, n, 0, 0);\\n}\\n\\nprivate boolean isInterleave(String s1, String s2, String s3, int m, int n, int i, int j) {\\n\\treturn i == m && j == n // reached end of both strings, so interleaving\\n\\t\\t|| i < m && s1.charAt(i) == s3.charAt(i + j) && isInterleave(s1, s2, s3, m, n, i + 1, j) // recurse over s1\\n\\t\\t|| j < n && s2.charAt(j) == s3.charAt(i + j) && isInterleave(s1, s2, s3, m, n, i, j + 1); // recurse over s2\\n}\\n```\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\treturn m + n == s3.length() \\n\\t\\t&& isInterleave(s1, s2, s3, m, n, 0, 0, new Boolean[m + 1][n + 1]);\\n}\\n\\nprivate boolean isInterleave(String s1, String s2, String s3, int m, int n, int i, int j, Boolean[][] memo) {\\n\\tif (i == m && j == n)\\n\\t\\treturn true;\\n\\tif (memo[i][j] != null)\\n\\t\\treturn memo[i][j];\\n\\t\\t\\n\\treturn memo[i][j] = i < m && s1.charAt(i) == s3.charAt(i + j) && isInterleave(s1, s2, s3, m, n, i + 1, j, memo) \\n\\t\\t\\t\\t\\t || j < n && s2.charAt(j) == s3.charAt(i + j) && isInterleave(s1, s2, s3, m, n, i, j + 1, memo);\\n}\\n```\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\tif (m + n != s3.length())\\n\\t\\treturn false;\\n\\n\\tvar dp = new boolean[m + 1][n + 1];\\n\\tdp[m][n] = true;\\n\\n\\tfor (var i = m; i >= 0; i--)\\n\\t\\tfor (var j = n; j >= 0; j--)\\n\\t\\t\\tif (i < m && s1.charAt(i) == s3.charAt(i + j) && dp[i + 1][j] \\n\\t\\t\\t || j < n && s2.charAt(j) == s3.charAt(i + j) && dp[i][j + 1])\\t\\t\\t\\t\\n\\t\\t\\t\\tdp[i][j] = true;\\n\\n\\treturn dp[0][0];\\n}\\n```\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\tif (m + n != s3.length())\\n\\t\\treturn false;\\n\\n\\tvar dp = new boolean[m + 1][n + 1];\\n\\tdp[0][0] = true;\\n\\n\\tfor (var i = 0; i < m && dp[i][0]; i++)\\n\\t\\tdp[i + 1][0] = s1.charAt(i) == s3.charAt(i) && dp[i][0];\\n\\n\\tfor (var j = 0; j < n && dp[0][j]; j++)\\n\\t\\tdp[0][j + 1] = s2.charAt(j) == s3.charAt(j) && dp[0][j];\\n\\n\\tfor (var i = 1; i <= m; i++)\\n\\t\\tfor (var j = 1; j <= n; j++)\\n\\t\\t\\tdp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)\\n\\t\\t\\t\\t\\t|| dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\treturn dp[m][n];\\n}\\n```\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\tif (m + n != s3.length())\\n\\t\\treturn false;\\n\\n\\tvar dp = new boolean[n + 1];\\n\\n\\tfor (var i = 0; i <= m; i++)\\n\\t\\tfor (var j = 0; j <= n; j++) {\\n\\t\\t\\tvar first = j != 0 && dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\t\\t\\tvar second = i != 0 && dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\tif (i == 0 && j == 0)\\n\\t\\t\\t\\tdp[j] = true;\\n\\t\\t\\telse if (i == 0)\\n\\t\\t\\t\\tdp[j] = first;\\n\\t\\t\\telse if (j == 0)\\n\\t\\t\\t\\tdp[j] = second;\\n\\t\\t\\telse\\n\\t\\t\\t\\tdp[j] = first || second;\\n\\t\\t}\\n\\treturn dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2250499,
                "title": "python-easiest-alternative-o-n-space-solution-beats-97-19",
                "content": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        \\n        curr_layer, next_layer = set([(-1, -1)]), set()\\n        i3 = 0\\n        \\n        while curr_layer and i3 < len(s3):\\n            for i1, i2 in curr_layer:\\n                if i1 + 1 < len(s1) and s1[i1 + 1] == s3[i3]:\\n                    next_layer.add((i1 + 1, i2))\\n                if i2 + 1 < len(s2) and s2[i2 + 1] == s3[i3]:\\n                    next_layer.add((i1, i2 + 1))\\n            curr_layer, next_layer = next_layer, set()\\n            if curr_layer:\\n                i3 += 1\\n        \\n        return i3 == len(s3)\\n```\\n\\nIn this solution, we represent all possible combinations in a graph, and each time in the loop we go down one level in depth.\\n\\nTime Complexity - ```O(M *N)```, ```37``` ms, faster than ```97.19%```\\nSpace \\u0421omplexity - ```O(N)```,  ```13.9``` MB, faster than ```98.69%```\\n\\nVisualization:\\n![image](https://assets.leetcode.com/users/images/69135256-b4d7-48aa-b7d7-266639118969_1657195236.3817675.jpeg)\\n![image](https://assets.leetcode.com/users/images/bc25a80b-242d-4548-b5b4-ee0ecd75f1dd_1657195282.757755.jpeg)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        \\n        curr_layer, next_layer = set([(-1, -1)]), set()\\n        i3 = 0\\n        \\n        while curr_layer and i3 < len(s3):\\n            for i1, i2 in curr_layer:\\n                if i1 + 1 < len(s1) and s1[i1 + 1] == s3[i3]:\\n                    next_layer.add((i1 + 1, i2))\\n                if i2 + 1 < len(s2) and s2[i2 + 1] == s3[i3]:\\n                    next_layer.add((i1, i2 + 1))\\n            curr_layer, next_layer = next_layer, set()\\n            if curr_layer:\\n                i3 += 1\\n        \\n        return i3 == len(s3)\\n```\n```O(M *N)```\n```37```\n```97.19%```\n```O(N)```\n```13.9```\n```98.69%```",
                "codeTag": "Java"
            },
            {
                "id": 2249083,
                "title": "cpp-beats-100-runtime-and-100-memory-usage-users-simple-dp-memoization",
                "content": "![image](https://assets.leetcode.com/users/images/37f82ee7-e049-4f80-8432-e08a34b9e045_1657170763.5329103.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        if(s1.size() + s2.size()!=s3.size()){\\n            return false;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return fun(s1,s2,s3,0,0,0);\\n        \\n    }\\n    \\n    int dp[105][105];\\n    \\n    int fun(string& s1,string& s2,string& s3,int p1,int p2,int p3){\\n        \\n        if(p1+p2==s3.size()){\\n            return true;\\n        }\\n        \\n        if(dp[p1][p2]!=-1){\\n            return dp[p1][p2];\\n        }\\n        \\n        bool res = false;\\n        \\n        if(p1!=s1.size()&&s1[p1]==s3[p3]) res|=fun(s1,s2,s3,p1+1,p2,p3+1);\\n        if(p2!=s2.size()&&s2[p2]==s3[p3]) res|=fun(s1,s2,s3,p1,p2+1,p3+1);\\n        \\n        return dp[p1][p2]=res;\\n        \\n    }\\n    \\n};\\n```\\n\\n\\n##### Upvote !!",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        if(s1.size() + s2.size()!=s3.size()){\\n            return false;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return fun(s1,s2,s3,0,0,0);\\n        \\n    }\\n    \\n    int dp[105][105];\\n    \\n    int fun(string& s1,string& s2,string& s3,int p1,int p2,int p3){\\n        \\n        if(p1+p2==s3.size()){\\n            return true;\\n        }\\n        \\n        if(dp[p1][p2]!=-1){\\n            return dp[p1][p2];\\n        }\\n        \\n        bool res = false;\\n        \\n        if(p1!=s1.size()&&s1[p1]==s3[p3]) res|=fun(s1,s2,s3,p1+1,p2,p3+1);\\n        if(p2!=s2.size()&&s2[p2]==s3[p3]) res|=fun(s1,s2,s3,p1,p2+1,p3+1);\\n        \\n        return dp[p1][p2]=res;\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956582,
                "title": "easy-recursion-and-memoization-cpp",
                "content": "\\n\\n# RECURSION\\n```\\nclass Solution {\\npublic:\\n    bool helper(int i,int j,int k,string &s1, string &s2, string &s3){\\n        if(i<0 && j<0 && k<0)\\n            return true;\\n        \\n        if(i>=0 && j>=0 && k>=0 && s1[i]==s3[k] && s2[j]==s3[k])\\n            return helper(i-1,j,k-1,s1,s2,s3) || helper(i,j-1,k-1,s1,s2,s3) ;\\n        else if (i>=0 && k>=0 && s1[i]==s3[k])\\n            return helper(i-1,j,k-1,s1,s2,s3);\\n        else if(j>=0 && k>=0 && s2[j] == s3[k] )\\n            return helper(i,j-1,k-1,s1,s2,s3);\\n        else\\n            return false;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length() + s2.length() != s3.length())\\n            return false;\\n\\n        return helper(s1.length()-1,s2.length()-1,s3.length()-1,s1,s2,s3);\\n    }\\n};\\n```\\n\\n\\n# MEMOIZATION\\n```\\nbool helper(int i,int j,int k,string &s1, string &s2, string &s3,vector<vector<int>> &dp){\\n        if(i<0 && j<0 && k<0)\\n            return true;\\n\\n        if(dp[i+1][j+1]!=-1)\\n            return dp[i+1][j+1];\\n        \\n        bool result = false;\\n        if(i>=0 && j>=0 && k>=0 && s1[i]==s3[k] && s2[j]==s3[k])\\n            return result = helper(i-1,j,k-1,s1,s2,s3,dp) || helper(i,j-1,k-1,s1,s2,s3,dp) ;\\n        else if (i>=0 && k>=0 && s1[i]==s3[k])\\n            return result = helper(i-1,j,k-1,s1,s2,s3,dp);\\n        else if(j>=0 && k>=0 && s2[j] == s3[k] )\\n            return result = helper(i,j-1,k-1,s1,s2,s3,dp);\\n        \\n        return dp[i+1][j+1] = result;\\n    }\\n    bool isInterleave(string &s1, string &s2, string &s3) {\\n        if(s1.length() + s2.length() != s3.length())\\n            return false;\\n        vector<vector<int>> dp(s1.length()+1,vector<int>(s2.length()+1,-1));\\n        return helper(s1.length()-1,s2.length()-1,s3.length()-1,s1,s2,s3,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(int i,int j,int k,string &s1, string &s2, string &s3){\\n        if(i<0 && j<0 && k<0)\\n            return true;\\n        \\n        if(i>=0 && j>=0 && k>=0 && s1[i]==s3[k] && s2[j]==s3[k])\\n            return helper(i-1,j,k-1,s1,s2,s3) || helper(i,j-1,k-1,s1,s2,s3) ;\\n        else if (i>=0 && k>=0 && s1[i]==s3[k])\\n            return helper(i-1,j,k-1,s1,s2,s3);\\n        else if(j>=0 && k>=0 && s2[j] == s3[k] )\\n            return helper(i,j-1,k-1,s1,s2,s3);\\n        else\\n            return false;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length() + s2.length() != s3.length())\\n            return false;\\n\\n        return helper(s1.length()-1,s2.length()-1,s3.length()-1,s1,s2,s3);\\n    }\\n};\\n```\n```\\nbool helper(int i,int j,int k,string &s1, string &s2, string &s3,vector<vector<int>> &dp){\\n        if(i<0 && j<0 && k<0)\\n            return true;\\n\\n        if(dp[i+1][j+1]!=-1)\\n            return dp[i+1][j+1];\\n        \\n        bool result = false;\\n        if(i>=0 && j>=0 && k>=0 && s1[i]==s3[k] && s2[j]==s3[k])\\n            return result = helper(i-1,j,k-1,s1,s2,s3,dp) || helper(i,j-1,k-1,s1,s2,s3,dp) ;\\n        else if (i>=0 && k>=0 && s1[i]==s3[k])\\n            return result = helper(i-1,j,k-1,s1,s2,s3,dp);\\n        else if(j>=0 && k>=0 && s2[j] == s3[k] )\\n            return result = helper(i,j-1,k-1,s1,s2,s3,dp);\\n        \\n        return dp[i+1][j+1] = result;\\n    }\\n    bool isInterleave(string &s1, string &s2, string &s3) {\\n        if(s1.length() + s2.length() != s3.length())\\n            return false;\\n        vector<vector<int>> dp(s1.length()+1,vector<int>(s2.length()+1,-1));\\n        return helper(s1.length()-1,s2.length()-1,s3.length()-1,s1,s2,s3,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130468,
                "title": "python-recursion-with-dp-with-added-comments",
                "content": "# Interleaving Strings solution\\n\\n\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        \\'\\'\\' base condition, if sum of the length of given strings, \\n\\t\\ts1 and s2 are not equal to length of the \\'interleaved\\' string,\\n\\t\\tthen The required string s3 cannot be formed by completely using s1 and s2\\'\\'\\'\\n        if len(s1)+len(s2) != len(s3):\\n            return False\\n        \\n        dp ={}\\n        \\n        \\n        def construct(p1,p2,ind):\\n            if ind == len(s3):\\n                return True\\n            \\n            if (p1,p2) in dp:\\n                return dp[(p1,p2)]\\n            \\n            \\n            \\n            # if the s1 has been traversed or the pointer at s1 doesnt match\\n            if p1>=len(s1) or s1[p1] != s3[ind]:\\n                \\n                # if s2 has not been traversed completely but still pointer is not matchin\\n                if p2<len(s2) and s2[p2]!=s3[ind]:\\n                    return False\\n                \\n                # both s1 and s2 has been traversed\\n                elif p2>=len(s2):return False\\n                \\n                # else a match is found in s2 so inc pointers to s2 and the req string\\n                dp[(p1,p2)] = construct(p1,p2+1,ind+1)\\n            \\n            \\n            # doing the same for p2\\n            elif p2>= len(s2) or s2[p2] != s3[ind]:\\n                \\n                if s1[p1] != s3[ind]: return False\\n                \\n                \\n                dp[(p1,p2)] = construct(p1+1,p2,ind+1)\\n    \\n            # in this case we have matches in both s1 and s2 so you can traverse along either of the path\\n            elif s1[p1] == s3[ind] and s2[p2] == s3[ind]:\\n                dp[(p1,p2)] = construct(p1+1,p2,ind+1) or construct(p1,p2+1,ind+1)\\n            \\n            return dp[(p1,p2)]\\n        \\n        return construct(0,0,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        \\'\\'\\' base condition, if sum of the length of given strings, \\n\\t\\ts1 and s2 are not equal to length of the \\'interleaved\\' string,\\n\\t\\tthen The required string s3 cannot be formed by completely using s1 and s2\\'\\'\\'\\n        if len(s1)+len(s2) != len(s3):\\n            return False\\n        \\n        dp ={}\\n        \\n        \\n        def construct(p1,p2,ind):\\n            if ind == len(s3):\\n                return True\\n            \\n            if (p1,p2) in dp:\\n                return dp[(p1,p2)]\\n            \\n            \\n            \\n            # if the s1 has been traversed or the pointer at s1 doesnt match\\n            if p1>=len(s1) or s1[p1] != s3[ind]:\\n                \\n                # if s2 has not been traversed completely but still pointer is not matchin\\n                if p2<len(s2) and s2[p2]!=s3[ind]:\\n                    return False\\n                \\n                # both s1 and s2 has been traversed\\n                elif p2>=len(s2):return False\\n                \\n                # else a match is found in s2 so inc pointers to s2 and the req string\\n                dp[(p1,p2)] = construct(p1,p2+1,ind+1)\\n            \\n            \\n            # doing the same for p2\\n            elif p2>= len(s2) or s2[p2] != s3[ind]:\\n                \\n                if s1[p1] != s3[ind]: return False\\n                \\n                \\n                dp[(p1,p2)] = construct(p1+1,p2,ind+1)\\n    \\n            # in this case we have matches in both s1 and s2 so you can traverse along either of the path\\n            elif s1[p1] == s3[ind] and s2[p2] == s3[ind]:\\n                dp[(p1,p2)] = construct(p1+1,p2,ind+1) or construct(p1,p2+1,ind+1)\\n            \\n            return dp[(p1,p2)]\\n        \\n        return construct(0,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450701,
                "title": "simple-python-o-mn-dynamic-programming-solution",
                "content": "```Python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s3) != len(s1)+len(s2):\\n            return False\\n        # state: dp[i][j] denote whether the first i+j letters in s3 is a \\n        # interleaving of the first i elements in s1 and the first j\\n        # elements in s2\\n        n, m = len(s1), len(s2)\\n        dp = [[False]*(m+1) for _ in range(n+1)]\\n        \\n        # initialization: fill in the first row and column\\n        dp[0][0] = True\\n        for i in range(1, n+1):\\n            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\\n        for i in range(1, m+1):\\n            dp[0][i] = dp[0][i-1] and s2[i-1] == s3[i-1]\\n        \\n        # state transition: matching last character in s1 and s2 with that\\n        # of s3\\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                if s1[i-1] == s3[i+j-1]:         # s3[:3] = \"abc\", s1[2] = \\'c\\'\\n                    dp[i][j] = dp[i-1][j]\\n                if s2[j-1] == s3[i+j-1]:         # s3[:3] = \"abc\", s2[2] = \\'c\\'\\n                    dp[i][j] = dp[i][j] or dp[i][j-1]\\n            \\n        # result: whether entire s3 is an interleaving of entire s1 and s2\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```Python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s3) != len(s1)+len(s2):\\n            return False\\n        # state: dp[i][j] denote whether the first i+j letters in s3 is a \\n        # interleaving of the first i elements in s1 and the first j\\n        # elements in s2\\n        n, m = len(s1), len(s2)\\n        dp = [[False]*(m+1) for _ in range(n+1)]\\n        \\n        # initialization: fill in the first row and column\\n        dp[0][0] = True\\n        for i in range(1, n+1):\\n            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\\n        for i in range(1, m+1):\\n            dp[0][i] = dp[0][i-1] and s2[i-1] == s3[i-1]\\n        \\n        # state transition: matching last character in s1 and s2 with that\\n        # of s3\\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                if s1[i-1] == s3[i+j-1]:         # s3[:3] = \"abc\", s1[2] = \\'c\\'\\n                    dp[i][j] = dp[i-1][j]\\n                if s2[j-1] == s3[i+j-1]:         # s3[:3] = \"abc\", s2[2] = \\'c\\'\\n                    dp[i][j] = dp[i][j] or dp[i][j-1]\\n            \\n        # result: whether entire s3 is an interleaving of entire s1 and s2\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1049250,
                "title": "recursive-to-recursion-memoization-optimised-in-c",
                "content": "Recursive Solution :-\\n```\\nclass Solution {\\npublic:\\n    bool answ(string s1,int i,string s2,int j,string ans,string s3)\\n    {\\n        if(ans==s3 and i==s1.length() and j==s2.length())\\n            return true;\\n        \\n        bool a=false;\\n        \\n        if(i<s1.length())\\n            a|=answ(s1,i+1,s2,j,ans+s1[i],s3);\\n        \\n        if(j<s2.length())\\n            a|=answ(s1,i,s2,j+1,ans+s2[j],s3);\\n        \\n        return a;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3)\\n    {\\n        return answ(s1,0,s2,0,\"\",s3);\\n    }\\n};\\n```\\n\\nRecursive+Memoization Optimised :-\\n```\\nclass Solution {\\npublic:\\n    bool answ(string s1,int i,string s2,int j,string s3,int k,vector<vector<int>> &dp)\\n    {\\n        if(i==s1.length())\\n        {\\n            string a=s2.substr(j);\\n            string b=s3.substr(k);\\n            \\n            return a==b;\\n        }\\n        \\n        if(j==s2.length())\\n        {\\n            string a=s1.substr(i);\\n            string b=s3.substr(k);\\n            \\n            return a==b;\\n        }\\n        \\n        if(dp[i][j]>=0)\\n        {\\n            if(dp[i][j]==1)\\n                return true;\\n            return false;\\n        }\\n        \\n        bool ans=false;\\n        \\n        if((s3[k]==s1[i] and answ(s1,i+1,s2,j,s3,k+1,dp)) or (s3[k]==s2[j] and answ(s1,i,s2,j+1,s3,k+1,dp)))\\n            ans=true;\\n        \\n        dp[i][j]=ans?1:0;\\n        \\n        return ans;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3)\\n    {\\n        int n=s1.length();\\n        int m=s2.length();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n        return answ(s1,0,s2,0,s3,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool answ(string s1,int i,string s2,int j,string ans,string s3)\\n    {\\n        if(ans==s3 and i==s1.length() and j==s2.length())\\n            return true;\\n        \\n        bool a=false;\\n        \\n        if(i<s1.length())\\n            a|=answ(s1,i+1,s2,j,ans+s1[i],s3);\\n        \\n        if(j<s2.length())\\n            a|=answ(s1,i,s2,j+1,ans+s2[j],s3);\\n        \\n        return a;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3)\\n    {\\n        return answ(s1,0,s2,0,\"\",s3);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool answ(string s1,int i,string s2,int j,string s3,int k,vector<vector<int>> &dp)\\n    {\\n        if(i==s1.length())\\n        {\\n            string a=s2.substr(j);\\n            string b=s3.substr(k);\\n            \\n            return a==b;\\n        }\\n        \\n        if(j==s2.length())\\n        {\\n            string a=s1.substr(i);\\n            string b=s3.substr(k);\\n            \\n            return a==b;\\n        }\\n        \\n        if(dp[i][j]>=0)\\n        {\\n            if(dp[i][j]==1)\\n                return true;\\n            return false;\\n        }\\n        \\n        bool ans=false;\\n        \\n        if((s3[k]==s1[i] and answ(s1,i+1,s2,j,s3,k+1,dp)) or (s3[k]==s2[j] and answ(s1,i,s2,j+1,s3,k+1,dp)))\\n            ans=true;\\n        \\n        dp[i][j]=ans?1:0;\\n        \\n        return ans;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3)\\n    {\\n        int n=s1.length();\\n        int m=s2.length();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n        return answ(s1,0,s2,0,s3,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617188,
                "title": "python-dp-lru-cahce-beats-97",
                "content": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    @lru_cache(maxsize=None)\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if s1 == s2 == s3 == \\'\\':\\n            return True\\n        elif s3 == \\'\\' and (s1 != \\'\\' or s2 != \\'\\'):\\n            return False\\n        \\n        if s1 == \\'\\':\\n            return s2 == s3\\n        elif s2 == \\'\\':\\n            return s1 == s3\\n       \\n        if s1[0] == s2[0] == s3[0]:\\n            return self.isInterleave(s1[1:] , s2, s3[1:]) or self.isInterleave(s1 , s2[1:], s3[1:])\\n        elif s1[0] == s3[0]:\\n            return self.isInterleave(s1[1:] , s2, s3[1:])\\n        elif s2[0] == s3[0]:\\n            return self.isInterleave(s1 , s2[1:], s3[1:])\\n        else:\\n            return False\\n```\\nNo extra function required.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    @lru_cache(maxsize=None)\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if s1 == s2 == s3 == \\'\\':\\n            return True\\n        elif s3 == \\'\\' and (s1 != \\'\\' or s2 != \\'\\'):\\n            return False\\n        \\n        if s1 == \\'\\':\\n            return s2 == s3\\n        elif s2 == \\'\\':\\n            return s1 == s3\\n       \\n        if s1[0] == s2[0] == s3[0]:\\n            return self.isInterleave(s1[1:] , s2, s3[1:]) or self.isInterleave(s1 , s2[1:], s3[1:])\\n        elif s1[0] == s3[0]:\\n            return self.isInterleave(s1[1:] , s2, s3[1:])\\n        elif s2[0] == s3[0]:\\n            return self.isInterleave(s1 , s2[1:], s3[1:])\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957679,
                "title": "ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nThe problem of determining whether one string is an interleaving of two others can be approached using dynamic programming. The core intuition lies in breaking down the problem into smaller subproblems. Essentially, we want to determine if the characters from both strings, s1 and s2, can be interwoven to create the target string s3. We aim to build a dynamic programming matrix that stores the state of the interleaving at different points, helping us track the possibilities.\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 247 videos as of August 25th.\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Initialize `dp` array: Create an array `dp` of size `(len(s2) + 1)` to store whether substrings of `s1` and `s2` can interleave to form substrings of `s3`.\\n\\n2. Check total length: If the sum of the lengths of `s1` and `s2` is not equal to the length of `s3`, return `False` since it\\'s impossible for `s1` and `s2` to interleave to form `s3`.\\n\\n3. Initialization: Set `dp[0]` to `True` to indicate that an empty `s1` and empty `s2` can interleave to form an empty `s3`.\\n\\n4. Loop through `s1` and `s2`: Use nested loops to iterate through all possible combinations of substrings of `s1` and `s2` to check if they can interleave to form `s3`.\\n\\n5. Base cases handling:\\n   - If `i` is `0` and `j` is `0`, it means both `s1` and `s2` are empty. Set `dp[j]` to `True`.\\n   - If `i` is `0`, update `dp[j]` using the previous value of `dp[j - 1]` and check if the character in `s2` at index `j - 1` matches the character in `s3` at index `i + j - 1`.\\n   - If `j` is `0`, update `dp[j]` using the current value of `dp[j]` and check if the character in `s1` at index `i - 1` matches the character in `s3` at index `i + j - 1`.\\n\\n6. General case:\\n   - For all other cases (when both `i` and `j` are not `0`), update `dp[j]` using the following conditions:\\n     - `dp[j]` should be the result of `(dp[j] and s1[i - 1] == s3[i + j - 1])`, meaning that the current character in `s1` matches the current character in `s3`, and the previous substring also interleave to form the previous part of `s3`.\\n     - `dp[j - 1]` should be the result of `(dp[j - 1] and s2[j - 1] == s3[i + j - 1])`, meaning that the current character in `s2` matches the current character in `s3`, and the previous substring of `s2` can interleave to form the previous part of `s3`.\\n\\n7. Return result: The final result is stored in `dp[len(s2)]`, which indicates whether `s1` and `s2` can interleave to form `s3`.\\n\\n8. The function returns the value of `dp[len(s2)]` as the final result.\\n\\nIn summary, the algorithm uses dynamic programming to determine whether substrings of `s1` and `s2` can be interleaved to form substrings of `s3`. The `dp` array stores whether the substrings can interleave at each position.\\n\\n# Complexity\\n- Time complexity: O(m * n)\\nm is the length of string s1 and n is the length of string s2. This is because we iterate through each character of s1 and s2 once while constructing the dynamic programming matrix.\\n\\n- Space complexity: O(n),\\nn is the length of string s2. We only use a dynamic programming array of length n+1 to store the state transitions.\\n\\n```python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        # Check if the combined length of s1 and s2 matches the length of s3\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        \\n        # Initialize a dynamic programming array dp\\n        # dp[j] will store whether s1[0:i] and s2[0:j] can form s3[0:i+j]\\n        dp = [False] * (len(s2) + 1)\\n        \\n        for i in range(len(s1) + 1):\\n            for j in range(len(s2) + 1):\\n                if i == 0 and j == 0:\\n                    # Base case: Both s1 and s2 are empty, so s3 is also empty.\\n                    # Set dp[j] to True.\\n                    dp[j] = True\\n                elif i == 0:\\n                    # Base case: s1 is empty, so check if the previous dp[j-1]\\n                    # is True and if s2[j-1] matches s3[i+j-1].\\n                    dp[j] = dp[j - 1] and s2[j - 1] == s3[i + j - 1]\\n                elif j == 0:\\n                    # Base case: s2 is empty, so check if the current dp[j]\\n                    # is True and if s1[i-1] matches s3[i+j-1].\\n                    dp[j] = dp[j] and s1[i - 1] == s3[i + j - 1]\\n                else:\\n                    # General case: Check if either the previous dp[j] or dp[j-1]\\n                    # is True and if the corresponding characters match s3[i+j-1].\\n                    dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\\n\\n        # Return the result stored in dp[len(s2)], which indicates whether\\n        # s1 and s2 can form s3 by interleaving characters.\\n        return dp[len(s2)]\\n\\n```\\n```javascript []\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @param {string} s3\\n * @return {boolean}\\n */\\nvar isInterleave = function(s1, s2, s3) {\\n    if (s1.length + s2.length !== s3.length) {\\n        return false;\\n    }\\n    \\n    const dp = new Array(s2.length + 1).fill(false);\\n    \\n    for (let i = 0; i <= s1.length; i++) {\\n        for (let j = 0; j <= s2.length; j++) {\\n            if (i === 0 && j === 0) {\\n                dp[j] = true;\\n            } else if (i === 0) {\\n                dp[j] = dp[j - 1] && s2[j - 1] === s3[i + j - 1];\\n            } else if (j === 0) {\\n                dp[j] = dp[j] && s1[i - 1] === s3[i + j - 1];\\n            } else {\\n                dp[j] = (dp[j] && s1[i - 1] === s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] === s3[i + j - 1]);\\n            }\\n        }\\n    }\\n    \\n    return dp[s2.length];    \\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        boolean[] dp = new boolean[s2.length() + 1];\\n        \\n        for (int i = 0; i <= s1.length(); i++) {\\n            for (int j = 0; j <= s2.length(); j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[j] = true;\\n                } else if (i == 0) {\\n                    dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n                } else if (j == 0) {\\n                    dp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n                } else {\\n                    dp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n                }\\n            }\\n        }\\n        \\n        return dp[s2.length()];        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        vector<bool> dp(s2.length() + 1, false);\\n        \\n        for (int i = 0; i <= s1.length(); i++) {\\n            for (int j = 0; j <= s2.length(); j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[j] = true;\\n                } else if (i == 0) {\\n                    dp[j] = dp[j - 1] && s2[j - 1] == s3[i + j - 1];\\n                } else if (j == 0) {\\n                    dp[j] = dp[j] && s1[i - 1] == s3[i + j - 1];\\n                } else {\\n                    dp[j] = (dp[j] && s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] == s3[i + j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[s2.length()];        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        # Check if the combined length of s1 and s2 matches the length of s3\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        \\n        # Initialize a dynamic programming array dp\\n        # dp[j] will store whether s1[0:i] and s2[0:j] can form s3[0:i+j]\\n        dp = [False] * (len(s2) + 1)\\n        \\n        for i in range(len(s1) + 1):\\n            for j in range(len(s2) + 1):\\n                if i == 0 and j == 0:\\n                    # Base case: Both s1 and s2 are empty, so s3 is also empty.\\n                    # Set dp[j] to True.\\n                    dp[j] = True\\n                elif i == 0:\\n                    # Base case: s1 is empty, so check if the previous dp[j-1]\\n                    # is True and if s2[j-1] matches s3[i+j-1].\\n                    dp[j] = dp[j - 1] and s2[j - 1] == s3[i + j - 1]\\n                elif j == 0:\\n                    # Base case: s2 is empty, so check if the current dp[j]\\n                    # is True and if s1[i-1] matches s3[i+j-1].\\n                    dp[j] = dp[j] and s1[i - 1] == s3[i + j - 1]\\n                else:\\n                    # General case: Check if either the previous dp[j] or dp[j-1]\\n                    # is True and if the corresponding characters match s3[i+j-1].\\n                    dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\\n\\n        # Return the result stored in dp[len(s2)], which indicates whether\\n        # s1 and s2 can form s3 by interleaving characters.\\n        return dp[len(s2)]\\n\\n```\n```javascript []\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @param {string} s3\\n * @return {boolean}\\n */\\nvar isInterleave = function(s1, s2, s3) {\\n    if (s1.length + s2.length !== s3.length) {\\n        return false;\\n    }\\n    \\n    const dp = new Array(s2.length + 1).fill(false);\\n    \\n    for (let i = 0; i <= s1.length; i++) {\\n        for (let j = 0; j <= s2.length; j++) {\\n            if (i === 0 && j === 0) {\\n                dp[j] = true;\\n            } else if (i === 0) {\\n                dp[j] = dp[j - 1] && s2[j - 1] === s3[i + j - 1];\\n            } else if (j === 0) {\\n                dp[j] = dp[j] && s1[i - 1] === s3[i + j - 1];\\n            } else {\\n                dp[j] = (dp[j] && s1[i - 1] === s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] === s3[i + j - 1]);\\n            }\\n        }\\n    }\\n    \\n    return dp[s2.length];    \\n};\\n```\n```java []\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        boolean[] dp = new boolean[s2.length() + 1];\\n        \\n        for (int i = 0; i <= s1.length(); i++) {\\n            for (int j = 0; j <= s2.length(); j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[j] = true;\\n                } else if (i == 0) {\\n                    dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n                } else if (j == 0) {\\n                    dp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n                } else {\\n                    dp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n                }\\n            }\\n        }\\n        \\n        return dp[s2.length()];        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        vector<bool> dp(s2.length() + 1, false);\\n        \\n        for (int i = 0; i <= s1.length(); i++) {\\n            for (int j = 0; j <= s2.length(); j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[j] = true;\\n                } else if (i == 0) {\\n                    dp[j] = dp[j - 1] && s2[j - 1] == s3[i + j - 1];\\n                } else if (j == 0) {\\n                    dp[j] = dp[j] && s1[i - 1] == s3[i + j - 1];\\n                } else {\\n                    dp[j] = (dp[j] && s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] == s3[i + j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[s2.length()];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957330,
                "title": "recursion-best-optimization-4-steps-of-optimization-c-dp",
                "content": "*Note:-* Refer the last stage of this solution for *best optimization code*, else move step by step optimization for better understanding.\\n\\n\\n# 1. Naive Recursive approach \\n- **Time complexity: O(2^o)**\\nThe function f is a recursive function that explores various possibilities of interleaving s1 and s2 to form s3. In the worst case, each recursive call results in two new recursive calls, as shown in the code. Therefore, the number of recursive calls grows exponentially with the length of the strings. The maximum depth of the recursion tree will be o, the length of string s3, since each recursive call reduces the length of s3 by 1. So, the time complexity of this algorithm can be approximated as O(2^o), where o is the length of the target string s3.\\n- **Space complexity: O(o)**\\nThe space complexity is determined by the maximum depth of the recursive call stack. At any point in time, the maximum number of active recursive calls corresponds to the depth of the recursion tree. Since each recursive call only involves a few additional variables and constant space complexity operations, the dominant factor here is the recursion stack space. Therefore, the space complexity is O(o), where o is the length of the target string s3.\\n```\\nclass Solution {\\npublic:\\n    bool f(int m, int n, int o, string &s1, string &s2, string &s3){\\n        if(o==0) return true;\\n        if(m==0 && n==0) return false;\\n        if(m>0 && n>0 && s1[m-1]==s3[o-1] && s2[n-1]==s3[o-1]){\\n            return f(m-1, n, o-1, s1, s2, s3) || f(m, n-1, o-1, s1, s2, s3);\\n        }\\n        else if(n>0 && s2[n-1]==s3[o-1]){\\n            return f(m, n-1, o-1, s1, s2, s3);\\n        }\\n        else if(m>0 && s1[m-1]==s3[o-1]){\\n            return f(m-1, n, o-1, s1, s2, s3);\\n        }\\n        else return false;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        string s;\\n        int m=s1.size();\\n        int n=s2.size();\\n        int o=s3.size();\\n        if(m+n!=o) return false;\\n        return f(m, n, o, s1, s2, s3);\\n    }\\n};\\n```\\n# 2. Memoization(DP)\\n- Time complexity: O(m*n)\\n- Space complexity: O(m*n)\\n\\n```\\nclass Solution {\\npublic:\\n    bool f(int m, int n, int o, string &s1, string &s2, string &s3, vector<vector<int>>&dp){\\n        if(o==0) return true;\\n        if(m==0 && n==0) return false;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        if(m>0 && n>0 && s1[m-1]==s3[o-1] && s2[n-1]==s3[o-1]){\\n            return dp[m][n] = f(m-1, n, o-1, s1, s2, s3, dp) || f(m, n-1, o-1, s1, s2, s3, dp);\\n        }\\n        else if(n>0 && s2[n-1]==s3[o-1]){\\n            return dp[m][n] = f(m, n-1, o-1, s1, s2, s3, dp);\\n        }\\n        else if(m>0 && s1[m-1]==s3[o-1]){\\n            return dp[m][n] = f(m-1, n, o-1, s1, s2, s3, dp);\\n        }\\n        else return false;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        string s;\\n        int m=s1.size();\\n        int n=s2.size();\\n        int o=s3.size();\\n        if(m+n!=o) return false;\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, -1));\\n        return f(m, n, o, s1, s2, s3, dp);\\n    }\\n};\\n```\\n\\n# 3. Tabulation(DP)\\n- Time complexity: O(m*n)\\n- Space complexity: O(m*n)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int o = s3.size();\\n        \\n        if (m + n != o) return false;\\n        \\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));\\n        dp[0][0] = true;  // Base case\\n        \\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                int k = i + j - 1;  // Adjusted index for s3\\n                \\n                if (i > 0 && s1[i - 1] == s3[k])\\n                    dp[i][j] = dp[i][j] || dp[i - 1][j];\\n                if (j > 0 && s2[j - 1] == s3[k])\\n                    dp[i][j] = dp[i][j] || dp[i][j - 1];\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```\\n\\n# 4. Optimized Space (BEST Approach)\\n- Time complexity: O(m*n)\\n- Space complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int o = s3.size();\\n        \\n        if (m+n!=o) return false;\\n        \\n        vector<bool> dp(n + 1);\\n        dp[0]=true;  // Base case\\n        \\n        for (int i=0;i<=m;i++) {\\n            for (int j=0;j<=n;j++) {\\n                int k=i+j-1;  // Adjusted index for s3\\n                \\n                if(i>0)\\n                    dp[j]=dp[j] && s1[i-1] == s3[k];\\n                if (j > 0)\\n                    dp[j]=dp[j] || (dp[j-1] && s2[j-1] == s3[k]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int m, int n, int o, string &s1, string &s2, string &s3){\\n        if(o==0) return true;\\n        if(m==0 && n==0) return false;\\n        if(m>0 && n>0 && s1[m-1]==s3[o-1] && s2[n-1]==s3[o-1]){\\n            return f(m-1, n, o-1, s1, s2, s3) || f(m, n-1, o-1, s1, s2, s3);\\n        }\\n        else if(n>0 && s2[n-1]==s3[o-1]){\\n            return f(m, n-1, o-1, s1, s2, s3);\\n        }\\n        else if(m>0 && s1[m-1]==s3[o-1]){\\n            return f(m-1, n, o-1, s1, s2, s3);\\n        }\\n        else return false;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        string s;\\n        int m=s1.size();\\n        int n=s2.size();\\n        int o=s3.size();\\n        if(m+n!=o) return false;\\n        return f(m, n, o, s1, s2, s3);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool f(int m, int n, int o, string &s1, string &s2, string &s3, vector<vector<int>>&dp){\\n        if(o==0) return true;\\n        if(m==0 && n==0) return false;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        if(m>0 && n>0 && s1[m-1]==s3[o-1] && s2[n-1]==s3[o-1]){\\n            return dp[m][n] = f(m-1, n, o-1, s1, s2, s3, dp) || f(m, n-1, o-1, s1, s2, s3, dp);\\n        }\\n        else if(n>0 && s2[n-1]==s3[o-1]){\\n            return dp[m][n] = f(m, n-1, o-1, s1, s2, s3, dp);\\n        }\\n        else if(m>0 && s1[m-1]==s3[o-1]){\\n            return dp[m][n] = f(m-1, n, o-1, s1, s2, s3, dp);\\n        }\\n        else return false;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        string s;\\n        int m=s1.size();\\n        int n=s2.size();\\n        int o=s3.size();\\n        if(m+n!=o) return false;\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, -1));\\n        return f(m, n, o, s1, s2, s3, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int o = s3.size();\\n        \\n        if (m + n != o) return false;\\n        \\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));\\n        dp[0][0] = true;  // Base case\\n        \\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                int k = i + j - 1;  // Adjusted index for s3\\n                \\n                if (i > 0 && s1[i - 1] == s3[k])\\n                    dp[i][j] = dp[i][j] || dp[i - 1][j];\\n                if (j > 0 && s2[j - 1] == s3[k])\\n                    dp[i][j] = dp[i][j] || dp[i][j - 1];\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int o = s3.size();\\n        \\n        if (m+n!=o) return false;\\n        \\n        vector<bool> dp(n + 1);\\n        dp[0]=true;  // Base case\\n        \\n        for (int i=0;i<=m;i++) {\\n            for (int j=0;j<=n;j++) {\\n                int k=i+j-1;  // Adjusted index for s3\\n                \\n                if(i>0)\\n                    dp[j]=dp[j] && s1[i-1] == s3[k];\\n                if (j > 0)\\n                    dp[j]=dp[j] || (dp[j-1] && s2[j-1] == s3[k]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957222,
                "title": "dp-solution-explanation-by-comment",
                "content": "# Intuition\\nThis code uses a dynamic programming approach to fill in a 2D table dp, where **dp[i][j]** represents whether the first **i** characters from **s1** and the first **j** characters from **s2** can form the first **i+j** characters of **s3**. The recurrence relation used is based on the idea that for **dp[i][j]** to be true, either the character from s1 should match the current character of s3, and the previous state should also be true, or the character from **s2** should match the current character of **s3**, and the current state in the previous column should be true.\\n\\n# Complexity\\n- Time complexity:O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n * m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        \\n        if (n + m != s3.size()) {\\n            return false;\\n        }\\n        \\n        vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));\\n        \\n        // Base case: Empty strings interleave to form an empty string\\n        dp[0][0] = true;\\n        \\n        // Initialize the first row (s1) and first column (s2)\\n        for (int i = 1; i <= n; ++i) {\\n            dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1];\\n        }\\n        \\n        for (int j = 1; j <= m; ++j) {\\n            dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1];\\n        }\\n        \\n        // Fill in the DP table\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) ||\\n                           (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        \\n        if (n + m != s3.size()) {\\n            return false;\\n        }\\n        \\n        vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));\\n        \\n        // Base case: Empty strings interleave to form an empty string\\n        dp[0][0] = true;\\n        \\n        // Initialize the first row (s1) and first column (s2)\\n        for (int i = 1; i <= n; ++i) {\\n            dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1];\\n        }\\n        \\n        for (int j = 1; j <= m; ++j) {\\n            dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1];\\n        }\\n        \\n        // Fill in the DP table\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) ||\\n                           (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250660,
                "title": "c-recursion-memoization-tabulation-space-optimization-o-n-space-with-intuition",
                "content": "I have renamed Input Strings in my code\\na=s1,b=s2 and ist i.e Interleaved STring =s3\\n\\nRecursion:\\nTime complexity :Exponential\\nSpace complexity: O(N+M) (Auxiliary Stack Space)\\nCode:\\n```\\nbool rec(string &a, string &b, string &ist, int i = 0, int j = 0, int k = 0)\\n{\\nint n = a.length(), m = b.length();\\nif (n + m != ist.length())\\nreturn false;\\nif (i == n && j == m)\\n    return true; // base case\\n\\nbool left, right;\\nleft = i < n ? a[i] == ist[k] : false;\\nright = j < m ? b[j] == ist[k] : false;\\n\\nif (left && right)\\n    return rec(a, b, ist, i + 1, j, k + 1) || rec(a, b, ist, i, j + 1, k + 1);\\n\\nelse if (left)\\n    return rec(a, b, ist, i + 1, j, k + 1);\\n\\nelse if (right)\\n    return rec(a, b, ist, i, j + 1, k + 1);\\n\\nelse\\n    return false;\\n}\\nbool isInterleave(string s1, string s2, string s3)\\n{\\nreturn rec(s1, s2, s3);\\n}\\n```\\n\\nMemoization:\\nTime Complexity:O(N^M)\\nSpace Complexity: O(N+M)(Auxiliary Space) +O(N^M) (2D DP Vector)\\nCode:\\n\\n```\\nbool mem(string &a, string &b, string &ist, vector<vector> &dp, int i = 0, int j = 0, int k = 0)\\n{\\nint n = a.length(), m = b.length();\\nif (n + m != ist.length())\\nreturn false;\\nif (i == n && j == m)\\n    return true; // base case\\n\\nif (dp[i][j] != -1)\\n    return dp[i][j];\\n\\nbool left, right;\\nleft = i < n ? a[i] == ist[k] : false;\\nright = j < m ? b[j] == ist[k] : false;\\n\\nif (left && right)\\n    return dp[i][j] = mem(a, b, ist, dp, i + 1, j, k + 1) || mem(a, b, ist, dp, i, j + 1, k + 1);\\n\\nelse if (left)\\n    return dp[i][j] = mem(a, b, ist, dp, i + 1, j, k + 1);\\n\\nelse if (right)\\n    return dp[i][j] = mem(a, b, ist, dp, i, j + 1, k + 1);\\n\\nelse\\n    return dp[i][j] = false;\\n}\\nbool isInterleave(string s1, string s2, string s3)\\n{\\nint n = s1.length(), m = s2.length();\\nvector<vector> dp(n + 1, vector(m + 1, -1));\\nreturn mem(s1, s2, s3, dp);\\n}\\n\\n```\\n\\nTabulation:\\nTime Complexity: O(N^M)\\nSpace Complexity: O(N^M) (2D DP Vector)\\nCode:\\n\\n```\\nbool tabulation(string& a,string& b,string& ist)\\n{\\nint m = b.length(), n = a.length();\\nif (m + n != ist.length())\\nreturn false;\\nvector<vector<bool>> dp(n+1,vector<bool>(m+1,true));\\n\\nfor (int j = m - 1; j >= 0; j--)\\n{\\n    if (b[j] == ist[n + j])\\n        dp[n][j] = dp[n][j+1];\\n    else\\n        dp[n][j] = false;\\n} // base case i==n\\n\\nfor (int i = n - 1; i >= 0; i--)\\n{\\n    dp[i][m] = a[i] == ist[m + i];\\n\\n    for (int j = m - 1; j >= 0; j--)\\n    {\\n        bool left, right;\\n        left = a[i] == ist[i + j];\\n        right = b[j] == ist[i + j];\\n\\n        if (left && right)\\n            dp[i][j] = dp[i+1][j] || dp[i][j+1];\\n\\n        else if (right)\\n            dp[i][j] = dp[i][j+1];\\n\\n        else if(left)\\n            dp[i][j]=dp[i+1][j];\\n\\n        else\\n            dp[i][j] = false;\\n    }\\n}\\n\\nreturn dp[0][0];\\n}\\nbool isInterleave(string s1, string s2, string s3)\\n{\\nreturn tabulation(s1, s2, s3);\\n}\\n\\n```\\n\\nSpace-optimization:\\nTime Complexity:O(N^M)\\nSpace Complexity:O(M) (Only a prev 1D vector used of size M i.e s2.length())\\nFollow Up Question Solved\\nCode:\\n\\n```\\nbool sop(string &a, string &b, string &ist)\\n{\\nint m = b.length(), n = a.length();\\nif (m + n != ist.length())\\nreturn false;\\nvector<bool> prev(m + 1, true);\\n\\nfor (int j = m - 1; j >= 0; j--)\\n{\\n    if (b[j] == ist[n + j])\\n        prev[j] = prev[j + 1];\\n    else\\n        prev[j] = false;\\n} // base case i==n\\n\\nfor (int i = n - 1; i >= 0; i--)\\n{\\n    prev[m] = a[i] == ist[m + i];\\n\\n    for (int j = m - 1; j >= 0; j--)\\n    {\\n        bool left, right;\\n        left = a[i] == ist[i + j];\\n        right = b[j] == ist[i + j];\\n\\n        if (left && right)\\n            prev[j] = prev[j] || prev[j + 1];\\n\\n        else if (right)\\n            prev[j] = prev[j + 1];\\n\\n        else if (!left)\\n            prev[j] = false;\\n    }\\n}\\n\\nreturn prev[0];\\n}\\nbool isInterleave(string s1, string s2, string s3)\\n{\\nreturn sop(s1, s2, s3);\\n}\\n\\n```\\n\\nComplete Intuition for space optimization:-\\nThis prev array is a dp array only, but if we observer in tabulation that for filling dp[i] we are only requiring dp[i+1] and not any further. So, I thought why not only store only dp[i+1] and keep updating it for every i.\\nNow we could keep current i.e dp[i] and previous i.e dp[i+1]  but here also i tried to optimize and keeping only one i.e previous.\\nwe see that while filling dp[i][j] we are needing either dp[i][j+1](will come from current hence needs to be computed before,hence we go from j=m ->j=0) or dp[i+1][j](will come from previous). Now compare it to filling for each ith row prev[j] , we know prev[j+1] is already computed,and just before filling prev[j] value in it is prev[j],but for i+1 th row (dp[i+1][j]), and these were the two needed for prev[j].\\nThis was all intuition.\\n\\nIf you find this solution helpful , plz upvote.\\nAnd would love to hear about flaws in code in comment section.\\nThanks for reading.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nbool rec(string &a, string &b, string &ist, int i = 0, int j = 0, int k = 0)\\n{\\nint n = a.length(), m = b.length();\\nif (n + m != ist.length())\\nreturn false;\\nif (i == n && j == m)\\n    return true; // base case\\n\\nbool left, right;\\nleft = i < n ? a[i] == ist[k] : false;\\nright = j < m ? b[j] == ist[k] : false;\\n\\nif (left && right)\\n    return rec(a, b, ist, i + 1, j, k + 1) || rec(a, b, ist, i, j + 1, k + 1);\\n\\nelse if (left)\\n    return rec(a, b, ist, i + 1, j, k + 1);\\n\\nelse if (right)\\n    return rec(a, b, ist, i, j + 1, k + 1);\\n\\nelse\\n    return false;\\n}\\nbool isInterleave(string s1, string s2, string s3)\\n{\\nreturn rec(s1, s2, s3);\\n}\\n```\n```\\nbool mem(string &a, string &b, string &ist, vector<vector> &dp, int i = 0, int j = 0, int k = 0)\\n{\\nint n = a.length(), m = b.length();\\nif (n + m != ist.length())\\nreturn false;\\nif (i == n && j == m)\\n    return true; // base case\\n\\nif (dp[i][j] != -1)\\n    return dp[i][j];\\n\\nbool left, right;\\nleft = i < n ? a[i] == ist[k] : false;\\nright = j < m ? b[j] == ist[k] : false;\\n\\nif (left && right)\\n    return dp[i][j] = mem(a, b, ist, dp, i + 1, j, k + 1) || mem(a, b, ist, dp, i, j + 1, k + 1);\\n\\nelse if (left)\\n    return dp[i][j] = mem(a, b, ist, dp, i + 1, j, k + 1);\\n\\nelse if (right)\\n    return dp[i][j] = mem(a, b, ist, dp, i, j + 1, k + 1);\\n\\nelse\\n    return dp[i][j] = false;\\n}\\nbool isInterleave(string s1, string s2, string s3)\\n{\\nint n = s1.length(), m = s2.length();\\nvector<vector> dp(n + 1, vector(m + 1, -1));\\nreturn mem(s1, s2, s3, dp);\\n}\\n\\n```\n```\\nbool tabulation(string& a,string& b,string& ist)\\n{\\nint m = b.length(), n = a.length();\\nif (m + n != ist.length())\\nreturn false;\\nvector<vector<bool>> dp(n+1,vector<bool>(m+1,true));\\n\\nfor (int j = m - 1; j >= 0; j--)\\n{\\n    if (b[j] == ist[n + j])\\n        dp[n][j] = dp[n][j+1];\\n    else\\n        dp[n][j] = false;\\n} // base case i==n\\n\\nfor (int i = n - 1; i >= 0; i--)\\n{\\n    dp[i][m] = a[i] == ist[m + i];\\n\\n    for (int j = m - 1; j >= 0; j--)\\n    {\\n        bool left, right;\\n        left = a[i] == ist[i + j];\\n        right = b[j] == ist[i + j];\\n\\n        if (left && right)\\n            dp[i][j] = dp[i+1][j] || dp[i][j+1];\\n\\n        else if (right)\\n            dp[i][j] = dp[i][j+1];\\n\\n        else if(left)\\n            dp[i][j]=dp[i+1][j];\\n\\n        else\\n            dp[i][j] = false;\\n    }\\n}\\n\\nreturn dp[0][0];\\n}\\nbool isInterleave(string s1, string s2, string s3)\\n{\\nreturn tabulation(s1, s2, s3);\\n}\\n\\n```\n```\\nbool sop(string &a, string &b, string &ist)\\n{\\nint m = b.length(), n = a.length();\\nif (m + n != ist.length())\\nreturn false;\\nvector<bool> prev(m + 1, true);\\n\\nfor (int j = m - 1; j >= 0; j--)\\n{\\n    if (b[j] == ist[n + j])\\n        prev[j] = prev[j + 1];\\n    else\\n        prev[j] = false;\\n} // base case i==n\\n\\nfor (int i = n - 1; i >= 0; i--)\\n{\\n    prev[m] = a[i] == ist[m + i];\\n\\n    for (int j = m - 1; j >= 0; j--)\\n    {\\n        bool left, right;\\n        left = a[i] == ist[i + j];\\n        right = b[j] == ist[i + j];\\n\\n        if (left && right)\\n            prev[j] = prev[j] || prev[j + 1];\\n\\n        else if (right)\\n            prev[j] = prev[j + 1];\\n\\n        else if (!left)\\n            prev[j] = false;\\n    }\\n}\\n\\nreturn prev[0];\\n}\\nbool isInterleave(string s1, string s2, string s3)\\n{\\nreturn sop(s1, s2, s3);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2248790,
                "title": "easy-memoization-c-code",
                "content": "intuition:- we compair first element of both of s1 and s2 with s3 if match ind1 of s1 with current  index of then we go forword with ind1+1 and next index of s3 and same for s2.\\n \\n    bool isInterleave(string s1, string s2, string s3) {\\n       if(s1.size()+s2.size()!=s3.size()) return false;\\n        vector<vector<int>>dp(s1.size()+1,vector<int>(s2.size()+1,-1));\\n        \\n        return fun(s1,s2,s3,0,0,dp);\\n    }\\n\\tbool fun(string &s1, string &s2, string &s3,int ind1,int ind2,vector<vector<int>>&dp)\\n    {\\n        if(ind1+ind2==s3.size()) return 1;\\n        if(dp[ind1][ind2]!=-1) return dp[ind1][ind2];\\n        bool ans=0;        \\n        if(ind1<s1.size() and s1[ind1]==s3[ind1+ind2] and fun(s1,s2,s3,ind1+1,ind2,dp)) ans=1;\\n        if(ind2<s2.size() and s2[ind2]==s3[ind1+ind2] and fun(s1,s2,s3,ind1,ind2+1,dp)) ans=1;\\n        \\n        return dp[ind1][ind2]=ans;\\n    }\\n",
                "solutionTags": [
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "intuition:- we compair first element of both of s1 and s2 with s3 if match ind1 of s1 with current  index of then we go forword with ind1+1 and next index of s3 and same for s2.\\n \\n    bool isInterleave(string s1, string s2, string s3) {\\n       if(s1.size()+s2.size()!=s3.size()) return false;\\n        vector<vector<int>>dp(s1.size()+1,vector<int>(s2.size()+1,-1));\\n        \\n        return fun(s1,s2,s3,0,0,dp);\\n    }\\n\\tbool fun(string &s1, string &s2, string &s3,int ind1,int ind2,vector<vector<int>>&dp)\\n    {\\n        if(ind1+ind2==s3.size()) return 1;\\n        if(dp[ind1][ind2]!=-1) return dp[ind1][ind2];\\n        bool ans=0;        \\n        if(ind1<s1.size() and s1[ind1]==s3[ind1+ind2] and fun(s1,s2,s3,ind1+1,ind2,dp)) ans=1;\\n        if(ind2<s2.size() and s2[ind2]==s3[ind1+ind2] and fun(s1,s2,s3,ind1,ind2+1,dp)) ans=1;\\n        \\n        return dp[ind1][ind2]=ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2248668,
                "title": "easy-js-solution",
                "content": "At first I tried to solved it linearly in which i kept three variables a, b, c all pointing to each string starting. I then kept on increasing them till i reach end of all string but this approach fails if there are two choices ( same character is availabe on both string s1, s2 ) then a wrong decision will give you wrong result. \\nSince constraints are small I tried taking all decisions using recursion where i take two decisions either from s1 or s2 and see which gives a positive result.\\n```\\nvar isInterleave = function(s1, s2, s3) {\\n    const dp = new Map();\\n    const solve = (a = 0, b = 0, c = 0) => {\\n        if(c == s3.length) return a == s1.length && b == s2.length;\\n        const key = [a, b, c].join(\\':\\');\\n        \\n        if(dp.has(key)) {\\n            // console.log(\\'hit\\');\\n            return dp.get(key);\\n        }\\n        \\n        let takeS1 = false, takeS2 = false;\\n        if(s1[a] == s3[c]) takeS1 = solve(a + 1, b, c + 1);\\n        if(s2[b] == s3[c]) takeS2 = solve(a, b + 1, c + 1);\\n\\n        dp.set(key, takeS1 || takeS2);\\n        return takeS1 || takeS2;\\n    }\\n    return solve();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isInterleave = function(s1, s2, s3) {\\n    const dp = new Map();\\n    const solve = (a = 0, b = 0, c = 0) => {\\n        if(c == s3.length) return a == s1.length && b == s2.length;\\n        const key = [a, b, c].join(\\':\\');\\n        \\n        if(dp.has(key)) {\\n            // console.log(\\'hit\\');\\n            return dp.get(key);\\n        }\\n        \\n        let takeS1 = false, takeS2 = false;\\n        if(s1[a] == s3[c]) takeS1 = solve(a + 1, b, c + 1);\\n        if(s2[b] == s3[c]) takeS2 = solve(a, b + 1, c + 1);\\n\\n        dp.set(key, takeS1 || takeS2);\\n        return takeS1 || takeS2;\\n    }\\n    return solve();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906440,
                "title": "c-100-fast-recursion-memoization-clean-code-t-c-s-c-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[102][102];\\n    bool solve(string &s1, string &s2, string &s3, int i, int j, int k){\\n        \\n        if(k >= s3.size()) \\n            return true;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        bool flag1 = false, flag2 = false;\\n        if(s1[i] == s3[k]){\\n            flag1 =  solve(s1, s2, s3, i + 1, j, k + 1);\\n        }\\n        \\n        if(s2[j] == s3[k]){\\n            flag2 =  solve(s1, s2, s3, i, j + 1, k + 1);\\n        }\\n    \\n        return dp[i][j] = (flag1 || flag2);\\n        \\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n         if((s1.size() + s2.size()) != s3.size()) return false;\\n         memset(dp, -1,sizeof(dp));         \\n         return solve(s1, s2, s3, 0 , 0 , 0);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[102][102];\\n    bool solve(string &s1, string &s2, string &s3, int i, int j, int k){\\n        \\n        if(k >= s3.size()) \\n            return true;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        bool flag1 = false, flag2 = false;\\n        if(s1[i] == s3[k]){\\n            flag1 =  solve(s1, s2, s3, i + 1, j, k + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1506121,
                "title": "c-beats-100-9-lines-simple-recursion-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    bool interleave(string &s1, string &s2, string &s3,int i,int j,int k,vector<vector<int>> &dp)\\n    {\\n        if(k==s3.size()) return true;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        bool ans=false;\\n        if(i<s1.size() && s3[k]==s1[i]) ans=ans || interleave(s1,s2,s3,i+1,j,k+1,dp);\\n        if(j<s2.size() && s3[k]==s2[j]) ans = ans || interleave(s1,s2,s3,i,j+1,k+1,dp);\\n        return dp[i][j]=ans;\\n    }\\n    \\n    bool isInterleave(string &s1, string &s2, string &s3) {\\n    if(s1.size()+s2.size()!=s3.size()) return false;\\n    vector<vector<int>> dp(s1.size()+1,vector<int>(s2.size()+1,-1));    \\n    return interleave(s1,s2,s3,0,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool interleave(string &s1, string &s2, string &s3,int i,int j,int k,vector<vector<int>> &dp)\\n    {\\n        if(k==s3.size()) return true;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        bool ans=false;\\n        if(i<s1.size() && s3[k]==s1[i]) ans=ans || interleave(s1,s2,s3,i+1,j,k+1,dp);\\n        if(j<s2.size() && s3[k]==s2[j]) ans = ans || interleave(s1,s2,s3,i,j+1,k+1,dp);\\n        return dp[i][j]=ans;\\n    }\\n    \\n    bool isInterleave(string &s1, string &s2, string &s3) {\\n    if(s1.size()+s2.size()!=s3.size()) return false;\\n    vector<vector<int>> dp(s1.size()+1,vector<int>(s2.size()+1,-1));    \\n    return interleave(s1,s2,s3,0,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956644,
                "title": "it-just-works-in-java",
                "content": "# Intuition\\nTry all the possibilities using recursion, now include memory to reduce time complexity.\\n\\n# Approach\\n1. Use recursion to find all the possibilites to combine 2 strings to form final string str3.\\n2. Whenever the indx3 reaches the end we can return true, but only when indx1 and indx2 also reaches their end simultaneously because it is mentioned both the strings have to be used completely.\\n3. So if there haven\\'t reached their end at the same time when indx3 had reached end we can return false.\\n4. The rest of the code is just checking all the possibilities.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean recursion(int indx1,int indx2,int indx3,String s1,String s2,String s3,int[][][] dp){\\n        if(indx3==s3.length()) \\n        {\\n            if(indx1==s1.length() && indx2==s2.length())\\n                return true;\\n            else\\n                return false;\\n        }\\n\\n        if(dp[indx1][indx2][indx3]!=-1) return dp[indx1][indx2][indx3]==1?true:false;\\n        boolean first=false,second=false;\\n        if(indx1<s1.length() && s1.charAt(indx1)==s3.charAt(indx3))\\n            first = recursion(indx1+1,indx2,indx3+1,s1,s2,s3,dp);\\n        if(indx2<s2.length() && s2.charAt(indx2)==s3.charAt(indx3))\\n            second = recursion(indx1,indx2+1,indx3+1,s1,s2,s3,dp);\\n        \\n        dp[indx1][indx2][indx3] = (first||second)?1:0;\\n        return first || second;\\n    }\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int[][][]dp =new int[s1.length()+1][s2.length()+1][s3.length()+1];\\n        for(int i=0;i<=s1.length();i++){\\n            for(int j=0;j<=s2.length();j++){\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        return recursion(0,0,0,s1,s2,s3,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean recursion(int indx1,int indx2,int indx3,String s1,String s2,String s3,int[][][] dp){\\n        if(indx3==s3.length()) \\n        {\\n            if(indx1==s1.length() && indx2==s2.length())\\n                return true;\\n            else\\n                return false;\\n        }\\n\\n        if(dp[indx1][indx2][indx3]!=-1) return dp[indx1][indx2][indx3]==1?true:false;\\n        boolean first=false,second=false;\\n        if(indx1<s1.length() && s1.charAt(indx1)==s3.charAt(indx3))\\n            first = recursion(indx1+1,indx2,indx3+1,s1,s2,s3,dp);\\n        if(indx2<s2.length() && s2.charAt(indx2)==s3.charAt(indx3))\\n            second = recursion(indx1,indx2+1,indx3+1,s1,s2,s3,dp);\\n        \\n        dp[indx1][indx2][indx3] = (first||second)?1:0;\\n        return first || second;\\n    }\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int[][][]dp =new int[s1.length()+1][s2.length()+1][s3.length()+1];\\n        for(int i=0;i<=s1.length();i++){\\n            for(int j=0;j<=s2.length();j++){\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        return recursion(0,0,0,s1,s2,s3,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956593,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        n1=len(s1)\\n        n2=len(s2)\\n        n3=len(s3)\\n        @cache\\n        def isInter(i1,i2,i3):\\n            if i1==n1 and i2==n2 and i3==n3:\\n                return True\\n\\n            return i3<n3 and (i1<n1 and s1[i1]==s3[i3] and isInter(i1+1,i2,i3+1) or i2<n2 and s2[i2]==s3[i3] and isInter(i1,i2+1,i3+1))\\n\\n        return isInter(0,0,0)        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        n1=len(s1)\\n        n2=len(s2)\\n        n3=len(s3)\\n        @cache\\n        def isInter(i1,i2,i3):\\n            if i1==n1 and i2==n2 and i3==n3:\\n                return True\\n\\n            return i3<n3 and (i1<n1 and s1[i1]==s3[i3] and isInter(i1+1,i2,i3+1) or i2<n2 and s2[i2]==s3[i3] and isInter(i1,i2+1,i3+1))\\n\\n        return isInter(0,0,0)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679676,
                "title": "c-easy-tabular-dp-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- At each step, we have two options: **either take a character from s1 or take a character from s2** to contribute to the interleaved string.\\n- The solution for the current step depends on the solutions for the previous steps, which leads to **overlapping subproblems**.\\n- By using a **dynamic programming table** (such as the interleaved table in the code), we can store and reuse the solutions to these smaller subproblems.\\n---\\n\\n\\n# Approach\\n- **Initialize** the **interleaved** table of size (m+1) x (n+1).\\n- Iterate through each cell of the interleaved table using two nested loops.\\n- For each cell (i, j), there are following cases:\\n    1) If both **s1 and s2 are empty strings** (i.e., i == 0 and j == 0), then **interleaved[i][j] is set to true** since there are no characters to interleave.\\n    2) If **s1 is empty** (i.e., i == 0), then **interleaved[i][j]** is determined by **comparing s2[j-1] with s3[i+j-1]** and the **previous cell interleaved[i][j-1]**.\\n    3) If **s2 is empty** (i.e., j == 0), then **interleaved[i][j]** is determined by comparing **s1[i-1] with s3[i+j-1]** and the **previous cell interleaved[i-1][j]**.\\n    4) If both **s1 and s2 are non-empty**, **interleaved[i][j]** is determined by **comparing s1[i-1] with s3[i+j-1]** and the **previous cell interleaved[i-1][j]**, as well as **comparing s2[j-1] with s3[i+j-1]** and the **previous cell interleaved[i][j-1]**.\\n- Finally, **return interleaved[m][n]**, which represents whether s1 and s2 can interleave to form s3, where m and n are the lengths of s1 and s2 respectively.\\n<!-- Describe your approach to solving the problem. -->\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the code is **O(m * n)**, where m and n are the lengths of **s1** and **s2** respectively. The nested loops iterate through each cell of the **interleaved** table, which has dimensions (m+1) x (n+1).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nThe space complexity of the code is **O(m * n)**, where m and n are the lengths of **s1** and **s2** respectively. The interleaved table is of size (m+1) x (n+1), which\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n    if (s1.size() + s2.size() != s3.size()) {\\n        return false;\\n    }\\n    \\n    int m = s1.size();\\n    int n = s2.size();\\n    bool interleaved[m + 1][n + 1];\\n\\n    for (int i = 0; i <= m; i++) {\\n        for (int j = 0; j <= n; j++) {\\n            if (i == 0 && j == 0) {\\n                interleaved[i][j] = true;\\n            } else if (i == 0) {\\n                interleaved[i][j] = interleaved[i][j - 1] && s2[j - 1] == s3[i + j - 1];\\n            } else if (j == 0) {\\n                interleaved[i][j] = interleaved[i - 1][j] && s1[i - 1] == s3[i + j - 1];\\n            } else {\\n                interleaved[i][j] = (interleaved[i - 1][j] && s1[i - 1] == s3[i + j - 1]) ||\\n                                    (interleaved[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n    }\\n    \\n    return interleaved[m][n];\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n    if (s1.size() + s2.size() != s3.size()) {\\n        return false;\\n    }\\n    \\n    int m = s1.size();\\n    int n = s2.size();\\n    bool interleaved[m + 1][n + 1];\\n\\n    for (int i = 0; i <= m; i++) {\\n        for (int j = 0; j <= n; j++) {\\n            if (i == 0 && j == 0) {\\n                interleaved[i][j] = true;\\n            } else if (i == 0) {\\n                interleaved[i][j] = interleaved[i][j - 1] && s2[j - 1] == s3[i + j - 1];\\n            } else if (j == 0) {\\n                interleaved[i][j] = interleaved[i - 1][j] && s1[i - 1] == s3[i + j - 1];\\n            } else {\\n                interleaved[i][j] = (interleaved[i - 1][j] && s1[i - 1] == s3[i + j - 1]) ||\\n                                    (interleaved[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n    }\\n    \\n    return interleaved[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249605,
                "title": "python-elegant-short-top-down-dp-lru-cache",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n- Space complexity: $$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isInterleave(self, a: str, b: str, target: str) -> bool:\\n        @cache\\n        def dp(i: int, j: int) -> bool:\\n            if i == n and j == m:\\n                return True\\n            return any([\\n                i < n and a[i] == target[i + j] and dp(i + 1, j),\\n                j < m and b[j] == target[i + j] and dp(i, j + 1),\\n            ])\\n\\n        n, m = len(a), len(b)\\n        return n + m == len(target) and dp(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, a: str, b: str, target: str) -> bool:\\n        @cache\\n        def dp(i: int, j: int) -> bool:\\n            if i == n and j == m:\\n                return True\\n            return any([\\n                i < n and a[i] == target[i + j] and dp(i + 1, j),\\n                j < m and b[j] == target[i + j] and dp(i, j + 1),\\n            ])\\n\\n        n, m = len(a), len(b)\\n        return n + m == len(target) and dp(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783687,
                "title": "can-lcs-be-applied-to-this-problem-in-any-way",
                "content": "Can the longest common subsequence approach be applied to this problem in any way?\\n\\nMy initial intuition was we can return `true`,\\nif:\\n\\t\\ti) Length of String one + Length of String two == length of String three &&\\n\\t\\tii) Length of String one == LCS(String one, String three) &&\\n\\t\\tiii) Length of String two == LCS(String two, String three)\\n\\t\\t\\n`false` otherwise;\\n\\nBut this approach is failing some of the test cases. Please let me know if LCS can be applied to this problem in any way.",
                "solutionTags": [],
                "code": "Can the longest common subsequence approach be applied to this problem in any way?\\n\\nMy initial intuition was we can return `true`,\\nif:\\n\\t\\ti) Length of String one + Length of String two == length of String three &&\\n\\t\\tii) Length of String one == LCS(String one, String three) &&\\n\\t\\tiii) Length of String two == LCS(String two, String three)\\n\\t\\t\\n`false` otherwise;\\n\\nBut this approach is failing some of the test cases. Please let me know if LCS can be applied to this problem in any way.",
                "codeTag": "Unknown"
            },
            {
                "id": 1468511,
                "title": "simple-explanation-for-bottom-up-approach-with-diagrams",
                "content": "> First we create a dp table with s1 and s2( s1 -> Y-axis , s2-> X-axis) where **dp[i][j]** represents if first i characters of s1 and first j characters of s2 interleave to form ( i + j ) characters of s3.\\n![image](https://assets.leetcode.com/users/images/d761ab3b-78c4-426a-aee3-3f6a122fbc99_1631866519.9569435.png)\\n\\n\\n`How to fill dp table ?`\\nWe divide this into three parts \\n1. First Cell\\n2. First Row and First Column\\n3. Rest of the Cells\\n\\n* **First Cell** -> meaning  0 characters of s1 and 0 characters of s2 interleave to form 0 characters of s3 \\n\\t\\t![image](https://assets.leetcode.com/users/images/2e489f60-ac5d-46a6-b3b4-4812f788e547_1631866807.4218714.png)\\n\\t\\t\\n* **First Row** -> When  s1 is empty and s2 is not empty , then we have to check if substring of s2 = substring of s3\\n   ```\\n    if (s2[i-1] != s3[i-1])\\n\\t\\tdp[0][i] = false;\\n\\telse \\n\\t\\tdp[0][i] = dp[0][i-1];\\n   ```\\n  **Remember** : If we are at cell(i,j), then current characters of s1, s2 and s3 are (i-1)th, (j-1)th and (i+j-1)th characters of s1 , s2 and s3 respectively.\\n  \\n  Similarly ,\\n  **First Column** -> When s2 is empty and s1 is not empty, then we have to check if substring of s1 = substring of s3\\n  ```\\n\\t  if(s1[i-1] != s3[i-1])\\n\\t     dp[i][0] = false;\\n\\t  else \\n\\t\\t  dp[i][0] = dp[i-1][0];\\n  ```\\n  ![image](https://assets.leetcode.com/users/images/1c91c32c-c60f-4dfb-9e19-d785058dc61c_1631868477.9101102.png)\\n\\n  \\n*   **Rest of the cells**\\n  We have 4 possiblities for the rest of the cells, If\\n\\t  1. Current character of s3 is neither equals to current character of s1 nor current character of s2, then value of the cell is false\\n\\t  2. Current character of s3 is equal  current character of s1 but not current character of s2, then value of cell is the same cell above it.\\n\\t3. Current character of s3 is equal to current character of s2 but not current character of s1 , then value of cell is the cell left to it.\\n\\t4. Current character of s3 is equal to current character of s2 and current character of s1 , then value of cell is either from cell above it or cell left to it if they are true, otherwise false\\n\\n\\t\\t![image](https://assets.leetcode.com/users/images/fe18ed45-fe8c-4f54-bbda-8c4b74b277da_1631869257.556291.png)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        int l = s3.size();\\n        \\n        if(l != n + m)return false;\\n        \\n        vector<vector<bool>> dp(n+1 , vector<bool>(m+1, false));\\n        \\n        dp[0][0] = true;\\n        \\n        //populating first row\\n        for(int i=1 ;i<=m ;i++){\\n            if(s2[i-1] != s3[i-1])dp[0][i] = false;\\n            else dp[0][i] = dp[0][i-1];\\n        }\\n        \\n        //populating first col\\n        for(int i=1 ;i<=n ;i++){\\n            if(s1[i-1] != s3[i-1])dp[i][0] = false;\\n            else dp[i][0] = dp[i-1][0];\\n        }\\n        \\n        // rest\\n        for(int i=1;i<=n ;i++){\\n            for(int j=1;j<=m ;j++){\\n                if(s1[i-1] == s3[i+j-1] and s2[j-1] == s3[i+j-1]){\\n                    dp[i][j] = (dp[i-1][j] || dp[i][j-1]);\\n                }\\n                else if(s1[i-1] == s3[i+j-1] and s2[j-1] != s3[i+j-1]){\\n                    dp[i][j] = dp[i-1][j];\\n                } \\n                else if(s1[i-1] != s3[i+j-1] and s2[j-1] == s3[i+j-1]){\\n                    dp[i][j] = dp[i][j-1];\\n                }else{\\n                    dp[i][j] = false;\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];\\n        \\n        \\n        \\n    }\\n};\\n\\n```\\n\\nTime : O(M*N)\\n\\nSpace : O(M*N)\\n\\n**Space Opitmization**\\n**Idea** : To fill the each row , we just need one row above it ( 2 rows at a time ) \\n\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        int l = s3.size();\\n        \\n        if(l != n + m)return false;\\n        \\n\\t\\t// considering two rows at a time\\n        vector<vector<bool>> dp(2 , vector<bool>(m+1, false));\\n        \\n        dp[0][0] = true;\\n        \\n        //populating first row\\n        for(int i=1 ;i<=m ;i++){\\n            if(s2[i-1] != s3[i-1])dp[0][i] = false;\\n            else dp[0][i] = dp[0][i-1];\\n        }\\n        \\n     \\n        // rest\\n        for(int i=1;i<=n ;i++){\\n            for(int j=0;j<=m ;j++){\\n                if(j == 0){\\n                    // first col\\n                    if(s1[i-1] != s3[i+j-1])dp[i%2][j] = false;\\n                    else dp[i%2][j] = dp[(i-1)%2][j];\\n                }\\n                else if(s1[i-1] == s3[i+j-1] and s2[j-1] == s3[i+j-1]){\\n                    dp[i%2][j] = (dp[(i-1)%2][j] || dp[i%2][j-1]);\\n                }\\n                else if(s1[i-1] == s3[i+j-1] and s2[j-1] != s3[i+j-1]){\\n                    dp[i%2][j] = dp[(i-1)%2][j];\\n                } \\n                else if(s1[i-1] != s3[i+j-1] and s2[j-1] == s3[i+j-1]){\\n                    dp[i%2][j] = dp[i%2][j-1];\\n                }else{\\n                    dp[i%2][j] = false;\\n                }\\n            }\\n        }\\n        \\n        return dp[n%2][m];\\n        \\n        \\n        \\n    }\\n};\\n```\\n\\t\\nTime : O(M*N)\\n\\nSpace : O(M)\\n   \\n  \\n\\n\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    if (s2[i-1] != s3[i-1])\\n\\t\\tdp[0][i] = false;\\n\\telse \\n\\t\\tdp[0][i] = dp[0][i-1];\\n   ```\n```\\n\\t  if(s1[i-1] != s3[i-1])\\n\\t     dp[i][0] = false;\\n\\t  else \\n\\t\\t  dp[i][0] = dp[i-1][0];\\n  ```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        int l = s3.size();\\n        \\n        if(l != n + m)return false;\\n        \\n        vector<vector<bool>> dp(n+1 , vector<bool>(m+1, false));\\n        \\n        dp[0][0] = true;\\n        \\n        //populating first row\\n        for(int i=1 ;i<=m ;i++){\\n            if(s2[i-1] != s3[i-1])dp[0][i] = false;\\n            else dp[0][i] = dp[0][i-1];\\n        }\\n        \\n        //populating first col\\n        for(int i=1 ;i<=n ;i++){\\n            if(s1[i-1] != s3[i-1])dp[i][0] = false;\\n            else dp[i][0] = dp[i-1][0];\\n        }\\n        \\n        // rest\\n        for(int i=1;i<=n ;i++){\\n            for(int j=1;j<=m ;j++){\\n                if(s1[i-1] == s3[i+j-1] and s2[j-1] == s3[i+j-1]){\\n                    dp[i][j] = (dp[i-1][j] || dp[i][j-1]);\\n                }\\n                else if(s1[i-1] == s3[i+j-1] and s2[j-1] != s3[i+j-1]){\\n                    dp[i][j] = dp[i-1][j];\\n                } \\n                else if(s1[i-1] != s3[i+j-1] and s2[j-1] == s3[i+j-1]){\\n                    dp[i][j] = dp[i][j-1];\\n                }else{\\n                    dp[i][j] = false;\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];\\n        \\n        \\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        int l = s3.size();\\n        \\n        if(l != n + m)return false;\\n        \\n\\t\\t// considering two rows at a time\\n        vector<vector<bool>> dp(2 , vector<bool>(m+1, false));\\n        \\n        dp[0][0] = true;\\n        \\n        //populating first row\\n        for(int i=1 ;i<=m ;i++){\\n            if(s2[i-1] != s3[i-1])dp[0][i] = false;\\n            else dp[0][i] = dp[0][i-1];\\n        }\\n        \\n     \\n        // rest\\n        for(int i=1;i<=n ;i++){\\n            for(int j=0;j<=m ;j++){\\n                if(j == 0){\\n                    // first col\\n                    if(s1[i-1] != s3[i+j-1])dp[i%2][j] = false;\\n                    else dp[i%2][j] = dp[(i-1)%2][j];\\n                }\\n                else if(s1[i-1] == s3[i+j-1] and s2[j-1] == s3[i+j-1]){\\n                    dp[i%2][j] = (dp[(i-1)%2][j] || dp[i%2][j-1]);\\n                }\\n                else if(s1[i-1] == s3[i+j-1] and s2[j-1] != s3[i+j-1]){\\n                    dp[i%2][j] = dp[(i-1)%2][j];\\n                } \\n                else if(s1[i-1] != s3[i+j-1] and s2[j-1] == s3[i+j-1]){\\n                    dp[i%2][j] = dp[i%2][j-1];\\n                }else{\\n                    dp[i%2][j] = false;\\n                }\\n            }\\n        }\\n        \\n        return dp[n%2][m];\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406870,
                "title": "c-dp-solution-fully-explained",
                "content": "While solving dp question always first find what are the possible choices you have at any given point i.e., first make the choice diagram and then coding it will be very easy.\\n\\nAnd if you see some overlapping sub problems then just store their result and use it later.\\n\\nIn this question, we have to form `s3` using `s1` and `s2` while maintaining their orders.\\n\\n## How we\\'re getting the answer\\n\\nIn the given test case:\\n\\ns1 = `aabcc`\\ns2 = `dbbca`\\ns3 = `aadbbcbcac`\\n\\nI\\'m starting from the end and trying to make `s3` with the help of `s1` and `s2`\\n\\nLet `i = s1.size() - 1` (end of `s1`) and `j = s2.size() - 1` (end of `s2`) and `k = s3.size() - 1` (end of `s3`)\\n\\n1. First I need `c`, so take `c` from `s1` (now `s1` = `aabc ` and s2 =`dbbca` and `s3` = `aadbbcbca`)\\n2. Now,  I need `a`, so take `a` from `s2` (now `s1` = `aabc ` and s2 =`dbbc` and `s3` = `aadbbcbc`)\\n3. Now, I need `c`, so I can take `c` from either `s1` or from `s2`\\n\\nThis intuition is more than enough to make the choice diagram\\n\\n## Choice Diagram\\n\\n1. `ith` character of `s1` = `kth` character of `s3`  (aabc**c**, aadbbcbca**c**)\\n\\n\\tJust shift the two pointers `i` to `i-1` and `k` to `k-1` as we\\'ve included `c` from `s1`\\n\\t\\n\\t```\\n\\tsolve(s1, s2, s3, i-1, j, k-1);\\n\\t```\\n\\n2. `jth` character of `s2` = `kth` character of `s3`  (dbbc**a**, aadbbcbc**a**)\\n\\t\\n\\tJust shift the two pointers `j` to `j-1` and `k` to `k-1`\\n\\t\\n\\t```\\n\\tsolve(s1, s2, s3, i, j-1, k-1);\\n\\t```\\n\\t\\n3. Both `ith` and `jth` character are equal to `kth` character of `s3` (aab**c**, dbb**c**, aadbbcb**c**)\\n\\t\\n\\tIn this case I can take the character from any of the string. And since I can get answer from any of the possiblity that\\'s why I\\'m using `||` \\n\\t\\n\\t```\\n\\tsolve(s1, s2, s3, i-1, j, k-1) || solve(s1, s2,s3, i, j-1, k-1);\\n\\t```\\n\\t\\n\\n4. None of them are equal to `kth` character of `s3`\\n\\tIf none of the character is equal to the `kth` character of `s3` then it\\'s impossible to make `s3` with the help of `s1` and `s2` as they don\\'t contain the `kth` character in them.\\n\\n## Recursive Code\\n\\nIn this step we just have to code the choice diagram\\n\\n```\\nbool solve(string &s1, string &s2, string &s3, int i, int j, int k)\\n{\\n\\n\\t// Base Case\\n\\tif(k == 0 and (i or j)) // If we\\'ve reached the end of s3 but still some of the characters are remaining in s1 or s2 then return false as we\\'ve to utilise every character of s1 and s2\\n\\t\\treturn false;\\n\\n\\tif(i == 0 and j == 0 and k == 0) // If we\\'ve exhausted all of the three strings then just return true as we have finally formed s3 with the help of s1 and s2\\n\\t\\treturn true;\\n\\t\\t\\n\\t// Choice Diagram\\n\\t\\n\\t// i and j should be > 0, which make sures that there are some characters left in our string\\n\\n\\tif(i > 0 and j > 0 and s1[i-1] == s2[j-1] and s1[i-1] == s3[k-1]) // Case 3\\n\\t\\treturn solve(s1, s2, s3, i-1, j, k-1) || solve(s1, s2,s3, i, j-1, k-1);\\n\\n\\tif(i > 0 and s3[k-1] == s1[i-1]) // Case 1\\n\\t\\treturn solve(s1, s2, s3, i-1, j, k-1);\\n\\n\\tif(j > 0 and s3[k-1] == s2[j-1]) // Case 2\\n\\t\\treturn solve(s1, s2,s3, i, j-1, k-1);\\n\\n\\treturn false; // Case 4\\n}\\n\\nbool isInterleave(string s1, string s2, string s3) {\\n\\n\\tif(s1.size() + s2.size() != s3.size())\\n\\t\\treturn false;\\n\\n\\treturn solve(s1, s2, s3, s1.size(), s2.size(), s3.size());\\n}\\n```\\n\\n## Memoized Code\\n\\nWe just have to add 2-3 extra lines to convert recusive code into memoized code. Make a DP Table and store the subproblems result in it.\\n\\n```\\nbool solve(string &s1, string &s2, string &s3, int i, int j, int k, vector<vector<int>> &dp)\\n{\\n\\tif(k == 0 and (i or j))\\n\\t\\treturn false;\\n\\n\\tif(i == 0 and j == 0 and k == 0)\\n\\t\\treturn true;\\n\\n\\tif(dp[i][j] != -1) // Just return the result from the cache\\n\\t\\treturn dp[i][j];\\n\\n\\tif(i > 0 and j > 0 and s1[i-1] == s2[j-1] and s1[i-1] == s3[k-1])\\n\\t\\treturn dp[i][j] = solve(s1, s2, s3, i-1, j, k-1, dp) || solve(s1, s2,s3, i, j-1, k-1, dp); // before returning the result store it into the cache\\n\\n\\tif(i > 0 and s3[k-1] == s1[i-1])\\n\\t\\treturn dp[i][j] = solve(s1, s2, s3, i-1, j, k-1, dp);\\n\\n\\tif(j > 0 and s3[k-1] == s2[j-1])\\n\\t\\treturn dp[i][j] = solve(s1, s2,s3, i, j-1, k-1, dp);\\n\\n\\treturn dp[i][j] = false;\\n}\\n\\nbool isInterleave(string s1, string s2, string s3) {\\n\\n\\tvector<vector<int>> dp(s1.size() + 1, vector<int> (s2.size() + 1, -1)); // initialisiation of 2D vector\\n\\n\\tif(s1.size() + s2.size() != s3.size())\\n\\t\\treturn false;\\n\\n\\treturn solve(s1, s2, s3, s1.size(), s2.size(), s3.size(), dp);\\n}\\n```\\n\\nSmall tip to avoid TLE \\n\\nAlways use call by referance wherever you can as in call by referance you\\'re not wasting any time in making copies of variables in every function call.\\n\\nSo, if I\\'ve used `bool solve(string s1, string s2, string s3, int i, int j, int k, vector<vector<int>> dp)` this instead of `bool solve(string &s1, string &s2, string &s3, int i, int j, int k, vector<vector<int>> &dp)` then I would\\'ve definately gotten TLE as I\\'m unncecessarily copying the values in every function call.",
                "solutionTags": [],
                "code": "```\\n\\tsolve(s1, s2, s3, i-1, j, k-1);\\n\\t```\n```\\n\\tsolve(s1, s2, s3, i, j-1, k-1);\\n\\t```\n```\\n\\tsolve(s1, s2, s3, i-1, j, k-1) || solve(s1, s2,s3, i, j-1, k-1);\\n\\t```\n```\\nbool solve(string &s1, string &s2, string &s3, int i, int j, int k)\\n{\\n\\n\\t// Base Case\\n\\tif(k == 0 and (i or j)) // If we\\'ve reached the end of s3 but still some of the characters are remaining in s1 or s2 then return false as we\\'ve to utilise every character of s1 and s2\\n\\t\\treturn false;\\n\\n\\tif(i == 0 and j == 0 and k == 0) // If we\\'ve exhausted all of the three strings then just return true as we have finally formed s3 with the help of s1 and s2\\n\\t\\treturn true;\\n\\t\\t\\n\\t// Choice Diagram\\n\\t\\n\\t// i and j should be > 0, which make sures that there are some characters left in our string\\n\\n\\tif(i > 0 and j > 0 and s1[i-1] == s2[j-1] and s1[i-1] == s3[k-1]) // Case 3\\n\\t\\treturn solve(s1, s2, s3, i-1, j, k-1) || solve(s1, s2,s3, i, j-1, k-1);\\n\\n\\tif(i > 0 and s3[k-1] == s1[i-1]) // Case 1\\n\\t\\treturn solve(s1, s2, s3, i-1, j, k-1);\\n\\n\\tif(j > 0 and s3[k-1] == s2[j-1]) // Case 2\\n\\t\\treturn solve(s1, s2,s3, i, j-1, k-1);\\n\\n\\treturn false; // Case 4\\n}\\n\\nbool isInterleave(string s1, string s2, string s3) {\\n\\n\\tif(s1.size() + s2.size() != s3.size())\\n\\t\\treturn false;\\n\\n\\treturn solve(s1, s2, s3, s1.size(), s2.size(), s3.size());\\n}\\n```\n```\\nbool solve(string &s1, string &s2, string &s3, int i, int j, int k, vector<vector<int>> &dp)\\n{\\n\\tif(k == 0 and (i or j))\\n\\t\\treturn false;\\n\\n\\tif(i == 0 and j == 0 and k == 0)\\n\\t\\treturn true;\\n\\n\\tif(dp[i][j] != -1) // Just return the result from the cache\\n\\t\\treturn dp[i][j];\\n\\n\\tif(i > 0 and j > 0 and s1[i-1] == s2[j-1] and s1[i-1] == s3[k-1])\\n\\t\\treturn dp[i][j] = solve(s1, s2, s3, i-1, j, k-1, dp) || solve(s1, s2,s3, i, j-1, k-1, dp); // before returning the result store it into the cache\\n\\n\\tif(i > 0 and s3[k-1] == s1[i-1])\\n\\t\\treturn dp[i][j] = solve(s1, s2, s3, i-1, j, k-1, dp);\\n\\n\\tif(j > 0 and s3[k-1] == s2[j-1])\\n\\t\\treturn dp[i][j] = solve(s1, s2,s3, i, j-1, k-1, dp);\\n\\n\\treturn dp[i][j] = false;\\n}\\n\\nbool isInterleave(string s1, string s2, string s3) {\\n\\n\\tvector<vector<int>> dp(s1.size() + 1, vector<int> (s2.size() + 1, -1)); // initialisiation of 2D vector\\n\\n\\tif(s1.size() + s2.size() != s3.size())\\n\\t\\treturn false;\\n\\n\\treturn solve(s1, s2, s3, s1.size(), s2.size(), s3.size(), dp);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1248331,
                "title": "java-easy-to-understand-dp-solution",
                "content": "```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int n1=s1.length();\\n        int n2=s2.length();\\n        if(n1+n2!=s3.length())\\n            return false;\\n        boolean dp[][]=new boolean[n1+1][n2+1];\\n        dp[0][0]=true;\\n        for(int j=1;j<=n2;j++)\\n        {//initializing 0th row\\n            if(s2.charAt(j-1)==s3.charAt(j-1))\\n                dp[0][j]=dp[0][j-1];\\n        }\\n        for(int i=1;i<=n1;i++)\\n        {//initializing 0th column\\n            if(s1.charAt(i-1)==s3.charAt(i-1))\\n                dp[i][0]=dp[i-1][0];\\n        }\\n        for(int i=1;i<=n1;i++)\\n        {\\n            for(int j=1;j<=n2;j++)\\n            {//the length of s3 is n1+n2, since the string is 0 indexed we check at i+j-1\\n                if(s3.charAt(i+j-1)==s1.charAt(i-1))\\n                    dp[i][j]=dp[i-1][j];\\n                if(s3.charAt(i+j-1)==s2.charAt(j-1))\\n                    dp[i][j]=dp[i][j]||dp[i][j-1];  \\n\\t\\t\\t\\t\\t//In some cases the character from s3 matches both s1 and s2, therefore we consider the value thats true\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int n1=s1.length();\\n        int n2=s2.length();\\n        if(n1+n2!=s3.length())\\n            return false;\\n        boolean dp[][]=new boolean[n1+1][n2+1];\\n        dp[0][0]=true;\\n        for(int j=1;j<=n2;j++)\\n        {//initializing 0th row\\n            if(s2.charAt(j-1)==s3.charAt(j-1))\\n                dp[0][j]=dp[0][j-1];\\n        }\\n        for(int i=1;i<=n1;i++)\\n        {//initializing 0th column\\n            if(s1.charAt(i-1)==s3.charAt(i-1))\\n                dp[i][0]=dp[i-1][0];\\n        }\\n        for(int i=1;i<=n1;i++)\\n        {\\n            for(int j=1;j<=n2;j++)\\n            {//the length of s3 is n1+n2, since the string is 0 indexed we check at i+j-1\\n                if(s3.charAt(i+j-1)==s1.charAt(i-1))\\n                    dp[i][j]=dp[i-1][j];\\n                if(s3.charAt(i+j-1)==s2.charAt(j-1))\\n                    dp[i][j]=dp[i][j]||dp[i][j-1];  \\n\\t\\t\\t\\t\\t//In some cases the character from s3 matches both s1 and s2, therefore we consider the value thats true\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247271,
                "title": "python3-fast-dp-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/e6742f38-33b2-4096-a3b1-5e2854d6cca6_1622643568.1336555.png)\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m = len(s1) \\n        n = len(s2)\\n        @lru_cache(None)\\n        def dfs(i,j,k) : \\n            if i > m-1 and j > n-1 : \\n                return True\\n            if i < m and s1[i] == s3[k] and dfs(i+1,j,k+1) :\\n                return True \\n            if j < n and s2[j] == s3[k] and dfs(i,j+1,k+1) : \\n                return True\\n            return False\\n        return Counter(s1) + Counter(s2) == Counter(s3) and dfs(0,0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m = len(s1) \\n        n = len(s2)\\n        @lru_cache(None)\\n        def dfs(i,j,k) : \\n            if i > m-1 and j > n-1 : \\n                return True\\n            if i < m and s1[i] == s3[k] and dfs(i+1,j,k+1) :\\n                return True \\n            if j < n and s2[j] == s3[k] and dfs(i,j+1,k+1) : \\n                return True\\n            return False\\n        return Counter(s1) + Counter(s2) == Counter(s3) and dfs(0,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246962,
                "title": "basic-recursion",
                "content": "THIS WILL NOT ACCEPT\\nbut if you want the logic of this question then you need to understand the recursion behind this.\\n\\n\\n boolean  helper(String s1, String s2, String s3, int i, int j, int k) {\\n\\n\\tif(i<0 && j<0 && k<0)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\tif(i>=0 && j>=0 && s1.charAt(i)==s3.charAt(k) && s2.charAt(j)==s3.charAt(k))\\n\\t{\\n\\t\\treturn helper(s1,s2,s3,i-1,j,k-1) || helper(s1,s2,s3,i,j-1,k-1);\\n\\t}\\n\\telse if(i>=0 &&s1.charAt(i)==s3.charAt(k) )\\n\\t{\\n\\t\\treturn helper(s1,s2,s3,i-1,j,k-1);\\n\\t}\\n\\telse if(j>=0 && s2.charAt(j)==s3.charAt(k) )\\n\\t{\\n\\t\\treturn helper(s1,s2,s3,i,j-1,k-1);\\n\\t}else\\n\\t\\treturn false;\\n}\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "THIS WILL NOT ACCEPT\\nbut if you want the logic of this question then you need to understand the recursion behind this.\\n\\n\\n boolean  helper(String s1, String s2, String s3, int i, int j, int k) {\\n\\n\\tif(i<0 && j<0 && k<0)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\tif(i>=0 && j>=0 && s1.charAt(i)==s3.charAt(k) && s2.charAt(j)==s3.charAt(k))\\n\\t{\\n\\t\\treturn helper(s1,s2,s3,i-1,j,k-1) || helper(s1,s2,s3,i,j-1,k-1);\\n\\t}\\n\\telse if(i>=0 &&s1.charAt(i)==s3.charAt(k) )\\n\\t{\\n\\t\\treturn helper(s1,s2,s3,i-1,j,k-1);\\n\\t}\\n\\telse if(j>=0 && s2.charAt(j)==s3.charAt(k) )\\n\\t{\\n\\t\\treturn helper(s1,s2,s3,i,j-1,k-1);\\n\\t}else\\n\\t\\treturn false;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 259205,
                "title": "clean-javascript-bfs",
                "content": "I used BFS + Set for this approach and got 64ms. \\nThe idea is to try every possible combination, but skip duplicates by using set.\\n\\n```\\nvar isInterleave = function(s1, s2, s3) {    \\n  let queue = [[0, 0, 0]];\\n  let set = new Set();\\n  \\n  while (queue.length) {\\n    let [one, two, three] = queue.shift(); // indices of s1, s2, and s3\\n\\t\\n    if (set.has(`${one}-${two}`)) continue;   // Skipping any duplicates.\\n    set.add(`${one}-${two}`); \\n    \\n\\t// if all indices are same as their length we basically found our answer so return true;\\n    if (three === s3.length && one === s1.length && two === s2.length) return true;\\n    \\n\\t// we enqueue the next possibles\\n    if (one < s1.length && s3[three] === s1[one]) queue.push([one + 1, two, three + 1]);\\n    if (two < s2.length && s3[three] === s2[two]) queue.push([one, two + 1, three + 1]);\\n  }\\n  \\n  // Our queue is empty which means we tried every possible combination, so return false;\\n  return false; \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar isInterleave = function(s1, s2, s3) {    \\n  let queue = [[0, 0, 0]];\\n  let set = new Set();\\n  \\n  while (queue.length) {\\n    let [one, two, three] = queue.shift(); // indices of s1, s2, and s3\\n\\t\\n    if (set.has(`${one}-${two}`)) continue;   // Skipping any duplicates.\\n    set.add(`${one}-${two}`); \\n    \\n\\t// if all indices are same as their length we basically found our answer so return true;\\n    if (three === s3.length && one === s1.length && two === s2.length) return true;\\n    \\n\\t// we enqueue the next possibles\\n    if (one < s1.length && s3[three] === s1[one]) queue.push([one + 1, two, three + 1]);\\n    if (two < s2.length && s3[three] === s2[two]) queue.push([one, two + 1, three + 1]);\\n  }\\n  \\n  // Our queue is empty which means we tried every possible combination, so return false;\\n  return false; \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151397,
                "title": "javascript-dp-solution",
                "content": "```js\\nfunction isInterleave(s1, s2, s3) {\\n  if (s1.length + s2.length !== s3.length) {\\n    return false;\\n  }\\n  \\n  const N1 = s1.length;\\n  const N2 = s2.length;\\n  const DP = [...Array(N1+1)].map(r => Array(N2+1).fill(false));\\n  \\n  for (let r = 0; r <= N1; r++) {\\n    for (let c = 0; c <= N2; c++) {\\n      if (r === 0 && c === 0) {\\n        DP[r][c] = true;\\n      } else if (r === 0) {\\n        DP[r][c] = DP[r][c-1] && s2[c-1] === s3[r+c-1];\\n      } else if (c === 0) {\\n        DP[r][c] = DP[r-1][c] && s1[r-1] === s3[r+c-1];\\n      } else {\\n        DP[r][c] = (DP[r][c-1] && s3[r+c-1] === s2[c-1]) || (DP[r-1][c] && s3[r+c-1] === s1[r-1]);\\n      }\\n    }\\n  }\\n  \\n  return DP[N1][N2];\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction isInterleave(s1, s2, s3) {\\n  if (s1.length + s2.length !== s3.length) {\\n    return false;\\n  }\\n  \\n  const N1 = s1.length;\\n  const N2 = s2.length;\\n  const DP = [...Array(N1+1)].map(r => Array(N2+1).fill(false));\\n  \\n  for (let r = 0; r <= N1; r++) {\\n    for (let c = 0; c <= N2; c++) {\\n      if (r === 0 && c === 0) {\\n        DP[r][c] = true;\\n      } else if (r === 0) {\\n        DP[r][c] = DP[r][c-1] && s2[c-1] === s3[r+c-1];\\n      } else if (c === 0) {\\n        DP[r][c] = DP[r-1][c] && s1[r-1] === s3[r+c-1];\\n      } else {\\n        DP[r][c] = (DP[r][c-1] && s3[r+c-1] === s2[c-1]) || (DP[r-1][c] && s3[r+c-1] === s1[r-1]);\\n      }\\n    }\\n  }\\n  \\n  return DP[N1][N2];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31998,
                "title": "my-c-dp-solution",
                "content": "This is a typical DP problem. Use an array to save the intermediate matching result. dp[i][j] represents if s3[0::i+j-1] is an interleaved version of s1[0::i-1] and s2[0::j-1].  The recursive equation is dp[i][j] = ( dp[i-1][j] && (s1[i-1]==s3[i+j-1]) ) || ( dp[i][j-1] && (s2[j-1]==s3[i+j-1]) ). This equation only needs dp[i][] and dp[i-1][], so two rows are enough.\\n\\n    class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int len1 = s1.size(), len2 = s2.size(), len3 = s3.size(), row, col;\\n            if(len1+len2!=len3) return false;//if the length doesn't match\\n            if(!len1 || !len2) return s3 == s1+s2; // if at least one (s1 or s2) is empty, compare if the other equals to s3\\n            bool dp[2][len2+1];\\n    \\n            for(col=1, dp[0][0] = true; col<=len2;++col)\\n                dp[0][col] = dp[0][col-1] && (s2[col-1] == s3[col-1]); // generate the first row of dp\\n            \\n            for(row=1; row<=len1;++row)\\n                for(col=1, dp[row%2][0] = dp[(row-1)%2][0] && (s1[row-1]==s3[row-1]) ; col<=len2;++col)\\n                    dp[row%2][col] = (dp[row%2][col-1] && s2[col-1] == s3[row+col-1]) ||\\n                                     (dp[(row-1)%2][col] && s1[row-1] == s3[row+col-1]); // recursive equation\\n            return dp[len1%2][len2];                         \\n         }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int len1 = s1.size(), len2 = s2.size(), len3 = s3.size(), row, col;\\n            if(len1+len2!=len3) return false;//if the length doesn't match\\n            if(!len1 || !len2) return s3 == s1+s2; // if at least one (s1 or s2) is empty, compare if the other equals to s3\\n            bool dp[2][len2+1];\\n    \\n            for(col=1, dp[0][0] = true; col<=len2;++col)\\n                dp[0][col] = dp[0][col-1] && (s2[col-1] == s3[col-1]); // generate the first row of dp\\n            \\n            for(row=1; row<=len1;++row)\\n                for(col=1, dp[row%2][0] = dp[(row-1)%2][0] && (s1[row-1]==s3[row-1]) ; col<=len2;++col)\\n                    dp[row%2][col] = (dp[row%2][col-1] && s2[col-1] == s3[row+col-1]) ||\\n                                     (dp[(row-1)%2][col] && s1[row-1] == s3[row+col-1]); // recursive equation\\n            return dp[len1%2][len2];                         \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 32059,
                "title": "3ms-dfs-easy-to-understand",
                "content": "    void isInterleave1(int i, int j, int k, string s1, string s2, string s3, bool &flag, vector<bool> &visit)\\n    {\\n\\tif (!flag)\\n\\t{\\n\\t\\tif (k == s3.length())\\n\\t\\t{\\n\\t\\t\\tflag = true;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (!visit[i*(s2.length()+1) + j])\\n\\t\\t{\\n\\t\\t\\tvisit[i*(s2.length() + 1) + j] = true;\\n\\t\\t\\tif (i < s1.length() && s3[k] == s1[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tisInterleave1(i + 1, j, k + 1, s1, s2, s3, flag, visit);\\n\\t\\t\\t}\\n\\t\\t\\tif (j < s2.length() && s3[k] == s2[j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tisInterleave1(i, j + 1, k + 1, s1, s2, s3, flag, visit);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n\\tbool flag = false;\\n\\tif (s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\tvector<bool> visit((s1.length()+1)*(s2.length()+1), false);\\n\\tisInterleave1(0, 0, 0, s1, s2, s3, flag, visit);\\n\\treturn flag;\\n    }",
                "solutionTags": [],
                "code": "    void isInterleave1(int i, int j, int k, string s1, string s2, string s3, bool &flag, vector<bool> &visit)\\n    {\\n\\tif (!flag)\\n\\t{\\n\\t\\tif (k == s3.length())\\n\\t\\t{\\n\\t\\t\\tflag = true;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (!visit[i*(s2.length()+1) + j])\\n\\t\\t{\\n\\t\\t\\tvisit[i*(s2.length() + 1) + j] = true;\\n\\t\\t\\tif (i < s1.length() && s3[k] == s1[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tisInterleave1(i + 1, j, k + 1, s1, s2, s3, flag, visit);\\n\\t\\t\\t}\\n\\t\\t\\tif (j < s2.length() && s3[k] == s2[j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tisInterleave1(i, j + 1, k + 1, s1, s2, s3, flag, visit);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n\\tbool flag = false;\\n\\tif (s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\tvector<bool> visit((s1.length()+1)*(s2.length()+1), false);\\n\\tisInterleave1(0, 0, 0, s1, s2, s3, flag, visit);\\n\\treturn flag;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3957580,
                "title": "python-easy-to-understand-fast-dp-tabulation",
                "content": "# Python | Easy to Understand | Fast | DP-Tabulation\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3):\\n            return False\\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for i in range(1, m + 1):\\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\\n        for j in range(1, n + 1):\\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                choose_s1, choose_s2 = False, False\\n                if s1[i - 1] == s3[i + j - 1]:\\n                    choose_s1 = dp[i - 1][j]\\n                if s2[j - 1] == s3[i + j - 1]:\\n                    choose_s2 = dp[i][j - 1]\\n                dp[i][j] = choose_s1 or choose_s2\\n\\n        return dp[m][n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3):\\n            return False\\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for i in range(1, m + 1):\\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\\n        for j in range(1, n + 1):\\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                choose_s1, choose_s2 = False, False\\n                if s1[i - 1] == s3[i + j - 1]:\\n                    choose_s1 = dp[i - 1][j]\\n                if s2[j - 1] == s3[i + j - 1]:\\n                    choose_s2 = dp[i][j - 1]\\n                dp[i][j] = choose_s1 or choose_s2\\n\\n        return dp[m][n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956545,
                "title": "c-simple-solution-using-dp-tabulation-memoization",
                "content": "USING Dynamic Programming\\nMethod 1 -Memoization\\n*Time Complexity: O(m * n)\\nSpace Complexity: O(m * n)*\\n```\\nclass Solution {\\n      bool help(string& s1, string& s2, string& s3, int i, int j, int k, vector<vector<int>>& dp) {\\n\\n        if (i == s1.size() && j == s2.size() && k == s3.size()) { //base case \\n            return true;   \\n        }\\n        \\n        if (dp[i][j] != -1) {  //check is dp array\\n            return dp[i][j];\\n        }\\n        \\n        bool result = false;   //first false check s1 ,s2 element not present then return false as always\\n        if (i < s1.size() && s1[i] == s3[k]) { check string s1 first\\n            result = help(s1, s2, s3, i + 1, j, k + 1, dp);//check s1 and s3 \\n        }\\n        if (result==false && j < s2.size() && s2[j] == s3[k]) { check string s2\\n            result = help(s1, s2, s3, i, j + 1, k + 1, dp); //check s2 and s3\\n        }\\n        dp[i][j] = result;\\n        return result;\\n    }\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int k = s3.size();\\n\\n        if (m + n != k) {\\n            return false;  . // when size of s3 is larger\\n        }\\n        \\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, -1));\\n        return help(s1, s2, s3, 0, 0, 0, dp);\\n    }\\n};\\n```\\nMethod 2 -Tabulation\\n*Time Complexity: O(m * n)\\nSpace Complexity: O(m * n)*\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int k = s3.size();\\n\\n        if (m + n != k) {\\n            return false;\\n        }\\n\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n\\n        // base case\\n        dp[0][0] = true;\\n\\n        // Fill the dp table\\n        for (int i = 0; i <= m; ++i) {\\n            for (int j = 0; j <= n; ++j) {\\n                int l = i + j - 1; // Current character in s3\\n\\n                if (i > 0 && s1[i - 1] == s3[l]) {\\n                    dp[i][j] = dp[i][j] || dp[i - 1][j];\\n                }\\n\\n                if (j > 0 && s2[j - 1] == s3[l]) {\\n                    dp[i][j] = dp[i][j] || dp[i][j - 1];\\n                }\\n            }\\n        }\\n\\n        return dp[m][n];\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/ee427cbc-2502-4d04-9f60-13f66bf0a0b0_1692928977.5194664.webp)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n      bool help(string& s1, string& s2, string& s3, int i, int j, int k, vector<vector<int>>& dp) {\\n\\n        if (i == s1.size() && j == s2.size() && k == s3.size()) { //base case \\n            return true;   \\n        }\\n        \\n        if (dp[i][j] != -1) {  //check is dp array\\n            return dp[i][j];\\n        }\\n        \\n        bool result = false;   //first false check s1 ,s2 element not present then return false as always\\n        if (i < s1.size() && s1[i] == s3[k]) { check string s1 first\\n            result = help(s1, s2, s3, i + 1, j, k + 1, dp);//check s1 and s3 \\n        }\\n        if (result==false && j < s2.size() && s2[j] == s3[k]) { check string s2\\n            result = help(s1, s2, s3, i, j + 1, k + 1, dp); //check s2 and s3\\n        }\\n        dp[i][j] = result;\\n        return result;\\n    }\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int k = s3.size();\\n\\n        if (m + n != k) {\\n            return false;  . // when size of s3 is larger\\n        }\\n        \\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, -1));\\n        return help(s1, s2, s3, 0, 0, 0, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int k = s3.size();\\n\\n        if (m + n != k) {\\n            return false;\\n        }\\n\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n\\n        // base case\\n        dp[0][0] = true;\\n\\n        // Fill the dp table\\n        for (int i = 0; i <= m; ++i) {\\n            for (int j = 0; j <= n; ++j) {\\n                int l = i + j - 1; // Current character in s3\\n\\n                if (i > 0 && s1[i - 1] == s3[l]) {\\n                    dp[i][j] = dp[i][j] || dp[i - 1][j];\\n                }\\n\\n                if (j > 0 && s2[j - 1] == s3[l]) {\\n                    dp[i][j] = dp[i][j] || dp[i][j - 1];\\n                }\\n            }\\n        }\\n\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715481,
                "title": "c-solution-with-explanation",
                "content": "\\n# Approach\\nThe dynamic programming approach uses a 2D DP array where dp[i][j] represents whether the substrings s1[0...i-1] and s2[0...j-1] can interleave to form s3[0...i+j-1].\\n\\n\\nHere\\'s a step-by-step explanation of the logic behind the solution:\\n\\n1. **Base Case Initialization**: Initialize a 2D DP array `dp`, where `dp[i][j]` represents whether the first `i` characters of `s1` and the first `j` characters of `s2` can be interleaved to form the first `i + j` characters of `s3`. Initialize `dp[0][0]` as `true`, since two empty strings can form an empty string.\\n\\n2. **Check for Matches with `s1`**: Iterate through the characters of `s1` (from index 1 to `m`). For each character in `s1`, if the current character matches the corresponding character in `s3` and the previous state `dp[i - 1][0]` is `true`, set `dp[i][0]` as `true`. This means that the first `i` characters of `s1` can form the first `i` characters of `s3`.\\n\\n3. **Check for Matches with `s2`**: Similarly, iterate through the characters of `s2` (from index 1 to `n`). For each character in `s2`, if the current character matches the corresponding character in `s3` and the previous state `dp[0][j - 1]` is `true`, set `dp[0][j]` as `true`. This means that the first `j` characters of `s2` can form the first `j` characters of `s3`.\\n\\n4. **Interleaving Check**: Iterate through both `s1` and `s2` (using nested loops). For each position `(i, j)` in the DP array, check if either of the following conditions holds:\\n   - If the current character in `s1` matches the corresponding character in `s3` and the state `dp[i - 1][j]` is `true`. This indicates that characters from `s1` are being used.\\n   - If the current character in `s2` matches the corresponding character in `s3` and the state `dp[i][j - 1]` is `true`. This indicates that characters from `s2` are being used.\\n   \\n   If either of these conditions holds, set `dp[i][j]` as `true`, indicating that the characters from both `s1` and `s2` can be interleaved to form the current prefix of `s3`.\\n\\n5. **Final Result**: After filling the DP array, the value of `dp[m][n]` will indicate whether the entire strings `s1` and `s2` can be interleaved to form the string `s3`.\\n\\n\\n\\n# Upvote for goodluck in interviews\\uD83E\\uDD1E\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        \\n        // Check if the lengths of s1, s2, and s3 add up\\n        if (m + n != s3.length()) {\\n            return false;\\n        }\\n        \\n        // Create a 2D DP array to store the intermediate results\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n        \\n        // Initialize the base cases\\n        dp[0][0] = true;\\n        \\n        // Check if s1 matches with s3\\n        for (int i = 1; i <= m; i++) {\\n            if (s1[i - 1] == s3[i - 1] && dp[i - 1][0]) {\\n                dp[i][0] = true;\\n            }\\n        }\\n        \\n        // Check if s2 matches with s3\\n        for (int j = 1; j <= n; j++) {\\n            if (s2[j - 1] == s3[j - 1] && dp[0][j - 1]) {\\n                dp[0][j] = true;\\n            }\\n        }\\n        \\n        // Check if s1 and s2 interleave to form s3\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if ((s1[i - 1] == s3[i + j - 1] && dp[i - 1][j]) ||\\n                    (s2[j - 1] == s3[i + j - 1] && dp[i][j - 1])) {\\n                    dp[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        \\n        // Check if the lengths of s1, s2, and s3 add up\\n        if (m + n != s3.length()) {\\n            return false;\\n        }\\n        \\n        // Create a 2D DP array to store the intermediate results\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n        \\n        // Initialize the base cases\\n        dp[0][0] = true;\\n        \\n        // Check if s1 matches with s3\\n        for (int i = 1; i <= m; i++) {\\n            if (s1[i - 1] == s3[i - 1] && dp[i - 1][0]) {\\n                dp[i][0] = true;\\n            }\\n        }\\n        \\n        // Check if s2 matches with s3\\n        for (int j = 1; j <= n; j++) {\\n            if (s2[j - 1] == s3[j - 1] && dp[0][j - 1]) {\\n                dp[0][j] = true;\\n            }\\n        }\\n        \\n        // Check if s1 and s2 interleave to form s3\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if ((s1[i - 1] == s3[i + j - 1] && dp[i - 1][j]) ||\\n                    (s2[j - 1] == s3[i + j - 1] && dp[i][j - 1])) {\\n                    dp[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097709,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size(), n2=s2.size(), n3=s3.size();\\n        if(n1+n2 != n3)\\n        return false;\\n        vector<vector<bool>> dp(n1+1, vector<bool>(n2+1));\\n        for(int i=0;i<=n1;i++)\\n        {\\n            for(int j=0;j<=n2;j++)\\n            {\\n                if(i==0 && j==0)\\n                dp[i][j]=true;\\n                else if(i==0)\\n                dp[i][j]=(dp[i][j-1] && s2[j-1]==s3[j-1]);\\n                else if(j==0)\\n                dp[i][j]=(dp[i-1][j] && s1[i-1]==s3[i-1]);\\n                else\\n                dp[i][j]=(dp[i][j-1] && s2[j-1]==s3[i+j-1]) || \\n                         (dp[i-1][j] && s1[i-1]==s3[i+j-1]);\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size(), n2=s2.size(), n3=s3.size();\\n        if(n1+n2 != n3)\\n        return false;\\n        vector<vector<bool>> dp(n1+1, vector<bool>(n2+1));\\n        for(int i=0;i<=n1;i++)\\n        {\\n            for(int j=0;j<=n2;j++)\\n            {\\n                if(i==0 && j==0)\\n                dp[i][j]=true;\\n                else if(i==0)\\n                dp[i][j]=(dp[i][j-1] && s2[j-1]==s3[j-1]);\\n                else if(j==0)\\n                dp[i][j]=(dp[i-1][j] && s1[i-1]==s3[i-1]);\\n                else\\n                dp[i][j]=(dp[i][j-1] && s2[j-1]==s3[i+j-1]) || \\n                         (dp[i-1][j] && s1[i-1]==s3[i+j-1]);\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250515,
                "title": "c-easy-understandable-code-recursive-dp-please-upvote-if-found-useful",
                "content": "``` \\n#define ll long long\\nclass Solution {\\npublic:\\n    ll n,m,nn;\\n    bool fun(ll i,ll j,ll k,string &s1,string &s2,string &t, vector<vector<vector<int>>>&dp){\\n        \\n        \\n        if(i==n and j==m and k==nn)return true;\\n        else if(i==n and j==m)return false;\\n        else if(i==n){\\n            bool ok=true;\\n            if(s2.substr(j,m-j)==t.substr(k,nn-k))return true;\\n            else return dp[i][j][k]= false;\\n        }\\n        else if(j==m){\\n              if(s1.substr(i,n-i)==t.substr(k,nn-k))return true;\\n            else return  dp[i][j][k]=false;\\n        }\\n        \\n        if(dp[i][j][k]!=-1)return dp[i][j][k];\\n        \\n        if(s1[i]==t[k] and s2[j]==t[k]){\\n            bool ans1=fun(i+1,j,k+1,s1,s2,t,dp);\\n            bool ans2=fun(i,j+1,k+1,s1,s2,t,dp);\\n            return dp[i][j][k]= ans1|ans2;\\n        }\\n        else if(s1[i]==t[k]){\\n            return dp[i][j][k]= fun(i+1,j,k+1,s1,s2,t,dp);\\n        }\\n        else if(s2[j]==t[k]){\\n            return dp[i][j][k]= fun(i,j+1,k+1,s1,s2,t,dp);\\n        }\\n        else return dp[i][j][k]= false;\\n    }\\n    \\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        n=s1.size();\\n        m=s2.size();\\n        nn=s3.size();\\n        if(n+m!=nn)return false;\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(m+1,vector<int>(nn+1,-1)));\\n        \\n        return fun(0,0,0,s1,s2,s3,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` \\n#define ll long long\\nclass Solution {\\npublic:\\n    ll n,m,nn;\\n    bool fun(ll i,ll j,ll k,string &s1,string &s2,string &t, vector<vector<vector<int>>>&dp){\\n        \\n        \\n        if(i==n and j==m and k==nn)return true;\\n        else if(i==n and j==m)return false;\\n        else if(i==n){\\n            bool ok=true;\\n            if(s2.substr(j,m-j)==t.substr(k,nn-k))return true;\\n            else return dp[i][j][k]= false;\\n        }\\n        else if(j==m){\\n              if(s1.substr(i,n-i)==t.substr(k,nn-k))return true;\\n            else return  dp[i][j][k]=false;\\n        }\\n        \\n        if(dp[i][j][k]!=-1)return dp[i][j][k];\\n        \\n        if(s1[i]==t[k] and s2[j]==t[k]){\\n            bool ans1=fun(i+1,j,k+1,s1,s2,t,dp);\\n            bool ans2=fun(i,j+1,k+1,s1,s2,t,dp);\\n            return dp[i][j][k]= ans1|ans2;\\n        }\\n        else if(s1[i]==t[k]){\\n            return dp[i][j][k]= fun(i+1,j,k+1,s1,s2,t,dp);\\n        }\\n        else if(s2[j]==t[k]){\\n            return dp[i][j][k]= fun(i,j+1,k+1,s1,s2,t,dp);\\n        }\\n        else return dp[i][j][k]= false;\\n    }\\n    \\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        n=s1.size();\\n        m=s2.size();\\n        nn=s3.size();\\n        if(n+m!=nn)return false;\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(m+1,vector<int>(nn+1,-1)));\\n        \\n        return fun(0,0,0,s1,s2,s3,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249170,
                "title": "very-very-easy-100-beat-solution",
                "content": "class Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size();\\n        int n2=s2.size();\\n        int n3=s3.size();\\n        if(n3!=n1+n2) return false;\\n        bool t[n1+1][n2+1];\\n        for(int i=0;i<n1+1;i++)\\n            for(int j=0;j<n2+1;j++){\\n                if(i==0&&j==0) t[i][j]= true;\\n                else if(i==0)\\n                    t[i][j]=(t[i][j-1]&&s2[j-1]==s3[i+j-1]);\\n                else if(j==0)\\n                    t[i][j]=(t[i-1][j]&&s1[i-1]==s3[i+j-1]);\\n                else \\n                    t[i][j]=(t[i-1][j]&&s1[i-1]==s3[i+j-1])||\\n                              (t[i][j-1]&&s2[j-1]==s3[i+j-1]);\\n            }\\n        return t[n1][n2];\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size();\\n        int n2=s2.size();\\n        int n3=s3.size();\\n        if(n3!=n1+n2) return false;\\n        bool t[n1+1][n2+1];\\n        for(int i=0;i<n1+1;i++)\\n            for(int j=0;j<n2+1;j++){\\n                if(i==0&&j==0) t[i][j]= true;\\n                else if(i==0)\\n                    t[i][j]=(t[i][j-1]&&s2[j-1]==s3[i+j-1]);\\n                else if(j==0)\\n                    t[i][j]=(t[i-1][j]&&s1[i-1]==s3[i+j-1]);\\n                else \\n                    t[i][j]=(t[i-1][j]&&s1[i-1]==s3[i+j-1])||\\n                              (t[i][j-1]&&s2[j-1]==s3[i+j-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2248916,
                "title": "c-top-down-approach-dynamic-programming-diagram-recursion-tree",
                "content": "![image](https://assets.leetcode.com/users/images/93cf4f7e-6b36-4465-9a08-fa9a9abef864_1657167982.869954.jpeg)\\n\\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n**Recursion Tree**\\n\\n![image](https://assets.leetcode.com/users/images/ad3ede31-8317-43b5-8338-cc74add708ed_1657167531.1246266.jpeg)\\n\\nNow take **s1=\"aa\" and s2=\"aa\" s3 = \"aaaa\"** . \\nYou will observe repeated subproblems . \\n\\n\\n***C++ Top-Down Memoization***\\n```\\nclass Solution {\\npublic:\\n    bool recursion(string s1, int i,string s2,int j ,string s3 ,int k,vector<vector<int>>&dp)\\n    {\\n        if(i==s1.length() && j==s2.length() && k==s3.length())\\n            return true; // when all three strings reach end simultaneously \\n        \\n        if(k==s3.length()) return false; \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n    \\n        if(s1[i]==s3[k] && recursion(s1,i+1,s2,j,s3,k+1,dp))\\n            return dp[i][j]=true;\\n        if(s2[j]==s3[k] && recursion(s1,i,s2,j+1,s3,k+1,dp))\\n            return dp[i][j]=true;\\n        \\n        return dp[i][j]=false;\\n    }\\n  \\n    bool isInterleave(string s1, string s2, string s3) \\n    {\\n        if(s1.length()+s2.length()!=s3.length())\\n            return false;\\n            \\n        vector<vector<int>>dp(s1.length()+1,vector<int>(s2.length()+1,-1));\\n        \\n        return recursion(s1,0,s2,0,s3,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool recursion(string s1, int i,string s2,int j ,string s3 ,int k,vector<vector<int>>&dp)\\n    {\\n        if(i==s1.length() && j==s2.length() && k==s3.length())\\n            return true; // when all three strings reach end simultaneously \\n        \\n        if(k==s3.length()) return false; \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n    \\n        if(s1[i]==s3[k] && recursion(s1,i+1,s2,j,s3,k+1,dp))\\n            return dp[i][j]=true;\\n        if(s2[j]==s3[k] && recursion(s1,i,s2,j+1,s3,k+1,dp))\\n            return dp[i][j]=true;\\n        \\n        return dp[i][j]=false;\\n    }\\n  \\n    bool isInterleave(string s1, string s2, string s3) \\n    {\\n        if(s1.length()+s2.length()!=s3.length())\\n            return false;\\n            \\n        vector<vector<int>>dp(s1.length()+1,vector<int>(s2.length()+1,-1));\\n        \\n        return recursion(s1,0,s2,0,s3,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1813050,
                "title": "c-o-n-2-top-down-memoization",
                "content": "```\\nclass Solution {\\nprivate:\\n    string p, q, s;\\n    bool f(int i, int j, vector<vector<int>>& dp) {\\n        if(i == p.size() and j == q.size())\\n            return 1;\\n        bool ans = 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n         if(i < p.size() and p[i] == s[i + j])\\n             ans |= f(i + 1, j, dp);\\n        \\n         if(j < q.size() and q[j] == s[i + j])\\n            ans |= f(i, j + 1, dp);\\n\\n        \\n       \\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n                p = s1, q = s2, s = s3;\\n        vector<vector<int>> dp(101, vector<int>(101, -1));\\n        if(s1.size() + s2.size() != s3.size())\\n            return false;\\n        \\n        int i = 0, j = 0;\\n        return f(i, j, dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\nprivate:\\n    string p, q, s;\\n    bool f(int i, int j, vector<vector<int>>& dp) {\\n        if(i == p.size() and j == q.size())\\n            return 1;\\n        bool ans = 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n         if(i < p.size() and p[i] == s[i + j])\\n             ans |= f(i + 1, j, dp);\\n        \\n         if(j < q.size() and q[j] == s[i + j])\\n            ans |= f(i, j + 1, dp);\\n\\n        \\n       \\n        return dp[i][j] = ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1731392,
                "title": "python-3-memo-soln-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1)+len(s2)!=len(s3):\\n            return False\\n        \\n        dp={}\\n        \\n        def solve(i,j):\\n            \\n            if i== len(s1) and j==len(s2):\\n                return True\\n            \\n            if (i,j) in dp:\\n                return dp[(i,j)]\\n            \\n            if  i <len(s1) and s3[i+j]==s1[i] and solve(i+1,j):\\n                return True\\n\\n            if j<len(s2) and s3[i+j]==s2[j] and solve(i,j+1):\\n                return True\\n            \\n            dp[(i,j)]=False\\n         \\n        return solve(0,0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1)+len(s2)!=len(s3):\\n            return False\\n        \\n        dp={}\\n        \\n        def solve(i,j):\\n            \\n            if i== len(s1) and j==len(s2):\\n                return True\\n            \\n            if (i,j) in dp:\\n                return dp[(i,j)]\\n            \\n            if  i <len(s1) and s3[i+j]==s1[i] and solve(i+1,j):\\n                return True\\n\\n            if j<len(s2) and s3[i+j]==s2[j] and solve(i,j+1):\\n                return True\\n            \\n            dp[(i,j)]=False\\n         \\n        return solve(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375149,
                "title": "simple-java-solution-dp-memoization-time-o-n-m",
                "content": "```\\nclass Solution {\\n\\tpublic boolean isInterLeave(String s1,String s2,String s3)\\n\\t{\\n       if(s1.length()+s2.length()!=s3.length())\\n       return false;\\n       Boolean dp[][]= new Boolean[s1.length()+1][s2.length()+1];\\n       return  solve(s1,s2,s3,0,0,dp);\\n    }\\n    \\n     boolean solve(String s1,String s2,String s3,int i,int j, Boolean[][]dp)\\n     {\\n           if( i == s1.length() && j == s2.length() )\\n            return  true;\\n         \\n         if(dp[i][j]!=null)\\n         {\\n             return dp[i][j];\\n         }\\n         \\n        if(i< s1.length() && s1.charAt(i)==s3.charAt(i+j)) \\n        {\\n           boolean f1= solve(s1,s2,s3,i+1,j,dp);\\n            dp[i][j] =  f1;\\n            if(f1==true)\\n            {\\n                return true;\\n            }\\n        }\\n       if(j< s2.length() && s2.charAt(j)==s3.charAt(i+j)) \\n        {\\n           boolean f2= solve(s1,s2,s3,i,j+1,dp);\\n            dp[i][j] = f2;\\n            if(f2==true)\\n            {\\n                return true;\\n            }    \\n        }   \\n       dp[i][j]=false;  \\n       return dp[i][j];  \\n     }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic boolean isInterLeave(String s1,String s2,String s3)\\n\\t{\\n       if(s1.length()+s2.length()!=s3.length())\\n       return false;\\n       Boolean dp[][]= new Boolean[s1.length()+1][s2.length()+1];\\n       return  solve(s1,s2,s3,0,0,dp);\\n    }\\n    \\n     boolean solve(String s1,String s2,String s3,int i,int j, Boolean[][]dp)\\n     {\\n           if( i == s1.length() && j == s2.length() )\\n            return  true;\\n         \\n         if(dp[i][j]!=null)\\n         {\\n             return dp[i][j];\\n         }\\n         \\n        if(i< s1.length() && s1.charAt(i)==s3.charAt(i+j)) \\n        {\\n           boolean f1= solve(s1,s2,s3,i+1,j,dp);\\n            dp[i][j] =  f1;\\n            if(f1==true)\\n            {\\n                return true;\\n            }\\n        }\\n       if(j< s2.length() && s2.charAt(j)==s3.charAt(i+j)) \\n        {\\n           boolean f2= solve(s1,s2,s3,i,j+1,dp);\\n            dp[i][j] = f2;\\n            if(f2==true)\\n            {\\n                return true;\\n            }    \\n        }   \\n       dp[i][j]=false;  \\n       return dp[i][j];  \\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247301,
                "title": "interleaving-string-dp-solution-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int x = s1.length();\\n        int y = s2.length();\\n        int z = s3.length();\\n        if(z!=x+y)\\n            return false;\\n        bool dp[x+1][y+1];\\n        for(int i=0;i<=x;i++)\\n        {\\n            for(int j=0;j<=y;j++)\\n            {\\n                if(i==0 && j==0)\\n                    dp[i][j]=true;\\n                else if(i==0)\\n                    dp[i][j] = dp[i][j-1] && s2[j-1]==s3[j-1];\\n                else if(j==0)\\n                    dp[i][j] = dp[i-1][j] && s1[i-1]==s3[i-1];\\n                else\\n                    dp[i][j] = ((dp[i][j-1] && s2[j-1]==s3[i+j-1]) || (dp[i-1][j] && s1[i-1]==s3[i+j-1]));\\n            }\\n        }\\n        return dp[x][y];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int x = s1.length();\\n        int y = s2.length();\\n        int z = s3.length();\\n        if(z!=x+y)\\n            return false;\\n        bool dp[x+1][y+1];\\n        for(int i=0;i<=x;i++)\\n        {\\n            for(int j=0;j<=y;j++)\\n            {\\n                if(i==0 && j==0)\\n                    dp[i][j]=true;\\n                else if(i==0)\\n                    dp[i][j] = dp[i][j-1] && s2[j-1]==s3[j-1];\\n                else if(j==0)\\n                    dp[i][j] = dp[i-1][j] && s1[i-1]==s3[i-1];\\n                else\\n                    dp[i][j] = ((dp[i][j-1] && s2[j-1]==s3[i+j-1]) || (dp[i-1][j] && s1[i-1]==s3[i+j-1]));\\n            }\\n        }\\n        return dp[x][y];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247179,
                "title": "c-clean-dp-solution-o-n-m-space-and-o-m-space",
                "content": "# **O(n\\\\*m) space**\\n\\n```\\nbool isInterleave(string s1, string s2, string s3) {\\n\\n\\tint n = s1.size(), m = s2.size(), sz = s3.size();\\n\\tif(n + m != sz) return false;\\n\\n\\tvector<vector<bool>> dp(n+1, vector<bool>(m+1));\\n\\t// dp[i][j] = is it possible to form s3[0...i+j-1] from s1[0...i-1] and s2[0...j-1]\\n\\n\\t// both strings empty\\n\\tdp[0][0] = true;\\n\\n\\t// if s2 is empty\\n\\tfor(int i = 1 ; i <= n ; i++) {\\n\\t\\tdp[i][0] = (s1[i-1] == s3[i-1]) and dp[i-1][0];\\n\\t}\\n\\n\\t// if s1 is empty\\n\\tfor(int j = 1 ; j <= m ; j++) {\\n\\t\\tdp[0][j] = (s2[j-1] == s3[j-1]) and dp[0][j-1];\\n\\t}\\n\\n\\tfor(int i = 1 ; i <= n ; i++) {\\n\\t\\tfor(int j = 1 ; j <= m ; j++) {\\n\\n\\t\\t\\tbool matchI = (s1[i-1] == s3[i+j-1]) and dp[i-1][j];\\n\\t\\t\\tbool matchJ = (s2[j-1] == s3[i+j-1]) and dp[i][j-1];\\n\\n\\t\\t\\tdp[i][j] = matchI or matchJ;\\n\\t\\t}\\n\\t}\\n\\n\\n\\treturn dp[n][m];\\n}\\n```\\n\\n# **O(m) space**\\n\\n\\n```\\nbool isInterleave(string s1, string s2, string s3) {\\n\\tint n = s1.size(), m = s2.size();\\n\\tif(n + m != s3.size()) return false;\\n\\n\\n\\tvector<bool> dp(m+1);\\n\\tdp[0] = true;\\n\\n\\tfor(int len1 = 0 ; len1 <= n ; len1++) {\\n\\t\\tfor(int len2 = 0 ; len2 <= m ; len2++) {\\n\\n\\t\\t\\tif(!len1 and !len2) continue;\\n\\t\\t\\tint len3 = len1 + len2;\\n\\t\\t\\tbool match1 = (len1) ? s1[len1-1] == s3[len3-1] and dp[len2] : false;\\n\\t\\t\\tbool match2 = (len2) ? s2[len2-1] == s3[len3-1] and dp[len2-1] : false;\\n\\t\\t\\tdp[len2] = match1 or match2;\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[m];\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nbool isInterleave(string s1, string s2, string s3) {\\n\\n\\tint n = s1.size(), m = s2.size(), sz = s3.size();\\n\\tif(n + m != sz) return false;\\n\\n\\tvector<vector<bool>> dp(n+1, vector<bool>(m+1));\\n\\t// dp[i][j] = is it possible to form s3[0...i+j-1] from s1[0...i-1] and s2[0...j-1]\\n\\n\\t// both strings empty\\n\\tdp[0][0] = true;\\n\\n\\t// if s2 is empty\\n\\tfor(int i = 1 ; i <= n ; i++) {\\n\\t\\tdp[i][0] = (s1[i-1] == s3[i-1]) and dp[i-1][0];\\n\\t}\\n\\n\\t// if s1 is empty\\n\\tfor(int j = 1 ; j <= m ; j++) {\\n\\t\\tdp[0][j] = (s2[j-1] == s3[j-1]) and dp[0][j-1];\\n\\t}\\n\\n\\tfor(int i = 1 ; i <= n ; i++) {\\n\\t\\tfor(int j = 1 ; j <= m ; j++) {\\n\\n\\t\\t\\tbool matchI = (s1[i-1] == s3[i+j-1]) and dp[i-1][j];\\n\\t\\t\\tbool matchJ = (s2[j-1] == s3[i+j-1]) and dp[i][j-1];\\n\\n\\t\\t\\tdp[i][j] = matchI or matchJ;\\n\\t\\t}\\n\\t}\\n\\n\\n\\treturn dp[n][m];\\n}\\n```\n```\\nbool isInterleave(string s1, string s2, string s3) {\\n\\tint n = s1.size(), m = s2.size();\\n\\tif(n + m != s3.size()) return false;\\n\\n\\n\\tvector<bool> dp(m+1);\\n\\tdp[0] = true;\\n\\n\\tfor(int len1 = 0 ; len1 <= n ; len1++) {\\n\\t\\tfor(int len2 = 0 ; len2 <= m ; len2++) {\\n\\n\\t\\t\\tif(!len1 and !len2) continue;\\n\\t\\t\\tint len3 = len1 + len2;\\n\\t\\t\\tbool match1 = (len1) ? s1[len1-1] == s3[len3-1] and dp[len2] : false;\\n\\t\\t\\tbool match2 = (len2) ? s2[len2-1] == s3[len3-1] and dp[len2-1] : false;\\n\\t\\t\\tdp[len2] = match1 or match2;\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[m];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1246996,
                "title": "c-dp-4ms-solution-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.length()>s1.length()+s2.length() || s3.length()<s1.length()+s2.length()){\\n            return false; \\n        }\\n        if(s3==(s1+s2)){\\n            return true;\\n        }\\n        vector<vector<int>> dp(s1.length()+1, vector<int> (s2.length()+1,-1));\\n        return interleave(s1,s2,s3,0,0,0,dp);\\n    }\\n    bool interleave(string &s1, string &s2, string &s3, int i, int j, int k, vector<vector<int>> &dp){\\n        if((i==s1.length()&&j==s2.length()) && (k==s3.length())){\\n            return true; //base case\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j]; //look-up\\n            }\\n        if(i==s1.length()&& j< s2.length()){\\n             if(s3[k]==s2[j])\\n            return dp[i][j] = interleave(s1,s2,s3,i,j+1,k+1,dp); // if s1 string gets empty\\n            return false;\\n        }\\n        if(i<s1.length() && j==s2.length()){\\n           if(s3[k]==s1[i])\\n            return dp[i][j] = interleave(s1,s2,s3,i+1,j,k+1,dp); // if s2 string gets empty\\n            return false;\\n        }\\n        if(s3[k]==s2[j] && s3[k]==s1[i]){\\n            bool op2 = interleave(s1,s2,s3,i+1,j,k+1,dp); //choose from string s1\\n            bool op1 = interleave(s1,s2,s3,i,j+1,k+1,dp);  //choose from string s2;\\n            \\n            return dp[i][j] = op1||op2;\\n        }else if(s3[k]==s2[j]){\\n            return dp[i][j] = interleave(s1,s2,s3,i,j+1,k+1,dp); // choose from string s2;\\n        }else if(s3[k]==s1[i]){\\n            return dp[i][j] = interleave(s1,s2,s3,i+1,j,k+1,dp); // choose from string s1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.length()>s1.length()+s2.length() || s3.length()<s1.length()+s2.length()){\\n            return false; \\n        }\\n        if(s3==(s1+s2)){\\n            return true;\\n        }\\n        vector<vector<int>> dp(s1.length()+1, vector<int> (s2.length()+1,-1));\\n        return interleave(s1,s2,s3,0,0,0,dp);\\n    }\\n    bool interleave(string &s1, string &s2, string &s3, int i, int j, int k, vector<vector<int>> &dp){\\n        if((i==s1.length()&&j==s2.length()) && (k==s3.length())){\\n            return true; //base case\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j]; //look-up\\n            }\\n        if(i==s1.length()&& j< s2.length()){\\n             if(s3[k]==s2[j])\\n            return dp[i][j] = interleave(s1,s2,s3,i,j+1,k+1,dp); // if s1 string gets empty\\n            return false;\\n        }\\n        if(i<s1.length() && j==s2.length()){\\n           if(s3[k]==s1[i])\\n            return dp[i][j] = interleave(s1,s2,s3,i+1,j,k+1,dp); // if s2 string gets empty\\n            return false;\\n        }\\n        if(s3[k]==s2[j] && s3[k]==s1[i]){\\n            bool op2 = interleave(s1,s2,s3,i+1,j,k+1,dp); //choose from string s1\\n            bool op1 = interleave(s1,s2,s3,i,j+1,k+1,dp);  //choose from string s2;\\n            \\n            return dp[i][j] = op1||op2;\\n        }else if(s3[k]==s2[j]){\\n            return dp[i][j] = interleave(s1,s2,s3,i,j+1,k+1,dp); // choose from string s2;\\n        }else if(s3[k]==s1[i]){\\n            return dp[i][j] = interleave(s1,s2,s3,i+1,j,k+1,dp); // choose from string s1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246872,
                "title": "interleaving-string-100-fast-dp-solution",
                "content": "```\\n\\n\\nbool isInterleave(char * s1, char * s2, char * s3){\\n    int m = strlen(s1);\\n    int n = strlen(s2);\\n    int l = strlen(s3);\\n    if ((m + n) != l)\\n        return false;\\n    int dp[m+1][n+1];\\n    for(int i = 0;i <= m;i += 1) {\\n        for(int j = 0;j <= n;j += 1) {\\n            if (i == 0 && j == 0)\\n                dp[i][j] = 1;\\n            else if(i == 0)\\n                dp[i][j] = dp[i][j-1] && s2[j-1] == s3[j-1];\\n            else if(j == 0)\\n                dp[i][j] = dp[i-1][j] && s1[i-1] == s3[i-1];\\n            else\\n                dp[i][j] = (dp[i][j-1] && s2[j-1] == s3[i+j-1]) || (dp[i-1][j] && s1[i-1] == s3[i+j-1]);\\n        }\\n    }\\n    return dp[m][n];\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n\\nbool isInterleave(char * s1, char * s2, char * s3){\\n    int m = strlen(s1);\\n    int n = strlen(s2);\\n    int l = strlen(s3);\\n    if ((m + n) != l)\\n        return false;\\n    int dp[m+1][n+1];\\n    for(int i = 0;i <= m;i += 1) {\\n        for(int j = 0;j <= n;j += 1) {\\n            if (i == 0 && j == 0)\\n                dp[i][j] = 1;\\n            else if(i == 0)\\n                dp[i][j] = dp[i][j-1] && s2[j-1] == s3[j-1];\\n            else if(j == 0)\\n                dp[i][j] = dp[i-1][j] && s1[i-1] == s3[i-1];\\n            else\\n                dp[i][j] = (dp[i][j-1] && s2[j-1] == s3[i+j-1]) || (dp[i-1][j] && s1[i-1] == s3[i+j-1]);\\n        }\\n    }\\n    return dp[m][n];\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1127736,
                "title": "javascript-simple-top-down-dp",
                "content": "Time: `O(N*M)`\\nSpace: `O(N*M)`\\n```javascript\\nvar isInterleave = function(s1, s2, s3) {\\n    if(s1.length + s2.length !== s3.length) return false;\\n    const memo = new Map()\\n    \\n    function run(i1, i2, i3) {\\n        if(i1 === s1.length) return s3.slice(i3) === s2.slice(i2);\\n        if(i2 === s2.length) return s3.slice(i3) === s1.slice(i1);\\n        const key = `${i1}-${i2}`;\\n        if(memo.has(key)) return memo.get(key)\\n        \\n        let res = false;\\n        \\n        if(s1[i1] === s2[i2] && s1[i1] === s3[i3]) res = run(i1+1, i2, i3+1) || run(i1, i2+1, i3+1);\\n        else if(s1[i1] === s3[i3]) res = run(i1+1, i2, i3+1);\\n        else if(s2[i2] === s3[i3]) res = run(i1, i2+1, i3+1);\\n        \\n        memo.set(key, res);\\n        return res;\\n    }\\n    return run(0, 0, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar isInterleave = function(s1, s2, s3) {\\n    if(s1.length + s2.length !== s3.length) return false;\\n    const memo = new Map()\\n    \\n    function run(i1, i2, i3) {\\n        if(i1 === s1.length) return s3.slice(i3) === s2.slice(i2);\\n        if(i2 === s2.length) return s3.slice(i3) === s1.slice(i1);\\n        const key = `${i1}-${i2}`;\\n        if(memo.has(key)) return memo.get(key)\\n        \\n        let res = false;\\n        \\n        if(s1[i1] === s2[i2] && s1[i1] === s3[i3]) res = run(i1+1, i2, i3+1) || run(i1, i2+1, i3+1);\\n        else if(s1[i1] === s3[i3]) res = run(i1+1, i2, i3+1);\\n        else if(s2[i2] === s3[i3]) res = run(i1, i2+1, i3+1);\\n        \\n        memo.set(key, res);\\n        return res;\\n    }\\n    return run(0, 0, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 188575,
                "title": "extremely-easy-to-understand-java-dp-solution-with-detailed-explanations",
                "content": "  Hi! This is a quite straightforward solution using dp array. I can\\'t say this is runing with the lowest time complexity, but it\\'s really really really easy to understand!\\n\\tI introduced a array called ```boolean data[a + 1][b + 1]```, here a, b stand for the length of s1, s2. \\n  Each element in ```data``` like ```data[i + 1][j + 1]``` means if ```s3.substring(0, k + 1)``` could be formed by interleaving of ```s1.substring(0, i + 1)``` and ```s2.substring(0, j + 1)```, here ```k = i + j + 1``` in which the length of the substring of s1 + s2 equals to s3.\\n\\tThen there is the main idea of how this dp solution works:\\n\\t```Situation 1:```\\n\\t```if s3.charAt(k) == s1.charAt(i), so data[i + 1][j + 1] |= data[i][j + 1]```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t```(the default data[i + 1][j + 1] is false)``` \\n\\tAnd\\n\\t```if s3.charAt(k) == s2.charAt(j), so data[i + 1][j + 1] |= data[i + 1][j]```\\n\\t```Situation 2:```\\n\\t```s3.charAt(k) != s1.charAt(i) && s3.charAt(k) != s2.charAt(j)``` doesn\\'t match! Just leave ```data[i + 1][j + 1]``` false.\\n\\t\\tBase case: \\n\\t\\t```1. data[0][0] = true``` since empty s1, s2 match empty s3.\\n\\t\\t```2. if(s1.charAt(i) == s3.charAt(i)) data[i + 1][0] = true ``` since s3 could be form by s1 without s2.\\n\\t\\t```3. if(s2.charAt(j) == s3.charAt(j)) data[0][j + 1] = true ``` reason is same as ```2.```\\n\\t\\tTime Complexity <strong>O(ab)</strong> btw.\\n\\t\\tAnd the code is shown below:\\n\\t\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int a = s1.length(), b = s2.length(), c = s3.length();\\n        if(a + b != c) return false;\\n        boolean[][] data = new boolean[a + 1][b + 1];\\n        data[0][0] = true;\\n        for(int i = 0; i < a && s1.charAt(i) == s3.charAt(i); i++) data[i + 1][0] = true;\\n        for(int i = 0; i < b && s2.charAt(i) == s3.charAt(i); i++) data[0][i + 1] = true;\\n        for(int i = 0; i < a; i++) {\\n            for(int j = 0; j < b; j++) {\\n                int k = i + j + 1;\\n                if(s3.charAt(k) == s1.charAt(i)) \\n                    data[i + 1][j + 1] |= data[i][j + 1];\\n                if(s3.charAt(k) == s2.charAt(j)) \\n                    data[i + 1][j + 1] |= data[i + 1][j];\\n            }\\n        }\\n        return data[a][b];\\n    }\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```boolean data[a + 1][b + 1]```\n```data```\n```data[i + 1][j + 1]```\n```s3.substring(0, k + 1)```\n```s1.substring(0, i + 1)```\n```s2.substring(0, j + 1)```\n```k = i + j + 1```\n```Situation 1:```\n```if s3.charAt(k) == s1.charAt(i), so data[i + 1][j + 1] |= data[i][j + 1]```\n```(the default data[i + 1][j + 1] is false)```\n```if s3.charAt(k) == s2.charAt(j), so data[i + 1][j + 1] |= data[i + 1][j]```\n```Situation 2:```\n```s3.charAt(k) != s1.charAt(i) && s3.charAt(k) != s2.charAt(j)```\n```data[i + 1][j + 1]```\n```1. data[0][0] = true```\n```2. if(s1.charAt(i) == s3.charAt(i)) data[i + 1][0] = true ```\n```3. if(s2.charAt(j) == s3.charAt(j)) data[0][j + 1] = true ```\n```2.```",
                "codeTag": "Unknown"
            },
            {
                "id": 31918,
                "title": "9-lines-dp-js-o-s1-len-s2-len",
                "content": "```\\nvar isInterleave = function(s1, s2, s3) {\\n    // dp[i][j] <=> if s1.substr(0, i) interleaving s2.substr(0, j) generates s3.substr(0, i+j)\\n    var dp= Array(s1.length+1).fill().map(r=>[])  \\n\\n    if (s1.length+s2.length!=s3.length) // quit ealier if possible\\n        return false\\n\\n    for (var i =0;i<= s1.length;i++)\\n        for (var j=0;j<= s2.length;j++)\\n            dp[i][j] = i && dp[i-1][j] && s3[i+j-1] == s1[i-1]    \\n                    || j && dp[i][j-1] && s3[i+j-1] == s2[j-1]\\n                    || !i&&!j   // set dp[0][0] to true\\n\\n    \\n    return !!dp.pop().pop();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar isInterleave = function(s1, s2, s3) {\\n    // dp[i][j] <=> if s1.substr(0, i) interleaving s2.substr(0, j) generates s3.substr(0, i+j)\\n    var dp= Array(s1.length+1).fill().map(r=>[])  \\n\\n    if (s1.length+s2.length!=s3.length) // quit ealier if possible\\n        return false\\n\\n    for (var i =0;i<= s1.length;i++)\\n        for (var j=0;j<= s2.length;j++)\\n            dp[i][j] = i && dp[i-1][j] && s3[i+j-1] == s1[i-1]    \\n                    || j && dp[i][j-1] && s3[i+j-1] == s2[j-1]\\n                    || !i&&!j   // set dp[0][0] to true\\n\\n    \\n    return !!dp.pop().pop();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31974,
                "title": "java-first-got-an-idea-about-3d-dp-and-then-realized-that-i-can-change-it-to-2d-dp",
                "content": "**3D dp 46 ms:**\\n\\n        int n = s1.length();\\n        int m = s2.length();\\n        int l = s3.length();\\n        \\n        boolean[][][] dp = new boolean[l+1][n+1][m+1];\\n        \\n        for (int i = 0; i <= n; i++)\\n        {\\n        \\tfor (int j = 0; j <= m; j++)\\n        \\t\\tdp[0][i][j] = false;\\n        }\\n        \\n        dp[0][0][0] = true;\\n        \\n        for (int k = 1; k <= l; k++)\\n        {\\n        \\tfor (int i = 0; i <= n; i++)\\n        \\t{\\n        \\t\\tfor (int j = 0; j <= m; j++)\\n        \\t\\t{\\n        \\t\\t\\tdp[k][i][j] = (i+j == k)&&\\n        \\t\\t\\t\\t\\t((i >= 1 && dp[k-1][i-1][j] && s1.charAt(i-1) == s3.charAt(k-1)) \\n        \\t\\t\\t\\t\\t|| (j >= 1 && dp[k-1][i][j-1] && s2.charAt(j-1) == s3.charAt(k-1))); \\n        \\t\\t}\\n        \\t}\\n        }\\n        \\n        return dp[l][n][m];\\n  \\n**2D dp 6ms (shrink from above solution):**\\n\\n        int n = s1.length();\\n        int m = s2.length();\\n        \\n        boolean[][] dp = new boolean[n+1][m+1];\\n                \\n        dp[0][0] = true;\\n        \\n        for (int i = 0; i <= n; i++)\\n    \\t{\\n    \\t\\tfor (int j = 0; j <= m; j++)\\n    \\t\\t{\\n    \\t\\t\\tif (i == j && i == 0)\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\n    \\t\\t\\tint k = i+j;\\n    \\t\\t\\tdp[i][j] = (i >= 1 && dp[i-1][j] && s1.charAt(i-1) == s3.charAt(k-1))\\n    \\t\\t\\t\\t\\t|| (j >= 1 && dp[i][j-1] && s2.charAt(j-1) == s3.charAt(k-1));\\n    \\t\\t}\\n    \\t}\\n                \\n        return dp[n][m];",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "**3D dp 46 ms:**\\n\\n        int n = s1.length();\\n        int m = s2.length();\\n        int l = s3.length();\\n        \\n        boolean[][][] dp = new boolean[l+1][n+1][m+1];\\n        \\n        for (int i = 0; i <= n; i++)\\n        {\\n        \\tfor (int j = 0; j <= m; j++)\\n        \\t\\tdp[0][i][j] = false;\\n        }\\n        \\n        dp[0][0][0] = true;\\n        \\n        for (int k = 1; k <= l; k++)\\n        {\\n        \\tfor (int i = 0; i <= n; i++)\\n        \\t{\\n        \\t\\tfor (int j = 0; j <= m; j++)\\n        \\t\\t{\\n        \\t\\t\\tdp[k][i][j] = (i+j == k)&&\\n        \\t\\t\\t\\t\\t((i >= 1 && dp[k-1][i-1][j] && s1.charAt(i-1) == s3.charAt(k-1)) \\n        \\t\\t\\t\\t\\t|| (j >= 1 && dp[k-1][i][j-1] && s2.charAt(j-1) == s3.charAt(k-1))); \\n        \\t\\t}\\n        \\t}\\n        }\\n        \\n        return dp[l][n][m];\\n  \\n**2D dp 6ms (shrink from above solution):**\\n\\n        int n = s1.length();\\n        int m = s2.length();\\n        \\n        boolean[][] dp = new boolean[n+1][m+1];\\n                \\n        dp[0][0] = true;\\n        \\n        for (int i = 0; i <= n; i++)\\n    \\t{\\n    \\t\\tfor (int j = 0; j <= m; j++)\\n    \\t\\t{\\n    \\t\\t\\tif (i == j && i == 0)\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\n    \\t\\t\\tint k = i+j;\\n    \\t\\t\\tdp[i][j] = (i >= 1 && dp[i-1][j] && s1.charAt(i-1) == s3.charAt(k-1))\\n    \\t\\t\\t\\t\\t|| (j >= 1 && dp[i][j-1] && s2.charAt(j-1) == s3.charAt(k-1));\\n    \\t\\t}\\n    \\t}\\n                \\n        return dp[n][m];",
                "codeTag": "Unknown"
            },
            {
                "id": 32001,
                "title": "how-to-from-error-to-ac-thoughts-and-extensions-with-c-implementation",
                "content": "At the first glance, it seems a bit hard for me. So I want to try the tail DP.\\n\\nI set the dp[i][j] means\\n\\n         dp[i][j] = true  if s3[0...i+j-1] is the interleaving-string of  s1[0...i-1]  and  s2[0...j-1]  \\n\\nSo, we need to check the tail element .\\n\\nIt is not hard for me to think of  the equation  like this:\\n\\n        dp[i][j] = s3[i+j-1]==s1[i-1] && dp[i-1][j]\\n                           ||   s3[i+j-1]==s2[j-1] && dp[i][j-1]\\n\\nBefore seeing the AC code, I have to mention I make 2 mistakes before AC.\\n\\n**One is my code can not deal with if s1 or s2 is NULL\\nIt is important to first deal with the corner cases first.**\\n\\n\\n**Second is that when I do the initialization, I mis-type some code....**\\n\\nHere is the code.\\n\\n    class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int len1=s1.size(), len2=s2.size(), len3=s3.size();\\n            if(len1+len2!=len3)  return false;\\n            if(len1==0) return s2==s3;\\n            if(len2==0) return s1==s3;\\n            vector<vector<bool>> dp(len1+1, vector<bool>(len2+1, false));\\n            dp[0][0]=true;\\n            for(int i=1; i<=len1; i++) dp[i][0]=s1[i-1]==s3[i-1] && dp[i-1][0];\\n            for(int i=1; i<=len2; i++) dp[0][i]=s2[i-1]==s3[i-1] && dp[0][i-1];\\n            \\n            for(int i=1; i<=len1; i++){\\n                for(int j=1; j<=len2; j++){\\n                    dp[i][j] = (s3[i+j-1]==s1[i-1] && dp[i-1][j]) ||\\n                                  (s3[i+j-1]==s2[j-1] && dp[i][j-1]);\\n                }\\n            }\\n            return dp[len1][len2];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int len1=s1.size(), len2=s2.size(), len3=s3.size();\\n            if(len1+len2!=len3)  return false;\\n            if(len1==0) return s2==s3;\\n            if(len2==0) return s1==s3;\\n            vector<vector<bool>> dp(len1+1, vector<bool>(len2+1, false));\\n            dp[0][0]=true;\\n            for(int i=1; i<=len1; i++) dp[i][0]=s1[i-1]==s3[i-1] && dp[i-1][0];\\n            for(int i=1; i<=len2; i++) dp[0][i]=s2[i-1]==s3[i-1] && dp[0][i-1];\\n            \\n            for(int i=1; i<=len1; i++){\\n                for(int j=1; j<=len2; j++){\\n                    dp[i][j] = (s3[i+j-1]==s1[i-1] && dp[i-1][j]) ||\\n                                  (s3[i+j-1]==s2[j-1] && dp[i][j-1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3963313,
                "title": "python3-dp-top-down-bottom-up-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. Top-Down\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3): return False\\n        \\n        @cache\\n        def dp(i: int, j: int) -> bool:\\n            if i < 0 and j < 0: return True\\n            ans = False\\n            if i >= 0 and s1[i] == s3[i + j + 1]: ans |= dp(i - 1, j)\\n            if j >= 0 and s2[j] == s3[i + j + 1]: ans |= dp(i, j - 1)\\n            return ans\\n\\n        return dp(m - 1, n - 1)\\n```\\n- TC: $$O(N^2)$$\\n- SC: $$O(N^2)$$\\n\\n2. Bottom-Up\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3): return False\\n\\n        dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for i in range(-1, m):\\n            for j in range(-1, n):\\n                if i >= 0 and s1[i] == s3[i + j + 1]: dp[i + 1][j + 1] |= dp[i][j + 1]\\n                if j >= 0 and s2[j] == s3[i + j + 1]: dp[i + 1][j + 1] |= dp[i + 1][j]\\n        return dp[m][n]\\n```\\n- TC: $$O(N^2)$$\\n- SC: $$O(N^2)$$\\n",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3): return False\\n        \\n        @cache\\n        def dp(i: int, j: int) -> bool:\\n            if i < 0 and j < 0: return True\\n            ans = False\\n            if i >= 0 and s1[i] == s3[i + j + 1]: ans |= dp(i - 1, j)\\n            if j >= 0 and s2[j] == s3[i + j + 1]: ans |= dp(i, j - 1)\\n            return ans\\n\\n        return dp(m - 1, n - 1)\\n```\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3): return False\\n\\n        dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for i in range(-1, m):\\n            for j in range(-1, n):\\n                if i >= 0 and s1[i] == s3[i + j + 1]: dp[i + 1][j + 1] |= dp[i][j + 1]\\n                if j >= 0 and s2[j] == s3[i + j + 1]: dp[i + 1][j + 1] |= dp[i + 1][j]\\n        return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959849,
                "title": "recursion-to-space-optimization-dp-c-with-explanation",
                "content": "# Intuition\\nWe try to interleave `s1` & `s2` in every possible way that can form string `s3`. We can use recursion to explore all possible ways & find if there exist an answer for any possibility.\\n\\n# Recursion\\nLet\\'s define a recursive boolean function `canInterleave`. where, `canInterleave(k, i, j)` tells us that is it possible to interleave `s1[i...end]` & `s2[j...end]` to form `s3[k...end]`.\\nTherefore our answer will be `canInterleave(0, 0, 0)`.\\n\\n## Code\\n```\\nclass Solution {\\n    bool canInterleave(int k, int i, int j, string& s1, string& s2, string& s3) {\\n        \\n        // All indices reached the end then interleaving is possible\\n        if(i == s1.length() && j == s2.length() && k == s3.length())\\n            return true;\\n\\n        // Intially considering that interleaving is not possible\\n        bool res = false;\\n\\n        // Check if we can match s1[i] to s3[k]\\n        // and if we can, can we get answer by matching them\\n        if(i < s1.length() && s1[i] == s3[k])\\n            res |= canInterleave(k + 1, i + 1, j, s1, s2, s3);\\n\\n        // Check if we can match s2[j] to s3[k]\\n        // and if we can, can we get answer by matching them\\n        if(j < s2.length() && s2[j] == s3[k])\\n            res |= canInterleave(k + 1, i, j + 1, s1, s2, s3);\\n\\n        return res;\\n    }\\n\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        return canInterleave(0, 0, 0, s1, s2, s3);\\n    }\\n};\\n```\\n\\n## Complexity\\n- Time complexity:\\n$$O(2^{len3})$$, where `len3` is length of string`s3`.\\nBecause at a hypothetical situation, we\\'ll have 2 possibilities for every character in `s3` that either match it with character in `s1` or in `s2`.\\n\\n- Space complexity:\\n$$O(len3)$$, Because the recursion depth will be at most `len3` & every function call will have its constant space.\\n\\n# Memoization\\nAbove solution will not work because of it\\'s exponential nature. but we can optimize by memoizing it as there will be overlapping subproblems which we evaluate again & again unnecessarily.\\n\\n## Code\\n```\\nclass Solution {\\n    bool canInterleave(int k, int i, int j, string& s1, string& s2, string& s3, vector<vector<vector<int>>>& dp) {\\n        \\n        // All indices reached the end then interleaving is possible\\n        if(i == s1.length() && j == s2.length() && k == s3.length())\\n            return true;\\n\\n        if(dp[k][i][j] != -1)\\n            return dp[k][i][j];\\n\\n        // Intially considering that interleaving is not possible\\n        bool res = false;\\n\\n        // Check if we can match s1[i] to s3[k]\\n        // and if we can, can we get answer by matching them\\n        if(i < s1.length() && s1[i] == s3[k])\\n            res |= canInterleave(k + 1, i + 1, j, s1, s2, s3, dp);\\n\\n        // Check if we can match s2[j] to s3[k]\\n        // and if we can, can we get answer by matching them\\n        if(j < s2.length() && s2[j] == s3[k])\\n            res |= canInterleave(k + 1, i, j + 1, s1, s2, s3, dp);\\n\\n        return dp[k][i][j] = res;\\n    }\\n\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        vector dp(len3 + 1, vector<vector<int>>(len1 + 1, vector<int>(len2 + 1, -1)));\\n        return canInterleave(0, 0, 0, s1, s2, s3, dp);\\n    }\\n};\\n```\\n\\n## Complexity\\n- Time complexity:\\n$$O(len1*len2*len3)$$, Because there are `len1*len2*len3` dp states to evaluate.\\n\\n- Space complexity:\\n$$O(len3) + O(len1*len2*len3)$$, For recursion stack space & dp array respectively.\\n\\n# Tabulation\\nWe can eliminate recursion stack space from previous solution by using a bottom up tabulation solution as follows\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        vector dp(len3 + 1, vector<vector<int>>(len1 + 1, vector<int>(len2 + 1, false)));\\n\\n        dp[len3][len1][len2] = true;\\n\\n        for(int k = len3 - 1; k >= 0; k--) {\\n            for(int i = len1; i >= 0; i--) {\\n                for(int j = len2; j >= 0; j--) {\\n                    bool res = false;\\n                    if(i < len1 && s1[i] == s3[k])\\n                        res |= dp[k + 1][i + 1][j];\\n\\n                    if(j < len2 && s2[j] == s3[k])\\n                        res |= dp[k + 1][i][j + 1];\\n\\n                    dp[k][i][j] = res;\\n                }\\n            }\\n        }\\n\\n        return dp[0][0][0];\\n    }\\n};\\n```\\n\\n## Complexity\\n- Time complexity:\\n$$O(len1*len2*len3)$$, Because there are `len1*len2*len3` dp states to evaluate.\\n\\n- Space complexity:\\n$$O(len1*len2*len3)$$, For dp array.\\n\\n# Space Optimization\\nTo calculate dp states for any index `k` we do not need all the previously calculated states we just need dp states for index `k+1`. We can use this to eliminate the 3D dp array with just 2 2D dp arrays.\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        vector curdp(len1 + 1, vector<bool>(len2 + 1, false));\\n        vector nextdp(len1 + 1, vector<bool>(len2 + 1, false));\\n\\n        nextdp[len1][len2] = true;\\n\\n        for(int k = len3 - 1; k >= 0; k--) {\\n            for(int i = len1; i >= 0; i--) {\\n                for(int j = len2; j >= 0; j--) {\\n                    bool res = false;\\n                    if(i < len1 && s1[i] == s3[k])\\n                        res |= nextdp[i + 1][j];\\n\\n                    if(j < len2 && s2[j] == s3[k])\\n                        res |= nextdp[i][j + 1];\\n\\n                    curdp[i][j] = res;\\n                }\\n            }\\n            nextdp = curdp;\\n        }\\n\\n        return nextdp[0][0];\\n    }\\n};\\n```\\n\\n## Complexity\\n- Time complexity:\\n$$O(len1*len2*len3)$$, Because there are `len1*len2*len3` dp states to evaluate.\\n\\n- Space complexity:\\n$$O(len1*len2)$$, For dp array.\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    bool canInterleave(int k, int i, int j, string& s1, string& s2, string& s3) {\\n        \\n        // All indices reached the end then interleaving is possible\\n        if(i == s1.length() && j == s2.length() && k == s3.length())\\n            return true;\\n\\n        // Intially considering that interleaving is not possible\\n        bool res = false;\\n\\n        // Check if we can match s1[i] to s3[k]\\n        // and if we can, can we get answer by matching them\\n        if(i < s1.length() && s1[i] == s3[k])\\n            res |= canInterleave(k + 1, i + 1, j, s1, s2, s3);\\n\\n        // Check if we can match s2[j] to s3[k]\\n        // and if we can, can we get answer by matching them\\n        if(j < s2.length() && s2[j] == s3[k])\\n            res |= canInterleave(k + 1, i, j + 1, s1, s2, s3);\\n\\n        return res;\\n    }\\n\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        return canInterleave(0, 0, 0, s1, s2, s3);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    bool canInterleave(int k, int i, int j, string& s1, string& s2, string& s3, vector<vector<vector<int>>>& dp) {\\n        \\n        // All indices reached the end then interleaving is possible\\n        if(i == s1.length() && j == s2.length() && k == s3.length())\\n            return true;\\n\\n        if(dp[k][i][j] != -1)\\n            return dp[k][i][j];\\n\\n        // Intially considering that interleaving is not possible\\n        bool res = false;\\n\\n        // Check if we can match s1[i] to s3[k]\\n        // and if we can, can we get answer by matching them\\n        if(i < s1.length() && s1[i] == s3[k])\\n            res |= canInterleave(k + 1, i + 1, j, s1, s2, s3, dp);\\n\\n        // Check if we can match s2[j] to s3[k]\\n        // and if we can, can we get answer by matching them\\n        if(j < s2.length() && s2[j] == s3[k])\\n            res |= canInterleave(k + 1, i, j + 1, s1, s2, s3, dp);\\n\\n        return dp[k][i][j] = res;\\n    }\\n\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        vector dp(len3 + 1, vector<vector<int>>(len1 + 1, vector<int>(len2 + 1, -1)));\\n        return canInterleave(0, 0, 0, s1, s2, s3, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        vector dp(len3 + 1, vector<vector<int>>(len1 + 1, vector<int>(len2 + 1, false)));\\n\\n        dp[len3][len1][len2] = true;\\n\\n        for(int k = len3 - 1; k >= 0; k--) {\\n            for(int i = len1; i >= 0; i--) {\\n                for(int j = len2; j >= 0; j--) {\\n                    bool res = false;\\n                    if(i < len1 && s1[i] == s3[k])\\n                        res |= dp[k + 1][i + 1][j];\\n\\n                    if(j < len2 && s2[j] == s3[k])\\n                        res |= dp[k + 1][i][j + 1];\\n\\n                    dp[k][i][j] = res;\\n                }\\n            }\\n        }\\n\\n        return dp[0][0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        vector curdp(len1 + 1, vector<bool>(len2 + 1, false));\\n        vector nextdp(len1 + 1, vector<bool>(len2 + 1, false));\\n\\n        nextdp[len1][len2] = true;\\n\\n        for(int k = len3 - 1; k >= 0; k--) {\\n            for(int i = len1; i >= 0; i--) {\\n                for(int j = len2; j >= 0; j--) {\\n                    bool res = false;\\n                    if(i < len1 && s1[i] == s3[k])\\n                        res |= nextdp[i + 1][j];\\n\\n                    if(j < len2 && s2[j] == s3[k])\\n                        res |= nextdp[i][j + 1];\\n\\n                    curdp[i][j] = res;\\n                }\\n            }\\n            nextdp = curdp;\\n        }\\n\\n        return nextdp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957308,
                "title": "easy-video-explanation-recursive-memoization-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUses Dynamic Progrmming to solve the problem\\n\\n***I\\'ve created a video that breaks down this problem with a thorough explanation, ensuring everyone can easily grasp the concept***\\n\\nhttps://youtu.be/UJVvaO_TuX4\\n\\n# Approach\\nThe code checks if string s3 can be formed by interleaving characters from s1 and s2 while maintaining order. It uses dynamic programming with memoization to efficiently solve.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(x * y)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(x * y)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    bool solve(int x,int y,int z,string &s1,string &s2,string &s3)\\n    {   \\n        if(x==0 && y==0 && z==0)\\n            return true;\\n        if(dp[x][y]!=-1)\\n            return dp[x][y];\\n        bool a=false,b=false;\\n        if(x-1>=0 && z-1>=0 && s1[x-1]==s3[z-1])\\n            a=solve(x-1,y,z-1,s1,s2,s3);\\n        if(y-1>=0 && z-1>=0 && s2[y-1]==s3[z-1])\\n            b=solve(x,y-1,z-1,s1,s2,s3);\\n        return dp[x][y]=a||b;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int x=s1.size();\\n        int y=s2.size();\\n        int z=s3.size();\\n        memset(dp,-1,sizeof(dp));\\n        bool ans=solve(x,y,z,s1,s2,s3);\\n        return ans;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def solve(self, x, y, z, s1, s2, s3, dp):\\n        if x == 0 and y == 0 and z == 0:\\n            return True\\n        if dp[x][y] != -1:\\n            return dp[x][y]\\n        a, b = False, False\\n        if x - 1 >= 0 and z - 1 >= 0 and s1[x - 1] == s3[z - 1]:\\n            a = self.solve(x - 1, y, z - 1, s1, s2, s3, dp)\\n        if y - 1 >= 0 and z - 1 >= 0 and s2[y - 1] == s3[z - 1]:\\n            b = self.solve(x, y - 1, z - 1, s1, s2, s3, dp)\\n        dp[x][y] = a or b\\n        return dp[x][y]\\n\\n    def isInterleave(self, s1, s2, s3):\\n        x, y, z = len(s1), len(s2), len(s3)\\n        dp = [[-1] * (y + 1) for _ in range(x + 1)]\\n        return self.solve(x, y, z, s1, s2, s3, dp)\\n\\n```\\n```java []\\npublic class Solution {\\n    private int[][] dp;\\n\\n    public boolean solve(int x, int y, int z, String s1, String s2, String s3) {\\n        if (x == 0 && y == 0 && z == 0)\\n            return true;\\n        if (dp[x][y] != -1)\\n            return dp[x][y];\\n        boolean a = false, b = false;\\n        if (x - 1 >= 0 && z - 1 >= 0 && s1.charAt(x - 1) == s3.charAt(z - 1))\\n            a = solve(x - 1, y, z - 1, s1, s2, s3);\\n        if (y - 1 >= 0 && z - 1 >= 0 && s2.charAt(y - 1) == s3.charAt(z - 1))\\n            b = solve(x, y - 1, z - 1, s1, s2, s3);\\n        return dp[x][y] = a || b;\\n    }\\n\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int x = s1.length();\\n        int y = s2.length();\\n        int z = s3.length();\\n        dp = new int[x + 1][y + 1];\\n        for (int i = 0; i <= x; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return solve(x, y, z, s1, s2, s3);\\n    }\\n}\\n```\\n\\n\\n***If the solution resonates with you, I\\'d really appreciate an upvote. Feel free to hit the like button and consider subscribing to my channel, where I\\'ll be sharing more LeetCode challenges.***\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    bool solve(int x,int y,int z,string &s1,string &s2,string &s3)\\n    {   \\n        if(x==0 && y==0 && z==0)\\n            return true;\\n        if(dp[x][y]!=-1)\\n            return dp[x][y];\\n        bool a=false,b=false;\\n        if(x-1>=0 && z-1>=0 && s1[x-1]==s3[z-1])\\n            a=solve(x-1,y,z-1,s1,s2,s3);\\n        if(y-1>=0 && z-1>=0 && s2[y-1]==s3[z-1])\\n            b=solve(x,y-1,z-1,s1,s2,s3);\\n        return dp[x][y]=a||b;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int x=s1.size();\\n        int y=s2.size();\\n        int z=s3.size();\\n        memset(dp,-1,sizeof(dp));\\n        bool ans=solve(x,y,z,s1,s2,s3);\\n        return ans;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def solve(self, x, y, z, s1, s2, s3, dp):\\n        if x == 0 and y == 0 and z == 0:\\n            return True\\n        if dp[x][y] != -1:\\n            return dp[x][y]\\n        a, b = False, False\\n        if x - 1 >= 0 and z - 1 >= 0 and s1[x - 1] == s3[z - 1]:\\n            a = self.solve(x - 1, y, z - 1, s1, s2, s3, dp)\\n        if y - 1 >= 0 and z - 1 >= 0 and s2[y - 1] == s3[z - 1]:\\n            b = self.solve(x, y - 1, z - 1, s1, s2, s3, dp)\\n        dp[x][y] = a or b\\n        return dp[x][y]\\n\\n    def isInterleave(self, s1, s2, s3):\\n        x, y, z = len(s1), len(s2), len(s3)\\n        dp = [[-1] * (y + 1) for _ in range(x + 1)]\\n        return self.solve(x, y, z, s1, s2, s3, dp)\\n\\n```\n```java []\\npublic class Solution {\\n    private int[][] dp;\\n\\n    public boolean solve(int x, int y, int z, String s1, String s2, String s3) {\\n        if (x == 0 && y == 0 && z == 0)\\n            return true;\\n        if (dp[x][y] != -1)\\n            return dp[x][y];\\n        boolean a = false, b = false;\\n        if (x - 1 >= 0 && z - 1 >= 0 && s1.charAt(x - 1) == s3.charAt(z - 1))\\n            a = solve(x - 1, y, z - 1, s1, s2, s3);\\n        if (y - 1 >= 0 && z - 1 >= 0 && s2.charAt(y - 1) == s3.charAt(z - 1))\\n            b = solve(x, y - 1, z - 1, s1, s2, s3);\\n        return dp[x][y] = a || b;\\n    }\\n\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int x = s1.length();\\n        int y = s2.length();\\n        int z = s3.length();\\n        dp = new int[x + 1][y + 1];\\n        for (int i = 0; i <= x; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return solve(x, y, z, s1, s2, s3);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956632,
                "title": "c-solution-for-interleaving-strings-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks whether a string s3 can be formed by interleaving two strings s1 and s2. Interleaving means that the characters of s1 and s2 maintain their relative order while forming s3. To solve this problem efficiently, dynamic programming is used to build a table that stores whether the current substrings of s1 and s2 can form the corresponding substring of s3.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe dynamic programming approach involves using a 2D boolean array dp, where dp[i, j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i + j characters of s3.\\n\\n1. Base case: Initialize dp[0, 0] as true, since empty strings can be interleaved to form an empty string.\\n1. Fill in the base cases for when one of the strings (s1 or s2) is empty.\\n1. For each remaining cell dp[i, j], consider whether the current character of s1 or s2 can be matched with the next character of s3. If yes, then check the previous states (dp[i-1, j] and dp[i, j-1]) to determine if the current interleaving is possible.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(len1 * len2), where len1 is the length of string s1 and len2 is the length of string s2. This is because the 2D dp array has dimensions len1 + 1 and len2 + 1, and each cell is filled once based on the previous cells.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(len1 * len2), as the 2D array dp of size (len1 + 1) x (len2 + 1) is used to store the intermediate results.\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.Length, len2 = s2.Length, len3 = s3.Length;\\n        \\n        if (len1 + len2 != len3) {\\n            return false;\\n        }\\n        \\n        bool[,] dp = new bool[len1 + 1, len2 + 1];\\n        \\n        for (int i = 0; i <= len1; i++) {\\n            for (int j = 0; j <= len2; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[i, j] = true;\\n                } else if (i == 0) {\\n                    dp[i, j] = dp[i, j - 1] && s2[j - 1] == s3[i + j - 1];\\n                } else if (j == 0) {\\n                    dp[i, j] = dp[i - 1, j] && s1[i - 1] == s3[i + j - 1];\\n                } else {\\n                    dp[i, j] = (dp[i - 1, j] && s1[i - 1] == s3[i + j - 1]) ||\\n                               (dp[i, j - 1] && s2[j - 1] == s3[i + j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[len1, len2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.Length, len2 = s2.Length, len3 = s3.Length;\\n        \\n        if (len1 + len2 != len3) {\\n            return false;\\n        }\\n        \\n        bool[,] dp = new bool[len1 + 1, len2 + 1];\\n        \\n        for (int i = 0; i <= len1; i++) {\\n            for (int j = 0; j <= len2; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[i, j] = true;\\n                } else if (i == 0) {\\n                    dp[i, j] = dp[i, j - 1] && s2[j - 1] == s3[i + j - 1];\\n                } else if (j == 0) {\\n                    dp[i, j] = dp[i - 1, j] && s1[i - 1] == s3[i + j - 1];\\n                } else {\\n                    dp[i, j] = (dp[i - 1, j] && s1[i - 1] == s3[i + j - 1]) ||\\n                               (dp[i, j - 1] && s2[j - 1] == s3[i + j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[len1, len2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956471,
                "title": "easy-to-understand-memoization-approach-c-with-proper-explanation-of-each-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach involves breaking down the problem into smaller subproblems, and checking different possibilities.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- There are basically three iterators: i, j, k where i keeps track of s1 string, j and k keeps track of string s2 and s3 respectively.\\n### - **Base Cases**\\n  a.) if iterator k reaches the end of target string i.e., s3 return true as entire string is traversed\\n  b.) if s1 is finished and current character of s2 doesn\\'t matches with s3\\'s current character, then return false as there is no character left that can match with current character of s3\\n  c.) Similarly if s2 ends and current s1[i] doesn\\'t matches with s3[k], return false.\\n d.) If neither s1[i] nor s2[j] matches with s3[k], return false\\n\\n### **- Recursions**\\n a.) If character at ith position of matches with s3[k] ans s2[j] does not match then, move the iterator i and k.\\n b.) If character at jth position of matches with s3[k] ans s1[i] does not match then, move the iterator j and k.\\n c.) If both s1[i] and s2[j] match with s3[k], then we will have two options---- \\nI. take ith element of s1\\nII. take jth element of s2\\nWe will exploit both the possibilities and return true if any of the two cases return true.\\n             \\n\\n\\n# Complexity\\n- Time complexity:\\nO(s1.length() * s2.length())\\n\\n- Space complexity:\\nO(s1.length() * s2.length())\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int i, int j, int k, string s1, string s2, string s3, vector<vector<int>>&dp)\\n    {\\n        if(k==s3.length()) //base case - a - if s3 is completely traversed\\n            return true;\\n        if(dp[i][j]!=-1) // searching in dp table\\n            return dp[i][j];\\n        /* base case - b - if s1 is finished and current \\n        character of s2 doesn\\'t matches with s3\\'s current character. */\\n        if(i==s1.length() && s2[j]!=s3[k])\\n            return false;\\n        /* base case - c - if s2 is finished and current \\n        character of s1 doesn\\'t matches with s3\\'s current character. */\\n        if(j==s2.length() && s1[i]!=s3[k])\\n            return false;\\n        //base case - d - If neither s1[i] nor s2[j] matches with s3[k], return false\\n        if(s1[i]!=s3[k] && s2[j]!=s3[k])\\n            return false;\\n//RECURSION\\n    //a.\\n        if(s1[i]==s3[k] && s2[j]!=s3[k])\\n            return dp[i][j]=solve(i+1, j, k+1, s1, s2, s3, dp);\\n    //b.\\n        if(s1[i]!=s3[k] && s2[j]==s3[k])\\n            return dp[i][j]=solve(i, j+1, k+1, s1, s2, s3, dp);\\n    //c.\\n        else\\n            return dp[i][j]=(solve(i+1, j, k+1, s1, s2, s3, dp) || solve(i, j+1, k+1, s1, s2, s3, dp));\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        //if length of string s3 is less than lengthof s1+s2 string then, interleaving not possible\\n        if(s1.length()+s2.length()!=s3.length())\\n            return false;\\n        vector<vector<int>>dp(s1.length()+1, vector<int>(s2.length()+1, -1));\\n        return solve(0, 0, 0, s1, s2, s3, dp);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    bool solve(int i, int j, int k, string s1, string s2, string s3, vector<vector<int>>&dp)\\n    {\\n        if(k==s3.length()) //base case - a - if s3 is completely traversed\\n            return true;\\n        if(dp[i][j]!=-1) // searching in dp table\\n            return dp[i][j];\\n        /* base case - b - if s1 is finished and current \\n        character of s2 doesn\\'t matches with s3\\'s current character. */\\n        if(i==s1.length() && s2[j]!=s3[k])\\n            return false;\\n        /* base case - c - if s2 is finished and current \\n        character of s1 doesn\\'t matches with s3\\'s current character. */\\n        if(j==s2.length() && s1[i]!=s3[k])\\n            return false;\\n        //base case - d - If neither s1[i] nor s2[j] matches with s3[k], return false\\n        if(s1[i]!=s3[k] && s2[j]!=s3[k])\\n            return false;\\n//RECURSION\\n    //a.\\n        if(s1[i]==s3[k] && s2[j]!=s3[k])\\n            return dp[i][j]=solve(i+1, j, k+1, s1, s2, s3, dp);\\n    //b.\\n        if(s1[i]!=s3[k] && s2[j]==s3[k])\\n            return dp[i][j]=solve(i, j+1, k+1, s1, s2, s3, dp);\\n    //c.\\n        else\\n            return dp[i][j]=(solve(i+1, j, k+1, s1, s2, s3, dp) || solve(i, j+1, k+1, s1, s2, s3, dp));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3699287,
                "title": "my-dp-solution-in-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int l = s1.size(), m = s2.size(), n = s3.size();\\n        if(l + m != n) return false;\\n        if (l == 0) return s2 == s3;\\n        if (m == 0) return s1 == s3;\\n        vector<vector<bool>> dp(l+1, vector<bool>(m+1, false));\\n\\n        dp[l][m] = true;\\n        for(int i = 0; i < l; i++) {\\n            if(s1.substr(i, l-i) == s3.substr(m+i, l-i))\\n                dp[i][m] = true;\\n        }\\n        for(int j = 0; j < m; j++) {\\n            if(s2.substr(j, m-j) == s3.substr(l+j, m-j))\\n                dp[l][j] = true;\\n        }\\n\\n        for(int i = l-1; i >= 0; i--) {\\n            for(int j = m-1; j >= 0; j--) {\\n                if(s1[i] == s3[i+j] && s2[j] == s3[i+j]) {\\n                    if(dp[i+1][j] == true || dp[i][j+1] == true) dp[i][j] = true;\\n                }\\n                else if(s1[i] == s3[i+j]) {\\n                    if(dp[i+1][j] == true) dp[i][j] = true;\\n                }\\n                else if(s2[j] == s3[i+j]) {\\n                    if(dp[i][j+1] == true) dp[i][j] = true;\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int l = s1.size(), m = s2.size(), n = s3.size();\\n        if(l + m != n) return false;\\n        if (l == 0) return s2 == s3;\\n        if (m == 0) return s1 == s3;\\n        vector<vector<bool>> dp(l+1, vector<bool>(m+1, false));\\n\\n        dp[l][m] = true;\\n        for(int i = 0; i < l; i++) {\\n            if(s1.substr(i, l-i) == s3.substr(m+i, l-i))\\n                dp[i][m] = true;\\n        }\\n        for(int j = 0; j < m; j++) {\\n            if(s2.substr(j, m-j) == s3.substr(l+j, m-j))\\n                dp[l][j] = true;\\n        }\\n\\n        for(int i = l-1; i >= 0; i--) {\\n            for(int j = m-1; j >= 0; j--) {\\n                if(s1[i] == s3[i+j] && s2[j] == s3[i+j]) {\\n                    if(dp[i+1][j] == true || dp[i][j+1] == true) dp[i][j] = true;\\n                }\\n                else if(s1[i] == s3[i+j]) {\\n                    if(dp[i+1][j] == true) dp[i][j] = true;\\n                }\\n                else if(s2[j] == s3[i+j]) {\\n                    if(dp[i][j+1] == true) dp[i][j] = true;\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592463,
                "title": "java-5-approaches-recursive-memoization-iterative",
                "content": "# Recursive Code \\n```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        Boolean[][][] memo=new Boolean[s1.length()+1][s2.length()+1][s3.length()+1];\\n        return helper(0,0,0,s1,s2,s3,memo);\\n    }\\n    public boolean helper(int i, int j, int k, String s1, String s2, String s3,Boolean[][][] memo){\\n        if(k>=s3.length() ) {\\n            if(i>=s1.length() && j>=s2.length() ) return true;\\n            return false;\\n        }\\n        \\n        if(i>=s1.length() && j>=s2.length()) return false;\\n        if(memo[i][j][k]!=null) return memo[i][j][k];\\n        boolean op1 = false;\\n        if(i<s1.length() && s1.charAt(i)==s3.charAt(k)){\\n            op1=helper(i+1,j,k+1,s1,s2,s3,memo);\\n        }\\n        boolean op2=false;\\n        if(j<s2.length()&& s2.charAt(j)==s3.charAt(k)){\\n            op2=helper(i,j+1,k+1,s1,s2,s3,memo);\\n        }\\n        return memo[i][j][k]= op1 || op2;\\n    }\\n}\\n```\\n# Recursive Code 2\\n```\\nclass Solution{\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tBoolean[][] memo = new Boolean[s1.length() + 1][s2.length() + 1];\\n\\n\\treturn helper(s1, s2, s3, 0, 0, memo);\\n}\\n\\npublic boolean helper(String s1, String s2, String s3, int i, int j, Boolean[][] memo) {\\n\\tif(i+j == s3.length())\\n\\t\\treturn true;\\n\\n\\tif(memo[i][j] != null)\\n\\t\\treturn memo[i][j];\\n    boolean op1=false;\\n\\n\\t if(i < s1.length() && s3.charAt(i+j) == s1.charAt(i)) {\\n\\t\\top1 = helper(s1, s2, s3, i+1, j, memo);\\n\\t\\t\\n\\t}\\n    boolean op2 = false;\\n\\tif(j < s2.length() && s3.charAt(i+j) == s2.charAt(j)) {\\n\\t\\top2 = helper(s1, s2, s3, i, j+1, memo);\\n\\t\\t\\n\\t}\\n\\n\\tmemo[i][j] = op1|| op2;\\n\\treturn memo[i][j];\\n}\\n}\\n```\\n# Tabulation Code - 2d\\n```\\nclass Solution{\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tboolean dp[][] = new boolean[s1.length() + 1][s2.length() + 1];\\n\\n\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\tif (i == 0 && j == 0) \\n\\t\\t\\t\\tdp[i][j] = true;\\n\\t\\t\\n\\t\\t\\telse if (i == 0) \\n\\t\\t\\t\\tdp[i][j] = dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse if (j == 0) \\n\\t\\t\\t\\tdp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) \\n\\t\\t\\t\\t\\t\\t\\t\\t|| (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[s1.length()][s2.length()];\\n}\\n}\\n```\\n# Tabulation Code - 1d\\n```\\n//Tabulation 1d -> just make dp[i][j] to dp[j]\\nclass Solution{\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tboolean dp[] = new boolean[s2.length() + 1];\\n\\n\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\tif (i == 0 && j == 0) \\n\\t\\t\\t\\tdp[j] = true;\\n\\t\\t\\n\\t\\t\\telse if (i == 0) \\n\\t\\t\\t\\tdp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse if (j == 0) \\n\\t\\t\\t\\tdp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) \\n\\t\\t\\t\\t\\t\\t\\t\\t|| (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[s2.length()];\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        Boolean[][][] memo=new Boolean[s1.length()+1][s2.length()+1][s3.length()+1];\\n        return helper(0,0,0,s1,s2,s3,memo);\\n    }\\n    public boolean helper(int i, int j, int k, String s1, String s2, String s3,Boolean[][][] memo){\\n        if(k>=s3.length() ) {\\n            if(i>=s1.length() && j>=s2.length() ) return true;\\n            return false;\\n        }\\n        \\n        if(i>=s1.length() && j>=s2.length()) return false;\\n        if(memo[i][j][k]!=null) return memo[i][j][k];\\n        boolean op1 = false;\\n        if(i<s1.length() && s1.charAt(i)==s3.charAt(k)){\\n            op1=helper(i+1,j,k+1,s1,s2,s3,memo);\\n        }\\n        boolean op2=false;\\n        if(j<s2.length()&& s2.charAt(j)==s3.charAt(k)){\\n            op2=helper(i,j+1,k+1,s1,s2,s3,memo);\\n        }\\n        return memo[i][j][k]= op1 || op2;\\n    }\\n}\\n```\n```\\nclass Solution{\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tBoolean[][] memo = new Boolean[s1.length() + 1][s2.length() + 1];\\n\\n\\treturn helper(s1, s2, s3, 0, 0, memo);\\n}\\n\\npublic boolean helper(String s1, String s2, String s3, int i, int j, Boolean[][] memo) {\\n\\tif(i+j == s3.length())\\n\\t\\treturn true;\\n\\n\\tif(memo[i][j] != null)\\n\\t\\treturn memo[i][j];\\n    boolean op1=false;\\n\\n\\t if(i < s1.length() && s3.charAt(i+j) == s1.charAt(i)) {\\n\\t\\top1 = helper(s1, s2, s3, i+1, j, memo);\\n\\t\\t\\n\\t}\\n    boolean op2 = false;\\n\\tif(j < s2.length() && s3.charAt(i+j) == s2.charAt(j)) {\\n\\t\\top2 = helper(s1, s2, s3, i, j+1, memo);\\n\\t\\t\\n\\t}\\n\\n\\tmemo[i][j] = op1|| op2;\\n\\treturn memo[i][j];\\n}\\n}\\n```\n```\\nclass Solution{\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tboolean dp[][] = new boolean[s1.length() + 1][s2.length() + 1];\\n\\n\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\tif (i == 0 && j == 0) \\n\\t\\t\\t\\tdp[i][j] = true;\\n\\t\\t\\n\\t\\t\\telse if (i == 0) \\n\\t\\t\\t\\tdp[i][j] = dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse if (j == 0) \\n\\t\\t\\t\\tdp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) \\n\\t\\t\\t\\t\\t\\t\\t\\t|| (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[s1.length()][s2.length()];\\n}\\n}\\n```\n```\\n//Tabulation 1d -> just make dp[i][j] to dp[j]\\nclass Solution{\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tboolean dp[] = new boolean[s2.length() + 1];\\n\\n\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\tif (i == 0 && j == 0) \\n\\t\\t\\t\\tdp[j] = true;\\n\\t\\t\\n\\t\\t\\telse if (i == 0) \\n\\t\\t\\t\\tdp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse if (j == 0) \\n\\t\\t\\t\\tdp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) \\n\\t\\t\\t\\t\\t\\t\\t\\t|| (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[s2.length()];\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353694,
                "title": "super-super-easy-to-understand-java-sol",
                "content": "\\n```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s1.length() + s2.length() != s3.length()) return false;\\n        this.s1 = s1;\\n        this.s2 = s2;\\n        this.s3 = s3;\\n        dp = new int[s1.length() + 1][s2.length() + 1];\\n        return helper(0, 0, 0);\\n    }\\n\\n    String s1;\\n    String s2;\\n    String s3;\\n    int[][] dp;\\n\\n    private boolean helper(int i, int j, int k) {\\n        boolean isMatch = false;\\n        // base case\\n        if(k == s3.length()) return true;\\n        \\n        // we don\\'t have to calculate it again, just return result\\n        if(dp[i][j] != 0) return dp[i][j] == 1;\\n\\n        // if s1 matches pick s1\\n        if(i < s1.length() && s1.charAt(i) == s3.charAt(k)) {\\n            isMatch = isMatch || helper(i + 1, j, k + 1);\\n        }\\n\\n        // if s2 matches pick s2\\n        if(j < s2.length() && s2.charAt(j) == s3.charAt(k)) {\\n            isMatch = isMatch || helper(i, j + 1, k + 1);\\n        }\\n\\n        // memorize the final answer\\n        dp[i][j] = isMatch ? 1 : -1;\\n\\n        return isMatch;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s1.length() + s2.length() != s3.length()) return false;\\n        this.s1 = s1;\\n        this.s2 = s2;\\n        this.s3 = s3;\\n        dp = new int[s1.length() + 1][s2.length() + 1];\\n        return helper(0, 0, 0);\\n    }\\n\\n    String s1;\\n    String s2;\\n    String s3;\\n    int[][] dp;\\n\\n    private boolean helper(int i, int j, int k) {\\n        boolean isMatch = false;\\n        // base case\\n        if(k == s3.length()) return true;\\n        \\n        // we don\\'t have to calculate it again, just return result\\n        if(dp[i][j] != 0) return dp[i][j] == 1;\\n\\n        // if s1 matches pick s1\\n        if(i < s1.length() && s1.charAt(i) == s3.charAt(k)) {\\n            isMatch = isMatch || helper(i + 1, j, k + 1);\\n        }\\n\\n        // if s2 matches pick s2\\n        if(j < s2.length() && s2.charAt(j) == s3.charAt(k)) {\\n            isMatch = isMatch || helper(i, j + 1, k + 1);\\n        }\\n\\n        // memorize the final answer\\n        dp[i][j] = isMatch ? 1 : -1;\\n\\n        return isMatch;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734441,
                "title": "c",
                "content": "```\\nbool isInterleave(char * s1, char * s2, char * s3){\\n    int n1 = strlen(s1);\\n    int n2 = strlen(s2);\\n    int n3 = strlen(s3);\\n    if((n1 + n2) != n3)\\n        return false;\\n    if(n1 == 0){\\n        if(strcmp(s2, s3) == 0)\\n            return true;\\n        else\\n            return false;\\n    }\\n    if(n2 == 0){\\n        if(strcmp(s1, s3) == 0)\\n            return true;\\n        else\\n            return false;\\n    }\\n    if(s3[n3-1] != s1[n1-1]  &&  s3[n3-1] != s2[n2-1])\\n        return false;\\n    if(s3[0] != s1[0]  &&  s3[0] != s2[0])\\n        return false;\\n    \\n    bool** dp = malloc((n1+1) * sizeof(bool*));\\n    for(int i = 0; i <= n1; i++){\\n        dp[i] = calloc((n2+1), sizeof(bool));\\n    }\\n\\n    dp[0][0] = true;\\n    for(int i = 1; i <= n1; i++){\\n        dp[i][0] = (dp[i-1][0]== true && (s1[i-1] == s3[i-1]));\\n    }\\n    for(int j = 1; j <= n2; j++){\\n        dp[0][j] = (dp[0][j-1]== true && (s2[j-1] == s3[j-1]));\\n    }\\n    \\n    for(int i = 1; i <= n1; i++){\\n        for(int j = 1; j <= n2; j++){\\n            if((s1[i-1] == s3[i+j-1]) && dp[i-1][j]== true)\\n                dp[i][j] = true;\\n            else if((s2[j-1] == s3[i+j-1]) && dp[i][j-1] == true)\\n                dp[i][j] = true;\\n        }\\n    }\\n\\n    return dp[n1][n2];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isInterleave(char * s1, char * s2, char * s3){\\n    int n1 = strlen(s1);\\n    int n2 = strlen(s2);\\n    int n3 = strlen(s3);\\n    if((n1 + n2) != n3)\\n        return false;\\n    if(n1 == 0){\\n        if(strcmp(s2, s3) == 0)\\n            return true;\\n        else\\n            return false;\\n    }\\n    if(n2 == 0){\\n        if(strcmp(s1, s3) == 0)\\n            return true;\\n        else\\n            return false;\\n    }\\n    if(s3[n3-1] != s1[n1-1]  &&  s3[n3-1] != s2[n2-1])\\n        return false;\\n    if(s3[0] != s1[0]  &&  s3[0] != s2[0])\\n        return false;\\n    \\n    bool** dp = malloc((n1+1) * sizeof(bool*));\\n    for(int i = 0; i <= n1; i++){\\n        dp[i] = calloc((n2+1), sizeof(bool));\\n    }\\n\\n    dp[0][0] = true;\\n    for(int i = 1; i <= n1; i++){\\n        dp[i][0] = (dp[i-1][0]== true && (s1[i-1] == s3[i-1]));\\n    }\\n    for(int j = 1; j <= n2; j++){\\n        dp[0][j] = (dp[0][j-1]== true && (s2[j-1] == s3[j-1]));\\n    }\\n    \\n    for(int i = 1; i <= n1; i++){\\n        for(int j = 1; j <= n2; j++){\\n            if((s1[i-1] == s3[i+j-1]) && dp[i-1][j]== true)\\n                dp[i][j] = true;\\n            else if((s2[j-1] == s3[i+j-1]) && dp[i][j-1] == true)\\n                dp[i][j] = true;\\n        }\\n    }\\n\\n    return dp[n1][n2];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2491750,
                "title": "c-three-different-method-approach-with-most-optimal-solution",
                "content": "```\\nclass Solution {\\n    \\n    //1. Top Down Approach\\n    bool SolveByMemo(string s1, string s2, string s3, vector<vector<int>> &dp)\\n    {\\n        int i = s1.length() , j = s2.length();\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(s3.empty())\\n            return dp[i][j] = (s1.empty() && s2.empty());\\n        \\n        if(s1.empty())\\n            return dp[i][j] = (s2 == s3);\\n        if(s2.empty())\\n            return dp[i][j] = (s1 == s3);\\n        \\n        if(s1[0] == s3[0] && s2[0] == s3[0])\\n            return dp[i][j] = SolveByMemo(s1.substr(1) , s2 , s3.substr(1) , dp) || SolveByMemo(s1 , s2.substr(1) , s3.substr(1), dp) ;\\n        if(s1[0] == s3[0] )\\n            return dp[i][j] = SolveByMemo(s1.substr(1) , s2 , s3.substr(1), dp);\\n        if(s2[0] == s3[0] )\\n            return dp[i][j] = SolveByMemo(s1 , s2.substr(1) , s3.substr(1), dp) ;\\n        \\n        return dp[i][j] = false;\\n        \\n    }\\n    \\n    // 2. Bottom UP Approach\\n    bool SolveByTab(string s1 , string s2 , string s3)\\n    {\\n         vector<vector<int>> dp(s1.length()+1, vector<int> (s2.length()+1, 0));\\n        \\n        for(int i = 0 ; i<= s1.length(); i++)\\n        {\\n            for(int j = 0; j<= s2.length() ; j++)\\n            {\\n                int k = i+j ;\\n                if(i == 0 && j == 0)\\n                   dp[0][0]  = 1;\\n                else if( i == 0)\\n                {\\n                    if(s2[j-1] == s3[k-1])\\n                        dp[i][j] = dp[i][j-1];\\n                }\\n                else if(j == 0)\\n                {\\n                    if(s1[i-1] == s3[k-1])\\n                        dp[i][j] = dp[i-1][j];\\n                }\\n                else\\n                {\\n                   dp[i][j] = (s1[i-1] == s3[k-1] && dp[i-1][j] || s2[j-1] == s3[k-1] && dp[i][j-1]);          \\n                }    \\n            }       \\n        }\\n        \\n        return dp[s1.length()][s2.length()];\\n    }\\n    \\n    // 3. Bottom Up Approach with Space Optimisation\\n      bool SolveSpaceOptimised(string s1 , string s2 , string s3)\\n    {\\n          if(s1.empty())\\n              return s2 == s3;\\n          if(s2.empty())\\n              return s1 == s3;\\n          \\n         vector<int> prev (s2.length()+1, 0);\\n         vector<int> curr (s2.length()+1, 0);\\n          \\n        for(int i = 0 ; i<= s1.length(); i++)\\n        {\\n            for(int j = 0; j<= s2.length() ; j++)\\n            {\\n                int k = i+j ;\\n                if(i == 0 && j == 0)\\n                  curr[0] = 1;\\n                else if( i == 0)\\n                {\\n                    if(s2[j-1] == s3[k-1])\\n                        curr[j] = curr[j-1];\\n                }\\n                else if(j == 0)\\n                {\\n                    if(s1[i-1] == s3[k-1])\\n                        curr[j] = prev[j];\\n                }\\n                else\\n                {\\n                   curr[j] = (s1[i-1] == s3[k-1] && prev[j] || s2[j-1] == s3[k-1] && curr[j-1]);\\n                }    \\n            }\\n            \\n            prev = curr;\\n        }\\n          \\n        return curr[s2.length()];\\n    }\\n    \\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n            \\n        if(s1.length() + s2.length() != s3.length())\\n            return false;\\n        // 1. Top Down Approach\\n        // vector<vector<int>> dp(s1.length()+1, vector<int> (s2.length()+1, -1));\\n        // return SolveByMemo(s1 , s2 , s3 , dp);\\n        \\n        // 2. Bottom Up Approach\\n         return SolveByTab(s1, s2 , s3);\\n        \\n        // 2. Bottom Up Approach + Space optimised\\n        return SolveSpaceOptimised(s1, s2 , s3);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //1. Top Down Approach\\n    bool SolveByMemo(string s1, string s2, string s3, vector<vector<int>> &dp)\\n    {\\n        int i = s1.length() , j = s2.length();\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(s3.empty())\\n            return dp[i][j] = (s1.empty() && s2.empty());\\n        \\n        if(s1.empty())\\n            return dp[i][j] = (s2 == s3);\\n        if(s2.empty())\\n            return dp[i][j] = (s1 == s3);\\n        \\n        if(s1[0] == s3[0] && s2[0] == s3[0])\\n            return dp[i][j] = SolveByMemo(s1.substr(1) , s2 , s3.substr(1) , dp) || SolveByMemo(s1 , s2.substr(1) , s3.substr(1), dp) ;\\n        if(s1[0] == s3[0] )\\n            return dp[i][j] = SolveByMemo(s1.substr(1) , s2 , s3.substr(1), dp);\\n        if(s2[0] == s3[0] )\\n            return dp[i][j] = SolveByMemo(s1 , s2.substr(1) , s3.substr(1), dp) ;\\n        \\n        return dp[i][j] = false;\\n        \\n    }\\n    \\n    // 2. Bottom UP Approach\\n    bool SolveByTab(string s1 , string s2 , string s3)\\n    {\\n         vector<vector<int>> dp(s1.length()+1, vector<int> (s2.length()+1, 0));\\n        \\n        for(int i = 0 ; i<= s1.length(); i++)\\n        {\\n            for(int j = 0; j<= s2.length() ; j++)\\n            {\\n                int k = i+j ;\\n                if(i == 0 && j == 0)\\n                   dp[0][0]  = 1;\\n                else if( i == 0)\\n                {\\n                    if(s2[j-1] == s3[k-1])\\n                        dp[i][j] = dp[i][j-1];\\n                }\\n                else if(j == 0)\\n                {\\n                    if(s1[i-1] == s3[k-1])\\n                        dp[i][j] = dp[i-1][j];\\n                }\\n                else\\n                {\\n                   dp[i][j] = (s1[i-1] == s3[k-1] && dp[i-1][j] || s2[j-1] == s3[k-1] && dp[i][j-1]);          \\n                }    \\n            }       \\n        }\\n        \\n        return dp[s1.length()][s2.length()];\\n    }\\n    \\n    // 3. Bottom Up Approach with Space Optimisation\\n      bool SolveSpaceOptimised(string s1 , string s2 , string s3)\\n    {\\n          if(s1.empty())\\n              return s2 == s3;\\n          if(s2.empty())\\n              return s1 == s3;\\n          \\n         vector<int> prev (s2.length()+1, 0);\\n         vector<int> curr (s2.length()+1, 0);\\n          \\n        for(int i = 0 ; i<= s1.length(); i++)\\n        {\\n            for(int j = 0; j<= s2.length() ; j++)\\n            {\\n                int k = i+j ;\\n                if(i == 0 && j == 0)\\n                  curr[0] = 1;\\n                else if( i == 0)\\n                {\\n                    if(s2[j-1] == s3[k-1])\\n                        curr[j] = curr[j-1];\\n                }\\n                else if(j == 0)\\n                {\\n                    if(s1[i-1] == s3[k-1])\\n                        curr[j] = prev[j];\\n                }\\n                else\\n                {\\n                   curr[j] = (s1[i-1] == s3[k-1] && prev[j] || s2[j-1] == s3[k-1] && curr[j-1]);\\n                }    \\n            }\\n            \\n            prev = curr;\\n        }\\n          \\n        return curr[s2.length()];\\n    }\\n    \\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n            \\n        if(s1.length() + s2.length() != s3.length())\\n            return false;\\n        // 1. Top Down Approach\\n        // vector<vector<int>> dp(s1.length()+1, vector<int> (s2.length()+1, -1));\\n        // return SolveByMemo(s1 , s2 , s3 , dp);\\n        \\n        // 2. Bottom Up Approach\\n         return SolveByTab(s1, s2 , s3);\\n        \\n        // 2. Bottom Up Approach + Space optimised\\n        return SolveSpaceOptimised(s1, s2 , s3);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249713,
                "title": "dp-easy-solution-0ms-memoization-easy-and-simple-with-comments",
                "content": "DP solution (memoization)\\nTC - O(n)\\n```\\nclass Solution {\\npublic:\\n    bool f(int i,int j, int k, string &s1, string &s2, string &s3, vector<vector<int>> &dp){\\n        //base cases\\n        if(i==s1.size() && j==s2.size() && k==s3.size()) return true;\\n        if(i>s1.size() || j>s2.size()) return false;\\n        \\n        //memoization\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        //if both are same then check for both i.e. recursion\\n        if(s1[i]==s3[k] && s2[j]==s3[k]){\\n            return dp[i][j] = (f(i+1,j,k+1,s1,s2,s3,dp) || f(i,j+1,k+1,s1,s2,s3,dp));\\n        }\\n        else if(s1[i]==s3[k]){\\n            return dp[i][j] = f(i+1,j,k+1,s1,s2,s3,dp);\\n        }\\n        else if(s2[j]==s3[k]){\\n            return dp[i][j] = f(i,j+1,k+1,s1,s2,s3,dp);\\n        }else{\\n            return false;\\n        }\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n=s1.length(),m=s2.length(),len=s3.length();\\n        //initialization of dp\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return f(0,0,0,s1,s2,s3,dp);\\n    }\\n};\\n```\\nwe can do it with tabulation and then space optimization also.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int i,int j, int k, string &s1, string &s2, string &s3, vector<vector<int>> &dp){\\n        //base cases\\n        if(i==s1.size() && j==s2.size() && k==s3.size()) return true;\\n        if(i>s1.size() || j>s2.size()) return false;\\n        \\n        //memoization\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        //if both are same then check for both i.e. recursion\\n        if(s1[i]==s3[k] && s2[j]==s3[k]){\\n            return dp[i][j] = (f(i+1,j,k+1,s1,s2,s3,dp) || f(i,j+1,k+1,s1,s2,s3,dp));\\n        }\\n        else if(s1[i]==s3[k]){\\n            return dp[i][j] = f(i+1,j,k+1,s1,s2,s3,dp);\\n        }\\n        else if(s2[j]==s3[k]){\\n            return dp[i][j] = f(i,j+1,k+1,s1,s2,s3,dp);\\n        }else{\\n            return false;\\n        }\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n=s1.length(),m=s2.length(),len=s3.length();\\n        //initialization of dp\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return f(0,0,0,s1,s2,s3,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249366,
                "title": "easy-understandable-recursion-with-memoization-3d-dp",
                "content": "```\\nclass Solution {\\n    Boolean[][][] dp;\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        \\n        int s1Len = s1.length(), s2Len = s2.length(), s3Len = s3.length();\\n        \\n        dp = new Boolean[s1Len+1][s2Len+1][s3Len+1];\\n\\t\\t\\n\\t\\t// If length of s1 + s2 is not equal with that of s3 then return false bcz s3 is created by combining s1 and s2 only\\n        if((s1Len+s2Len) != s3Len) return false;\\n        \\n        return solve(s1,s2,s3,0,0,0);\\n    }\\n    \\n    private boolean solve(String s1, String s2, String s3, int i1, int i2, int j){\\n        \\n        // Base condition\\n        if(j == s3.length()) return true;\\n        \\n        if(dp[i1][i2][j] != null) return dp[i1][i2][j];\\n        \\n        // If any of string (s1 or s2) ends, then continue comparing with the remaining string\\n        if(i1 == s1.length() && i2 != s2.length())\\n            return dp[i1][i2][j] = (s2.charAt(i2)==s3.charAt(j)) && solve(s1,s2,s3,i1,i2+1,j+1);\\n        else if(i1 != s1.length() && i2 == s2.length())\\n            return dp[i1][i2][j] = (s1.charAt(i1)==s3.charAt(j)) && solve(s1,s2,s3,i1+1,i2,j+1);\\n        \\n        char s1C = s1.charAt(i1), s2C = s2.charAt(i2), s3C = s3.charAt(j);\\n        \\n        // If char of s1 matches with s3 but not of s2 \\n        if(s1C == s3C && s2C != s3C)\\n            return dp[i1][i2][j] = solve(s1,s2,s3,i1+1,i2,j+1);\\n        \\n        // If char of s2 matches with s3 but not of s1\\n        else if (s1C != s3C && s2C == s3C)\\n            return dp[i1][i2][j] = solve(s1,s2,s3,i1,i2+1,j+1);\\n        \\n        // If char of both s1 and s2 matches with s3\\n        else if(s1C == s3C && s2C == s3C)\\n            return dp[i1][i2][j] = solve(s1,s2,s3,i1,i2+1,j+1) || solve(s1,s2,s3,i1+1,i2,j+1);\\n        \\n        // If no char of either s1 or s2 matching with s3, then return false as the char in s3 is not a part of any substring of s1 and s2\\n        else return dp[i1][i2][j] = false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Boolean[][][] dp;\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        \\n        int s1Len = s1.length(), s2Len = s2.length(), s3Len = s3.length();\\n        \\n        dp = new Boolean[s1Len+1][s2Len+1][s3Len+1];\\n\\t\\t\\n\\t\\t// If length of s1 + s2 is not equal with that of s3 then return false bcz s3 is created by combining s1 and s2 only\\n        if((s1Len+s2Len) != s3Len) return false;\\n        \\n        return solve(s1,s2,s3,0,0,0);\\n    }\\n    \\n    private boolean solve(String s1, String s2, String s3, int i1, int i2, int j){\\n        \\n        // Base condition\\n        if(j == s3.length()) return true;\\n        \\n        if(dp[i1][i2][j] != null) return dp[i1][i2][j];\\n        \\n        // If any of string (s1 or s2) ends, then continue comparing with the remaining string\\n        if(i1 == s1.length() && i2 != s2.length())\\n            return dp[i1][i2][j] = (s2.charAt(i2)==s3.charAt(j)) && solve(s1,s2,s3,i1,i2+1,j+1);\\n        else if(i1 != s1.length() && i2 == s2.length())\\n            return dp[i1][i2][j] = (s1.charAt(i1)==s3.charAt(j)) && solve(s1,s2,s3,i1+1,i2,j+1);\\n        \\n        char s1C = s1.charAt(i1), s2C = s2.charAt(i2), s3C = s3.charAt(j);\\n        \\n        // If char of s1 matches with s3 but not of s2 \\n        if(s1C == s3C && s2C != s3C)\\n            return dp[i1][i2][j] = solve(s1,s2,s3,i1+1,i2,j+1);\\n        \\n        // If char of s2 matches with s3 but not of s1\\n        else if (s1C != s3C && s2C == s3C)\\n            return dp[i1][i2][j] = solve(s1,s2,s3,i1,i2+1,j+1);\\n        \\n        // If char of both s1 and s2 matches with s3\\n        else if(s1C == s3C && s2C == s3C)\\n            return dp[i1][i2][j] = solve(s1,s2,s3,i1,i2+1,j+1) || solve(s1,s2,s3,i1+1,i2,j+1);\\n        \\n        // If no char of either s1 or s2 matching with s3, then return false as the char in s3 is not a part of any substring of s1 and s2\\n        else return dp[i1][i2][j] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248912,
                "title": "dp-memoization",
                "content": "\\n\\n    class Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        int dp[][][]=new int[s1.length()+1][s2.length()+1][s3.length()];\\n        for(int p[][]:dp){\\n            for(int t1[]:p){\\n                Arrays.fill(t1,-1);\\n            }\\n        }\\n        return f(0,0,0,s1,s2,s3,dp);\\n    }\\n    public boolean f(int i,int j,int k,String s1,String s2,String s3,int dp[][][]){\\n        if(i>=s1.length() && j>=s2.length() && k>=s3.length())return true;\\n        \\n        if(dp[i][j][k]!=-1)return dp[i][j][k]==0?false:true;\\n        boolean up=false;\\n        //checking if from both string characters are equal\\n        if((i<s1.length() && s1.charAt(i)==s3.charAt(k)) && (j<s2.length() && s2.charAt(j)==s3.charAt(k))){\\n            boolean take=f(i+1,j,k+1,s1,s2,s3,dp);\\n            boolean not=f(i,j+1,k+1,s1,s2,s3,dp);\\n            up=take || not;\\n        }\\n         // checking if from first string characters are equal  \\n        else if(i<s1.length() && s1.charAt(i)==s3.charAt(k)){\\n            up=f(i+1,j,k+1,s1,s2,s3,dp);\\n        }\\n        //checking if from second string characters are equal  \\n        else if(j<s2.length() && s2.charAt(j)==s3.charAt(k)){\\n            up=f(i,j+1,k+1,s1,s2,s3,dp);\\n        }\\n        dp[i][j][k]=(up==false)?0:1;\\n        return up;\\n    }\\n}",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        int dp[][][]=new int[s1.length()+1][s2.length()+1][s3.length()];\\n        for(int p[][]:dp){\\n            for(int t1[]:p){\\n                Arrays.fill(t1,-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2248489,
                "title": "java-easy-solution-with-explanation",
                "content": "\\'\\'\\'\\n class Solution {\\n\\tpublic boolean isInterleave(String s1, String s2, String s3) {\\n\\t\\tint m = s1.length(); \\n\\t\\tint n = s2.length();\\n\\n\\t\\t// Base case\\n\\t\\tif(s3.length() != m + n) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif(s1.length() == 0) {\\n\\t\\t\\treturn s2.equals(s3);\\n\\t\\t} \\n\\t\\tif(s2.length() == 0) {\\n\\t\\t\\treturn s1.equals(s3);\\n\\t\\t}\\n\\n\\t\\t// dp[i][j] represents can we use i characters from s1 and j characters from s2 \\n\\t\\t// to form the first i+j characters from s3\\n\\t\\tboolean[][] dp = new boolean[m+1][n+1];\\n\\n\\t\\t// base case using 0 characters from both means yes. \\n\\t\\tdp[0][0] = true;\\n\\n\\t\\tfor(int i = 1; i < m+1; i++) {\\n\\t\\t\\tdp[i][0] = dp[i-1][0] && s1.charAt(i-1) == s3.charAt(i-1);\\n\\t\\t}\\n\\n\\t\\tfor(int i = 1; i < n+1; i++) {\\n\\t\\t\\tdp[0][i] = dp[0][i-1] && s2.charAt(i-1) == s3.charAt(i-1);\\n\\t\\t}\\n\\n\\t\\t// the recursive relationship\\n\\t\\tfor(int i = 1; i < m+1; i++) {\\n\\t\\t\\tfor(int j = 1; j < n+1; j++) {\\n\\t\\t\\t\\tdp[i][j] = (dp[i-1][j] && s1.charAt(i-1) == s3.charAt(i+j-1)) \\n\\t\\t\\t\\t\\t\\t|| (dp[i][j-1] && s2.charAt(j-1) == s3.charAt(i+j-1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[m][n];\\n\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic boolean isInterleave(String s1, String s2, String s3) {\\n\\t\\tint m = s1.length(); \\n\\t\\tint n = s2.length();\\n\\n\\t\\t// Base case\\n\\t\\tif(s3.length() != m + n) {\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1823087,
                "title": "super-fast-golang",
                "content": "2D DP matrix is faster than 1D DP array (100% vs 40%), for some reason. May be due to underlying slice operations. \\nBoth are included below.\\n\\n```\\nfunc isInterleave(s1 string, s2 string, s3 string) bool {\\n    /*\\n\\t\\n\\t2D DP matrix: \\n\\tPlace s1 and s2 on axes. \\n\\tmatrix[i][j] represents isInterleave(s1[:i], s2[:j], s3[:i+j]).\\n    \\n\\t       a a b c c\\n        0 1 2 3 4 5\\n      0 t t t f f f\\n    d 1 f f t t f f  \\n    b 2 f f t t t f\\n    b 3 f f t t t f\\n    c 4 f f t t t f\\n    a 5 f f f f t t\\n      \\n    */\\n    if s1 == \"\" || s2 == \"\" {\\n        return s3 == s1 + s2\\n    }\\n    if len(s1) + len(s2) != len(s3) {\\n        return false\\n    }\\n    dp := make([][]bool, len(s1)+1)\\n    for i := range dp {\\n        dp[i] = make([]bool, len(s2)+1)\\n    }\\n    for i := 0; i < len(dp); i++ {\\n        for j := 0; j < len(dp[0]); j++ {\\n            if i == 0 || j == 0 {\\n                dp[i][j] = s1[:i] + s2[:j] == s3[:i+j]\\n                continue\\n            }\\n            // check top\\n            if dp[i-1][j] && s1[i-1] == s3[i+j-1] {\\n                dp[i][j] = true\\n            }\\n            // check left\\n            if dp[i][j-1] && s2[j-1] == s3[i+j-1] {\\n                dp[i][j] = true\\n            }\\n        }\\n    }\\n    return dp[len(s1)][len(s2)]\\n}\\n```\\n\\nSince we are going row by row, we only need to hold two rows in memory (current and previous).\\n1D DP slice solution here.\\n\\n```\\nfunc isInterleave(s1 string, s2 string, s3 string) bool {\\n    if s1 == \"\" || s2 == \"\" {\\n        return s3 == s1 + s2\\n    }\\n    if len(s1) + len(s2) != len(s3) {\\n        return false\\n    }\\n    dp := make([]bool, len(s2)+1)\\n    for i := 0; i <= len(s1); i++ {\\n        nextDP := make([]bool, len(s2)+1)\\n        for j := 0; j <= len(s2); j++ {\\n            if i == 0 || j == 0 {\\n                nextDP[j] = s1[:i] + s2[:j] == s3[:i+j]\\n                continue\\n            }\\n            // check top\\n            if dp[j] && s1[i-1] == s3[i+j-1] {\\n                nextDP[j] = true\\n            }\\n            // check left\\n            if nextDP[j-1] && s2[j-1] == s3[i+j-1] {\\n                nextDP[j] = true\\n            }\\n        }\\n        dp = nextDP\\n    }\\n    return dp[len(s2)]\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isInterleave(s1 string, s2 string, s3 string) bool {\\n    /*\\n\\t\\n\\t2D DP matrix: \\n\\tPlace s1 and s2 on axes. \\n\\tmatrix[i][j] represents isInterleave(s1[:i], s2[:j], s3[:i+j]).\\n    \\n\\t       a a b c c\\n        0 1 2 3 4 5\\n      0 t t t f f f\\n    d 1 f f t t f f  \\n    b 2 f f t t t f\\n    b 3 f f t t t f\\n    c 4 f f t t t f\\n    a 5 f f f f t t\\n      \\n    */\\n    if s1 == \"\" || s2 == \"\" {\\n        return s3 == s1 + s2\\n    }\\n    if len(s1) + len(s2) != len(s3) {\\n        return false\\n    }\\n    dp := make([][]bool, len(s1)+1)\\n    for i := range dp {\\n        dp[i] = make([]bool, len(s2)+1)\\n    }\\n    for i := 0; i < len(dp); i++ {\\n        for j := 0; j < len(dp[0]); j++ {\\n            if i == 0 || j == 0 {\\n                dp[i][j] = s1[:i] + s2[:j] == s3[:i+j]\\n                continue\\n            }\\n            // check top\\n            if dp[i-1][j] && s1[i-1] == s3[i+j-1] {\\n                dp[i][j] = true\\n            }\\n            // check left\\n            if dp[i][j-1] && s2[j-1] == s3[i+j-1] {\\n                dp[i][j] = true\\n            }\\n        }\\n    }\\n    return dp[len(s1)][len(s2)]\\n}\\n```\n```\\nfunc isInterleave(s1 string, s2 string, s3 string) bool {\\n    if s1 == \"\" || s2 == \"\" {\\n        return s3 == s1 + s2\\n    }\\n    if len(s1) + len(s2) != len(s3) {\\n        return false\\n    }\\n    dp := make([]bool, len(s2)+1)\\n    for i := 0; i <= len(s1); i++ {\\n        nextDP := make([]bool, len(s2)+1)\\n        for j := 0; j <= len(s2); j++ {\\n            if i == 0 || j == 0 {\\n                nextDP[j] = s1[:i] + s2[:j] == s3[:i+j]\\n                continue\\n            }\\n            // check top\\n            if dp[j] && s1[i-1] == s3[i+j-1] {\\n                nextDP[j] = true\\n            }\\n            // check left\\n            if nextDP[j-1] && s2[j-1] == s3[i+j-1] {\\n                nextDP[j] = true\\n            }\\n        }\\n        dp = nextDP\\n    }\\n    return dp[len(s2)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470519,
                "title": "recursive-dp-solution-c-0ms-faster-than-100",
                "content": "```class Solution {\\npublic:\\n    int dp[105][105];\\n    bool sol(string& s1,string& s2,string& s3,int i,int j,int k){\\n        if(k==s3.length()){\\n            if(i==s1.length()&&j==s2.length())return dp[i][j]=true;\\n            return false;\\n        }\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s1[i]==s3[k]){\\n            if(s2[j]==s3[k]){\\n                bool a1=sol(s1,s2,s3,i+1,j,k+1);\\n                if(a1==true)return dp[i][j]=true;\\n                return dp[i][j]=sol(s1,s2,s3,i,j+1,k+1);\\n            }\\n            return dp[i][j]=sol(s1,s2,s3,i+1,j,k+1);\\n        }\\n        if(s2[j]==s3[k]){\\n            return dp[i][j]=sol(s1,s2,s3,i,j+1,k+1);\\n        }\\n        return dp[i][j]=false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        // if(s1+s2==s3||s2+s1==s3)return true;\\n        memset(dp,-1,sizeof(dp));\\n        return sol(s1,s2,s3,0,0,0);\\n    }\\n};```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```class Solution {\\npublic:\\n    int dp[105][105];\\n    bool sol(string& s1,string& s2,string& s3,int i,int j,int k){\\n        if(k==s3.length()){\\n            if(i==s1.length()&&j==s2.length())return dp[i][j]=true;\\n            return false;\\n        }\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s1[i]==s3[k]){\\n            if(s2[j]==s3[k]){\\n                bool a1=sol(s1,s2,s3,i+1,j,k+1);\\n                if(a1==true)return dp[i][j]=true;\\n                return dp[i][j]=sol(s1,s2,s3,i,j+1,k+1);\\n            }\\n            return dp[i][j]=sol(s1,s2,s3,i+1,j,k+1);\\n        }\\n        if(s2[j]==s3[k]){\\n            return dp[i][j]=sol(s1,s2,s3,i,j+1,k+1);\\n        }\\n        return dp[i][j]=false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        // if(s1+s2==s3||s2+s1==s3)return true;\\n        memset(dp,-1,sizeof(dp));\\n        return sol(s1,s2,s3,0,0,0);\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1311468,
                "title": "c-4-ms-faster-than-73-89-6-1-mb-less-than-93-05-dp-visualised",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n\\t\\n\\t/* Input\\n\\t\\n\\t\"aabcc\"\\n\\t\"dbbca\"\\n\\t\"aadbbcbcac\"\\n\\t\\n\\t*/\\n\\n        \\n    if (s1.size() > 100 \\n        || s2.size() > 100 \\n        || s1.size() + s2.size() != s3.size()) {\\n        return false;\\n    }\\n        \\n    int dp[101][101];\\n        \\n    for(int i = 0; i < 101; i++) {\\n        for(int j = 0; j < 101; j++) {\\n            dp[i][j] = 0;\\n        }\\n    }\\n\\n    // If no length then match\\n    dp[0][0] = 1;\\n        \\n    \\n    // Calculate for only s1\\n    for(int i = 0 ; i < s1.size() ; i++ ) {\\n        if( s3[i] == s1[i] ) {\\n            dp[0][i+1] =  dp[0][i];\\n        }\\n    }\\n\\n    // Calculate for only s2 \\n    for(int j = 0 ; j < s2.size() ; j++ ) {\\n        if( s3[j] == s2[j] ) {\\n            dp[j+1][0] = dp[j][0];\\n        }\\n    }\\n\\n    /* dp table lloks like\\n\\t\\n\\t1 1 1 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t\\n\\t*/\\n        \\n    for (  int j = 1;  j  <=  s2.size() ;  j++ ) {\\n        \\n        for ( int i = 1;  i <= s1.size();  i++ )  {\\n\\n            // if s3[previous] not from s2, then check if s1 match\\n\\t\\t\\t\\n            bool isFromS1 = dp[j][i-1] && s3[i+j-1] == s1[i-1];\\n\\n            // if s3[previous] not from s1, then check if s2 match\\n\\t\\t\\t\\n            bool isFromS2 = dp[j-1][i] && s3[i+j-1] == s2[j-1];\\n\\n            dp[j][i] = isFromS1 || isFromS2;\\n        }\\n    }\\n\\n   /* dp table lloks like\\n\\t\\n\\t1 1 1 0 0 0 \\n\\t0 0 1 1 0 0 \\n\\t0 0 1 1 1 0 \\n\\t0 0 1 0 1 1 \\n\\t0 0 1 1 1 0 \\n\\t0 0 0 0 1 1 \\n\\t\\n\\t*/\\n\\t\\n    return dp[s2.size()][s1.size()];\\n}\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n\\t\\n\\t/* Input\\n\\t\\n\\t\"aabcc\"\\n\\t\"dbbca\"\\n\\t\"aadbbcbcac\"\\n\\t\\n\\t*/\\n\\n        \\n    if (s1.size() > 100 \\n        || s2.size() > 100 \\n        || s1.size() + s2.size() != s3.size()) {\\n        return false;\\n    }\\n        \\n    int dp[101][101];\\n        \\n    for(int i = 0; i < 101; i++) {\\n        for(int j = 0; j < 101; j++) {\\n            dp[i][j] = 0;\\n        }\\n    }\\n\\n    // If no length then match\\n    dp[0][0] = 1;\\n        \\n    \\n    // Calculate for only s1\\n    for(int i = 0 ; i < s1.size() ; i++ ) {\\n        if( s3[i] == s1[i] ) {\\n            dp[0][i+1] =  dp[0][i];\\n        }\\n    }\\n\\n    // Calculate for only s2 \\n    for(int j = 0 ; j < s2.size() ; j++ ) {\\n        if( s3[j] == s2[j] ) {\\n            dp[j+1][0] = dp[j][0];\\n        }\\n    }\\n\\n    /* dp table lloks like\\n\\t\\n\\t1 1 1 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t\\n\\t*/\\n        \\n    for (  int j = 1;  j  <=  s2.size() ;  j++ ) {\\n        \\n        for ( int i = 1;  i <= s1.size();  i++ )  {\\n\\n            // if s3[previous] not from s2, then check if s1 match\\n\\t\\t\\t\\n            bool isFromS1 = dp[j][i-1] && s3[i+j-1] == s1[i-1];\\n\\n            // if s3[previous] not from s1, then check if s2 match\\n\\t\\t\\t\\n            bool isFromS2 = dp[j-1][i] && s3[i+j-1] == s2[j-1];\\n\\n            dp[j][i] = isFromS1 || isFromS2;\\n        }\\n    }\\n\\n   /* dp table lloks like\\n\\t\\n\\t1 1 1 0 0 0 \\n\\t0 0 1 1 0 0 \\n\\t0 0 1 1 1 0 \\n\\t0 0 1 0 1 1 \\n\\t0 0 1 1 1 0 \\n\\t0 0 0 0 1 1 \\n\\t\\n\\t*/\\n\\t\\n    return dp[s2.size()][s1.size()];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248583,
                "title": "c-from-top-down-memoization-using-map",
                "content": "bool godp(string s1, string s2, string s3, int i, int j, int k, map<pair<int,int>,int> &ma ) {\\n        \\n        int n = s1.length(), m = s2.length(), l = s3.length();\\n        if(k >= l && i >=n && j >= m) {\\n            return 1;\\n        }\\n        if(k >= l)\\n            return 0;\\n        if(ma.find({i,j}) != ma.end()) {\\n            return ma[{i,j}];\\n        }\\n        int op1 = 0, op2 = 0;\\n        if(j < m && s3[k] == s2[j]) {\\n                    op1 = godp(s1,s2,s3,i,j+1,k+1, ma);\\n        }\\n        if(i < n && s3[k] == s1[i]) {\\n            op2 = godp(s1,s2,s3,i+1,j,k+1, ma);\\n        }\\n        return ma[{i,j}] = (op1||op2);\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n         map<pair<int,int>,int> ma;\\n        int i =0, j = 0, k = 0;\\n        int n = s1.length(), m = s2.length(), l = s3.length(); \\n        return godp(s1,s2,s3,0,0,0,ma);\\n    }",
                "solutionTags": [],
                "code": "bool godp(string s1, string s2, string s3, int i, int j, int k, map<pair<int,int>,int> &ma ) {\\n        \\n        int n = s1.length(), m = s2.length(), l = s3.length();\\n        if(k >= l && i >=n && j >= m) {\\n            return 1;\\n        }\\n        if(k >= l)\\n            return 0;\\n        if(ma.find({i,j}) != ma.end()) {\\n            return ma[{i,j}];\\n        }\\n        int op1 = 0, op2 = 0;\\n        if(j < m && s3[k] == s2[j]) {\\n                    op1 = godp(s1,s2,s3,i,j+1,k+1, ma);\\n        }\\n        if(i < n && s3[k] == s1[i]) {\\n            op2 = godp(s1,s2,s3,i+1,j,k+1, ma);\\n        }\\n        return ma[{i,j}] = (op1||op2);\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n         map<pair<int,int>,int> ma;\\n        int i =0, j = 0, k = 0;\\n        int n = s1.length(), m = s2.length(), l = s3.length(); \\n        return godp(s1,s2,s3,0,0,0,ma);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1248054,
                "title": "java-easy-3ms-tabulation-tabulation",
                "content": "```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        int q = s3.length();\\n        if(n+m!=q){\\n            return false;\\n        }\\n        boolean dp[][]= new boolean[n+1][m+1];\\n        for(int i = 0;i<=n;i++){\\n            for(int j = 0;j<=m;j++){\\n                if(i==0&&j==0){\\n                    dp[i][j]=true;\\n                }\\n                else if(i==0){\\n                    char a = s3.charAt(j-1);\\n                    char b = s2.charAt(j-1);\\n                    if(a==b&&dp[i][j-1]){\\n                        dp[i][j]=true;\\n                    }\\n                }else if(j==0){\\n                    char a = s3.charAt(i-1);\\n                    char b = s1.charAt(i-1);\\n                    if(a==b&&dp[i-1][j]){\\n                        dp[i][j]=true;\\n                    }\\n                }else{\\n                    if(dp[i][j-1]&&!dp[i-1][j]){\\n                    char a = s2.charAt(j-1);\\n                    char b = s3.charAt(i+j-1);\\n                        if(a==b){\\n                            dp[i][j]=true;\\n                        }\\n                  \\n                }\\n                    else if(dp[i-1][j]&&!dp[i][j-1]){\\n                    char a = s1.charAt(i-1);\\n                    char b = s3.charAt(i+j-1);\\n                        if(a==b){\\n                            dp[i][j]=true;\\n                        }\\n                  \\n                }\\n                    else if(dp[i-1][j]&&dp[i][j-1]){\\n                         char a = s1.charAt(i-1);\\n                        char c = s2.charAt(j-1);\\n                    char b = s3.charAt(i+j-1);\\n                        if(a==b&&a==c){\\n                            dp[i][j]=true;\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n       return dp[n][m]; \\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/a02d94b5-9c16-4d19-a261-d6873a24911d_1622681113.874321.png)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        int q = s3.length();\\n        if(n+m!=q){\\n            return false;\\n        }\\n        boolean dp[][]= new boolean[n+1][m+1];\\n        for(int i = 0;i<=n;i++){\\n            for(int j = 0;j<=m;j++){\\n                if(i==0&&j==0){\\n                    dp[i][j]=true;\\n                }\\n                else if(i==0){\\n                    char a = s3.charAt(j-1);\\n                    char b = s2.charAt(j-1);\\n                    if(a==b&&dp[i][j-1]){\\n                        dp[i][j]=true;\\n                    }\\n                }else if(j==0){\\n                    char a = s3.charAt(i-1);\\n                    char b = s1.charAt(i-1);\\n                    if(a==b&&dp[i-1][j]){\\n                        dp[i][j]=true;\\n                    }\\n                }else{\\n                    if(dp[i][j-1]&&!dp[i-1][j]){\\n                    char a = s2.charAt(j-1);\\n                    char b = s3.charAt(i+j-1);\\n                        if(a==b){\\n                            dp[i][j]=true;\\n                        }\\n                  \\n                }\\n                    else if(dp[i-1][j]&&!dp[i][j-1]){\\n                    char a = s1.charAt(i-1);\\n                    char b = s3.charAt(i+j-1);\\n                        if(a==b){\\n                            dp[i][j]=true;\\n                        }\\n                  \\n                }\\n                    else if(dp[i-1][j]&&dp[i][j-1]){\\n                         char a = s1.charAt(i-1);\\n                        char c = s2.charAt(j-1);\\n                    char b = s3.charAt(i+j-1);\\n                        if(a==b&&a==c){\\n                            dp[i][j]=true;\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n       return dp[n][m]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247877,
                "title": "clean-1d-dp-go-solution-beats-100",
                "content": "```\\nfunc isInterleave(s1 string, s2 string, s3 string) bool {\\n\\tif len(s1)+len(s2) != len(s3) {\\n\\t\\treturn false\\n\\t}\\n\\n\\tdp := make([]bool, len(s1)+1)\\n\\tfor i := 0; i < len(s2)+1; i++ {\\n\\t\\tfor j := 0; j < len(s1)+1; j++ {\\n\\t\\t\\tdp[j] = i == 0 && j == 0 || j > 0 && dp[j-1] && s1[j-1] == s3[i+j-1] || i > 0 && dp[j] && s2[i-1] == s3[i+j-1]\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[len(s1)]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc isInterleave(s1 string, s2 string, s3 string) bool {\\n\\tif len(s1)+len(s2) != len(s3) {\\n\\t\\treturn false\\n\\t}\\n\\n\\tdp := make([]bool, len(s1)+1)\\n\\tfor i := 0; i < len(s2)+1; i++ {\\n\\t\\tfor j := 0; j < len(s1)+1; j++ {\\n\\t\\t\\tdp[j] = i == 0 && j == 0 || j > 0 && dp[j-1] && s1[j-1] == s3[i+j-1] || i > 0 && dp[j] && s2[i-1] == s3[i+j-1]\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[len(s1)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1247161,
                "title": "interleaving-string",
                "content": "**Basic intution**\\nthis question is somewhat similar to longest common subsequence which is a very popular dp problem. Here were are selecting last character of s3 and comparing it with  last element of s1 and s2.\\n\\n**Example1**\\n   consider s1=\"abc\",s2=\"adg\" and s3=\"aabcdg\"\\n![image](https://assets.leetcode.com/users/images/fc54b5d6-67c8-451e-af04-0903dc4809ce_1622638700.4142802.png)\\n\\n**Example2**\\n![image](https://assets.leetcode.com/users/images/944f8c3f-b56f-4ed3-b8d4-7040ac82de91_1622639036.6773384.png)\\n\\n\\t\\t\\t\\t\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int t[101][101];\\n    bool lcs(string s1,string s2,string s3,int n1,int n2,int n3){\\n        if(t[n1+1][n2+1]!=-1){\\n            return t[n1+1][n2+1];\\n        }\\n        if(n1<0 and n2<0){\\n            return t[n1+1][n2+1]=true;\\n        }\\n        if(n1<0){\\n            if(s2[n2]==s3[n3]){\\n                return t[n1+1][n2+1]=lcs(s1,s2,s3,n1,n2-1,n3-1);\\n            }\\n            else{\\n                return t[n1+1][n2+1]=false;\\n            }\\n        }\\n        else if(n2<0){\\n             if(s1[n1]==s3[n3]){\\n                return t[n1+1][n2+1]=lcs(s1,s2,s3,n1-1,n2,n3-1);\\n            }\\n            else{\\n                return t[n1+1][n2+1]=false;\\n            }\\n        }\\n        if(s1[n1]==s3[n3] and s2[n2]==s3[n3]){\\n            return t[n1+1][n2+1]=lcs(s1,s2,s3,n1-1,n2,n3-1) or lcs(s1,s2,s3,n1,n2-1,n3-1);\\n        }\\n        else if(s1[n1]==s3[n3]){\\n            return t[n1+1][n2+1]=lcs(s1,s2,s3,n1-1,n2,n3-1);\\n        }\\n        else if(s2[n2]==s3[n3]){\\n             return t[n1+1][n2+1]=lcs(s1,s2,s3,n1,n2-1,n3-1);\\n        }\\n        return t[n1+1][n2+1]=false;\\n        \\n    }    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.size()!=s1.size()+s2.size()){\\n            return false;\\n        }\\n        memset(t,-1,sizeof(t));\\n        return lcs(s1,s2,s3,s1.size()-1,s2.size()-1,s3.size()-1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int t[101][101];\\n    bool lcs(string s1,string s2,string s3,int n1,int n2,int n3){\\n        if(t[n1+1][n2+1]!=-1){\\n            return t[n1+1][n2+1];\\n        }\\n        if(n1<0 and n2<0){\\n            return t[n1+1][n2+1]=true;\\n        }\\n        if(n1<0){\\n            if(s2[n2]==s3[n3]){\\n                return t[n1+1][n2+1]=lcs(s1,s2,s3,n1,n2-1,n3-1);\\n            }\\n            else{\\n                return t[n1+1][n2+1]=false;\\n            }\\n        }\\n        else if(n2<0){\\n             if(s1[n1]==s3[n3]){\\n                return t[n1+1][n2+1]=lcs(s1,s2,s3,n1-1,n2,n3-1);\\n            }\\n            else{\\n                return t[n1+1][n2+1]=false;\\n            }\\n        }\\n        if(s1[n1]==s3[n3] and s2[n2]==s3[n3]){\\n            return t[n1+1][n2+1]=lcs(s1,s2,s3,n1-1,n2,n3-1) or lcs(s1,s2,s3,n1,n2-1,n3-1);\\n        }\\n        else if(s1[n1]==s3[n3]){\\n            return t[n1+1][n2+1]=lcs(s1,s2,s3,n1-1,n2,n3-1);\\n        }\\n        else if(s2[n2]==s3[n3]){\\n             return t[n1+1][n2+1]=lcs(s1,s2,s3,n1,n2-1,n3-1);\\n        }\\n        return t[n1+1][n2+1]=false;\\n        \\n    }    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.size()!=s1.size()+s2.size()){\\n            return false;\\n        }\\n        memset(t,-1,sizeof(t));\\n        return lcs(s1,s2,s3,s1.size()-1,s2.size()-1,s3.size()-1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247111,
                "title": "interleaving-string-with-dp-solution-c",
                "content": "\\n\\n![image](https://assets.leetcode.com/users/images/ee9cb1ad-88e5-491f-aac7-2ae94816c95d_1622637178.164193.jpeg)\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    // Recursive DP Solution\\n\\t\\n    vector < vector < int > > dp;\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        dp.assign(s1.size() + 1, vector < int > (s2.size() + 1, -1));\\n        return ans(s1, s2, s3, 0, 0, 0);    \\n    }\\n    \\n    bool ans(string s1, string s2, string s3, int idx1, int idx2, int idx3){\\n\\t   if(idx3 == s3.size() && idx1 == s1.size() && idx2 == s2.size()) return true;\\n        if(dp[idx1][idx2] != -1) return dp[idx1][idx2];\\n        bool res = false;\\n        if(s1[idx1] == s3[idx3] && idx1 < s1.size())\\n            res |= ans(s1, s2, s3, idx1 + 1, idx2, idx3 + 1);\\n        if(s2[idx2] == s3[idx3] && idx2 < s2.size())\\n            res |= ans(s1, s2, s3, idx1, idx2 + 1, idx3 + 1);\\n        return dp[idx1][idx2] = res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Recursive DP Solution\\n\\t\\n    vector < vector < int > > dp;\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        dp.assign(s1.size() + 1, vector < int > (s2.size() + 1, -1));\\n        return ans(s1, s2, s3, 0, 0, 0);    \\n    }\\n    \\n    bool ans(string s1, string s2, string s3, int idx1, int idx2, int idx3){\\n\\t   if(idx3 == s3.size() && idx1 == s1.size() && idx2 == s2.size()) return true;\\n        if(dp[idx1][idx2] != -1) return dp[idx1][idx2];\\n        bool res = false;\\n        if(s1[idx1] == s3[idx3] && idx1 < s1.size())\\n            res |= ans(s1, s2, s3, idx1 + 1, idx2, idx3 + 1);\\n        if(s2[idx2] == s3[idx3] && idx2 < s2.size())\\n            res |= ans(s1, s2, s3, idx1, idx2 + 1, idx3 + 1);\\n        return dp[idx1][idx2] = res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246982,
                "title": "interleaving-string-simple-bottom-up-dp-python",
                "content": "Before solving this question I would advice you to solve the longest common subsequence problem and then maybe try this one again. You\\'ll be able to understand the logic better.\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m = len(s1)\\n        n = len(s2)\\n        lenS3 = len(s3)\\n        \\n        if m == 0:\\n            return s2 == s3\\n        elif n == 0:\\n            return s1 == s3\\n        elif lenS3 == 0:\\n            return m + n == 0\\n        elif m + n != lenS3:\\n            return False\\n        \\n        t = [[False] * (n + 1) for i in range(m + 1)]\\n        t[0][0] = True\\n        \\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                # Base conditions\\n                if s1[i-1] == s3[i-1]:\\n                    t[i][0] = t[i-1][0]\\n                \\n                if s2[j-1] == s3[j-1]:\\n                    t[0][j] = t[0][j-1]\\n                \\n                # Main logic - We\\'re taking i + j - 1 in s3 because of 0-index\\n                if s1[i-1] == s3[i+j-1]:\\n                    t[i][j] = t[i-1][j]\\n                \\n                # We do an OR to cover the case that both s1 and s2 match.\\n                # This way we reduce an extra loop.\\n                if s2[j-1] == s3[i+j-1]:\\n                    t[i][j] = t[i][j] or t[i][j-1]\\n        \\n        return t[m][n]\\n```\\n\\nIf you like my approach please consider upvoting. Also, if you have any doubts feel free to ask. \\nThank you.",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m = len(s1)\\n        n = len(s2)\\n        lenS3 = len(s3)\\n        \\n        if m == 0:\\n            return s2 == s3\\n        elif n == 0:\\n            return s1 == s3\\n        elif lenS3 == 0:\\n            return m + n == 0\\n        elif m + n != lenS3:\\n            return False\\n        \\n        t = [[False] * (n + 1) for i in range(m + 1)]\\n        t[0][0] = True\\n        \\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                # Base conditions\\n                if s1[i-1] == s3[i-1]:\\n                    t[i][0] = t[i-1][0]\\n                \\n                if s2[j-1] == s3[j-1]:\\n                    t[0][j] = t[0][j-1]\\n                \\n                # Main logic - We\\'re taking i + j - 1 in s3 because of 0-index\\n                if s1[i-1] == s3[i+j-1]:\\n                    t[i][j] = t[i-1][j]\\n                \\n                # We do an OR to cover the case that both s1 and s2 match.\\n                # This way we reduce an extra loop.\\n                if s2[j-1] == s3[i+j-1]:\\n                    t[i][j] = t[i][j] or t[i][j-1]\\n        \\n        return t[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246814,
                "title": "interleaving-string-rust-dynamic-programming",
                "content": "**Intuition**\\n\\n- We have to use letters in the input order, hence it makes sense to consider prefixes.\\n- Let `dp[i1][i2]` denote the length of the longest prefix of `s3` that we can obtain by interleaving `s1[..i1]` and `s2[..i2]`.\\n- When looking at `dp[i1][i2]` we update `dp[i1 + 1][i2]` if `s1[i1] == s3[i1 + i2]` and  `dp[i1][i2 + 1]` if `s2[i2] == s3[i1 + i2]`.\\n\\n**Complexity**\\n\\n- Time is O(nm).\\n- Space is O(nm).\\n\\n**Implementation**\\n\\n```rust\\nimpl Solution {\\n    pub fn is_interleave(s1: String, s2: String, s3: String) -> bool {\\n        let (l1, l2, l3) = (s1.len(), s2.len(), s3.len());\\n        if l1 + l2 != l3 {\\n            return false;\\n        }\\n\\n        let (s1, s2, s3) = (s1.as_bytes(), s2.as_bytes(), s3.as_bytes());\\n        let mut dp: Vec<Vec<usize>> = vec![vec![0; l2 + 1]; l1 + 1];\\n\\n        for i1 in 0..=l1 {\\n            for i2 in 0..=l2 {\\n                let i3 = i1 + i2;\\n                if i1 < l1 && s1[i1] == s3[i3] {\\n                    dp[i1 + 1][i2] = std::cmp::max(dp[i1 + 1][i2], dp[i1][i2] + 1);\\n                }\\n                if i2 < l2 && s2[i2] == s3[i3] {\\n                    dp[i1][i2 + 1] = std::cmp::max(dp[i1][i2 + 1], dp[i1][i2] + 1);\\n                }\\n            }\\n        }\\n        \\n        dp[l1][l2] == l3\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_interleave(s1: String, s2: String, s3: String) -> bool {\\n        let (l1, l2, l3) = (s1.len(), s2.len(), s3.len());\\n        if l1 + l2 != l3 {\\n            return false;\\n        }\\n\\n        let (s1, s2, s3) = (s1.as_bytes(), s2.as_bytes(), s3.as_bytes());\\n        let mut dp: Vec<Vec<usize>> = vec![vec![0; l2 + 1]; l1 + 1];\\n\\n        for i1 in 0..=l1 {\\n            for i2 in 0..=l2 {\\n                let i3 = i1 + i2;\\n                if i1 < l1 && s1[i1] == s3[i3] {\\n                    dp[i1 + 1][i2] = std::cmp::max(dp[i1 + 1][i2], dp[i1][i2] + 1);\\n                }\\n                if i2 < l2 && s2[i2] == s3[i3] {\\n                    dp[i1][i2 + 1] = std::cmp::max(dp[i1][i2 + 1], dp[i1][i2] + 1);\\n                }\\n            }\\n        }\\n        \\n        dp[l1][l2] == l3\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1246757,
                "title": "explanation-brute-memorization-dp-o-l-m-time-space-dp-o-l-m-time-and-o-m-space",
                "content": "# Brute Force + Memo\\nEx.\\n\\n    s1 = abc  \\n    s2 = abcd\\n\\n    s3 = aabbccd\\n\\n  **Intution:**\\n    For making s3[k] what we have,\\n    suppose we have used s1[0...i) and s2[0...j) for making s3[0...k)\\n    So we have three condition for making s3[k]\\n    1.  s1[i] == s2[j] == s3[k], so we have 2 option\\n        i. whether we use s1[i] to make s3[k], \\n        ii. or we can use s2[j] to make s3[k]\\n    2. if none of s1[i] and s2[j] is able to make s3[k]\\n        i. We can\\'t make s3 for now.\\n    3. If s1[i] is able to make s3[k] then use s1[i] else use s2[j]\\n    \\n    vector<vector<int>> dp;\\n    bool solve(string& s1, string& s2, string& s3, int i, int j, int k) {\\n        if (k == s3.size()) {\\n            return i == s1.size() && j == s2.size();\\n        }\\n\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n\\n        if (i >= s1.size()) {\\n            if (s2[j] != s3[k]) {\\n                return dp[i][j] = false;\\n            } else {\\n                return dp[i][j] = solve(s1, s2, s3, i, j + 1, k + 1);\\n            }\\n        } else if (j >= s2.size()) {\\n            if (s1[i] != s3[k]) {\\n                return dp[i][j] = false;\\n            } else {\\n                return dp[i][j] = solve(s1, s2, s3, i + 1, j, k + 1);\\n            }\\n        } else {\\n            if (s1[i] != s3[k] && s2[j] != s3[k]) {\\n                return dp[i][j] = false;\\n            }\\n        }\\n\\n        bool ans = false;\\n        if (s1[i] == s2[j]) {\\n            ans |= solve(s1, s2, s3, i + 1, j, k + 1);\\n            ans |= solve(s1, s2, s3, i, j + 1, k + 1);\\n        } else {\\n            if (s1[i] == s3[k]) {\\n                ans |= solve(s1, s2, s3, i + 1, j, k + 1);\\n            } else {\\n                ans |= solve(s1, s2, s3, i, j + 1, k + 1);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n\\t\\n**Time Complexity :**\\n O(2^(L+M)), without memorization  but using memorization O(L*M)\\n **Space Complexity:**\\n O(L*M) Size of dp\\n# \\tIterative Dp\\n    If we look carefully recursive solution then how dp is filling.\\n    dp[i][j] is filled by \\n    1. solve(i+1,j,k+1) || solve(i,j+1,k+1) // When both s1[i] and s2[i] is able to make s3[k]\\n    2. solve(i+1,j,k+1) // When only s1[i] only able to make s3[k]\\n    3. solve(i,j+1, k + 1) // When only s2[j] only able to make s3[k]\\n\\n    So we can fill dp iterative also\\n\\t\\n\\t\\n\\tbool solve(string s1, string s2, string s3) {\\n        int l = s1.size(), m = s2.size(), n = s3.size();\\n        if (l + m != n) return false;\\n\\n        vector<vector<bool>> dp(l + 1, vector<bool>(m + 1));\\n\\n        for (int i = 0; i <= l; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = true;\\n                } else if (i == 0) {\\n                    dp[i][j] = (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n                } else if (j == 0) {\\n                    dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]);\\n                } else {\\n                    dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n                }\\n            }\\n        }\\n        return dp[l][m];\\n    }\\n\\t\\n# \\tO(M) space dp\\nNow if we look the dependency of dp[i][j] then\\n    dp[i][j] -> dp[i-1][j], dp[i][j-1] only, so we can skip all the remove which are less than i-1 because we don\\'t need them\\n\\t```\\n\\t    bool solve(string s1, string s2, string s3) {\\n        int l = s1.size(), m = s2.size(), n = s3.size(), flag = 1;\\n        vector<vector<bool>> dp(2, vector<bool>(m + 1));\\n\\n        for (int i = 0; i <= l; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[flag][j] = true;\\n                } else if (i == 0) {\\n                    dp[flag][j] = (dp[flag ^ 1][j] && (s2[j - 1] == s3[i + j - 1]));\\n                } else if (j == 0) {\\n                    dp[flag][j] = (dp[flag ^ 1])[j] && (s1[i - 1] == s3[i + j - 1]);\\n                } else {\\n                    dp[flag][j] = ((dp[flag ^ 1][j] && s1[i - 1] == s3[i + j - 1]) || (dp[flag][j - 1] && (s2[j - 1] == s3[i + j - 1])));\\n                }\\n            }\\n            flag ^= 1;\\n        }\\n        return dp[flag ^ 1][m];\\n    }\\n\\t\\n\\nHappy Coding !!!",
                "solutionTags": [],
                "code": "# Brute Force + Memo\\nEx.\\n\\n    s1 = abc  \\n    s2 = abcd\\n\\n    s3 = aabbccd\\n\\n  **Intution:**\\n    For making s3[k] what we have,\\n    suppose we have used s1[0...i) and s2[0...j) for making s3[0...k)\\n    So we have three condition for making s3[k]\\n    1.  s1[i] == s2[j] == s3[k], so we have 2 option\\n        i. whether we use s1[i] to make s3[k], \\n        ii. or we can use s2[j] to make s3[k]\\n    2. if none of s1[i] and s2[j] is able to make s3[k]\\n        i. We can\\'t make s3 for now.\\n    3. If s1[i] is able to make s3[k] then use s1[i] else use s2[j]\\n    \\n    vector<vector<int>> dp;\\n    bool solve(string& s1, string& s2, string& s3, int i, int j, int k) {\\n        if (k == s3.size()) {\\n            return i == s1.size() && j == s2.size();\\n        }\\n\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n\\n        if (i >= s1.size()) {\\n            if (s2[j] != s3[k]) {\\n                return dp[i][j] = false;\\n            } else {\\n                return dp[i][j] = solve(s1, s2, s3, i, j + 1, k + 1);\\n            }\\n        } else if (j >= s2.size()) {\\n            if (s1[i] != s3[k]) {\\n                return dp[i][j] = false;\\n            } else {\\n                return dp[i][j] = solve(s1, s2, s3, i + 1, j, k + 1);\\n            }\\n        } else {\\n            if (s1[i] != s3[k] && s2[j] != s3[k]) {\\n                return dp[i][j] = false;\\n            }\\n        }\\n\\n        bool ans = false;\\n        if (s1[i] == s2[j]) {\\n            ans |= solve(s1, s2, s3, i + 1, j, k + 1);\\n            ans |= solve(s1, s2, s3, i, j + 1, k + 1);\\n        } else {\\n            if (s1[i] == s3[k]) {\\n                ans |= solve(s1, s2, s3, i + 1, j, k + 1);\\n            } else {\\n                ans |= solve(s1, s2, s3, i, j + 1, k + 1);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n\\t\\n**Time Complexity :**\\n O(2^(L+M)), without memorization  but using memorization O(L*M)\\n **Space Complexity:**\\n O(L*M) Size of dp\\n# \\tIterative Dp\\n    If we look carefully recursive solution then how dp is filling.\\n    dp[i][j] is filled by \\n    1. solve(i+1,j,k+1) || solve(i,j+1,k+1) // When both s1[i] and s2[i] is able to make s3[k]\\n    2. solve(i+1,j,k+1) // When only s1[i] only able to make s3[k]\\n    3. solve(i,j+1, k + 1) // When only s2[j] only able to make s3[k]\\n\\n    So we can fill dp iterative also\\n\\t\\n\\t\\n\\tbool solve(string s1, string s2, string s3) {\\n        int l = s1.size(), m = s2.size(), n = s3.size();\\n        if (l + m != n) return false;\\n\\n        vector<vector<bool>> dp(l + 1, vector<bool>(m + 1));\\n\\n        for (int i = 0; i <= l; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = true;\\n                } else if (i == 0) {\\n                    dp[i][j] = (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n                } else if (j == 0) {\\n                    dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]);\\n                } else {\\n                    dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n                }\\n            }\\n        }\\n        return dp[l][m];\\n    }\\n\\t\\n# \\tO(M) space dp\\nNow if we look the dependency of dp[i][j] then\\n    dp[i][j] -> dp[i-1][j], dp[i][j-1] only, so we can skip all the remove which are less than i-1 because we don\\'t need them\\n\\t```\\n\\t    bool solve(string s1, string s2, string s3) {\\n        int l = s1.size(), m = s2.size(), n = s3.size(), flag = 1;\\n        vector<vector<bool>> dp(2, vector<bool>(m + 1));\\n\\n        for (int i = 0; i <= l; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[flag][j] = true;\\n                } else if (i == 0) {\\n                    dp[flag][j] = (dp[flag ^ 1][j] && (s2[j - 1] == s3[i + j - 1]));\\n                } else if (j == 0) {\\n                    dp[flag][j] = (dp[flag ^ 1])[j] && (s1[i - 1] == s3[i + j - 1]);\\n                } else {\\n                    dp[flag][j] = ((dp[flag ^ 1][j] && s1[i - 1] == s3[i + j - 1]) || (dp[flag][j - 1] && (s2[j - 1] == s3[i + j - 1])));\\n                }\\n            }\\n            flag ^= 1;\\n        }\\n        return dp[flag ^ 1][m];\\n    }\\n\\t\\n\\nHappy Coding !!!",
                "codeTag": "Unknown"
            },
            {
                "id": 1079837,
                "title": "c-0ms-100-recursion-memorization-with-comments",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Interleaving String.\\nMemory Usage: 7.3 MB, less than 37.03% of C++ online submissions for Interleaving String.\\n```\\nclass Solution {\\npublic:\\n  int n1,n2,n3;\\n  set<pair<int,int>> st;                              //for memorization\\n  \\n  bool helper(string &s1, string &s2, string &s3, int i1, int i2, int i3){    \\n    if(st.count({i1,i2})) return false;                                       //if we already attend this variant \\n    \\n    while(n1 != i1 || n2 != i2){\\n      \\n      if(n1 != i1 && n2 != i2 && s1[i1] == s2[i2] && s1[i1] == s3[i3]){       //if we have to use letters from two words\\n        st.insert({i1,i2});                                                   //check it situation\\n        return helper(s1, s2, s3, i1 + 1, i2 , i3 + 1) ||                     //and consider two possibilities\\n          helper(s1, s2, s3, i1 , i2 + 1 , i3 + 1);\\n      }\\n      if(n1 != i1 && s1[i1] == s3[i3]){i1++;i3++;continue;}                   //if use letter only from one word\\n      if(n2 != i2 && s2[i2] == s3[i3]){i2++;i3++;continue;}\\n      return false;\\n    }\\n    \\n    return true;                                                              //FINISH !!!!!!\\n  }\\n  \\n  \\n  bool isInterleave(string s1, string s2, string s3) {\\n    n1 = s1.size(), n2 = s2.size(), n3 = s3.size();\\n    if(n1 + n2 != n3) return false;\\n   \\n    return helper(s1,s2,s3,0,0,0);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int n1,n2,n3;\\n  set<pair<int,int>> st;                              //for memorization\\n  \\n  bool helper(string &s1, string &s2, string &s3, int i1, int i2, int i3){    \\n    if(st.count({i1,i2})) return false;                                       //if we already attend this variant \\n    \\n    while(n1 != i1 || n2 != i2){\\n      \\n      if(n1 != i1 && n2 != i2 && s1[i1] == s2[i2] && s1[i1] == s3[i3]){       //if we have to use letters from two words\\n        st.insert({i1,i2});                                                   //check it situation\\n        return helper(s1, s2, s3, i1 + 1, i2 , i3 + 1) ||                     //and consider two possibilities\\n          helper(s1, s2, s3, i1 , i2 + 1 , i3 + 1);\\n      }\\n      if(n1 != i1 && s1[i1] == s3[i3]){i1++;i3++;continue;}                   //if use letter only from one word\\n      if(n2 != i2 && s2[i2] == s3[i3]){i2++;i3++;continue;}\\n      return false;\\n    }\\n    \\n    return true;                                                              //FINISH !!!!!!\\n  }\\n  \\n  \\n  bool isInterleave(string s1, string s2, string s3) {\\n    n1 = s1.size(), n2 = s2.size(), n3 = s3.size();\\n    if(n1 + n2 != n3) return false;\\n   \\n    return helper(s1,s2,s3,0,0,0);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933323,
                "title": "dfs-dp-progression-with-explanation-o-s1-s2-o-s1-s2",
                "content": "In this problem, we are tasked to see if `s3` can be broken down into `s1` and `s2` where `s1` and `s2` have to be used from front to back.  Therefore to find the solution, let\\'s look at all possible combinations of breaking down `s3` given `s1` and `s2`.  DFS is a great tool for this as it allows us to express an instance of a function as the current state, and the recursive calls as actions to future states.  To start out, the best approach is to draw a DFS tree.\\n![image](https://assets.leetcode.com/users/images/8a501cca-f3a5-43f5-b047-b9f57af55712_1605200826.533606.png)\\nAt each step, we check if the first character of `s1` and/or `s2` match the first character of `s3` and recurse downwards if there is a match.  This translates well to code, and looks like\\n```\\ndef dfs(s1, s2, s3):\\n\\tif not s1:\\n\\t\\treturn s2 == s3\\n\\tif not s2:\\n\\t\\treturn s1 == s3\\n\\tif not s3:\\n\\t\\treturn True\\n\\n\\tleft = right = False\\n\\tif s1[0] == s3[0]:\\n\\t\\tleft = dfs(s1[1:], s2, s3[1:])\\n\\tif s2[0] == s3[0]:\\n\\t\\tright = dfs(s1, s2[1:], s3[1:])\\n\\treturn left or right\\nreturn dfs(s1, s2, s3)\\n```\\nIt may not exactly help us solve this problem, but notice that the solution can also be seen as finding a root -> leaf path of length `s3`.  It seems this is a very common pattern in DFS, and it makes sense why.  The tree recurses down until it hits a base case, which indicates success or failure, depending on the base case.  This DFS approach will solve the problem, but takes far too long and times out on larger inputs.  Why is that?\\nNotice in the DFS tree, after two steps, both branches have the state `s1 = b, s2 = c, s3 = bc`.  From this point onwards, the rest of the calculation will return the same answer.  However our implementation of DFS is unaware of this and will waste time calculating the answer separately for both branches.  This becomes exponentially worse as the input sizes grow and the DFS tree becomes larger.  This is where the DP solution comes in.\\n\\nThe DFS approach solves the problem from the top down, meaning it must recurse all the way to a base case before there is any idea of a solution.  Instead, let\\'s build the solution from the ground up, saving the answer to subproblems as we solve them.  Therefore instead of spending time recalculating them, we can simply reference them when needed.\\n```\\ndef dp(s1, s2, s3):\\n\\tA = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\\n\\t# Base cases\\n\\tA[0][0] = True\\n\\tfor i in range(1, len(s1) + 1):\\n\\t\\tA[i][0] = A[i - 1][0] and s1[i - 1] == s3[i - 1]\\n\\tfor j in range(1, len(s2) + 1):\\n\\t\\tA[0][j] = A[0][j - 1] and s2[j - 1] == s3[j - 1]\\n\\n\\tfor i in range(1, len(s1) + 1):\\n\\t\\tfor j in range(1, len(s2) + 1):                    \\n\\t\\t\\tif s1[i - 1] == s3[i - 1 + j]:\\n\\t\\t\\t\\tA[i][j] = A[i - 1][j]\\n\\t\\t\\tif s2[j - 1] == s3[i - 1 + j]:\\n\\t\\t\\t\\tA[i][j] = A[i][j] or A[i][j - 1]\\n\\treturn A[-1][-1]\\nreturn dp(s1, s2, s3)\\n```\\nNotice that the recursion relation and base cases we are using are essentially the same as we found in the DFS approach.  We check if the first character of `s1` and/or `s2` match the first character of `s3`, and simply reference the smaller subproblem that was already solved.  This technique is like building the DFS tree from bottom up, and gives us our solution.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndef dfs(s1, s2, s3):\\n\\tif not s1:\\n\\t\\treturn s2 == s3\\n\\tif not s2:\\n\\t\\treturn s1 == s3\\n\\tif not s3:\\n\\t\\treturn True\\n\\n\\tleft = right = False\\n\\tif s1[0] == s3[0]:\\n\\t\\tleft = dfs(s1[1:], s2, s3[1:])\\n\\tif s2[0] == s3[0]:\\n\\t\\tright = dfs(s1, s2[1:], s3[1:])\\n\\treturn left or right\\nreturn dfs(s1, s2, s3)\\n```\n```\\ndef dp(s1, s2, s3):\\n\\tA = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\\n\\t# Base cases\\n\\tA[0][0] = True\\n\\tfor i in range(1, len(s1) + 1):\\n\\t\\tA[i][0] = A[i - 1][0] and s1[i - 1] == s3[i - 1]\\n\\tfor j in range(1, len(s2) + 1):\\n\\t\\tA[0][j] = A[0][j - 1] and s2[j - 1] == s3[j - 1]\\n\\n\\tfor i in range(1, len(s1) + 1):\\n\\t\\tfor j in range(1, len(s2) + 1):                    \\n\\t\\t\\tif s1[i - 1] == s3[i - 1 + j]:\\n\\t\\t\\t\\tA[i][j] = A[i - 1][j]\\n\\t\\t\\tif s2[j - 1] == s3[i - 1 + j]:\\n\\t\\t\\t\\tA[i][j] = A[i][j] or A[i][j - 1]\\n\\treturn A[-1][-1]\\nreturn dp(s1, s2, s3)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 921322,
                "title": "java-0-ms-recursion-with-memoization-two-solutions-with-comments",
                "content": "Without memoization\\n```\\nclass Solution {\\n   public boolean isInterleave(String s1, String s2, String s3) {\\n        return isInterleave(s1, s2, s3, 0, 0, 0);\\n    }\\n\\n    public boolean isInterleave(String s1, String s2, String s3, int idx1, int idx2, int idx3) {\\n\\n\\t\\t//if we have reached the end of all the strings - found the answer\\n        if (idx3 == s3.length() && idx1 == s1.length() && idx2 == s2.length()) return true;\\n\\n\\t\\t//compare the character of s3 with s1\\n\\t\\t//if same - recursively check for other characters with s3 index+1   and    s1 index+1\\n\\t\\t//if not same compare the same character of s3 with s2\\n        if (idx1 < s1.length()  && idx3 < s3.length()  && s3.charAt(idx3) == s1.charAt(idx1)) {\\n            boolean result = isInterleave(s1, s2, s3, idx1 + 1, idx2, idx3 + 1);\\n            if (result) return true;\\n        }\\n\\n\\t\\t//compare the character of s3 with s2\\n\\t\\t//if same - recursively check for other characters with s3 index+1   and    s2 index+1\\n\\t\\t//if not same return false\\n        if (idx2 < s2.length() && idx3 < s3.length()  && s3.charAt(idx3) == s2.charAt(idx2)) {\\n            boolean result = isInterleave(s1, s2, s3, idx1, idx2 + 1, idx3 + 1);\\n            if (result) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n----------------------------------------------------------\\n\\nDoing the same logic as above but saving the computed results to an array\\n\\n**With memoization**\\n```\\nclass Solution {\\n   public boolean isInterleave(String s1, String s2, String s3) {\\n       Boolean[][] dp = new Boolean[s1.length()+1][s2.length()+1];\\n        return isInterleave(s1, s2, s3, 0, 0, 0, dp);\\n    }\\n\\n    public boolean isInterleave(String s1, String s2, String s3, int idx1, int idx2, int idx3, Boolean[][] dp) {\\n\\n        if(dp[idx1][idx2] != null) return dp[idx1][idx2];\\n        \\n        if (idx3 == s3.length() && idx1 == s1.length() && idx2 == s2.length()) return true;\\n\\n        if (idx1 < s1.length()  && idx3 < s3.length()  && s3.charAt(idx3) == s1.charAt(idx1)) {\\n            boolean result = isInterleave(s1, s2, s3, idx1 + 1, idx2, idx3 + 1, dp);\\n            dp[idx1][idx2] = result;\\n            if (result) return dp[idx1][idx2];\\n        }\\n\\n        if (idx2 < s2.length() && idx3 < s3.length()  && s3.charAt(idx3) == s2.charAt(idx2)) {\\n            boolean result = isInterleave(s1, s2, s3, idx1, idx2 + 1, idx3 + 1, dp);\\n            dp[idx1][idx2] = result;\\n            if (result) return dp[idx1][idx2];\\n        }\\n        \\n        dp[idx1][idx2] = false;\\n\\n        return dp[idx1][idx2];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public boolean isInterleave(String s1, String s2, String s3) {\\n        return isInterleave(s1, s2, s3, 0, 0, 0);\\n    }\\n\\n    public boolean isInterleave(String s1, String s2, String s3, int idx1, int idx2, int idx3) {\\n\\n\\t\\t//if we have reached the end of all the strings - found the answer\\n        if (idx3 == s3.length() && idx1 == s1.length() && idx2 == s2.length()) return true;\\n\\n\\t\\t//compare the character of s3 with s1\\n\\t\\t//if same - recursively check for other characters with s3 index+1   and    s1 index+1\\n\\t\\t//if not same compare the same character of s3 with s2\\n        if (idx1 < s1.length()  && idx3 < s3.length()  && s3.charAt(idx3) == s1.charAt(idx1)) {\\n            boolean result = isInterleave(s1, s2, s3, idx1 + 1, idx2, idx3 + 1);\\n            if (result) return true;\\n        }\\n\\n\\t\\t//compare the character of s3 with s2\\n\\t\\t//if same - recursively check for other characters with s3 index+1   and    s2 index+1\\n\\t\\t//if not same return false\\n        if (idx2 < s2.length() && idx3 < s3.length()  && s3.charAt(idx3) == s2.charAt(idx2)) {\\n            boolean result = isInterleave(s1, s2, s3, idx1, idx2 + 1, idx3 + 1);\\n            if (result) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n   public boolean isInterleave(String s1, String s2, String s3) {\\n       Boolean[][] dp = new Boolean[s1.length()+1][s2.length()+1];\\n        return isInterleave(s1, s2, s3, 0, 0, 0, dp);\\n    }\\n\\n    public boolean isInterleave(String s1, String s2, String s3, int idx1, int idx2, int idx3, Boolean[][] dp) {\\n\\n        if(dp[idx1][idx2] != null) return dp[idx1][idx2];\\n        \\n        if (idx3 == s3.length() && idx1 == s1.length() && idx2 == s2.length()) return true;\\n\\n        if (idx1 < s1.length()  && idx3 < s3.length()  && s3.charAt(idx3) == s1.charAt(idx1)) {\\n            boolean result = isInterleave(s1, s2, s3, idx1 + 1, idx2, idx3 + 1, dp);\\n            dp[idx1][idx2] = result;\\n            if (result) return dp[idx1][idx2];\\n        }\\n\\n        if (idx2 < s2.length() && idx3 < s3.length()  && s3.charAt(idx3) == s2.charAt(idx2)) {\\n            boolean result = isInterleave(s1, s2, s3, idx1, idx2 + 1, idx3 + 1, dp);\\n            dp[idx1][idx2] = result;\\n            if (result) return dp[idx1][idx2];\\n        }\\n        \\n        dp[idx1][idx2] = false;\\n\\n        return dp[idx1][idx2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815959,
                "title": "java-simple-dp-memo",
                "content": "```\\nclass Solution {\\n    HashMap<String, Boolean> map;\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        map = new HashMap();\\n        return find(s1, s2, s3, s1.length()-1, s2.length()-1, s3.length()-1);\\n    }\\n    \\n    boolean find(String a, String b, String c, int i, int j, int k){\\n        \\n        \\n        if( i == -1 && j == -1 && k == -1)  return true;\\n        String key = i+\"-\"+j+\"-\"+k;\\n        \\n        if( map.containsKey(key))   return map.get(key);\\n         \\n        if( i >= 0 && j >= 0 && k >= 0 && a.charAt(i) == b.charAt(j) && b.charAt(j) == c.charAt(k) ){\\n            boolean temp = find(a, b, c, i-1, j, k-1) || find(a, b, c, i, j-1, k-1);\\n            map.put(key, temp);\\n            return temp;\\n            \\n        }\\n        \\n        \\n        if( i >= 0 && k >= 0 && a.charAt(i) == c.charAt(k) ){\\n            boolean temp = find(a, b, c, i-1, j, k-1);\\n            map.put(key, temp);\\n            return temp;\\n        }\\n        \\n        if( j >= 0 && k >= 0 && b.charAt(j) == c.charAt(k) ){\\n            boolean temp = find(a, b, c, i, j-1, k-1);\\n            map.put(key, temp);\\n            return temp;\\n        }\\n        \\n        return false;\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String, Boolean> map;\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        map = new HashMap();\\n        return find(s1, s2, s3, s1.length()-1, s2.length()-1, s3.length()-1);\\n    }\\n    \\n    boolean find(String a, String b, String c, int i, int j, int k){\\n        \\n        \\n        if( i == -1 && j == -1 && k == -1)  return true;\\n        String key = i+\"-\"+j+\"-\"+k;\\n        \\n        if( map.containsKey(key))   return map.get(key);\\n         \\n        if( i >= 0 && j >= 0 && k >= 0 && a.charAt(i) == b.charAt(j) && b.charAt(j) == c.charAt(k) ){\\n            boolean temp = find(a, b, c, i-1, j, k-1) || find(a, b, c, i, j-1, k-1);\\n            map.put(key, temp);\\n            return temp;\\n            \\n        }\\n        \\n        \\n        if( i >= 0 && k >= 0 && a.charAt(i) == c.charAt(k) ){\\n            boolean temp = find(a, b, c, i-1, j, k-1);\\n            map.put(key, temp);\\n            return temp;\\n        }\\n        \\n        if( j >= 0 && k >= 0 && b.charAt(j) == c.charAt(k) ){\\n            boolean temp = find(a, b, c, i, j-1, k-1);\\n            map.put(key, temp);\\n            return temp;\\n        }\\n        \\n        return false;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 705691,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        memo = {}\\n        return self.helper(s1, s2, s3, 0, 0, 0, \\'\\', {})\\n        \\n    \\n    def helper(self, s1, s2, s3, index1, index2, index3, current, memo):\\n        if current == s3 and index1 == len(s1) and index2 == len(s2):\\n            return True\\n        if current and current[-1] != s3[index3 - 1]:\\n            return False\\n        ans = False\\n        if (index1, index2) in memo:\\n            return memo[(index1, index2)]\\n        if index1 < len(s1):\\n            ans = ans or self.helper(s1, s2, s3, index1 + 1, index2, index3 + 1, current + s1[index1], memo)\\n        if index2 < len(s2):\\n            ans = ans or self.helper(s1, s2, s3, index1, index2 + 1, index3 + 1, current + s2[index2], memo)\\n        \\n        memo[(index1, index2)] = ans\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        memo = {}\\n        return self.helper(s1, s2, s3, 0, 0, 0, \\'\\', {})\\n        \\n    \\n    def helper(self, s1, s2, s3, index1, index2, index3, current, memo):\\n        if current == s3 and index1 == len(s1) and index2 == len(s2):\\n            return True\\n        if current and current[-1] != s3[index3 - 1]:\\n            return False\\n        ans = False\\n        if (index1, index2) in memo:\\n            return memo[(index1, index2)]\\n        if index1 < len(s1):\\n            ans = ans or self.helper(s1, s2, s3, index1 + 1, index2, index3 + 1, current + s1[index1], memo)\\n        if index2 < len(s2):\\n            ans = ans or self.helper(s1, s2, s3, index1, index2 + 1, index3 + 1, current + s2[index2], memo)\\n        \\n        memo[(index1, index2)] = ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687639,
                "title": "python3-top-down-dp",
                "content": "\\n\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False \\n        \\n        @cache\\n        def fn(i, j): \\n            \"\"\"Return True if s3[i+j:] is formed by interleaving s1[i:] and s2[j:]\"\"\"\\n            if i == len(s1) and j == len(s2): return True\\n            ans = False\\n            if i < len(s1) and s1[i] == s3[i+j]: ans = ans or fn(i+1, j)\\n            if j < len(s2) and s2[j] == s3[i+j]: ans = ans or fn(i, j+1)\\n            return ans \\n        \\n        return fn(0, 0)\\n```\\n\\nEdited on 6/2/2021\\nAdding bottom-up implementation \\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False \\n        \\n        dp = [False]*len(s2) + [True]\\n        for i in reversed(range(len(s1)+1)): \\n            for j in reversed(range(len(s2)+1)): \\n                if i < len(s1): dp[j] = (dp[j] and s1[i] == s3[i+j])\\n                if j < len(s2): dp[j] = dp[j] or (dp[j+1] and s2[j] == s3[i+j])\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False \\n        \\n        @cache\\n        def fn(i, j): \\n            \"\"\"Return True if s3[i+j:] is formed by interleaving s1[i:] and s2[j:]\"\"\"\\n            if i == len(s1) and j == len(s2): return True\\n            ans = False\\n            if i < len(s1) and s1[i] == s3[i+j]: ans = ans or fn(i+1, j)\\n            if j < len(s2) and s2[j] == s3[i+j]: ans = ans or fn(i, j+1)\\n            return ans \\n        \\n        return fn(0, 0)\\n```\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False \\n        \\n        dp = [False]*len(s2) + [True]\\n        for i in reversed(range(len(s1)+1)): \\n            for j in reversed(range(len(s2)+1)): \\n                if i < len(s1): dp[j] = (dp[j] and s1[i] == s3[i+j])\\n                if j < len(s2): dp[j] = dp[j] or (dp[j+1] and s2[j] == s3[i+j])\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526481,
                "title": "c-0ms-top-down-and-bottom-up-dp-solutions-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/interleaving-string/submissions/\\n    \\n    Solutions:\\n    1. Top-down, TC: O(MN)\\n    2. Bottom-up, TC: O(MN)\\n*/\\n\\nclass Solution {\\npublic:\\n    // Checks if interleaves using top-down DP\\n    /*\\n        If the string interleaves, then that means the entire s1 and s2 will be used \\n        for making s3. So len(s1) + len(s2) = len(s3).\\n        So till any pos. k in s3, we would have used i of s1 and j of s2.\\n        So we track if string till (i + j) interleaves with s3[i+j-1]\\n        \\n        TC: O(MN)\\n    */\\n    bool isInterleaveMem(int i, int j, int k, string& s1, string& s2, string& s3,\\n                        vector<vector<int>>& dp) {\\n        // when the total char length is zero\\n        // also check if s1 and s2 has ended as well\\n        if(k == 0)\\n            return (i || j) ? false : true;\\n        \\n        if(dp[i][j] == -1) {\\n            // do dfs with the string whose current char matches s3\\n            dp[i][j] = (i-1) >= 0 && s1[i-1] == s3[k-1] && isInterleaveMem(i-1, j, k-1, s1, s2, s3, dp) ||\\n                        (j-1) >= 0 && s2[j-1] == s3[k-1] && isInterleaveMem(i, j-1, k-1, s1, s2, s3, dp);\\n        }\\n        return dp[i][j];\\n    }\\n    \\n    bool isInterleaveMemDriver(string& s1, string& s2, string& s3) {\\n        int M = s1.size(), N = s2.size(), K = s3.size();\\n        // the strings interleaves only if the sum of string lengths match\\n        if(M + N != K)\\n            return false;\\n        \\n        // dp(i, j): if string till s[i+j-1] interleaves till s1[i] and s2[j]  \\n        vector<vector<int>> dp(M + 1, vector<int>(N + 1, -1));\\n        return isInterleaveMem(M, N, K, s1, s2, s3, dp);\\n    }\\n    \\n    // Checks if interleaves using bottom-up DP\\n    /*\\n        If the string interleaves, then that means the entire s1 and s2 will be used \\n        for making s3. So len(s1) + len(s2) = len(s3).\\n        So till any pos. k in s3, we would have used i of s1 and j of s2.\\n        So we track if string till (i + j) interleaves with s3[i+j-1]\\n        \\n        TC: O(MN)\\n    */\\n    bool isInterleaveTab(string& s1, string& s2, string& s3) {\\n        const int M = s1.size(), N = s2.size();\\n        // the strings interleaves only if the sum of string lengths match\\n        if(M + N != s3.size())\\n            return false;\\n        \\n        // dp(i, j): if string till s[i+j-1] interleaves till s1[i] and s2[j]  \\n        vector<vector<bool>> dp(M + 1, vector<bool>(N + 1, false));\\n        // when s1, s2 and s3 are empty\\n        dp[0][0] = true;\\n        // when s2 is empty\\n        for(int i = 1; i <= M; i++)\\n            dp[i][0] = dp[i-1][0] && s3[i-1] == s1[i-1];\\n        // when s1 is empty\\n        for(int i = 1; i <= N; i++)\\n            dp[0][i] = dp[0][i-1] && s3[i-1] == s2[i-1];\\n    \\n        for(int i = 1; i <= M; i++)\\n            for(int j = 1; j <= N; j++)\\n                // s3 interleaves if till the current length it was interleaving and one of chars from\\n                // s1 or s2 match the current position in s3\\n                dp[i][j] = (s1[i-1] == s3[i+j-1] && dp[i-1][j]) ||\\n                            (s2[j-1] == s3[i+j-1] && dp[i][j-1]);\\n        \\n        return dp[M][N];\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        //return isInterleaveTab(s1, s2, s3);\\n         return isInterleaveMemDriver(s1, s2, s3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/interleaving-string/submissions/\\n    \\n    Solutions:\\n    1. Top-down, TC: O(MN)\\n    2. Bottom-up, TC: O(MN)\\n*/\\n\\nclass Solution {\\npublic:\\n    // Checks if interleaves using top-down DP\\n    /*\\n        If the string interleaves, then that means the entire s1 and s2 will be used \\n        for making s3. So len(s1) + len(s2) = len(s3).\\n        So till any pos. k in s3, we would have used i of s1 and j of s2.\\n        So we track if string till (i + j) interleaves with s3[i+j-1]\\n        \\n        TC: O(MN)\\n    */\\n    bool isInterleaveMem(int i, int j, int k, string& s1, string& s2, string& s3,\\n                        vector<vector<int>>& dp) {\\n        // when the total char length is zero\\n        // also check if s1 and s2 has ended as well\\n        if(k == 0)\\n            return (i || j) ? false : true;\\n        \\n        if(dp[i][j] == -1) {\\n            // do dfs with the string whose current char matches s3\\n            dp[i][j] = (i-1) >= 0 && s1[i-1] == s3[k-1] && isInterleaveMem(i-1, j, k-1, s1, s2, s3, dp) ||\\n                        (j-1) >= 0 && s2[j-1] == s3[k-1] && isInterleaveMem(i, j-1, k-1, s1, s2, s3, dp);\\n        }\\n        return dp[i][j];\\n    }\\n    \\n    bool isInterleaveMemDriver(string& s1, string& s2, string& s3) {\\n        int M = s1.size(), N = s2.size(), K = s3.size();\\n        // the strings interleaves only if the sum of string lengths match\\n        if(M + N != K)\\n            return false;\\n        \\n        // dp(i, j): if string till s[i+j-1] interleaves till s1[i] and s2[j]  \\n        vector<vector<int>> dp(M + 1, vector<int>(N + 1, -1));\\n        return isInterleaveMem(M, N, K, s1, s2, s3, dp);\\n    }\\n    \\n    // Checks if interleaves using bottom-up DP\\n    /*\\n        If the string interleaves, then that means the entire s1 and s2 will be used \\n        for making s3. So len(s1) + len(s2) = len(s3).\\n        So till any pos. k in s3, we would have used i of s1 and j of s2.\\n        So we track if string till (i + j) interleaves with s3[i+j-1]\\n        \\n        TC: O(MN)\\n    */\\n    bool isInterleaveTab(string& s1, string& s2, string& s3) {\\n        const int M = s1.size(), N = s2.size();\\n        // the strings interleaves only if the sum of string lengths match\\n        if(M + N != s3.size())\\n            return false;\\n        \\n        // dp(i, j): if string till s[i+j-1] interleaves till s1[i] and s2[j]  \\n        vector<vector<bool>> dp(M + 1, vector<bool>(N + 1, false));\\n        // when s1, s2 and s3 are empty\\n        dp[0][0] = true;\\n        // when s2 is empty\\n        for(int i = 1; i <= M; i++)\\n            dp[i][0] = dp[i-1][0] && s3[i-1] == s1[i-1];\\n        // when s1 is empty\\n        for(int i = 1; i <= N; i++)\\n            dp[0][i] = dp[0][i-1] && s3[i-1] == s2[i-1];\\n    \\n        for(int i = 1; i <= M; i++)\\n            for(int j = 1; j <= N; j++)\\n                // s3 interleaves if till the current length it was interleaving and one of chars from\\n                // s1 or s2 match the current position in s3\\n                dp[i][j] = (s1[i-1] == s3[i+j-1] && dp[i-1][j]) ||\\n                            (s2[j-1] == s3[i+j-1] && dp[i][j-1]);\\n        \\n        return dp[M][N];\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        //return isInterleaveTab(s1, s2, s3);\\n         return isInterleaveMemDriver(s1, s2, s3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518963,
                "title": "simple-python-dfs",
                "content": "```python\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    @lru_cache()\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:        \\n        if s1 == \\'\\': return s2 == s3\\n        if s2 == \\'\\': return s1 == s3\\n\\n        return ( s3[0] == s1[0] and self.isInterleave(s1[1:], s2, s3[1:]) ) \\\\\\n            or ( s3[0] == s2[0] and self.isInterleave(s1, s2[1:], s3[1:]) )\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    @lru_cache()\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:        \\n        if s1 == \\'\\': return s2 == s3\\n        if s2 == \\'\\': return s1 == s3\\n\\n        return ( s3[0] == s1[0] and self.isInterleave(s1[1:], s2, s3[1:]) ) \\\\\\n            or ( s3[0] == s2[0] and self.isInterleave(s1, s2[1:], s3[1:]) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 214113,
                "title": "dp-solution-with-intuition-in-java",
                "content": "```\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        // dp[i][j] = true, means first i characters of s1 and first j characters of s2 interleaved to form i+j characters of s3\\n        // intuition dp[i][j] = true, if(dp[i-1][j] = true and ith char of s1 = (i+j)th char of s3 or dp[i][j-1] = true and jth character of s2 = (i+j)th char of s3\\n        \\n        int m = s1.length();\\n        int n = s2.length();\\n        int t = s3.length();\\n        \\n        if(t==0) return true;\\n        if(m+n != t) return false;\\n        else if(m==0 && n==0 && t!=0) return false;\\n        else if(m==0 && n!=0 )\\n        {\\n            if(s2.equals(s3))\\n                return true;\\n            else\\n                return false;\\n        }\\n        else if(m!=0 && n==0)\\n        {\\n            if(s1.equals(s3))\\n                return true;\\n            else\\n                return false;\\n        }\\n            \\n        \\n        boolean dp[][] = new boolean[m+1][n+1];\\n        dp[0][0] = true;\\n        \\n        //base case 1\\n        for(int i=1;i<=m;i++)\\n        {\\n            if((s1.substring(0,i)).equals(s3.substring(0,i)))\\n                dp[i][0] = true;\\n            else\\n                dp[i][0] = false;\\n        }\\n\\n        //base case 2\\n        for(int j=1;j<=n;j++)\\n        {\\n            if((s2.substring(0,j)).equals(s3.substring(0,j)))\\n                dp[0][j] = true;\\n            else\\n                dp[0][j] = false;\\n        }\\n        \\n        //dp solution\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if( (dp[i-1][j]==true && s1.charAt(i-1)==s3.charAt(i+j-1)) || (dp[i][j-1]==true && s2.charAt(j-1)==s3.charAt(i+j-1)) )\\n                    dp[i][j] = true;\\n                 else\\n                    dp[i][j] = false;\\n            }\\n        }\\n        return dp[m][n]; \\n    }\\n\\n",
                "solutionTags": [],
                "code": "```\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        // dp[i][j] = true, means first i characters of s1 and first j characters of s2 interleaved to form i+j characters of s3\\n        // intuition dp[i][j] = true, if(dp[i-1][j] = true and ith char of s1 = (i+j)th char of s3 or dp[i][j-1] = true and jth character of s2 = (i+j)th char of s3\\n        \\n        int m = s1.length();\\n        int n = s2.length();\\n        int t = s3.length();\\n        \\n        if(t==0) return true;\\n        if(m+n != t) return false;\\n        else if(m==0 && n==0 && t!=0) return false;\\n        else if(m==0 && n!=0 )\\n        {\\n            if(s2.equals(s3))\\n                return true;\\n            else\\n                return false;\\n        }\\n        else if(m!=0 && n==0)\\n        {\\n            if(s1.equals(s3))\\n                return true;\\n            else\\n                return false;\\n        }\\n            \\n        \\n        boolean dp[][] = new boolean[m+1][n+1];\\n        dp[0][0] = true;\\n        \\n        //base case 1\\n        for(int i=1;i<=m;i++)\\n        {\\n            if((s1.substring(0,i)).equals(s3.substring(0,i)))\\n                dp[i][0] = true;\\n            else\\n                dp[i][0] = false;\\n        }\\n\\n        //base case 2\\n        for(int j=1;j<=n;j++)\\n        {\\n            if((s2.substring(0,j)).equals(s3.substring(0,j)))\\n                dp[0][j] = true;\\n            else\\n                dp[0][j] = false;\\n        }\\n        \\n        //dp solution\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if( (dp[i-1][j]==true && s1.charAt(i-1)==s3.charAt(i+j-1)) || (dp[i][j-1]==true && s2.charAt(j-1)==s3.charAt(i+j-1)) )\\n                    dp[i][j] = true;\\n                 else\\n                    dp[i][j] = false;\\n            }\\n        }\\n        return dp[m][n]; \\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 31934,
                "title": "java-dp-solution-o-m-n-time-o-n-space",
                "content": "```\\npublic class Solution {\\n    /**\\n     * Dynamic programming\\n     * Dynamic programming has 2 properties: overlapping subproblems and optimal substructure. \\n     * Then for this question, the overlapping subproblem would be matching substring of s1 or s2 with substring of s3. \\n     * Since s3 must match s1 and s2 in a way that the character has the same order, so we can just start comparison from start to end. \\n     * Say, s1.charAt(i) == s3.charAt(i + j); then we only have to deal with the subproblem of s1.substring(i + 1, s1.length()), s2.substring(j, s2.length()) and s3.substring(i + j, s3.length())\\n     * Since we don't have to know exactly how they match but rather only if they have matched for previous characters, a 2-dimensional boolean array would be enough. \\n     * One dimension record the index of s1 and the other record the index of s2.\\n     * matched[i][j] = matched[i][j-1] && current character of s2 and s3 is the same || matched[i-1][j] && current character of s1 and s3 is the same\\n     * Base case would be matched[0][0] = true\\n     * The corner case would be s1.length() + s2.length() != s3.length(), which is obviously false. \\n     * O(m * n) time and space where m and n are length of s1 and s2 respectively\\n     * The space may be further optimized to O(n), see below.\\n     */\\n    \\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1 == null || s1.length() == 0) {\\n            return s2.equals(s3);\\n        }\\n        if (s2 == null || s2.length() == 0) {\\n            return s1.equals(s3);\\n        }\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        boolean[][] matched = new boolean[s1.length() + 1][s2.length() + 1];\\n        char[] ch1 = s1.toCharArray();\\n        char[] ch2 = s2.toCharArray();\\n        char[] ch3 = s3.toCharArray();\\n        \\n        for (int i = 0; i <= ch1.length; i++) {\\n            for (int j = 0; j <= ch2.length; j++) {\\n                if (i == 0 && j == 0) {\\n                    matched[i][j] = true;\\n                } else if (i == 0) {\\n                    matched[i][j] = matched[i][j-1] && ch2[j - 1] == ch3[i + j - 1];\\n                } else if (j == 0) {\\n                    matched[i][j] = matched[i - 1][j] && ch1[i - 1] == ch3[i + j - 1];\\n                } else {\\n                    matched[i][j] = (matched[i][j - 1] && ch2[j - 1] == ch3[i + j - 1] || matched[i - 1][j] && ch1[i - 1] == ch3[i + j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return matched[ch1.length][ch2.length];\\n    }\\n```\\n\\nSince every matched flag is only related to the flag on the right and above it, we can drop every other flags and only retain a 1-dimension array to store these flags. \\n```\\npublic Solution {\\n    /**\\n     * Further optimized to O(m * n) time and O(n) space where m and n are the length of s1 and s2 respectively\\n     */\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1 == null || s2 == null || s3 == null) {\\n            return false;\\n        }\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        char[] ch1 = s1.toCharArray();\\n        char[] ch2 = s2.toCharArray();\\n        char[] ch3 = s3.toCharArray();\\n        boolean[] matched = new boolean[ch2.length + 1];\\n        for (int i = 0; i <= ch1.length; i++) {\\n            for (int j = 0; j <= ch2.length; j++) {\\n                if (i == 0 && j == 0) {\\n                    matched[j] = true;\\n                } else if (i == 0) {\\n                    matched[j] = matched[j - 1] && ch2[j - 1] == ch3[i + j -1];\\n                } else if (j == 0) {\\n                    matched[j] = matched[j] && ch1[i - 1] == ch3[i + j - 1];\\n                } else {\\n                    matched[j] = matched[j - 1] && ch2[j - 1] == ch3[i + j - 1] || matched[j] && ch1[i - 1] == ch3[i + j - 1];\\n                }\\n            }\\n        }\\n        \\n        return matched[ch2.length];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /**\\n     * Dynamic programming\\n     * Dynamic programming has 2 properties: overlapping subproblems and optimal substructure. \\n     * Then for this question, the overlapping subproblem would be matching substring of s1 or s2 with substring of s3. \\n     * Since s3 must match s1 and s2 in a way that the character has the same order, so we can just start comparison from start to end. \\n     * Say, s1.charAt(i) == s3.charAt(i + j); then we only have to deal with the subproblem of s1.substring(i + 1, s1.length()), s2.substring(j, s2.length()) and s3.substring(i + j, s3.length())\\n     * Since we don't have to know exactly how they match but rather only if they have matched for previous characters, a 2-dimensional boolean array would be enough. \\n     * One dimension record the index of s1 and the other record the index of s2.\\n     * matched[i][j] = matched[i][j-1] && current character of s2 and s3 is the same || matched[i-1][j] && current character of s1 and s3 is the same\\n     * Base case would be matched[0][0] = true\\n     * The corner case would be s1.length() + s2.length() != s3.length(), which is obviously false. \\n     * O(m * n) time and space where m and n are length of s1 and s2 respectively\\n     * The space may be further optimized to O(n), see below.\\n     */\\n    \\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1 == null || s1.length() == 0) {\\n            return s2.equals(s3);\\n        }\\n        if (s2 == null || s2.length() == 0) {\\n            return s1.equals(s3);\\n        }\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        boolean[][] matched = new boolean[s1.length() + 1][s2.length() + 1];\\n        char[] ch1 = s1.toCharArray();\\n        char[] ch2 = s2.toCharArray();\\n        char[] ch3 = s3.toCharArray();\\n        \\n        for (int i = 0; i <= ch1.length; i++) {\\n            for (int j = 0; j <= ch2.length; j++) {\\n                if (i == 0 && j == 0) {\\n                    matched[i][j] = true;\\n                } else if (i == 0) {\\n                    matched[i][j] = matched[i][j-1] && ch2[j - 1] == ch3[i + j - 1];\\n                } else if (j == 0) {\\n                    matched[i][j] = matched[i - 1][j] && ch1[i - 1] == ch3[i + j - 1];\\n                } else {\\n                    matched[i][j] = (matched[i][j - 1] && ch2[j - 1] == ch3[i + j - 1] || matched[i - 1][j] && ch1[i - 1] == ch3[i + j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return matched[ch1.length][ch2.length];\\n    }\\n```\n```\\npublic Solution {\\n    /**\\n     * Further optimized to O(m * n) time and O(n) space where m and n are the length of s1 and s2 respectively\\n     */\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1 == null || s2 == null || s3 == null) {\\n            return false;\\n        }\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        char[] ch1 = s1.toCharArray();\\n        char[] ch2 = s2.toCharArray();\\n        char[] ch3 = s3.toCharArray();\\n        boolean[] matched = new boolean[ch2.length + 1];\\n        for (int i = 0; i <= ch1.length; i++) {\\n            for (int j = 0; j <= ch2.length; j++) {\\n                if (i == 0 && j == 0) {\\n                    matched[j] = true;\\n                } else if (i == 0) {\\n                    matched[j] = matched[j - 1] && ch2[j - 1] == ch3[i + j -1];\\n                } else if (j == 0) {\\n                    matched[j] = matched[j] && ch1[i - 1] == ch3[i + j - 1];\\n                } else {\\n                    matched[j] = matched[j - 1] && ch2[j - 1] == ch3[i + j - 1] || matched[j] && ch1[i - 1] == ch3[i + j - 1];\\n                }\\n            }\\n        }\\n        \\n        return matched[ch2.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31946,
                "title": "clear-code-java-1ms-solution",
                "content": "```\\npublic class Solution {\\n    public boolean isInterleave(String a, String b, String c) {\\n        if (a.length() + b.length() != c.length())\\n            return false;\\n        return isInterleave(0, 0, new boolean[a.length() + 1][b.length() + 1], a, b, c);\\n    }\\n    public boolean isInterleave(int i, int j, boolean[][] f, String a, String b, String c) {\\n        if (f[i][j])\\n            return false;\\n        else\\n            f[i][j] = true;\\n        if (i == a.length() && j == b.length())\\n            return true;\\n        if (i < a.length() && a.charAt(i) == c.charAt(i + j) && isInterleave(i + 1, j, f, a, b, c))\\n            return true;\\n        if (j < b.length() && b.charAt(j) == c.charAt(i + j) && isInterleave(i, j + 1, f, a, b, c))\\n            return true;\\n        return false;\\n    }\\n}\\n```\\nThe idea is very clear so that I don't think any explanation is needed. QAQ",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean isInterleave(String a, String b, String c) {\\n        if (a.length() + b.length() != c.length())\\n            return false;\\n        return isInterleave(0, 0, new boolean[a.length() + 1][b.length() + 1], a, b, c);\\n    }\\n    public boolean isInterleave(int i, int j, boolean[][] f, String a, String b, String c) {\\n        if (f[i][j])\\n            return false;\\n        else\\n            f[i][j] = true;\\n        if (i == a.length() && j == b.length())\\n            return true;\\n        if (i < a.length() && a.charAt(i) == c.charAt(i + j) && isInterleave(i + 1, j, f, a, b, c))\\n            return true;\\n        if (j < b.length() && b.charAt(j) == c.charAt(i + j) && isInterleave(i, j + 1, f, a, b, c))\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32075,
                "title": "share-accepted-python-solution",
                "content": "    class Solution:\\n        # @return a boolean\\n        def isInterleave(self, s1, s2, s3):\\n            #dp[i][j][k] = True if s3[:k] is interleave of s1[:i] and s2[:j]\\n            #dp[i][j][k] = (dp[i-1][j][k-1] if s1[i] == s3[k]) or (dp[i][j-1][k-1] if s2[j] == s3[k])\\n            #dp[0][0][0] = True\\n            #dp[i][j][k] = False if i+j != k   Since k always = i+j, we can eliminate one dimension\\n            if len(s1)+len(s2) != len(s3): return False\\n            dp = [[False for j in range(len(s2)+1)] for i in range(len(s1)+1)]\\n            for i in range(0, len(s1)+1):\\n                for j in range(0, len(s2)+1): #k is determined\\n                    if i == 0 and j == 0:\\n                        dp[i][j] = True\\n                    elif i == 0:                        #\"aa\", \"ab\", \"abaa\" length of s1 is 0\\n                        dp[i][j] = s2[:j] == s3[:j]\\n                    elif j == 0:                        #length of s2 is 0\\n                        dp[i][j] = s1[:i] == s3[:i]\\n                    else:\\n                        dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])\\n            return dp[-1][-1]",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @return a boolean\\n        def isInterleave(self, s1, s2, s3):\\n            #dp[i][j][k] = True if s3[:k] is interleave of s1[:i] and s2[:j]\\n            #dp[i][j][k] = (dp[i-1][j][k-1] if s1[i] == s3[k]) or (dp[i][j-1][k-1] if s2[j] == s3[k])\\n            #dp[0][0][0] = True\\n            #dp[i][j][k] = False if i+j != k   Since k always = i+j, we can eliminate one dimension\\n            if len(s1)+len(s2) != len(s3): return False\\n            dp = [[False for j in range(len(s2)+1)] for i in range(len(s1)+1)]\\n            for i in range(0, len(s1)+1):\\n                for j in range(0, len(s2)+1): #k is determined\\n                    if i == 0 and j == 0:\\n                        dp[i][j] = True\\n                    elif i == 0:                        #\"aa\", \"ab\", \"abaa\" length of s1 is 0\\n                        dp[i][j] = s2[:j] == s3[:j]\\n                    elif j == 0:                        #length of s2 is 0\\n                        dp[i][j] = s1[:i] == s3[:i]\\n                    else:\\n                        dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])\\n            return dp[-1][-1]",
                "codeTag": "Java"
            },
            {
                "id": 31933,
                "title": "definition-of-interleave-on-test-examples",
                "content": "    The example says:\\n    s1 \"aabcc\"\\n    s2 \"dbbca\"\\n    s3 \"aadbbcbcac\" is interleave,\\n    \\n    if we decompose: s3\\n    \"aa\"   \"db\"  \"bc\"  \"bc\"  \"a\"  \"c\"\\n     s1     s2    s1    s2   s2    s1\\n    \\n    It is not interleaving right?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3997350,
                "title": "interleaving-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[101][101];\\n    bool solve(string &s1, string &s2, string &s3,int i,int j)\\n    {\\n        if(i == s1.length() && j == s2.length() && i+j == s3.length()) return true;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        bool result = false;\\n        \\n        if(i < s1.length() && j < s2.length() && s1[i] == s3[i+j] && s2[j] == s3[i+j])\\n        {\\n            result = (solve(s1,s2,s3,i+1,j) || solve(s1,s2,s3,i,j+1));\\n        }\\n        else if(i < s1.length() && s1[i] == s3[i+j])\\n        {\\n            result = solve(s1,s2,s3,i+1,j);\\n        }\\n        else if(j < s2.length() && s2[j] == s3[i+j])\\n        {\\n            result = solve(s1,s2,s3,i,j+1);\\n        }\\n        return dp[i][j] = result;\\n    }\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) \\n    {\\n      if(s1.length() + s2.length() != s3.length()) return false;\\n      memset(dp,-1,sizeof(dp));\\n      return solve(s1,s2,s3,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dp[101][101];\\n    bool solve(string &s1, string &s2, string &s3,int i,int j)\\n    {\\n        if(i == s1.length() && j == s2.length() && i+j == s3.length()) return true;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        bool result = false;\\n        \\n        if(i < s1.length() && j < s2.length() && s1[i] == s3[i+j] && s2[j] == s3[i+j])\\n        {\\n            result = (solve(s1,s2,s3,i+1,j) || solve(s1,s2,s3,i,j+1));\\n        }\\n        else if(i < s1.length() && s1[i] == s3[i+j])\\n        {\\n            result = solve(s1,s2,s3,i+1,j);\\n        }\\n        else if(j < s2.length() && s2[j] == s3[i+j])\\n        {\\n            result = solve(s1,s2,s3,i,j+1);\\n        }\\n        return dp[i][j] = result;\\n    }\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) \\n    {\\n      if(s1.length() + s2.length() != s3.length()) return false;\\n      memset(dp,-1,sizeof(dp));\\n      return solve(s1,s2,s3,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959506,
                "title": "faster-99-73-easy-and-clean-dp-top-down-bottom-up",
                "content": "# Please Upvote if you liked my Solution \\uD83E\\uDD17\\uD83E\\uDD17\\n> **Please do UpVote** it took lot of time to figure out these solutions\\n\\n# Complexity \\n- Time complexity: $$O(N*M)$$ for `N = s1.length` and `M = s2.length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N*M)$$ for `Solution 1` and `Solution 2`\\n- Space complexity: $$O(N)$$ for `Solution 3`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# C++ Code\\n```\\nclass Solution {\\n    int isInterleaveHelp(int i, int j, vector<vector<int>> &dp, string &s1, string &s2, string &s3) {\\n        if( i+j == s3.size() ) return 1;\\n        if( dp[i][j] != -1 ) return dp[i][j];\\n\\n        if( i<s1.size() && s1[i] == s3[i+j] && isInterleaveHelp(i+1, j, dp, s1, s2, s3) )\\n            return dp[i][j] = 1;\\n        if( j<s2.size() && s2[j] == s3[i+j] && isInterleaveHelp(i, j+1, dp, s1, s2, s3) )\\n            return dp[i][j] = 1;\\n        return dp[i][j] = 0;\\n    }\\n\\npublic:\\n    // Solution 1 - TOP DOWN DP - SC - O(N*M)\\n    bool isInterleave1(string s1, string s2, string s3) {\\n        if( s1.size() + s2.size() != s3.size() ) return 0;\\n        int n = s1.size(), m = s2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        return isInterleaveHelp(0, 0, dp, s1, s2, s3) == 1;\\n    }\\n\\n\\n    // Solution 2 - BOTTOM UP DP - SC - O(N*M)\\n    bool isInterleave2(string s1, string s2, string s3) {\\n        if( s1.size() + s2.size() != s3.size() ) return 0;\\n        int n = s1.size(), m = s2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                int ans = (i + j == s3.size());\\n                if( i<s1.size() && s1[i] == s3[i+j] ) ans |= dp[i+1][j];\\n                if( j<s2.size() && s2[j] == s3[i+j] ) ans |= dp[i][j+1];\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[0][0] == 1;\\n    }\\n\\n\\n    // Solution 3 - BOTTOM UP - Space Optimized - SC - O(M)\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if( s1.size() + s2.size() != s3.size() ) return 0;\\n        int n = s1.size(), m = s2.size();\\n        vector<int> cur(m+1, 0);\\n\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                int ans = (i + j == s3.size());\\n                if( i<s1.size() && s1[i] == s3[i+j] ) ans |= cur[j];\\n                if( j<s2.size() && s2[j] == s3[i+j] ) ans |= cur[j+1];\\n                cur[j] = ans;\\n            }\\n        }\\n        return cur[0] == 1;\\n    }\\n};\\n```\\n\\n---\\n\\n# Java Code\\n```\\nclass Solution {\\n    private int isInterleaveHelp(int i, int j, int dp[][], String s1, String s2, String s3) {\\n        if( i+j == s3.length() ) return 1;\\n        if( dp[i][j] != -1 ) return dp[i][j];\\n\\n        int ans = 0;\\n        if( i<s1.length() && s1.charAt(i) == s3.charAt(i+j) )\\n            ans |= isInterleaveHelp(i+1, j, dp, s1, s2, s3);\\n        \\n        if( j<s2.length() && s2.charAt(j) == s3.charAt(i+j) )\\n            ans |= isInterleaveHelp(i, j+1, dp, s1, s2, s3);\\n        \\n        return dp[i][j] = ans;\\n    }\\n\\n\\n\\n    // Solution 1 - TOP DOWN DP - SC - O(N*M)\\n    public boolean isInterleave1(String s1, String s2, String s3) {\\n        if( s1.length() + s2.length() != s3.length() ) return false;\\n        int n = s1.length(), m = s2.length();\\n        int dp[][] = new int[n+1][m+1];\\n        for(int row[] : dp) Arrays.fill(row, -1);\\n        return isInterleaveHelp(0, 0, dp, s1, s2, s3) == 1;\\n    }\\n\\n\\n\\n    // Solution 2 - BOTTOM UP DP - SC - O(N*M)\\n    public boolean isInterleave2(String s1, String s2, String s3) {\\n        if( s1.length() + s2.length() != s3.length() ) return false;\\n        int n = s1.length(), m = s2.length();\\n        int dp[][] = new int[n+1][m+1];\\n\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                int ans = (i + j == s3.length() ? 1 : 0);\\n                if( i<s1.length() && s1.charAt(i) == s3.charAt(i+j) ) ans |= dp[i+1][j];\\n                if( j<s2.length() && s2.charAt(j) == s3.charAt(i+j) ) ans |= dp[i][j+1];\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[0][0] == 1;\\n    }\\n\\n\\n\\n    // Solution 3 - BOTTOM UP - Space Optimized - SC - O(M)\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if( s1.length() + s2.length() != s3.length() ) return false;\\n        int n = s1.length(), m = s2.length();\\n        int cur[] = new int[m+1];\\n\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                int ans = (i + j == s3.length() ? 1 : 0 );\\n                if( i<n && s1.charAt(i) == s3.charAt(i+j) ) ans |= cur[j];\\n                if( j<m && s2.charAt(j) == s3.charAt(i+j) ) ans |= cur[j+1];\\n                cur[j] = ans;\\n            }\\n        }\\n        return cur[0] == 1;\\n    }\\n}\\n```\\n\\n![upvote-4.png](https://assets.leetcode.com/users/images/5af4e2a5-e8b2-4f46-be00-75247cfdf9ff_1689947516.7818904.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    int isInterleaveHelp(int i, int j, vector<vector<int>> &dp, string &s1, string &s2, string &s3) {\\n        if( i+j == s3.size() ) return 1;\\n        if( dp[i][j] != -1 ) return dp[i][j];\\n\\n        if( i<s1.size() && s1[i] == s3[i+j] && isInterleaveHelp(i+1, j, dp, s1, s2, s3) )\\n            return dp[i][j] = 1;\\n        if( j<s2.size() && s2[j] == s3[i+j] && isInterleaveHelp(i, j+1, dp, s1, s2, s3) )\\n            return dp[i][j] = 1;\\n        return dp[i][j] = 0;\\n    }\\n\\npublic:\\n    // Solution 1 - TOP DOWN DP - SC - O(N*M)\\n    bool isInterleave1(string s1, string s2, string s3) {\\n        if( s1.size() + s2.size() != s3.size() ) return 0;\\n        int n = s1.size(), m = s2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        return isInterleaveHelp(0, 0, dp, s1, s2, s3) == 1;\\n    }\\n\\n\\n    // Solution 2 - BOTTOM UP DP - SC - O(N*M)\\n    bool isInterleave2(string s1, string s2, string s3) {\\n        if( s1.size() + s2.size() != s3.size() ) return 0;\\n        int n = s1.size(), m = s2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                int ans = (i + j == s3.size());\\n                if( i<s1.size() && s1[i] == s3[i+j] ) ans |= dp[i+1][j];\\n                if( j<s2.size() && s2[j] == s3[i+j] ) ans |= dp[i][j+1];\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[0][0] == 1;\\n    }\\n\\n\\n    // Solution 3 - BOTTOM UP - Space Optimized - SC - O(M)\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if( s1.size() + s2.size() != s3.size() ) return 0;\\n        int n = s1.size(), m = s2.size();\\n        vector<int> cur(m+1, 0);\\n\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                int ans = (i + j == s3.size());\\n                if( i<s1.size() && s1[i] == s3[i+j] ) ans |= cur[j];\\n                if( j<s2.size() && s2[j] == s3[i+j] ) ans |= cur[j+1];\\n                cur[j] = ans;\\n            }\\n        }\\n        return cur[0] == 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private int isInterleaveHelp(int i, int j, int dp[][], String s1, String s2, String s3) {\\n        if( i+j == s3.length() ) return 1;\\n        if( dp[i][j] != -1 ) return dp[i][j];\\n\\n        int ans = 0;\\n        if( i<s1.length() && s1.charAt(i) == s3.charAt(i+j) )\\n            ans |= isInterleaveHelp(i+1, j, dp, s1, s2, s3);\\n        \\n        if( j<s2.length() && s2.charAt(j) == s3.charAt(i+j) )\\n            ans |= isInterleaveHelp(i, j+1, dp, s1, s2, s3);\\n        \\n        return dp[i][j] = ans;\\n    }\\n\\n\\n\\n    // Solution 1 - TOP DOWN DP - SC - O(N*M)\\n    public boolean isInterleave1(String s1, String s2, String s3) {\\n        if( s1.length() + s2.length() != s3.length() ) return false;\\n        int n = s1.length(), m = s2.length();\\n        int dp[][] = new int[n+1][m+1];\\n        for(int row[] : dp) Arrays.fill(row, -1);\\n        return isInterleaveHelp(0, 0, dp, s1, s2, s3) == 1;\\n    }\\n\\n\\n\\n    // Solution 2 - BOTTOM UP DP - SC - O(N*M)\\n    public boolean isInterleave2(String s1, String s2, String s3) {\\n        if( s1.length() + s2.length() != s3.length() ) return false;\\n        int n = s1.length(), m = s2.length();\\n        int dp[][] = new int[n+1][m+1];\\n\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                int ans = (i + j == s3.length() ? 1 : 0);\\n                if( i<s1.length() && s1.charAt(i) == s3.charAt(i+j) ) ans |= dp[i+1][j];\\n                if( j<s2.length() && s2.charAt(j) == s3.charAt(i+j) ) ans |= dp[i][j+1];\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[0][0] == 1;\\n    }\\n\\n\\n\\n    // Solution 3 - BOTTOM UP - Space Optimized - SC - O(M)\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if( s1.length() + s2.length() != s3.length() ) return false;\\n        int n = s1.length(), m = s2.length();\\n        int cur[] = new int[m+1];\\n\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                int ans = (i + j == s3.length() ? 1 : 0 );\\n                if( i<n && s1.charAt(i) == s3.charAt(i+j) ) ans |= cur[j];\\n                if( j<m && s2.charAt(j) == s3.charAt(i+j) ) ans |= cur[j+1];\\n                cur[j] = ans;\\n            }\\n        }\\n        return cur[0] == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957919,
                "title": "python-3-one-line",
                "content": "Looks like this is the shortest:\\n```python\\nclass Solution:\\n    @cache\\n    def isInterleave(self, a: str, b: str, c: str) -> bool:\\n        return any(c[:1]==x[:1]and self.isInterleave(x[1:],y,c[1:])for x,y in((a,b),(b,a)))if(a and b)else(a or b or\\'\\')==c\\n```\\nYou can also use cache decorator as a function:\\n```python\\nclass Solution:\\n    def isInterleave(self, a: str, b: str, c: str) -> bool:\\n        return(f:=cache(lambda a,b,c:any(c[:1]==x[:1]and f(x[1:],y,c[1:])for x,y in((a,b),(b,a)))if(a and b)else(a or b or\\'\\')==c))(a,b,c)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    @cache\\n    def isInterleave(self, a: str, b: str, c: str) -> bool:\\n        return any(c[:1]==x[:1]and self.isInterleave(x[1:],y,c[1:])for x,y in((a,b),(b,a)))if(a and b)else(a or b or\\'\\')==c\\n```\n```python\\nclass Solution:\\n    def isInterleave(self, a: str, b: str, c: str) -> bool:\\n        return(f:=cache(lambda a,b,c:any(c[:1]==x[:1]and f(x[1:],y,c[1:])for x,y in((a,b),(b,a)))if(a and b)else(a or b or\\'\\')==c))(a,b,c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957841,
                "title": "using-dp",
                "content": "# Intuition\\nYou can solve this problem using dynamic programming.\\n\\n# Approach\\n\\n\\nThe dp[i][j] entry in the 2D array represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3. The dynamic programming approach iterates through all possible combinations of s1 and s2 substrings and checks if they can form the corresponding substring of s3.\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :type s3: str\\n        :rtype: bool\\n        \"\"\"\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n    \\n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\\n        \\n        dp[0][0] = True\\n        \\n        for i in range(len(s1) + 1):\\n            for j in range(len(s2) + 1):\\n                if i > 0 and s1[i - 1] == s3[i + j - 1]:\\n                    dp[i][j] |= dp[i - 1][j]\\n                if j > 0 and s2[j - 1] == s3[i + j - 1]:\\n                    dp[i][j] |= dp[i][j - 1]\\n                    \\n        return dp[len(s1)][len(s2)]\\n\\n\\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "Python",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :type s3: str\\n        :rtype: bool\\n        \"\"\"\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n    \\n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\\n        \\n        dp[0][0] = True\\n        \\n        for i in range(len(s1) + 1):\\n            for j in range(len(s2) + 1):\\n                if i > 0 and s1[i - 1] == s3[i + j - 1]:\\n                    dp[i][j] |= dp[i - 1][j]\\n                if j > 0 and s2[j - 1] == s3[i + j - 1]:\\n                    dp[i][j] |= dp[i][j - 1]\\n                    \\n        return dp[len(s1)][len(s2)]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957744,
                "title": "inter-leave",
                "content": "# Intuition\\nMy initial thoughts on solving this problem are to use a Depth-First Search (DFS) approach to determine whether a given string `s3` can be formed by interleaving characters from two input strings `s1` and `s2`.\\n\\n# Approach\\nThe approach I\\'ve taken to solve this problem is to use a recursive DFS algorithm with memoization. The idea is to consider each character of `s1` and `s2` and check if it matches the current character of `s3`. If there\\'s a match, we recursively check the next characters from both `s1` and `s2` along with the next character from `s3`. If either of these recursive calls returns true, it means that we\\'ve successfully formed an interleaved string up to this point. \\n\\nI\\'m using a 2D boolean array `dp` to store the memoization information. The element `dp[i][j]` represents whether the substring formed by considering the first `i` characters from `s1` and the first `j` characters from `s2` can form the first `i+j` characters of `s3`.\\n\\n# Complexity\\n- Time complexity: The worst-case time complexity of the algorithm is O(m * n), where `m` is the length of string `s1` and `n` is the length of string `s2`. This is because for each character of `s1`, we potentially explore all characters of `s2`.\\n- Space complexity: The space complexity is O(m * n), as we are using a 2D array `dp` of size `(m+1) x (n+1)` for memoization.\\n\\n# Code\\n```java\\nimport java.util.*;\\n\\nclass Solution {\\n    public static boolean dfs(char c1[], char c2[], char c3[], int i, int j, int k, boolean dp[][]) {\\n        if (dp[i][j]) {\\n            return false;\\n        }\\n        if (k == c3.length) {\\n            return true;\\n        }\\n        boolean valid = i < c1.length && c1[i] == c3[k] && dfs(c1, c2, c3, i + 1, j, k + 1, dp)\\n                || j < c2.length && c2[j] == c3[k] && dfs(c1, c2, c3, i, j + 1, k + 1, dp);\\n        if (!valid) {\\n            dp[i][j] = true;\\n        }\\n        return valid;\\n    }\\n\\n    public static boolean isInterleave(String s1, String s2, String s3) {\\n        char c1[] = s1.toCharArray(), c2[] = s2.toCharArray(), c3[] = s3.toCharArray();\\n        int m = s1.length(), n = s2.length();\\n        if (m + n != s3.length()) {\\n            return false;\\n        }\\n        boolean dp[][] = new boolean[m + 1][n + 1];\\n        return dfs(c1, c2, c3, 0, 0, 0, dp);\\n    }\\n}\\n```\\n\\nThis code implements the DFS algorithm with memoization to solve the problem of determining whether `s3` can be formed by interleaving characters from `s1` and `s2`.",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```java\\nimport java.util.*;\\n\\nclass Solution {\\n    public static boolean dfs(char c1[], char c2[], char c3[], int i, int j, int k, boolean dp[][]) {\\n        if (dp[i][j]) {\\n            return false;\\n        }\\n        if (k == c3.length) {\\n            return true;\\n        }\\n        boolean valid = i < c1.length && c1[i] == c3[k] && dfs(c1, c2, c3, i + 1, j, k + 1, dp)\\n                || j < c2.length && c2[j] == c3[k] && dfs(c1, c2, c3, i, j + 1, k + 1, dp);\\n        if (!valid) {\\n            dp[i][j] = true;\\n        }\\n        return valid;\\n    }\\n\\n    public static boolean isInterleave(String s1, String s2, String s3) {\\n        char c1[] = s1.toCharArray(), c2[] = s2.toCharArray(), c3[] = s3.toCharArray();\\n        int m = s1.length(), n = s2.length();\\n        if (m + n != s3.length()) {\\n            return false;\\n        }\\n        boolean dp[][] = new boolean[m + 1][n + 1];\\n        return dfs(c1, c2, c3, 0, 0, 0, dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957693,
                "title": "most-easy-dp-solution-u-can-get",
                "content": "\\n# **PLS UPVOTE IF YOU LIKE AND COMMENT FOR ANY DOUBT**\\n# Approach\\nsolve function: This function takes the current indices i, j, and k as well as the three strings s1, s2, and s3 and the dp table for memoization.\\n\\nBase Case: The base case of the recursion is when all three strings have been completely used (i == s1.length(), j == s2.length(), and k == s3.length()). In this case, if both s1 and s2 have been fully used, it means we have successfully interleaved s1 and s2 to create s3, and thus, we return true.\\n\\nMemoization: If the state (i, j) has been computed before (indicated by dp[i][j] != -1), then we directly return the precomputed result.\\n\\nRecursive Steps: Two conditions are checked here to recursively explore the interleaving possibilities:\\n\\nIf the current character of s1 (s1[i]) matches the current character of s3 (s3[k]), then we can consider this match and recurse with the next character from s1 and s3. We increment i and k.\\nSimilarly, if the current character of s2 (s2[j]) matches the current character of s3 (s3[k]), then we can consider this match and recurse with the next character from s2 and s3. We increment j and k.\\nReturn: The result of the current state (i, j) is stored in the dp table and returned as a || b, where a and b are the results of the two recursive steps mentioned above.\\n\\nisInterleave function: This function is the entry point of the solution. It checks if the lengths of the strings match correctly. If not, it returns false immediately since interleaving wouldn\\'t be possible. Otherwise, it initializes the dp table and starts the recursion from the (0, 0, 0) state of the solve function\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool solve(string& s1, string& s2, string& s3, int i, int j, int k, vector<vector<int>>& dp) {\\n    if (i == s1.length() && j == s2.length() && k == s3.length()) {\\n        // Both s1 and s2 should be empty at this point to return true\\n        return true;\\n    }\\n    if (dp[i][j] != -1) {\\n        return dp[i][j];\\n    }\\n    bool a = false, b = false;\\n    if( i!=s1.length() && k!=s3.length() && s1[i] == s3[k]) {\\n        a = solve(s1, s2, s3, i+1, j , k+1, dp);\\n    }\\n    if ( j!=s2.length() && k!=s3.length() && s2[j] == s3[k]) {\\n        b = solve(s1, s2, s3, i , j+1 , k+1 , dp);\\n    }\\n    return dp[i][j] = a || b;\\n}\\n\\n   bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        int len= s3.length();\\n        if(n+m!=len)\\n        {\\n            return false;\\n        }\\n        vector<vector<int>>dp(201,vector<int>(201,-1));\\n        return solve(s1 , s2 , s3 , 0 , 0 , 0 , dp);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool solve(string& s1, string& s2, string& s3, int i, int j, int k, vector<vector<int>>& dp) {\\n    if (i == s1.length() && j == s2.length() && k == s3.length()) {\\n        // Both s1 and s2 should be empty at this point to return true\\n        return true;\\n    }\\n    if (dp[i][j] != -1) {\\n        return dp[i][j];\\n    }\\n    bool a = false, b = false;\\n    if( i!=s1.length() && k!=s3.length() && s1[i] == s3[k]) {\\n        a = solve(s1, s2, s3, i+1, j , k+1, dp);\\n    }\\n    if ( j!=s2.length() && k!=s3.length() && s2[j] == s3[k]) {\\n        b = solve(s1, s2, s3, i , j+1 , k+1 , dp);\\n    }\\n    return dp[i][j] = a || b;\\n}\\n\\n   bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        int len= s3.length();\\n        if(n+m!=len)\\n        {\\n            return false;\\n        }\\n        vector<vector<int>>dp(201,vector<int>(201,-1));\\n        return solve(s1 , s2 , s3 , 0 , 0 , 0 , dp);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957663,
                "title": "c-recursion-memoisation-tabulation-follow-up-space-optimisation",
                "content": "\\n# Recursion(TLE)\\n```\\nclass Solution {\\npublic:\\n    bool helper(string&s1,string&s2,string&s3,int i,int j){\\n        if(i+j==s3.length())return true;\\n        int ans=false;\\n        if(i<s1.length()&&j<s2.length()&&s1[i]==s3[i+j]&&s2[j]==s3[i+j]){\\n            bool take1 =helper(s1,s2,s3,i+1,j);\\n            bool take2=helper(s1,s2,s3,i,j+1);\\n            ans=take1||take2;\\n        }\\n        else if(i<s1.length()&&s1[i]==s3[i+j]){\\n            ans=helper(s1,s2,s3,i+1,j);\\n        }\\n        else if(j<s2.length()&&s2[j]==s3[i+j]){\\n            ans=helper(s1,s2,s3,i,j+1);\\n        }\\n        return ans;\\n\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        return helper(s1,s2,s3,0,0);\\n    }\\n};\\n```\\n# Memoisation(AC)\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>>memo;\\n    bool helper(string&s1,string&s2,string&s3,int i,int j){\\n        if(i+j==s3.length())return true;\\n        if(memo[i][j]!=-1)return memo[i][j];\\n        int ans=false;\\n        if(i<s1.length()&&j<s2.length()&&s1[i]==s3[i+j]&&s2[j]==s3[i+j]){\\n            bool take1 =helper(s1,s2,s3,i+1,j);\\n            bool take2=helper(s1,s2,s3,i,j+1);\\n            ans=take1||take2;\\n        }\\n        else if(i<s1.length()&&s1[i]==s3[i+j]){\\n            ans=helper(s1,s2,s3,i+1,j);\\n        }\\n        else if(j<s2.length()&&s2[j]==s3[i+j]){\\n            ans=helper(s1,s2,s3,i,j+1);\\n        }\\n        return memo[i][j]= ans;\\n\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        memo.resize(s1.length()+1,vector<int>(s2.length()+1,-1));\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        return helper(s1,s2,s3,0,0);\\n    }\\n};\\n```\\n# Tabulation(AC) \\n**space complexity**: `0(s1.length*s2.length)`\\n```\\nclass Solution {\\npublic:\\n\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        vector<vector<bool>>dp(s1.length()+1,vector<bool>(s2.length()+1));\\n        dp[0][0]=1; //satisfies because s1,s2,and s3 are empty strings\\n        for(int j=1;j<s2.length()+1;j++){ //check when s1 length is zero\\n             dp[0][j]=dp[0][j-1]&&(s2[j-1]==s3[j-1]);\\n        }\\n        for(int i=1;i<s1.length()+1;i++){ //check when s2 length is zero\\n             dp[i][0]=dp[i-1][0]&&(s1[i-1]==s3[i-1]);\\n        }\\n        for(int i=1;i<s1.length()+1;i++){\\n            for(int j=1;j<s2.length()+1;j++){\\n                bool a=(s1[i-1]==s3[i+j-1])&&dp[i-1][j];\\n                bool b=(s2[j-1]==s3[i+j-1])&&dp[i][j-1];\\n                dp[i][j]=a||b;\\n            }\\n        }\\n        return dp[s1.length()][s2.length()];\\n    }\\n};\\n```\\n# Space optimisation(Follow up):\\n **space complexity**: `0(s2.length)`\\n```\\n bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n\\n       vector<bool>dp(s2.length()+1);\\n        dp[0]=1; //satisfies because s1,s2,and s3 are empty strings\\n        for(int j=1;j<s2.length()+1;j++){ //check when s1 length is zero\\n             dp[j]=dp[j-1]&&(s2[j-1]==s3[j-1]);\\n        }\\n        \\n        for(int i=1;i<s1.length()+1;i++){\\n            dp[0]=(s3[i-1]==s1[i-1])&&dp[0];\\n            for(int j=1;j<s2.length()+1;j++){\\n                bool a=(s1[i-1]==s3[i+j-1])&&dp[j];\\n                bool b=(s2[j-1]==s3[i+j-1])&&dp[j-1];\\n                dp[j]=a||b;\\n            }\\n        }\\n        return dp[s2.length()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(string&s1,string&s2,string&s3,int i,int j){\\n        if(i+j==s3.length())return true;\\n        int ans=false;\\n        if(i<s1.length()&&j<s2.length()&&s1[i]==s3[i+j]&&s2[j]==s3[i+j]){\\n            bool take1 =helper(s1,s2,s3,i+1,j);\\n            bool take2=helper(s1,s2,s3,i,j+1);\\n            ans=take1||take2;\\n        }\\n        else if(i<s1.length()&&s1[i]==s3[i+j]){\\n            ans=helper(s1,s2,s3,i+1,j);\\n        }\\n        else if(j<s2.length()&&s2[j]==s3[i+j]){\\n            ans=helper(s1,s2,s3,i,j+1);\\n        }\\n        return ans;\\n\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        return helper(s1,s2,s3,0,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nvector<vector<int>>memo;\\n    bool helper(string&s1,string&s2,string&s3,int i,int j){\\n        if(i+j==s3.length())return true;\\n        if(memo[i][j]!=-1)return memo[i][j];\\n        int ans=false;\\n        if(i<s1.length()&&j<s2.length()&&s1[i]==s3[i+j]&&s2[j]==s3[i+j]){\\n            bool take1 =helper(s1,s2,s3,i+1,j);\\n            bool take2=helper(s1,s2,s3,i,j+1);\\n            ans=take1||take2;\\n        }\\n        else if(i<s1.length()&&s1[i]==s3[i+j]){\\n            ans=helper(s1,s2,s3,i+1,j);\\n        }\\n        else if(j<s2.length()&&s2[j]==s3[i+j]){\\n            ans=helper(s1,s2,s3,i,j+1);\\n        }\\n        return memo[i][j]= ans;\\n\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        memo.resize(s1.length()+1,vector<int>(s2.length()+1,-1));\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        return helper(s1,s2,s3,0,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        vector<vector<bool>>dp(s1.length()+1,vector<bool>(s2.length()+1));\\n        dp[0][0]=1; //satisfies because s1,s2,and s3 are empty strings\\n        for(int j=1;j<s2.length()+1;j++){ //check when s1 length is zero\\n             dp[0][j]=dp[0][j-1]&&(s2[j-1]==s3[j-1]);\\n        }\\n        for(int i=1;i<s1.length()+1;i++){ //check when s2 length is zero\\n             dp[i][0]=dp[i-1][0]&&(s1[i-1]==s3[i-1]);\\n        }\\n        for(int i=1;i<s1.length()+1;i++){\\n            for(int j=1;j<s2.length()+1;j++){\\n                bool a=(s1[i-1]==s3[i+j-1])&&dp[i-1][j];\\n                bool b=(s2[j-1]==s3[i+j-1])&&dp[i][j-1];\\n                dp[i][j]=a||b;\\n            }\\n        }\\n        return dp[s1.length()][s2.length()];\\n    }\\n};\\n```\n```\\n bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n\\n       vector<bool>dp(s2.length()+1);\\n        dp[0]=1; //satisfies because s1,s2,and s3 are empty strings\\n        for(int j=1;j<s2.length()+1;j++){ //check when s1 length is zero\\n             dp[j]=dp[j-1]&&(s2[j-1]==s3[j-1]);\\n        }\\n        \\n        for(int i=1;i<s1.length()+1;i++){\\n            dp[0]=(s3[i-1]==s1[i-1])&&dp[0];\\n            for(int j=1;j<s2.length()+1;j++){\\n                bool a=(s1[i-1]==s3[i+j-1])&&dp[j];\\n                bool b=(s2[j-1]==s3[i+j-1])&&dp[j-1];\\n                dp[j]=a||b;\\n            }\\n        }\\n        return dp[s2.length()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957198,
                "title": "c-recursion-memoization-dp-simple-code-with-explanation-mr-robot",
                "content": "# Approach 1 Recursion : TLE\\n```\\nclass Solution {\\n    private:\\n    bool solve(string &s1,int i, string &s2, int j,string &s3,int k){\\n        if(k == s3.length())return true;\\n        if(i < s1.size() && s1[i] == s3[k]  && j<s2.size() && s2[j] == s3[k]){\\n           \\n            return solve(s1,i+1,s2,j,s3,k+1) ||  solve(s1,i,s2,j+1,s3,k+1);\\n        }\\n        else if(i < s1.size() && s1[i] == s3[k]){\\n           \\n            return solve(s1,i+1,s2,j,s3,k+1);\\n        }\\n        else if (j<s2.size() && s2[j] == s3[k]){\\n          \\n            return solve(s1,i,s2,j+1,s3,k+1);\\n        }\\n        else return false;\\n    }\\npublic:\\n\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.size() + s2.size() != s3.size())return false;\\n        return solve(s1,0,s2,0,s3,0);\\n    }\\n};\\n```\\n\\n# Complexity Analysis\\n\\n- **Time complexity** : O(2^{m+n})\\n- **Space complexity** : O(m+n).The size of stack for recursive calls can go upto m+n\\n- m = s1.length()\\n- n = s2.length()\\n\\n\\n\\n---\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# Approach 2 \\n- Solve Function: This is a recursive helper function that determines whether s3 can be formed by interleaving characters from s1 and s2. The function uses dynamic programming with memoization to avoid redundant calculations. The parameters are the current indices (i, j, k) for s1, s2, and s3 respectively, along with the memoization dp vector.\\n\\n- Base Case: The base case checks if the index k has reached the length of s3, indicating that the interleaving is successful, and the function returns true.\\n\\n- Memoization: The dp vector is used to store the results of subproblems to avoid recalculating them. If a particular state (i, j, k) has been computed before, it is stored in dp[i][j][k].\\n\\n- Interleaving Logic: The code checks three scenarios to determine if the current characters from s1 and s2 match the character at index k in s3:\\n\\n- If both s1[i] and s2[j] match s3[k], then the function recursively calls itself by either incrementing i or j.\\n- If only s1[i] matches s3[k], the function increments i and proceeds with the next character comparison.\\n- If only s2[j] matches s3[k], the function increments j and proceeds with the next character comparison.\\n- Return: If none of the conditions are met, it means that the current characters of s1 and s2 cannot contribute to the interleaving of s3, so the function returns false.\\n\\n- Return Value: The result of the solve function is returned, which indicates whether s3 can be formed by interleaving s1 and s2.\\n\\n- This solution uses dynamic programming with memoization to avoid redundant calculations, ensuring efficiency in solving the interleaving problem. The concept of recursion and memoization is key to understanding and implementing this solution.\\n\\n\\n\\n---\\n\\n\\n# Approach 2 : Recursion + Memoization\\n```\\nclass Solution {\\n    private:\\n    bool solve(string &s1,int i, string &s2, int j,string &s3,int k,vector<vector<vector<int>>>&dp){\\n        if(k == s3.length())return true;\\n        if(dp[i][j][k] != -1)return dp[i][j][k];\\n        if(i < s1.size() && s1[i] == s3[k]  && j<s2.size() && s2[j] == s3[k]){\\n            return  dp[i][j][k]=solve(s1,i+1,s2,j,s3,k+1,dp) || solve(s1,i,s2,j+1,s3,k+1,dp);\\n        }\\n        else if(i < s1.size() && s1[i] == s3[k]){\\n            return  dp[i][j][k]=solve(s1,i+1,s2,j,s3,k+1,dp);\\n        }\\n        else if (j<s2.size() && s2[j] == s3[k]){ \\n            return  dp[i][j][k]=solve(s1,i,s2,j+1,s3,k+1,dp);\\n        }\\n        else return  dp[i][j][k]=false;\\n    }\\npublic:\\n\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.size() + s2.size() != s3.size())return false;\\n        vector<vector<vector<int>>>dp(s1.size()+ 1, vector<vector<int>>(s2.size()+1,vector<int>(s3.size()+1,-1)));\\n        return solve(s1,0,s2,0,s3,0,dp);\\n    }\\n\\n};\\n```\\n---\\n![image.png](https://assets.leetcode.com/users/images/9a3019b7-d663-4c47-94a6-c33d8916a04b_1692943277.9862583.png)\\n\\n---\\nDO UPVOTE\\u2B06\\uFE0F\\nDROP YOUR SUGGESTIONS IN THE COMMENT\\n\\nKeep Coding\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n-- *MR.ROBOT SIGNING OFF*\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    bool solve(string &s1,int i, string &s2, int j,string &s3,int k){\\n        if(k == s3.length())return true;\\n        if(i < s1.size() && s1[i] == s3[k]  && j<s2.size() && s2[j] == s3[k]){\\n           \\n            return solve(s1,i+1,s2,j,s3,k+1) ||  solve(s1,i,s2,j+1,s3,k+1);\\n        }\\n        else if(i < s1.size() && s1[i] == s3[k]){\\n           \\n            return solve(s1,i+1,s2,j,s3,k+1);\\n        }\\n        else if (j<s2.size() && s2[j] == s3[k]){\\n          \\n            return solve(s1,i,s2,j+1,s3,k+1);\\n        }\\n        else return false;\\n    }\\npublic:\\n\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.size() + s2.size() != s3.size())return false;\\n        return solve(s1,0,s2,0,s3,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private:\\n    bool solve(string &s1,int i, string &s2, int j,string &s3,int k,vector<vector<vector<int>>>&dp){\\n        if(k == s3.length())return true;\\n        if(dp[i][j][k] != -1)return dp[i][j][k];\\n        if(i < s1.size() && s1[i] == s3[k]  && j<s2.size() && s2[j] == s3[k]){\\n            return  dp[i][j][k]=solve(s1,i+1,s2,j,s3,k+1,dp) || solve(s1,i,s2,j+1,s3,k+1,dp);\\n        }\\n        else if(i < s1.size() && s1[i] == s3[k]){\\n            return  dp[i][j][k]=solve(s1,i+1,s2,j,s3,k+1,dp);\\n        }\\n        else if (j<s2.size() && s2[j] == s3[k]){ \\n            return  dp[i][j][k]=solve(s1,i,s2,j+1,s3,k+1,dp);\\n        }\\n        else return  dp[i][j][k]=false;\\n    }\\npublic:\\n\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.size() + s2.size() != s3.size())return false;\\n        vector<vector<vector<int>>>dp(s1.size()+ 1, vector<vector<int>>(s2.size()+1,vector<int>(s3.size()+1,-1)));\\n        return solve(s1,0,s2,0,s3,0,dp);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957156,
                "title": "video-solution-explanation-with-drawings-in-depth-c-java",
                "content": "# Intuition, approach, and complexity disucssed in detail in video solution\\nhttps://youtu.be/_X9aOayXvl0\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        if((len1 + len2) != len3){\\n            return false;\\n        }\\n        vector<vector<bool>> indxState(len1+1, vector<bool>(len2+1, false));\\n        indxState[0][0] = true;\\n\\n        for(int indx1 = 1; indx1<indxState.size(); indx1++){\\n            indxState[indx1][0] = indxState[indx1-1][0] && (s1[indx1-1] == s3[indx1-1]); \\n        }\\n        for(int indx2 = 1; indx2<indxState[0].size(); indx2++){\\n            indxState[0][indx2] = indxState[0][indx2-1] && (s2[indx2-1] == s3[indx2-1]);\\n        }\\n        for(int indx1 = 1; indx1<indxState.size(); indx1++){\\n            for(int indx2 = 1; indx2<indxState[0].size(); indx2++){\\n                indxState[indx1][indx2] = (indxState[indx1-1][indx2] && s1[indx1-1] == s3[indx1+indx2-1]) || (indxState[indx1][indx2-1] && s2[indx2-1] == s3[indx1+indx2-1]); \\n            }\\n        }\\n        return indxState[len1][len2];\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n           int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        if((len1 + len2) != len3){\\n            return false;\\n        }\\n        boolean indxState[][] = new boolean[len1+1][len2+1];\\n        indxState[0][0] = true;\\n\\n        for(int indx1 = 1; indx1<indxState.length; indx1++){\\n            indxState[indx1][0] = indxState[indx1-1][0] && (s1.charAt(indx1-1) == s3.charAt(indx1-1)); \\n        }\\n        for(int indx2 = 1; indx2<indxState[0].length; indx2++){\\n            indxState[0][indx2] = indxState[0][indx2-1] && (s2.charAt(indx2-1) == s3.charAt(indx2-1));\\n        }\\n        for(int indx1 = 1; indx1<indxState.length; indx1++){\\n            for(int indx2 = 1; indx2<indxState[0].length; indx2++){\\n                indxState[indx1][indx2] = (indxState[indx1-1][indx2] && s1.charAt(indx1-1) == s3.charAt(indx1+indx2-1)) || (indxState[indx1][indx2-1] && s2.charAt(indx2-1) == s3.charAt(indx1+indx2-1)); \\n            }\\n        }\\n        return indxState[len1][len2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        if((len1 + len2) != len3){\\n            return false;\\n        }\\n        vector<vector<bool>> indxState(len1+1, vector<bool>(len2+1, false));\\n        indxState[0][0] = true;\\n\\n        for(int indx1 = 1; indx1<indxState.size(); indx1++){\\n            indxState[indx1][0] = indxState[indx1-1][0] && (s1[indx1-1] == s3[indx1-1]); \\n        }\\n        for(int indx2 = 1; indx2<indxState[0].size(); indx2++){\\n            indxState[0][indx2] = indxState[0][indx2-1] && (s2[indx2-1] == s3[indx2-1]);\\n        }\\n        for(int indx1 = 1; indx1<indxState.size(); indx1++){\\n            for(int indx2 = 1; indx2<indxState[0].size(); indx2++){\\n                indxState[indx1][indx2] = (indxState[indx1-1][indx2] && s1[indx1-1] == s3[indx1+indx2-1]) || (indxState[indx1][indx2-1] && s2[indx2-1] == s3[indx1+indx2-1]); \\n            }\\n        }\\n        return indxState[len1][len2];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n           int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        if((len1 + len2) != len3){\\n            return false;\\n        }\\n        boolean indxState[][] = new boolean[len1+1][len2+1];\\n        indxState[0][0] = true;\\n\\n        for(int indx1 = 1; indx1<indxState.length; indx1++){\\n            indxState[indx1][0] = indxState[indx1-1][0] && (s1.charAt(indx1-1) == s3.charAt(indx1-1)); \\n        }\\n        for(int indx2 = 1; indx2<indxState[0].length; indx2++){\\n            indxState[0][indx2] = indxState[0][indx2-1] && (s2.charAt(indx2-1) == s3.charAt(indx2-1));\\n        }\\n        for(int indx1 = 1; indx1<indxState.length; indx1++){\\n            for(int indx2 = 1; indx2<indxState[0].length; indx2++){\\n                indxState[indx1][indx2] = (indxState[indx1-1][indx2] && s1.charAt(indx1-1) == s3.charAt(indx1+indx2-1)) || (indxState[indx1][indx2-1] && s2.charAt(indx2-1) == s3.charAt(indx1+indx2-1)); \\n            }\\n        }\\n        return indxState[len1][len2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956862,
                "title": "c-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if (s3.size() != s1.size() + s2.size()) {\\n            return false;\\n        }\\n        return dfs(s1, s2, s3, 0, 0);\\n    }\\nprivate:\\n    map<pair<int, int>, bool> dp;\\n    \\n    bool dfs(string s1, string s2, string s3, int i, int j) {\\n        if (i == s1.size() && j == s2.size()) {\\n            return true;\\n        }\\n        if (dp.find({i, j}) != dp.end()) {\\n            return dp[{i, j}];\\n        }\\n        \\n        if (i < s1.size() && s1[i] == s3[i + j] && dfs(s1, s2, s3, i + 1, j)) {\\n            return true;\\n        }\\n        if (j < s2.size() && s2[j] == s3[i + j] && dfs(s1, s2, s3, i, j + 1)) {\\n            return true;\\n        }\\n        \\n        dp[{i, j}] = false;\\n        return dp[{i, j}];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if (s3.size() != s1.size() + s2.size()) {\\n            return false;\\n        }\\n        return dfs(s1, s2, s3, 0, 0);\\n    }\\nprivate:\\n    map<pair<int, int>, bool> dp;\\n    \\n    bool dfs(string s1, string s2, string s3, int i, int j) {\\n        if (i == s1.size() && j == s2.size()) {\\n            return true;\\n        }\\n        if (dp.find({i, j}) != dp.end()) {\\n            return dp[{i, j}];\\n        }\\n        \\n        if (i < s1.size() && s1[i] == s3[i + j] && dfs(s1, s2, s3, i + 1, j)) {\\n            return true;\\n        }\\n        if (j < s2.size() && s2[j] == s3[i + j] && dfs(s1, s2, s3, i, j + 1)) {\\n            return true;\\n        }\\n        \\n        dp[{i, j}] = false;\\n        return dp[{i, j}];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956861,
                "title": "very-simple-dp-code-memoization-c",
                "content": "# Intuition\\n\\n# Approach\\nThere are three states of dp in this question :\\n- character of string s3 matches with s1 and s2\\n- character of string s3 matches with string s1 only\\n- character of string s3 matches with string s2 only\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n     bool solve(int i,int j, int k,string s1,string s2,string s3,vector<vector<int>>&dp){\\n      if(i==s1.size() && j==s2.size() && k==s3.size()) return true;\\n      if(i<s1.size() && j<s2.size() && dp[i][j]!=-1) return dp[i][j];\\n      if(i<s1.size() && j<s2.size() && s1[i]==s3[k] && s2[j]==s3[k]){\\n       return dp[i][j]= solve(i+1,j,k+1,s1,s2,s3,dp)||solve(i,j+1,k+1,s1,s2,s3,dp);\\n      }else if(i<s1.size() && s1[i]==s3[k]){\\n        return dp[i][j]=solve(i+1,j,k+1,s1,s2,s3,dp);\\n       }else if(j<s2.size() && s2[j]==s3[k]){\\n         return dp[i][j]=solve(i,j+1,k+1,s1,s2,s3,dp);\\n       }\\n         return dp[i][j]= false;  \\n            \\n     }\\n     \\n    bool isInterleave(string s1, string s2, string s3) {\\n      if(s1.size()+s2.size() !=s3.size()) return false;\\n      vector<vector<int>>dp(s1.size()+1,vector<int>(s2.size()+1,-1));\\n     return solve(0,0,0,s1,s2,s3,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n     bool solve(int i,int j, int k,string s1,string s2,string s3,vector<vector<int>>&dp){\\n      if(i==s1.size() && j==s2.size() && k==s3.size()) return true;\\n      if(i<s1.size() && j<s2.size() && dp[i][j]!=-1) return dp[i][j];\\n      if(i<s1.size() && j<s2.size() && s1[i]==s3[k] && s2[j]==s3[k]){\\n       return dp[i][j]= solve(i+1,j,k+1,s1,s2,s3,dp)||solve(i,j+1,k+1,s1,s2,s3,dp);\\n      }else if(i<s1.size() && s1[i]==s3[k]){\\n        return dp[i][j]=solve(i+1,j,k+1,s1,s2,s3,dp);\\n       }else if(j<s2.size() && s2[j]==s3[k]){\\n         return dp[i][j]=solve(i,j+1,k+1,s1,s2,s3,dp);\\n       }\\n         return dp[i][j]= false;  \\n            \\n     }\\n     \\n    bool isInterleave(string s1, string s2, string s3) {\\n      if(s1.size()+s2.size() !=s3.size()) return false;\\n      vector<vector<int>>dp(s1.size()+1,vector<int>(s2.size()+1,-1));\\n     return solve(0,0,0,s1,s2,s3,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956476,
                "title": "javascript-solution-explanation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @param {string} s3\\n * @return {boolean}\\n */\\n\\nfunction isInterleave(s1, s2, s3) {\\n    // Check if the total length of s1 and s2 is equal to s3\\n    if (s1.length + s2.length !== s3.length) {\\n        return false;\\n    }\\n\\n    // Create a 2D dynamic programming array dp\\n    const dp = new Array(s1.length + 1).fill(false).map(() => new Array(s2.length + 1).fill(false));\\n\\n    // Base case: Both s1 and s2 are empty, and s3 is also empty\\n    dp[0][0] = true;\\n\\n    // Fill the first column of dp using s1 and s3\\n    for (let i = 1; i <= s1.length; i++) {\\n        dp[i][0] = dp[i - 1][0] && s1[i - 1] === s3[i - 1];\\n    }\\n\\n    // Fill the first row of dp using s2 and s3\\n    for (let j = 1; j <= s2.length; j++) {\\n        dp[0][j] = dp[0][j - 1] && s2[j - 1] === s3[j - 1];\\n    }\\n\\n    // Fill the rest of the dp array based on character matching logic\\n    for (let i = 1; i <= s1.length; i++) {\\n        for (let j = 1; j <= s2.length; j++) {\\n            dp[i][j] = (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]) ||\\n                       (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1]);\\n        }\\n    }\\n\\n    // Return whether the last cell of dp is true, indicating s3 can be formed by interleaving s1 and s2\\n    return dp[s1.length][s2.length];\\n}\\n\\nconst s1 = \"aabcc\";\\nconst s2 = \"dbbca\";\\nconst s3 = \"aadbbcbcac\";\\nconsole.log(isInterleave(s1, s2, s3)); // Output: true\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @param {string} s3\\n * @return {boolean}\\n */\\n\\nfunction isInterleave(s1, s2, s3) {\\n    // Check if the total length of s1 and s2 is equal to s3\\n    if (s1.length + s2.length !== s3.length) {\\n        return false;\\n    }\\n\\n    // Create a 2D dynamic programming array dp\\n    const dp = new Array(s1.length + 1).fill(false).map(() => new Array(s2.length + 1).fill(false));\\n\\n    // Base case: Both s1 and s2 are empty, and s3 is also empty\\n    dp[0][0] = true;\\n\\n    // Fill the first column of dp using s1 and s3\\n    for (let i = 1; i <= s1.length; i++) {\\n        dp[i][0] = dp[i - 1][0] && s1[i - 1] === s3[i - 1];\\n    }\\n\\n    // Fill the first row of dp using s2 and s3\\n    for (let j = 1; j <= s2.length; j++) {\\n        dp[0][j] = dp[0][j - 1] && s2[j - 1] === s3[j - 1];\\n    }\\n\\n    // Fill the rest of the dp array based on character matching logic\\n    for (let i = 1; i <= s1.length; i++) {\\n        for (let j = 1; j <= s2.length; j++) {\\n            dp[i][j] = (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]) ||\\n                       (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1]);\\n        }\\n    }\\n\\n    // Return whether the last cell of dp is true, indicating s3 can be formed by interleaving s1 and s2\\n    return dp[s1.length][s2.length];\\n}\\n\\nconst s1 = \"aabcc\";\\nconst s2 = \"dbbca\";\\nconst s3 = \"aadbbcbcac\";\\nconsole.log(isInterleave(s1, s2, s3)); // Output: true\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3786588,
                "title": "backtracking-with-memoization-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea is that we create this type of a path \\n\\n\\n![image.png](https://assets.leetcode.com/users/images/a028a997-21fc-4f04-8b14-e6c7b78cf49e_1689750812.7706375.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf char from s1 is chosen we travel downwards (i+1 ,j) \\n\\nand char from s2 is chosen we travel to the right.\\n\\nand there we update the value.\\n\\n\\n\\nThe trace on the dict is as follows :\\n\\n{(5, 3): False, (5, 5): True, (4, 5): True, (4, 4): True, (4, 3): True, (4, 2): True, (3, 2): True, (3, 1): True, (2, 1): True, (2, 0): True, (1, 0): True, (0, 0): True}\\n\\nGoing from last to first The right path would be like:\\n\\n![image.png](https://assets.leetcode.com/users/images/c3d4b55e-d142-4fef-890b-54d03fa6409a_1689752315.7093666.png)\\n\\nNote :**The movement is backwards and we check the incremented cell before we update our current cell.**\\n\\nIn this wrong trace where \\'c\\' was chosen from s1 , we would not have gotten the subset and thus that backtracking run has failed\\n\\n![image.png](https://assets.leetcode.com/users/images/e9af376b-b69c-4ed0-8458-66dcb3e68e4c_1689752552.5403507.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n\\n# Code\\n```\\nclass Solution:\\n\\n    \\'\\'\\'\\n            This recursion goes all in and backtracks\\n\\n            Goal string : aadbbcbcac\\n\\n             +---+---+---+---+---+---+\\n            |   | d | b | b | c |   |\\n            +---+---+---+---+---+---+\\n            | a |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            | a |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            | b |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            | c |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            | c |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            |   |   |   |   |   | T |\\n            +---+---+---+---+---+---+\\n\\n\\n    \\'\\'\\'\\n    \\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        def topDownBacktrack(i,j):\\n            # Bottom Up approach This is the goal state\\n            if i == len(s1) and j == len(s2):\\n                return True \\n            # using memo\\n            if (i,j) in dp:\\n                return dp[(i,j)]\\n\\n            if i < len(s1) and s1[i] == s3[i+j] and topDownBacktrack(i+1,j) : # Checking if we take the s1 substring \\n                dp[(i,j)] = True\\n                return True\\n            if j < len(s2) and s2[j] == s3[i+j] and topDownBacktrack(i,j+1) : # Checking if we take the s2 substring\\n                dp[(i,j)] = True\\n                return True\\n            dp[(i,j)] = False\\n            return False\\n            \\n\\n        if len(s1) +len(s2) != len(s3):\\n            return False\\n\\n        dp = {} #memo : [(i,j)] = True or False, need to only mark false nodes\\n        \\n\\n        \\n        \\n\\n        # while i <= len(s1) and j <=len(s2) and i+j len(s3):\\n            \\n            \\n            \\n        return topDownBacktrack(0,0)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n\\n    \\'\\'\\'\\n            This recursion goes all in and backtracks\\n\\n            Goal string : aadbbcbcac\\n\\n             +---+---+---+---+---+---+\\n            |   | d | b | b | c |   |\\n            +---+---+---+---+---+---+\\n            | a |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            | a |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            | b |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            | c |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            | c |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            |   |   |   |   |   | T |\\n            +---+---+---+---+---+---+\\n\\n\\n    \\'\\'\\'\\n    \\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        def topDownBacktrack(i,j):\\n            # Bottom Up approach This is the goal state\\n            if i == len(s1) and j == len(s2):\\n                return True \\n            # using memo\\n            if (i,j) in dp:\\n                return dp[(i,j)]\\n\\n            if i < len(s1) and s1[i] == s3[i+j] and topDownBacktrack(i+1,j) : # Checking if we take the s1 substring \\n                dp[(i,j)] = True\\n                return True\\n            if j < len(s2) and s2[j] == s3[i+j] and topDownBacktrack(i,j+1) : # Checking if we take the s2 substring\\n                dp[(i,j)] = True\\n                return True\\n            dp[(i,j)] = False\\n            return False\\n            \\n\\n        if len(s1) +len(s2) != len(s3):\\n            return False\\n\\n        dp = {} #memo : [(i,j)] = True or False, need to only mark false nodes\\n        \\n\\n        \\n        \\n\\n        # while i <= len(s1) and j <=len(s2) and i+j len(s3):\\n            \\n            \\n            \\n        return topDownBacktrack(0,0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146211,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int rec(int i1,int i2,int i3,string &s1,string &s2,string &s3,int n1,int n2,int n3,vector<vector<vector<int>>>&dp)\\n   {\\n       if (i1==n1 && i2==n2 && i3==n3)\\n       return 1;\\n       if (i3==n3) return 0;\\n       if (dp[i1][i2][i3]!=-1) return dp[i1][i2][i3];\\n       int a=0;\\n       if(i1<n1 && s3[i3]==s1[i1])\\n       a=rec(i1+1,i2,i3+1,s1,s2,s3,n1,n2,n3,dp);\\n       int b=0;\\n        if(i2<n2 && s3[i3]==s2[i2])\\n       b=rec(i1,i2+1,i3+1,s1,s2,s3,n1,n2,n3,dp);\\n       return dp[i1][i2][i3]=a||b;\\n   }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size(),n2=s2.size(),n3=s3.size();\\n        vector<vector<vector<int>>>dp(n1+1,vector<vector<int>>(n2+1,vector<int>(n3+1,-1)));\\n        return rec(0,0,0,s1,s2,s3,n1,n2,n3,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int rec(int i1,int i2,int i3,string &s1,string &s2,string &s3,int n1,int n2,int n3,vector<vector<vector<int>>>&dp)\\n   {\\n       if (i1==n1 && i2==n2 && i3==n3)\\n       return 1;\\n       if (i3==n3) return 0;\\n       if (dp[i1][i2][i3]!=-1) return dp[i1][i2][i3];\\n       int a=0;\\n       if(i1<n1 && s3[i3]==s1[i1])\\n       a=rec(i1+1,i2,i3+1,s1,s2,s3,n1,n2,n3,dp);\\n       int b=0;\\n        if(i2<n2 && s3[i3]==s2[i2])\\n       b=rec(i1,i2+1,i3+1,s1,s2,s3,n1,n2,n3,dp);\\n       return dp[i1][i2][i3]=a||b;\\n   }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size(),n2=s2.size(),n3=s3.size();\\n        vector<vector<vector<int>>>dp(n1+1,vector<vector<int>>(n2+1,vector<int>(n3+1,-1)));\\n        return rec(0,0,0,s1,s2,s3,n1,n2,n3,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576535,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1646591,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 2029056,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1576855,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568627,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 2029275,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568580,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 2029043,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570461,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567151,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1576535,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1646591,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 2029056,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1576855,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568627,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 2029275,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568580,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 2029043,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570461,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567151,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566477,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 2030001,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 2029182,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 1575397,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 2030072,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 2029778,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 1576218,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 2029643,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 2029496,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 2029343,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 2029121,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 1944239,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 1575375,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 1572625,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 1571211,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 1575347,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 2043146,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 2032884,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 2031581,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 2030326,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 2030217,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2030197,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2030096,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2030092,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2029995,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2029886,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2029879,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2029827,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2029820,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2029809,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2029768,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029709,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029662,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029600,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029564,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029559,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029518,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029479,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029477,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029419,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029248,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 2029134,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 2029075,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 2029021,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 2029017,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 2020501,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 2014006,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 1967139,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 1953238,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 1926683,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            }
        ]
    }
]