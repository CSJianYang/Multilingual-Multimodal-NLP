[
    {
        "title": "Island Perimeter",
        "question_content": "You are given row x col grid representing a map where grid[i][j] = 1 represents&nbsp;land and grid[i][j] = 0 represents water.\nGrid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn't have \"lakes\", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\n&nbsp;\nExample 1:\n\nInput: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\nOutput: 16\nExplanation: The perimeter is the 16 yellow stripes in the image above.\n\nExample 2:\n\nInput: grid = [[1]]\nOutput: 4\n\nExample 3:\n\nInput: grid = [[1,0]]\nOutput: 4\n\n&nbsp;\nConstraints:\n\n\trow == grid.length\n\tcol == grid[i].length\n\t1 <= row, col <= 100\n\tgrid[i][j] is 0 or 1.\n\tThere is exactly one island in grid.",
        "solutions": [
            {
                "id": 95001,
                "title": "clear-and-easy-java-solution",
                "content": "1. loop over the matrix and count the number of islands;\\n2. if the current dot is an island, count if it has any right neighbour or down neighbour;\\n3. the result is islands * 4 - neighbours * 2\\n\\n```\\npublic class Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int islands = 0, neighbours = 0;\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    islands++; // count islands\\n                    if (i < grid.length - 1 && grid[i + 1][j] == 1) neighbours++; // count down neighbours\\n                    if (j < grid[i].length - 1 && grid[i][j + 1] == 1) neighbours++; // count right neighbours\\n                }\\n            }\\n        }\\n\\n        return islands * 4 - neighbours * 2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int islands = 0, neighbours = 0;\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    islands++; // count islands\\n                    if (i < grid.length - 1 && grid[i + 1][j] == 1) neighbours++; // count down neighbours\\n                    if (j < grid[i].length - 1 && grid[i][j + 1] == 1) neighbours++; // count right neighbours\\n                }\\n            }\\n        }\\n\\n        return islands * 4 - neighbours * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95126,
                "title": "c-solution-with-explanation",
                "content": "1. find how many 1 in the map. If without the consideration of surrounding cells, the total perimeter should be the total amount of 1 times 4. \\n2. find how many cell walls that connect with both lands. We need to deduct twice of those lines from total perimeter\\n```\\nint islandPerimeter(vector<vector<int>>& grid) {\\n        int count=0, repeat=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0; j<grid[i].size();j++)\\n                {\\n                    if(grid[i][j]==1)\\n                    {\\n                        count ++;\\n                        if(i!=0 && grid[i-1][j] == 1) repeat++;\\n                        if(j!=0 && grid[i][j-1] == 1) repeat++;\\n                    }\\n                }\\n        }\\n        return 4*count-repeat*2;\\n    }\\n```\\n@msg  thanks for the edit",
                "solutionTags": [],
                "code": "```\\nint islandPerimeter(vector<vector<int>>& grid) {\\n        int count=0, repeat=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0; j<grid[i].size();j++)\\n                {\\n                    if(grid[i][j]==1)\\n                    {\\n                        count ++;\\n                        if(i!=0 && grid[i-1][j] == 1) repeat++;\\n                        if(j!=0 && grid[i][j-1] == 1) repeat++;\\n                    }\\n                }\\n        }\\n        return 4*count-repeat*2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94992,
                "title": "java-9-line-solution-add-4-for-each-land-and-remove-2-for-each-internal-edge",
                "content": "```\\npublic static int islandPerimeter(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        int result = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    result += 4;\\n                    if (i > 0 && grid[i-1][j] == 1) result -= 2;\\n                    if (j > 0 && grid[i][j-1] == 1) result -= 2;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int islandPerimeter(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        int result = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    result += 4;\\n                    if (i > 0 && grid[i-1][j] == 1) result -= 2;\\n                    if (j > 0 && grid[i][j-1] == 1) result -= 2;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 723842,
                "title": "python-o-mn-simple-loop-solution-explained",
                "content": "How we can evaluate perimeter of our island? We can evaluate perimeters off all squares first, and then subtract all sides of cells, which need to be removed, and that is all!\\n\\n1. Perimeter of each cell is equal to `4`, so when we see non-empty cell, we add `4`.\\n2. For each non-empty cell with coordinates `(i,j)`, if `(i-1,j)` also non-empty, we need to subract `1` from our perimeter, which can be done with line `Perimeter -= grid[i][j]*grid[i-1][j]`. Note, that for the case `1 1`, we subtract `1` twice, so perimeter will be `4+4-1-1 = 6`, as it should be. Similar for other neibours of cell `(i,j)`.\\n\\n![image](https://assets.leetcode.com/users/images/5e2c58ea-946c-4b65-a95b-1a19af0becba_1594131840.7698135.png)\\n\\n\\n\\n\\n**Complexity**: time complexity is `O(mn)`, because we traverse our grid once and for each cell check `4` neighbors. Space complexity is `O(1)`, because we do not use any extraspace, only `Perimeter`.\\n\\n\\n```\\nclass Solution:\\n    def islandPerimeter(self, grid):\\n        m, n, Perimeter = len(grid), len(grid[0]), 0\\n\\n        for i in range(m):\\n            for j in range(n):\\n                Perimeter += 4*grid[i][j]\\n                if i > 0:   Perimeter -= grid[i][j]*grid[i-1][j]\\n                if i < m-1: Perimeter -= grid[i][j]*grid[i+1][j]\\n                if j > 0:   Perimeter -= grid[i][j]*grid[i][j-1]\\n                if j < n-1: Perimeter -= grid[i][j]*grid[i][j+1]\\n                    \\n        return Perimeter\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid):\\n        m, n, Perimeter = len(grid), len(grid[0]), 0\\n\\n        for i in range(m):\\n            for j in range(n):\\n                Perimeter += 4*grid[i][j]\\n                if i > 0:   Perimeter -= grid[i][j]*grid[i-1][j]\\n                if i < m-1: Perimeter -= grid[i][j]*grid[i+1][j]\\n                if j > 0:   Perimeter -= grid[i][j]*grid[i][j-1]\\n                if j < n-1: Perimeter -= grid[i][j]*grid[i][j+1]\\n                    \\n        return Perimeter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95007,
                "title": "short-python",
                "content": "Since there are no lakes, every pair of neighbour cells with different values is part of the perimeter (more precisely, the edge between them is). So just count the differing pairs, both horizontally and vertically (for the latter I simply transpose the grid).\\n\\n    def islandPerimeter(self, grid):\\n        return sum(sum(map(operator.ne, [0] + row, row + [0]))\\n                   for row in grid + map(list, zip(*grid)))",
                "solutionTags": [],
                "code": "Since there are no lakes, every pair of neighbour cells with different values is part of the perimeter (more precisely, the edge between them is). So just count the differing pairs, both horizontally and vertically (for the latter I simply transpose the grid).\\n\\n    def islandPerimeter(self, grid):\\n        return sum(sum(map(operator.ne, [0] + row, row + [0]))\\n                   for row in grid + map(list, zip(*grid)))",
                "codeTag": "Python3"
            },
            {
                "id": 95004,
                "title": "java-solution-with-dfs",
                "content": "```\\npublic class Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        if (grid == null) return 0;\\n        for (int i = 0 ; i < grid.length ; i++){\\n            for (int j = 0 ; j < grid[0].length ; j++){\\n                if (grid[i][j] == 1) {\\n                    return getPerimeter(grid,i,j);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    public int getPerimeter(int[][] grid, int i, int j){\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {return 1;}\\n        if (grid[i][j] == 0) {\\n            return 1;\\n        }\\n        if (grid[i][j] == -1) return 0;\\n        \\n        int count = 0;\\n        grid[i][j] = -1;\\n        \\n        count += getPerimeter(grid, i-1, j);\\n        count += getPerimeter(grid, i, j-1);\\n        count += getPerimeter(grid, i, j+1);\\n        count += getPerimeter(grid, i+1, j);\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        if (grid == null) return 0;\\n        for (int i = 0 ; i < grid.length ; i++){\\n            for (int j = 0 ; j < grid[0].length ; j++){\\n                if (grid[i][j] == 1) {\\n                    return getPerimeter(grid,i,j);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    public int getPerimeter(int[][] grid, int i, int j){\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {return 1;}\\n        if (grid[i][j] == 0) {\\n            return 1;\\n        }\\n        if (grid[i][j] == -1) return 0;\\n        \\n        int count = 0;\\n        grid[i][j] = -1;\\n        \\n        count += getPerimeter(grid, i-1, j);\\n        count += getPerimeter(grid, i, j-1);\\n        count += getPerimeter(grid, i, j+1);\\n        count += getPerimeter(grid, i+1, j);\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 624178,
                "title": "cpp-very-easy-solution-with-explaination-no-dfs",
                "content": "![image](https://assets.leetcode.com/users/ankit2020k/image_1589096397.png)\\n\\n**the approach i used in code is **\\n1) count all \"1\". suppose the number of 1 in grid is \"t\"\\n2) ans = t*4 \\n3) now subtract the number of neighbour from it for each 1;\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int m = grid.size(); //row\\n        int n = grid[0].size(); //column\\n        int ans =0;\\n        for(int i =0;i<m;i++)\\n        {\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(grid[i][j] == 1)\\n                { ans+=4; \\n                     \\n                 \\n                   if( i+1 <m  && grid[i+1][j] == 1  )  // if down neighbour is there\\n                   {        ans--;}\\n                 if(   i-1 >=0 && grid[i-1][j] == 1 ) // if upward neighbour is there\\n                 { ans--;}\\n                   if(   j-1>=0  && grid[i][j-1] == 1)  // if left neighbour is there\\n                   {     ans--;}\\n                 if(  j+1<n && grid[i][j+1] == 1 ) // if right neighbour is there\\n                 { ans--;}\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```*\\n\\nask in comment if u have any doubt in any line of this code..\\nand pls upvote it (upvoting it will motivate me to come with more better solution) if u found it useful\\u263A\\uFE0F \\nthankyou\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int m = grid.size(); //row\\n        int n = grid[0].size(); //column\\n        int ans =0;\\n        for(int i =0;i<m;i++)\\n        {\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(grid[i][j] == 1)\\n                { ans+=4; \\n                     \\n                 \\n                   if( i+1 <m  && grid[i+1][j] == 1  )  // if down neighbour is there\\n                   {        ans--;}\\n                 if(   i-1 >=0 && grid[i-1][j] == 1 ) // if upward neighbour is there\\n                 { ans--;}\\n                   if(   j-1>=0  && grid[i][j-1] == 1)  // if left neighbour is there\\n                   {     ans--;}\\n                 if(  j+1<n && grid[i][j+1] == 1 ) // if right neighbour is there\\n                 { ans--;}\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95003,
                "title": "easy-to-read-python-solution",
                "content": "```\\nclass Solution(object):\\n    def islandPerimeter(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0\\n\\n        def sum_adjacent(i, j):\\n            adjacent = (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1),\\n            res = 0\\n            for x, y in adjacent:\\n                if x < 0 or y < 0 or x == len(grid) or y == len(grid[0]) or grid[x][y] == 0:\\n                    res += 1\\n            return res\\n\\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    count += sum_adjacent(i, j)\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def islandPerimeter(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0\\n\\n        def sum_adjacent(i, j):\\n            adjacent = (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1),\\n            res = 0\\n            for x, y in adjacent:\\n                if x < 0 or y < 0 or x == len(grid) or y == len(grid[0]) or grid[x][y] == 0:\\n                    res += 1\\n            return res\\n\\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    count += sum_adjacent(i, j)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502418,
                "title": "c-java-python-think-straightforward-o-1-in-space-clean-concise",
                "content": "**Idea**\\n- Let `perimeter` be the perimeter of the island of the grid.\\n- For a land cell:\\n\\t- There are 4 sides, so `perimeter += 4`.\\n\\t- We check 4 neighbors of that land cell:\\n\\t\\t- If a neighbor cell is a land then **the common side between current cell and its neighbor** doesn\\'t count in perimeter, so `perimeter -= 1`.\\n\\n![image](https://assets.leetcode.com/users/images/4f4393d9-cbc0-45a3-8a8c-1e5a4a6b045a_1633325385.8200758.png)\\n\\n\\n<iframe src=\"https://leetcode.com/playground/fNHMFg8v/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n**Complexity**\\n- Time: `O(row * col)`, where `row <= 100` is the number of rows, `col <= 100` is the number of columns of the grid.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "**Idea**\\n- Let `perimeter` be the perimeter of the island of the grid.\\n- For a land cell:\\n\\t- There are 4 sides, so `perimeter += 4`.\\n\\t- We check 4 neighbors of that land cell:\\n\\t\\t- If a neighbor cell is a land then **the common side between current cell and its neighbor** doesn\\'t count in perimeter, so `perimeter -= 1`.\\n\\n![image](https://assets.leetcode.com/users/images/4f4393d9-cbc0-45a3-8a8c-1e5a4a6b045a_1633325385.8200758.png)\\n\\n\\n<iframe src=\"https://leetcode.com/playground/fNHMFg8v/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n**Complexity**\\n- Time: `O(row * col)`, where `row <= 100` is the number of rows, `col <= 100` is the number of columns of the grid.\\n- Space: `O(1)`",
                "codeTag": "Unknown"
            },
            {
                "id": 95113,
                "title": "easy-and-clear-python-solution",
                "content": "```\\ndef islandPerimeter(self, grid):\\n    \"\"\"\\n    :type grid: List[List[int]]\\n    :rtype: int\\n    \"\"\"\\n    s, m = len(grid), len(grid[0])\\n    ans = 0\\n    for x in xrange(s):\\n        for y in xrange(m):\\n            if grid[x][y] == 1:\\n                ans += 4\\n                if x < s - 1 and grid[x+1][y] == 1:\\n                    ans -= 2\\n                if y < m - 1 and grid[x][y+1] == 1:\\n                    ans -= 2\\n                    \\n    return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef islandPerimeter(self, grid):\\n    \"\"\"\\n    :type grid: List[List[int]]\\n    :rtype: int\\n    \"\"\"\\n    s, m = len(grid), len(grid[0])\\n    ans = 0\\n    for x in xrange(s):\\n        for y in xrange(m):\\n            if grid[x][y] == 1:\\n                ans += 4\\n                if x < s - 1 and grid[x+1][y] == 1:\\n                    ans -= 2\\n                if y < m - 1 and grid[x][y+1] == 1:\\n                    ans -= 2\\n                    \\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1502532,
                "title": "python-straight-forward-approach-beats-98-69-submissions",
                "content": "Take the following single block as an example\\n![image](https://assets.leetcode.com/users/images/0e83f5ff-0648-4fed-8fc6-a0c10e8f9383_1633329700.4937315.png)\\nIt has four sides. So perimeter of one block is 4.\\n\\nNow take a look when two blocks intersect\\n![image](https://assets.leetcode.com/users/images/5ffe8b8c-0913-40b7-bdbd-806582a4b70f_1633329670.84569.png)\\nHere these blocks and they intersect at one edge. So perimeter(4+4=8) will be reduced by 2 (removing intersected edge at each square) upon each intersection. Each block in the land has four neighbours. We need to check whether the neighbour is land or not and decrement perimeter based on intersections.\\n\\nThe algorithm is simple as follows\\n1. Traverse the grid block by block\\n2. If the block is land increment perimeter by 4 and check it\\'s top and left neighbours. If the neighbours are land blocks decrement perimeter by 2 per intersection.\\n3.  Repeat the process until the whole grid is traversed\\n\\nTime Complexity: O(n^2)\\nSpace Complexity: O(1)\\n\\n```\\ndef islandPerimeter(self, grid: List[List[int]]) -> int:\\n\\t  R,C = len(grid), len(grid[0])\\n      perimeter = 0\\n\\t  # Traverse the grid\\n      for i in range(R):\\n        for j in range(C):\\n\\t\\t  # If it is a land block increment perimeter by 4\\n          if grid[i][j] == 1:\\n            perimeter += 4\\n\\t\\t\\t# Check whether top neighbour is a land and decrement it by 2\\n\\t\\t\\t# as it intersects\\n            if i>0 and grid[i-1][j] == 1:\\n              perimeter -= 2\\n\\t\\t\\t# Check left neighbour is a land and decrement it by 2\\n\\t\\t\\t# as it intersects\\n            if j>0 and grid[i][j-1] == 1:\\n              perimeter -= 2\\n      return perimeter\\n```\\n\\n![image](https://assets.leetcode.com/users/images/1a8f29f0-3b3b-4d0f-aa8f-37bfbb3b85a0_1633327869.711078.png)\\n\\nThanks for reading. If this post had helped you kindly upvote :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef islandPerimeter(self, grid: List[List[int]]) -> int:\\n\\t  R,C = len(grid), len(grid[0])\\n      perimeter = 0\\n\\t  # Traverse the grid\\n      for i in range(R):\\n        for j in range(C):\\n\\t\\t  # If it is a land block increment perimeter by 4\\n          if grid[i][j] == 1:\\n            perimeter += 4\\n\\t\\t\\t# Check whether top neighbour is a land and decrement it by 2\\n\\t\\t\\t# as it intersects\\n            if i>0 and grid[i-1][j] == 1:\\n              perimeter -= 2\\n\\t\\t\\t# Check left neighbour is a land and decrement it by 2\\n\\t\\t\\t# as it intersects\\n            if j>0 and grid[i][j-1] == 1:\\n              perimeter -= 2\\n      return perimeter\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 343154,
                "title": "solution-in-python-3",
                "content": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int: \\n    \\tM, N, p = len(grid), len(grid[0]), 0\\n    \\tfor m in range(M):\\n    \\t\\tfor n in range(N):\\n    \\t\\t\\tif grid[m][n] == 1:\\n    \\t\\t\\t\\tif m == 0   or grid[m-1][n] == 0: p += 1\\n    \\t\\t\\t\\tif n == 0   or grid[m][n-1] == 0: p += 1\\n    \\t\\t\\t\\tif n == N-1 or grid[m][n+1] == 0: p += 1\\n    \\t\\t\\t\\tif m == M-1 or grid[m+1][n] == 0: p += 1\\n    \\treturn p\\n\\t\\t\\n\\t\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int: \\n    \\tM, N, p = len(grid), len(grid[0]), 0\\n    \\tfor m in range(M):\\n    \\t\\tfor n in range(N):\\n    \\t\\t\\tif grid[m][n] == 1:\\n    \\t\\t\\t\\tif m == 0   or grid[m-1][n] == 0: p += 1\\n    \\t\\t\\t\\tif n == 0   or grid[m][n-1] == 0: p += 1\\n    \\t\\t\\t\\tif n == N-1 or grid[m][n+1] == 0: p += 1\\n    \\t\\t\\t\\tif m == M-1 or grid[m+1][n] == 0: p += 1\\n    \\treturn p\\n\\t\\t\\n\\t\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 95273,
                "title": "easy-dfs-solution-explaination-without-visited-array",
                "content": "The idea here is that each land cell contributes as many lines in perimeter as it's surrounded by water / boundary. \\n```\\nvoid dfs(vector<vector<int>>& b, int *ans, int i, int j) {\\n        if (i < 0 || i >= b.size() || j < 0 || j >= b[0].size() || b[i][j] != 1)\\n            return;\\n        b[i][j] = -1; // mark it as visited\\n        *ans += (j + 1 >= b[0].size() || b[i][j+1] == 0) /* right */ +\\n                (i - 1 < 0            || b[i-1][j] == 0) /* top */ +\\n                (j - 1 < 0            || b[i][j-1] == 0) /* left */ +\\n                (i + 1 >= b.size()    || b[i+1][j] == 0) /* bottom */;\\n        dfs(b, ans, i, j + 1);\\n        dfs(b, ans, i - 1, j);\\n        dfs(b, ans, i, j - 1);\\n        dfs(b, ans, i + 1, j);\\n        return;\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int ans = 0, i, j;\\n        for (i = 0; i < grid.size(); i++) {\\n            for (j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j]) {\\n                    dfs(grid, &ans, i, j);\\n                    return ans;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid dfs(vector<vector<int>>& b, int *ans, int i, int j) {\\n        if (i < 0 || i >= b.size() || j < 0 || j >= b[0].size() || b[i][j] != 1)\\n            return;\\n        b[i][j] = -1; // mark it as visited\\n        *ans += (j + 1 >= b[0].size() || b[i][j+1] == 0) /* right */ +\\n                (i - 1 < 0            || b[i-1][j] == 0) /* top */ +\\n                (j - 1 < 0            || b[i][j-1] == 0) /* left */ +\\n                (i + 1 >= b.size()    || b[i+1][j] == 0) /* bottom */;\\n        dfs(b, ans, i, j + 1);\\n        dfs(b, ans, i - 1, j);\\n        dfs(b, ans, i, j - 1);\\n        dfs(b, ans, i + 1, j);\\n        return;\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int ans = 0, i, j;\\n        for (i = 0; i < grid.size(); i++) {\\n            for (j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j]) {\\n                    dfs(grid, &ans, i, j);\\n                    return ans;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 373979,
                "title": "c-easy-solution-simple-beats-98-100-with-explanation",
                "content": "For every one we know that the square consists of four walls.\\nNow for every one found in the grid, don\\'t add the walls which are surrounded by other blocks (i.e. 1s). \\nAdd the ones not surrounded by any 1s (i.e. have 0 as adjacent element).\\n\\n\\n*Runtime: 52 ms, faster than 98.57% of C++ online submissions for Island Perimeter.\\nMemory Usage: 16.1 MB, less than 100.00% of C++ online submissions for Island Perimeter.*\\n\\n```\\nint islandPerimeter(vector<vector<int>>& grid) {\\n        \\n        int res = 0;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    res += (i == 0 || grid[i-1][j] == 0 ? 1 : 0);\\n                    res += (i == r-1 || grid[i+1][j] == 0 ? 1 : 0);\\n                    res += (j == 0 || grid[i][j-1] == 0 ? 1 : 0);\\n                    res += (j == c-1 || grid[i][j+1] == 0 ? 1 : 0);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "For every one we know that the square consists of four walls.\\nNow for every one found in the grid, don\\'t add the walls which are surrounded by other blocks (i.e. 1s). \\nAdd the ones not surrounded by any 1s (i.e. have 0 as adjacent element).\\n\\n\\n*Runtime: 52 ms, faster than 98.57% of C++ online submissions for Island Perimeter.\\nMemory Usage: 16.1 MB, less than 100.00% of C++ online submissions for Island Perimeter.*\\n\\n```\\nint islandPerimeter(vector<vector<int>>& grid) {\\n        \\n        int res = 0;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    res += (i == 0 || grid[i-1][j] == 0 ? 1 : 0);\\n                    res += (i == r-1 || grid[i+1][j] == 0 ? 1 : 0);\\n                    res += (j == 0 || grid[i][j-1] == 0 ? 1 : 0);\\n                    res += (j == c-1 || grid[i][j+1] == 0 ? 1 : 0);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 95124,
                "title": "easy-javascript-solution",
                "content": "```\\nvar islandPerimeter = function(grid) {\\n    const rows = grid.length;\\n    const cols = grid[0].length;\\n    \\n    var perimeter = 0;\\n    \\n    for (var row = 0; row < rows; row++) {\\n        for (var col = 0; col < cols; col++) {\\n            if (!grid[row][col]) continue;\\n            \\n            perimeter += 4;\\n            \\n            // abstract the number of adjacent island\\n            if (row > 0 && grid[row - 1][col]) perimeter--;\\n            if (col > 0 && grid[row][col - 1]) perimeter--;\\n            if (row < rows - 1 && grid[row + 1][col]) perimeter--;\\n            if (col < cols - 1 && grid[row][col + 1]) perimeter--;\\n        }\\n    }\\n    \\n    return perimeter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar islandPerimeter = function(grid) {\\n    const rows = grid.length;\\n    const cols = grid[0].length;\\n    \\n    var perimeter = 0;\\n    \\n    for (var row = 0; row < rows; row++) {\\n        for (var col = 0; col < cols; col++) {\\n            if (!grid[row][col]) continue;\\n            \\n            perimeter += 4;\\n            \\n            // abstract the number of adjacent island\\n            if (row > 0 && grid[row - 1][col]) perimeter--;\\n            if (col > 0 && grid[row][col - 1]) perimeter--;\\n            if (row < rows - 1 && grid[row + 1][col]) perimeter--;\\n            if (col < cols - 1 && grid[row][col + 1]) perimeter--;\\n        }\\n    }\\n    \\n    return perimeter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3448621,
                "title": "two-best-solutions-by-java-in-runtime-7ms-beats-71-32",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# code1\\nin Runtime 7ms Beats 71.32%\\n\\n```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n      int output = 0;\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == 1){\\n                    output += 4;\\n\\n                    if ( j-1 >= 0  && grid[i][j-1] == 1)  output -= 1;\\n\\n                    if ( j+1 != grid[i].length && grid[i][j+1] == 1)  output -=1;\\n\\n                    if (i-1 >= 0 && grid[i-1][j] == 1)   output -= 1;\\n                    \\n                    if (i+1 != grid.length && grid[i+1][j] == 1) output -=1;\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```\\n\\n# Code2\\nin Runtime 7ms Beats 71.32%\\n```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n      int output = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    output += 4;\\n\\n                    output -= (j - 1 >= 0 && grid[i][j - 1] == 1) ? 1  : 0;\\n                    output -= (j + 1 != grid[i].length && grid[i][j + 1] == 1)  ? 1 : 0;\\n                    output -= (i - 1 >= 0 && grid[i - 1][j] == 1 ) ? 1 : 0;\\n                    output -= (i + 1 != grid.length && grid[i + 1][j] == 1) ? 1 : 0;\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```\\n\\n![b0e5afaa-48ec-4dcc-bd96-e39aa7a524f8_1681948924.2890832.png](https://assets.leetcode.com/users/images/7f765552-569f-484d-bc15-affb66fe4bbd_1682288533.3115897.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n      int output = 0;\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == 1){\\n                    output += 4;\\n\\n                    if ( j-1 >= 0  && grid[i][j-1] == 1)  output -= 1;\\n\\n                    if ( j+1 != grid[i].length && grid[i][j+1] == 1)  output -=1;\\n\\n                    if (i-1 >= 0 && grid[i-1][j] == 1)   output -= 1;\\n                    \\n                    if (i+1 != grid.length && grid[i+1][j] == 1) output -=1;\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n      int output = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    output += 4;\\n\\n                    output -= (j - 1 >= 0 && grid[i][j - 1] == 1) ? 1  : 0;\\n                    output -= (j + 1 != grid[i].length && grid[i][j + 1] == 1)  ? 1 : 0;\\n                    output -= (i - 1 >= 0 && grid[i - 1][j] == 1 ) ? 1 : 0;\\n                    output -= (i + 1 != grid.length && grid[i + 1][j] == 1) ? 1 : 0;\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204204,
                "title": "python3-easy-to-understand",
                "content": "``` python\\nclass Solution:\\n    def islandPerimeter(self, grid):\\n        H, W = len(grid), len(grid[0])        \\n        area = 0\\n        connect = 0\\n        for r in range(H):\\n            for c in range(W):\\n                if grid[r][c] == 1:\\n                    area += 1\\n                    # check up and left\\n                    if r > 0 and grid[r-1][c] == 1: connect += 1\\n                    if c > 0 and grid[r][c-1] == 1: connect += 1\\n        return area * 4 - 2 * connect\\n```",
                "solutionTags": [],
                "code": "``` python\\nclass Solution:\\n    def islandPerimeter(self, grid):\\n        H, W = len(grid), len(grid[0])        \\n        area = 0\\n        connect = 0\\n        for r in range(H):\\n            for c in range(W):\\n                if grid[r][c] == 1:\\n                    area += 1\\n                    # check up and left\\n                    if r > 0 and grid[r-1][c] == 1: connect += 1\\n                    if c > 0 and grid[r][c-1] == 1: connect += 1\\n        return area * 4 - 2 * connect\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664910,
                "title": "python-easy-solution-fully-explained",
                "content": "![image](https://assets.leetcode.com/users/images/3c49e397-f36f-4cd7-8f8a-1fcd5593acf9_1641236051.5259821.jpeg)\\n\\n\\t# Time: O(mn)\\n\\tclass Solution:\\n\\t\\t\\tdef islandPerimeter(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t\\tisLands = 0\\n\\t\\t\\t\\tnghbrs = 0\\n\\t\\t\\t\\tgrd_len = len(grid)\\n\\t\\t\\t\\tgrd0_len = len(grid[0])\\n\\t\\t\\t\\tfor i in range(grd_len):\\n\\t\\t\\t\\t\\tfor j in range(grd0_len):\\n\\t\\t\\t\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\t\\t\\t\\tisLands += 1\\n\\t\\t\\t\\t\\t\\t\\tif i < grd_len-1 and grid[i+1][j] == 1:\\n\\t\\t\\t\\t\\t\\t\\t\\tnghbrs += 1  # Counting next Down Neighbour...\\n\\t\\t\\t\\t\\t\\t\\tif j < grd0_len-1 and grid[i][j+1] == 1:\\n\\t\\t\\t\\t\\t\\t\\t\\tnghbrs += 1  # Counting next Right Neighbour...\\n\\t\\t\\t\\treturn 4*isLands - 2*nghbrs\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/3c49e397-f36f-4cd7-8f8a-1fcd5593acf9_1641236051.5259821.jpeg)\\n\\n\\t# Time: O(mn)\\n\\tclass Solution:\\n\\t\\t\\tdef islandPerimeter(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t\\tisLands = 0\\n\\t\\t\\t\\tnghbrs = 0\\n\\t\\t\\t\\tgrd_len = len(grid)\\n\\t\\t\\t\\tgrd0_len = len(grid[0])\\n\\t\\t\\t\\tfor i in range(grd_len):\\n\\t\\t\\t\\t\\tfor j in range(grd0_len):\\n\\t\\t\\t\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\t\\t\\t\\tisLands += 1\\n\\t\\t\\t\\t\\t\\t\\tif i < grd_len-1 and grid[i+1][j] == 1:\\n\\t\\t\\t\\t\\t\\t\\t\\tnghbrs += 1  # Counting next Down Neighbour...\\n\\t\\t\\t\\t\\t\\t\\tif j < grd0_len-1 and grid[i][j+1] == 1:\\n\\t\\t\\t\\t\\t\\t\\t\\tnghbrs += 1  # Counting next Right Neighbour...\\n\\t\\t\\t\\treturn 4*isLands - 2*nghbrs\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "codeTag": "Java"
            },
            {
                "id": 1502637,
                "title": "c-easy-simple-and-concise-solution",
                "content": "**Idea:**\\nFor every land cell, we count how many cells around it are water or edges.\\n```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size(), m = grid[0].size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                \\n                if (!grid[i][j]) continue;\\n                \\n                if ((j > 0 && !grid[i][j-1]) || j == 0) res++;\\n                if ((i > 0 && !grid[i-1][j]) || i == 0) res++;\\n                if ((j < m-1 && !grid[i][j+1]) || j == m-1) res++;\\n                if ((i < n-1 && !grid[i+1][j]) || i == n-1) res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size(), m = grid[0].size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                \\n                if (!grid[i][j]) continue;\\n                \\n                if ((j > 0 && !grid[i][j-1]) || j == 0) res++;\\n                if ((i > 0 && !grid[i-1][j]) || i == 0) res++;\\n                if ((j < m-1 && !grid[i][j+1]) || j == m-1) res++;\\n                if ((i < n-1 && !grid[i+1][j]) || i == n-1) res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723914,
                "title": "c-brute-force-and-dfs-approaches-what-s-the-optimal-solution-for-this-problem",
                "content": "Brute force:\\n```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int ans = 0 , row = grid.size(), col = grid[0].size();    \\n        for(int i = 0 ; i < row ; i++)\\n        {\\n           for(int j = 0 ; j < col ; j++)\\n           {\\n               if( grid[i][j])\\n               {\\n                  ans+=4;\\n                  if(i < row - 1 && grid[i+1][j])ans--; \\n                  if(j < col -1 && grid[i][j+1])ans--; \\n                  if(j  && grid[i][j-1])ans--; \\n                  if(i  && grid[i-1][j])ans--; \\n               }\\n           } \\n        }\\n        return ans;\\n    }\\n};\\n```\\nDFS:\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>> & grid,int i, int j)\\n    {\\n        // if we are out of the grid, or we have already been at this cell, or the value is zero return,\\n        if( i < 0 || j < 0 || i > grid.size()-1 \\n       || j > grid[0].size()-1 || !grid[i][j] || grid[i][j] == 2) return 0 ; \\n       \\n        grid[i][j] = 2; // used to track if we already visited this cell \\n        int ans = 4; \\n        \\n        if(i < grid.size() - 1 && grid[i+1][j])ans--; // checks if top == 1 \\n        if(j < grid[0].size() -1 && grid[i][j+1])ans--;//checks if right == 1 \\n        \\n        if(j > 0 && grid[i][j-1])ans--; // checks if left == 1 \\n        if(i > 0 && grid[i-1][j])ans--; // checks if bottom == 1 \\n        \\n        // dfs the left, right ,top , and bottom\\n        return ans + (dfs(grid, i + 1 ,j) + dfs(grid,i-1,j) + dfs(grid,i,j-1) + dfs(grid,i,j+1)); \\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int ans = 0 , row = grid.size(), col = grid[0].size();    \\n        for(int i = 0 ; i < row ; i++)\\n        {\\n           for(int j = 0 ; j < col ; j++)\\n           {\\n               if( grid[i][j])\\n               {\\n                 return dfs(grid,i,j);  \\n               }\\n           } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int ans = 0 , row = grid.size(), col = grid[0].size();    \\n        for(int i = 0 ; i < row ; i++)\\n        {\\n           for(int j = 0 ; j < col ; j++)\\n           {\\n               if( grid[i][j])\\n               {\\n                  ans+=4;\\n                  if(i < row - 1 && grid[i+1][j])ans--; \\n                  if(j < col -1 && grid[i][j+1])ans--; \\n                  if(j  && grid[i][j-1])ans--; \\n                  if(i  && grid[i-1][j])ans--; \\n               }\\n           } \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>> & grid,int i, int j)\\n    {\\n        // if we are out of the grid, or we have already been at this cell, or the value is zero return,\\n        if( i < 0 || j < 0 || i > grid.size()-1 \\n       || j > grid[0].size()-1 || !grid[i][j] || grid[i][j] == 2) return 0 ; \\n       \\n        grid[i][j] = 2; // used to track if we already visited this cell \\n        int ans = 4; \\n        \\n        if(i < grid.size() - 1 && grid[i+1][j])ans--; // checks if top == 1 \\n        if(j < grid[0].size() -1 && grid[i][j+1])ans--;//checks if right == 1 \\n        \\n        if(j > 0 && grid[i][j-1])ans--; // checks if left == 1 \\n        if(i > 0 && grid[i-1][j])ans--; // checks if bottom == 1 \\n        \\n        // dfs the left, right ,top , and bottom\\n        return ans + (dfs(grid, i + 1 ,j) + dfs(grid,i-1,j) + dfs(grid,i,j-1) + dfs(grid,i,j+1)); \\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int ans = 0 , row = grid.size(), col = grid[0].size();    \\n        for(int i = 0 ; i < row ; i++)\\n        {\\n           for(int j = 0 ; j < col ; j++)\\n           {\\n               if( grid[i][j])\\n               {\\n                 return dfs(grid,i,j);  \\n               }\\n           } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502484,
                "title": "island-perimeter-c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, int i, int j, int r, int c, int &perimeter)\\n    {\\n        // Mark as visited\\n        grid[i][j] = 2;\\n        \\n        // Calculate perimeter in all the 4 directions of the current cell\\n        if(i == 0 || grid[i-1][j] == 0)\\n            perimeter++;\\n        \\n        if(i == r || grid[i+1][j] == 0)\\n            perimeter++;\\n        \\n        if(j == 0 || grid[i][j-1] == 0)\\n            perimeter++;\\n        \\n        if(j == c || grid[i][j+1] == 0)\\n            perimeter++;\\n        \\n        // Check all the 4 directions\\n        // If land is found then recursively call dfs function\\n        if(i > 0 && grid[i-1][j] == 1)\\n            dfs(grid,i-1,j,r,c,perimeter);\\n        \\n        if(i < r && grid[i+1][j] == 1)\\n            dfs(grid,i+1,j,r,c,perimeter);\\n        \\n        if(j > 0 && grid[i][j-1] == 1)\\n            dfs(grid,i,j-1,r,c,perimeter);\\n        \\n        if(j < c && grid[i][j+1] == 1)\\n            dfs(grid,i,j+1,r,c,perimeter);\\n    }\\n    \\n    int islandPerimeter(vector<vector<int>>& grid) \\n    {\\n        // r = total rows\\n        // c = total columns\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        \\n        // Create a variable to store perimeter\\n        int perimeter = 0;\\n        \\n        // Traverse the grid\\n        for(int i = 0; i < r; i++)\\n        {\\n            for(int j = 0; j < c; j++)\\n            {\\n                // If land is found (i.e. grid[i][j] == 1)\\n                if(grid[i][j] == 1)\\n                {\\n                    dfs(grid,i,j,r-1,c-1,perimeter);\\n\\t\\t\\t\\t\\tbreak;\\n                }\\n            }\\n        }\\n        \\n        // Return the result\\n        return perimeter;\\n    }\\n};\\n```\\n**If you like then do upvote\\uD83D\\uDE0A**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, int i, int j, int r, int c, int &perimeter)\\n    {\\n        // Mark as visited\\n        grid[i][j] = 2;\\n        \\n        // Calculate perimeter in all the 4 directions of the current cell\\n        if(i == 0 || grid[i-1][j] == 0)\\n            perimeter++;\\n        \\n        if(i == r || grid[i+1][j] == 0)\\n            perimeter++;\\n        \\n        if(j == 0 || grid[i][j-1] == 0)\\n            perimeter++;\\n        \\n        if(j == c || grid[i][j+1] == 0)\\n            perimeter++;\\n        \\n        // Check all the 4 directions\\n        // If land is found then recursively call dfs function\\n        if(i > 0 && grid[i-1][j] == 1)\\n            dfs(grid,i-1,j,r,c,perimeter);\\n        \\n        if(i < r && grid[i+1][j] == 1)\\n            dfs(grid,i+1,j,r,c,perimeter);\\n        \\n        if(j > 0 && grid[i][j-1] == 1)\\n            dfs(grid,i,j-1,r,c,perimeter);\\n        \\n        if(j < c && grid[i][j+1] == 1)\\n            dfs(grid,i,j+1,r,c,perimeter);\\n    }\\n    \\n    int islandPerimeter(vector<vector<int>>& grid) \\n    {\\n        // r = total rows\\n        // c = total columns\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        \\n        // Create a variable to store perimeter\\n        int perimeter = 0;\\n        \\n        // Traverse the grid\\n        for(int i = 0; i < r; i++)\\n        {\\n            for(int j = 0; j < c; j++)\\n            {\\n                // If land is found (i.e. grid[i][j] == 1)\\n                if(grid[i][j] == 1)\\n                {\\n                    dfs(grid,i,j,r-1,c-1,perimeter);\\n\\t\\t\\t\\t\\tbreak;\\n                }\\n            }\\n        }\\n        \\n        // Return the result\\n        return perimeter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502140,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        if(grid == null || grid.length == 0)    return 0;\\n        int perimeter = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1){\\n                    perimeter += 4;\\n                    if(i > 0 && grid[i-1][j] == 1){\\n                        perimeter -= 2;\\n                    }\\n                    if(j > 0 && grid[i][j-1] == 1){\\n                        perimeter -= 2;\\n                    }\\n                }\\n            }\\n        }\\n        return perimeter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        if(grid == null || grid.length == 0)    return 0;\\n        int perimeter = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1){\\n                    perimeter += 4;\\n                    if(i > 0 && grid[i-1][j] == 1){\\n                        perimeter -= 2;\\n                    }\\n                    if(j > 0 && grid[i][j-1] == 1){\\n                        perimeter -= 2;\\n                    }\\n                }\\n            }\\n        }\\n        return perimeter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404441,
                "title": "java-easy-approach-with-explanation-dfs-preorder",
                "content": "```\\nclass Solution \\n{\\n    private int peremeter= 0;//calculating the peremeter, by traversing in 4 direction in search of water and boundary \\n    public int islandPerimeter(int[][] grid) \\n    {\\n        for(int i= 0; i< grid.length; i++)\\n        {\\n          for(int j= 0; j< grid[0].length; j++)\\n          {\\n            if(grid[i][j] == 1)\\n            {\\n               getIslandPerimeter(grid, i, j);//recursively calculates the peremeter of 1 island, we just need one node of that component \\n               return peremeter;\\n            }\\n          }\\n        }\\n        return peremeter;\\n    }\\n    public void getIslandPerimeter(int [][]grid, int i, int j)\\n    {//Preorder, DFS (since we have to first mark as visit with -1, oherwise there will be a loop i.e; function calling each other)\\n      \\n      //BASE CASE \\n      if(i< 0 || j< 0 || i >= grid.length || j >= grid[0].length){\\n          peremeter+= 1;//when we hit a index out of bound means it is boundary(we are crossing a boundary) we add 1 to the peremeter \\n          return;\\n      }\\n      \\n      if(grid[i][j] == 0){//when we hit a zero means that there is a boundary between water and island \\n         peremeter+= 1;\\n         return;\\n      }\\n      \\n      if(grid[i][j] == -1)//already calculated the peremeter, do need to take tension \\n         return;\\n      \\n      //Only one island \\n      \\n      \\n      //ROOT\\n      grid[i][j]= -1;//marking the visited block of the component as -1, so that we dont traverse it more than once and it should not affect the peremeter \\n         \\n      \\n      //LEFT-RIGHT-TOP-BOTTOM\\n      getIslandPerimeter(grid, i-1, j);//Top \\n      getIslandPerimeter(grid, i, j+1);//Right\\n      getIslandPerimeter(grid, i, j-1);//Left\\n      getIslandPerimeter(grid, i+1, j);//Bottom \\n      \\n      \\n      //child is recursively bringing the peremeter from 4 direction \\n      return;//returning to the calling function \\n      }\\n}//OPlease do Upvote, it helps a lot.\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    private int peremeter= 0;//calculating the peremeter, by traversing in 4 direction in search of water and boundary \\n    public int islandPerimeter(int[][] grid) \\n    {\\n        for(int i= 0; i< grid.length; i++)\\n        {\\n          for(int j= 0; j< grid[0].length; j++)\\n          {\\n            if(grid[i][j] == 1)\\n            {\\n               getIslandPerimeter(grid, i, j);//recursively calculates the peremeter of 1 island, we just need one node of that component \\n               return peremeter;\\n            }\\n          }\\n        }\\n        return peremeter;\\n    }\\n    public void getIslandPerimeter(int [][]grid, int i, int j)\\n    {//Preorder, DFS (since we have to first mark as visit with -1, oherwise there will be a loop i.e; function calling each other)\\n      \\n      //BASE CASE \\n      if(i< 0 || j< 0 || i >= grid.length || j >= grid[0].length){\\n          peremeter+= 1;//when we hit a index out of bound means it is boundary(we are crossing a boundary) we add 1 to the peremeter \\n          return;\\n      }\\n      \\n      if(grid[i][j] == 0){//when we hit a zero means that there is a boundary between water and island \\n         peremeter+= 1;\\n         return;\\n      }\\n      \\n      if(grid[i][j] == -1)//already calculated the peremeter, do need to take tension \\n         return;\\n      \\n      //Only one island \\n      \\n      \\n      //ROOT\\n      grid[i][j]= -1;//marking the visited block of the component as -1, so that we dont traverse it more than once and it should not affect the peremeter \\n         \\n      \\n      //LEFT-RIGHT-TOP-BOTTOM\\n      getIslandPerimeter(grid, i-1, j);//Top \\n      getIslandPerimeter(grid, i, j+1);//Right\\n      getIslandPerimeter(grid, i, j-1);//Left\\n      getIslandPerimeter(grid, i+1, j);//Bottom \\n      \\n      \\n      //child is recursively bringing the peremeter from 4 direction \\n      return;//returning to the calling function \\n      }\\n}//OPlease do Upvote, it helps a lot.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95094,
                "title": "python-short-efficient-solution-with-explanation-o-mn-time-and-o-1-space",
                "content": "My solution from the contest. For each cell with land on it add the number of cells around it that have water. All cells that are not on the grid are considered to have water:\\n```\\ndef islandPerimeter(self, grid):\\n    def water_around(y, x):\\n        return ((x == 0              or grid[y][x-1] == 0) +\\n                (x == len(grid[0])-1 or grid[y][x+1] == 0) +\\n                (y == 0              or grid[y-1][x] == 0) +\\n                (y == len(grid)-1    or grid[y+1][x] == 0) )\\n    return sum(water_around(y, x) for y in xrange(len(grid)) for x in xrange(len(grid[0])) if grid[y][x])\\n```\\n\\nUPDATE: Changed calls to ```range``` to use ```xrange``` instead. See posts below for further discussion on the effects of this change.",
                "solutionTags": [],
                "code": "```\\ndef islandPerimeter(self, grid):\\n    def water_around(y, x):\\n        return ((x == 0              or grid[y][x-1] == 0) +\\n                (x == len(grid[0])-1 or grid[y][x+1] == 0) +\\n                (y == 0              or grid[y-1][x] == 0) +\\n                (y == len(grid)-1    or grid[y+1][x] == 0) )\\n    return sum(water_around(y, x) for y in xrange(len(grid)) for x in xrange(len(grid[0])) if grid[y][x])\\n```\n```range```\n```xrange```",
                "codeTag": "Python3"
            },
            {
                "id": 3046548,
                "title": "python-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought on how to solve this problem was to iterate through the grid and for each cell with a value of 1, check the surrounding cells to see if they also have a value of 1. If they do, that means they are part of the same island and I can subtract from the perimeter count.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is to iterate through the grid and for each cell with a value of 1, add 4 to the perimeter count. Then, check the surrounding cells to see if they also have a value of 1. If they do, that means they are part of the same island and I can subtract 2 from the perimeter count for each shared side.\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        perimeter = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    perimeter += 4\\n                    if i > 0 and grid[i-1][j] == 1:\\n                        perimeter -= 2\\n                    if j > 0 and grid[i][j-1] == 1:\\n                        perimeter -= 2\\n        return perimeter\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        perimeter = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    perimeter += 4\\n                    if i > 0 and grid[i-1][j] == 1:\\n                        perimeter -= 2\\n                    if j > 0 and grid[i][j-1] == 1:\\n                        perimeter -= 2\\n        return perimeter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701521,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                if grid[i][j] == 1:\\n                    count = self.countIsland(grid, i, j, 0)\\n                    return count\\n    \\n    def countIsland(self, grid: List[List[int]], i: int, j: int, count: int) -> int:\\n        if i < 0 or i > len(grid)-1 or j < 0 or j > len(grid[i])-1:\\n            return 1\\n        elif grid[i][j] == 0:\\n            return 1\\n        elif grid[i][j] == -1:\\n            return 0\\n        else:\\n            grid[i][j] = -1\\n            return self.countIsland(grid, i+1, j, 1) + self.countIsland(grid, i-1, j, 1) + self.countIsland(grid, i, j+1, 1) + self.countIsland(grid, i, j-1, 1)\\n```\\n\\nO(n^2) where n is the number of rows/cols. The main thing you have to understand here is that we\\'re not counting the number of 1\\'s themselves, but how many 0\\'s surround a 1. You have to consider a number of conditions:\\n\\n1) We have reached the boundary of the square\\n2) We have hit water\\n3) We have to make sure we don\\'t revisit land already visited (set to some other value than 0 or 1)\\n\\nThe perimeter twist to the classic island DFS can take some time to understand.",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                if grid[i][j] == 1:\\n                    count = self.countIsland(grid, i, j, 0)\\n                    return count\\n    \\n    def countIsland(self, grid: List[List[int]], i: int, j: int, count: int) -> int:\\n        if i < 0 or i > len(grid)-1 or j < 0 or j > len(grid[i])-1:\\n            return 1\\n        elif grid[i][j] == 0:\\n            return 1\\n        elif grid[i][j] == -1:\\n            return 0\\n        else:\\n            grid[i][j] = -1\\n            return self.countIsland(grid, i+1, j, 1) + self.countIsland(grid, i-1, j, 1) + self.countIsland(grid, i, j+1, 1) + self.countIsland(grid, i, j-1, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285887,
                "title": "c-beats-100-recursion-dfs-easy",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>& grid, int i, int j){\\n        if(i>=grid.size() || j>=grid[0].size() || i<0 || j<0 || grid[i][j]==0) return 1;\\n        if(grid[i][j]==-1) return 0;\\n        grid[i][j]=-1;\\n        \\n        return helper(grid, i+1, j) + helper(grid, i-1, j)+ helper(grid, i, j+1) + helper(grid, i, j-1);\\n     }\\n    \\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int ct=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    ct=helper(grid, i, j);\\n                }\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>& grid, int i, int j){\\n        if(i>=grid.size() || j>=grid[0].size() || i<0 || j<0 || grid[i][j]==0) return 1;\\n        if(grid[i][j]==-1) return 0;\\n        grid[i][j]=-1;\\n        \\n        return helper(grid, i+1, j) + helper(grid, i-1, j)+ helper(grid, i, j+1) + helper(grid, i, j-1);\\n     }\\n    \\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int ct=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    ct=helper(grid, i, j);\\n                }\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485601,
                "title": "javascript-whiteboard",
                "content": "![image](https://assets.leetcode.com/users/images/422c7a1d-d8f5-4637-9682-b8def2e1c90b_1632590271.0713317.png)\\n```\\nvar islandPerimeter = function(grid) {\\n\\n    let height = grid.length\\n    let width = grid[0].length;\\n\\n    let count = 0\\n\\t\\n    for (let row = 0; row < height; row++) {\\n        for (let col = 0; col < width; col++) {\\n            if (grid[row][col] == 1) {\\n                  count += 4\\n\\t\\t\\t\\t\\n                  if (row > 0 && grid[row-1][col] == 1) count--\\n                  if (row < height-1 && grid[row+1][col] == 1) count--\\n                  if (grid[row][col-1] == 1) count--\\n                  if (grid[row][col+1] == 1) count--\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar islandPerimeter = function(grid) {\\n\\n    let height = grid.length\\n    let width = grid[0].length;\\n\\n    let count = 0\\n\\t\\n    for (let row = 0; row < height; row++) {\\n        for (let col = 0; col < width; col++) {\\n            if (grid[row][col] == 1) {\\n                  count += 4\\n\\t\\t\\t\\t\\n                  if (row > 0 && grid[row-1][col] == 1) count--\\n                  if (row < height-1 && grid[row+1][col] == 1) count--\\n                  if (grid[row][col-1] == 1) count--\\n                  if (grid[row][col+1] == 1) count--\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1502174,
                "title": "python-one-liner-with-explanation",
                "content": "Idea is simple, for each 1 add `4` to the perimeter (`P`). Also, check up and left of the cell to see if there is any  `1`. For each one in those two directions, we subtract `2` as two connected cells lose `2` for each connected side. It\\'s enough for us to check only up and left directions\\n\\nOne liner, **may not be suitable for interviews**. Using [product](https://docs.python.org/3/library/itertools.html#itertools.product) function and implicit type casting from `bool` to `int`\\n```\\nclass Solution:\\n    def islandPerimeter(self, I: List[List[int]]) -> int:\\n        return sum(2 * I[i][j] * (2 - (i > 0 and I[i - 1][j]) - (j > 0 and I[i][j - 1])) for i,j in product(range(len(I)), range(len(I[0]))))\\n```\\n\\nNormal version:\\n```\\nclass Solution:\\n    def islandPerimeter(self, I: List[List[int]]) -> int:\\n        m, n = len(I), len(I[0])\\n        P = 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if I[i][j]:\\n                    P += 4\\n                    if i > 0 and I[i - 1][j]:\\n                        P -= 2\\n                    if j > 0 and I[i][j - 1]:\\n                        P -= 2\\n        return P\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, I: List[List[int]]) -> int:\\n        return sum(2 * I[i][j] * (2 - (i > 0 and I[i - 1][j]) - (j > 0 and I[i][j - 1])) for i,j in product(range(len(I)), range(len(I[0]))))\\n```\n```\\nclass Solution:\\n    def islandPerimeter(self, I: List[List[int]]) -> int:\\n        m, n = len(I), len(I[0])\\n        P = 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if I[i][j]:\\n                    P += 4\\n                    if i > 0 and I[i - 1][j]:\\n                        P -= 2\\n                    if j > 0 and I[i][j - 1]:\\n                        P -= 2\\n        return P\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95122,
                "title": "clean-java-solution-o-mn",
                "content": "\\tIdea: Every side of a land-cell exposed to water-cell will be part of perimeter.\\n\\n    public int islandPerimeter(int[][] grid) {\\n        int[][] d = new int[][] {{0,-1}, {-1,0}, {0,1}, {1,0}};\\n        \\n        int perimeter = 0;\\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) {\\n                if(grid[i][j] == 0)\\n                    continue;\\n                \\n                for(int k=0; k<d.length; k++) {\\n                    int x=i+d[k][0], y=j+d[k][1];\\n                    if(x<0 || x>=grid.length || y<0 || y>=grid[0].length || grid[x][y] == 0)\\n                        perimeter++;\\n                }\\n            }\\n        }\\n        \\n        return perimeter;\\n    }\\n\\t\\n\\tTime complexity:  O(mn)\\n\\tSpace complexity: O(1)",
                "solutionTags": [],
                "code": "\\tIdea: Every side of a land-cell exposed to water-cell will be part of perimeter.\\n\\n    public int islandPerimeter(int[][] grid) {\\n        int[][] d = new int[][] {{0,-1}, {-1,0}, {0,1}, {1,0}};\\n        \\n        int perimeter = 0;\\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) {\\n                if(grid[i][j] == 0)\\n                    continue;\\n                \\n                for(int k=0; k<d.length; k++) {\\n                    int x=i+d[k][0], y=j+d[k][1];\\n                    if(x<0 || x>=grid.length || y<0 || y>=grid[0].length || grid[x][y] == 0)\\n                        perimeter++;\\n                }\\n            }\\n        }\\n        \\n        return perimeter;\\n    }\\n\\t\\n\\tTime complexity:  O(mn)\\n\\tSpace complexity: O(1)",
                "codeTag": "Unknown"
            },
            {
                "id": 308084,
                "title": "python-o-n-m-solution-112ms-upto-100-faster",
                "content": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        for row in range(len(grid)):\\n            for column in range(len(grid[0])):\\n                    if grid[row][column]:\\n                        res+=4\\n                        if row and grid[row-1][column]:\\n                            res-=2                        \\n                        if column and grid[row][column-1]:\\n                            res-=2\\n        return res\\n```\\nAdd 4 for all 1s. Subtract 2 for all adjacent 1-to-1 cell pairs (horizontal and vertical).",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        for row in range(len(grid)):\\n            for column in range(len(grid[0])):\\n                    if grid[row][column]:\\n                        res+=4\\n                        if row and grid[row-1][column]:\\n                            res-=2                        \\n                        if column and grid[row][column-1]:\\n                            res-=2\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 144321,
                "title": "python-counting-solution",
                "content": "```\\nclass Solution(object):\\n    def islandPerimeter(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n        num = 0\\n\\n        for r in xrange(m):\\n            for c in xrange(n):\\n                if grid[r][c] == 1:\\n                    if r == 0 or grid[r-1][c] == 0:\\n                        num += 1\\n                    if r == m-1 or grid[r+1][c] == 0:\\n                        num += 1\\n                    if c == 0 or grid[r][c-1] == 0:\\n                        num += 1\\n                    if c == n-1 or grid[r][c+1] == 0:\\n                        num += 1\\n        return num\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def islandPerimeter(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n        num = 0\\n\\n        for r in xrange(m):\\n            for c in xrange(n):\\n                if grid[r][c] == 1:\\n                    if r == 0 or grid[r-1][c] == 0:\\n                        num += 1\\n                    if r == m-1 or grid[r+1][c] == 0:\\n                        num += 1\\n                    if c == 0 or grid[r][c-1] == 0:\\n                        num += 1\\n                    if c == n-1 or grid[r][c+1] == 0:\\n                        num += 1\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801020,
                "title": "very-easy-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The logic behind this is, if any land was above it there will be 2 edges common, similarly for left side.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Traverse over every unit and check if it is land, perimeter +=4\\n- And if there is a land above it, perimeter -= 2, same for left side land.\\n- Return the ans.\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int row = grid.size(), col = grid[0].size();\\n        int ans=0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                if(grid[i][j]==1){\\n                    // check for i-1,j and i,j-1\\n                    ans+=4;\\n                    if(i>0 && grid[i-1][j]==1) ans-=2;\\n                    if(j>0 && grid[i][j-1]==1) ans-=2;\\n                }\\n            }\\n       }\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int row = grid.size(), col = grid[0].size();\\n        int ans=0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                if(grid[i][j]==1){\\n                    // check for i-1,j and i,j-1\\n                    ans+=4;\\n                    if(i>0 && grid[i-1][j]==1) ans-=2;\\n                    if(j>0 && grid[i][j-1]==1) ans-=2;\\n                }\\n            }\\n       }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741899,
                "title": "java-faster-than-100-easy",
                "content": "```\\n//PLEASE UPVOTE IF IT HELPS YOU\\n\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        if(grid==null || grid.length==0 || grid[0].length==0)\\n            return 0;\\n        \\n        int result=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j] == 1){\\n                    result+=4;\\n                    \\n                    if(i>0 && grid[i-1][j]==1)   //check for value above grid[i][j]\\n                        result-=2;\\n                    \\n                    if(j>0 && grid[i][j-1]==1)   ////check for value to the left of grid[i][j]\\n                        result-=2;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//PLEASE UPVOTE IF IT HELPS YOU\\n\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        if(grid==null || grid.length==0 || grid[0].length==0)\\n            return 0;\\n        \\n        int result=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j] == 1){\\n                    result+=4;\\n                    \\n                    if(i>0 && grid[i-1][j]==1)   //check for value above grid[i][j]\\n                        result-=2;\\n                    \\n                    if(j>0 && grid[i][j-1]==1)   ////check for value to the left of grid[i][j]\\n                        result-=2;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403416,
                "title": "c-simple-iterative-each-line-clearly-explained-modified-question",
                "content": "# **How to solve the given question iteratively without applying any DFS or graphs ?**\\n`We can simply iterate the matrix, and for a cell check its 4 adjacent cells, and suppose if u have 2 adjacent cells with value 1, then your current cell will contribute **4-1 = 2** to the actual perimeter, bcz. 2 of its sides are covered by adjacent cells.`\\n\\n# **I am modifying the question**\\n**Explanation is large ...... but the code is short**\\n*Like the post if it helped you*\\n\\n**Here, in this question, you are given that you have single island, what if there would have been multiple island and you need to find the island with maximum perimeter**\\n* In this case u need to apply DFS and iterate on every island and find the maximum perimeter\\n* I will be solving this question, rather than the given question \\n* The below solution will also give correct result for the given question as well \\n\\n***Each line of the code is explained, feel free to post your doubt in comment section***\\n\\n* If we consider the **matrix as a graph**, then we need to find **max perimeter among all the components of the graph**\\n* **What will be the node and edge** ? \\n\\t*The cells with value 1 will act as node, and the cell adjacent to it having value as 1 will be its adjacent node*\\n* So we will simply apply DFS on all the components \\n* **How to mark visited** ?... Create another matrix to mark visited and unvisited as 1, 0\\n* **How to get the perimeter of component** ? \\n  -> You can pass a reference variable and increase the perimeter according to conditions\\n  -> or u can make the return type of DFS function as int and return the perimeter\\n  \\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void DFS( vector<vector<int>>& G, vector<vector<int>> &visited, int r, int c, int& perimeter ){\\n        int n=G.size(), m=G[0].size();\\n        \\n        // check if the cell lies outside the boundary or already visited\\n        if( r<0 || c<0 || r>=n || c>=m || visited[r][c] == 1 ) return; \\n        \\n        visited[r][c]=1; // mark the node as visited\\n        \\n        // these array will help to get to 4 adjacent cells easily, making the code shorter\\n        int X[]={ 0,0,-1,1 };\\n        int Y[]={ 1,-1,0,0 };\\n        \\n        int noPerimeter = 0; // it stores the number of sides which wont contribute to perimeter\\n        for( int i=0; i<4; i++ ){\\n            int x = r+X[i], y = c+Y[i];\\n            \\n            if( x<0 || y<0 || x>=n || y>=m) continue; // cell outside the boundary\\n            \\n            if( G[x][y] == 1 ) // i.e. adjacent node is hiding the current side \\n                noPerimeter++;\\n        }\\n        perimeter = perimeter + ( 4 - noPerimeter ); // adding the perimeter contributed by current cell to the final perimeter of island\\n        \\n        for( int i=0; i<4; i++ ){ // call DFS for all the adjacent cella\\n            int x = r+X[i], y = c+Y[i]; // row and column number of adjacent cell \\n            DFS( G, visited, x, y, perimeter ); // call DFS for adjacent cell\\n        }\\n        \\n    }\\n    \\n    int islandPerimeter(vector<vector<int>>& G) {\\n        \\n        int r = G.size(); // number of rows in grid\\n        int c = G[0].size(); // number of columns in grid\\n        \\n        vector<int> temp( c , 1 );\\n        vector<vector<int>> visited(  r, temp ); // taking the visited array for DFS\\n        \\n        for( int i=0; i<r; i++ ){\\n            for( int j=0; j<c; j++ ){\\n                if( G[i][j]==1 ) visited[i][j]=0; // marking the island cells as not visited and rest of the cells as visited\\n            }\\n        }\\n        \\n        int maxPerimeter = 0; // final answer to return\\n        \\n        // Applying DFS\\n        // since the graph will be disconnected, we need to check each cell of matrix \\n        for( int i=0; i<r; i++ ){\\n            for( int j=0; j<c; j++ ){\\n                if( visited[i][j] == 0 ){ // found a new island\\n                    int perimeter = 0; // will pass this variable to DFS function as reference and get the perimeter \\n                    DFS(G,visited,i,j,perimeter); // call DFS\\n                    maxPerimeter = max( maxPerimeter,perimeter ); // update the Max perimeter \\n                }\\n            }\\n        }\\n        \\n        return maxPerimeter;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void DFS( vector<vector<int>>& G, vector<vector<int>> &visited, int r, int c, int& perimeter ){\\n        int n=G.size(), m=G[0].size();\\n        \\n        // check if the cell lies outside the boundary or already visited\\n        if( r<0 || c<0 || r>=n || c>=m || visited[r][c] == 1 ) return; \\n        \\n        visited[r][c]=1; // mark the node as visited\\n        \\n        // these array will help to get to 4 adjacent cells easily, making the code shorter\\n        int X[]={ 0,0,-1,1 };\\n        int Y[]={ 1,-1,0,0 };\\n        \\n        int noPerimeter = 0; // it stores the number of sides which wont contribute to perimeter\\n        for( int i=0; i<4; i++ ){\\n            int x = r+X[i], y = c+Y[i];\\n            \\n            if( x<0 || y<0 || x>=n || y>=m) continue; // cell outside the boundary\\n            \\n            if( G[x][y] == 1 ) // i.e. adjacent node is hiding the current side \\n                noPerimeter++;\\n        }\\n        perimeter = perimeter + ( 4 - noPerimeter ); // adding the perimeter contributed by current cell to the final perimeter of island\\n        \\n        for( int i=0; i<4; i++ ){ // call DFS for all the adjacent cella\\n            int x = r+X[i], y = c+Y[i]; // row and column number of adjacent cell \\n            DFS( G, visited, x, y, perimeter ); // call DFS for adjacent cell\\n        }\\n        \\n    }\\n    \\n    int islandPerimeter(vector<vector<int>>& G) {\\n        \\n        int r = G.size(); // number of rows in grid\\n        int c = G[0].size(); // number of columns in grid\\n        \\n        vector<int> temp( c , 1 );\\n        vector<vector<int>> visited(  r, temp ); // taking the visited array for DFS\\n        \\n        for( int i=0; i<r; i++ ){\\n            for( int j=0; j<c; j++ ){\\n                if( G[i][j]==1 ) visited[i][j]=0; // marking the island cells as not visited and rest of the cells as visited\\n            }\\n        }\\n        \\n        int maxPerimeter = 0; // final answer to return\\n        \\n        // Applying DFS\\n        // since the graph will be disconnected, we need to check each cell of matrix \\n        for( int i=0; i<r; i++ ){\\n            for( int j=0; j<c; j++ ){\\n                if( visited[i][j] == 0 ){ // found a new island\\n                    int perimeter = 0; // will pass this variable to DFS function as reference and get the perimeter \\n                    DFS(G,visited,i,j,perimeter); // call DFS\\n                    maxPerimeter = max( maxPerimeter,perimeter ); // update the Max perimeter \\n                }\\n            }\\n        }\\n        \\n        return maxPerimeter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026976,
                "title": "java-simple-solution-o-mxn-99",
                "content": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int p = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 1){\\n                    \\n                    //assume it is an unconnected cell with perimeter = 4\\n                    p += 4;\\n                    \\n                    //check connection to the left\\n                    if(j > 0 && grid[i][j - 1] == 1) p += -1;\\n                    \\n                    //check connection up\\n                    if(i > 0 && grid[i-1][j] == 1) p += -1;\\n                    \\n                    //check connection to the right\\n                    if(j < n - 1 && grid[i][j + 1] == 1) p += -1;\\n                    \\n                    //check bottom connection\\n                    if(i < m - 1 && grid[i+1][j] == 1) p += -1;\\n                }\\n            }\\n        }\\n        \\n        return p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int p = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 1){\\n                    \\n                    //assume it is an unconnected cell with perimeter = 4\\n                    p += 4;\\n                    \\n                    //check connection to the left\\n                    if(j > 0 && grid[i][j - 1] == 1) p += -1;\\n                    \\n                    //check connection up\\n                    if(i > 0 && grid[i-1][j] == 1) p += -1;\\n                    \\n                    //check connection to the right\\n                    if(j < n - 1 && grid[i][j + 1] == 1) p += -1;\\n                    \\n                    //check bottom connection\\n                    if(i < m - 1 && grid[i+1][j] == 1) p += -1;\\n                }\\n            }\\n        }\\n        \\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724267,
                "title": "python-3-iterative-solution-easy-to-read",
                "content": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        row , col , count = len(grid) , len(grid[0]) , 0\\n        for x in range(row):\\n            for y in range(col):\\n                if grid[x][y] == 1:\\n                    count += 4\\n                    if x > 0 and grid[x - 1][y] == 1:\\n                        count -= 2\\n                    if y > 0 and grid[x][y - 1] == 1:\\n                        count -= 2\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        row , col , count = len(grid) , len(grid[0]) , 0\\n        for x in range(row):\\n            for y in range(col):\\n                if grid[x][y] == 1:\\n                    count += 4\\n                    if x > 0 and grid[x - 1][y] == 1:\\n                        count -= 2\\n                    if y > 0 and grid[x][y - 1] == 1:\\n                        count -= 2\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94991,
                "title": "o-mn-javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar islandPerimeter = function(grid) {\\n    var edges = 0;\\n    grid.forEach((row, r) => {\\n        row.forEach((col, c) => {\\n            var left = grid[r][c-1] || 0;\\n            var right = grid[r][c+1] || 0;\\n            var top = (grid[r-1] || [])[c] || 0;\\n            var bottom = (grid[r+1] || [])[c] || 0;\\n            if (col === 1) {\\n                edges += (4 - top - bottom - left - right)\\n            }\\n        })\\n    });\\n    return edges;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar islandPerimeter = function(grid) {\\n    var edges = 0;\\n    grid.forEach((row, r) => {\\n        row.forEach((col, c) => {\\n            var left = grid[r][c-1] || 0;\\n            var right = grid[r][c+1] || 0;\\n            var top = (grid[r-1] || [])[c] || 0;\\n            var bottom = (grid[r+1] || [])[c] || 0;\\n            if (col === 1) {\\n                edges += (4 - top - bottom - left - right)\\n            }\\n        })\\n    });\\n    return edges;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3666665,
                "title": "easy-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount number of 1\\'s and set perimeter to 4*number. Check for every 1 if it has any 1 as neighbour, if yes reduce count by 1. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore every pair of 1\\'s in a vector of pairs, traverse through the vector and check 4 directions and decrease if 1 is found\\n\\n# Complexity\\n- Time complexity:O(N2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n       int count = 0; \\n       vector<pair<int,int>> v; \\n       for(int i=0; i<grid.size(); i++){\\n           for(int j=0; j<grid[0].size(); j++){\\n               if(grid[i][j] == 1) v.push_back({i,j}); \\n           }\\n       } \\n\\n       count = 4*(v.size());\\n\\n       for(int i=0; i<v.size(); i++){\\n           int x = v[i].first, y = v[i].second; \\n           //check upwards\\n           if(x!=0 && grid[x-1][y] == 1) count--; \\n           //check downwards\\n           if(x!= grid.size()-1 && grid[x+1][y] == 1) count--; \\n           //check left\\n           if(y!=0 && grid[x][y-1] == 1) count--; \\n           //check right\\n           if(y!=grid[0].size()-1 && grid[x][y+1] == 1) count--; \\n       } \\n\\n\\n       return count; \\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n       int count = 0; \\n       vector<pair<int,int>> v; \\n       for(int i=0; i<grid.size(); i++){\\n           for(int j=0; j<grid[0].size(); j++){\\n               if(grid[i][j] == 1) v.push_back({i,j}); \\n           }\\n       } \\n\\n       count = 4*(v.size());\\n\\n       for(int i=0; i<v.size(); i++){\\n           int x = v[i].first, y = v[i].second; \\n           //check upwards\\n           if(x!=0 && grid[x-1][y] == 1) count--; \\n           //check downwards\\n           if(x!= grid.size()-1 && grid[x+1][y] == 1) count--; \\n           //check left\\n           if(y!=0 && grid[x][y-1] == 1) count--; \\n           //check right\\n           if(y!=grid[0].size()-1 && grid[x][y+1] == 1) count--; \\n       } \\n\\n\\n       return count; \\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613365,
                "title": "fastest-and-unique-using-of-d-f-s",
                "content": "# Intuition\\nThe intuition behind the given code is to use a depth-first search (DFS) algorithm to explore the island cells in the grid and calculate the perimeter. \\n\\nThe DFS starts from each unvisited land cell and recursively visits its neighboring cells to explore the entire island. \\n\\nDuring the DFS traversal, the code keeps track of visited cells to avoid revisiting them and counts the number of neighboring water cells for each land cell. \\n\\nThe perimeter of an island can be calculated by subtracting the number of neighboring land cells from 4 (since each land cell contributes 4 sides to the perimeter) and adding this count to the total perimeter count.\\n\\nBy iterating over all the cells in the grid and performing DFS on unvisited land cells, the code effectively calculates the perimeter of the entire island.\\n\\nThe intuition behind DFS is to explore as far as possible along each branch before backtracking. In this case, it helps to explore the island cells in a systematic manner, counting the neighboring water cells and calculating the perimeter as we traverse the island.\\n\\nOverall, the code utilizes DFS to solve the problem by exploring the island cells and calculating the perimeter based on the neighboring water cells.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach used in the given code is a depth-first search (DFS) algorithm to explore the island cells in the grid and calculate the perimeter.\\n\\nHere\\'s a step-by-step breakdown of the approach:\\n\\n1. The `islandPerimeter` function iterates over each cell in the grid and checks if the cell is land (1) and not visited. If these conditions are met, it calls the `dfs` function to explore the island starting from that cell.\\n\\n2. The `dfs` function takes the current row and column, the visited array (`vis`), the grid, and a reference to the `cnt` variable (perimeter count) as parameters.\\n\\n3. Inside the `dfs` function, it marks the current cell as visited by setting `vis[row][col]` to 1.\\n\\n4. It initializes a variable `a` to count the number of neighboring cells that are land (1). This variable is initially set to 0.\\n\\n5. Two arrays, `drow` and `dcol`, represent the four possible directions to move: down, up, right, and left.\\n\\n6. The `for` loop iterates over the four directions. For each direction, it calculates the new row and column (`nrow` and `ncol`) by adding the corresponding offset from `drow` and `dcol` to the current row and column.\\n\\n7. It checks if the new row and column are within the grid boundaries and if the cell at that position is land (1) and not visited (`vis[nrow][ncol] == 0`). If these conditions are met, it increments the `a` counter and makes a recursive call to `dfs` with the new row and column.\\n\\n8. After the `for` loop, it updates the `cnt` variable by subtracting the number of land neighbors (`a`) from 4 and adds it to the current count. This accounts for the perimeter of the current cell.\\n\\n9. The `dfs` function ends, and the `islandPerimeter` function continues iterating over the remaining cells in the grid, calling `dfs` only on unvisited land cells.\\n\\n10. Finally, the `cnt` variable, which holds the total perimeter count, is returned as the result.\\n\\nIn summary, the code uses a DFS approach to traverse the island cells, keeping track of visited cells and counting the neighboring water cells to calculate the perimeter.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n- The recursive calls in the dfs function consume additional space on the call stack. The maximum depth of the recursive calls depends on the size of the island in the grid. In the worst case, if the entire grid is filled with a single island, the maximum depth of recursion would be equal to the total number of cells in the grid. Therefore, the space complexity of the recursive calls can be considered O(rows x columns).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>& grid,int& cnt){\\n    vis[row][col]=1;\\n    int a=0;\\n    int drow[4]={1,-1,0,0};\\n    int dcol[4]={0,0,1,-1};\\n    for(int i=0;i<4;i++){\\n          int nrow=row+drow[i];\\n          int ncol=col+dcol[i];\\n          if(nrow>=0 && ncol>=0 && nrow<grid.size() && ncol<grid[0].size() && grid[nrow][ncol]==1){\\n              a++;\\n          }\\n          if(nrow>=0 && ncol>=0 && nrow<grid.size() && ncol<grid[0].size() && grid[nrow][ncol]==1&& vis[nrow][ncol]==0 ){\\n          \\n              dfs(nrow,ncol,vis,grid,cnt);\\n          }\\n    }\\n    cnt+=4-a;\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        vector<vector<int>>vis(grid.size(),vector<int>(grid[0].size(),0));\\n        int cnt=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(!vis[i][j] && grid[i][j]==1)\\n                       dfs(i,j,vis,grid,cnt);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/098a89c3-86b0-404f-bd44-cf90f6e14f67_1686222491.951552.png)\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>& grid,int& cnt){\\n    vis[row][col]=1;\\n    int a=0;\\n    int drow[4]={1,-1,0,0};\\n    int dcol[4]={0,0,1,-1};\\n    for(int i=0;i<4;i++){\\n          int nrow=row+drow[i];\\n          int ncol=col+dcol[i];\\n          if(nrow>=0 && ncol>=0 && nrow<grid.size() && ncol<grid[0].size() && grid[nrow][ncol]==1){\\n              a++;\\n          }\\n          if(nrow>=0 && ncol>=0 && nrow<grid.size() && ncol<grid[0].size() && grid[nrow][ncol]==1&& vis[nrow][ncol]==0 ){\\n          \\n              dfs(nrow,ncol,vis,grid,cnt);\\n          }\\n    }\\n    cnt+=4-a;\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        vector<vector<int>>vis(grid.size(),vector<int>(grid[0].size(),0));\\n        int cnt=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(!vis[i][j] && grid[i][j]==1)\\n                       dfs(i,j,vis,grid,cnt);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963276,
                "title": "5ms-solution-fastest-unique-approach-depth-first-search-o-n-m-time-java",
                "content": "```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int islandPerimeter(int[][] grid) \\n    {\\n        if(grid==null || grid.length==0 || grid[0].length==0)// base case\\n          return 0;\\n        \\n        int count = 0;\\n        for (int i = 0; i < grid.length; i ++)\\n        {\\n            for (int j = 0; j < grid[0].length; j ++) \\n            {\\n                if (grid[i][j] == 1) \\n                {\\n                    count += 4;\\n                    if (j - 1 >= 0 && grid[i][j-1] == 1)\\n                        count -= 2;\\n                    if (i - 1 >= 0 && grid[i-1][j] == 1)\\n                        count -= 2;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\n```\\nclass Solution \\n{\\n    public int islandPerimeter(int[][] grid) \\n    {\\n        if(grid==null || grid.length==0 || grid[0].length==0)// base case\\n          return 0;\\n        \\n        int count = 0;\\n        for (int i = 0; i < grid.length; i ++)\\n        {\\n            for (int j = 0; j < grid[0].length; j ++) \\n            {\\n                if (grid[i][j] == 1) \\n                {\\n                    count += 4;\\n                    if (j - 1 >= 0 && grid[i][j-1] == 1)\\n                        count -= 2;\\n                    if (i - 1 >= 0 && grid[i-1][j] == 1)\\n                        count -= 2;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502754,
                "title": "easy-approach-brute-to-optimal-with-explanation-c-brute-dfs",
                "content": "**Easy question is always easy if you take is easy.**\\n\\nWe can solve it using brute force and dfs both . Like striver vhaiya says \"Pahle brute force dedo fir optimal do\".\\n***BRUTE FORCE***\\nFirst take the row and col thn traverse through that .\\n you have to check it is 1 or 0 . if 1 then take that it has all 4 sides (ans =4) then check for its 4 directions just if up do (i-1), if down do (i+1) ,same with left right using j . if any of the side have 1 thn decrese ans by 1. \\n\\n```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    ans+=4;\\n                    if(i-1>=0 && grid[i-1][j]==1)// check for the upward\\n                    {\\n                        ans--;\\n                    }\\n                    if(i+1<row && grid[i+1][j]==1)//check for the downward\\n                    {\\n                        ans--;\\n                    }\\n                    if(j-1>=0 && grid[i][j-1]==1)//check for the left\\n                    {\\n                        ans--;\\n                    }\\n                    if(j+1<col && grid[i][j+1]==1)// check for the right \\n                    {\\n                        ans--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n****optimal Approach ****\\n\\njust a small change while you r checking sides do that in a diff fun then call that fun if all four sights.\\n\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>> & grid,int i, int j)\\n    {\\n        // if we are out of the grid, or we have already been at this cell, or the value is zero return,\\n        if( i < 0 || j < 0 || i > grid.size()-1 \\n       || j > grid[0].size()-1 || !grid[i][j] || grid[i][j] == -1) return 0 ; \\n       \\n        grid[i][j] = -1; \\n        int ans = 4; \\n        \\n        if(i < grid.size() - 1 && grid[i+1][j]) // check for the upward\\n            ans--; \\n        if(j < grid[0].size() -1 && grid[i][j+1])// check for the rightward\\n            ans--; \\n        \\n        if(j > 0 && grid[i][j-1])// check for the leftward\\n            ans--; \\n        if(i > 0 && grid[i-1][j])// check for the downward\\n            ans--;\\n        \\n        // call there dfs up,down ,left ,right.\\n        return ans + (dfs(grid, i + 1 ,j) + dfs(grid,i-1,j) + dfs(grid,i,j-1) + dfs(grid,i,j+1)); \\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int ans = 0 , row = grid.size(), col = grid[0].size();    \\n        for(int i = 0 ; i < row ; i++)\\n        {\\n           for(int j = 0 ; j < col ; j++)\\n           {\\n               if( grid[i][j])\\n               {\\n                 return dfs(grid,i,j);  \\n               }\\n           } \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nI love to choose simple way for me I will do only brute if I had to do this type of question in contest  where there will be no constraints.\\n\\nwhat you will do say in comments and if there can be any better approach please do say .\\n** **If you get this helpful please do upvote it truely  motivates. ****\\n \\n** ** HAPPY CODING****",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    ans+=4;\\n                    if(i-1>=0 && grid[i-1][j]==1)// check for the upward\\n                    {\\n                        ans--;\\n                    }\\n                    if(i+1<row && grid[i+1][j]==1)//check for the downward\\n                    {\\n                        ans--;\\n                    }\\n                    if(j-1>=0 && grid[i][j-1]==1)//check for the left\\n                    {\\n                        ans--;\\n                    }\\n                    if(j+1<col && grid[i][j+1]==1)// check for the right \\n                    {\\n                        ans--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>> & grid,int i, int j)\\n    {\\n        // if we are out of the grid, or we have already been at this cell, or the value is zero return,\\n        if( i < 0 || j < 0 || i > grid.size()-1 \\n       || j > grid[0].size()-1 || !grid[i][j] || grid[i][j] == -1) return 0 ; \\n       \\n        grid[i][j] = -1; \\n        int ans = 4; \\n        \\n        if(i < grid.size() - 1 && grid[i+1][j]) // check for the upward\\n            ans--; \\n        if(j < grid[0].size() -1 && grid[i][j+1])// check for the rightward\\n            ans--; \\n        \\n        if(j > 0 && grid[i][j-1])// check for the leftward\\n            ans--; \\n        if(i > 0 && grid[i-1][j])// check for the downward\\n            ans--;\\n        \\n        // call there dfs up,down ,left ,right.\\n        return ans + (dfs(grid, i + 1 ,j) + dfs(grid,i-1,j) + dfs(grid,i,j-1) + dfs(grid,i,j+1)); \\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int ans = 0 , row = grid.size(), col = grid[0].size();    \\n        for(int i = 0 ; i < row ; i++)\\n        {\\n           for(int j = 0 ; j < col ; j++)\\n           {\\n               if( grid[i][j])\\n               {\\n                 return dfs(grid,i,j);  \\n               }\\n           } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423297,
                "title": "recursive-dfs-iterative-dfs-and-bfs-python-solution",
                "content": "3 Condition to note\\n* We have reached the boundary of the square\\n* We have hit water\\n* We have to make sure we don\\'t revisit land already visited (set to some other value than 0 or 1) (-1 in recursive DFS)\\n\\n## DFS Recursive\\n```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        res = [0]\\n        \\n        rows, cols = len(grid), len(grid[0])\\n        \\n        \\n        def dfs(grid, i, j):\\n            if i<0 or i>rows-1 or j<0 or j>cols-1:\\n                res[0] += 1\\n                return \\n            \\n            if grid[i][j] == 0:\\n                res[0] += 1\\n                return\\n            \\n            if grid[i][j] == -1:\\n                return\\n            \\n            grid[i][j] = -1\\n            directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n            for dr, dc in directions:\\n                dfs(grid, i+dr, j+dc)\\n\\n            \\n        \\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 1:\\n                    dfs(grid, r, c)\\n                    return res[0]\\n```\\n## DFS Iterative\\n```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        perimeter = [0]\\n        \\n        rows, cols = len(grid), len(grid[0])\\n        visited = set()\\n        \\n        \\n        def bfs(r, c):\\n            q = deque()\\n            visited.add((r, c))\\n            q.append((r, c))\\n            \\n            while q:\\n                row, col = q.pop()\\n                direction = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n                \\n                for dr, dc in direction:\\n                    r, c = row+dr, col+dc\\n                    \\n                    if (r<0 or r>rows-1 or c<0 or c>cols-1):\\n                        perimeter[0] += 1\\n                        \\n                    elif grid[r][c] == 0:\\n                        perimeter[0] += 1\\n                        \\n                    elif (grid[r][c] == 1 and (r, c) not in visited):\\n                        visited.add((r, c))\\n                        q.append((r, c))\\n        \\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 1 and (r, c) not in visited:\\n                    bfs(r, c)\\n                    return perimeter[0]\\n                    \\n```\\n\\n\\n## BFS\\n```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        perimeter = [0]\\n        \\n        rows, cols = len(grid), len(grid[0])\\n        visited = set()\\n        \\n        \\n        def bfs(r, c):\\n            q = deque()\\n            visited.add((r, c))\\n            q.append((r, c))\\n            \\n            while q:\\n                row, col = q.popleft()\\n                direction = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n                \\n                for dr, dc in direction:\\n                    r, c = row+dr, col+dc\\n                    \\n                    if (r<0 or r>rows-1 or c<0 or c>cols-1):\\n                        perimeter[0] += 1\\n                        \\n                    elif grid[r][c] == 0:\\n                        perimeter[0] += 1\\n                        \\n                    elif (grid[r][c] == 1 and (r, c) not in visited):\\n                        visited.add((r, c))\\n                        q.append((r, c))\\n        \\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 1 and (r, c) not in visited:\\n                    bfs(r, c)\\n                    return perimeter[0]\\n                    \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        res = [0]\\n        \\n        rows, cols = len(grid), len(grid[0])\\n        \\n        \\n        def dfs(grid, i, j):\\n            if i<0 or i>rows-1 or j<0 or j>cols-1:\\n                res[0] += 1\\n                return \\n            \\n            if grid[i][j] == 0:\\n                res[0] += 1\\n                return\\n            \\n            if grid[i][j] == -1:\\n                return\\n            \\n            grid[i][j] = -1\\n            directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n            for dr, dc in directions:\\n                dfs(grid, i+dr, j+dc)\\n\\n            \\n        \\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 1:\\n                    dfs(grid, r, c)\\n                    return res[0]\\n```\n```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        perimeter = [0]\\n        \\n        rows, cols = len(grid), len(grid[0])\\n        visited = set()\\n        \\n        \\n        def bfs(r, c):\\n            q = deque()\\n            visited.add((r, c))\\n            q.append((r, c))\\n            \\n            while q:\\n                row, col = q.pop()\\n                direction = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n                \\n                for dr, dc in direction:\\n                    r, c = row+dr, col+dc\\n                    \\n                    if (r<0 or r>rows-1 or c<0 or c>cols-1):\\n                        perimeter[0] += 1\\n                        \\n                    elif grid[r][c] == 0:\\n                        perimeter[0] += 1\\n                        \\n                    elif (grid[r][c] == 1 and (r, c) not in visited):\\n                        visited.add((r, c))\\n                        q.append((r, c))\\n        \\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 1 and (r, c) not in visited:\\n                    bfs(r, c)\\n                    return perimeter[0]\\n                    \\n```\n```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        perimeter = [0]\\n        \\n        rows, cols = len(grid), len(grid[0])\\n        visited = set()\\n        \\n        \\n        def bfs(r, c):\\n            q = deque()\\n            visited.add((r, c))\\n            q.append((r, c))\\n            \\n            while q:\\n                row, col = q.popleft()\\n                direction = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n                \\n                for dr, dc in direction:\\n                    r, c = row+dr, col+dc\\n                    \\n                    if (r<0 or r>rows-1 or c<0 or c>cols-1):\\n                        perimeter[0] += 1\\n                        \\n                    elif grid[r][c] == 0:\\n                        perimeter[0] += 1\\n                        \\n                    elif (grid[r][c] == 1 and (r, c) not in visited):\\n                        visited.add((r, c))\\n                        q.append((r, c))\\n        \\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 1 and (r, c) not in visited:\\n                    bfs(r, c)\\n                    return perimeter[0]\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 909346,
                "title": "easy-js-solution",
                "content": "```\\nvar islandPerimeter = function(grid) {\\n    let height = grid.length, width = grid[0].length;\\n    let count = 0;\\n    for (let row = 0; row < height; row++) {\\n        for (let col = 0; col < width; col++) {\\n            if (grid[row][col] == 1) {\\n                count += 4;\\n                if (row > 0 && grid[row-1][col] == 1) count--;\\n                if (row < height-1 && grid[row+1][col] == 1) count--;\\n                if (grid[row][col-1] == 1) count--;\\n                if (grid[row][col+1] == 1) count--;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n\\n/*\\nFor every sigle square our perimeter increases by 4 since a square has four sides. But, when two squares meet, each square loses one side.\\nSo, whenever we are on land, we check our top, bottom, left and right to check if there are connected lands and if there are, for each square we subtract one side.\\n\\nTime Complexity: O(row*col)\\nSpace Complexity: O(1)\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar islandPerimeter = function(grid) {\\n    let height = grid.length, width = grid[0].length;\\n    let count = 0;\\n    for (let row = 0; row < height; row++) {\\n        for (let col = 0; col < width; col++) {\\n            if (grid[row][col] == 1) {\\n                count += 4;\\n                if (row > 0 && grid[row-1][col] == 1) count--;\\n                if (row < height-1 && grid[row+1][col] == 1) count--;\\n                if (grid[row][col-1] == 1) count--;\\n                if (grid[row][col+1] == 1) count--;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n\\n/*\\nFor every sigle square our perimeter increases by 4 since a square has four sides. But, when two squares meet, each square loses one side.\\nSo, whenever we are on land, we check our top, bottom, left and right to check if there are connected lands and if there are, for each square we subtract one side.\\n\\nTime Complexity: O(row*col)\\nSpace Complexity: O(1)\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 723933,
                "title": "c-dfs-clean-and-simple-code-with-explain",
                "content": "The Approch Is Straight Forword As we Need to Found perimeter of the island\\nFirst of all We need to Find one land grid And then Do DFS and count For each land Grid All the adjcent grid is valid land or Not . If it\\'s Not  do Increse your perimeter count \\nThats we Are Done!!!!!\\nLet\\'s take An exmple To Uderstand it\\n![image](https://assets.leetcode.com/users/images/ff90061f-4f90-4542-81e5-7cac2e86df72_1594110272.9041574.png)\\nAs We Found our first Land at ( 0 , 1 )\\nneed to Run DFS Form That grid [ The Red One ] and and count perimeter for Each Land For an Example For That Red one perimeter is 3 and   As one Arraow pointing on A land Grid so we can\\'t consider it as a perimeter\\nFor Green Grid perimeter would be 2 \\nThis Is how we are going to count perimeter \\nAt last return It\\'s Count!!!!!!!!!!!!\\n\\n```\\nclass Solution {\\npublic:\\n    int DFS(vector<vector<int>>& grid,int x, int y,vector<vector<bool>>&visited){\\n        if(x<0||y<0||x>=grid.size()||y>=grid[0].size()||!grid[x][y])return 1;\\n        if(visited[x][y])return 0;\\n        visited[x][y] = true;\\n        int a = DFS(grid,x+1,y,visited);\\n            a +=DFS(grid,x-1,y,visited);\\n            a +=DFS(grid,x,y+1,visited);\\n            a +=DFS(grid,x,y-1,visited);\\n        return a;\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        vector<vector<bool>>visited(grid.size(),vector<bool>(grid[0].size(),false));\\n        for(int i = 0;i<grid.size();i++){\\n            for(int j = 0;j<grid[i].size();j++){\\n                if(grid[i][j]){\\n                    return DFS(grid,i,j,visited);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\nIf It\\'s Help You Please upvote It\\nAnd foSuggestion Comment Bellow\\nThank You (^-^)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int DFS(vector<vector<int>>& grid,int x, int y,vector<vector<bool>>&visited){\\n        if(x<0||y<0||x>=grid.size()||y>=grid[0].size()||!grid[x][y])return 1;\\n        if(visited[x][y])return 0;\\n        visited[x][y] = true;\\n        int a = DFS(grid,x+1,y,visited);\\n            a +=DFS(grid,x-1,y,visited);\\n            a +=DFS(grid,x,y+1,visited);\\n            a +=DFS(grid,x,y-1,visited);\\n        return a;\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        vector<vector<bool>>visited(grid.size(),vector<bool>(grid[0].size(),false));\\n        for(int i = 0;i<grid.size();i++){\\n            for(int j = 0;j<grid[i].size();j++){\\n                if(grid[i][j]){\\n                    return DFS(grid,i,j,visited);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723886,
                "title": "c-same-as-no-of-islands-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int islands = 0;\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = m ? grid[0].size() : 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    eraseIslands(grid, i, j);\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\nprivate:\\n    void eraseIslands(vector<vector<int>>& grid, int i, int j) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (i < 0 || i == m || j < 0 || j == n || grid[i][j] == 0) {\\n            islands++;\\n            return;\\n        }\\n        if(grid[i][j] == 2){\\n            return;\\n        }\\n        grid[i][j] = 2;\\n        eraseIslands(grid, i - 1, j);\\n        eraseIslands(grid, i + 1, j);\\n        eraseIslands(grid, i, j - 1);\\n        eraseIslands(grid, i, j + 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int islands = 0;\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = m ? grid[0].size() : 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    eraseIslands(grid, i, j);\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\nprivate:\\n    void eraseIslands(vector<vector<int>>& grid, int i, int j) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (i < 0 || i == m || j < 0 || j == n || grid[i][j] == 0) {\\n            islands++;\\n            return;\\n        }\\n        if(grid[i][j] == 2){\\n            return;\\n        }\\n        grid[i][j] = 2;\\n        eraseIslands(grid, i - 1, j);\\n        eraseIslands(grid, i + 1, j);\\n        eraseIslands(grid, i, j - 1);\\n        eraseIslands(grid, i, j + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278771,
                "title": "463-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define a function named \"islandPerimeter\" that takes in a 2D list of integers called \"grid\" and returns an integer.\\n2. Initialize a variable \"perimeter\" to 0.\\n3. Loop through each cell in the grid using two nested for loops.\\n4. Check if the current cell is a land cell (has a value of 1).\\n5. If it is a land cell, check the cell\\'s neighbors and add to the perimeter accordingly.\\n6. Check the neighbor above the current cell. If it is a water cell or the current cell is on the top edge of the grid, add 1 to the perimeter.\\n7. Check the neighbor to the left of the current cell. If it is a water cell or the current cell is on the left edge of the grid, add 1 to the perimeter.\\n8. Check the neighbor below the current cell. If it is a water cell or the current cell is on the bottom edge of the grid, add 1 to the perimeter.\\n9. Check the neighbor to the right of the current cell. If it is a water cell or the current cell is on the right edge of the grid, add 1 to the perimeter.\\n10. After looping through all cells in the grid, return the final value of \"perimeter\".\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        # Initialize perimeter to 0\\n        perimeter = 0\\n        \\n        # Loop through each cell in the grid\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                if grid[i][j] == 1:\\n                    # Check the cell\\'s neighbors and add to perimeter accordingly\\n                    if i == 0 or grid[i-1][j] == 0:\\n                        perimeter += 1\\n                    if j == 0 or grid[i][j-1] == 0:\\n                        perimeter += 1\\n                    if i == len(grid)-1 or grid[i+1][j] == 0:\\n                        perimeter += 1\\n                    if j == len(grid[i])-1 or grid[i][j+1] == 0:\\n                        perimeter += 1\\n        \\n        return perimeter\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        # Initialize perimeter to 0\\n        perimeter = 0\\n        \\n        # Loop through each cell in the grid\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                if grid[i][j] == 1:\\n                    # Check the cell\\'s neighbors and add to perimeter accordingly\\n                    if i == 0 or grid[i-1][j] == 0:\\n                        perimeter += 1\\n                    if j == 0 or grid[i][j-1] == 0:\\n                        perimeter += 1\\n                    if i == len(grid)-1 or grid[i+1][j] == 0:\\n                        perimeter += 1\\n                    if j == len(grid[i])-1 or grid[i][j+1] == 0:\\n                        perimeter += 1\\n        \\n        return perimeter\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502325,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) \\n    {\\n        ios_base::sync_with_stdio(false),cin.tie(NULL);\\n        int ans=0;\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    ans+=4;\\n                    if(i>0 && grid[i-1][j]) \\n                        ans-=2;\\n                    if(j>0 && grid[i][j-1]) \\n                        ans-=2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) \\n    {\\n        ios_base::sync_with_stdio(false),cin.tie(NULL);\\n        int ans=0;\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    ans+=4;\\n                    if(i>0 && grid[i-1][j]) \\n                        ans-=2;\\n                    if(j>0 && grid[i][j-1]) \\n                        ans-=2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145167,
                "title": "weeb-does-python-bfs",
                "content": "\\n\\tclass Solution:\\n\\t\\tdef islandPerimeter(self, grid: List[List[int]]) -> int:\\n\\t\\t\\trow, col, queue = len(grid), len(grid[0]), deque()\\n\\t\\t\\tfor x in range(row):\\n\\t\\t\\t\\tfor y in range(col):\\n\\t\\t\\t\\t\\tif grid[x][y] == 1:\\n\\t\\t\\t\\t\\t\\tqueue.append((x,y))\\n\\t\\t\\t\\t\\t\\treturn self.bfs(grid, row, col, queue)\\n\\n\\t\\tdef bfs(self,grid, row, col, queue):\\n\\t\\t\\tvisited = set()\\n\\t\\t\\tperimeter = 0\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tx,y = queue.popleft()\\n\\t\\t\\t\\tif (x,y) in visited: continue\\n\\t\\t\\t\\tvisited.add((x,y))\\n\\t\\t\\t\\tfor nx,ny in [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]:\\n\\t\\t\\t\\t\\tif 0<=nx<row and 0<=ny<col:\\n\\t\\t\\t\\t\\t\\tif grid[nx][ny] == 0:\\n\\t\\t\\t\\t\\t\\t\\tperimeter+=1\\n\\t\\t\\t\\t\\t\\tif grid[nx][ny] == 1:\\n\\t\\t\\t\\t\\t\\t\\tqueue.append((nx,ny))\\n\\t\\t\\t\\t\\telse: # if out of grid\\n\\t\\t\\t\\t\\t\\tperimeter+=1\\n\\n\\t\\t\\treturn perimeter\\nMy solution is slow, but it uses bfs so hopefully it helps someone that uses a similar method to solve this question.\\n\\nAnyways, its anime time.\\n# Go ahead and check out ***Akagami no Shirayuki-hime (Snow White with the Red Hair)***\\n\\n# Genre: Fantasy, Romance, Drama\\n# Episodes: 24 +1 OVA*\\n\\nI like this anime. So u should try it out as well.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "\\n\\tclass Solution:\\n\\t\\tdef islandPerimeter(self, grid: List[List[int]]) -> int:\\n\\t\\t\\trow, col, queue = len(grid), len(grid[0]), deque()\\n\\t\\t\\tfor x in range(row):\\n\\t\\t\\t\\tfor y in range(col):\\n\\t\\t\\t\\t\\tif grid[x][y] == 1:\\n\\t\\t\\t\\t\\t\\tqueue.append((x,y))\\n\\t\\t\\t\\t\\t\\treturn self.bfs(grid, row, col, queue)\\n\\n\\t\\tdef bfs(self,grid, row, col, queue):\\n\\t\\t\\tvisited = set()\\n\\t\\t\\tperimeter = 0\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tx,y = queue.popleft()\\n\\t\\t\\t\\tif (x,y) in visited: continue\\n\\t\\t\\t\\tvisited.add((x,y))\\n\\t\\t\\t\\tfor nx,ny in [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]:\\n\\t\\t\\t\\t\\tif 0<=nx<row and 0<=ny<col:\\n\\t\\t\\t\\t\\t\\tif grid[nx][ny] == 0:\\n\\t\\t\\t\\t\\t\\t\\tperimeter+=1\\n\\t\\t\\t\\t\\t\\tif grid[nx][ny] == 1:\\n\\t\\t\\t\\t\\t\\t\\tqueue.append((nx,ny))\\n\\t\\t\\t\\t\\telse: # if out of grid\\n\\t\\t\\t\\t\\t\\tperimeter+=1\\n\\n\\t\\t\\treturn perimeter\\nMy solution is slow, but it uses bfs so hopefully it helps someone that uses a similar method to solve this question.\\n\\nAnyways, its anime time.\\n# Go ahead and check out ***Akagami no Shirayuki-hime (Snow White with the Red Hair)***\\n\\n# Genre: Fantasy, Romance, Drama\\n# Episodes: 24 +1 OVA*\\n\\nI like this anime. So u should try it out as well.\\n",
                "codeTag": "Java"
            },
            {
                "id": 883259,
                "title": "simple-iterative-solution-faster-than-90-linear-complexity",
                "content": "In this approach we simply iterate through the grid once and check for grid values. \\nThe idea behind is to simply subtract the values from the result if encountered a \"1\" above or left of the current element.\\n\\n\\nIf we find an element, we add 4 to the result *top, bottom, left and right*. Now when we move and find an element to the top(i-1, j) and/or left(i, j -1) we subtract 2 from the result as we loose edges.\\n\\nHere is the Pythonic Implementation below:\\n```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        \\n        if m == 0:  # if empty grid\\n            return 0\\n        \\n        n = len(grid[0])\\n        res = 0    # initial value\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:  # if found \"1\"\\n                    res += 4\\n                    \\n                if i > 0 and grid[i-1][j] == 1and grid[i][j] == 1:  # if found an top element\\n                    res -= 2\\n                if j > 0 and grid[i][j - 1] == 1 and grid[i][j] == 1: # if found a left element\\n                    res -= 2\\n                    \\n        return res\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        \\n        if m == 0:  # if empty grid\\n            return 0\\n        \\n        n = len(grid[0])\\n        res = 0    # initial value\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:  # if found \"1\"\\n                    res += 4\\n                    \\n                if i > 0 and grid[i-1][j] == 1and grid[i][j] == 1:  # if found an top element\\n                    res -= 2\\n                if j > 0 and grid[i][j - 1] == 1 and grid[i][j] == 1: # if found a left element\\n                    res -= 2\\n                    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723836,
                "title": "c-easiest-and-most-concise-code-o-m-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        if(grid.empty())    return 0;\\n        int m = grid.size(), n = grid[0].size(), peri = 0;\\n        \\n        auto borderLines = [&](int i, int j) -> int {\\n            int cnt = 0;\\n            if(i-1 < 0 || grid[i-1][j] == 0)    cnt++;\\n            if(j+1 >= n || grid[i][j+1] == 0)   cnt++;\\n            if(i+1 >= m || grid[i+1][j] == 0)   cnt++;\\n            if(j-1 < 0 || grid[i][j-1] == 0)    cnt++;\\n            return cnt;\\n        };\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 1)    peri += borderLines(i, j);\\n            }\\n        }\\n        return peri;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        if(grid.empty())    return 0;\\n        int m = grid.size(), n = grid[0].size(), peri = 0;\\n        \\n        auto borderLines = [&](int i, int j) -> int {\\n            int cnt = 0;\\n            if(i-1 < 0 || grid[i-1][j] == 0)    cnt++;\\n            if(j+1 >= n || grid[i][j+1] == 0)   cnt++;\\n            if(i+1 >= m || grid[i+1][j] == 0)   cnt++;\\n            if(j-1 < 0 || grid[i][j-1] == 0)    cnt++;\\n            return cnt;\\n        };\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 1)    peri += borderLines(i, j);\\n            }\\n        }\\n        return peri;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 608148,
                "title": "java-99-8-time-efficient-and-100-memory-efficient",
                "content": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==1){\\n                    count+=4;\\n                    if(i-1>-1 && grid[i-1][j]==1)\\n                        count--;\\n                    if(j+1<grid[0].length && grid[i][j+1]==1)\\n                        count--;\\n                    if(i+1<grid.length && grid[i+1][j]==1)\\n                        count--;\\n                    if(j-1>-1 && grid[i][j-1]==1)\\n                        count--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==1){\\n                    count+=4;\\n                    if(i-1>-1 && grid[i-1][j]==1)\\n                        count--;\\n                    if(j+1<grid[0].length && grid[i][j+1]==1)\\n                        count--;\\n                    if(i+1<grid.length && grid[i+1][j]==1)\\n                        count--;\\n                    if(j-1>-1 && grid[i][j-1]==1)\\n                        count--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 264689,
                "title": "java-solution-6ms-beats-100",
                "content": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int result = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[i].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    result += 4;\\n                    if(i > 0 && grid[i - 1][j] == 1)\\n                        result -= 2;\\n                    if(j > 0 && grid[i][j - 1] == 1)\\n                        result -= 2;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int result = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[i].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    result += 4;\\n                    if(i > 0 && grid[i - 1][j] == 1)\\n                        result -= 2;\\n                    if(j > 0 && grid[i][j - 1] == 1)\\n                        result -= 2;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570472,
                "title": "python-simple-dfs-implementation",
                "content": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        m,n,visited = len(grid), len(grid[0]), set()\\n        \\n        def dfs(i,j):\\n            if (i,j) in visited: return 0\\n            if i<0 or i>=m or j<0 or j>=n or grid[i][j] == 0: return 1\\n\\t\\t\\tvisited.add((i,j))\\n            return dfs(i+1,j) + dfs(i-1,j) + dfs(i,j+1) + dfs(i,j-1)\\n   \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    return dfs(i,j)\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        m,n,visited = len(grid), len(grid[0]), set()\\n        \\n        def dfs(i,j):\\n            if (i,j) in visited: return 0\\n            if i<0 or i>=m or j<0 or j>=n or grid[i][j] == 0: return 1\\n\\t\\t\\tvisited.add((i,j))\\n            return dfs(i+1,j) + dfs(i-1,j) + dfs(i,j+1) + dfs(i,j-1)\\n   \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    return dfs(i,j)\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400724,
                "title": "simplest-dfs-approach-with-explanation",
                "content": "**Simply we have to tarvsere until 0 comes and matain count for that because when ever a 0 comes it means an outer side i.e towrds water(or boundary) and hence will be added to perimeter .And  if two sides are adjacent it will not include them because we have done if grid[i][j]==0 then return 1  so only need to dfs in four directions and whenever it is a zero return 1**\\n*Dfs in four directions is done beacuse lands are connected in four directions up,down ,left ,right*\\n*Also whenever its an edge case like at the ends when i==0 or j==0  or i==n-1 or j==n-1 we have to count them also beacuse they are the boundries there hence will be added to perimeter*\\n*And at last we have to do dfs from the point which is 1*\\n\\n```\\n  int dfs(vector<vector<int>>& grid,int sr,int sc){\\n        if(sr<0 || sr>=grid.size() || sc<0 || sc>=grid[0].size() || grid[sr][sc]==0){\\n         return 1 ;\\n        }\\n        if(grid[sr][sc]==-1)return 0;\\n        grid[sr][sc]=-1;\\n    \\n       return dfs(grid,sr,sc+1)+\\n       dfs(grid,sr-1,sc)+   \\n        dfs(grid,sr+1,sc)+\\n        dfs(grid,sr,sc-1);   \\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int cnt=0;\\n         for(int i=0;i<grid.size();i++){\\n             for(int j=0;j<grid[0].size();j++){\\n                 if(grid[i][j]==1){\\n                    cnt= dfs(grid,i,j);break;\\n                 }\\n             }\\n         }\\n        return cnt;\\n    }\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n  int dfs(vector<vector<int>>& grid,int sr,int sc){\\n        if(sr<0 || sr>=grid.size() || sc<0 || sc>=grid[0].size() || grid[sr][sc]==0){\\n         return 1 ;\\n        }\\n        if(grid[sr][sc]==-1)return 0;\\n        grid[sr][sc]=-1;\\n    \\n       return dfs(grid,sr,sc+1)+\\n       dfs(grid,sr-1,sc)+   \\n        dfs(grid,sr+1,sc)+\\n        dfs(grid,sr,sc-1);   \\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int cnt=0;\\n         for(int i=0;i<grid.size();i++){\\n             for(int j=0;j<grid[0].size();j++){\\n                 if(grid[i][j]==1){\\n                    cnt= dfs(grid,i,j);break;\\n                 }\\n             }\\n         }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1931554,
                "title": "java-dfs-solution",
                "content": "```\\n/**\\n    DFS\\n    Time: O(m*n)\\n    space: O(m*n)\\n*/\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) { // there is only one island so we can return immediately                \\n                    return dfs(grid, i, j, visited);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    public int dfs(int[][] grid, int x, int y, boolean[][] visited) {\\n        if (x < 0 || x > grid.length-1 || y < 0 || y > grid[0].length-1) {\\n            return 1; // we hit edge of matrix\\n        }\\n        if (grid[x][y] == 0) { // we can visit 0\\'s more than once because we need to count more than one edge\\n            return 1;\\n        } else if (grid[x][y] == 1 && !visited[x][y]) { // don\\'t visted 1\\'s more than once otherwise loop\\n            visited[x][y] = true;\\n            int right = dfs(grid, x+1, y, visited);\\n            int top = dfs(grid, x, y+1, visited);\\n            int left = dfs(grid, x-1, y, visited);\\n            int down = dfs(grid, x, y-1, visited);\\n            return top + down + left + right;        \\n        }\\n        return 0;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) { // there is only one island so we can return immediately                \\n                    return dfs(grid, i, j, visited);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1809218,
                "title": "c-brute-force-easy-76-faster-consumes-87-less-memory-explained",
                "content": "Please Upvote if you like...\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\n\\nclass Solution {\\npublic:\\n\\n    int islandPerimeter(vector<vector<int>>& grid)\\n    {\\n        int ans = 0;\\n        int row = grid.size(), col = grid[0].size();\\n        \\n        for(int i = 0; i < row; i++)\\n        {\\n           for(int j = 0; j < col; j++)\\n           {\\n               if(grid[i][j] == 1)\\n               {\\n                  ans += 4;                 //we assume that all four sides are water\\n                  \\n                  if(i > 0)               //bound check and decremented by 1\\n                      ans -= grid[i-1][j];\\n                   \\n                  if(j > 0)                           //bound check and decremented by 1\\n                      ans -= grid[i][j-1];\\n                  \\n                  if(i < row-1)                     //bound check and decremented by 1\\n                      ans -= grid[i+1][j]; \\n                   \\n                  if(j < col-1)                      //bound check and decremented by 1\\n                      ans -= grid[i][j+1]; \\n               }\\n           } \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int islandPerimeter(vector<vector<int>>& grid)\\n    {\\n        int ans = 0;\\n        int row = grid.size(), col = grid[0].size();\\n        \\n        for(int i = 0; i < row; i++)\\n        {\\n           for(int j = 0; j < col; j++)\\n           {\\n               if(grid[i][j] == 1)\\n               {\\n                  ans += 4;                 //we assume that all four sides are water\\n                  \\n                  if(i > 0)               //bound check and decremented by 1\\n                      ans -= grid[i-1][j];\\n                   \\n                  if(j > 0)                           //bound check and decremented by 1\\n                      ans -= grid[i][j-1];\\n                  \\n                  if(i < row-1)                     //bound check and decremented by 1\\n                      ans -= grid[i+1][j]; \\n                   \\n                  if(j < col-1)                      //bound check and decremented by 1\\n                      ans -= grid[i][j+1]; \\n               }",
                "codeTag": "Java"
            },
            {
                "id": 1712398,
                "title": "c-easy-solution-with-explanation",
                "content": "Please upvote if you find it useful !!\\n\\n```\\nclass Solution {\\n  \\n\\npublic:\\n     void dfs(int i, int j,vector<vector<int>>& grid, vector<vector<bool>>&vis,int &sum)\\n   \\n\\t{\\n        \\n        if(i<0  || j<0 || j>=grid[0].size() || i>=grid.size() ||  grid[i][j]==0)   //if the boundary condition hits and the cell contains 0 , will increment the perimeter by 1\\n        { \\n            sum+=1;\\n            return;\\n        }\\n       \\n       if(vis[i][j]==true)    //if the cell is visited return  \\n       {\\n         return;\\n       }\\n       \\n       \\n        \\n       vis[i][j]=true;  //make the cell visited\\n       \\n      //do dfs for all four directions \\n\\t  \\n             dfs(i-1,j,grid,vis,sum);\\n          dfs(i,j+1,grid,vis,sum);\\n           dfs(i,j-1,grid,vis,sum);\\n        dfs(i+1,j,grid,vis,sum);\\n       \\n    \\n     \\n      \\n        \\n        \\n    }\\n    \\n  \\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        \\n       int sum=0;   // will contain perimeter\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<vector<bool>>vis(r, vector<bool>(c,false));\\n    \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)    //traverse the grid \\n            {\\n                if(grid[i][j]==1 and vis[i][j]==false)    // if the cell contains 1 and not visited  do dfs \\n                {\\n                    dfs(i,j,grid,vis,sum);\\n                    \\n                }\\n            }\\n        }\\n      \\n      return sum;      //return the perimeter\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n  \\n\\npublic:\\n     void dfs(int i, int j,vector<vector<int>>& grid, vector<vector<bool>>&vis,int &sum)\\n   \\n\\t{\\n        \\n        if(i<0  || j<0 || j>=grid[0].size() || i>=grid.size() ||  grid[i][j]==0)   //if the boundary condition hits and the cell contains 0 , will increment the perimeter by 1\\n        { \\n            sum+=1;\\n            return;\\n        }\\n       \\n       if(vis[i][j]==true)    //if the cell is visited return  \\n       {\\n         return;\\n       }\\n       \\n       \\n        \\n       vis[i][j]=true;  //make the cell visited\\n       \\n      //do dfs for all four directions \\n\\t  \\n             dfs(i-1,j,grid,vis,sum);\\n          dfs(i,j+1,grid,vis,sum);\\n           dfs(i,j-1,grid,vis,sum);\\n        dfs(i+1,j,grid,vis,sum);\\n       \\n    \\n     \\n      \\n        \\n        \\n    }\\n    \\n  \\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        \\n       int sum=0;   // will contain perimeter\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<vector<bool>>vis(r, vector<bool>(c,false));\\n    \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)    //traverse the grid \\n            {\\n                if(grid[i][j]==1 and vis[i][j]==false)    // if the cell contains 1 and not visited  do dfs \\n                {\\n                    dfs(i,j,grid,vis,sum);\\n                    \\n                }\\n            }\\n        }\\n      \\n      return sum;      //return the perimeter\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622214,
                "title": "c-97-easy-to-understand-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int res = 0, m = grid.size(), n = grid[0].size(), rep = 0;\\n        \\n        for(int i=0;i<m;i++) \\n            for(int j=0;j<n;j++) \\n                    if(grid[i][j]==1) \\n                    {\\n                        res++;\\n                        if(i!=0 && grid[i-1][j]==1) rep++;\\n                        if(j!=0 && grid[i][j-1]==1) rep++;\\n                    }\\n        \\n        return (4 * res) - (2 * rep);\\n    }\\n};\\n\\n``` \\n\\neverytime we encounter a piece of land we add it in `res`, \\neverytime we see a border / replication of side between two adjacent pieces of land we add it in `rep` (repetition). \\n\\nat each node we have to check whether there is a peice of land above it `grid[i-1][j]==1` or if there is a piece of land adjacent on the left side `grid[i][j-1]==1` if so we add them in rep. \\n\\nafter we have traversed the entire 2D matrix we calculate the result by subtracting the value of original nodes found i.e. `4 * res` minus the duplicates found along the way i.e. `2 * rep`. \\n\\nPlease Upvote if you like the solution :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int res = 0, m = grid.size(), n = grid[0].size(), rep = 0;\\n        \\n        for(int i=0;i<m;i++) \\n            for(int j=0;j<n;j++) \\n                    if(grid[i][j]==1) \\n                    {\\n                        res++;\\n                        if(i!=0 && grid[i-1][j]==1) rep++;\\n                        if(j!=0 && grid[i][j-1]==1) rep++;\\n                    }\\n        \\n        return (4 * res) - (2 * rep);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375928,
                "title": "c-solution-clean-code-90-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        if(m == 0 || n == 0) return 0;\\n\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j]){\\n                    ans += 4;\\n                    if(i > 0 && grid[i-1][j]) ans -= 2;\\n                    if(j > 0 && grid[i][j-1]) ans -= 2;\\n                }     \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        if(m == 0 || n == 0) return 0;\\n\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j]){\\n                    ans += 4;\\n                    if(i > 0 && grid[i-1][j]) ans -= 2;\\n                    if(j > 0 && grid[i][j-1]) ans -= 2;\\n                }     \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334428,
                "title": "clean-and-concise-dfs-solution-c",
                "content": "```\\n   int count=0;\\n    void dfs(vector<vector<int>>& grid,int i,int j){\\n        if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || grid[i][j]==0)\\n        {\\n            count++;\\n            return;\\n        }\\n\\n        if(grid[i][j]==-1)\\n            return;\\n                \\n        grid[i][j]=-1;\\n   \\n        dfs(grid,i+1,j);\\n        dfs(grid,i,j+1);\\n        dfs(grid,i-1,j);\\n        dfs(grid,i,j-1);\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    dfs(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n   int count=0;\\n    void dfs(vector<vector<int>>& grid,int i,int j){\\n        if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || grid[i][j]==0)\\n        {\\n            count++;\\n            return;\\n        }\\n\\n        if(grid[i][j]==-1)\\n            return;\\n                \\n        grid[i][j]=-1;\\n   \\n        dfs(grid,i+1,j);\\n        dfs(grid,i,j+1);\\n        dfs(grid,i-1,j);\\n        dfs(grid,i,j-1);\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    dfs(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1265116,
                "title": "python-3-easy-to-understand-and-readable-code-that-beats-99-63",
                "content": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        perimeter = 0\\n        for row_idx, row in enumerate(grid):\\n            for col_idx, land in enumerate(row):\\n                if not land:\\n                    continue\\n                perimeter += 4\\n\\t\\t\\t\\t# If previous cell in the current row is land, reduce the perimeter by 2\\n                if col_idx and row[col_idx - 1]:\\n                    perimeter -= 2\\n\\t\\t\\t\\t# If current column index of the previous/above row is land, reduce the perimeter by 2\\n                if row_idx and grid[row_idx - 1][col_idx]:\\n                    perimeter -= 2\\n        return perimeter\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        perimeter = 0\\n        for row_idx, row in enumerate(grid):\\n            for col_idx, land in enumerate(row):\\n                if not land:\\n                    continue\\n                perimeter += 4\\n\\t\\t\\t\\t# If previous cell in the current row is land, reduce the perimeter by 2\\n                if col_idx and row[col_idx - 1]:\\n                    perimeter -= 2\\n\\t\\t\\t\\t# If current column index of the previous/above row is land, reduce the perimeter by 2\\n                if row_idx and grid[row_idx - 1][col_idx]:\\n                    perimeter -= 2\\n        return perimeter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316625,
                "title": "java-easy-understand-solution-minus-one-if-have-a-neighbor",
                "content": "```\\nclass Solution {\\n   public int islandPerimeter(int[][] grid) {\\n    if (grid == null || grid.length == 0) {\\n        return 0;\\n    }\\n   if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        int result = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    result += 4;\\n                    if (i > 0 && grid[i-1][j] == 1) result--;\\n                    if (j > 0 && grid[i][j-1] == 1) result--;\\n                    if (i+1 < grid.length && grid[i+1][j] == 1) result--;\\n                    if (j+1 < grid[0].length && grid[i][j+1] == 1) result--;\\n                }\\n            }\\n        }\\n\\n    return result;\\n   }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public int islandPerimeter(int[][] grid) {\\n    if (grid == null || grid.length == 0) {\\n        return 0;\\n    }\\n   if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        int result = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    result += 4;\\n                    if (i > 0 && grid[i-1][j] == 1) result--;\\n                    if (j > 0 && grid[i][j-1] == 1) result--;\\n                    if (i+1 < grid.length && grid[i+1][j] == 1) result--;\\n                    if (j+1 < grid[0].length && grid[i][j+1] == 1) result--;\\n                }\\n            }\\n        }\\n\\n    return result;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238293,
                "title": "java-easy-solution-with-explaination-beats-100",
                "content": "Every tile will have perimeter 4. But if it has adjacent tile, 1 edge would not be included in the perimeter..\\n\\nSo, if a tile has 0 neigbours, its contribution to answer will be 4.\\nif a tile has 1 neighbour, its contribution to answer will be 4-1 = 3.\\nif a tile has 2 neighbours, its contribution to answer will be 4-1-1 = 2.\\nif a tile has 3 neighbours, its contribution to answer will be 4-1-1-1 = 1\\nif a tile has 4 neighbours, its contribution to answer will be 4-1-1-1-1 = 0.\\n\\n```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) \\n    {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                int t=0;\\n                if(grid[i][j]==1)\\n                {\\n                    t=4;\\n                    if(i>=1 && grid[i-1][j]==1)\\n                        t--;\\n                    if(i<grid.length-1 && grid[i+1][j]==1)\\n                        t--;\\n                    if(j>=1 && grid[i][j-1]==1)\\n                        t--;\\n                    if(j<grid[i].length-1 && grid[i][j+1]==1)\\n                        t--;\\n                    \\n                    count=count+t;\\n                        \\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int islandPerimeter(int[][] grid) \\n    {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                int t=0;\\n                if(grid[i][j]==1)\\n                {\\n                    t=4;\\n                    if(i>=1 && grid[i-1][j]==1)\\n                        t--;\\n                    if(i<grid.length-1 && grid[i+1][j]==1)\\n                        t--;\\n                    if(j>=1 && grid[i][j-1]==1)\\n                        t--;\\n                    if(j<grid[i].length-1 && grid[i][j+1]==1)\\n                        t--;\\n                    \\n                    count=count+t;\\n                        \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 95179,
                "title": "c-easy-to-understand-find-edges",
                "content": "\\n        int n = grid.size(); //num_rows\\n        int m = grid[0].size(); //num_cols\\n        int sum = 0,i,j;\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<m-1;j++)\\n            {\\n                sum += abs(grid[i][j+1]-grid[i][j]); //find vertical edges\\n            }\\n            sum = sum+grid[i][j]+grid[i][0]; //account for 2 corner blocks\\n        }\\n        \\n        for(j=0;j<m;j++)\\n        {\\n            for(i=0;i<n-1;i++)\\n            {\\n                sum += abs(grid[i+1][j]-grid[i][j]); //find horizontal edges\\n            }\\n            sum = sum + grid[i][j] + grid[0][j]; //account for 2 corner blocks\\n        }\\n        return sum;",
                "solutionTags": [],
                "code": "\\n        int n = grid.size(); //num_rows\\n        int m = grid[0].size(); //num_cols\\n        int sum = 0,i,j;\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<m-1;j++)\\n            {\\n                sum += abs(grid[i][j+1]-grid[i][j]); //find vertical edges\\n            }\\n            sum = sum+grid[i][j]+grid[i][0]; //account for 2 corner blocks\\n        }\\n        \\n        for(j=0;j<m;j++)\\n        {\\n            for(i=0;i<n-1;i++)\\n            {\\n                sum += abs(grid[i+1][j]-grid[i][j]); //find horizontal edges\\n            }\\n            sum = sum + grid[i][j] + grid[0][j]; //account for 2 corner blocks\\n        }\\n        return sum;",
                "codeTag": "Unknown"
            },
            {
                "id": 3665997,
                "title": "c-solution-explained",
                "content": "\\n# Approach\\nThe function islandPerimeter takes a 2D vector grid as input, representing the map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.\\n\\nThe function initializes a variable perimeter to 0, which will be used to keep track of the island\\u2019s perimeter. It then gets the number of rows and columns in the grid using the size() method.\\n\\nThe function then uses a nested for loop to iterate through each cell in the grid. If the current cell is land (grid[i][j] == 1), it adds 4 to the perimeter (since a square has 4 sides).\\n\\n However, if the current cell has adjacent land cells (either to its left or above it), it means that those sides are not part of the perimeter (since they are connected to other land cells), so the code subtracts 2 from the perimeter for each adjacent land cell.\\n\\nAfter iterating through all the cells in the grid, the function returns the final value of perimeter, which represents the perimeter of the island.\\n\\n# Complexity\\n- Time complexity:O(n*m)\\n\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n         int perimeter = 0;\\n    int row = grid.size();\\n    int col = grid[0].size();\\n    for (int i = 0; i < row; i++) {\\n        for (int j = 0; j < col; j++) {\\n            if (grid[i][j] == 1) {\\n                perimeter += 4;\\n                if (i > 0 && grid[i-1][j] == 1) perimeter -= 2;\\n                if (j > 0 && grid[i][j-1] == 1) perimeter -= 2;\\n            }\\n        }\\n    }\\n    return perimeter;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n         int perimeter = 0;\\n    int row = grid.size();\\n    int col = grid[0].size();\\n    for (int i = 0; i < row; i++) {\\n        for (int j = 0; j < col; j++) {\\n            if (grid[i][j] == 1) {\\n                perimeter += 4;\\n                if (i > 0 && grid[i-1][j] == 1) perimeter -= 2;\\n                if (j > 0 && grid[i][j-1] == 1) perimeter -= 2;\\n            }\\n        }\\n    }\\n    return perimeter;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975200,
                "title": "c-dfs-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- There is only one island with all cells as 1. \\n- Traverse through all one\\'s from a island and calculate the perimeter by adding number of zero cells they are connected to.\\n# Approach:\\n<!-- Describe your approach to solving the problem. -->\\n- Call DFS function when cell is non-zero basically that is a part of island and non-visited.\\n- Now calculate perimeter by adding zero cells they\\'re connected to.\\n- Take care of boundary cells and water when row and column number go out of bound.\\n# Complexity:\\n- Time complexity: O(n*m)<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n```\\nclass Solution\\n{\\npublic:\\n    int ans = 0;\\n    void dfs(int r, int c, vector<vector<int>> &grid, vector<vector<int>> &vis)\\n    {\\n        vis[r][c] = 1;\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        int delrow[] = {-1, 0, 1, 0};\\n        int delcol[] = {0, 1, 0, -1};\\n\\n        for (int i = 0; i < 4; i++)\\n        {\\n            int nr = r + delrow[i];\\n            int nc = c + delcol[i];\\n\\n            if ((nr < 0 or nr == n) and nc >= 0)\\n                ans++;\\n                \\n            if ((nc < 0 or nc == m) and nr >= 0)\\n                ans++;\\n\\n            if (nr >= 0 and nr < n and nc >= 0 and nc < m)\\n            {\\n                if (!grid[nr][nc])\\n                    ans++;\\n\\n                if (grid[nr][nc] and !vis[nr][nc])\\n                    dfs(nr, nc, grid, vis);\\n            }\\n        }\\n    }\\n\\n    int islandPerimeter(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (grid[i][j] and !vis[i][j])\\n                    dfs(i, j, grid, vis);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int ans = 0;\\n    void dfs(int r, int c, vector<vector<int>> &grid, vector<vector<int>> &vis)\\n    {\\n        vis[r][c] = 1;\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        int delrow[] = {-1, 0, 1, 0};\\n        int delcol[] = {0, 1, 0, -1};\\n\\n        for (int i = 0; i < 4; i++)\\n        {\\n            int nr = r + delrow[i];\\n            int nc = c + delcol[i];\\n\\n            if ((nr < 0 or nr == n) and nc >= 0)\\n                ans++;\\n                \\n            if ((nc < 0 or nc == m) and nr >= 0)\\n                ans++;\\n\\n            if (nr >= 0 and nr < n and nc >= 0 and nc < m)\\n            {\\n                if (!grid[nr][nc])\\n                    ans++;\\n\\n                if (grid[nr][nc] and !vis[nr][nc])\\n                    dfs(nr, nc, grid, vis);\\n            }\\n        }\\n    }\\n\\n    int islandPerimeter(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (grid[i][j] and !vis[i][j])\\n                    dfs(i, j, grid, vis);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940653,
                "title": "c-solution-97-73-time-84-71-space-test-land-blocks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n), n = number lines * number columns\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid);\\n};\\n/**************************************************************/\\nint Solution::islandPerimeter(vector<vector<int>>& grid) {\\n    int sizeL = grid.size(), sizeC = grid[0].size();\\n    int count = 0, i, j;\\n    for (i = 0; i < sizeL; ++i) {\\n        for (j = 0; j < sizeC; ++j) {\\n            if (grid[i][j] == 0) {\\n                continue;\\n            }\\n            /* left test */\\n            if (j == 0 || grid[i][j-1] == 0) {\\n                ++count;\\n            }\\n            /* right test */\\n            if (j == sizeC-1 || grid[i][j+1] == 0) {\\n                ++count;\\n            }\\n            /* up test */\\n            if (i == 0 || grid[i-1][j] == 0) {\\n                ++count;\\n            }\\n            /* down test */\\n            if (i == sizeL-1 || grid[i+1][j] == 0) {\\n                ++count;\\n            }\\n        }\\n    }\\n    return count;\\n}\\n/***************************************************************/\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid);\\n};\\n/**************************************************************/\\nint Solution::islandPerimeter(vector<vector<int>>& grid) {\\n    int sizeL = grid.size(), sizeC = grid[0].size();\\n    int count = 0, i, j;\\n    for (i = 0; i < sizeL; ++i) {\\n        for (j = 0; j < sizeC; ++j) {\\n            if (grid[i][j] == 0) {\\n                continue;\\n            }\\n            /* left test */\\n            if (j == 0 || grid[i][j-1] == 0) {\\n                ++count;\\n            }\\n            /* right test */\\n            if (j == sizeC-1 || grid[i][j+1] == 0) {\\n                ++count;\\n            }\\n            /* up test */\\n            if (i == 0 || grid[i-1][j] == 0) {\\n                ++count;\\n            }\\n            /* down test */\\n            if (i == sizeL-1 || grid[i+1][j] == 0) {\\n                ++count;\\n            }\\n        }\\n    }\\n    return count;\\n}\\n/***************************************************************/\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768322,
                "title": "java-2-solutions-regular-iteration-dfs",
                "content": "### **Please Upvote** :D\\n##### 1. Regular Iteration:\\n```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int perimeter = 0;\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    perimeter += 4;\\n\\n                    if (i > 0 && grid[i - 1][j] == 1) {\\n                        perimeter -= 2;\\n                    }\\n\\t\\t\\t\\t\\t\\n                    if (j > 0 && grid[i][j - 1] == 1) {\\n                        perimeter -= 2;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return perimeter;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(1)\\n```\\n\\n##### 2. Iteration with DFS:\\n```\\nclass Solution {\\n    int perimeter = 0;\\n\\n    public int islandPerimeter(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    dfs(grid, i, j);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return perimeter;\\n    }\\n\\n    public void dfs(int[][] grid, int i, int j) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {\\n            perimeter++;\\n            return;\\n        }\\n\\n        if (grid[i][j] == -1) return;\\n\\n        grid[i][j] = -1;\\n\\n        dfs(grid, i + 1, j);\\n        dfs(grid, i - 1, j);\\n        dfs(grid, i, j + 1);\\n        dfs(grid, i, j - 1);\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int perimeter = 0;\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    perimeter += 4;\\n\\n                    if (i > 0 && grid[i - 1][j] == 1) {\\n                        perimeter -= 2;\\n                    }\\n\\t\\t\\t\\t\\t\\n                    if (j > 0 && grid[i][j - 1] == 1) {\\n                        perimeter -= 2;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return perimeter;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(1)\\n```\n```\\nclass Solution {\\n    int perimeter = 0;\\n\\n    public int islandPerimeter(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    dfs(grid, i, j);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return perimeter;\\n    }\\n\\n    public void dfs(int[][] grid, int i, int j) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {\\n            perimeter++;\\n            return;\\n        }\\n\\n        if (grid[i][j] == -1) return;\\n\\n        grid[i][j] = -1;\\n\\n        dfs(grid, i + 1, j);\\n        dfs(grid, i - 1, j);\\n        dfs(grid, i, j + 1);\\n        dfs(grid, i, j - 1);\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765341,
                "title": "clear-and-easy-c-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int co = 0, n = grid.size(), m = grid[0].size();\\n        for(auto i : grid) co += count(i.begin(),i.end(),1);\\n        co = co * 4;\\n        vector<vector<bool>> check(n, vector<bool> (m,false));\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1){\\n                    \\n                    // UP\\n                    if(i-1 >= 0 and grid[i-1][j] and !check[i-1][j]){\\n                        // check[i][j] = true;\\n                        co--;\\n                    }\\n\\n                    // DOWN\\n                    if(i+1 < n and grid[i+1][j] and !check[i+1][j]){\\n                        // check[i][j] = true;\\n                        co--;\\n                    }\\n\\n                    // LEFT\\n                    if(j -1 >= 0 and grid[i][j-1] and !check[i][j-1]){\\n                        // check[i][j] = true;\\n                        co--;\\n                    }\\n\\n                    // RIGHT\\n                    if(j + 1 < m and grid[i][j+1] and !check[i][j+1]){\\n                        // check[i][j] = true;\\n                        co--;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return co;\\n    }\\n};\\n```\\n\\n<br>\\n<div> Happy coding </div>\\nPlease do upvote this post.\\n\\n![image](https://assets.leetcode.com/users/images/5ce11bf6-0db9-4239-bbb9-dfe5d76443f3_1666346629.9681695.gif)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int co = 0, n = grid.size(), m = grid[0].size();\\n        for(auto i : grid) co += count(i.begin(),i.end(),1);\\n        co = co * 4;\\n        vector<vector<bool>> check(n, vector<bool> (m,false));\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1){\\n                    \\n                    // UP\\n                    if(i-1 >= 0 and grid[i-1][j] and !check[i-1][j]){\\n                        // check[i][j] = true;\\n                        co--;\\n                    }\\n\\n                    // DOWN\\n                    if(i+1 < n and grid[i+1][j] and !check[i+1][j]){\\n                        // check[i][j] = true;\\n                        co--;\\n                    }\\n\\n                    // LEFT\\n                    if(j -1 >= 0 and grid[i][j-1] and !check[i][j-1]){\\n                        // check[i][j] = true;\\n                        co--;\\n                    }\\n\\n                    // RIGHT\\n                    if(j + 1 < m and grid[i][j+1] and !check[i][j+1]){\\n                        // check[i][j] = true;\\n                        co--;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return co;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738509,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int totalPerimeter = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) \\n\\t\\t\\t\\t\\ttotalPerimeter += perimeter(i, j, grid);\\n            }\\n        }\\n        return totalPerimeter;\\n    }\\n\\n    public int perimeter(int i, int j, int[][] grid) {\\n        int sum = 4; //if the current cell doesnt have any neighbours\\n        // decrementing sum if there is a valid neighbour around the current cell\\n        if (i - 1 >= 0 && grid[i - 1][j] == 1) sum--;\\n        if (i + 1 < grid.length && grid[i + 1][j] == 1) sum--;\\n        if (j - 1 >= 0 && grid[i][j - 1] == 1) sum--;\\n        if (j + 1 < grid[0].length && grid[i][j + 1] == 1) sum--;\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int totalPerimeter = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) \\n\\t\\t\\t\\t\\ttotalPerimeter += perimeter(i, j, grid);\\n            }\\n        }\\n        return totalPerimeter;\\n    }\\n\\n    public int perimeter(int i, int j, int[][] grid) {\\n        int sum = 4; //if the current cell doesnt have any neighbours\\n        // decrementing sum if there is a valid neighbour around the current cell\\n        if (i - 1 >= 0 && grid[i - 1][j] == 1) sum--;\\n        if (i + 1 < grid.length && grid[i + 1][j] == 1) sum--;\\n        if (j - 1 >= 0 && grid[i][j - 1] == 1) sum--;\\n        if (j + 1 < grid[0].length && grid[i][j + 1] == 1) sum--;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406149,
                "title": "c-clean-code-explained-with-comments",
                "content": "```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& grid, vector<vector<bool>> &visited, int i, int j, int row, int col, int &ans) {\\n        \\n        // checking bounds\\n        if(i >= 0 && i < row && j >= 0 && j < col && visited[i][j] == false && grid[i][j] == 1) {\\n            visited[i][j] = true; // marking visited\\n\\n            // checking for boundaries and water\\n            if(i + 1 == row || grid[i + 1][j] == 0)\\n                ++ans;\\n            if(i - 1 < 0 || grid[i - 1][j] == 0)\\n                ++ans;\\n            if(j + 1 == col || grid[i][j + 1] == 0)\\n                ++ans;\\n            if(j - 1 < 0 || grid[i][j - 1] == 0)\\n                ++ans;\\n            \\n            // checking the 4 sides\\n            dfs(grid, visited, i + 1, j, row, col, ans);\\n            dfs(grid, visited, i - 1, j, row, col, ans);\\n            dfs(grid, visited, i, j + 1, row, col, ans);\\n            dfs(grid, visited, i, j - 1, row, col, ans);\\n        }\\n    }\\n\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        vector< vector<bool> > visited (row, vector<bool> (col, false));\\n        \\n        int perimeter = 0;\\n        \\n        for(int i = 0; i < row; ++i) {\\n            for(int j = 0; j < col; ++j) {\\n                if(grid[i][j] == 1) {\\n                    dfs(grid, visited, i, j, row, col, perimeter);\\n                    break; // as there is only 1 island, it will be covered in single DFS only\\n                }\\n            }\\n        }\\n        \\n        return perimeter;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& grid, vector<vector<bool>> &visited, int i, int j, int row, int col, int &ans) {\\n        \\n        // checking bounds\\n        if(i >= 0 && i < row && j >= 0 && j < col && visited[i][j] == false && grid[i][j] == 1) {\\n            visited[i][j] = true; // marking visited\\n\\n            // checking for boundaries and water\\n            if(i + 1 == row || grid[i + 1][j] == 0)\\n                ++ans;\\n            if(i - 1 < 0 || grid[i - 1][j] == 0)\\n                ++ans;\\n            if(j + 1 == col || grid[i][j + 1] == 0)\\n                ++ans;\\n            if(j - 1 < 0 || grid[i][j - 1] == 0)\\n                ++ans;\\n            \\n            // checking the 4 sides\\n            dfs(grid, visited, i + 1, j, row, col, ans);\\n            dfs(grid, visited, i - 1, j, row, col, ans);\\n            dfs(grid, visited, i, j + 1, row, col, ans);\\n            dfs(grid, visited, i, j - 1, row, col, ans);\\n        }\\n    }\\n\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        vector< vector<bool> > visited (row, vector<bool> (col, false));\\n        \\n        int perimeter = 0;\\n        \\n        for(int i = 0; i < row; ++i) {\\n            for(int j = 0; j < col; ++j) {\\n                if(grid[i][j] == 1) {\\n                    dfs(grid, visited, i, j, row, col, perimeter);\\n                    break; // as there is only 1 island, it will be covered in single DFS only\\n                }\\n            }\\n        }\\n        \\n        return perimeter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765631,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    \\n\\t//simply count the boundaries of the land covered with water\\n\\tpublic int islandPerimeter(int[][] grid) {\\n        int perimeter = 0;\\n        \\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1){\\n                    if(i - 1 == -1 || grid[i - 1][j] == 0)\\n                        perimeter++;\\n                    if(i + 1 == grid.length || grid[i + 1][j] == 0)\\n                        perimeter++;\\n                    if(j - 1 == -1 || grid[i][j - 1] == 0)\\n                        perimeter++;\\n                    if(j + 1 == grid[0].length || grid[i][j + 1] == 0)\\n                        perimeter++;\\n                }\\n            }\\n        }\\n        \\n        return perimeter;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n\\t//simply count the boundaries of the land covered with water\\n\\tpublic int islandPerimeter(int[][] grid) {\\n        int perimeter = 0;\\n        \\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1){\\n                    if(i - 1 == -1 || grid[i - 1][j] == 0)\\n                        perimeter++;\\n                    if(i + 1 == grid.length || grid[i + 1][j] == 0)\\n                        perimeter++;\\n                    if(j - 1 == -1 || grid[i][j - 1] == 0)\\n                        perimeter++;\\n                    if(j + 1 == grid[0].length || grid[i][j + 1] == 0)\\n                        perimeter++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1690149,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n*     int islandPerimeter(vector<vector<int>>& grid) {\\n            int m = grid.size(), n = grid[0].size(), ans = 0;\\n        if(m == 0 || n == 0) return 0;\\n\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j]==1){\\n                    ans += 4;\\n                    if(i > 0 && grid[i-1][j]) ans -= 2;\\n                    if(j > 0 && grid[i][j-1]) ans -= 2;\\n                }     \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n*     int islandPerimeter(vector<vector<int>>& grid) {\\n            int m = grid.size(), n = grid[0].size(), ans = 0;\\n        if(m == 0 || n == 0) return 0;\\n\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j]==1){\\n                    ans += 4;\\n                    if(i > 0 && grid[i-1][j]) ans -= 2;\\n                    if(j > 0 && grid[i][j-1]) ans -= 2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1655746,
                "title": "python-simple-recursive-dfs-explained",
                "content": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        row = len(grid)\\n        col = len(grid[0])\\n        \\n        visited = [[0 for x in range(col)] for y in range(row)]\\n        \\n        def dfs(i, j):\\n            # we\\'re at a boundary node or a 0 node but we reached here\\n            # from a 1 node, so this \"unwanted node\" is a adjacent to one\\n            # of the wanted nodes and hence sharing the boundary (part perimeter)\\n            # add 1 to the perimeter here\\n            if i < 0 or i > row-1 or j < 0 or j > col-1 or grid[i][j] == 0:\\n                return 1\\n            \\n            # return if the current node is visited, we don\\'t need\\n            # to count that as part of our permieter calculation\\n            # if not visited, mark the current node as visited,\\n            # this is a legit node\\n            if visited[i][j]:\\n                return 0\\n            visited[i][j] = 1\\n            \\n            # now recursively check all the neighbours of the current node\\n            return dfs(i-1, j) + dfs(i+1, j) + dfs(i, j+1) + dfs(i, j-1)\\n        \\n        # loop over all elements in the\\n        # matrix and as soon as you find\\n        # a piece of land(1); begin graph\\n        # traversal and we can safely return\\n        # here since it\\'s going to traverse\\n        # the whole island and there\\'s just 1\\n        for x in range(row):\\n            for y in range(col):\\n                if grid[x][y] == 1:\\n                    return dfs(x, y)                \\n```\\n\\nSolution from [@rajiththennakoon](https://leetcode.com/problems/island-perimeter/discuss/1523841/Python-BFS-solution-without-changing-original-grid). I\\'ve just added a little more explanation and a list comprehension in line 6.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        row = len(grid)\\n        col = len(grid[0])\\n        \\n        visited = [[0 for x in range(col)] for y in range(row)]\\n        \\n        def dfs(i, j):\\n            # we\\'re at a boundary node or a 0 node but we reached here\\n            # from a 1 node, so this \"unwanted node\" is a adjacent to one\\n            # of the wanted nodes and hence sharing the boundary (part perimeter)\\n            # add 1 to the perimeter here\\n            if i < 0 or i > row-1 or j < 0 or j > col-1 or grid[i][j] == 0:\\n                return 1\\n            \\n            # return if the current node is visited, we don\\'t need\\n            # to count that as part of our permieter calculation\\n            # if not visited, mark the current node as visited,\\n            # this is a legit node\\n            if visited[i][j]:\\n                return 0\\n            visited[i][j] = 1\\n            \\n            # now recursively check all the neighbours of the current node\\n            return dfs(i-1, j) + dfs(i+1, j) + dfs(i, j+1) + dfs(i, j-1)\\n        \\n        # loop over all elements in the\\n        # matrix and as soon as you find\\n        # a piece of land(1); begin graph\\n        # traversal and we can safely return\\n        # here since it\\'s going to traverse\\n        # the whole island and there\\'s just 1\\n        for x in range(row):\\n            for y in range(col):\\n                if grid[x][y] == 1:\\n                    return dfs(x, y)                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503955,
                "title": "c-solution",
                "content": "```\\n# include <bits/stdc++.h>\\nusing namespace std;\\nclass Solution \\n{\\n    public:\\n    int DIRECTIONS[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    int sidesTouchingWater(vector<vector<int>> &grid, int x, int y)\\n    {\\n        int sides = 0;\\n        for(auto dir: DIRECTIONS)\\n        {\\n                int newX = x + dir[0], newY = y + dir[1];\\n                if(newX < 0 || newY < 0 || newX >= grid.size() || newY >= grid[0].size() || grid[newX][newY] == 0) \\n                    sides++;   \\n        }\\n        return sides;\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) \\n    {\\n        int N = grid.size(), M = grid[0].size();\\n        int res = 0;\\n        for(int i = 0; i < N; i++)\\n        {\\n                for(int j = 0; j < M; j++)\\n                {\\n                        if(grid[i][j] == 1)\\n                        {\\n                                res += sidesTouchingWater(grid, i, j);\\n                        }\\n                }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n# include <bits/stdc++.h>\\nusing namespace std;\\nclass Solution \\n{\\n    public:\\n    int DIRECTIONS[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    int sidesTouchingWater(vector<vector<int>> &grid, int x, int y)\\n    {\\n        int sides = 0;\\n        for(auto dir: DIRECTIONS)\\n        {\\n                int newX = x + dir[0], newY = y + dir[1];\\n                if(newX < 0 || newY < 0 || newX >= grid.size() || newY >= grid[0].size() || grid[newX][newY] == 0) \\n                    sides++;   \\n        }\\n        return sides;\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) \\n    {\\n        int N = grid.size(), M = grid[0].size();\\n        int res = 0;\\n        for(int i = 0; i < N; i++)\\n        {\\n                for(int j = 0; j < M; j++)\\n                {\\n                        if(grid[i][j] == 1)\\n                        {\\n                                res += sidesTouchingWater(grid, i, j);\\n                        }\\n                }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502048,
                "title": "python3-simple-iteration-no-bfs-dfs-annotated-code",
                "content": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        ans = 0\\n        \\n        for x in range(m):\\n            for y in range(n):\\n                if not grid[x][y]: continue # if 0, skip\\n\\t\\t\\t\\t# now we are looking at a land cell\\n                ans += 4 \\n\\t\\t\\t\\t# the below removes 1 for every land cell in neighbourhood\\n                if x > 0 and grid[x-1][y]: ans -= 1\\n                if x < m-1 and grid[x+1][y]: ans -= 1\\n                if y > 0 and grid[x][y-1]: ans -= 1\\n                if y < n-1 and grid[x][y+1]: ans -= 1\\n                    \\n        return ans\\n```\\n\\nUpvote if you like this :D",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        ans = 0\\n        \\n        for x in range(m):\\n            for y in range(n):\\n                if not grid[x][y]: continue # if 0, skip\\n\\t\\t\\t\\t# now we are looking at a land cell\\n                ans += 4 \\n\\t\\t\\t\\t# the below removes 1 for every land cell in neighbourhood\\n                if x > 0 and grid[x-1][y]: ans -= 1\\n                if x < m-1 and grid[x+1][y]: ans -= 1\\n                if y > 0 and grid[x][y-1]: ans -= 1\\n                if y < n-1 and grid[x][y+1]: ans -= 1\\n                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370204,
                "title": "java-dfs-solution",
                "content": "```\\n\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    return dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return 4;\\n\\n    }\\n\\n    private int dfs(int[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] == 0) return 1;\\n\\n        if (grid[i][j] == -1) return 0;\\n        grid[i][j] = -1;\\n        int l = dfs(grid, i, j - 1);\\n        int r = dfs(grid, i, j + 1);\\n        int t = dfs(grid, i - 1, j);\\n        int d = dfs(grid, i + 1, j);\\n\\n        return l + r + t + d;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    return dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return 4;\\n\\n    }\\n\\n    private int dfs(int[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] == 0) return 1;\\n\\n        if (grid[i][j] == -1) return 0;\\n        grid[i][j] = -1;\\n        int l = dfs(grid, i, j - 1);\\n        int r = dfs(grid, i, j + 1);\\n        int t = dfs(grid, i - 1, j);\\n        int d = dfs(grid, i + 1, j);\\n\\n        return l + r + t + d;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315218,
                "title": "javascript-clean-and-easy-solution",
                "content": "**Please upvote if you find this solution useful**\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar islandPerimeter = function(grid) {\\n    let row = grid.length;\\n    let col = grid[0].length;\\n    let dirs = [ [-1,0], [0,-1], [1,0], [0,1] ];\\n    let perimeter = 0;\\n    for(let i=0; i<row; i++){\\n        for(let j=0; j<col; j++){\\n            if(grid[i][j] == 1){\\n                findPerimeter(i, j)\\n            }\\n        }\\n    }\\n    return perimeter\\n    function findPerimeter(i,j){\\n        if(i < 0 || i>row-1 || j<0 || j>col-1 || grid[i][j] == 0 ){\\n            perimeter++\\n            return;\\n        }\\n        if(grid[i][j] == 2)return;\\n        \\n        grid[i][j] = 2;\\n        for(let dir of dirs){\\n            findPerimeter(i+ dir[0] , j + dir[1]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar islandPerimeter = function(grid) {\\n    let row = grid.length;\\n    let col = grid[0].length;\\n    let dirs = [ [-1,0], [0,-1], [1,0], [0,1] ];\\n    let perimeter = 0;\\n    for(let i=0; i<row; i++){\\n        for(let j=0; j<col; j++){\\n            if(grid[i][j] == 1){\\n                findPerimeter(i, j)\\n            }\\n        }\\n    }\\n    return perimeter\\n    function findPerimeter(i,j){\\n        if(i < 0 || i>row-1 || j<0 || j>col-1 || grid[i][j] == 0 ){\\n            perimeter++\\n            return;\\n        }\\n        if(grid[i][j] == 2)return;\\n        \\n        grid[i][j] = 2;\\n        for(let dir of dirs){\\n            findPerimeter(i+ dir[0] , j + dir[1]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 969792,
                "title": "python-3-short-solution-do-not-check-neighbors",
                "content": "* For a row, turn it into a string, `[1,1,0,1]` to `\\'1101\\'`. Find how many `1` series in it. In this case, `\\'11\\'` and `\\'1\\'`. Each piece adds `2` edges to the perimeter. Same with the vertical direction.\\n\\n```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        #\\n        res = 0\\n        for i in grid:\\n            string = \\'\\'.join(str(e) for e in i)\\n            res += sum(2 for ones in string.split(\\'0\\') if ones != \\'\\')\\n        for i in zip(*grid):\\n            string = \\'\\'.join(str(e) for e in i)\\n            res += sum(2 for ones in string.split(\\'0\\') if ones != \\'\\')\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        #\\n        res = 0\\n        for i in grid:\\n            string = \\'\\'.join(str(e) for e in i)\\n            res += sum(2 for ones in string.split(\\'0\\') if ones != \\'\\')\\n        for i in zip(*grid):\\n            string = \\'\\'.join(str(e) for e in i)\\n            res += sum(2 for ones in string.split(\\'0\\') if ones != \\'\\')\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953660,
                "title": "very-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        \\n        op = 0\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    for x,y in [(0,1),(1,0),(-1,0),(0,-1)]:\\n                        dx = i + x\\n                        dy = j + y\\n                        # print(dx,dy)\\n                        if dx >= m or dy >= n or dx < 0 or dy < 0 or grid[dx][dy] == 0:\\n                            op += 1\\n                            \\n        return op\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        \\n        op = 0\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    for x,y in [(0,1),(1,0),(-1,0),(0,-1)]:\\n                        dx = i + x\\n                        dy = j + y\\n                        # print(dx,dy)\\n                        if dx >= m or dy >= n or dx < 0 or dy < 0 or grid[dx][dy] == 0:\\n                            op += 1\\n                            \\n        return op\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724519,
                "title": "clear-and-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==1){\\n                    count+=4;\\n                    if(i>0 && grid[i-1][j]==1)\\n                        count-=2;\\n                    if(j>0 && grid[i][j-1]==1)\\n                        count-=2;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==1){\\n                    count+=4;\\n                    if(i>0 && grid[i-1][j]==1)\\n                        count-=2;\\n                    if(j>0 && grid[i][j-1]==1)\\n                        count-=2;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723908,
                "title": "c-simple-solution-explained-no-bfs-no-dfs-or-other-graph-theory-tricks",
                "content": "So, basically I scan the whole map only once with a nested loop.\\n\\nIf the cell is land (`1`), I check if it is at the border of the map, and I add to my counter variable `res` how many borders do we actually with the map.\\n\\nIf it is sea (`0`), I cound how many adjacent cells are land and add it to `res` again.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        // storing max coordinates with -1 will prevent me from having to do the same over and over again\\n        int maxX = grid[0].size() - 1, maxY = grid.size() - 1, res = 0;\\n        for (int y = 0; y <= maxY; y++) {\\n            for (int x = 0; x <= maxX; x++) {\\n                // counting borders with grid limit\\n                if (grid[y][x] == 1) res += !x + !y + (maxX == x) + (maxY == y);\\n                // counting borders around mapped sea (goind left, up, right and down respectively)\\n                else res += (x && grid[y][x - 1]) + (y && grid[y - 1][x]) + (x < maxX && grid[y][x + 1]) + (y < maxY && grid[y + 1][x]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        // storing max coordinates with -1 will prevent me from having to do the same over and over again\\n        int maxX = grid[0].size() - 1, maxY = grid.size() - 1, res = 0;\\n        for (int y = 0; y <= maxY; y++) {\\n            for (int x = 0; x <= maxX; x++) {\\n                // counting borders with grid limit\\n                if (grid[y][x] == 1) res += !x + !y + (maxX == x) + (maxY == y);\\n                // counting borders around mapped sea (goind left, up, right and down respectively)\\n                else res += (x && grid[y][x - 1]) + (y && grid[y - 1][x]) + (x < maxX && grid[y][x + 1]) + (y < maxY && grid[y + 1][x]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500075,
                "title": "js-easy-understand-solution-98-61-speed",
                "content": "\\n\\n```\\nvar islandPerimeter = function(grid) {\\n    let per = 0;\\n    \\n    for (let i = 0; i < grid.length; i++ ){\\n        for(let j = 0; j < grid[i].length; j++){\\n            if (grid[i][j] == 1) per = per + check_all(i,j,grid)\\n        }\\n    }\\n    return per\\n};\\n\\nfunction check_up(i,j,grid){\\n    if (i == 0) return 1\\n    else return (grid[i-1][j] - 1) ** 2\\n}\\n\\nfunction check_left(i,j,grid){\\n    if (j == 0) return 1\\n    else return (grid[i][j-1] - 1) ** 2\\n}\\nfunction check_right(i,j,grid){\\n    if (j == grid[0].length - 1) return 1\\n    else return (grid[i][j+1] - 1) ** 2\\n}\\nfunction check_down(i,j,grid){\\n    if (i == grid.length - 1) return 1\\n    else return (grid[i+1][j] - 1) ** 2\\n}\\n\\nfunction check_all(i,j,grid){\\n    return check_up(i,j,grid) + check_left(i,j,grid) + check_right(i,j,grid) + check_down(i,j,grid)\\n    \\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n```\\nvar islandPerimeter = function(grid) {\\n    let per = 0;\\n    \\n    for (let i = 0; i < grid.length; i++ ){\\n        for(let j = 0; j < grid[i].length; j++){\\n            if (grid[i][j] == 1) per = per + check_all(i,j,grid)\\n        }\\n    }\\n    return per\\n};\\n\\nfunction check_up(i,j,grid){\\n    if (i == 0) return 1\\n    else return (grid[i-1][j] - 1) ** 2\\n}\\n\\nfunction check_left(i,j,grid){\\n    if (j == 0) return 1\\n    else return (grid[i][j-1] - 1) ** 2\\n}\\nfunction check_right(i,j,grid){\\n    if (j == grid[0].length - 1) return 1\\n    else return (grid[i][j+1] - 1) ** 2\\n}\\nfunction check_down(i,j,grid){\\n    if (i == grid.length - 1) return 1\\n    else return (grid[i+1][j] - 1) ** 2\\n}\\n\\nfunction check_all(i,j,grid){\\n    return check_up(i,j,grid) + check_left(i,j,grid) + check_right(i,j,grid) + check_down(i,j,grid)\\n    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 379904,
                "title": "clear-python-solution",
                "content": "```python\\nclass Solution:\\n    #Number of cells which are arround of g[i][j] and are inside of island\\n    def one_surround(self, g, i, j): \\n        ans = 0\\n        n = len(g)\\n        m = len(g[0])\\n        \\n        if j > 0 and g[i][j-1] == 1:ans += 1\\n        if i > 0 and g[i-1][j] == 1:ans += 1\\n        if j < m-1 and g[i][j+1] == 1:ans += 1    \\n        if i < n-1 and g[i+1][j] == 1:ans += 1\\n        \\n        return ans\\n        \\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    ans += 4-self.one_surround(grid, i, j)\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    #Number of cells which are arround of g[i][j] and are inside of island\\n    def one_surround(self, g, i, j): \\n        ans = 0\\n        n = len(g)\\n        m = len(g[0])\\n        \\n        if j > 0 and g[i][j-1] == 1:ans += 1\\n        if i > 0 and g[i-1][j] == 1:ans += 1\\n        if j < m-1 and g[i][j+1] == 1:ans += 1    \\n        if i < n-1 and g[i+1][j] == 1:ans += 1\\n        \\n        return ans\\n        \\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    ans += 4-self.one_surround(grid, i, j)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132944,
                "title": "swift",
                "content": "My main goal here was that it be readable.\\n```\\n    func islandPerimeter(_ grid: [[Int]]) -> Int {\\n        var perimeter = 0\\n        for (row, rows) in grid.enumerated() {\\n            for (cell, cellVal) in rows.enumerated() where cellVal == 1 {\\n                \\n                // top\\n                if row == 0 { perimeter += 1 }\\n                else if grid[row - 1][cell] == 0 { perimeter += 1 }\\n\\n                // bottom\\n                if row == grid.count - 1 { perimeter += 1 }\\n                else if grid[row + 1][cell] == 0 { perimeter += 1 }\\n\\n                // left\\n                if cell == 0 { perimeter += 1 }\\n                else if grid[row][cell - 1] == 0 { perimeter += 1 }\\n\\n                // right\\n                if cell == rows.count - 1 { perimeter += 1 }\\n                else if grid[row][cell + 1] == 0 { perimeter += 1 }\\n            }\\n        }\\n        return perimeter\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    func islandPerimeter(_ grid: [[Int]]) -> Int {\\n        var perimeter = 0\\n        for (row, rows) in grid.enumerated() {\\n            for (cell, cellVal) in rows.enumerated() where cellVal == 1 {\\n                \\n                // top\\n                if row == 0 { perimeter += 1 }\\n                else if grid[row - 1][cell] == 0 { perimeter += 1 }\\n\\n                // bottom\\n                if row == grid.count - 1 { perimeter += 1 }\\n                else if grid[row + 1][cell] == 0 { perimeter += 1 }\\n\\n                // left\\n                if cell == 0 { perimeter += 1 }\\n                else if grid[row][cell - 1] == 0 { perimeter += 1 }\\n\\n                // right\\n                if cell == rows.count - 1 { perimeter += 1 }\\n                else if grid[row][cell + 1] == 0 { perimeter += 1 }\\n            }\\n        }\\n        return perimeter\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95044,
                "title": "clear-and-easy-javascript-solution-beat-98",
                "content": "For each land cell, its diameter is determined by the number of land cell neighbors it has. \\n\\ndiameter = 4 - num of adjacent neighbors\\n\\nSo the solution is very straightforward which is to traverse the entire grid and calculate the total diameter using this approach.  \\n\\nEfficiency: O(n*m)\\n\\n```\\nvar islandPerimeter = function(grid) {\\n    var diameter = 0;\\n    if(!grid || grid.length == 0) return 0;\\n    for(var m = 0; m < grid.length; m++){\\n        for(var n = 0; n < grid[m].length; n++){\\n            if(grid[m][n] == 1){\\n                var left = n-1 < 0 ? 0 : grid[m][n-1];\\n                var right = n + 1 >= grid[m].length ? 0 : grid[m][n+1];\\n                var top = m - 1 < 0 ? 0 : grid[m-1][n];\\n                var down = m + 1 >= grid.length ? 0 : grid[m+1][n];\\n                var numOfAdj = right + left+top+down;\\n                diameter += 4 - numOfAdj;\\n            }\\n            \\n        }\\n    }\\n    return diameter;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar islandPerimeter = function(grid) {\\n    var diameter = 0;\\n    if(!grid || grid.length == 0) return 0;\\n    for(var m = 0; m < grid.length; m++){\\n        for(var n = 0; n < grid[m].length; n++){\\n            if(grid[m][n] == 1){\\n                var left = n-1 < 0 ? 0 : grid[m][n-1];\\n                var right = n + 1 >= grid[m].length ? 0 : grid[m][n+1];\\n                var top = m - 1 < 0 ? 0 : grid[m-1][n];\\n                var down = m + 1 >= grid.length ? 0 : grid[m+1][n];\\n                var numOfAdj = right + left+top+down;\\n                diameter += 4 - numOfAdj;\\n            }\\n            \\n        }\\n    }\\n    return diameter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3607812,
                "title": "simple-solution-with-98-accuracy",
                "content": "# Intuition\\nThe problem statement provides the following information:\\n\\n    The grid represents a map where each cell can be either land (1) or water (0).\\n    The cells in the grid are connected horizontally or vertically, but not diagonally.\\n    The grid is completely surrounded by water.\\n    There is exactly one island, which means there is at least one land cell and all land cells are connected.\\n    The island doesn\\'t have any \"lakes,\" meaning there are no enclosed bodies of water within the island.\\n    Each cell represents a square with a side length of 1.\\nThe dimensions of the grid (row and column) don\\'t exceed 100.\\n# Approach\\nMY approach to solving the problem is correct. The code I provided implements the logic to calculate the perimeter of the island based on the given grid representation.\\nThe code iterates over each cell in the grid and checks if it represents land (1). If a land cell is found, the perimeter is incremented by 4, representing the four sides of the square cell.\\nThen, it checks if there is a neighboring land cell to the left or above the current cell. If such a neighbor exists, it means there is an adjacent land cell, and the perimeter is decremented by 2, as one side of the current cell is shared with the neighboring cell.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        perimeter = 0\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    perimeter += 4\\n                    if i != 0 and grid[i-1][j] == 1:\\n                        perimeter -= 2\\n                    if j != 0 and grid[i][j-1] == 1:\\n                        perimeter -= 2 \\n            \\n        return perimeter\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        perimeter = 0\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    perimeter += 4\\n                    if i != 0 and grid[i-1][j] == 1:\\n                        perimeter -= 2\\n                    if j != 0 and grid[i][j-1] == 1:\\n                        perimeter -= 2 \\n            \\n        return perimeter\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059046,
                "title": "easy-and-intutive-c-dfs-solution",
                "content": "So this problem is pretty similar to that of flood fill problem. You will add +1 to your ans whenever there will be \\'0\\' or water when you traverse from any node which is \"1\".\\n```\\nclass Solution\\n{\\n\\n    int dfs(int i, int j, vector<vector < int>> &grid, vector< vector< bool>> &vis)\\n    {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        if (i < 0 || j < 0 || i >= row || j >= col) return 1;\\n        \\n        if (vis[i][j]) return 0;\\n        if (grid[i][j] == 0) return 1;\\n\\n        vis[i][j] = true;\\n\\n        int ans = dfs(i + 1, j, grid, vis) +\\n            dfs(i - 1, j, grid, vis) +\\n            dfs(i, j - 1, grid, vis) +\\n            dfs(i, j + 1, grid, vis);\\n        return ans;\\n    }\\n\\n    public:\\n        int islandPerimeter(vector<vector < int>> &grid)\\n        {\\n            int ans = 0;\\n            int row = grid.size();\\n            int col = grid[0].size();\\n            vector<vector < bool>> vis(row, vector<bool> (col, false));\\n\\n            for (int i = 0; i < row; i++)\\n            {\\n                for (int j = 0; j < col; j++)\\n                {\\n                    if (grid[i][j] and !vis[i][j])\\n                    {\\n                        ans += dfs(i, j, grid, vis);\\n                    }\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n    int dfs(int i, int j, vector<vector < int>> &grid, vector< vector< bool>> &vis)\\n    {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        if (i < 0 || j < 0 || i >= row || j >= col) return 1;\\n        \\n        if (vis[i][j]) return 0;\\n        if (grid[i][j] == 0) return 1;\\n\\n        vis[i][j] = true;\\n\\n        int ans = dfs(i + 1, j, grid, vis) +\\n            dfs(i - 1, j, grid, vis) +\\n            dfs(i, j - 1, grid, vis) +\\n            dfs(i, j + 1, grid, vis);\\n        return ans;\\n    }\\n\\n    public:\\n        int islandPerimeter(vector<vector < int>> &grid)\\n        {\\n            int ans = 0;\\n            int row = grid.size();\\n            int col = grid[0].size();\\n            vector<vector < bool>> vis(row, vector<bool> (col, false));\\n\\n            for (int i = 0; i < row; i++)\\n            {\\n                for (int j = 0; j < col; j++)\\n                {\\n                    if (grid[i][j] and !vis[i][j])\\n                    {\\n                        ans += dfs(i, j, grid, vis);\\n                    }\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919397,
                "title": "fastest-cleanest-js-solution-beats-100-o-n2",
                "content": "# Intuition\\nAt given index look all direction and see if there is sea or not\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar islandPerimeter = function(grid) {\\n    let count = 0\\n    const lookLeft = (i,j) => {\\n        if(j===0) return true\\n        return !grid[i][j-1]\\n    }\\n\\n    const lookUp = (i,j) => {\\n        if(i===0) return true\\n        return !grid[i-1][j]\\n    }\\n\\n    const lookRight= (i,j) => {\\n        if(j===grid[i].length - 1) return true\\n        return !grid[i][j+1]\\n    }\\n\\n    const lookBottom= (i,j) => {\\n        if(i===grid.length - 1) return true\\n        return !grid[i+1][j]\\n    }\\n\\n    for(let i=0; i<grid.length; i++){\\n        for(let j=0; j<grid[i].length; j++) {\\n            if(grid[i][j]) {\\n                //look left\\n                lookLeft(i,j) && count++\\n                //look up\\n                lookUp(i,j) && count++\\n                //look right\\n                lookRight(i,j) && count++\\n                //look bottom\\n                lookBottom(i,j) && count++\\n            }\\n            \\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar islandPerimeter = function(grid) {\\n    let count = 0\\n    const lookLeft = (i,j) => {\\n        if(j===0) return true\\n        return !grid[i][j-1]\\n    }\\n\\n    const lookUp = (i,j) => {\\n        if(i===0) return true\\n        return !grid[i-1][j]\\n    }\\n\\n    const lookRight= (i,j) => {\\n        if(j===grid[i].length - 1) return true\\n        return !grid[i][j+1]\\n    }\\n\\n    const lookBottom= (i,j) => {\\n        if(i===grid.length - 1) return true\\n        return !grid[i+1][j]\\n    }\\n\\n    for(let i=0; i<grid.length; i++){\\n        for(let j=0; j<grid[i].length; j++) {\\n            if(grid[i][j]) {\\n                //look left\\n                lookLeft(i,j) && count++\\n                //look up\\n                lookUp(i,j) && count++\\n                //look right\\n                lookRight(i,j) && count++\\n                //look bottom\\n                lookBottom(i,j) && count++\\n            }\\n            \\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2829609,
                "title": "java-simple-dfs-clean-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    return dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private static int dfs (int[][] grid, int row, int col) {\\n        if (row >= grid.length || col >= grid[0].length || row < 0 || col < 0 || grid[row][col] == 0) {\\n            return 1;\\n        }\\n        if (grid[row][col] == -1) {\\n            return 0;\\n        }\\n        grid[row][col] = -1;\\n\\n        return dfs(grid, row + 1, col) + dfs(grid, row, col + 1) + dfs(grid, row - 1, col) + dfs(grid, row, col - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    return dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private static int dfs (int[][] grid, int row, int col) {\\n        if (row >= grid.length || col >= grid[0].length || row < 0 || col < 0 || grid[row][col] == 0) {\\n            return 1;\\n        }\\n        if (grid[row][col] == -1) {\\n            return 0;\\n        }\\n        grid[row][col] = -1;\\n\\n        return dfs(grid, row + 1, col) + dfs(grid, row, col + 1) + dfs(grid, row - 1, col) + dfs(grid, row, col - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819912,
                "title": "straightforward-solution-with-detail-explanation",
                "content": "public class Solution {\\n    \\n    // Define the four neighbors\\n    static int[][] neighbors = new int[][] { new int[] {-1, 0}, new int[] {1, 0},\\n                                        new int[] {0, -1}, new int[] {0, 1}};\\n    \\n    public int IslandPerimeter(int[][] grid) \\n    {\\n        int rCount = grid.Length;\\n        int cCount = grid[0].Length;\\n        \\n        int perimeter = 0;\\n        \\n        // Iterate over the grid cell by cell \\n        for(int r = 0; r < rCount; r++)\\n        {\\n            for(int c = 0; c < cCount; c++)\\n            {\\n                // Calculate the perimeter only for the island cell \\n                if(grid[r][c] == 1)\\n                {\\n                    // Each cell has four sides - maximum of 4 for perimeter\\n                    // Decrease by one for any neighbor which is island cell  \\n                    int curP = 4;\\n                    foreach(var neighbor in neighbors)\\n                    {\\n                        if((r + neighbor[0] >= 0) && (r + neighbor[0] < rCount) \\n                          &&(c + neighbor[1] >= 0) && (c + neighbor[1] < cCount))\\n                        {\\n                            if(grid[r + neighbor[0]][c + neighbor[1]] == 1)\\n                            {\\n                                curP--;\\n                            }\\n                        }\\n                    }\\n                    perimeter += curP;\\n                }\\n            }\\n        }\\n        return perimeter;        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    // Define the four neighbors\\n    static int[][] neighbors = new int[][] { new int[] {-1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 2440595,
                "title": "clear-and-easy-java-solution",
                "content": "public int islandPerimeter(int[][] grid) {\\n        int p=0;\\n        int r =grid.length;\\n        int c =grid[0].length;\\n        \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(grid[i][j] ==1){\\n                    p+=4;\\n                    if(i>0 && grid[i-1][j]==1){\\n                        p-=2;\\n                    }\\n\\n                    if(j>0 && grid[i][j-1]==1){\\n                        p-=2;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return p;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int islandPerimeter(int[][] grid) {\\n        int p=0;\\n        int r =grid.length;\\n        int c =grid[0].length;\\n        \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(grid[i][j] ==1){\\n                    p+=4;\\n                    if(i>0 && grid[i-1][j]==1){\\n                        p-=2;\\n                    }\\n\\n                    if(j>0 && grid[i][j-1]==1){\\n                        p-=2;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return p;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1503338,
                "title": "3-python-solutions-dfs-bfs-and-iterative-with-space-and-time-complexity-analysis",
                "content": "This problem is failry easy to solve, which is why it could be solved using three main methods:\\n* **D**epth **F**irst **S**earch (DFS)\\n* **B**readth **F**irst **S**earch (BFS)\\n* Iterative\\n\\n# Iterative\\nThe first method we will look into is the iterative one. The idea is to traverse the matrix, and when we find a one, we search for all its neighbors, and if any of those neighbors are 1s we subtract the number of 1s from 4 and add that to the perimeter variable.\\n\\nFor example:\\n```\\n[\\n\\t[0, 0, 1, 1],\\n\\t[0, 0, 1, 1],\\n\\t[1 ,1, 1 ,0]\\n]\\n```\\nSo for the first row, we find a one at index 2, so we search its neighbors, up, down, left, right. we find that the one below it and to its right are ones so 4 - 2 = 2, so we add 2 to the perimeter, and so on to the end.\\n\\n*Space and time complexity analysis:*\\n* **Time:** O(n * 4) (Worst case) where n is the size of the matrix and 4 because we search in four directions whenever we find a one. \\n* **Space:** O(1) since we are only using a fixed number of variables for all testcases.\\n\\n**Code**\\n825 ms, 14.6 MB\\n```\\ndef IslanPerimeter(grid):\\n    perimeter = 0\\n    dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]\\n    for i in range(len(grid)):\\n        for j in range(len(grid[i])):\\n            if grid[i][j] == 1:\\n                perimeter += 4\\n                for dir in dirs:\\n                    ni, nj = i + dir[0], j + dir[1]\\n                    if 0 <= ni < len(grid) and 0 <= nj < len(grid[i]):\\n                        if grid[ni][nj] == 1:\\n                            perimeter -= 1\\n    return perimeter\\n\\t\\n\\n```\\n# BFS\\nThe second method is BFS, which is obviously less efficient in this particular problem but is good practice nonetheless. The idea is exactly like your typical BFS code with the difference of checking for neighbors whenever we find a one.\\n\\n\\n*Space and time complexity analysis:*\\n* **Time:** O(4 * V + E)  where V is the height of the matrix and E is its width. , since we looke in four different directions whenever we find a one.\\n* **Space:** O(1) since we are only using a fixed number of variables for all testcases.\\n\\n**Code**\\n1392 ms, 15.7 MB\\n```\\ndef IslandPerimeterBFS(grid):\\n    visited = set()\\n    visited.add((0, 0))\\n    q = [[0, 0]]\\n    perimeter = 0\\n    dirs = [[0, 1], [1, 0], [-1, 0],[0, -1]]\\n    while q:\\n        i, j = q.pop(0)\\n        if grid[i][j] == 1:\\n            perimeter += 4\\n            for dir in dirs:\\n                ni, nj = i + dir[0], j + dir[1]\\n                if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]):\\n                    if grid[ni][nj] == 1:\\n                        perimeter -= 1\\n        for dir in dirs:\\n            ni, nj = i + dir[0], j + dir[1]\\n            if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (ni, nj) not in visited:\\n                visited.add((ni, nj))\\n                q.append([ni, nj])\\n    return perimeter\\n```\\n# DFS\\nThe third and final method is DFS, which is again less efficient than the iteritave solution but it is also good practice. Again its the same as your typical DFS but with an extra loop for searching for neighbors.\\n\\n*Space and time complexity analysis:*\\n* **Time:** O(4 * V * E)  where V is the height of the matrix and E is its width. , since we looke in four different directions whenever we find a one.\\n* **Space:** O(1) since we are only using a fixed number of variables for all testcases.\\n\\n**Code**\\n1285 ms, 32 MB\\n```\\ndef IslandPerimeterDFS(grid):\\n    visited = set()\\n    visited.add((0, 0))\\n    dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]\\n    def dfs(i, j, perimeter):\\n        if grid[i][j] == 1:\\n            perimeter += 4\\n            for dir in dirs:\\n                ni, nj = i + dir[0], j + dir[1]\\n                if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]):\\n                    if grid[ni][nj] == 1:\\n                        perimeter -= 1\\n        for dir in dirs:\\n            ni, nj = i + dir[0], j + dir[1]\\n            if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (ni, nj) not in visited:\\n                visited.add((ni, nj))\\n                return dfs(ni, nj, perimeter)\\n        return perimeter\\n    return dfs(0, 0, 0)\\n```\\n*If you found this post helpful, please consider upvoting, thanks!*\\n",
                "solutionTags": [],
                "code": "```\\n[\\n\\t[0, 0, 1, 1],\\n\\t[0, 0, 1, 1],\\n\\t[1 ,1, 1 ,0]\\n]\\n```\n```\\ndef IslanPerimeter(grid):\\n    perimeter = 0\\n    dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]\\n    for i in range(len(grid)):\\n        for j in range(len(grid[i])):\\n            if grid[i][j] == 1:\\n                perimeter += 4\\n                for dir in dirs:\\n                    ni, nj = i + dir[0], j + dir[1]\\n                    if 0 <= ni < len(grid) and 0 <= nj < len(grid[i]):\\n                        if grid[ni][nj] == 1:\\n                            perimeter -= 1\\n    return perimeter\\n\\t\\n\\n```\n```\\ndef IslandPerimeterBFS(grid):\\n    visited = set()\\n    visited.add((0, 0))\\n    q = [[0, 0]]\\n    perimeter = 0\\n    dirs = [[0, 1], [1, 0], [-1, 0],[0, -1]]\\n    while q:\\n        i, j = q.pop(0)\\n        if grid[i][j] == 1:\\n            perimeter += 4\\n            for dir in dirs:\\n                ni, nj = i + dir[0], j + dir[1]\\n                if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]):\\n                    if grid[ni][nj] == 1:\\n                        perimeter -= 1\\n        for dir in dirs:\\n            ni, nj = i + dir[0], j + dir[1]\\n            if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (ni, nj) not in visited:\\n                visited.add((ni, nj))\\n                q.append([ni, nj])\\n    return perimeter\\n```\n```\\ndef IslandPerimeterDFS(grid):\\n    visited = set()\\n    visited.add((0, 0))\\n    dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]\\n    def dfs(i, j, perimeter):\\n        if grid[i][j] == 1:\\n            perimeter += 4\\n            for dir in dirs:\\n                ni, nj = i + dir[0], j + dir[1]\\n                if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]):\\n                    if grid[ni][nj] == 1:\\n                        perimeter -= 1\\n        for dir in dirs:\\n            ni, nj = i + dir[0], j + dir[1]\\n            if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (ni, nj) not in visited:\\n                visited.add((ni, nj))\\n                return dfs(ni, nj, perimeter)\\n        return perimeter\\n    return dfs(0, 0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1285763,
                "title": "java-detailed-explanation-2-approaches-simple-intuitive-approach-and-dfs-approach",
                "content": "**Do vote up if you like it :)**\\n\\nSolution Type 1 : Simple intuitive approach\\n\\nThe idea is count all the ones, and multiply by 4, so we get total perimeter including all the boxes separatly.\\nFor the given example,\\nWe have 7 ones, so 7 * 4 = 28, but here we have to neglect all the connected sides (2 edges, birectional connection) of the square with another square. \\nSo, if for (0, 1) cell we find all the neighbours (which is 1), so here we find the cell (1, 1) is the only neighbour of cell (0, 1).\\nSo if we subtract 1 from the total Perimeter we have successfully removed a connected edge from 0 -> 1 row for 1st column, now 1 -> 0 for 1st column connection is still left to break (inorder to neglect the common edge).\\nSo, when we count neighbour of (1, 1) we find 4 neighbours (since 4 ones are connected to that (1,1) cell, so when we solve for (1,1) another edge from 1-> 0 row of 1st column will  be removed. Also, at cell (1,1) 4 edges will be removed for all its direction, because there are 4 neighbours of (1,1) cell.\\nSimilarly, for the rest.\\n\\nSo, 28(total permeter) - 12(total neighbours of each 1\\'s cell) = 16 Ans\\n\\n```\\nclass Solution {\\n    \\n    public int islandPerimeter(int[][] grid) {\\n        \\n        int onesCount = 0;\\n        int neighCount = 0;\\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1){\\n                    onesCount++;\\n                    \\n                    for(int d = 0; d < dir.length; d++) {\\n                        int x = i + dir[d][0];\\n                        int y = j + dir[d][1];\\n                        if(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 1)\\n                            neighCount++;\\n                    }\\n                }\\n            }\\n        }\\n        return 4 * onesCount - neighCount;\\n    }\\n    \\n}\\n```\\n------------------------------------------------------------\\nSolution Type 2 : a) Using dfs with Direction matrix\\n\\n```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        \\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1){\\n                    return dfs(grid, i, j, dir);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    public static int dfs(int[][] grid, int i, int j, int[][] dir){\\n        if(i<0 || i>= grid.length || j<0 || j>= grid[0].length || grid[i][j] == 0)\\n            return 1;\\n        if(grid[i][j] == -1)\\n            return 0;\\n\\n        int result = 0;\\n        grid[i][j] = -1;\\n        for(int d = 0; d < dir.length; d++){\\n            result += dfs(grid, i + dir[d][0], j + dir[d][1], dir);\\n        }\\n        return result;\\n    }\\n}\\n```\\n-----------------------------------------------------\\nSolution Type 2 : b) Using dfs without direction matrix\\n\\n```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 1){\\n                    return dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    public static int dfs(int[][] grid, int i, int j){\\n        if(i<0 || i>= grid.length || j<0 || j>= grid[0].length || grid[i][j] == 0)\\n            return 1;\\n        if(grid[i][j] == -1)\\n            return 0;\\n\\n        grid[i][j] = -1;\\n        int result = 0;\\n        result += dfs(grid, i-1, j);\\n        result += dfs(grid, i, j+1);\\n        result += dfs(grid, i+1, j);\\n        result += dfs(grid, i, j-1);\\n        return result;\\n    }\\n}\\n```\\n----------------------------------------------------\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int islandPerimeter(int[][] grid) {\\n        \\n        int onesCount = 0;\\n        int neighCount = 0;\\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1){\\n                    onesCount++;\\n                    \\n                    for(int d = 0; d < dir.length; d++) {\\n                        int x = i + dir[d][0];\\n                        int y = j + dir[d][1];\\n                        if(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 1)\\n                            neighCount++;\\n                    }\\n                }\\n            }\\n        }\\n        return 4 * onesCount - neighCount;\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        \\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1){\\n                    return dfs(grid, i, j, dir);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    public static int dfs(int[][] grid, int i, int j, int[][] dir){\\n        if(i<0 || i>= grid.length || j<0 || j>= grid[0].length || grid[i][j] == 0)\\n            return 1;\\n        if(grid[i][j] == -1)\\n            return 0;\\n\\n        int result = 0;\\n        grid[i][j] = -1;\\n        for(int d = 0; d < dir.length; d++){\\n            result += dfs(grid, i + dir[d][0], j + dir[d][1], dir);\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 1){\\n                    return dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    public static int dfs(int[][] grid, int i, int j){\\n        if(i<0 || i>= grid.length || j<0 || j>= grid[0].length || grid[i][j] == 0)\\n            return 1;\\n        if(grid[i][j] == -1)\\n            return 0;\\n\\n        grid[i][j] = -1;\\n        int result = 0;\\n        result += dfs(grid, i-1, j);\\n        result += dfs(grid, i, j+1);\\n        result += dfs(grid, i+1, j);\\n        result += dfs(grid, i, j-1);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262356,
                "title": "c-3-approaches-simple-and-clean-interview-style",
                "content": "```\\n//Approach-1 (DFS)\\nclass Solution {\\npublic:\\n    int perimeter;\\n    void dfs(vector<vector<int>>& grid, int i, int j) {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == 0) {\\n            perimeter++;\\n            return;\\n        }\\n        \\n        if(grid[i][j] == -1)\\n            return;\\n        \\n        grid[i][j] = -1;\\n        \\n        dfs(grid, i+1, j);\\n        dfs(grid, i-1, j);\\n        dfs(grid, i, j+1);\\n        dfs(grid, i, j-1);\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        perimeter = 0;\\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(grid[i][j] == 1) {\\n                    dfs(grid, i, j);\\n                    return perimeter;\\n                }\\n            }\\n        }\\n        \\n        return perimeter;\\n    }\\n};\\n\\n\\n//Approach-2 (BFS)\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    int bfs(vector<vector<int>>& grid, int i, int j) {\\n        int perimeter = 0;\\n        \\n        queue<pair<int, int>> que;\\n        que.push({i, j});\\n        grid[i][j] = -1;\\n        while(!que.empty()) {\\n            auto it = que.front();\\n            que.pop();\\n            \\n            for(pair<int, int> &p : directions) {\\n                int i_ = it.first  + p.first;\\n                int j_ = it.second + p.second;\\n                \\n                if(i_ < 0 || i_ >= grid.size() || j_ < 0 || j_ >= grid[0].size() || grid[i_][j_] == 0)\\n                    perimeter++;\\n                else if(grid[i_][j_] == -1) {\\n                    continue;\\n                } else {\\n                    que.push({i_, j_});\\n                    grid[i_][j_] = -1;\\n                }\\n            }\\n        }\\n        \\n        return perimeter;\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(grid[i][j] == 1) {\\n                    return bfs(grid, i, j);\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n\\n\\n//Approach-3 (Iterative)\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int perimeter = 0;\\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(grid[i][j] == 0)\\n                    continue;\\n                \\n                if(i-1 < 0 || grid[i-1][j] == 0) //up\\n                    perimeter++;\\n                \\n                if(i+1 >= m || grid[i+1][j] == 0) //down\\n                    perimeter++;\\n                \\n                if(j-1 < 0 || grid[i][j-1] == 0) //left\\n                    perimeter++;\\n                \\n                if(j+1 >= n || grid[i][j+1] == 0) //right\\n                    perimeter++;\\n                \\n            }\\n        }\\n        \\n        return perimeter;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (DFS)\\nclass Solution {\\npublic:\\n    int perimeter;\\n    void dfs(vector<vector<int>>& grid, int i, int j) {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == 0) {\\n            perimeter++;\\n            return;\\n        }\\n        \\n        if(grid[i][j] == -1)\\n            return;\\n        \\n        grid[i][j] = -1;\\n        \\n        dfs(grid, i+1, j);\\n        dfs(grid, i-1, j);\\n        dfs(grid, i, j+1);\\n        dfs(grid, i, j-1);\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        perimeter = 0;\\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(grid[i][j] == 1) {\\n                    dfs(grid, i, j);\\n                    return perimeter;\\n                }\\n            }\\n        }\\n        \\n        return perimeter;\\n    }\\n};\\n\\n\\n//Approach-2 (BFS)\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    int bfs(vector<vector<int>>& grid, int i, int j) {\\n        int perimeter = 0;\\n        \\n        queue<pair<int, int>> que;\\n        que.push({i, j});\\n        grid[i][j] = -1;\\n        while(!que.empty()) {\\n            auto it = que.front();\\n            que.pop();\\n            \\n            for(pair<int, int> &p : directions) {\\n                int i_ = it.first  + p.first;\\n                int j_ = it.second + p.second;\\n                \\n                if(i_ < 0 || i_ >= grid.size() || j_ < 0 || j_ >= grid[0].size() || grid[i_][j_] == 0)\\n                    perimeter++;\\n                else if(grid[i_][j_] == -1) {\\n                    continue;\\n                } else {\\n                    que.push({i_, j_});\\n                    grid[i_][j_] = -1;\\n                }\\n            }\\n        }\\n        \\n        return perimeter;\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(grid[i][j] == 1) {\\n                    return bfs(grid, i, j);\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n\\n\\n//Approach-3 (Iterative)\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int perimeter = 0;\\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(grid[i][j] == 0)\\n                    continue;\\n                \\n                if(i-1 < 0 || grid[i-1][j] == 0) //up\\n                    perimeter++;\\n                \\n                if(i+1 >= m || grid[i+1][j] == 0) //down\\n                    perimeter++;\\n                \\n                if(j-1 < 0 || grid[i][j-1] == 0) //left\\n                    perimeter++;\\n                \\n                if(j+1 >= n || grid[i][j+1] == 0) //right\\n                    perimeter++;\\n                \\n            }\\n        }\\n        \\n        return perimeter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993494,
                "title": "very-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        \\n        int peri = 0;\\n        \\n        for(int i =0; i<grid.length; i++){\\n            for(int j=0; j<grid[i].length; j++){\\n                if(grid[i][j] == 1) { \\n                    if(j-1<0 || grid[i][j-1] == 0) { //left\\n                        peri++;\\n                    }\\n                    if(j+1 >grid[i].length-1 || grid[i][j+1] == 0){ //right\\n                        peri++;\\n                    }\\n                    if(i-1<0 || grid[i-1][j] ==0){ //top\\n                        peri++;\\n                    }\\n                    if(i+1>grid.length-1 || grid[i+1][j] == 0){ //down\\n                        peri++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return peri;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        \\n        int peri = 0;\\n        \\n        for(int i =0; i<grid.length; i++){\\n            for(int j=0; j<grid[i].length; j++){\\n                if(grid[i][j] == 1) { \\n                    if(j-1<0 || grid[i][j-1] == 0) { //left\\n                        peri++;\\n                    }\\n                    if(j+1 >grid[i].length-1 || grid[i][j+1] == 0){ //right\\n                        peri++;\\n                    }\\n                    if(i-1<0 || grid[i-1][j] ==0){ //top\\n                        peri++;\\n                    }\\n                    if(i+1>grid.length-1 || grid[i+1][j] == 0){ //down\\n                        peri++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return peri;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819966,
                "title": "java-o-mn-time-o-1-space-super-easy-guarantee-solution",
                "content": "Most answer looks good, but i felt like my answer is super easy to understand and something i came up in the interview (no bfs, no dfs)\\n\\n```\\n[0,1,0,0]\\n[1,1,1,0]\\n[0,1,0,0]\\n[1,1,0,0]\\n```\\nint count = 0\\n1. Check for boader first x = 0 or xLen - 1, and y = 0 or yLen - 1, if we encounter 1, we increment count since we need to built Perimeter, see matrix below: Notice we have 5 1s total (*) in the matrix hence or count is 1.\\n```\\n    *\\n [0,1,0,0]\\n*[1,1,1,0]\\n [0,1,0,0]\\n*[1,1,0,0]\\n  * *   \\n```\\n2. Scan through the matrix if we encounter a 0, we check its neighbor, when we found a neighbor that is equal to 1 we increment the count. label neighbors as (*)\\n ```\\n[0*,1,*0,0]\\n  *     * \\n[1 ,1, 1*,0]\\n  *     *\\n[0*,1*,0,0]\\n  *         \\n[1, 1*,0,0]\\n```\\n\\nCorner case\\n```\\n[1]     \\n```\\n= 4, hence we need to check the boarder first and make sure, we check four times to get all the count for the perimeter,\\n\\nHere is the code:\\n\\nRuntime: 6 ms, faster than 93.25% of Java online submissions for Island Perimeter.\\nMemory Usage: 40 MB, less than 94.76% of Java online submissions for Island Perimeter.\\n\\n```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        if(grid == null || grid.length == 0) {\\n            return 0;\\n        }\\n        int count = 0;\\n        int[] traversalCol = new int[] {0, grid[0].length - 1};\\n        int[] traversalRow = new int[] {0, grid.length - 1};\\n        \\n        // check first col, and last col\\n        for(int j = 0; j < traversalCol.length; j++) {\\n            for(int i = 0; i < grid.length; i++) {\\n                if(grid[i][traversalCol[j]] == 1) {\\n                    count++;\\n                }                \\n            }\\n        }\\n        \\n        // check first row, and last row\\n        for(int i = 0; i < traversalRow.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[traversalRow[i]][j] == 1) {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        // check entire matrix and serach for 0\\'s neighbor\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 0) {\\n                    if(i - 1 >= 0 && grid[i - 1][j] == 1) {\\n                        count++;\\n                    }\\n                    if(j - 1 >= 0 && grid[i][j - 1] == 1) {\\n                        count++;\\n                    }  \\n                    if(i + 1 < grid.length && grid[i +1][j] == 1) {\\n                        count++;\\n                    }\\n                    if(j + 1 < grid[0].length && grid[i][j + 1] == 1) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n[0,1,0,0]\\n[1,1,1,0]\\n[0,1,0,0]\\n[1,1,0,0]\\n```\n```\\n    *\\n [0,1,0,0]\\n*[1,1,1,0]\\n [0,1,0,0]\\n*[1,1,0,0]\\n  * *   \\n```\n```\\n[0*,1,*0,0]\\n  *     * \\n[1 ,1, 1*,0]\\n  *     *\\n[0*,1*,0,0]\\n  *         \\n[1, 1*,0,0]\\n```\n```\\n[1]     \\n```\n```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        if(grid == null || grid.length == 0) {\\n            return 0;\\n        }\\n        int count = 0;\\n        int[] traversalCol = new int[] {0, grid[0].length - 1};\\n        int[] traversalRow = new int[] {0, grid.length - 1};\\n        \\n        // check first col, and last col\\n        for(int j = 0; j < traversalCol.length; j++) {\\n            for(int i = 0; i < grid.length; i++) {\\n                if(grid[i][traversalCol[j]] == 1) {\\n                    count++;\\n                }                \\n            }\\n        }\\n        \\n        // check first row, and last row\\n        for(int i = 0; i < traversalRow.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[traversalRow[i]][j] == 1) {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        // check entire matrix and serach for 0\\'s neighbor\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 0) {\\n                    if(i - 1 >= 0 && grid[i - 1][j] == 1) {\\n                        count++;\\n                    }\\n                    if(j - 1 >= 0 && grid[i][j - 1] == 1) {\\n                        count++;\\n                    }  \\n                    if(i + 1 < grid.length && grid[i +1][j] == 1) {\\n                        count++;\\n                    }\\n                    if(j + 1 < grid[0].length && grid[i][j + 1] == 1) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 795865,
                "title": "javascript-99-faster-easy-to-understand-with-comments",
                "content": "```\\nvar islandPerimeter = function(grid) {\\n    let perimeter = 0;\\n    \\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] === 1) {\\n                if (j === 0 || grid[i][j - 1] === 0) {\\n                    // First in array or left is a 0\\n                    perimeter++;\\n                }\\n\\n                if (j === (grid[i].length - 1) || grid[i][j + 1] === 0) {\\n                    // Last in array or right is a 0\\n                    perimeter++;\\n                }\\n\\n                if (i === 0 || grid[i - 1][j] === 0) {\\n                    // Top of column or above is a 0\\n                    perimeter++;\\n                }\\n\\n                if (i === (grid.length - 1) || grid[i + 1][j] === 0) {\\n                    // Bottom of column or below is a 0\\n                    perimeter++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return perimeter;\\n};\\n```\\n\\nStats:\\nRuntime: 164 ms, faster than 99.69% of JavaScript online submissions for Island Perimeter.\\nMemory Usage: 46.3 MB, less than 75.56% of JavaScript online submissions for Island Perimeter.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar islandPerimeter = function(grid) {\\n    let perimeter = 0;\\n    \\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] === 1) {\\n                if (j === 0 || grid[i][j - 1] === 0) {\\n                    // First in array or left is a 0\\n                    perimeter++;\\n                }\\n\\n                if (j === (grid[i].length - 1) || grid[i][j + 1] === 0) {\\n                    // Last in array or right is a 0\\n                    perimeter++;\\n                }\\n\\n                if (i === 0 || grid[i - 1][j] === 0) {\\n                    // Top of column or above is a 0\\n                    perimeter++;\\n                }\\n\\n                if (i === (grid.length - 1) || grid[i + 1][j] === 0) {\\n                    // Bottom of column or below is a 0\\n                    perimeter++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return perimeter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 793165,
                "title": "python-hashtable",
                "content": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        \\n        if not grid or not grid[0]:\\n            return 0\\n        \\n        row, col = len(grid), len(grid[0])       \\n        hashMap = dict()\\n        \\n\\n        for i in range(row):\\n            for j in range(col):\\n                \\n                if grid[i][j] == 1:\\n                    \\n                    hashMap[(i, j)] = 4           \\n                    \\n                    if i == j == 0:\\n                        continue\\n                        \\n                    if (i, j-1) in hashMap:\\n                        hashMap[(i, j)] -= 2\\n                        \\n                    if (i-1, j) in hashMap:\\n                        hashMap[(i, j)] -= 2                       \\n                   \\n        return sum(hashMap.values())\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        \\n        if not grid or not grid[0]:\\n            return 0\\n        \\n        row, col = len(grid), len(grid[0])       \\n        hashMap = dict()\\n        \\n\\n        for i in range(row):\\n            for j in range(col):\\n                \\n                if grid[i][j] == 1:\\n                    \\n                    hashMap[(i, j)] = 4           \\n                    \\n                    if i == j == 0:\\n                        continue\\n                        \\n                    if (i, j-1) in hashMap:\\n                        hashMap[(i, j)] -= 2\\n                        \\n                    if (i-1, j) in hashMap:\\n                        hashMap[(i, j)] -= 2                       \\n                   \\n        return sum(hashMap.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 771074,
                "title": "golang-simple-solution",
                "content": "```\\nfunc islandPerimeter(grid [][]int) int {\\n    var(\\n        res int\\n        l = len(grid[0])\\n    )\\n    for i := 0; i < len(grid); i++ {\\n        for j := 0; j < l; j++ {\\n            if grid[i][j] == 1 {\\n                res += 4\\n                if i > 0 && grid[i-1][j] == 1 {\\n                    res -= 2\\n                }\\n                if j > 0 && grid[i][j-1] == 1 {\\n                    res -= 2\\n                }\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc islandPerimeter(grid [][]int) int {\\n    var(\\n        res int\\n        l = len(grid[0])\\n    )\\n    for i := 0; i < len(grid); i++ {\\n        for j := 0; j < l; j++ {\\n            if grid[i][j] == 1 {\\n                res += 4\\n                if i > 0 && grid[i-1][j] == 1 {\\n                    res -= 2\\n                }\\n                if j > 0 && grid[i][j-1] == 1 {\\n                    res -= 2\\n                }\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 724775,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    \\n    int res = 0;\\n    public int islandPerimeter(int[][] grid) {\\n        for (int i=0;i<grid.length;i++) {\\n            for (int j=0;j<grid[0].length;j++) {\\n                if (grid[i][j] == 1) {\\n                    dfs(i,j,grid);\\n                    return res;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    \\n    public void dfs(int x, int y, int[][] grid) {\\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0){\\n            res++;\\n            return;\\n        }\\n        if (grid[x][y] == -1) return;\\n        grid[x][y] = -1;\\n        dfs(x+1,y,grid);\\n        dfs(x-1,y,grid);\\n        dfs(x,y+1,grid);\\n        dfs(x,y-1,grid);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int res = 0;\\n    public int islandPerimeter(int[][] grid) {\\n        for (int i=0;i<grid.length;i++) {\\n            for (int j=0;j<grid[0].length;j++) {\\n                if (grid[i][j] == 1) {\\n                    dfs(i,j,grid);\\n                    return res;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    \\n    public void dfs(int x, int y, int[][] grid) {\\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0){\\n            res++;\\n            return;\\n        }\\n        if (grid[x][y] == -1) return;\\n        grid[x][y] = -1;\\n        dfs(x+1,y,grid);\\n        dfs(x-1,y,grid);\\n        dfs(x,y+1,grid);\\n        dfs(x,y-1,grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724553,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n         if (grid.empty() || grid[0].empty()) return 0;\\n        int m = grid.size(), n = grid[0].size(), res = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) continue;\\n                if (j == 0 || grid[i][j - 1] == 0) ++res;\\n                if (i == 0 || grid[i - 1][j] == 0) ++res;\\n                if (j == n - 1 || grid[i][j + 1] == 0) ++res;\\n                if (i == m - 1 || grid[i + 1][j] == 0) ++res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n         if (grid.empty() || grid[0].empty()) return 0;\\n        int m = grid.size(), n = grid[0].size(), res = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) continue;\\n                if (j == 0 || grid[i][j - 1] == 0) ++res;\\n                if (i == 0 || grid[i - 1][j] == 0) ++res;\\n                if (j == n - 1 || grid[i][j + 1] == 0) ++res;\\n                if (i == m - 1 || grid[i + 1][j] == 0) ++res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724163,
                "title": "cpp-four-conditions-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int per=0;\\n        int n = grid.size();\\n        for(int i=0;i<n;i++){\\n            int m = grid[i].size();\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                if(i==0 || grid[i-1][j]!=1) per++;\\n                if(j==0 || grid[i][j-1]!=1) per++;\\n                if(i==n-1 || grid[i+1][j]!=1) per++;\\n                if(j==m-1 || grid[i][j+1]!=1) per++; \\n                }\\n               \\n            }\\n        }\\n        return per;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int per=0;\\n        int n = grid.size();\\n        for(int i=0;i<n;i++){\\n            int m = grid[i].size();\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                if(i==0 || grid[i-1][j]!=1) per++;\\n                if(j==0 || grid[i][j-1]!=1) per++;\\n                if(i==n-1 || grid[i+1][j]!=1) per++;\\n                if(j==m-1 || grid[i][j+1]!=1) per++; \\n                }\\n               \\n            }\\n        }\\n        return per;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724078,
                "title": "python3-solution-using-dfs",
                "content": "```\\nclass Solution:\\n    def islandPerimeter(self, grid):\\n        def dfs(g, x, y, p):\\n            if x < 0 or y < 0 or x == len(g) or y == len(g[0]) or g[x][y] == 0: return p + 1\\n            elif g[x][y] == -1: return p\\n            g[x][y] = -1\\n            p = dfs(g, x-1, y, p)\\n            p = dfs(g, x, y+1, p)\\n            p = dfs(g, x+1, y, p)\\n            p = dfs(g, x, y-1, p)\\n            return p\\n        \\n        cols, rows = len(grid[0]), len(grid)\\n        for i in range(rows):\\n            for j in range(cols):\\n                if grid[i][j] == 1: return dfs(grid, i, j, 0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid):\\n        def dfs(g, x, y, p):\\n            if x < 0 or y < 0 or x == len(g) or y == len(g[0]) or g[x][y] == 0: return p + 1\\n            elif g[x][y] == -1: return p\\n            g[x][y] = -1\\n            p = dfs(g, x-1, y, p)\\n            p = dfs(g, x, y+1, p)\\n            p = dfs(g, x+1, y, p)\\n            p = dfs(g, x, y-1, p)\\n            return p\\n        \\n        cols, rows = len(grid[0]), len(grid)\\n        for i in range(rows):\\n            for j in range(cols):\\n                if grid[i][j] == 1: return dfs(grid, i, j, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661341,
                "title": "simple-java-beats-100-time-and-space",
                "content": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int c = 0;\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        for(int i = 0;i<row;i++){\\n            for (int j = 0;j<col;j++){\\n                if (grid[i][j] == 1){\\n                    if (i == 0 || grid[i-1][j] == 0)\\n                        c += 1;\\n                    if (j == 0 || grid[i][j-1] == 0)\\n                        c += 1;\\n                    if(i == row-1 || grid[i+1][j] == 0)\\n                        c += 1;\\n                    if(j == col-1 || grid[i][j+1] == 0)\\n                        c += 1;  \\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int c = 0;\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        for(int i = 0;i<row;i++){\\n            for (int j = 0;j<col;j++){\\n                if (grid[i][j] == 1){\\n                    if (i == 0 || grid[i-1][j] == 0)\\n                        c += 1;\\n                    if (j == 0 || grid[i][j-1] == 0)\\n                        c += 1;\\n                    if(i == row-1 || grid[i+1][j] == 0)\\n                        c += 1;\\n                    if(j == col-1 || grid[i][j+1] == 0)\\n                        c += 1;  \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 567924,
                "title": "java-different-solutions",
                "content": "**Solution 1: DFS ~ 11ms**\\n```java\\nclass Solution {\\n    int ans = 0;\\n    public int islandPerimeter(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c] == 1) {\\n                    dfs(grid, m, n, r, c, visited);\\n                    return ans;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int[] DIR = new int[]{0, 1, 0, -1, 0};\\n    private boolean dfs(int[][] grid, int m, int n, int r, int c, boolean[][] visited) {\\n        if (r < 0 || r == m || c < 0 || c == n || grid[r][c] == 0) return false;\\n        if (visited[r][c]) return true;\\n        visited[r][c] = true;\\n        ans += 4; // new land cell\\n        for (int i = 0; i < 4; i++) {\\n            if (dfs(grid, m, n, r + DIR[i], c + DIR[i + 1], visited)) {\\n                ans -= 1; // -1 for land cell neighbors\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\nTime & Space: `O(m*n)`, where `m` is number of rows, `n` is number of columns of themgrid.\\n\\n**Solution 2: Count number of islands, number of down neighbors, number of right neighbors ~ 4ms**\\n```java\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int islandCount = 0, neighborDownCount = 0, neighborRightCount = 0;\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c] == 1) {\\n                    islandCount++;\\n                    if (r + 1 < m && grid[r + 1][c] == 1) neighborDownCount++;\\n                    if (c + 1 < n && grid[r][c + 1] == 1) neighborRightCount++;\\n                }\\n            }\\n        }\\n        return islandCount * 4 - neighborDownCount * 2 - neighborRightCount * 2;\\n    }\\n}\\n```\\nTime & Space: `O(m*n)`, where `m` is number of rows, `n` is number of columns of themgrid.",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    int ans = 0;\\n    public int islandPerimeter(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c] == 1) {\\n                    dfs(grid, m, n, r, c, visited);\\n                    return ans;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int[] DIR = new int[]{0, 1, 0, -1, 0};\\n    private boolean dfs(int[][] grid, int m, int n, int r, int c, boolean[][] visited) {\\n        if (r < 0 || r == m || c < 0 || c == n || grid[r][c] == 0) return false;\\n        if (visited[r][c]) return true;\\n        visited[r][c] = true;\\n        ans += 4; // new land cell\\n        for (int i = 0; i < 4; i++) {\\n            if (dfs(grid, m, n, r + DIR[i], c + DIR[i + 1], visited)) {\\n                ans -= 1; // -1 for land cell neighbors\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int islandCount = 0, neighborDownCount = 0, neighborRightCount = 0;\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c] == 1) {\\n                    islandCount++;\\n                    if (r + 1 < m && grid[r + 1][c] == 1) neighborDownCount++;\\n                    if (c + 1 < n && grid[r][c + 1] == 1) neighborRightCount++;\\n                }\\n            }\\n        }\\n        return islandCount * 4 - neighborDownCount * 2 - neighborRightCount * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539392,
                "title": "java-iterative-approach",
                "content": "```\\nclass Solution {\\n    private static final int ISLAND = 1;\\n    \\n    public int islandPerimeter(int[][] grid) {\\n        int perimeters = 0;\\n        \\n        for (int row = 0; row < grid.length; row++) {\\n            for (int col = 0; col < grid[row].length; col++) {\\n                 if (isIsland(grid, row, col)) {\\n                    perimeters += 4;\\n                    \\n                    perimeters -= isIsland(grid, row - 1, col) ? 1 : 0; // top\\n                    perimeters -= isIsland(grid, row + 1, col) ? 1 : 0; // bottom\\n                    perimeters -= isIsland(grid, row, col - 1) ? 1 : 0; // left\\n                    perimeters -= isIsland(grid, row, col + 1) ? 1 : 0; // right\\n                } \\n            }\\n        }\\n        \\n        return perimeters;\\n    }\\n    \\n    private boolean isIsland(int[][] grid, int row, int col) {\\n        if (row < 0 || row >= grid.length || col < 0 || col >= grid[row].length) {\\n            return false;\\n        }\\n        \\n        return grid[row][col] == ISLAND;\\n    }\\n}\\n```\\n\\n**Thoughts before Coding**\\n- How many perimeters do we find if we have found a 1 square island?\\n\\t- Each 1 square island contains a perimeter of 4\\n- For each of the 1 square islands, we need to check its neighbors\\n\\t- Each of the neighbors that is also an island will subtract 1 from the perimeter\\n- Lets use the iterative approach in this solution\\n\\n**Answer**\\n- We will need a counter to keep track of our number of perimeters\\n- We will iterate every cell in our 2D array\\n\\t- When we see a cell that is an island\\n\\t\\t- We will increment our perimeter count by 4\\n\\t\\t- Then we need to check the top,left,right,bottom neighbors\\n\\t\\t\\t- for each of the neighbors that is an island\\n\\t\\t\\t\\t- we will decrement the perimeter count\\n\\t\\t- How will we check our neighboring cells?\\n\\t\\t\\t- If we are currently at [row][col], we can go\\n\\t\\t\\t\\t- top = [row - 1][col]\\n\\t\\t\\t\\t- left = [row][col - 1]\\n\\t\\t\\t\\t- right = [row][col + 1]\\n\\t\\t\\t\\t- bottom = [row + 1][col]\\n\\t\\t\\t- Before we check the neighboring cell is island or no\\n\\t\\t\\t\\t- make sure to check we do not go index out of bound\\n- return the number of perimeters\\n\\n**What is the Time and Space complexity?**\\n- Time complexity = O(r * c), where r = # of rows, c = # of column and i = # of islands\\n\\t- Worst case scenario where every single cell is an island\\n- Space complexity = O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int ISLAND = 1;\\n    \\n    public int islandPerimeter(int[][] grid) {\\n        int perimeters = 0;\\n        \\n        for (int row = 0; row < grid.length; row++) {\\n            for (int col = 0; col < grid[row].length; col++) {\\n                 if (isIsland(grid, row, col)) {\\n                    perimeters += 4;\\n                    \\n                    perimeters -= isIsland(grid, row - 1, col) ? 1 : 0; // top\\n                    perimeters -= isIsland(grid, row + 1, col) ? 1 : 0; // bottom\\n                    perimeters -= isIsland(grid, row, col - 1) ? 1 : 0; // left\\n                    perimeters -= isIsland(grid, row, col + 1) ? 1 : 0; // right\\n                } \\n            }\\n        }\\n        \\n        return perimeters;\\n    }\\n    \\n    private boolean isIsland(int[][] grid, int row, int col) {\\n        if (row < 0 || row >= grid.length || col < 0 || col >= grid[row].length) {\\n            return false;\\n        }\\n        \\n        return grid[row][col] == ISLAND;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535852,
                "title": "c-very-intuitive-dfs-solution-but-not-the-fastest",
                "content": "```\\nclass Solution {\\n    public:\\n        int islandPerimeter(vector<vector<int>>& grid) {\\n            for(int r = 0; r < grid.size(); ++r)\\n                for(int c = 0; c < grid[0].size(); ++c)\\n                    if(grid[r][c] == 1) return perimeter(grid, r, c);\\n            return 0;\\n        }\\n\\n    protected:\\n        int perimeter(vector<vector<int>>& grid, int r, int c)\\n        {\\n            if(r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] == 0)\\n                return 1;\\n            if(grid[r][c] == 2) return 0;\\n            grid[r][c] = 2; // \\'visited\\'\\n            return  perimeter(grid, r+1, c) +\\n                    perimeter(grid, r-1, c) +\\n                    perimeter(grid, r, c+1) +\\n                    perimeter(grid, r, c-1);\\n        }\\n};\\n```\\nSince we have only one \\'island\\' - the solution below, of course, is a better one:\\n```\\nclass Solution {\\n    public:\\n        int islandPerimeter(vector<vector<int>>& grid) {\\n            int land = 0;\\n            int not_perimeter = 0;\\n            for(int r = 0; r < grid.size(); ++r)\\n                for(int c = 0; c < grid[0].size(); ++c)\\n                {\\n                    if(grid[r][c] == 0) continue;\\n                    ++land;\\n                    if(r != 0 && grid[r-1][c] == 1) ++not_perimeter;\\n                    if(c != 0 && grid[r][c-1] == 1) ++not_perimeter;\\n                }\\n            return 4*land - not_perimeter*2; // land has 4 sides; each \\'non_perimeter\\' shared between 2 \\'land\\' cells\\n        }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n        int islandPerimeter(vector<vector<int>>& grid) {\\n            for(int r = 0; r < grid.size(); ++r)\\n                for(int c = 0; c < grid[0].size(); ++c)\\n                    if(grid[r][c] == 1) return perimeter(grid, r, c);\\n            return 0;\\n        }\\n\\n    protected:\\n        int perimeter(vector<vector<int>>& grid, int r, int c)\\n        {\\n            if(r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] == 0)\\n                return 1;\\n            if(grid[r][c] == 2) return 0;\\n            grid[r][c] = 2; // \\'visited\\'\\n            return  perimeter(grid, r+1, c) +\\n                    perimeter(grid, r-1, c) +\\n                    perimeter(grid, r, c+1) +\\n                    perimeter(grid, r, c-1);\\n        }\\n};\\n```\n```\\nclass Solution {\\n    public:\\n        int islandPerimeter(vector<vector<int>>& grid) {\\n            int land = 0;\\n            int not_perimeter = 0;\\n            for(int r = 0; r < grid.size(); ++r)\\n                for(int c = 0; c < grid[0].size(); ++c)\\n                {\\n                    if(grid[r][c] == 0) continue;\\n                    ++land;\\n                    if(r != 0 && grid[r-1][c] == 1) ++not_perimeter;\\n                    if(c != 0 && grid[r][c-1] == 1) ++not_perimeter;\\n                }\\n            return 4*land - not_perimeter*2; // land has 4 sides; each \\'non_perimeter\\' shared between 2 \\'land\\' cells\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 469713,
                "title": "logical-solution",
                "content": "```\\n// Adding some spoiler comments at last as this will help me answering this when I review this question next time.\\nclass Solution {\\n  // They have given there is exactly one island only.\\n  // And the given grid is completely surrounded by water.\\n  // They say that there are no lakes(water inside the grid that isn\\'t connected to the water around the island). <But this point is of no use as of my understanding>.\\n  public int islandPerimeter(int[][] grid) {\\n    \\n    int perimeter = 0;\\n    for(int i = 0; i < grid.length; i++) {\\n      for(int j = 0; j < grid[i].length; j++) {\\n        \\n        // Only do calculation for parts that are part of island(1).\\n        if(grid[i][j] == 1) {\\n          int top = 0, left = 0, right = 0, bottom = 0;\\n          \\n          // As the grid is surrounded by water, if this is top most cell(i = 0), its for sure the top end and this counts to perimeter.\\n          if(i == 0) {\\n            top++;\\n          } else {\\n            // If its not (i = 0), ie its somewhere in the middle, if the cell above it is water, then we add this as perimeter.\\n            if(grid[i-1][j] == 0) {\\n              top++;\\n            } else {\\n              // This wont count to top as this is not the top most (see the <1, 1> it shouldn\\'t be counted as per diagram).\\n            }\\n          }\\n\\n          // The same logic for top is followed to this too.\\n          if(j == 0) {\\n            left++;\\n          } else {\\n            if(grid[i][j-1] == 0) {\\n              left++;\\n            }\\n          }\\n\\n          if(i == grid.length-1) {\\n            bottom++;\\n          } else {\\n            if(grid[i+1][j] == 0) {\\n              bottom++;\\n            }\\n          }\\n\\n          if(j == grid[i].length-1) {\\n            right++;\\n          } else {\\n            if(grid[i][j+1] == 0) {\\n              right++;\\n            }\\n          }\\n          \\n          perimeter += top + bottom + left + right;\\n        } \\n        \\n        //System.out.println(perimeter);\\n      }\\n    }\\n    \\n    return perimeter;\\n  }\\n}\\n// This is a simple question, it doesn\\'t need recursion. You just need to go through all the elements and check if it adds to the perimeter.\\n```",
                "solutionTags": [],
                "code": "```\\n// Adding some spoiler comments at last as this will help me answering this when I review this question next time.\\nclass Solution {\\n  // They have given there is exactly one island only.\\n  // And the given grid is completely surrounded by water.\\n  // They say that there are no lakes(water inside the grid that isn\\'t connected to the water around the island). <But this point is of no use as of my understanding>.\\n  public int islandPerimeter(int[][] grid) {\\n    \\n    int perimeter = 0;\\n    for(int i = 0; i < grid.length; i++) {\\n      for(int j = 0; j < grid[i].length; j++) {\\n        \\n        // Only do calculation for parts that are part of island(1).\\n        if(grid[i][j] == 1) {\\n          int top = 0, left = 0, right = 0, bottom = 0;\\n          \\n          // As the grid is surrounded by water, if this is top most cell(i = 0), its for sure the top end and this counts to perimeter.\\n          if(i == 0) {\\n            top++;\\n          } else {\\n            // If its not (i = 0), ie its somewhere in the middle, if the cell above it is water, then we add this as perimeter.\\n            if(grid[i-1][j] == 0) {\\n              top++;\\n            } else {\\n              // This wont count to top as this is not the top most (see the <1, 1> it shouldn\\'t be counted as per diagram).\\n            }\\n          }\\n\\n          // The same logic for top is followed to this too.\\n          if(j == 0) {\\n            left++;\\n          } else {\\n            if(grid[i][j-1] == 0) {\\n              left++;\\n            }\\n          }\\n\\n          if(i == grid.length-1) {\\n            bottom++;\\n          } else {\\n            if(grid[i+1][j] == 0) {\\n              bottom++;\\n            }\\n          }\\n\\n          if(j == grid[i].length-1) {\\n            right++;\\n          } else {\\n            if(grid[i][j+1] == 0) {\\n              right++;\\n            }\\n          }\\n          \\n          perimeter += top + bottom + left + right;\\n        } \\n        \\n        //System.out.println(perimeter);\\n      }\\n    }\\n    \\n    return perimeter;\\n  }\\n}\\n// This is a simple question, it doesn\\'t need recursion. You just need to go through all the elements and check if it adds to the perimeter.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459718,
                "title": "python-one-pass-100-efficient-algorithm",
                "content": "Go through the matrix, and everytime you encounter 1, just check how many neighboring cells are are 0 or boundary,that will be counted in perimeter.\\n```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if not grid[i][j]: continue\\n                if i <= 0 or not grid[i-1][j]: count += 1\\n                if i >= len(grid)-1 or not grid[i+1][j]: count += 1\\n                if j <= 0 or not grid[i][j-1]: count += 1\\n                if j >= len(grid[0])-1 or not grid[i][j+1]: count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if not grid[i][j]: continue\\n                if i <= 0 or not grid[i-1][j]: count += 1\\n                if i >= len(grid)-1 or not grid[i+1][j]: count += 1\\n                if j <= 0 or not grid[i][j-1]: count += 1\\n                if j >= len(grid[0])-1 or not grid[i][j+1]: count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400455,
                "title": "c-bfs",
                "content": "```\\n/* \\n    so we can iterate through the grid looking for the first cell that is part of the island\\n    \\n    from there we will do a BFS and compute the perimeter\\n    \\n    The perimeter has a 1 added for each cell it is adjacent to that is not part of the island as well as when it borders the bounds of the grid\\n    This will run in O(mn) time and O(mn) space\\n    \\n*/\\n\\nclass Solution {\\n    vector<pair<int, int>> DIRs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        for (int i = 0; i < grid.size(); i++){\\n            for (int j = 0; j < grid[i].size(); j++){\\n                if (grid[i][j] == 1)\\n                    return BFS(grid, {i, j});\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int BFS(const vector<vector<int>>& grid, pair<int, int> pos){\\n        int res = 0;\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        queue<pair<int, int>> q;\\n        \\n        q.push(pos);\\n        visited[pos.first][pos.second] = 1;\\n        while (!q.empty()){\\n            pair<int, int> curr = q.front();\\n            q.pop();\\n            \\n            for (pair<int, int> dir : DIRs){\\n                pair<int, int> nextPos = {curr.first + dir.first, curr.second + dir.second};\\n                if (!canMove(grid, nextPos))\\n                    res++;\\n                else {\\n                    if (visited[nextPos.first][nextPos.second] == 1)\\n                        continue;\\n                    \\n                    visited[nextPos.first][nextPos.second] = 1;\\n                    q.push(nextPos);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    bool canMove(const vector<vector<int>>& grid, pair<int, int> pos){\\n        return pos.first >= 0 && pos.first < grid.size() && pos.second >= 0 && pos.second < grid[0].size() && grid[pos.first][pos.second] == 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/* \\n    so we can iterate through the grid looking for the first cell that is part of the island\\n    \\n    from there we will do a BFS and compute the perimeter\\n    \\n    The perimeter has a 1 added for each cell it is adjacent to that is not part of the island as well as when it borders the bounds of the grid\\n    This will run in O(mn) time and O(mn) space\\n    \\n*/\\n\\nclass Solution {\\n    vector<pair<int, int>> DIRs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        for (int i = 0; i < grid.size(); i++){\\n            for (int j = 0; j < grid[i].size(); j++){\\n                if (grid[i][j] == 1)\\n                    return BFS(grid, {i, j});\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int BFS(const vector<vector<int>>& grid, pair<int, int> pos){\\n        int res = 0;\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        queue<pair<int, int>> q;\\n        \\n        q.push(pos);\\n        visited[pos.first][pos.second] = 1;\\n        while (!q.empty()){\\n            pair<int, int> curr = q.front();\\n            q.pop();\\n            \\n            for (pair<int, int> dir : DIRs){\\n                pair<int, int> nextPos = {curr.first + dir.first, curr.second + dir.second};\\n                if (!canMove(grid, nextPos))\\n                    res++;\\n                else {\\n                    if (visited[nextPos.first][nextPos.second] == 1)\\n                        continue;\\n                    \\n                    visited[nextPos.first][nextPos.second] = 1;\\n                    q.push(nextPos);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    bool canMove(const vector<vector<int>>& grid, pair<int, int> pos){\\n        return pos.first >= 0 && pos.first < grid.size() && pos.second >= 0 && pos.second < grid[0].size() && grid[pos.first][pos.second] == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312762,
                "title": "python-solution-using-dictionary",
                "content": "Here are 2 solutions.\\nPlease comment for any doubt.\\n\\n```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        ilnd={}\\n        count=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1:\\n                    s=(i,j)\\n                    ilnd[s]=1\\n        for i in ilnd.keys():\\n            try:\\n                ilnd[(i[0]-1,i[1])]\\n            except:\\n                count+=1\\n            try:\\n                ilnd[(i[0]+1,i[1])]\\n            except:\\n                count+=1\\n            try:\\n                ilnd[(i[0],i[1]-1)]\\n            except:\\n                count+=1\\n            try:\\n                ilnd[(i[0],i[1]+1)]\\n            except:\\n                count+=1\\n        return count\\n                \\n        \\n```\\n\\n\\nIf you don\\'t want to use try and except, use dictionary.get() in the following manner:\\n\\n```\\ndef islandPerimeter(self, grid: List[List[int]]) -> int:\\n        ilnd={}\\n        count=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1:\\n                    s=(i,j)\\n                    ilnd[s]=1\\n        for i in ilnd.keys():\\n            if ilnd.get((i[0]-1,i[1]),-1)==-1:\\n                count+=1\\n            if ilnd.get((i[0]+1,i[1]),-1)==-1:\\n                count+=1\\n            if ilnd.get((i[0],i[1]-1),-1)==-1:\\n                count+=1\\n            if ilnd.get((i[0],i[1]+1),-1)==-1:\\n                count+=1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        ilnd={}\\n        count=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1:\\n                    s=(i,j)\\n                    ilnd[s]=1\\n        for i in ilnd.keys():\\n            try:\\n                ilnd[(i[0]-1,i[1])]\\n            except:\\n                count+=1\\n            try:\\n                ilnd[(i[0]+1,i[1])]\\n            except:\\n                count+=1\\n            try:\\n                ilnd[(i[0],i[1]-1)]\\n            except:\\n                count+=1\\n            try:\\n                ilnd[(i[0],i[1]+1)]\\n            except:\\n                count+=1\\n        return count\\n                \\n        \\n```\n```\\ndef islandPerimeter(self, grid: List[List[int]]) -> int:\\n        ilnd={}\\n        count=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1:\\n                    s=(i,j)\\n                    ilnd[s]=1\\n        for i in ilnd.keys():\\n            if ilnd.get((i[0]-1,i[1]),-1)==-1:\\n                count+=1\\n            if ilnd.get((i[0]+1,i[1]),-1)==-1:\\n                count+=1\\n            if ilnd.get((i[0],i[1]-1),-1)==-1:\\n                count+=1\\n            if ilnd.get((i[0],i[1]+1),-1)==-1:\\n                count+=1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 309985,
                "title": "easy-understanding-java-dfs-solution",
                "content": "```java\\nclass Solution {\\n\\n    private int result = 0;\\n\\n    public int islandPerimeter(int[][] grid) {\\n        if (grid == null || grid.length == 0) {\\n            return 0;\\n        }\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n\\n        islandPerimeter(grid, 0, 0, visited);\\n\\n        return result;\\n    }\\n\\n    private void islandPerimeter(int[][] grid, int i, int j, boolean[][] visited) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || visited[i][j]) {\\n            return;\\n        }\\n\\n        visited[i][j] = true;\\n\\n        if (grid[i][j] == 1) {\\n            result += countPerimeter(grid, i, j);\\n        }\\n\\n        islandPerimeter(grid, i + 1, j, visited);\\n        islandPerimeter(grid, i - 1, j, visited);\\n        islandPerimeter(grid, i, j + 1, visited);\\n        islandPerimeter(grid, i, j - 1, visited);\\n    }\\n\\n    private int countPerimeter(int[][] grid, int i, int j) {\\n        int cnt = 4;\\n\\n        if (i - 1 >= 0 && grid[i - 1][j] == 1) {\\n            cnt--;\\n        }\\n        if (i + 1 < grid.length && grid[i + 1][j] == 1) {\\n            cnt--;\\n        }\\n        if (j - 1 >= 0 && grid[i][j - 1] == 1) {\\n            cnt--;\\n        }\\n        if (j + 1 < grid[0].length && grid[i][j + 1] == 1) {\\n            cnt--;\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n\\n    private int result = 0;\\n\\n    public int islandPerimeter(int[][] grid) {\\n        if (grid == null || grid.length == 0) {\\n            return 0;\\n        }\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n\\n        islandPerimeter(grid, 0, 0, visited);\\n\\n        return result;\\n    }\\n\\n    private void islandPerimeter(int[][] grid, int i, int j, boolean[][] visited) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || visited[i][j]) {\\n            return;\\n        }\\n\\n        visited[i][j] = true;\\n\\n        if (grid[i][j] == 1) {\\n            result += countPerimeter(grid, i, j);\\n        }\\n\\n        islandPerimeter(grid, i + 1, j, visited);\\n        islandPerimeter(grid, i - 1, j, visited);\\n        islandPerimeter(grid, i, j + 1, visited);\\n        islandPerimeter(grid, i, j - 1, visited);\\n    }\\n\\n    private int countPerimeter(int[][] grid, int i, int j) {\\n        int cnt = 4;\\n\\n        if (i - 1 >= 0 && grid[i - 1][j] == 1) {\\n            cnt--;\\n        }\\n        if (i + 1 < grid.length && grid[i + 1][j] == 1) {\\n            cnt--;\\n        }\\n        if (j - 1 >= 0 && grid[i][j - 1] == 1) {\\n            cnt--;\\n        }\\n        if (j + 1 < grid[0].length && grid[i][j + 1] == 1) {\\n            cnt--;\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95154,
                "title": "python-detailed-solution-with-explanation",
                "content": "**Solution**\\n\\n**Island Perimeter** https://leetcode.com/problems/island-perimeter/\\n\\n**Count all grids and neighbors: O(MN)**\\n* For every grid which is 1, the contribution to the perimeter is 4 - x where x is the number of neighbors which are 1 as well.\\n```\\nclass Solution(object):\\n    def islandPerimeter(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N, perimeter = len(grid), len(grid[0]), 0\\n        for i in range(M):\\n            for j in range(N):\\n                if grid[i][j] == 1:\\n                    for x,y in ((i+1,j), (i-1,j), (i,j+1), (i, j-1)):\\n                        if 0<=x<M and 0<=y<N:\\n                            perimeter += int(grid[x][y] == 0)\\n                        else:\\n                            perimeter += 1\\n        return perimeter\\n```\\n\\n**Count all 1s and adjust for the neighbors: O(MN)**\\n* When a grid is 1, then add 4 to the perimeter. \\n* If the right neighbor is 1, remove 2 from the perimeter count otherwise there will be a double counting issue. Say a and b are right neighbors. Their real contibution to perimeter is 3+3 which can be expressed as 4 - 2 (common boundary) + 4. \\n* If the down neighbor is 1, remove 2 from perimeter. Same argument as above.\\n```\\nclass Solution(object):\\n    def islandPerimeter(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N, perimeter = len(grid), len(grid[0]), 0\\n        for i in range(M):\\n            for j in range(N):\\n                if grid[i][j] == 1:\\n                    perimeter += 4\\n                    for x,y in ((i+1,j), (i,j+1)):\\n                        if x<M and y<N and grid[x][y]:\\n                            perimeter -= 2\\n        return perimeter\\n``",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def islandPerimeter(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N, perimeter = len(grid), len(grid[0]), 0\\n        for i in range(M):\\n            for j in range(N):\\n                if grid[i][j] == 1:\\n                    for x,y in ((i+1,j), (i-1,j), (i,j+1), (i, j-1)):\\n                        if 0<=x<M and 0<=y<N:\\n                            perimeter += int(grid[x][y] == 0)\\n                        else:\\n                            perimeter += 1\\n        return perimeter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95243,
                "title": "concise-java-solution-without-recursion",
                "content": "```\\npublic int islandPerimeter(int[][] grid) {\\n        if (   grid           == null\\n            || grid.length    == 0\\n            || grid[0]        == null\\n            || grid[0].length == 0){\\n            return 0;    \\n        }\\n        \\n        int[][] directions = new int[][]{\\n            new int[]{+1, 0},\\n            new int[]{-1, 0},\\n            new int[]{0, +1},\\n            new int[]{0, -1}\\n        };\\n        \\n        int ret = 0;\\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                ret += grid[i][j] == 1? helper(grid, i, j, directions): 0;\\n            }\\n        }\\n        return ret;\\n    }\\n\\n    private int helper(int[][] grid, int i, int j, int[][] directions){\\n        int ret = 0;\\n        for (int[] direction: directions){\\n            int ii = i + direction[0];\\n            int jj = j + direction[1];\\n            \\n            ret += (0 <= ii && ii < grid.length && 0 <= jj && jj < grid[0].length && grid[ii][jj] == 1)? 0: +1;\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int islandPerimeter(int[][] grid) {\\n        if (   grid           == null\\n            || grid.length    == 0\\n            || grid[0]        == null\\n            || grid[0].length == 0){\\n            return 0;    \\n        }\\n        \\n        int[][] directions = new int[][]{\\n            new int[]{+1, 0},\\n            new int[]{-1, 0},\\n            new int[]{0, +1},\\n            new int[]{0, -1}\\n        };\\n        \\n        int ret = 0;\\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                ret += grid[i][j] == 1? helper(grid, i, j, directions): 0;\\n            }\\n        }\\n        return ret;\\n    }\\n\\n    private int helper(int[][] grid, int i, int j, int[][] directions){\\n        int ret = 0;\\n        for (int[] direction: directions){\\n            int ii = i + direction[0];\\n            int jj = j + direction[1];\\n            \\n            ret += (0 <= ii && ii < grid.length && 0 <= jj && jj < grid[0].length && grid[ii][jj] == 1)? 0: +1;\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95274,
                "title": "o-mn-time-and-o-1-space-java-solution",
                "content": "\\n    int rn ;\\n    int cn ;\\n    public int islandPerimeter(int[][] grid) {\\n        if(grid==null || grid.length<1 || grid[0].length<1){\\n            return 0;\\n        }\\n        rn = grid.length-1;\\n        cn = grid[0].length-1;\\n        int perimeter=0;\\n        for(int i=0;i<=rn;i++){\\n            for(int j=0;j<=cn;j++){\\n                    if(grid[i][j]==1)\\n                        perimeter+=findCount(grid,i,j);\\n                }\\n            }\\n            return perimeter;\\n        }\\n        int findCount(int[][] grid, int i, int j){\\n            int sum=0;\\n            //top\\n            if(i!=0){\\n                sum+= grid[i-1][j]==0?1:0;\\n            }\\n            else{sum+=1;}\\n            //bottom\\n            if(i!=rn){\\n                sum+= grid[i+1][j]==0?1:0;\\n            }\\n            else{sum+=1;}\\n            //left\\n             if(j!=0){\\n                sum+= grid[i][j-1]==0?1:0;\\n            }\\n            else{sum+=1;}\\n            //right\\n            if(j!=cn){\\n                sum+= grid[i][j+1]==0?1:0;\\n            }\\n            else{sum+=1;}\\n            return sum;\\n        }",
                "solutionTags": [],
                "code": "\\n    int rn ;\\n    int cn ;\\n    public int islandPerimeter(int[][] grid) {\\n        if(grid==null || grid.length<1 || grid[0].length<1){\\n            return 0;\\n        }\\n        rn = grid.length-1;\\n        cn = grid[0].length-1;\\n        int perimeter=0;\\n        for(int i=0;i<=rn;i++){\\n            for(int j=0;j<=cn;j++){\\n                    if(grid[i][j]==1)\\n                        perimeter+=findCount(grid,i,j);\\n                }\\n            }\\n            return perimeter;\\n        }\\n        int findCount(int[][] grid, int i, int j){\\n            int sum=0;\\n            //top\\n            if(i!=0){\\n                sum+= grid[i-1][j]==0?1:0;\\n            }\\n            else{sum+=1;}\\n            //bottom\\n            if(i!=rn){\\n                sum+= grid[i+1][j]==0?1:0;\\n            }\\n            else{sum+=1;}\\n            //left\\n             if(j!=0){\\n                sum+= grid[i][j-1]==0?1:0;\\n            }\\n            else{sum+=1;}\\n            //right\\n            if(j!=cn){\\n                sum+= grid[i][j+1]==0?1:0;\\n            }\\n            else{sum+=1;}\\n            return sum;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3887150,
                "title": "simplest-javascript-solution-beats-100-in-time-98-on-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor 15 minutes, I kepth thinking then realised, I could establis relationship b/w total boxes & perimeter after subtracting the overlapping edges\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate total number of land boxes, multiply by 4 to get total perimeter inclusive of overlapping edges\\n\\nCalculate overlapping edges,  multiply by 2 as 1 edge represents 2 squares combined.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/89e025c0-ddb3-4064-bce3-8a80e0f547f0_1691599277.660987.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number} 8:47 - 9:02 - 9:10 - 9:15\\n */ \\nvar islandPerimeter = function(grid) {\\n\\n    let totalPerimeter = 0;\\n    let overlapPerimeter = 0\\n\\n    for(let i=0; i< grid.length; i++){\\n\\n        for(let j=0; j< grid[i].length; j++){\\n            if(grid[i][j] === 0){\\n                continue;\\n            }\\n            if(grid[i][j] === 1){\\n                totalPerimeter +=1;\\n            }\\n            if( j< grid[i].length-1 && grid[i][j] === 1 && grid[i][j+1] === 1){\\n                overlapPerimeter++;\\n            }\\n            if(i < grid.length-1 && grid[i][j] === 1 && grid[i+1][j] === 1 ){\\n                overlapPerimeter++;\\n            }\\n        }\\n    }\\n    totalPerimeter = 4*totalPerimeter;\\n    overlapPerimeter = overlapPerimeter*2;\\n\\n    return totalPerimeter- overlapPerimeter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number} 8:47 - 9:02 - 9:10 - 9:15\\n */ \\nvar islandPerimeter = function(grid) {\\n\\n    let totalPerimeter = 0;\\n    let overlapPerimeter = 0\\n\\n    for(let i=0; i< grid.length; i++){\\n\\n        for(let j=0; j< grid[i].length; j++){\\n            if(grid[i][j] === 0){\\n                continue;\\n            }\\n            if(grid[i][j] === 1){\\n                totalPerimeter +=1;\\n            }\\n            if( j< grid[i].length-1 && grid[i][j] === 1 && grid[i][j+1] === 1){\\n                overlapPerimeter++;\\n            }\\n            if(i < grid.length-1 && grid[i][j] === 1 && grid[i+1][j] === 1 ){\\n                overlapPerimeter++;\\n            }\\n        }\\n    }\\n    totalPerimeter = 4*totalPerimeter;\\n    overlapPerimeter = overlapPerimeter*2;\\n\\n    return totalPerimeter- overlapPerimeter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3880485,
                "title": "simple-iterative-solution-no-dfs-or-bfs",
                "content": "# Approach\\nWe need only to check the immediate neighbours of our current position.\\n\\nIf we encounter water or we go out of bounds then add to our total.\\n\\n# Complexity\\n- Time complexity: O(M * N) for the 2 nested loops\\n\\n- Space complexity: O(1) as we are not using any extra memory\\n\\n# Code\\n```\\nclass Solution {\\n    // int dfs(vector<vector<int>>& grid, int i, int j) {\\n    //     if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == 0) return 1;\\n    //     if(grid[i][j] == 1) return 0;\\n    //     return dfs(grid, i + 1, j) + dfs(gri)\\n    // }\\npublic:\\n    vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[0].size(); j++) {\\n                if(grid[i][j] == 1) {\\n                    int add = 4; // default to 4 if all neighbours are water or are out of bounds\\n                    for(auto [dr, dc] : dirs) {\\n                        int x = i + dr, y = j + dc;\\n                        // If we come across land then decrement by one\\n                        if(x >= 0 && y >= 0 && x < grid.size() && y < grid[0].size() && grid[x][y] == 1) add--;\\n                    }\\n                    ans += add;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // int dfs(vector<vector<int>>& grid, int i, int j) {\\n    //     if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == 0) return 1;\\n    //     if(grid[i][j] == 1) return 0;\\n    //     return dfs(grid, i + 1, j) + dfs(gri)\\n    // }\\npublic:\\n    vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[0].size(); j++) {\\n                if(grid[i][j] == 1) {\\n                    int add = 4; // default to 4 if all neighbours are water or are out of bounds\\n                    for(auto [dr, dc] : dirs) {\\n                        int x = i + dr, y = j + dc;\\n                        // If we come across land then decrement by one\\n                        if(x >= 0 && y >= 0 && x < grid.size() && y < grid[0].size() && grid[x][y] == 1) add--;\\n                    }\\n                    ans += add;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812552,
                "title": "c-three-approaches",
                "content": "\\n\\n# DFS\\n```\\nclass Solution {\\nprivate: \\n    int p = 0;\\n    void dfs(vector<vector<int>>&grid, int i, int j) {\\n        // check if out of bounds or on bordering water\\n        if (i < 0 || j < 0 || i > grid.size() - 1 || j > grid[0].size() - 1 || grid[i][j] == 0) {\\n            ++p;\\n            return; \\n        }\\n        if (grid[i][j] == -1) return; \\n        grid[i][j] = -1; // mark visited\\n        dfs(grid, i + 1, j);\\n        dfs(grid, i - 1, j);\\n        dfs(grid, i, j + 1);\\n        dfs(grid, i, j - 1);\\n    }\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        for (int i = 0; i < grid.size(); ++i) \\n            for (int j = 0; j < grid[0].size(); ++j) \\n                if (grid[i][j] == 1) dfs(grid, i, j);\\n        return p; \\n    }\\n};\\n```\\n\\n\\n\\n# Pure Conditional\\n```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int p = 0;\\n        for (int i = 0; i < grid.size(); ++i) {\\n            for (int j = 0; j < grid[0].size(); ++j) {\\n                if (grid[i][j]) {\\n                    if (i == 0                  || !grid[i - 1][j]) ++p; // check row above\\n                    if (i == grid.size() - 1    || !grid[i + 1][j]) ++p; // check row below\\n                    if (j == 0                  || !grid[i][j - 1]) ++p; // check col left\\n                    if (j == grid[0].size() - 1 || !grid[i][j + 1]) ++p; // check col right\\n                }\\n            }\\n        }\\n        return p;\\n    }\\n};\\n```\\n\\n# Conditional Math\\n```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        // count land and subtract water that borders land twice\\n        int c = 0, t = 0; \\n        for (int i = 0; i < grid.size(); ++i) {\\n            for (int j = 0; j < grid[0].size(); ++j) {\\n                if (grid[i][j]) {\\n                    ++c;\\n                    if (i != 0 && grid[i - 1][j] == 1) ++t;\\n                    if (j != 0 && grid[i][j - 1] == 1) ++t;\\n                }\\n            }\\n        }\\n        return 4 * c - 2 * t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate: \\n    int p = 0;\\n    void dfs(vector<vector<int>>&grid, int i, int j) {\\n        // check if out of bounds or on bordering water\\n        if (i < 0 || j < 0 || i > grid.size() - 1 || j > grid[0].size() - 1 || grid[i][j] == 0) {\\n            ++p;\\n            return; \\n        }\\n        if (grid[i][j] == -1) return; \\n        grid[i][j] = -1; // mark visited\\n        dfs(grid, i + 1, j);\\n        dfs(grid, i - 1, j);\\n        dfs(grid, i, j + 1);\\n        dfs(grid, i, j - 1);\\n    }\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        for (int i = 0; i < grid.size(); ++i) \\n            for (int j = 0; j < grid[0].size(); ++j) \\n                if (grid[i][j] == 1) dfs(grid, i, j);\\n        return p; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int p = 0;\\n        for (int i = 0; i < grid.size(); ++i) {\\n            for (int j = 0; j < grid[0].size(); ++j) {\\n                if (grid[i][j]) {\\n                    if (i == 0                  || !grid[i - 1][j]) ++p; // check row above\\n                    if (i == grid.size() - 1    || !grid[i + 1][j]) ++p; // check row below\\n                    if (j == 0                  || !grid[i][j - 1]) ++p; // check col left\\n                    if (j == grid[0].size() - 1 || !grid[i][j + 1]) ++p; // check col right\\n                }\\n            }\\n        }\\n        return p;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        // count land and subtract water that borders land twice\\n        int c = 0, t = 0; \\n        for (int i = 0; i < grid.size(); ++i) {\\n            for (int j = 0; j < grid[0].size(); ++j) {\\n                if (grid[i][j]) {\\n                    ++c;\\n                    if (i != 0 && grid[i - 1][j] == 1) ++t;\\n                    if (j != 0 && grid[i][j - 1] == 1) ++t;\\n                }\\n            }\\n        }\\n        return 4 * c - 2 * t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558401,
                "title": "python-solution-beats-61-73-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to find number of non land tiles(water or boundary)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntraverse the gienn grid to find a 1 and then check all four directions of the tile and check if there are water tiles or boundary of the grid\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        r=len(grid)\\n        c=len(grid[0])\\n        per=0\\n        def walaco(i,j,grid):\\n            w=0\\n            r=len(grid)\\n            c=len(grid[0])\\n            if j==0 or grid[i][j-1]==0 :\\n                w+=1  \\n            if i==0 or grid[i-1][j]==0:\\n                w+=1\\n            if i==r-1 or grid[i+1][j]==0 :\\n                w+=1\\n            if j==c-1 or grid[i][j+1]==0:\\n                w+=1\\n            return w\\n        for i in range(r):\\n            for j in range(c):\\n                if grid[i][j]==1:\\n                    per+=walaco(i,j,grid)\\n        return per\\n\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        r=len(grid)\\n        c=len(grid[0])\\n        per=0\\n        def walaco(i,j,grid):\\n            w=0\\n            r=len(grid)\\n            c=len(grid[0])\\n            if j==0 or grid[i][j-1]==0 :\\n                w+=1  \\n            if i==0 or grid[i-1][j]==0:\\n                w+=1\\n            if i==r-1 or grid[i+1][j]==0 :\\n                w+=1\\n            if j==c-1 or grid[i][j+1]==0:\\n                w+=1\\n            return w\\n        for i in range(r):\\n            for j in range(c):\\n                if grid[i][j]==1:\\n                    per+=walaco(i,j,grid)\\n        return per\\n\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390379,
                "title": "c-solution-easy-dfs-queue-iterative",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int r=grid.size(),c=grid[0].size();\\n        int dir_x[]={0,0,1,-1};\\n        int dir_y[]={1,-1,0,0}; \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(grid[i][j]==0 || grid[i][j]==-1)\\n                    continue;\\n                queue<pair<int,int>> q;\\n                q.push({i,j});\\n                grid[i][j]=-1;\\n                while(!q.empty()){\\n                    auto front=q.front();\\n                    q.pop();\\n                    for(int d=0;d<4;d++){\\n                        int qr=front.first + dir_x[d];\\n                        int qc=front.second + dir_y[d];\\n                        if(qr<0 || qr>=r || qc<0 || qc>=c || grid[qr][qc] == 0){\\n                            ans++;\\n                            continue;\\n                        }\\n                        if(grid[qr][qc]==-1) continue;\\n                        q.push({qr,qc});\\n                        grid[qr][qc]=-1;\\n                    }\\n                }\\n            }\\n        }  \\n        return ans;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int r=grid.size(),c=grid[0].size();\\n        int dir_x[]={0,0,1,-1};\\n        int dir_y[]={1,-1,0,0}; \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(grid[i][j]==0 || grid[i][j]==-1)\\n                    continue;\\n                queue<pair<int,int>> q;\\n                q.push({i,j});\\n                grid[i][j]=-1;\\n                while(!q.empty()){\\n                    auto front=q.front();\\n                    q.pop();\\n                    for(int d=0;d<4;d++){\\n                        int qr=front.first + dir_x[d];\\n                        int qc=front.second + dir_y[d];\\n                        if(qr<0 || qr>=r || qc<0 || qc>=c || grid[qr][qc] == 0){\\n                            ans++;\\n                            continue;\\n                        }\\n                        if(grid[qr][qc]==-1) continue;\\n                        q.push({qr,qc});\\n                        grid[qr][qc]=-1;\\n                    }\\n                }\\n            }\\n        }  \\n        return ans;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332380,
                "title": "the-simplest-code-of-all-time-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        per=0\\n        connections=0\\n        length_row=len(grid)\\n        length_col=len(grid[0])\\n        for x in range(0,length_row):\\n            for y in range(0,length_col):\\n                if grid[x][y]==1:\\n                    per+=4\\n                    #checking top\\n                    if x!=0 and grid[x-1][y]==1:\\n                        connections+=1\\n                    #checking left\\n                    if y!=0 and grid[x][y-1]==1:\\n                        connections+=1\\n        return (per-(connections*2))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        per=0\\n        connections=0\\n        length_row=len(grid)\\n        length_col=len(grid[0])\\n        for x in range(0,length_row):\\n            for y in range(0,length_col):\\n                if grid[x][y]==1:\\n                    per+=4\\n                    #checking top\\n                    if x!=0 and grid[x-1][y]==1:\\n                        connections+=1\\n                    #checking left\\n                    if y!=0 and grid[x][y-1]==1:\\n                        connections+=1\\n        return (per-(connections*2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329396,
                "title": "island-perimeter-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int i, j, ans=0;\\n        for(i=0 ; i<grid.size() ; i++)\\n        {\\n            for(j=0 ; j<grid[i].size() ; j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    if(i==0 || grid[i-1][j]==0)\\n                    {\\n                        ans++;\\n                    }\\n                    if(i==grid.size()-1 || grid[i+1][j]==0)\\n                    {\\n                        ans++;\\n                    }\\n                    if(j==0 || grid[i][j-1]==0)\\n                    {\\n                        ans++;\\n                    }\\n                    if(j==grid[i].size()-1 || grid[i][j+1]==0)\\n                    {\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int i, j, ans=0;\\n        for(i=0 ; i<grid.size() ; i++)\\n        {\\n            for(j=0 ; j<grid[i].size() ; j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    if(i==0 || grid[i-1][j]==0)\\n                    {\\n                        ans++;\\n                    }\\n                    if(i==grid.size()-1 || grid[i+1][j]==0)\\n                    {\\n                        ans++;\\n                    }\\n                    if(j==0 || grid[i][j-1]==0)\\n                    {\\n                        ans++;\\n                    }\\n                    if(j==grid[i].size()-1 || grid[i][j+1]==0)\\n                    {\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921474,
                "title": "about-98-36-faster-python-solution",
                "content": "![Screenshot 2022-12-17 at 16.46.24.png](https://assets.leetcode.com/users/images/84029cf5-b899-4210-b7e4-69aba07afe4d_1671292840.7326882.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        answer = 0\\n        n, m = len(grid), len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j]:\\n                    answer+=(i==0 or grid[i-1][j]==0)+(j==0 or grid[i][j-1]==0)+(i==n-1 or grid[i+1][j]==0)+(j==m-1 or grid[i][j+1]==0)\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        answer = 0\\n        n, m = len(grid), len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j]:\\n                    answer+=(i==0 or grid[i-1][j]==0)+(j==0 or grid[i][j-1]==0)+(i==n-1 or grid[i+1][j]==0)+(j==m-1 or grid[i][j+1]==0)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847200,
                "title": "easiest-solution-c-plusplus-simple-dfs-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    int solve(vector<vector<int>>& grid,int sr,int sc){\\n        if(sr>=grid.size() || sc>=grid[0].size() || sr<0 || sc<0 || grid[sr][sc]==0) return 1;\\n        if(grid[sr][sc]==-1) return 0;\\n        if(grid[sr][sc]==1) grid[sr][sc]=-1;\\n        return solve(grid,sr-1,sc)+solve(grid,sr+1,sc)+solve(grid,sr,sc-1)+solve(grid,sr,sc+1);\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    return solve(grid,i,j);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    int solve(vector<vector<int>>& grid,int sr,int sc){\\n        if(sr>=grid.size() || sc>=grid[0].size() || sr<0 || sc<0 || grid[sr][sc]==0) return 1;\\n        if(grid[sr][sc]==-1) return 0;\\n        if(grid[sr][sc]==1) grid[sr][sc]=-1;\\n        return solve(grid,sr-1,sc)+solve(grid,sr+1,sc)+solve(grid,sr,sc-1)+solve(grid,sr,sc+1);\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    return solve(grid,i,j);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646117,
                "title": "easy-cpp-solution-o-n-2",
                "content": "class Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int ans=0;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    int up=0,down=0,left=0,right=0;\\n                    if(i-1>=0 && grid[i-1][j]==1) up=1;\\n                    if(j-1>=0 && grid[i][j-1]==1) left=1;\\n                    if(j+1 <=grid[0].size()-1 && grid[i][j+1]==1) right=1;\\n                    if(i+1 <grid.size() && grid[i+1][j]==1) down=1;\\n                    \\n                    ans+=4-up-down-left-right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int ans=0;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    int up=0,down=0,left=0,right=0;\\n                    if(i-1>=0 && grid[i-1][j]==1) up=1;\\n                    if(j-1>=0 && grid[i][j-1]==1) left=1;\\n                    if(j+1 <=grid[0].size()-1 && grid[i][j+1]==1) right=1;\\n                    if(i+1 <grid.size() && grid[i+1][j]==1) down=1;\\n                    \\n                    ans+=4-up-down-left-right;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2562954,
                "title": "python-dfs-easy",
                "content": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        ### dfs in grid\\n        perimeter = 0\\n        visited = set()\\n        def dfs(grid,i,j,visited):\\n            nonlocal perimeter\\n            row = len(grid)\\n            col = len(grid[0])\\n            if (i,j) in visited:\\n                return\\n            if i<0 or i>=row or j<0 or j>=col or grid[i][j] == 0:\\n                perimeter+=1\\n                return\\n            visited.add((i,j))\\n            # call in 4 directions\\n            directions = [[0,1],[1,0],[0,-1],[-1,0]]\\n            for u,v in directions:\\n                dfs(grid,i+u,j+v,visited)\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1 and (i,j) not in visited:\\n                    dfs(grid, i,j, visited)\\n        return perimeter\\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        ### dfs in grid\\n        perimeter = 0\\n        visited = set()\\n        def dfs(grid,i,j,visited):\\n            nonlocal perimeter\\n            row = len(grid)\\n            col = len(grid[0])\\n            if (i,j) in visited:\\n                return\\n            if i<0 or i>=row or j<0 or j>=col or grid[i][j] == 0:\\n                perimeter+=1\\n                return\\n            visited.add((i,j))\\n            # call in 4 directions\\n            directions = [[0,1],[1,0],[0,-1],[-1,0]]\\n            for u,v in directions:\\n                dfs(grid,i+u,j+v,visited)\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1 and (i,j) not in visited:\\n                    dfs(grid, i,j, visited)\\n        return perimeter\\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562047,
                "title": "no-one-can-explain-better-javascript",
                "content": "var islandPerimeter = function(grid) {\\n    let perimeter = 0\\n    let row = grid.length\\n    let col = grid[0].length\\n    \\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] === 1) {\\n                if (i === 0 || i > 0 && grid[i-1][j] === 0) perimeter++ \\n                if (i === row-1 || i < row-1 && grid[i+1][j] === 0) perimeter++              \\n                if (j === 0 || j > 0 && grid[i][j-1] === 0) perimeter++\\n                if (j === col - 1 || j < col && grid[i][j+1] === 0) perimeter++\\n            }\\n        }\\n    }\\n    \\n    return perimeter\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var islandPerimeter = function(grid) {\\n    let perimeter = 0\\n    let row = grid.length\\n    let col = grid[0].length\\n    \\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] === 1) {\\n                if (i === 0 || i > 0 && grid[i-1][j] === 0) perimeter++ \\n                if (i === row-1 || i < row-1 && grid[i+1][j] === 0) perimeter++              \\n                if (j === 0 || j > 0 && grid[i][j-1] === 0) perimeter++\\n                if (j === col - 1 || j < col && grid[i][j+1] === 0) perimeter++\\n            }\\n        }\\n    }\\n    \\n    return perimeter\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2450583,
                "title": "c-easy-solution-simple-approach-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int m=0;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    m = m + 4;\\n                    if(i>0 and grid[i-1][j]==1)\\n                        m--;\\n                    if(i<row-1 and grid[i+1][j]==1)\\n                        m--;\\n                    if(j>0 and grid[i][j-1]==1)\\n                        m--;\\n                    if(j<col-1 and grid[i][j+1]==1)\\n                        m--;\\n                }\\n            } \\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int m=0;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    m = m + 4;\\n                    if(i>0 and grid[i-1][j]==1)\\n                        m--;\\n                    if(i<row-1 and grid[i+1][j]==1)\\n                        m--;\\n                    if(j>0 and grid[i][j-1]==1)\\n                        m--;\\n                    if(j<col-1 and grid[i][j+1]==1)\\n                        m--;\\n                }\\n            } \\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422863,
                "title": "c-easy-to-understand-solution-using-bfs-time-complexity-o-n-n-space-complexity-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int i, j, c_x, c_y, r=grid.size(), c=grid[0].size(), perimeter=0;\\n        vector<pair<int, int>> dirn={{1, 0}, {0, 1},{-1, 0},{0, -1}};\\n        \\n        // Below for loop is for finding the girst block of island from which we can strat BFS\\n        for(i=0;i<r;i++)\\n        {\\n            for(j=0;j<c;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    c_x=i;\\n                    c_y=j;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        queue<pair<int, int>> Q;\\n        Q.push({c_x, c_y});\\n        grid[c_x][c_y]=2; // visited land cells are marked with 2.\\n        \\n        \\n        while(Q.empty()==false)\\n        {\\n            pair<int, int> top=Q.front();\\n            Q.pop();\\n            \\n            int c_x=top.first;\\n            int c_y=top.second;\\n            \\n            for(j=0;j<4;j++)\\n            {\\n                pair<int, int> Direction=dirn[j];\\n                int d_x=Direction.first;\\n                int d_y=Direction.second;\\n                \\n                if((c_x+d_x<r && c_x+d_x>=0) && (c_y+d_y<c && c_y+d_y>=0))\\n                {\\n                    if(grid[c_x+d_x][c_y+d_y]==1)\\n                    {\\n                        pair<int, int> new_pair={c_x+d_x, c_y+d_y};\\n                        Q.push(new_pair);\\n                        grid[c_x+d_x][c_y+d_y]=2;\\n                        \\n                        continue;\\n                    }\\n                    else if(grid[c_x+d_x][c_y+d_y]==0)\\n                    {\\n                        perimeter++;\\n                        continue;\\n                    }\\n                    else if(grid[c_x+d_x][c_y+d_y]==2)\\n                    {\\n                        continue;\\n                    }\\n                    \\n                }\\n                \\n                perimeter++;\\n            }\\n            \\n        }\\n        \\n        return perimeter;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int i, j, c_x, c_y, r=grid.size(), c=grid[0].size(), perimeter=0;\\n        vector<pair<int, int>> dirn={{1, 0}, {0, 1},{-1, 0},{0, -1}};\\n        \\n        // Below for loop is for finding the girst block of island from which we can strat BFS\\n        for(i=0;i<r;i++)\\n        {\\n            for(j=0;j<c;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    c_x=i;\\n                    c_y=j;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        queue<pair<int, int>> Q;\\n        Q.push({c_x, c_y});\\n        grid[c_x][c_y]=2; // visited land cells are marked with 2.\\n        \\n        \\n        while(Q.empty()==false)\\n        {\\n            pair<int, int> top=Q.front();\\n            Q.pop();\\n            \\n            int c_x=top.first;\\n            int c_y=top.second;\\n            \\n            for(j=0;j<4;j++)\\n            {\\n                pair<int, int> Direction=dirn[j];\\n                int d_x=Direction.first;\\n                int d_y=Direction.second;\\n                \\n                if((c_x+d_x<r && c_x+d_x>=0) && (c_y+d_y<c && c_y+d_y>=0))\\n                {\\n                    if(grid[c_x+d_x][c_y+d_y]==1)\\n                    {\\n                        pair<int, int> new_pair={c_x+d_x, c_y+d_y};\\n                        Q.push(new_pair);\\n                        grid[c_x+d_x][c_y+d_y]=2;\\n                        \\n                        continue;\\n                    }\\n                    else if(grid[c_x+d_x][c_y+d_y]==0)\\n                    {\\n                        perimeter++;\\n                        continue;\\n                    }\\n                    else if(grid[c_x+d_x][c_y+d_y]==2)\\n                    {\\n                        continue;\\n                    }\\n                    \\n                }\\n                \\n                perimeter++;\\n            }\\n            \\n        }\\n        \\n        return perimeter;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349558,
                "title": "sheer-observation-and-that-s-it",
                "content": "class Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        \\n        int cnt =0;\\n        for(int i=0;i<grid.size( );i++){\\n            \\n            for(int j=0;j<grid[i].size( );j++){\\n                \\n                if(grid[i][j]==1){\\n                    \\n                    if(i-1<0||grid[i-1][j]==0)\\n                        cnt++;\\n                    \\n                    if(i+1==grid.size( )||grid[i+1][j]==0)\\n                        cnt++;\\n                    \\n                    if(j+1==grid[i].size( )||grid[i][j+1]==0)\\n                        cnt++;\\n                    \\n                    if(j-1<0||grid[i][j-1]==0)\\n                        cnt++;\\n                    \\n                    else\\n                        continue;\\n                    \\n                 }\\n                \\n                else\\n                    continue;\\n                \\n            }\\n            \\n        }\\n        \\n        return cnt;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        \\n        int cnt =0;\\n        for(int i=0;i<grid.size( );i++){\\n            \\n            for(int j=0;j<grid[i].size( );j++){\\n                \\n                if(grid[i][j]==1){\\n                    \\n                    if(i-1<0||grid[i-1][j]==0)\\n                        cnt++;\\n                    \\n                    if(i+1==grid.size( )||grid[i+1][j]==0)\\n                        cnt++;\\n                    \\n                    if(j+1==grid[i].size( )||grid[i][j+1]==0)\\n                        cnt++;\\n                    \\n                    if(j-1<0||grid[i][j-1]==0)\\n                        cnt++;\\n                    \\n                    else\\n                        continue;\\n                    \\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 2340032,
                "title": "c-begineer-friendly-short-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!!***\\n\\t\\n\\tint islandPerimeter(vector<vector<int>>& grid) {\\n        \\n        int r=grid.size(), c=grid[0].size(), ans=0;\\n        \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(grid[i][j]==1){\\n                    ans+=4;    //for each block, perimeter = 4\\n                    \\n                    if(i>0 && grid[i-1][j]==1) ans -=2;  //upwards. subtract 2 since middle edge is counted twice\\n                    if(j>0 && grid[i][j-1]==1) ans -=2;  //leftwards                  \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!!***\\n\\t\\n\\tint islandPerimeter(vector<vector<int>>& grid) {\\n        \\n        int r=grid.size(), c=grid[0].size(), ans=0;\\n        \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(grid[i][j]==1){\\n                    ans+=4;    //for each block, perimeter = 4\\n                    \\n                    if(i>0 && grid[i-1][j]==1) ans -=2;  //upwards. subtract 2 since middle edge is counted twice\\n                    if(j>0 && grid[i][j-1]==1) ans -=2;  //leftwards                  \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2338639,
                "title": "c-simple",
                "content": "![image](https://assets.leetcode.com/users/images/f6e14a3d-e551-4bb8-8a84-2b13a13f3f07_1658880192.6819627.png)\\n```\\n\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        \\n                \\n        int res = 0;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    res += (i == 0 || grid[i-1][j] == 0 ? 1 : 0);\\n                    res += (i == r-1 || grid[i+1][j] == 0 ? 1 : 0);\\n                    res += (j == 0 || grid[i][j-1] == 0 ? 1 : 0);\\n                    res += (j == c-1 || grid[i][j+1] == 0 ? 1 : 0);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        \\n                \\n        int res = 0;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    res += (i == 0 || grid[i-1][j] == 0 ? 1 : 0);\\n                    res += (i == r-1 || grid[i+1][j] == 0 ? 1 : 0);\\n                    res += (j == 0 || grid[i][j-1] == 0 ? 1 : 0);\\n                    res += (j == c-1 || grid[i][j+1] == 0 ? 1 : 0);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322489,
                "title": "java-dfs-detailed-explanation",
                "content": "class Solution {\\n\\n    public int islandPerimeter(int[][] grid) {\\n        //this can track if we have already visited an index.\\n        Set<String> visitSet = new HashSet();\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0; j<grid[0].length;j++){\\n                if(grid[i][j]==1)\\n                    return helper(grid, i, j, visitSet);\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    //recursive helper function\\n    private int helper(int[][] grid, int i, int j, Set<String> visitSet){\\n        /*  each of these conditions below indicate the current index has a border which should be counted to\\n\\t\\t\\tour perimeter.\\n            Ex:\\n            0 1 0 0\\n            1 1 1 0\\n            0 1 0 0\\n            1 1 0 0\\n            When you are on index (0,1), it has border on 3 sides so we should add 3 to the perimeter, so we               \\n\\t\\t\\ttry to go up and find it is the border of the island and add, same when we go left and right.\\n            \\n            When you are on index (1,1) it is surounded by water because it has 1s on all 4 sides we dont have             \\n\\t\\t\\tto count anything, just go through the adjacent boxes.\\n        */\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)\\n            return 1;\\n        //we dont want to count any borders twice. so return 0 if you have already visited and counted.\\n        if(visitSet.contains(i+\",\"+j))\\n            return 0;\\n        \\n        visitSet.add(i+\",\"+j);\\n        \\n        // count through all 4 directions.\\n        int perimeter = helper(grid,i-1,j,visitSet);\\n        perimeter+=helper(grid,i+1,j,visitSet);\\n        perimeter+=helper(grid,i,j-1,visitSet);\\n        perimeter+=helper(grid,i,j+1,visitSet);\\n        \\n        return perimeter;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\n    public int islandPerimeter(int[][] grid) {\\n        //this can track if we have already visited an index.\\n        Set<String> visitSet = new HashSet();\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0; j<grid[0].length;j++){\\n                if(grid[i][j]==1)\\n                    return helper(grid, i, j, visitSet);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2312599,
                "title": "vv-easy-java-dfs-easy-understandable-code",
                "content": "class Solution {\\n\\n    static int mx = 0;\\n    public int islandPerimeter(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        boolean[][] vis = new boolean[m][n];\\n        // int max = 0;\\n        mx = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                if(grid[i][j] == 1 && vis[i][j] == false){\\n                    \\n                    int ans = dfs(grid, i,j,vis);\\n                    \\n                }\\n            }\\n        }\\n        \\n        return mx;\\n        \\n        \\n    }\\n    \\n    \\n    public static int dfs(int[][] grid, int i, int j,boolean[][] vis){\\n        \\n        int m = 1;\\n        \\n        if(i<0 || j<0 || i>=grid.length || j>= grid[0].length || grid[i][j] == 0){\\n            return 0;\\n        }\\n        if(vis[i][j] == true){\\n            return 1;\\n        }\\n        \\n        vis[i][j] = true;\\n        \\n        // System.out.print(m);\\n        // int u,l,r,d = 0;\\n        \\n        int u= dfs(grid, i-1,j,vis);\\n        int r= dfs(grid, i,j+1,vis);\\n        int d= dfs(grid, i+1,j,vis);\\n        int l= dfs(grid, i,j-1,vis);\\n        \\n        // System.out.println(\"u\"+u+\"r\"+r+\"d\"+d+\"l\"+l);\\n        mx += 4-(u+l+d+r);\\n        \\n        \\n        \\n        \\n        return m;\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\n    static int mx = 0;\\n    public int islandPerimeter(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        boolean[][] vis = new boolean[m][n];\\n        // int max = 0;\\n        mx = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                if(grid[i][j] == 1 && vis[i][j] == false){\\n                    \\n                    int ans = dfs(grid, i,j,vis);\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2299940,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        \\n        int perimeter =0;//Initialize the perimeter\\n        \\n        //Traverse the whole array and check if 1 comes i.e. the land part. \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                //Add 4 i.e the perimeter\\n                if(grid[i][j]==1){\\n                perimeter+=4;\\n                \\n                //Check if the other land is connected to the previous or after that land\\n                if(i>0 && grid[i-1][j]==1){\\n                    perimeter-=2;\\n                }\\n                if(j>0 && grid[i][j-1]==1){\\n                    perimeter-=2;\\n                }\\n            }\\n        }\\n        }\\n        return perimeter;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        \\n        int perimeter =0;//Initialize the perimeter\\n        \\n        //Traverse the whole array and check if 1 comes i.e. the land part. \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                //Add 4 i.e the perimeter\\n                if(grid[i][j]==1){\\n                perimeter+=4;\\n                \\n                //Check if the other land is connected to the previous or after that land\\n                if(i>0 && grid[i-1][j]==1){\\n                    perimeter-=2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2229356,
                "title": "java-with-dfs",
                "content": "```\\nclass Solution {\\n    //dfs approach\\n    int count = 0;\\n    public int islandPerimeter(int[][] grid) {\\n        \\n        int noOfRows = grid.length;\\n        int noOfCols = grid[0].length;\\n        \\n        for(int i=0; i<noOfRows; i++) {\\n            for(int j=0; j<noOfCols; j++) {\\n                \\n                if(grid[i][j] == 1) {\\n                    \\n                    // call dfs traversal\\n                    dfsTraversal(i,j,grid);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    public void dfsTraversal(int row, int col, int[][] grid) {\\n        \\n        // this way you only want to count the edges that touch water.\\n        if(row<0 || col<0 || row>=grid.length || col>=grid[0].length || grid[row][col] == 0) {\\n            count+=1;\\n            return;\\n        }\\n        \\n        // exit condition - to avoid traversing it again and again and going to infinite loop\\n        if(grid[row][col] == -1) {\\n            return;\\n        }\\n        \\n        // marking the cell as visited \\n        grid[row][col] = -1;\\n        \\n        dfsTraversal(row, col+1, grid);       \\n        dfsTraversal(row+1, col, grid);\\n        dfsTraversal(row-1, col, grid);\\n        dfsTraversal(row, col-1, grid);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n    //dfs approach\\n    int count = 0;\\n    public int islandPerimeter(int[][] grid) {\\n        \\n        int noOfRows = grid.length;\\n        int noOfCols = grid[0].length;\\n        \\n        for(int i=0; i<noOfRows; i++) {\\n            for(int j=0; j<noOfCols; j++) {\\n                \\n                if(grid[i][j] == 1) {\\n                    \\n                    // call dfs traversal\\n                    dfsTraversal(i,j,grid);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2229040,
                "title": "python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        rows, cols = len(grid), len(grid[0])\\n        directions = ((-1, 0), (1, 0), (0, 1), (0, -1))\\n        perimeter = 0\\n        \\n        visited = set()\\n        \\n        def bfs(row, col):\\n            queue = collections.deque()\\n            queue.append((row, col))\\n            visited.add((row, col))\\n            count = 0\\n            \\n            while queue:\\n                node_row, node_col = queue.popleft()\\n                \\n                for dir_r, dir_c in directions:\\n                    new_r, new_c = node_row + dir_r, node_col + dir_c\\n                    # check what the neighbor is - if water or out of boundary we can increment count\\n                    is_outside = new_r not in range(rows) or new_c not in range(cols)\\n                    is_water = not is_outside and grid[new_r][new_c] == 0\\n                    is_land = not is_outside and grid[new_r][new_c] == 1\\n                    if is_water or is_outside:\\n                        count += 1\\n                    # only want to search islands we havent visited\\n                    if not is_outside and is_land and (new_r, new_c) not in visited:\\n                        queue.append((new_r, new_c))\\n                        visited.add((new_r, new_c))\\n            return count\\n                        \\n        \\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                # check if island - bfs if so as long as not visited\\n                is_island = grid[r][c] == 1\\n                if is_island and (r, c) not in visited:\\n                    perimeter = bfs(r, c)\\n        \\n        return perimeter\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        rows, cols = len(grid), len(grid[0])\\n        directions = ((-1, 0), (1, 0), (0, 1), (0, -1))\\n        perimeter = 0\\n        \\n        visited = set()\\n        \\n        def bfs(row, col):\\n            queue = collections.deque()\\n            queue.append((row, col))\\n            visited.add((row, col))\\n            count = 0\\n            \\n            while queue:\\n                node_row, node_col = queue.popleft()\\n                \\n                for dir_r, dir_c in directions:\\n                    new_r, new_c = node_row + dir_r, node_col + dir_c\\n                    # check what the neighbor is - if water or out of boundary we can increment count\\n                    is_outside = new_r not in range(rows) or new_c not in range(cols)\\n                    is_water = not is_outside and grid[new_r][new_c] == 0\\n                    is_land = not is_outside and grid[new_r][new_c] == 1\\n                    if is_water or is_outside:\\n                        count += 1\\n                    # only want to search islands we havent visited\\n                    if not is_outside and is_land and (new_r, new_c) not in visited:\\n                        queue.append((new_r, new_c))\\n                        visited.add((new_r, new_c))\\n            return count\\n                        \\n        \\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                # check if island - bfs if so as long as not visited\\n                is_island = grid[r][c] == 1\\n                if is_island and (r, c) not in visited:\\n                    perimeter = bfs(r, c)\\n        \\n        return perimeter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213108,
                "title": "very-easy-concept-with-simple-explanation-using-dfs",
                "content": "Please Upvote for motivation\\n```\\n    int m, n, res=0;\\n    //Time =O( m*n) and Space=O(1)\\n    //counting no of 1 on border of current postion\\n    int helper(vector<vector<int>>& grid, int i, int j){\\n        int count=0;\\n        if(i!=0 and grid[i-1][j]==2) count++;\\n        if(j!=0 and grid[i][j-1]==2) count++;\\n        if(i<m-1 and grid[i+1][j]==2) count++;\\n        if(j<n-1 and grid[i][j+1]==2) count++;\\n        return count;\\n    }\\n    void dfs(vector<vector<int>>& grid, int i, int j){\\n        if(i<0 or j<0 or i>=m or j>=n or grid[i][j] != 1) return;\\n        grid[i][j]= 2;\\n        int count= helper(grid, i, j);\\n        res +=4;\\n        res -= (2*count); // res= res - (2 * no of shared edge)\\n        /*\\n        if(count==0) res += 4;  //o border: first element add 4\\n        else if(count==1) res+=2; //1 border: +2 (+4 -2 due to shared one edge)\\n        else if(count==3) res-=2; //3 border: -2(+4 -6 due to shared three edge)\\n        else if(count==4) res-=4; //4 border: -4 (+4 -8 due to shared four edge)\\n        cout<<i<<\" \"<<j<<\" \"<<count<<\" \"<<res<<endl;\\n        */\\n        dfs(grid, i, j+1);\\n        dfs(grid, i+1, j);\\n        dfs(grid, i-1, j);\\n        dfs(grid, i, j-1);\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        m= grid.size(), n= grid[0].size();\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                if(grid[i][j]==1){\\n                    dfs(grid, i, j);\\n                    break;\\n                }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "Please Upvote for motivation\\n```\\n    int m, n, res=0;\\n    //Time =O( m*n) and Space=O(1)\\n    //counting no of 1 on border of current postion\\n    int helper(vector<vector<int>>& grid, int i, int j){\\n        int count=0;\\n        if(i!=0 and grid[i-1][j]==2) count++;\\n        if(j!=0 and grid[i][j-1]==2) count++;\\n        if(i<m-1 and grid[i+1][j]==2) count++;\\n        if(j<n-1 and grid[i][j+1]==2) count++;\\n        return count;\\n    }\\n    void dfs(vector<vector<int>>& grid, int i, int j){\\n        if(i<0 or j<0 or i>=m or j>=n or grid[i][j] != 1) return;\\n        grid[i][j]= 2;\\n        int count= helper(grid, i, j);\\n        res +=4;\\n        res -= (2*count); // res= res - (2 * no of shared edge)\\n        /*\\n        if(count==0) res += 4;  //o border: first element add 4\\n        else if(count==1) res+=2; //1 border: +2 (+4 -2 due to shared one edge)\\n        else if(count==3) res-=2; //3 border: -2(+4 -6 due to shared three edge)\\n        else if(count==4) res-=4; //4 border: -4 (+4 -8 due to shared four edge)\\n        cout<<i<<\" \"<<j<<\" \"<<count<<\" \"<<res<<endl;\\n        */\\n        dfs(grid, i, j+1);\\n        dfs(grid, i+1, j);\\n        dfs(grid, i-1, j);\\n        dfs(grid, i, j-1);\\n    }\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        m= grid.size(), n= grid[0].size();\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                if(grid[i][j]==1){\\n                    dfs(grid, i, j);\\n                    break;\\n                }\\n        return res;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2202169,
                "title": "c-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int rows = grid.size(), cols = grid[0].size();\\n        set<pair<int,int>> visited;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 1) {\\n                    return dfshelper(grid, i, j, rows, cols, visited);\\n                }\\n            }\\n        }\\n        return -1; //Ideally code should not come here as long as there exists one island in the graph\\n    }\\n    \\n    //dfshelper returns perimeter of the whole island\\n    int dfshelper(vector<vector<int>>& grid, int x, int y, \\n                  int rows, int cols, set<pair<int,int>>& visited) {\\n        //when we out of bounds or a water cell, we can add a perimeter of length 1\\n        if (x < 0 || x == rows || y < 0 || y == cols || grid[x][y] == 0)\\n            return 1;\\n        if (visited.count({x,y})) //already visited\\n            return 0;\\n        \\n        //mark the node as visited\\n        visited.insert({x,y});\\n        return  dfshelper(grid, x+1, y, rows, cols, visited) + \\n                dfshelper(grid, x-1, y, rows, cols, visited) +\\n                dfshelper(grid, x, y+1, rows, cols, visited) + \\n                dfshelper(grid, x, y-1, rows, cols, visited);\\n    }\\n};\\n\\n//Time complexity: O(m*n) to go over all the cells of a grid constant # of times\\n//Space complexity: O(m*n) as the dfs call stack can go m*n levels deep when all the cells are 1\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int rows = grid.size(), cols = grid[0].size();\\n        set<pair<int,int>> visited;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 1) {\\n                    return dfshelper(grid, i, j, rows, cols, visited);\\n                }\\n            }\\n        }\\n        return -1; //Ideally code should not come here as long as there exists one island in the graph\\n    }\\n    \\n    //dfshelper returns perimeter of the whole island\\n    int dfshelper(vector<vector<int>>& grid, int x, int y, \\n                  int rows, int cols, set<pair<int,int>>& visited) {\\n        //when we out of bounds or a water cell, we can add a perimeter of length 1\\n        if (x < 0 || x == rows || y < 0 || y == cols || grid[x][y] == 0)\\n            return 1;\\n        if (visited.count({x,y})) //already visited\\n            return 0;\\n        \\n        //mark the node as visited\\n        visited.insert({x,y});\\n        return  dfshelper(grid, x+1, y, rows, cols, visited) + \\n                dfshelper(grid, x-1, y, rows, cols, visited) +\\n                dfshelper(grid, x, y+1, rows, cols, visited) + \\n                dfshelper(grid, x, y-1, rows, cols, visited);\\n    }\\n};\\n\\n//Time complexity: O(m*n) to go over all the cells of a grid constant # of times\\n//Space complexity: O(m*n) as the dfs call stack can go m*n levels deep when all the cells are 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188951,
                "title": "typescript-o-n2-o-i-space",
                "content": "```\\nfunction islandPerimeter(grid: number[][]): number {\\n    let [rows, cols] = [grid.length, grid[0].length];\\n    let perimeter = 0;\\n    for (let r = 0; r < rows; r +=1) {\\n        for (let c = 0; c < cols; c +=1) {\\n            if (grid[r][c] === 1) {\\n                perimeter +=4;\\n                if (r > 0 && grid[r - 1][c] === 1) perimeter -=2\\n                if (c > 0 && grid[r][c - 1] === 1) perimeter -=2\\n            }\\n        }\\n    }\\n    return perimeter\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction islandPerimeter(grid: number[][]): number {\\n    let [rows, cols] = [grid.length, grid[0].length];\\n    let perimeter = 0;\\n    for (let r = 0; r < rows; r +=1) {\\n        for (let c = 0; c < cols; c +=1) {\\n            if (grid[r][c] === 1) {\\n                perimeter +=4;\\n                if (r > 0 && grid[r - 1][c] === 1) perimeter -=2\\n                if (c > 0 && grid[r][c - 1] === 1) perimeter -=2\\n            }\\n        }\\n    }\\n    return perimeter\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2098087,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        int sum=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    sum+=4;    \\n                    if(i>=1 && grid[i-1][j]==1)\\n                        sum=sum-1;\\n                    if(i<m-1 && grid[i+1][j]==1)\\n                        sum=sum-1;\\n                    if(j>=1 && grid[i][j-1]==1)\\n                        sum=sum-1;\\n                    if(j<n-1 && grid[i][j+1]==1)\\n                        sum=sum-1;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        int sum=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    sum+=4;    \\n                    if(i>=1 && grid[i-1][j]==1)\\n                        sum=sum-1;\\n                    if(i<m-1 && grid[i+1][j]==1)\\n                        sum=sum-1;\\n                    if(j>=1 && grid[i][j-1]==1)\\n                        sum=sum-1;\\n                    if(j<n-1 && grid[i][j+1]==1)\\n                        sum=sum-1;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032809,
                "title": "c-easy-dfs-approach-solutions-with-time-complexity",
                "content": "DFS Approach\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int count=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    dfs(i,j,grid,count);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    void dfs(int i,int j,vector<vector<int>>& grid,int &count)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n\\t\\t// if i,j goes out of bound or adacent cell is water cell then\\n\\t\\t// there will be a perimeter wall, hence count++\\n        if(i<0 || j<0 || i>=n || j>=m || grid[i][j]==0)\\n        {   count++;\\n            return;}\\n        \\n\\t\\t// already visited\\n       else if(grid[i][j]==2)\\n           return ;\\n        \\n\\t\\t//  marking visited by assigning 2 to visited cell\\n        grid[i][j]=2;\\n        \\n\\t\\t// valid directions\\n        dfs(i+1,j,grid,count);\\n        dfs(i-1,j,grid,count);\\n        dfs(i,j+1,grid,count);\\n        dfs(i,j-1,grid,count);\\n    }\\n};\\n\\nTime Complexity: O(m*n)\\n```\\n\\nDO UPVOTE IF U FIND IT HELPFUL :)\\n\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int count=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    dfs(i,j,grid,count);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    void dfs(int i,int j,vector<vector<int>>& grid,int &count)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n\\t\\t// if i,j goes out of bound or adacent cell is water cell then\\n\\t\\t// there will be a perimeter wall, hence count++\\n        if(i<0 || j<0 || i>=n || j>=m || grid[i][j]==0)\\n        {   count++;\\n            return;}\\n        \\n\\t\\t// already visited\\n       else if(grid[i][j]==2)\\n           return ;\\n        \\n\\t\\t//  marking visited by assigning 2 to visited cell\\n        grid[i][j]=2;\\n        \\n\\t\\t// valid directions\\n        dfs(i+1,j,grid,count);\\n        dfs(i-1,j,grid,count);\\n        dfs(i,j+1,grid,count);\\n        dfs(i,j-1,grid,count);\\n    }\\n};\\n\\nTime Complexity: O(m*n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947299,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func islandPerimeter(_ grid: [[Int]]) -> Int {\\n        var islands = 0, neighbours = 0\\n\\n        for (i, row) in grid.enumerated() {\\n            for (j, column) in row.enumerated() {\\n                if (grid[i][j] == 1) {\\n                    islands += 1\\n                    if (i < grid.count - 1 && grid[i + 1][j] == 1) { neighbours += 1 }\\n                    if (j < grid[i].count - 1 && grid[i][j + 1] == 1) { neighbours += 1 }\\n                }\\n            }\\n        }\\n\\n        return islands * 4 - neighbours * 2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func islandPerimeter(_ grid: [[Int]]) -> Int {\\n        var islands = 0, neighbours = 0\\n\\n        for (i, row) in grid.enumerated() {\\n            for (j, column) in row.enumerated() {\\n                if (grid[i][j] == 1) {\\n                    islands += 1\\n                    if (i < grid.count - 1 && grid[i + 1][j] == 1) { neighbours += 1 }\\n                    if (j < grid[i].count - 1 && grid[i][j + 1] == 1) { neighbours += 1 }\\n                }\\n            }\\n        }\\n\\n        return islands * 4 - neighbours * 2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913468,
                "title": "java-iterative-beats-87",
                "content": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        if(grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n        int perimeter = 0;\\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[i].length;j++) {\\n                if(grid[i][j] == 1) {\\n                    perimeter += 4;\\n                    if(i>0 && grid[i-1][j] == 1) {\\n                        perimeter -= 2;\\n                    }\\n                    if(j>0 && grid[i][j-1] == 1) {\\n                        perimeter -= 2;\\n                    }\\n                }\\n            }\\n        }\\n        return perimeter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        if(grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n        int perimeter = 0;\\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[i].length;j++) {\\n                if(grid[i][j] == 1) {\\n                    perimeter += 4;\\n                    if(i>0 && grid[i-1][j] == 1) {\\n                        perimeter -= 2;\\n                    }\\n                    if(j>0 && grid[i][j-1] == 1) {\\n                        perimeter -= 2;\\n                    }\\n                }\\n            }\\n        }\\n        return perimeter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906525,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        \\n        \\n        def dfs(i,j):\\n            nonlocal res\\n            if (i,j) in visited:\\n                return\\n            if i<0 or j<0 or i>=m or j>=n or grid[i][j]==0:\\n                res+=1\\n                return\\n            visited.add((i,j))\\n            \\n            dfs(i-1,j)\\n            dfs(i+1,j)\\n            dfs(i,j-1)\\n            dfs(i,j+1)\\n            \\n        res=0\\n        m=len(grid)\\n        n=len(grid[0])\\n        visited=set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1:\\n                    dfs(i,j)\\n                    return res\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\\n        \\n        \\n        def dfs(i,j):\\n            nonlocal res\\n            if (i,j) in visited:\\n                return\\n            if i<0 or j<0 or i>=m or j>=n or grid[i][j]==0:\\n                res+=1\\n                return\\n            visited.add((i,j))\\n            \\n            dfs(i-1,j)\\n            dfs(i+1,j)\\n            dfs(i,j-1)\\n            dfs(i,j+1)\\n            \\n        res=0\\n        m=len(grid)\\n        n=len(grid[0])\\n        visited=set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1:\\n                    dfs(i,j)\\n                    return res\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893585,
                "title": "faster-than-97-c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> directions{{-1,0},{0,-1},{1,0},{0,1}};\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int answer=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                if(grid[i][j]==1){\\n                    answer+=getSides(grid,i,j);\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n    int getSides(vector<vector<int>> &grid,int i,int j){\\n        int count=0;\\n        for(int x=0;x<directions.size();x++){\\n            int newI=i+directions[x].first;\\n            int newJ=j+directions[x].second;\\n            if(newI<0 || newI>=grid.size() || newJ<0 || newJ>=grid[0].size() || grid[newI][newJ]==0)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> directions{{-1,0},{0,-1},{1,0},{0,1}};\\n    int islandPerimeter(vector<vector<int>>& grid) {\\n        int answer=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                if(grid[i][j]==1){\\n                    answer+=getSides(grid,i,j);\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n    int getSides(vector<vector<int>> &grid,int i,int j){\\n        int count=0;\\n        for(int x=0;x<directions.size();x++){\\n            int newI=i+directions[x].first;\\n            int newJ=j+directions[x].second;\\n            if(newI<0 || newI>=grid.size() || newJ<0 || newJ>=grid[0].size() || grid[newI][newJ]==0)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875608,
                "title": "island-perimeter-solution-java",
                "content": "class Solution {\\n  public int islandPerimeter(int[][] grid) {\\n    int islands = 0;\\n    int neighbors = 0;\\n\\n    for (int i = 0; i < grid.length; ++i)\\n      for (int j = 0; j < grid[0].length; ++j)\\n        if (grid[i][j] == 1) {\\n          ++islands;\\n          if (i - 1 >= 0 && grid[i - 1][j] == 1)\\n            ++neighbors;\\n          if (j - 1 >= 0 && grid[i][j - 1] == 1)\\n            ++neighbors;\\n        }\\n\\n    return islands * 4 - neighbors * 2;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "String",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n  public int islandPerimeter(int[][] grid) {\\n    int islands = 0;\\n    int neighbors = 0;\\n\\n    for (int i = 0; i < grid.length; ++i)\\n      for (int j = 0; j < grid[0].length; ++j)\\n        if (grid[i][j] == 1) {\\n          ++islands;\\n          if (i - 1 >= 0 && grid[i - 1][j] == 1)\\n            ++neighbors;\\n          if (j - 1 >= 0 && grid[i][j - 1] == 1)\\n            ++neighbors;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1726650,
                "title": "simple-java-solution-no-dfs",
                "content": "Just traverse the grid and if it is land see from how many sides it is connected to water and increment the count.\\nFinally return this count.\\n```\\n    public int islandPerimeter(int[][] grid) {\\n        int count = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    if(i-1 < 0 || grid[i-1][j] ==0)\\n                        count++;\\n                    if(i+1 >= m || grid[i+1][j] ==0)\\n                        count++; \\n                    if(j-1 < 0 || grid[i][j-1] ==0)\\n                        count++;\\n                    if(j+1 >= n || grid[i][j+1] ==0)\\n                        count++;                    \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int islandPerimeter(int[][] grid) {\\n        int count = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    if(i-1 < 0 || grid[i-1][j] ==0)\\n                        count++;\\n                    if(i+1 >= m || grid[i+1][j] ==0)\\n                        count++; \\n                    if(j-1 < 0 || grid[i][j-1] ==0)\\n                        count++;\\n                    if(j+1 >= n || grid[i][j+1] ==0)\\n                        count++;                    \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564990,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 1565308,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 1565270,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 1754106,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 1566684,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 1567015,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 1987221,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 2035380,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 2027325,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 2019540,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 1564990,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 1565308,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 1565270,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 1754106,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 1566684,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 1567015,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 1987221,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 2035380,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 2027325,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            },
            {
                "id": 2019540,
                "content": [
                    {
                        "username": "tekmark",
                        "content": "Why the tag is \"Hash Table\"? Is there a hash table solution?"
                    },
                    {
                        "username": "user2550e",
                        "content": "Not a good one but still beating 82.72%..\n\nvar islandPerimeter = function (grid) {\n  let result = 0;\n  let prevHashTable = {};\n  for (let i = 0; i < grid.length; i += 1) {\n    let prev = 0;\n    const currentHashTable = {};\n    for (let j = 0; j < grid[i].length; j += 1) {\n      if (grid[i][j]) {\n        if (prev) result -= 2;\n        if (prevHashTable[j]) result -= 2;\n        result += 4;\n        currentHashTable[j] = 1;\n        prev = 1;\n      } else prev = 0;\n    }\n    prevHashTable = currentHashTable;\n  }\n  return result;\n};"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "It would be interesting to find one."
                    },
                    {
                        "username": "poojaaa_r",
                        "content": "//Pls upvote if you agree with me \\n\\n\\nTwo islands are present here which makes the description incorrect \\n    [[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno if they updated it, but now that input is no longer valid, cause that  indeed has 2 islands"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@Hoaibao_21520628](/Hoaibao_21520628) True!"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "but in the description, it\\'s said that there is exactly one island"
                    },
                    {
                        "username": "mswlogo",
                        "content": "My code got the right answer (for multiple islands) which is the same code as solution 1.\\nBut this test case says expected as 8 but I get 14 and fails.\\nThe provided Java solution also gets 14 and fails.\\n\\n[[1],[1],[1],[0],[1],[1]]"
                    },
                    {
                        "username": "SanvuSarvesh",
                        "content": "If you\\'re finding any land then add 4 in your answer and also check wether (i-1,j) or (i,j-1) were land or not, if yes then subtract -2 for each. At the end print your answer."
                    },
                    {
                        "username": "mayank-01",
                        "content": "Thank you [@Sanvu Sarvesh](/sanvu08) for the idea :)"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Excellent idea! Thanks!"
                    },
                    {
                        "username": "rmcr714",
                        "content": "Dont understand but its said that there would be no water between islands, but this test case doesnt obey that property. I got it accepted by using some hack like an if else condition for this specific test case but i was lucky that i saw it quickly , what if somebody spends days to just work it out. This needs to be fixed"
                    },
                    {
                        "username": "alexeychik",
                        "content": "Please explain me, why related topic for this problem is Hash Table?\\nIs there better solution then O(N*M)?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "For beginners, don't be frustrated if you weren't able to solve it.\nI have solved 400+ problems, but it looks like a medium problem for me.\nHint: It's a DFS problem. If the next cell is out of boundary or water, then increase the perimeter by 1."
                    },
                    {
                        "username": "JosephHauter",
                        "content": "omg thank you so much ily this helped me solve it without looking at the answer"
                    },
                    {
                        "username": "Lax_27",
                        "content": "i passed 2422 testcases with this formula >> total number of ones *2    +2   . haha"
                    },
                    {
                        "username": "HazelDaniel",
                        "content": "how is this \"easy\"?"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "is this really easy?\\n"
                    }
                ]
            }
        ]
    }
]